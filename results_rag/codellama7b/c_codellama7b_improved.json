[
  {
    "id": 17,
    "pkg": "YPS-Instrument3",
    "fpath": "prj/CPDM04/Projects/3rd/awtk-widget-qr/src/qr/split.c",
    "input": "﻿/*\n * qrencode - QR Code encoder\n *\n * Input data splitter.\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * The following data / specifications are taken from\n * \"Two dimensional symbol -- QR-code -- Basic Specification\" (JIS X0510:2004)\n *  or\n * \"Automatic identification and data capture techniques --\n *  QR Code 2005 bar code symbology specification\" (ISO/IEC 18004:2006)\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n# include \"config.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include \"qrencode.h\"\n#include \"qrinput.h\"\n#include \"qrspec.h\"\n#include \"split.h\"\n\n#define isdigit(__c__) ((unsigned char)((signed char)(__c__) - '0') < 10)\n#define isalnum(__c__) (QRinput_lookAnTable(__c__) >= 0)\n\n#if !HAVE_STRDUP\n#undef strdup\nchar *strdup(const char *s)\n{\n\tsize_t len = strlen(s) + 1;\nvoid *newstring = ",
    "raw_res": "0;",
    "prompt_res": "malloc(len);",
    "gt": "malloc(len);"
  },
  {
    "id": 32,
    "pkg": "YPS-Instrument3",
    "fpath": "prj/CPDM04/Projects/3rd/awtk-widget-qr/src/qr/qrencode.c",
    "input": "﻿/*\n * qrencode - QR Code encoder\n *\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n# include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"qrencode.h\"\n#include \"qrspec.h\"\n#include \"mqrspec.h\"\n#include \"bitstream.h\"\n#include \"qrinput.h\"\n#include \"rsecc.h\"\n#include \"split.h\"\n#include \"mask.h\"\n#include \"mmask.h\"\n\n/******************************************************************************\n * Raw code\n *****************************************************************************/\n\ntypedef struct {\n\tint dataLength;\n\tint eccLength;\n\tunsigned char *data;\n\tunsigned char *ecc;\n} RSblock;\n\ntypedef struct {\n\tint version;\n\tint dataLength;\n\tint eccLength;\n\tunsigned char *datacode;\n\tunsigned char *ecccode;\n\tint b1;\n\tint blocks;\n\tRSblock *rsblock;\n\tint count;\n} QRRawCode;\n\nstatic void RSblock_initBlock(RSblock *block, int dl, unsigned char *data, int el, unsigned char *ecc)\n{\n\tblock->dataLength = dl;\n\tblock->data = data;\n\tblock->eccLength = el;\n\tblock->ecc = ecc;\n\n\tRSECC_encode((size_t)dl, (size_t)el, data, ecc);\n}\n\nstatic int RSblock_init(RSblock *blocks, int spec[5], unsigned char *data, unsigned char *ecc)\n{\n\tint i;\n\tRSblock *block;\n\tunsigned char *dp, *ep;\n\tint el, dl;\n\n\tdl = QRspec_rsDataCodes1(spec);\n\tel = QRspec_rsEccCodes1(spec);\n\n\tblock = blocks;\n\tdp = data;\n\tep = ecc;\n\tfor(i = 0; i < QRspec_rsBlockNum1(spec); i++) {\n\t\tRSblock_initBlock(block, dl, dp, el, ep);\n\t\tdp += dl;\n\t\tep += el;\n\t\tblock++;\n\t}\n\n\tif(QRspec_rsBlockNum2(spec) == 0) return 0;\n\n\tdl = QRspec_rsDataCodes2(spec);\n\tel = QRspec_rsEccCodes2(spec);\n\tfor(i = 0; i < QRspec_rsBlockNum2(spec); i++) {\n\t\tRSblock_initBlock(block, dl, dp, el, ep);\n\t\tdp += dl;\n\t\tep += el;\n\t\tblock++;\n\t}\n\n\treturn 0;\n}\n\nSTATIC_IN_RELEASE void QRraw_free(QRRawCode *raw);\nSTATIC_IN_RELEASE QRRawCode *QRraw_new(QRinput *input)\n{\n\tQRRawCode *raw;\n\tint spec[5], ret;\n\n\traw = (QRRawCode *)malloc(sizeof(QRRawCode));\n\tif(raw == NULL) return NULL;\n\n\traw->datacode = QRinput_getByteStream(input);\n\tif(raw->datacode == NULL) {\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\n\tQRspec_getEccSpec(input->version, input->level, spec);\n\n\traw->version = input->version;\n\traw->b1 = QRspec_rsBlockNum1(spec);\n\traw->dataLength = QRspec_rsDataLength(spec);\n\traw->eccLength = QRspec_rsEccLength(spec);\n\traw->ecccode = (unsigned char *)malloc((size_t)raw->eccLength);\n\tif(raw->ecccode == NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\n\traw->blocks = QRspec_rsBlockNum(spec);\n\traw->rsblock = (RSblock *)calloc((size_t)(raw->blocks), sizeof(RSblock));\n\tif(raw->rsblock == NULL) {\n\t\tQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\tret = RSblock_init(raw->rsblock, spec, raw->datacode, raw->ecccode);\n\tif(ret < 0) {\n\t\tQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\n\traw->count = 0;\n\n\treturn raw;\n}\n\n/**\n * Return a code (byte).\n * This function can be called iteratively.\n * @param raw raw code.\n * @return code\n */\nSTATIC_IN_RELEASE unsigned char QRraw_getCode(QRRawCode *raw)\n{\n\tint col, row;\n\tunsigned char ret;\n\n\tif(raw->count < raw->dataLength) {\n\t\trow = raw->count % raw->blocks;\n\t\tcol = raw->count / raw->blocks;\n\t\tif(col >= raw->rsblock[0].dataLength) {\n\t\t\trow += raw->b1;\n\t\t}\n\t\tret = raw->rsblock[row].data[col];\n\t} else if(raw->count < raw->dataLength + raw->eccLength) {\n\t\trow = (raw->count - raw->dataLength) % raw->blocks;\n\t\tcol = (raw->count - raw->dataLength) / raw->blocks;\n\t\tret = raw->rsblock[row].ecc[col];\n\t} else {\n\t\treturn 0;\n\t}\n\traw->count++;\n\treturn ret;\n}\n\nSTATIC_IN_RELEASE void QRraw_free(QRRawCode *raw)\n{\n\tif(raw != NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw->ecccode);\n\t\tfree(raw->rsblock);\n\t\tfree(raw);\n\t}\n}\n\n/******************************************************************************\n * Raw code for Micro QR Code\n *****************************************************************************/\n\ntypedef struct {\n\tint version;\n\tint dataLength;\n\tint eccLength;\n\tunsigned char *datacode;\n\tunsigned char *ecccode;\n\tRSblock *rsblock;\n\tint oddbits;\n\tint count;\n} MQRRawCode;\n\nSTATIC_IN_RELEASE void MQRraw_free(MQRRawCode *raw);\nSTATIC_IN_RELEASE MQRRawCode *MQRraw_new(QRinput *input)\n{\n\tMQRRawCode *raw;\n\n\traw = (MQRRawCode *)malloc(sizeof(MQRRawCode));\n\tif(raw == NULL) return NULL;\n\n\traw->version = input->version;\n\traw->dataLength = MQRspec_getDataLength(input->version, input->level);\n\traw->eccLength = MQRspec_getECCLength(input->version, input->level);\n\traw->oddbits = raw->dataLength * 8 - MQRspec_getDataLengthBit(input->version, input->level);\n\traw->datacode = QRinput_getByteStream(input);\n\tif(raw->datacode == NULL) {\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\traw->ecccode = (unsigned char *)malloc((size_t)raw->eccLength);\n\tif(raw->ecccode == NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\n\traw->rsblock = (RSblock *)calloc(1, sizeof(RSblock));\n\tif(raw->rsblock == NULL) {\n\t\tMQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\n\tRSblock_initBlock(raw->rsblock, raw->dataLength, raw->datacode, raw->eccLength, raw->ecccode);\n\n\traw->count = 0;\n\n\treturn raw;\n}\n\n/**\n * Return a code (byte).\n * This function can be called iteratively.\n * @param raw raw code.\n * @return code\n */\nSTATIC_IN_RELEASE unsigned char MQRraw_getCode(MQRRawCode *raw)\n{\n\tunsigned char ret;\n\n\tif(raw->count < raw->dataLength) {\n\t\tret = raw->datacode[raw->count];\n\t} else if(raw->count < raw->dataLength + raw->eccLength) {\n\t\tret = raw->ecccode[raw->count - raw->dataLength];\n\t} else {\n\t\treturn 0;\n\t}\n\traw->count++;\n\treturn ret;\n}\n\nSTATIC_IN_RELEASE void MQRraw_free(MQRRawCode *raw)\n{\n\tif(raw != NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw->ecccode);\n\t\tfree(raw->rsblock);\n\t\tfree(raw);\n\t}\n}\n\n\n/******************************************************************************\n * Frame filling\n *****************************************************************************/\n\ntypedef struct {\n\tint width;\n\tunsigned char *frame;\n\tint x, y;\n\tint dir;\n\tint bit;\n\tint mqr;\n} FrameFiller;\n\nstatic void FrameFiller_set(FrameFiller *filler, int width, unsigned char *frame, int mqr)\n{\n\tfiller->width = width;\n\tfiller->frame = frame;\n\tfiller->x = width - 1;\n\tfiller->y = width - 1;\n\tfiller->dir = -1;\n\tfiller->bit = -1;\n\tfiller->mqr = mqr;\n}\n\nstatic unsigned char *FrameFiller_next(FrameFiller *filler)\n{\n\tunsigned char *p;\n\tint x, y, w;\n\n\tif(filler->bit == -1) {\n\t\tfiller->bit = 0;\n\t\treturn filler->frame + filler->y * filler->width + filler->x;\n\t}\n\n\tx = filler->x;\n\ty = filler->y;\n\tp = filler->frame;\n\tw = filler->width;\n\n\tif(filler->bit == 0) {\n\t\tx--;\n\t\tfiller->bit++;\n\t} else {\n\t\tx++;\n\t\ty += filler->dir;\n\t\tfiller->bit--;\n\t}\n\n\tif(filler->dir < 0) {\n\t\tif(y < 0) {\n\t\t\ty = 0;\n\t\t\tx -= 2;\n\t\t\tfiller->dir = 1;\n\t\t\tif(!filler->mqr && x == 6) {\n\t\t\t\tx--;\n\t\t\t\ty = 9;\n\t\t\t}\n\t\t}\n\t} else if(y == w) {\n\t\ty = w - 1;\n\t\tx -= 2;\n\t\tfiller->dir = -1;\n\t\tif(!filler->mqr && x == 6) {\n\t\t\tx--;\n\t\t\ty -= 8;\n\t\t}\n\t}\n\tif(x < 0 || y < 0) return NULL;\n\n\tfiller->x = x;\n\tfiller->y = y;\n\n\tif(p[y * w + x] & 0x80) {\n\t\t// This tail recursion could be optimized.\n\t\treturn FrameFiller_next(filler);\n\t}\n\treturn &p[y * w + x];\n}\n\n#ifdef WITH_TESTS\nunsigned char *FrameFiller_test(int version)\n{\n\tint width;\n\tunsigned char *frame, *p;\n\tint i, length;\n\tFrameFiller filler;\n\n\twidth = QRspec_getWidth(version);\n\tframe = QRspec_newFrame(version);\n\tif(frame == NULL) return NULL;\n\tFrameFiller_set(&filler, width, frame, 0);\n\tlength = QRspec_getDataLength(version, QR_ECLEVEL_L) * 8\n\t       + QRspec_getECCLength(version, QR_ECLEVEL_L) * 8\n\t\t   + QRspec_getRemainder(version);\n\tfor(i = 0; i < length; i++) {\n\t\tp = FrameFiller_next(&filler);\n\t\tif(p == NULL) {\n\t\t\tfree(frame);\n\t\t\treturn NULL;\n\t\t}\n\t\t*p = (unsigned char)(i & 0x7f) | 0x80;\n\t}\n\treturn frame;\n}\n\nunsigned char *FrameFiller_testMQR(int version)\n{\n\tint width;\n\tunsigned char *frame, *p;\n\tint i, length;\n\tFrameFiller filler;\n\n\twidth = MQRspec_getWidth(version);\n\tframe = MQRspec_newFrame(version);\n\tif(frame == NULL) return NULL;\n\tFrameFiller_set(&filler, width, frame, 1);\n\tlength = MQRspec_getDataLengthBit(version, QR_ECLEVEL_L)\n\t       + MQRspec_getECCLength(version, QR_ECLEVEL_L) * 8;\n\tfor(i = 0; i < length; i++) {\n\t\tp = FrameFiller_next(&filler);\n\t\tif(p == NULL) {\n\t\t\tfprintf(stderr, \"Frame filler run over the frame!\\n\");\n\t\t\treturn frame;\n\t\t}\n\t\t*p = (unsigned char)(i & 0x7f) | 0x80;\n\t}\n\treturn frame;\n}\n#endif\n\n\n/******************************************************************************\n * QR-code encoding\n *****************************************************************************/\n\nSTATIC_IN_RELEASE QRcode *QRcode_new(int version, int width, unsigned char *data)\n{\n\tQRcode *qrcode;\n\n\tqrcode = (QRcode *)malloc(sizeof(QRcode));\n\tif(qrcode == NULL) return NULL;\n\n\tqrcode->version = version;\n\tqrcode->width = width;\n\tqrcode->data = data;\n\n\treturn qrcode;\n}\n\nvoid QRcode_free(QRcode *qrcode)\n{\n\tif(qrcode != NULL) {\n\t\tfree(qrcode->data);\n\t\tfree(qrcode);\n\t}\n}\n\nSTATIC_IN_RELEASE QRcode *QRcode_encodeMask(QRinput *input, int mask)\n{\n\tint width, version;\n\tQRRawCode *raw;\n\tunsigned char *frame, *masked, *p, code, bit;\n\tint i, j;\n\tQRcode *qrcode = NULL;\n\tFrameFiller filler;\n\n\tif(input->mqr) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(input->version < 0 || input->version > QRSPEC_VERSION_MAX) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(input->level > QR_ECLEVEL_H) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\nraw = ",
    "raw_res": "0;",
    "prompt_res": "QRraw_new(input);",
    "gt": "QRraw_new(input);"
  },
  {
    "id": 53,
    "pkg": "YPS-Instrument3",
    "fpath": "prj/CPDM04/Projects/3rd/awtk-widget-qr/src/qr/qrinput.c",
    "input": "﻿/*\n * qrencode - QR Code encoder\n *\n * Input data chunk class\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n# include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"qrencode.h\"\n#include \"qrspec.h\"\n#include \"mqrspec.h\"\n#include \"bitstream.h\"\n#include \"qrinput.h\"\n\n/******************************************************************************\n * Utilities\n *****************************************************************************/\nint QRinput_isSplittableMode(QRencodeMode mode)\n{\n\treturn (mode >= QR_MODE_NUM && mode <= QR_MODE_KANJI);\n}\n\n/******************************************************************************\n * Entry of input data\n *****************************************************************************/\n\nstatic QRinput_List *QRinput_List_newEntry(QRencodeMode mode, int size, const unsigned char *data)\n{\n\tQRinput_List *entry;\n\n\tif(QRinput_check(mode, size, data)) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tentry = (QRinput_List *)malloc(sizeof(QRinput_List));\n\tif(entry == NULL) return NULL;\n\n\tentry->mode = mode;\n\tentry->size = size;\n\tentry->data = NULL;\n\tif(size > 0) {\n\t\tentry->data = (unsigned char *)malloc((size_t)size);\n\t\tif(entry->data == NULL) {\n\t\t\tfree(entry);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemcpy(entry->data, data, (size_t)size);\n\t}\n\tentry->bstream = NULL;\n\tentry->next = NULL;\n\n\treturn entry;\n}\n\nstatic void QRinput_List_freeEntry(QRinput_List *entry)\n{\n\tif(entry != NULL) {\n\t\tfree(entry->data);\n\t\tBitStream_free(entry->bstream);\n\t\tfree(entry);\n\t}\n}\n\nstatic QRinput_List *QRinput_List_dup(QRinput_List *entry)\n{\n\tQRinput_List *n;\n\n\tn = (QRinput_List *)malloc(sizeof(QRinput_List));\n\tif(n == NULL) return NULL;\n\n\tn->mode = entry->mode;\n\tn->size = entry->size;\n\tn->data = (unsigned char *)malloc((size_t)n->size);\n\tif(n->data == NULL) {\n\t\tfree(n);\n\t\treturn NULL;\n\t}\n\tmemcpy(n->data, entry->data, (size_t)entry->size);\n\tn->bstream = NULL;\n\tn->next = NULL;\n\n\treturn n;\n}\n\n/******************************************************************************\n * Input Data\n *****************************************************************************/\n\nQRinput *QRinput_new(void)\n{\n\treturn QRinput_new2(0, QR_ECLEVEL_L);\n}\n\nQRinput *QRinput_new2(int version, QRecLevel level)\n{\n\tQRinput *input;\n\n\tif(version < 0 || version > QRSPEC_VERSION_MAX || level > QR_ECLEVEL_H) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tinput = (QRinput *)malloc(sizeof(QRinput));\n\tif(input == NULL) return NULL;\n\n\tinput->head = NULL;\n\tinput->tail = NULL;\n\tinput->version = version;\n\tinput->level = level;\n\tinput->mqr = 0;\n\tinput->fnc1 = 0;\n\n\treturn input;\n}\n\nQRinput *QRinput_newMQR(int version, QRecLevel level)\n{\n\tQRinput *input;\n\n\tif(version <= 0 || version > MQRSPEC_VERSION_MAX) goto INVALID;\n\tif((MQRspec_getECCLength(version, level) == 0)) goto INVALID;\n\n\tinput = QRinput_new2(version, level);\n\tif(input == NULL) return NULL;\n\n\tinput->mqr = 1;\n\n\treturn input;\n\nINVALID:\n\terrno = EINVAL;\n\treturn NULL;\n}\n\nint QRinput_getVersion(QRinput *input)\n{\n\treturn input->version;\n}\n\nint QRinput_setVersion(QRinput *input, int version)\n{\n\tif(input->mqr || version < 0 || version > QRSPEC_VERSION_MAX) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tinput->version = version;\n\n\treturn 0;\n}\n\nQRecLevel QRinput_getErrorCorrectionLevel(QRinput *input)\n{\n\treturn input->level;\n}\n\nint QRinput_setErrorCorrectionLevel(QRinput *input, QRecLevel level)\n{\n\tif(input->mqr || level > QR_ECLEVEL_H) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tinput->level = level;\n\n\treturn 0;\n}\n\nint QRinput_setVersionAndErrorCorrectionLevel(QRinput *input, int version, QRecLevel level)\n{\n\tif(input->mqr) {\n\t\tif(version <= 0 || version > MQRSPEC_VERSION_MAX) goto INVALID;\n\t\tif((MQRspec_getECCLength(version, level) == 0)) goto INVALID;\n\t} else {\n\t\tif(version < 0 || version > QRSPEC_VERSION_MAX) goto INVALID;\n\t\tif(level > QR_ECLEVEL_H) goto INVALID;\n\t}\n\n\tinput->version = version;\n\tinput->level = level;\n\n\treturn 0;\n\nINVALID:\n\terrno = EINVAL;\n\treturn -1;\n}\n\nstatic void QRinput_appendEntry(QRinput *input, QRinput_List *entry)\n{\n\tif(input->tail == NULL) {\n\t\tinput->head = entry;\n\t\tinput->tail = entry;\n\t} else {\n\t\tinput->tail->next = entry;\n\t\tinput->tail = entry;\n\t}\n\tentry->next = NULL;\n}\n\nint QRinput_append(QRinput *input, QRencodeMode mode, int size, const unsigned char *data)\n{\n\tQRinput_List *entry;\n\n\tentry = QRinput_List_newEntry(mode, size, data);\n\tif(entry == NULL) {\n\t\treturn -1;\n\t}\n\n\tQRinput_appendEntry(input, entry);\n\n\treturn 0;\n}\n\n/**\n * Insert a structured-append header to the head of the input data.\n * @param input input data.\n * @param size number of structured symbols.\n * @param number index number of the symbol. (1 <= number <= size)\n * @param parity parity among input data. (NOTE: each symbol of a set of structured symbols has the same parity data)\n * @retval 0 success.\n * @retval -1 error occurred and errno is set to indeicate the error. See Execptions for the details.\n * @throw EINVAL invalid parameter.\n * @throw ENOMEM unable to allocate memory.\n */\nSTATIC_IN_RELEASE int QRinput_insertStructuredAppendHeader(QRinput *input, int size, int number, unsigned char parity)\n{\n\tQRinput_List *entry;\n\tunsigned char buf[3];\n\n\tif(size > MAX_STRUCTURED_SYMBOLS) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tif(number <= 0 || number > size) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tbuf[0] = (unsigned char)size;\n\tbuf[1] = (unsigned char)number;\n\tbuf[2] = parity;\n\tentry = QRinput_List_newEntry(QR_MODE_STRUCTURE, 3, buf);\n\tif(entry == NULL) {\n\t\treturn -1;\n\t}\n\n\tentry->next = input->head;\n\tinput->head = entry;\n\n\treturn 0;\n}\n\nint QRinput_appendECIheader(QRinput *input, unsigned int ecinum)\n{\n\tunsigned char data[4];\n\n\tif(ecinum > 999999) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* We manually create byte array of ecinum because\n\t (unsigned char *)&ecinum may cause bus error on some architectures, */\n\tdata[0] = ecinum & 0xff;\n\tdata[1] = (ecinum >>  8) & 0xff;\n\tdata[2] = (ecinum >> 16) & 0xff;\n\tdata[3] = (ecinum >> 24) & 0xff;\n\treturn QRinput_append(input, QR_MODE_ECI, 4, data);\n}\n\nvoid QRinput_free(QRinput *input)\n{\n\tQRinput_List *list, *next;\n\n\tif(input != NULL) {\n\t\tlist = input->head;\n\t\twhile(list != NULL) {\n\t\t\tnext = list->next;\n\t\t\tQRinput_List_freeEntry(list);\n\t\t\tlist = next;\n\t\t}\n\t\tfree(input);\n\t}\n}\n\nstatic unsigned char QRinput_calcParity(QRinput *input)\n{\n\tunsigned char parity = 0;\n\tQRinput_List *list;\n\tint i;\n\n\tlist = input->head;\n\twhile(list != NULL) {\n\t\tif(list->mode != QR_MODE_STRUCTURE) {\n\t\t\tfor(i = list->size-1; i >= 0; i--) {\n\t\t\t\tparity ^= list->data[i];\n\t\t\t}\n\t\t}\n\t\tlist = list->next;\n\t}\n\n\treturn parity;\n}\n\nQRinput *QRinput_dup(QRinput *input)\n{\n\tQRinput *n;\n\tQRinput_List *list, *e;\n\n\tif(input->mqr) {\n\t\tn = QRinput_newMQR(input->version, input->level);\n\t} else {\nn = ",
    "raw_res": "n = QRinput_new2(input->version, input->level);",
    "prompt_res": "QRinput_new2(input->version, input->level);",
    "gt": "QRinput_new2(input->version, input->level);"
  },
  {
    "id": 119,
    "pkg": "YPS-Instrument3",
    "fpath": "prj/CPDM04/src/pages/carplay_mirror_page.c",
    "input": "#include <awtk.h>\n// #include \"yps_bll.h\"\n#include \"bllLog.h\"\n#include \"yps_bt.h\"\n#include \"yps_mcu.h\"\n#include \"yps_ec.h\"\n#include \"yps_bll.h\"\n#include \"yps_dataset.h\"\n#include \"yps_ui_types.h\"\n#include \"yps_page_base.h\"\n#include \"yps_app_status.h\"\n\n\nstatic widget_t* _win = NULL;\n\nstatic int _timer_id_show_bt_tip = TK_INVALID_ID;\n\nstatic int _bt_tip_counter = 0;\nstatic ret_t show_bt_tip(const timer_info_t* timer) {\n    if (_win == NULL) {\n        _bt_tip_counter = 0;\n        _timer_id_show_bt_tip = TK_INVALID_ID;\n        return RET_REMOVE;\n    }\n    if (_bt_tip_counter++ > 3) {\n        _bt_tip_counter = 0;\n        pop_view_bt_tip_handel(_win);\n        return RET_REMOVE;\n    }\n    return RET_REPEAT;\n}\n\n\nstatic void page_create_cb(widget_t* page) {\n    _win = page;\n}\n\nstatic void page_init_cb(void) {\n    if (yps_status_check_bt_tip()) {\n_timer_id_show_bt_tip = ",
    "raw_res": "tk_timer_create(show_bt_tip, 1000, 0);",
    "prompt_res": "widget_add_timer(_win, show_bt_tip, 1000);",
    "gt": "widget_add_timer(_win, show_bt_tip, 1000);"
  },
  {
    "id": 128,
    "pkg": "YPS-Instrument3",
    "fpath": "prj/CPDM04/src/pages/home_page.c",
    "input": "#include <awtk.h>\n#include <tkc/utils.h>\n#include <stdio.h>\n#include \"bllLog.h\"\n#include \"yps_page_base.h\"\n#include \"bllLog.h\"\n#include \"yps_bll.h\"\n#include \"yps_mcu.h\"\n#include \"yps_bt.h\"\n#include \"yps_dataset.h\"\n#include \"yps_inner.h\"\n#include \"yps_ui_types.h\"\n#include \"yps_theme_managr.h\"\n#include \"yps_view_manager.h\"\n#include \"yps_app_status.h\"\n#include \"yps_widget/carbit_irregular_maskimg.h\"\n#include \"yps_widget/yps_widget_label.h\"\n#include \"user_data/lang/lang_home_page.h\"\n#include \"pop_view/pop_view_hud.h\"\n\n\nstatic widget_t* _rpm_progress = NULL;\nstatic widget_t* _win = NULL;\nstatic int _trip_odo_type = 0;  // 0:odo 1:trip1 2:trip2\n\n\nret_t home_page(void);\n\n\n// 更新长度单位\nstatic void update_unit_length(int unit) {\n    widget_t* trip_odo_label = NULL;\n    trip_odo_label = widget_lookup(_win, \"switch_odo_trip\", true);\n\n    if (unit == YPS_LENGTH_UNIT_MILE) {\n        yps_widget_label_set_suffix_text(trip_odo_label, \"mile\");\n    }\n    else {\n        yps_widget_label_set_suffix_text(trip_odo_label, \"km\");\n    }\n}\n\n// ODO 和 TRIP 切换逻辑处理 type 0， 不切换显示直接刷新， 1， 切换显示\nstatic void change_trip_odo(int type) {\n    char buf[32] = { 0 };\n    widget_t* trip_odo_label = NULL;\n    trip_odo_label = widget_lookup(_win, \"switch_odo_trip\", true);\n    if (trip_odo_label == NULL) {\n        return;\n    }\n\n    if (type) {\n        if (++_trip_odo_type > 2) {\n            _trip_odo_type = 0;\n        }\n    }\n\n    int unit = yps_status_get_length_unit();\n    update_unit_length(unit);\n    float value = 0;\n    if (_trip_odo_type == 0) {  // 显示ODO\n        value = GET_INT(DI_MCU_ODO) / 10.0;\n        if (unit == YPS_LENGTH_UNIT_MILE) {\n            value = km_to_mile(value);\n        }\n        if (get_check_animation_status() == 0) {\n            value = 999999;\n        }\n        tk_snprintf(buf, sizeof(buf), \"%.0f\", value);\n        yps_widget_label_set_prefix_text(trip_odo_label, \"ODO\");\n    }\n    else if (_trip_odo_type == 1) {  // 显示trip1\n        value = GET_INT(DI_MCU_TRIP1) * 1.0 / 10.0;\n        if (unit == YPS_LENGTH_UNIT_MILE) {\n            value = km_to_mile(value);\n        }\n        tk_snprintf(buf, sizeof(buf), \"%.1f\", value);\n        yps_widget_label_set_prefix_text(trip_odo_label, \"TRIP1\");\n    }\n    else if (_trip_odo_type == 2) {  // 显示trip2\n        value = GET_INT(DI_MCU_TRIP2) * 1.0 / 10.0;\n        if (unit == YPS_LENGTH_UNIT_MILE) {\n            value = km_to_mile(value);\n        }\n        tk_snprintf(buf, sizeof(buf), \"%.1f\", value);\n        yps_widget_label_set_prefix_text(trip_odo_label, \"TRIP2\");\n    }\n    yps_widget_label_set_center_text(trip_odo_label, buf);\n    widget_invalidate(trip_odo_label, NULL);\n}\n\nstatic void page_create_cb(widget_t* page) {\n    _win = get_current_page();\n\n    // 配置转速控件的节点参数\n    _rpm_progress = widget_lookup(_win, \"prog_rpm\", TRUE);\n    // widget_set_prop_int(_rpm_progress, \"dirty_rect_threshold\", 3500);\n    widget_set_visible(_rpm_progress, TRUE);\n\n    yps_theme_t* theme_info = yps_theme_manager_get_current_theme_info();\n    carbit_irregular_maskimg_set_nodes(_rpm_progress, theme_info->rpm_node, theme_info->rpm_node_num, 10000);\n\n}\n\n\nstatic void page_init_cb(void) {\n    if (get_check_animation_status() == 0) {\nwidget_t* home_page_background = ",
    "raw_res": "widget_lookup(_win, \"home_page_background\", TRUE);",
    "prompt_res": "widget_lookup(_win, \"home_page_background\", true);",
    "gt": "widget_lookup(_win, \"home_page_background\", true);"
  },
  {
    "id": 134,
    "pkg": "YPS-Instrument3",
    "fpath": "prj/CPDM04/src/pages/super_mirror_page.c",
    "input": "#include <awtk.h>\n#include \"bllLog.h\"\n#include \"yps_mcu.h\"\n#include \"yps_ec.h\"\n#include \"yps_dataset.h\"\n#include \"yps_ui_types.h\"\n#include \"yps_page_base.h\"\n\n\nstatic widget_t* _win = NULL;\n\nstatic int _timer_id_show_bt_tip = TK_INVALID_ID;\n\nstatic int _bt_tip_counter = 0;\nstatic ret_t show_bt_tip(const timer_info_t* timer) {\n    if (_win == NULL) {\n        _bt_tip_counter = 0;\n        _timer_id_show_bt_tip = TK_INVALID_ID;\n        return RET_REMOVE;\n    }\n    if (_bt_tip_counter++ > 3) {\n        _bt_tip_counter = 0;\n        pop_view_bt_tip_handel(_win);\n        return RET_REMOVE;\n    }\n    return RET_REPEAT;\n}\n\n\nstatic void page_create_cb(widget_t* page) {\n    _win = page;\n}\n\nstatic void page_init_cb(void) {\n    if (yps_status_check_bt_tip()) {\n_timer_id_show_bt_tip = ",
    "raw_res": "tk_timer_create(show_bt_tip, 1000, 0);",
    "prompt_res": "widget_add_timer(_win, show_bt_tip, 1000);",
    "gt": "widget_add_timer(_win, show_bt_tip, 1000);"
  },
  {
    "id": 138,
    "pkg": "YPS-Instrument3",
    "fpath": "prj/CPDM04/src/pages/mirror_page.c",
    "input": "#include <awtk.h>\n#include \"bllLog.h\"\n#include \"yps_bt.h\"\n#include \"yps_mcu.h\"\n#include \"yps_ec.h\"\n#include \"yps_dataset.h\"\n#include \"yps_ui_types.h\"\n#include \"yps_page_base.h\"\n\n\nstatic widget_t* _win = NULL;\nstatic int _timer_id_show_bt_tip = TK_INVALID_ID;\n\nstatic int _bt_tip_counter = 0;\nstatic ret_t show_bt_tip(const timer_info_t* timer) {\n    if (_win == NULL) {\n        _timer_id_show_bt_tip = TK_INVALID_ID;\n        _bt_tip_counter = 0;\n        return RET_REMOVE;\n    }\n    if (_bt_tip_counter++ > 3) {\n        _bt_tip_counter = 0;\n        pop_view_bt_tip_handel(_win);\n        return RET_REMOVE;\n    }\n    return RET_REPEAT;\n}\n\nstatic void page_create_cb(widget_t* page) {\n    _win = page;\n}\n\nstatic void page_init_cb(void) {\n    if (yps_status_check_bt_tip()) {\n_timer_id_show_bt_tip = ",
    "raw_res": "tk_timer_create(show_bt_tip, 1000, 0);",
    "prompt_res": "widget_add_timer(_win, show_bt_tip, 1000);",
    "gt": "widget_add_timer(_win, show_bt_tip, 1000);"
  },
  {
    "id": 197,
    "pkg": "YPS-Instrument3",
    "fpath": "prj/CPDM04/src/pages/menu_view/menu_setting_brightness.c",
    "input": "#include \"menu_setting_brightness.h\"\n#include \"yps_view_base.h\"\n#include \"yps_mcu.h\"\n#include \"yps_bt.h\"\n#include \"yps_dataset.h\"\n#include \"yps_app_status.h\"\n#include \"bllLog.h\"\n#include \"user_data/lang/lang_menu_setting_brightness.h\"\n\nstatic widget_t* _brightness_view = NULL;\nstatic widget_t* _auto_btn = NULL;\nstatic widget_t* _prg_brightness = NULL;\nstatic widget_t* _brightness_ico1 = NULL;\nstatic widget_t* _brightness_ico2 = NULL;\nstatic widget_t* _item2 = NULL;\nstatic widget_t* _label_2 = NULL;\nstatic widget_t* _label_3 = NULL;\n\nwidget_animator_t* _anim_expand;\nwidget_animator_t* _anim_fold;\n\nstatic yps_view_item_focus_map_t _focus_map_list[ ] = {\n    // {\"item1\", \"\"},\n};\n\n//当前view焦点顺序配置\nstatic yps_view_focus_t _menu_setting_brightness_view_focus = {\n    .pre_view_name = \"menu_setting_view\",    //menu_tab_view 没有上级页面，点击返回之后直接回到主页面\n    .focus_map_list = _focus_map_list,\n    .focus_map_num = sizeof(_focus_map_list) / sizeof(yps_view_item_focus_map_t),\n    .focus_id = -1,\n    .default_focus_id = 0,\n};\n\n\nstatic yps_lang_list_t _menu_brightness_view_lang_list = {\n    .list = menu_setting_brightness_list,\n    .count = sizeof(menu_setting_brightness_list) / sizeof(yps_lang_t),\n    .lang_update_cb = yps_view_lang_update_cb,\n};\n\n//view数据回调函数定义，用于自定义数据更新\nYPS_VIEW_DATA_MODEL_CB(menu_setting_brightness) {\n    return value;\n}\n\n//view数据模型定义，用于view内子控件和数据绑定\n// static yps_view_data_model_t _menu_setting_brightness_data_model[ ] = {\n// };\n\nstatic ret_t anim_expand_done(void* ctx, event_t* e) {\n    widget_set_prop_int(_brightness_view, \"h\", 240);\n    widget_set_visible(_item2, true);\n    return RET_OK;\n}\n\nstatic ret_t anim_fold_done(void* ctx, event_t* e) {\n    widget_set_prop_int(_brightness_view, \"h\", 70);\n    return RET_OK;\n}\n\n\nstatic int _brightness_value = 0;\nstatic void brightness_label_update() {\n    char brightness_str_value[32] = { 0 };\n    sprintf(brightness_str_value, \"%d%%\", (_brightness_value + 1) * 20);\n    widget_set_text_utf8(_label_3, brightness_str_value);\n}\n\nstatic void update_brightness_view() {\n    // printf(\"%s:%d 背光模式：%d\\n\", __FILE__, __LINE__,GET_INT(DI_MCU_BRIGHTNESS_MODE));\n    if (GET_INT(DI_MCU_BRIGHTNESS_MODE) == 0) {\n        image_value_set_value(_auto_btn, 1);\n        image_value_set_value(_brightness_ico1, 1);\n        image_value_set_value(_brightness_ico2, 1);\n        \n        widget_set_visible(_prg_brightness, false);\n        widget_set_visible(_label_2, false);\n        widget_set_visible(_label_3, false);\n        // widget_set_visible(_item2, false);\n        // widget_start_animator(_brightness_view, \"fold\");\n    }\n    else {\n        _brightness_value = GET_INT(DI_MCU_BRIGHTNESS_LEVEL);\n        image_value_set_value(_auto_btn, 0);\n        image_value_set_value(_brightness_ico1, 0);\n        image_value_set_value(_brightness_ico2, 0);\n        image_value_set_value(_prg_brightness, _brightness_value);\n        widget_set_visible(_prg_brightness, true);\n        widget_set_visible(_label_2, true);\n        widget_set_visible(_label_3, true);\n        // widget_set_visible(_item2, true);\n        // widget_start_animator(_brightness_view, \"expand\");\n    }\n    brightness_label_update();\n}\n\nstatic void brightness_view_change() {\n    if (GET_INT(DI_MCU_BRIGHTNESS_MODE) == 1) {//自动调节亮度\n        yps_bll_mcu_exec_command(YPS_COMMAND_MCU_SET_BACK_BRIGHTING, 0, _brightness_value);\n    }\n    else {\n        _brightness_value = GET_INT(DI_MCU_BRIGHTNESS_LEVEL);\n        yps_bll_mcu_exec_command(YPS_COMMAND_MCU_SET_BACK_BRIGHTING, 1, _brightness_value);\n    }\n    update_brightness_view();\n}\n\n\nstatic void brightness_progress_update() {\n    yps_bll_mcu_exec_command(YPS_COMMAND_MCU_SET_BACK_BRIGHTING, 1, _brightness_value);\n    image_value_set_value(_prg_brightness, _brightness_value);\n    brightness_label_update();\n}\n\n//view事件回调函数定义，感兴趣的事件可以在这里处理\nYPS_VIEW_EVENT_CB(menu_setting_brightness) {\n    yps_view_t* view_obj = (yps_view_t*)view;\n    if (event_type == YPS_VIEW_EVENT_SHOW) {\n        // widget_create_animator(_brightness_view, \"h(name=expand,duration=100,easing=linear,auto_start=false,auto_destroy=false,from=70,to=240)\");\n        // widget_create_animator(_brightness_view, \"h(name=fold,duration=100,easing=linear,auto_start=false,auto_destroy=false,from=240,to=70)\");\n        // _anim_expand = widget_find_animator(_brightness_view, \"expand\");\n        // _anim_fold = widget_find_animator(_brightness_view, \"fold\");\n        // widget_animator_on(_anim_expand, EVT_ANIM_END, anim_expand_done, NULL);\n        // widget_animator_on(_anim_fold, EVT_ANIM_END, anim_fold_done, NULL);\n        update_brightness_view();\n    }\n    else if (event_type == YPS_VIEW_EVENT_HIDE) {\n        // widget_destroy_animator(_brightness_view, \"expand\");\n        // widget_destroy_animator(_brightness_view, \"fold\");\n    }\n    else if (event_type == YPS_VIEW_EVENT_CLICK) {\n        if (click_type == YPS_CLICK_OK) {\n            brightness_view_change();\n            return false;\n        }\n        else if (click_type == YPS_CLICK_BACK) {\n\n        }\n        else if (click_type == YPS_CLICK_UP) {\n            // printf(\"%s:%d 背光模式：%d\\n\", __FILE__, __LINE__,GET_INT(DI_MCU_BRIGHTNESS_MODE));\n            if (GET_INT(DI_MCU_BRIGHTNESS_MODE)) {\n                _brightness_value = GET_INT(DI_MCU_BRIGHTNESS_LEVEL);\n                if (++_brightness_value > 4) {\n                    _brightness_value = 4;\n                };\n                brightness_progress_update();\n            }\n            return false;\n        }\n        else if (click_type == YPS_CLICK_DOWN) {\n            // printf(\"%s:%d 背光模式：%d\\n\", __FILE__, __LINE__,GET_INT(DI_MCU_BRIGHTNESS_MODE));\n            if (GET_INT(DI_MCU_BRIGHTNESS_MODE)) {\n                _brightness_value = GET_INT(DI_MCU_BRIGHTNESS_LEVEL);\n                if (--_brightness_value < 0) {\n                    _brightness_value = 0;\n                }\n                brightness_progress_update();\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\n\nvoid menu_setting_brightness_open(widget_t* parent) {\n    // int data_model_size = sizeof(_menu_setting_brightness_data_model) / sizeof(yps_view_data_model_t);\n    int data_model_size = 0;\n    yps_view_conf_t view_conf = {\n    .xml_name = \"menu_view/setting_brightness\",\n    .view_type = YPS_VIEW_TYPE_MENU,\n    .lang_list = &_menu_brightness_view_lang_list,\n    .data_model = NULL,\n    .data_model_num = 0,\n    .focus = _menu_setting_brightness_view_focus,\n    .view_cb = YPS_VIEW_EVENT_CB_NAME(menu_setting_brightness),\n    };\n    yps_view_t* obj =  yps_view_create_ex(parent, \"setting_brightness_view\", &view_conf);\n    \n_brightness_view = ",
    "raw_res": "widget_get_child_by_name(obj->view, \"brightness_view\");",
    "prompt_res": "widget_lookup(obj->view, \"brightness_view\", true);",
    "gt": "widget_lookup(obj->view, \"brightness_view\", true);"
  },
  {
    "id": 212,
    "pkg": "YPS-Instrument3",
    "fpath": "src/framework/yps_page_base.c",
    "input": "#include \"yps_page_base.h\"\n// #include <sys/mman.h>\n// #include <tkc/mem.h>\n#include <unistd.h>\n#include <stdio.h>\n#include \"bllLog.h\"\n#include \"yps_ui_types.h\"\n#include \"bllLog.h\"\n#include \"yps_dataset.h\"\n#include \"yps_bll.h\"\n#include \"yps_mcu.h\"\n#include \"yps_ec.h\"\n#include \"yps_app_status.h\"\n#include \"yps_view_manager.h\"\n#include \"yps_theme_managr.h\"\n#include \"awtk_widget_common.h\"\n\n#define UI_SPEED_HIGH 20\n#define UI_SPEED_LOW 100\n#define UI_SPEED_LOW_RATIO 3\n\n\nstatic widget_t* _page_current;\nwidget_t* get_current_page() {\n    return _page_current;\n}\n\nstatic int _first_start_check_ok = 0;  //开机自检动画完成状态\nint get_check_animation_status() {\n    return _first_start_check_ok;\n}\n\n//自检动画播放完成通知\nret_t on_check_self_anim_event(void* ctx, event_t* e) {\n    _first_start_check_ok = 1;\n    //通知bll自检动画播放完成\n    yps_bll_mcu_exec_command(YPS_COMMAND_MCU_SELF_CHECK_OVER, 1, 0);\n    page_guimsg_handler(YPS_VIEW_EVENT_CHECK_SELF_DONE, YPS_CLICK_NONE, 0);\n\n    yps_app_loop_start();\n    return RET_OK;\n}\n\n\nstatic yps_page_config_p _page_config;\nstatic uint32_t _timer_ui_looping;\nstatic int16_t _timer_ui_low_ratio;\nstatic bool _window_opened = false;     //标识窗口是否时打开状况，判断是否接收外部事件进行处理\nint get_page_code() {\n    if (_page_config)\n        return _page_config->code;\n    return YPS_PAGE_NONE;\n}\n\nbool is_window_opened() {\n    return _window_opened;\n}\n\nstatic rect_t _page_canvas_rect = { 0, 0, YPS_MAX_SCREEN_WIDTH, YPS_MAX_SCREEN_HEIGHT };\nstatic ret_t mirror_page_clear_canvas(const idle_info_t* idle) {\n    native_window_t* native_window = (native_window_t*)widget_get_prop_pointer(window_manager(), WIDGET_PROP_NATIVE_WINDOW);\ncanvas_t* cavans = ",
    "raw_res": "0;",
    "prompt_res": "native_window_get_canvas(native_window);",
    "gt": "native_window_get_canvas(native_window);"
  },
  {
    "id": 270,
    "pkg": "YPS-Instrument3",
    "fpath": "src/framework/yps_lang_base.c",
    "input": "#include <stdio.h>\n#include \"yps_lang_base.h\"\n#include \"yps_type.h\"\n#include \"yps_app_status.h\"\n#include \"bllLog.h\"\n\nvoid yps_update_lang_text(widget_t* base_widget, yps_lang_list_t* lang_list) {\n    if (base_widget == NULL || lang_list == NULL) return;\n    yps_bll_lang_id_t lang_id = yps_status_get_lang_id();\n    for (int i = 0; i < lang_list->count; i++) {\n        yps_lang_t lang = lang_list->list[i];\nwidget_t* widget = ",
    "raw_res": "0;",
    "prompt_res": "widget_lookup(base_widget, lang.widget_name, true);",
    "gt": "widget_lookup(base_widget, lang.widget_name, true);"
  },
  {
    "id": 274,
    "pkg": "YPS-Instrument3",
    "fpath": "src/framework/awtk_widget_common.c",
    "input": "#include <stdio.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include \"awtk.h\"\n#include \"awtk_widget_common.h\"\n#include \"yps_bll.h\"\n#include \"yps_dataset.h\"\n#include \"bllLog.h\"\n\n\nbool is_valid_widget(widget_t *obj){\n    if (!tk_is_ui_thread())\n    {\n        LOGAPPE(\" must in tk ui thread!!!\");\n        return false;\n    }\n    return true;\n}\n\n\nwidget_t* find_widget(widget_t* win, const char* widget_name) {\n    return widget_lookup(win, widget_name, true);\n}\n\nwidget_t* find_widget_auto(widget_t* win, const char** widget_names ,int dept) {\n    widget_t* widget = NULL;\n    // int dept = sizeof(widget_names) / sizeof(widget_names[0]);\n    for (int i = 0; i < dept; i++) {\n        widget = widget_lookup(win, widget_names[i], true);\n        if (widget == NULL) {\n            break;\n        }\n    }\n    return widget;\n}\n\n\nret_t set_visible_by_name(widget_t* win, const char* name, bool flag) {\n    return widget_set_visible(find_widget(win, name), flag);\n}\n\nret_t hide_widget(widget_t* widget) {\n    if (widget == NULL) {\n        return RET_FAIL;\n    }\n    return widget_set_visible(widget, false);\n}\n\nret_t show_widget(widget_t* widget) {\n    if (widget == NULL) {\n        return RET_FAIL;\n    }\n    return widget_set_visible(widget, true);\n}\n\nret_t set_image(widget_t* widget, const char* image_name) {\n    if (!widget) {\n        printf(\"\\n!!set_image Control not found!!\\n\");\n        return  RET_FAIL;\n    }\n    const char* old_img = widget_get_prop_str(widget, WIDGET_PROP_IMAGE, NULL);\n\n    if (old_img && image_name && strcmp(old_img, image_name) != 0) {\n        image_set_image(widget, image_name);\n    }\n    else if (image_name == NULL || old_img == NULL) {\n        image_set_image(widget, image_name);\n    }\n    return RET_OK;\n}\n\nret_t set_text(widget_t* widget, const char* text) {\n    if (!widget) {\n        printf(\"\\n!!set_text Control not found!!\\n\");\n        return  RET_FAIL;\n    }\n    widget_set_text_utf8(widget, text);\n    return RET_OK;\n}\n\nret_t set_text_fmt(widget_t* widget, const char* fmt, ...) {\n    char buff[256] = { 0 };\n    va_list args;\n    va_start(args, fmt);\n    vsnprintf(buff, sizeof(buff), fmt, args);\n    va_end(args);\n    if (is_valid_widget(widget) && widget) {\n        set_text(widget, buff);\n    }\n    return RET_OK;\n}\n\nret_t set_text_by_name(widget_t* win, const char* name, const char* text) {\n    return set_text(find_widget(win, name), text);\n}\n\nint get_string_font_width(char *utf8_str, const char *font_name, int font_size)\n{\n    font_manager_t *fm = font_manager();\n    if (fm == NULL)\n    {\n        return -1;\n    }\n\n    glyph_t glyph;\nfont_t *p_font = ",
    "raw_res": "0;",
    "prompt_res": "font_manager_get_font(fm, font_name, font_size);",
    "gt": "font_manager_get_font(fm, font_name, font_size);"
  },
  {
    "id": 357,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/widgets/button.c",
    "input": "﻿/**\n * File:   button.h\n * Author: AWTK Develop Team\n * Brief:  button\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-28 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"base/timer.h\"\n#include \"tkc/utils.h\"\n#include \"widgets/button.h\"\n#include \"base/widget_vtable.h\"\n\nstatic ret_t button_remove_timer(widget_t* widget) {\n  button_t* button = BUTTON(widget);\n  return_value_if_fail(button != NULL, RET_REMOVE);\n\n  if (button->timer_id != TK_INVALID_ID) {\n    timer_remove(button->timer_id);\n    button->timer_id = TK_INVALID_ID;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t button_on_repeat(const timer_info_t* info) {\n  pointer_event_t evt;\n  button_t* button = NULL;\n  widget_t* widget = NULL;\n  return_value_if_fail(info != NULL, RET_REMOVE);\n\n  button = BUTTON(info->ctx);\n  widget = WIDGET(info->ctx);\n  return_value_if_fail(button != NULL && widget != NULL, RET_REMOVE);\n\n  evt.x = 0;\n  evt.y = 0;\n  evt.e = event_init(EVT_CLICK, widget);\n  evt.e.size = sizeof(pointer_event_t);\n\n  button->repeat_nr++;\n  widget_dispatch(widget, (event_t*)&evt);\n\n  return RET_REPEAT;\n}\n\nstatic ret_t button_pointer_up_cleanup_impl(widget_t* widget, bool_t ungrab) {\n  button_t* button = BUTTON(widget);\n  return_value_if_fail(button != NULL && widget != NULL, RET_BAD_PARAMS);\n\n  button->pressed = FALSE;\n  button_remove_timer(widget);\n  if (ungrab) {\n    widget_ungrab(widget->parent, widget);\n  }\n  widget_set_state(widget, WIDGET_STATE_NORMAL);\n\n  return RET_OK;\n}\n\nstatic ret_t button_pointer_up_cleanup(widget_t* widget) {\n  return button_pointer_up_cleanup_impl(widget, TRUE);\n}\n\nstatic ret_t button_on_long_press(const timer_info_t* info) {\n  pointer_event_t evt;\n  widget_t* widget = WIDGET(info->ctx);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  button_pointer_up_cleanup_impl(widget, FALSE);\n  widget_dispatch(widget, pointer_event_init(&evt, EVT_LONG_PRESS, widget, 1, 1));\n\n  return RET_REMOVE;\n}\n\nstatic ret_t button_on_event(widget_t* widget, event_t* e) {\n  uint16_t type = e->type;\n  button_t* button = BUTTON(widget);\n  return_value_if_fail(button != NULL && widget != NULL, RET_BAD_PARAMS);\n\n  switch (type) {\n    case EVT_POINTER_DOWN: {\n      button->repeat_nr = 0;\n      button->pressed = TRUE;\n      widget_set_state(widget, WIDGET_STATE_PRESSED);\n      button_remove_timer(widget);\n      if (button->repeat > 0) {\nbutton->timer_id = ",
    "raw_res": "timer_add(button->repeat, button_on_repeat, widget);",
    "prompt_res": "timer_add(button_on_repeat, widget, button->repeat);",
    "gt": "timer_add(button_on_repeat, widget, button->repeat);"
  },
  {
    "id": 445,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/widgets/combo_box.c",
    "input": "﻿/**\n * File:   combo_box.h\n * Author: AWTK Develop Team\n * Brief:  combo_box\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-07-25 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"base/layout.h\"\n#include \"base/window.h\"\n#include \"widgets/button.h\"\n#include \"widgets/popup.h\"\n#include \"widgets/combo_box.h\"\n#include \"tkc/tokenizer.h\"\n#include \"widgets/combo_box_item.h\"\n\n#define COMBO_BOX_DEFAULT_MARGIN 1\n\nstatic ret_t combo_box_on_button_click(void* ctx, event_t* e);\nstatic ret_t combo_box_sync_index_to_value(widget_t* widget, uint32_t index, bool_t only_set);\n\nconst char* const s_combo_box_properties[] = {WIDGET_PROP_MIN,\n                                              WIDGET_PROP_MAX,\n                                              WIDGET_PROP_STEP,\n                                              WIDGET_PROP_INPUT_TYPE,\n                                              WIDGET_PROP_READONLY,\n                                              WIDGET_PROP_AUTO_FIX,\n                                              WIDGET_PROP_MARGIN,\n                                              WIDGET_PROP_LEFT_MARGIN,\n                                              WIDGET_PROP_RIGHT_MARGIN,\n                                              WIDGET_PROP_TOP_MARGIN,\n                                              WIDGET_PROP_BOTTOM_MARGIN,\n                                              WIDGET_PROP_TIPS,\n                                              WIDGET_PROP_OPTIONS,\n                                              WIDGET_PROP_ITEM_HEIGHT,\n                                              WIDGET_PROP_OPEN_WINDOW,\n                                              WIDGET_PROP_SELECTED_INDEX,\n                                              WIDGET_PROP_LOCALIZE_OPTIONS,\n                                              NULL};\n\nstatic ret_t combo_box_active(widget_t* widget);\nstatic ret_t combo_box_add_selected_index(widget_t* widget, int32_t delta);\nstatic widget_t* combo_box_create_self(widget_t* parent, xy_t x, xy_t y, wh_t w, wh_t h);\nstatic ret_t combo_box_set_selected_index_ex(widget_t* widget, uint32_t index, widget_t* item);\n\nstatic ret_t combo_box_on_copy(widget_t* widget, widget_t* other) {\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  combo_box_t* combo_box_other = COMBO_BOX(other);\n  return_value_if_fail(combo_box != NULL && combo_box_other != NULL, RET_BAD_PARAMS);\n\n  edit_on_copy(widget, other);\n\n  combo_box->item_height = combo_box_other->item_height;\n  combo_box->selected_index = combo_box_other->selected_index;\n  combo_box->localize_options = combo_box_other->localize_options;\n\n  if (combo_box_other->options != NULL) {\n    combo_box_set_options(widget, combo_box_other->options);\n  }\n\n  if (combo_box_other->open_window != NULL) {\n    combo_box->open_window = tk_str_copy(combo_box->open_window, combo_box_other->open_window);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t combo_box_on_destroy(widget_t* widget) {\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  return_value_if_fail(widget != NULL && combo_box != NULL, RET_BAD_PARAMS);\n\n  str_reset(&(combo_box->text));\n  combo_box_reset_options(widget);\n  TKMEM_FREE(combo_box->open_window);\n\n  edit_on_destroy(widget);\n\n  if (combo_box->combobox_popup != NULL) {\n    widget_destroy(combo_box->combobox_popup);\n  }\n\n  return RET_OK;\n}\n\n#define WIDGET_NAME_VALUE \"value\"\n\nstatic uint32_t combo_box_get_curr_text_size(widget_t* widget) {\n  return_value_if_fail(widget != NULL, 0);\n  widget_t* value_widget = widget_lookup(widget, WIDGET_NAME_VALUE, TRUE);\n\n  if (value_widget == NULL) {\n    value_widget = widget;\n  }\n\n  return value_widget->text.size;\n}\n\nstatic ret_t combo_box_update_status(widget_t* widget) {\n  edit_t* edit = EDIT(widget);\n  if (combo_box_get_curr_text_size(widget) == 0) {\n    if (widget->focused) {\n      widget_set_state(widget, WIDGET_STATE_EMPTY_FOCUS);\n    } else {\n      widget_set_state(widget, WIDGET_STATE_EMPTY);\n    }\n  } else {\n    if (edit != NULL && edit->cancelable) {\n      if (!widget->loading) {\n        if (!wstr_equal(&(edit->saved_text), &(widget->text))) {\n          widget_set_state(widget, WIDGET_STATE_CHANGED);\n          return RET_OK;\n        }\n      }\n    }\n\n    if (widget->focused) {\n      widget_set_state(widget, WIDGET_STATE_FOCUSED);\n    } else {\n      widget_set_state(widget, WIDGET_STATE_NORMAL);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t combo_box_set_text_only(widget_t* widget, const char* text, const wchar_t* wtext,\n                                     bool_t tr) {\n  widget_t* value_widget = widget_lookup(widget, WIDGET_NAME_VALUE, TRUE);\n\n  if (value_widget == NULL) {\n    value_widget = widget;\n  } else {\n    TKMEM_FREE(widget->tr_text);\n    wstr_clear(&(widget->text));\n    combo_box_update_status(value_widget);\n  }\n\n  if (tr) {\n    widget_t* win = widget_get_window(value_widget);\n    if (win != NULL) {\n      text = locale_info_tr(widget_get_locale_info(widget), text);\n    }\n    wstr_set_utf8(&(value_widget->text), text);\n  } else {\n    if (wtext != NULL) {\n      wstr_set(&(value_widget->text), wtext);\n    } else {\n      wstr_set_utf8(&(value_widget->text), text);\n    }\n  }\n  combo_box_update_status(value_widget);\n  return RET_OK;\n}\n\nstatic ret_t combo_box_set_text(widget_t* widget, const char* text, const wchar_t* wtext,\n                                bool_t tr) {\n  widget_t* value_widget = widget_lookup(widget, WIDGET_NAME_VALUE, TRUE);\n\n  if (value_widget == NULL) {\n    value_widget = widget;\n  } else {\n    TKMEM_FREE(widget->tr_text);\n    widget_set_text(widget, L\"\");\n  }\n\n  if (tr) {\n    widget_set_tr_text(value_widget, text);\n  } else {\n    if (wtext != NULL) {\n      widget_set_text(value_widget, wtext);\n    } else {\n      widget_set_text_utf8(value_widget, text);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t combo_box_get_prop(widget_t* widget, const char* name, value_t* v) {\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  return_value_if_fail(widget != NULL && combo_box != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_OPEN_WINDOW)) {\n    value_set_str(v, combo_box->open_window);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_SELECTED_INDEX)) {\n    value_set_int(v, combo_box->selected_index);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_VALUE)) {\n    value_set_int(v, combo_box->value);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_LOCALIZE_OPTIONS)) {\n    value_set_bool(v, combo_box->localize_options);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_OPTIONS)) {\n    value_set_str(v, combo_box->options);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_ITEM_HEIGHT)) {\n    value_set_int(v, combo_box->item_height);\n    return RET_OK;\n  } else {\n    return edit_get_prop(widget, name, v);\n  }\n}\n\nret_t combo_box_parse_options(widget_t* widget, const char* str) {\n  int32_t i = 0;\n  tokenizer_t tokenizer;\n  tokenizer_t* t = &tokenizer;\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  return_value_if_fail(combo_box != NULL && str != NULL, RET_BAD_PARAMS);\n\n  combo_box_reset_options(widget);\n  combo_box->options = tk_strdup(str);\n  tokenizer_init(t, str, strlen(str), \";\");\n\n  while (tokenizer_has_more(t)) {\n    int32_t value = 0;\n    const char* token = tokenizer_next(t);\n    if (*token) {\n      const char* text = strchr(token, ':');\n      if (text != NULL) {\n        text++;\n        value = tk_atoi(token);\n      } else {\n        text = token;\n        value = i;\n      }\n\n      combo_box_append_option(widget, value, text);\n      i++;\n    }\n  }\n  tokenizer_deinit(t);\n\n  return RET_OK;\n}\n\nret_t combo_box_set_options(widget_t* widget, const char* options) {\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  ret_t ret = combo_box_parse_options(widget, options);\n  if (!widget->loading) {\n    ret = combo_box_sync_index_to_value(widget, 0, FALSE);\n  }\n  return ret;\n}\n\nstatic ret_t combo_box_text_to_index(widget_t* widget, const char* text) {\n  ret_t ret = RET_FAIL;\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  combo_box_option_t* option = NULL;\n  int32_t i = 0;\n  return_value_if_fail(widget != NULL && combo_box != NULL, RET_BAD_PARAMS);\n\n  option = combo_box->option_items;\n  for (; option != NULL; option = option->next, i++) {\n    if (tk_str_eq(text, option->text)) {\n      combo_box->selected_index = i;\n      ret = RET_OK;\n      break;\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t combo_box_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  if (tk_str_eq(name, WIDGET_PROP_OPEN_WINDOW)) {\n    combo_box_set_open_window(widget, value_str(v));\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_SELECTED_INDEX)) {\n    combo_box_set_selected_index(widget, value_int(v));\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_VALUE)) {\n    combo_box_set_value(widget, value_int(v));\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_LOCALIZE_OPTIONS)) {\n    combo_box_set_localize_options(widget, value_bool(v));\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_OPTIONS)) {\n    combo_box_set_options(widget, value_str(v));\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_ITEM_HEIGHT)) {\n    combo_box_set_item_height(widget, value_uint32(v));\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n    str_t str;\n    str_init(&str, 0);\n    edit_set_prop(widget, WIDGET_PROP_TEXT, v);\n    str_from_wstr(&str, widget_get_text(widget));\n    combo_box_text_to_index(widget, str.str);\n    str_reset(&str);\n    return RET_OK;\n  } else {\n    return edit_set_prop(widget, name, v);\n  }\n}\n\nstatic ret_t combo_box_on_layout_children_for_combobox_popup(widget_t* widget) {\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  return_value_if_fail(combo_box != NULL, RET_BAD_PARAMS);\n\n  if (combo_box->combobox_popup != NULL) {\n    point_t p = {0, 0};\n    int32_t margin = COMBO_BOX_DEFAULT_MARGIN;\n    int32_t item_height = combo_box->item_height;\n    int32_t nr = combo_box_count_options(widget);\n    int32_t h = nr * item_height + 2 * margin;\n    if (combo_box->open_window != NULL) {\n      h = combo_box->combobox_popup->h;\n    }\n    combo_box_combobox_popup_calc_position(widget, h, &p);\n    widget_move_resize(combo_box->combobox_popup, p.x, p.y, widget->w, h);\n  }\n  return RET_OK;\n}\n\nstatic ret_t combo_box_on_layout_children(widget_t* widget) {\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  widget_t* button = widget_lookup_by_type(widget, WIDGET_TYPE_BUTTON, TRUE);\n  return_value_if_fail(combo_box != NULL, RET_BAD_PARAMS);\n\n  widget_layout_children_default(widget);\n  if (button != NULL) {\n    if (button->auto_created) {\n      widget_move_resize(button, widget->w - widget->h, 0, widget->h, widget->h);\n    } else {\n      widget_layout(button);\n    }\n  }\n  if (combo_box->on_layout_combobox_popup) {\n    combo_box->on_layout_combobox_popup(widget);\n  } else {\n    combo_box_on_layout_children_for_combobox_popup(widget);\n  }\n  return RET_OK;\n}\n\nstatic uint32_t edit_get_right_margin(widget_t* widget) {\n  int32_t right_margin = 0;\n  style_t* style = widget != NULL ? widget->astyle : NULL;\n\n  right_margin = widget_get_prop_int(widget, WIDGET_PROP_RIGHT_MARGIN, 0);\n\n  if (right_margin == 0) {\n    right_margin = style_get_int(style, STYLE_ID_MARGIN_RIGHT, 0);\n  }\n\n  if (right_margin == 0) {\n    right_margin = style_get_int(style, STYLE_ID_MARGIN, 0);\n  }\n\n  return right_margin;\n}\n\nstatic ret_t combo_box_on_key_event(widget_t* widget, key_event_t* evt) {\n  ret_t ret = RET_OK;\n  edit_t* edit = EDIT(WIDGET(widget));\n  return_value_if_fail(edit != NULL, RET_BAD_PARAMS);\n\n  if (evt->key == TK_KEY_UP) {\n    ret = RET_STOP;\n    if (evt->e.type == EVT_KEY_DOWN) {\n      combo_box_add_selected_index(widget, -1);\n    }\n  } else if (evt->key == TK_KEY_DOWN) {\n    ret = RET_STOP;\n    if (evt->e.type == EVT_KEY_DOWN) {\n      combo_box_add_selected_index(widget, 1);\n    }\n  } else if (widget_is_activate_key(widget, evt) && evt->e.type == EVT_KEY_UP) {\n    if (edit->readonly) {\n      ret = RET_STOP;\n      combo_box_active(widget);\n    } else if (key_code_is_enter(evt->key)) {\n      ret = RET_STOP;\n      combo_box_active(widget);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t combo_box_on_event(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  edit_t* edit = EDIT(WIDGET(combo_box));\n  return_value_if_fail(combo_box != NULL && edit != NULL && e != NULL, RET_BAD_PARAMS);\n\n  switch (e->type) {\n    case EVT_WIDGET_LOAD: {\n      /*If there is a value widget, sync the text to value widget*/\n      if (widget_lookup(widget, WIDGET_NAME_VALUE, TRUE) != NULL) {\n        combo_box_sync_index_to_value(widget, combo_box->selected_index, FALSE);\n      }\n\n      if (combo_box_get_curr_text_size(widget) == 0 && widget->tr_text == NULL) {\n        combo_box_sync_index_to_value(widget, 0, TRUE);\n      }\n      break;\n    }\n    case EVT_RESIZE:\n    case EVT_MOVE_RESIZE: {\n      if (edit_get_right_margin(widget) == 0) {\n        edit->right_margin = widget->h;\n      }\n      break;\n    }\n    case EVT_KEY_DOWN:\n    case EVT_KEY_UP: {\n      key_event_t* evt = (key_event_t*)e;\n      if (combo_box_on_key_event(widget, evt) == RET_STOP) {\n        return RET_STOP;\n      }\n      break;\n    }\n    case EVT_POINTER_DOWN: {\n      combo_box->pressed = TRUE;\n      break;\n    }\n    case EVT_POINTER_DOWN_ABORT: {\n      combo_box->pressed = FALSE;\n      break;\n    }\n    case EVT_POINTER_UP: {\n      if (widget->target == NULL && edit->readonly && combo_box->pressed) {\n        combo_box_active(widget);\n        return RET_STOP;\n      }\n      combo_box->pressed = FALSE;\n      break;\n    }\n    case EVT_POINTER_LEAVE:\n      return combo_box_update_status(widget);\n      break;\n    case EVT_POINTER_ENTER:\n      if (combo_box_get_curr_text_size(widget) == 0) {\n        widget_set_state(widget, WIDGET_STATE_EMPTY_OVER);\n      } else {\n        widget_set_state(widget, WIDGET_STATE_OVER);\n      }\n      return RET_OK;\n      break;\n    case EVT_FOCUS:\n      combo_box_update_status(widget);\n      break;\n    case EVT_BLUR:\n      combo_box_update_status(widget);\n      break;\n    default:\n      break;\n  }\n\n  ret = edit_on_event(widget, e);\n\n  return ret;\n}\n\nstatic ret_t combo_box_on_add_child(widget_t* widget, widget_t* child) {\n  if (tk_str_eq(widget_get_type(child), WIDGET_TYPE_BUTTON)) {\n    widget_t* button = widget_lookup_by_type(widget, WIDGET_TYPE_BUTTON, TRUE);\n\n    if (button != NULL && button != child) {\n      widget_destroy(button);\n    }\n\n    widget_on(child, EVT_CLICK, combo_box_on_button_click, widget);\n  }\n\n  return RET_FAIL;\n}\n\nTK_DECL_VTABLE(combo_box) = {.size = sizeof(combo_box_t),\n                             .inputable = TRUE,\n                             .type = WIDGET_TYPE_COMBO_BOX,\n                             .focusable = TRUE,\n                             .pointer_cursor = WIDGET_CURSOR_EDIT,\n                             .space_key_to_activate = TRUE,\n                             .return_key_to_activate = TRUE,\n                             .clone_properties = s_combo_box_properties,\n                             .persistent_properties = s_combo_box_properties,\n                             .parent = TK_PARENT_VTABLE(edit),\n                             .create = combo_box_create_self,\n                             .on_paint_self = edit_on_paint_self,\n                             .set_prop = combo_box_set_prop,\n                             .get_prop = combo_box_get_prop,\n                             .on_add_child = combo_box_on_add_child,\n                             .on_layout_children = combo_box_on_layout_children,\n                             .on_destroy = combo_box_on_destroy,\n                             .on_copy = combo_box_on_copy,\n                             .on_event = combo_box_on_event};\n\nwidget_t* combo_box_create_self(widget_t* parent, xy_t x, xy_t y, wh_t w, wh_t h) {\n  widget_t* widget = edit_create_ex(parent, TK_REF_VTABLE(combo_box), x, y, w, h);\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  edit_t* edit = EDIT(WIDGET(combo_box));\n  return_value_if_fail(combo_box != NULL && edit != NULL, NULL);\n  widget_set_prop_int(widget, WIDGET_PROP_MARGIN, 0);\n  widget_set_prop_int(widget, WIDGET_PROP_LEFT_MARGIN, 0);\n  widget_set_prop_int(widget, WIDGET_PROP_RIGHT_MARGIN, 0);\n  str_init(&(combo_box->text), 32);\n  combo_box->localize_options = TRUE;\n\n  return widget;\n}\n\nstatic ret_t combo_box_on_item_click(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  widget_t* item = WIDGET(e->target);\n  return_value_if_fail(widget != NULL && item != NULL, RET_BAD_PARAMS);\n\n  combo_box_set_selected_index_ex(widget, widget_index_of(item), item);\n\n  widget->target = NULL;\n  widget->key_target = NULL;\n  window_close(widget_get_window(item));\n  widget_set_focused_internal(widget, TRUE);\n\n  return RET_OK;\n}\n\nstatic ret_t combo_box_visit_item(void* ctx, const void* data) {\n  widget_t* iter = WIDGET(data);\n  combo_box_t* combo_box = COMBO_BOX(ctx);\n  return_value_if_fail(combo_box != NULL && iter != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(widget_get_type(iter), WIDGET_TYPE_COMBO_BOX_ITEM)) {\n    int32_t index = widget_index_of(iter);\n\n    widget_on(iter, EVT_CLICK, combo_box_on_item_click, combo_box);\n\n    if (index == combo_box->selected_index) {\n      COMBO_BOX_ITEM(iter)->checked = TRUE;\n      widget_set_need_update_style(iter);\n      widget_set_focused(iter, TRUE);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t combo_box_hook_items(combo_box_t* combo_box, widget_t* popup) {\n  return widget_foreach(popup, combo_box_visit_item, combo_box);\n}\n\nstatic ret_t combo_box_create_popup_items(combo_box_t* combo_box, widget_t* parent) {\n  combo_box_option_t* iter = NULL;\n  return_value_if_fail(combo_box != NULL, RET_BAD_PARAMS);\n\n  iter = combo_box->option_items;\n  while (iter != NULL) {\n    widget_t* item = combo_box_item_create(parent, 0, 0, 0, 0);\n\n    widget_set_value(item, iter->value);\n    if (combo_box->localize_options) {\n      widget_set_tr_text(item, iter->text);\n    } else {\n      widget_set_text_utf8(item, iter->text);\n    }\n\n    iter = iter->next;\n  }\n\n  return RET_OK;\n}\n\nret_t combo_box_combobox_popup_on_close_func(void* ctx, event_t* e) {\n  combo_box_t* combo_box = COMBO_BOX(ctx);\n  return_value_if_fail(combo_box != NULL, RET_BAD_PARAMS);\n\n  combo_box->combobox_popup = NULL;\n\n  return RET_OK;\n}\n\nret_t combo_box_combobox_popup_calc_position(widget_t* widget, wh_t popup_h, point_t* p) {\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  return_value_if_fail(combo_box != NULL && p != NULL, RET_BAD_PARAMS);\n\n  memset(p, 0x00, sizeof(point_t));\n  widget_to_screen(widget, p);\n  if ((p->y + widget->h + popup_h) < combo_box->combobox_popup->parent->h) {\n    p->y += widget->h;\n  } else if (p->y >= popup_h) {\n    p->y -= combo_box->combobox_popup->h;\n  } else {\n    p->y = 0;\n  }\n  return RET_OK;\n}\n\nstatic widget_t* combo_box_create_popup(combo_box_t* combo_box) {\n  value_t v;\n  int32_t w = 0;\n  int32_t h = 0;\n  int32_t nr = 0;\n  char params[128];\n  widget_t* win = NULL;\n  int32_t item_height = 0;\n  widget_t* widget = WIDGET(combo_box);\n  int32_t margin = COMBO_BOX_DEFAULT_MARGIN;\n  return_value_if_fail(combo_box != NULL && widget != NULL, NULL);\n  item_height = combo_box->item_height;\n  nr = combo_box_count_options(widget);\n  w = widget->w;\n  h = nr * item_height + 2 * margin;\n  win = popup_create(NULL, 0, 0, w, h);\n\n  value_set_bool(&v, TRUE);\n  widget_set_prop(win, WIDGET_PROP_CLOSE_WHEN_CLICK_OUTSIDE, &v);\n  widget_set_prop_str(win, WIDGET_PROP_THEME, \"combobox_popup\");\n\n  tk_snprintf(params, sizeof(params) - 1, \"default(m=%d, r=%d c=%d)\", margin, nr, 1);\n  widget_set_children_layout(win, params);\n\n  widget_use_style(win, \"combobox_popup\");\n  combo_box_create_popup_items(combo_box, win);\n  widget_layout(win);\n\n  combo_box->combobox_popup = win;\n\n  widget_on(win, EVT_WINDOW_CLOSE, combo_box_combobox_popup_on_close_func, widget);\n  return win;\n}\n\nstatic ret_t combo_box_active(widget_t* widget) {\n  point_t p = {0, 0};\n  widget_t* win = NULL;\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  return_value_if_fail(widget != NULL && combo_box != NULL, RET_BAD_PARAMS);\n  if (combo_box->open_window) {\n    win = window_open(combo_box->open_window);\n    combo_box->combobox_popup = win;\n    widget_on(win, EVT_WINDOW_CLOSE, combo_box_combobox_popup_on_close_func, widget);\n  }\n\n  if (win != NULL) {\n    widget_resize(win, widget->w, win->h);\n    widget_layout_children(win);\n  } else {\n    if (combo_box->open_popup) {\n      win = combo_box->open_popup(widget);\n      return_value_if_fail(win != NULL, RET_FAIL);\n\n      widget_resize(win, widget->w, win->h);\n      widget_layout_children(win);\n    } else {\n      win = combo_box_create_popup(combo_box);\n      return_value_if_fail(win != NULL, RET_FAIL);\n    }\n  }\n  widget_set_prop_str(win, WIDGET_PROP_MOVE_FOCUS_PREV_KEY, \"up\");\n  widget_set_prop_str(win, WIDGET_PROP_MOVE_FOCUS_NEXT_KEY, \"down\");\n  combo_box_hook_items(combo_box, win);\n\n  combo_box_combobox_popup_calc_position(widget, win->h, &p);\n  widget_move(win, p.x, p.y);\n\n  return RET_OK;\n}\n\nstatic ret_t combo_box_on_button_click(void* ctx, event_t* e) {\n  return combo_box_active(WIDGET(ctx));\n}\n\nwidget_t* combo_box_create(widget_t* parent, xy_t x, xy_t y, wh_t w, wh_t h) {\n  widget_t* popup = NULL;\n  widget_t* widget = combo_box_create_self(parent, x, y, w, h);\n  return_value_if_fail(widget != NULL, NULL);\n\n  popup = button_create(widget, 0, 0, 0, 0);\n  popup->auto_created = TRUE;\n  combo_box_set_item_height(widget, 30);\n  widget_use_style(popup, \"combobox_down\");\n\n  return widget;\n}\n\nret_t combo_box_remove_option(widget_t* widget, int32_t value) {\n  combo_box_option_t* iter = NULL;\n  combo_box_option_t* prev = NULL;\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  return_value_if_fail(combo_box != NULL, RET_BAD_PARAMS);\n\n  iter = combo_box->option_items;\n  prev = combo_box->option_items;\n\n  while (iter != NULL) {\n    if (iter->value == value) {\n      if (iter == combo_box->option_items) {\n        combo_box->option_items = iter->next;\n      } else {\n        prev->next = iter->next;\n      }\n\n      TKMEM_FREE(iter->text);\n      TKMEM_FREE(iter);\n      return RET_OK;\n    }\n    prev = iter;\n    iter = iter->next;\n  }\n\n  return RET_NOT_FOUND;\n}\n\nret_t combo_box_reset_options(widget_t* widget) {\n  combo_box_option_t* iter = NULL;\n  combo_box_option_t* next = NULL;\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  return_value_if_fail(combo_box != NULL, RET_BAD_PARAMS);\n\n  iter = combo_box->option_items;\n  while (iter != NULL) {\n    next = iter->next;\n    TKMEM_FREE(iter->text);\n    TKMEM_FREE(iter);\n    iter = next;\n  }\n  combo_box->option_items = NULL;\n  TKMEM_FREE(combo_box->options);\n\n  return RET_OK;\n}\n\nret_t combo_box_set_open_window(widget_t* widget, const char* open_window) {\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  TKMEM_FREE(combo_box->open_window);\n  combo_box->open_window = tk_strdup(open_window);\n\n  return RET_OK;\n}\n\nret_t combo_box_append_option(widget_t* widget, int32_t value, const char* text) {\n  combo_box_option_t* iter = NULL;\n  combo_box_option_t* option = NULL;\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  return_value_if_fail(combo_box != NULL && text != NULL, RET_BAD_PARAMS);\n\n  option = TKMEM_ZALLOC(combo_box_option_t);\n  return_value_if_fail(option != NULL, RET_OOM);\n\n  option->value = value;\n  option->text = tk_strdup(text);\n\n  if (option->text == NULL) {\n    TKMEM_FREE(option);\n    return RET_OOM;\n  }\n\n  if (combo_box->option_items != NULL) {\n    iter = combo_box->option_items;\n    while (iter->next != NULL) iter = iter->next;\n    iter->next = option;\n  } else {\n    combo_box->option_items = option;\n  }\n\n  return RET_OK;\n}\n\nint32_t combo_box_count_options(widget_t* widget) {\n  int32_t nr = 0;\n  combo_box_option_t* iter = NULL;\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  return_value_if_fail(combo_box != NULL, nr);\n\n  iter = combo_box->option_items;\n  while (iter != NULL) {\n    nr++;\n    iter = iter->next;\n  }\n\n  return nr;\n}\n\ncombo_box_option_t* combo_box_get_option(widget_t* widget, uint32_t index) {\n  uint32_t i = 0;\n  combo_box_option_t* iter = NULL;\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  return_value_if_fail(combo_box != NULL, NULL);\n\n  iter = combo_box->option_items;\n  while (iter != NULL) {\n    if (i == index) {\n      return iter;\n    }\n\n    i++;\n    iter = iter->next;\n  }\n\n  return NULL;\n}\n\nbool_t combo_box_has_option_text(widget_t* widget, const char* text) {\n  combo_box_option_t* iter = NULL;\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  return_value_if_fail(combo_box != NULL, FALSE);\n\n  iter = combo_box->option_items;\n  while (iter != NULL) {\n    if (tk_str_eq(iter->text, text)) {\n      return TRUE;\n    }\n\n    iter = iter->next;\n  }\n\n  return FALSE;\n}\n\nint32_t combo_box_find_option(widget_t* widget, int32_t value) {\n  uint32_t i = 0;\n  combo_box_option_t* iter = NULL;\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  return_value_if_fail(combo_box != NULL, 0);\n\n  iter = combo_box->option_items;\n  while (iter != NULL) {\n    if (iter->value == value) {\n      return i;\n    }\n\n    i++;\n    iter = iter->next;\n  }\n\n  return 0;\n}\n\nstatic ret_t combo_box_sync_index_to_value(widget_t* widget, uint32_t index, bool_t only_set) {\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  return_value_if_fail(widget != NULL && combo_box != NULL, RET_BAD_PARAMS);\n\n  if (combo_box->option_items != NULL) {\ncombo_box_option_t* option = ",
    "raw_res": "combo_box->option_items;",
    "prompt_res": "combo_box_get_option(widget, index);",
    "gt": "combo_box_get_option(widget, index);"
  },
  {
    "id": 448,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/widgets/pages.c",
    "input": "﻿/**\n * File:   pages.c\n * Author: AWTK Develop Team\n * Brief:  pages\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-06-16 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"widgets/pages.h\"\n#include \"tkc/tokenizer.h\"\n#include \"base/widget_vtable.h\"\n#include \"base/image_manager.h\"\n#include \"default_focused_child.inc\"\n\nstatic bool_t pages_target_is_page(widget_t* target) {\n  return target->vt != NULL && tk_str_eq(target->vt->type, WIDGET_TYPE_PAGES);\n}\n\nstatic bool_t pages_active_is_valid(widget_t* widget, uint32_t active) {\n  return (active < widget_count_children(widget));\n}\n\nstatic ret_t pages_save_target(widget_t* widget) {\n  pages_t* pages = PAGES(widget);\n  return_value_if_fail(pages != NULL, RET_BAD_PARAMS);\n\n  if (pages_active_is_valid(widget, pages->active)) {\n    widget_t* active_view = widget_get_child(widget, pages->active);\n\n    if (active_view != NULL) {\n      default_focused_child_set_save_target(widget, active_view, pages_target_is_page);\n    }\n  }\n  return RET_OK;\n}\n\nstatic ret_t pages_on_idle_set_target_focused(const idle_info_t* idle) {\n  pages_t* pages = NULL;\n  return_value_if_fail(idle != NULL, RET_BAD_PARAMS);\n  pages = PAGES(idle->ctx);\n\n  default_focused_child_set_target_focused(&(pages->str_target), WIDGET(pages));\n\n  pages->focused_idle_id = TK_INVALID_ID;\n\n  return RET_OK;\n}\n\nstatic ret_t pages_restore_target(widget_t* widget) {\n  widget_t* target = NULL;\n  widget_t* active_view = NULL;\n  pages_t* pages = PAGES(widget);\n  return_value_if_fail(pages != NULL, RET_BAD_PARAMS);\n\n  if (pages_active_is_valid(widget, pages->active)) {\n    active_view = widget_get_child(widget, pages->active);\n  }\n\n  if (active_view != NULL) {\n    target = default_focused_child_get_save_target(widget, active_view);\n\n    if (target == NULL || target->parent == NULL || target == widget) {\n      target = active_view;\n    }\n    if (pages_target_is_page(target)) {\n      pages_restore_target(target);\n    } else {\n      default_focused_child_save_target_to_string(&(pages->str_target), target, widget);\n      if (pages->focused_idle_id == TK_INVALID_ID) {\npages->focused_idle_id = ",
    "raw_res": "0;",
    "prompt_res": "idle_add(pages_on_idle_set_target_focused, widget);",
    "gt": "idle_add(pages_on_idle_set_target_focused, widget);"
  },
  {
    "id": 526,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/debugger/debugger_client.c",
    "input": "﻿/**\n * File:   debugger.c\n * Author: AWTK Develop Team\n * Brief:  debugger\n *\n * Copyright (c) 2022 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2022-01-11 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/buffer.h\"\n#include \"ubjson/ubjson_parser.h\"\n#include \"debugger/debugger_message.h\"\n#include \"debugger/debugger_client.h\"\n\nstatic ret_t debugger_client_lock(debugger_t* debugger) {\n  return RET_OK;\n}\n\nstatic ret_t debugger_client_unlock(debugger_t* debugger) {\n  return RET_OK;\n}\n\nstatic ret_t debugger_client_write_data(tk_ostream_t* out, const void* data, uint32_t size) {\n  return tk_ostream_write_len(out, data, size, DEBUGGER_IO_WRITE_TIMEOUT) == size ? RET_OK : RET_IO;\n}\n\nstatic ret_t debugger_client_read_data(tk_istream_t* in, void* data, uint32_t size) {\n  return tk_istream_read_len(in, data, size, DEBUGGER_IO_READ_TIMEOUT) == size ? RET_OK : RET_IO;\n}\n\nstatic ret_t debugger_client_extend_buff(debugger_t* debugger, uint32_t size) {\n  ret_t ret = RET_OK;\n  debugger_client_t* client = DEBUGGER_CLIENT(debugger);\n\n  if (client->capacity < size) {\n    void* buff = TKMEM_REALLOC(client->buff, size);\n    if (buff != NULL) {\n      client->buff = buff;\n      client->capacity = size;\n    } else {\n      ret = RET_OOM;\n    }\n  }\n  return ret;\n}\n\nstatic ret_t debugger_client_dispatch_message(debugger_t* debugger, debugger_resp_t* resp) {\n  debugger_client_t* client = DEBUGGER_CLIENT(debugger);\n\n  switch (resp->code) {\n    case DEBUGGER_RESP_MSG_BREAKED: {\n      uint32_t line = 0;\n      debugger_breaked_event_t event;\n      tk_object_t* obj = ubjson_to_object(client->buff, resp->size);\n      return_value_if_fail(obj != NULL, RET_BAD_PARAMS);\n      line = tk_object_get_prop_int(obj, STR_DEBUGGER_EVENT_PROP_LINE, 0);\n      emitter_dispatch(EMITTER(debugger), debugger_breaked_event_init(&event, line));\n      TK_OBJECT_UNREF(obj);\n      break;\n    }\n    case DEBUGGER_RESP_MSG_LOG: {\n      uint32_t line = 0;\n      const char* message = NULL;\n      debugger_log_event_t event;\n      tk_object_t* obj = ubjson_to_object(client->buff, resp->size);\n      return_value_if_fail(obj != NULL, RET_BAD_PARAMS);\n      line = tk_object_get_prop_int(obj, STR_DEBUGGER_EVENT_PROP_LINE, 0);\n      message = tk_object_get_prop_str(obj, STR_DEBUGGER_EVENT_PROP_MESSAGE);\n      emitter_dispatch(EMITTER(debugger), debugger_log_event_init(&event, line, message));\n      TK_OBJECT_UNREF(obj);\n      break;\n    }\n    case DEBUGGER_RESP_MSG_ERROR: {\n      uint32_t line = 0;\n      const char* message = NULL;\n      debugger_error_event_t event;\n      tk_object_t* obj = ubjson_to_object(client->buff, resp->size);\n      return_value_if_fail(obj != NULL, RET_BAD_PARAMS);\n      line = tk_object_get_prop_int(obj, STR_DEBUGGER_EVENT_PROP_LINE, 0);\n      message = tk_object_get_prop_str(obj, STR_DEBUGGER_EVENT_PROP_MESSAGE);\n      emitter_dispatch(EMITTER(debugger), debugger_error_event_init(&event, line, message));\n      TK_OBJECT_UNREF(obj);\n      break;\n    }\n    case DEBUGGER_RESP_MSG_COMPLETED: {\n      client->program_completed = TRUE;\n      emitter_dispatch_simple_event(EMITTER(debugger), DEBUGGER_RESP_MSG_COMPLETED);\n      break;\n    }\n    default: {\n      emitter_dispatch_simple_event(EMITTER(debugger), resp->code);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t debugger_client_dispatch_one(debugger_t* debugger, debugger_resp_t* resp) {\n  debugger_client_t* client = DEBUGGER_CLIENT(debugger);\n  tk_istream_t* in = tk_iostream_get_istream(client->io);\n\n  return_value_if_fail(in != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(debugger_client_read_data(in, resp, sizeof(*resp)) == RET_OK, RET_IO);\n  assert(DEBUGGER_VERSION == resp->version);\n  return_value_if_fail(debugger_client_extend_buff(debugger, resp->size) == RET_OK, RET_OOM);\n\n  if (resp->size > 0) {\n    return_value_if_fail(debugger_client_read_data(in, client->buff, resp->size) == RET_OK, RET_IO);\n  }\n\n  return debugger_client_dispatch_message(debugger, resp);\n}\n\nret_t debugger_client_dispatch(debugger_t* debugger) {\n  debugger_resp_t resp;\n  return_value_if_fail(debugger != NULL, RET_BAD_PARAMS);\n\n  memset(&resp, 0x00, sizeof(resp));\n\n  return debugger_client_dispatch_one(debugger, &resp);\n}\n\nret_t debugger_client_wait_for_completed(debugger_t* debugger) {\n  debugger_resp_t resp;\n  debugger_client_t* client = DEBUGGER_CLIENT(debugger);\n\n  memset(&resp, 0x00, sizeof(resp));\n  while (!(client->program_completed)) {\n    break_if_fail(debugger_client_dispatch_one(debugger, &resp) == RET_OK);\n    if (resp.code == DEBUGGER_RESP_MSG_COMPLETED) {\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t debugger_client_read_packet(debugger_t* debugger, uint32_t resp_code, void** data,\n                                         uint32_t* size, ret_t* ret) {\n  debugger_resp_t resp;\n  debugger_client_t* client = DEBUGGER_CLIENT(debugger);\n\n  memset(&resp, 0x00, sizeof(resp));\n  while (TRUE) {\n    break_if_fail(debugger_client_dispatch_one(debugger, &resp) == RET_OK);\n    if (resp.code == resp_code) {\n      *data = client->buff;\n      *size = resp.size;\n      *ret = resp.error;\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t debugger_client_read_simple(debugger_t* debugger, uint32_t resp_code) {\n  void* data = NULL;\n  uint32_t size = 0;\n  ret_t ret = RET_FAIL;\n\n  debugger_client_read_packet(debugger, resp_code, &data, &size, &ret);\n\n  return ret;\n}\n\nstatic tk_object_t* debugger_client_read_object(debugger_t* debugger, uint32_t resp_code) {\n  void* data = NULL;\n  uint32_t size = 0;\n  ret_t ret = RET_FAIL;\n\n  if (debugger_client_read_packet(debugger, resp_code, &data, &size, &ret) == RET_OK &&\n      ret == RET_OK) {\n    assert(data != NULL && size > 0);\n    return ubjson_to_object(data, size);\n  }\n\n  return NULL;\n}\n\nstatic ret_t debugger_client_read_binary(debugger_t* debugger, uint32_t resp_code,\n                                         binary_data_t* data) {\n  ret_t ret = RET_FAIL;\n\n  debugger_client_read_packet(debugger, resp_code, &(data->data), &(data->size), &ret);\n\n  return ret;\n}\n\nstatic ret_t debugger_client_write_binary(debugger_t* debugger, uint32_t code, const void* data,\n                                          uint32_t size) {\n  debugger_req_t req;\n  debugger_client_t* client = DEBUGGER_CLIENT(debugger);\ntk_ostream_t* out = ",
    "raw_res": "0;",
    "prompt_res": "tk_iostream_get_ostream(client->io);",
    "gt": "tk_iostream_get_ostream(client->io);"
  },
  {
    "id": 533,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/debugger/debugger_fscript.c",
    "input": "﻿/**\n * File:   debugger_fscript.c\n * Author: AWTK Develop Team\n * Brief:  debugger\n *\n * Copyright (c) 2022 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2022-01-11 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/async.h\"\n#include \"tkc/object_default.h\"\n#include \"debugger/debugger_server.h\"\n#include \"debugger/debugger_message.h\"\n#include \"debugger/debugger_fscript.h\"\n\ntypedef struct _call_stack_frame_t {\n  const char* name;\n  darray_t* locals;\n} call_stack_frame_t;\n\nint32_t debugger_fscript_get_start_line(fscript_t* fscript) {\n  uint32_t i = 0;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* iter = NULL;\n  if (fscript == NULL || fscript->first == NULL) {\n    return 0;\n  }\n\n  args = &(fscript->first->args);\n  for (i = 0; i < args->size; i++) {\n    if (args->args[i].type == VALUE_TYPE_FSCRIPT_FUNC) {\n      iter = value_func(args->args + i);\n      return iter->row;\n    }\n  }\n\n  return 0;\n}\n\nstatic call_stack_frame_t* call_stack_frame_create(const char* name, darray_t* locals) {\n  call_stack_frame_t* frame = TKMEM_ZALLOC(call_stack_frame_t);\n  return_value_if_fail(frame != NULL, NULL);\n\n  frame->name = name;\n  frame->locals = locals;\n\n  return frame;\n}\n\nstatic ret_t call_stack_frame_destroy(call_stack_frame_t* frame) {\n  return_value_if_fail(frame != NULL, RET_BAD_PARAMS);\n\n  TKMEM_FREE(frame);\n\n  return RET_OK;\n}\n\nstatic ret_t debugger_fscript_enter_func(debugger_t* debugger, const char* name, darray_t* locals) {\n  call_stack_frame_t* frame = NULL;\n  debugger_fscript_t* d = DEBUGGER_FSCRIPT(debugger);\n  return_value_if_fail(d != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(name != NULL, RET_BAD_PARAMS);\n\n  frame = call_stack_frame_create(name, locals);\n  return_value_if_fail(frame != NULL, RET_OOM);\n\n  if (darray_push(&(d->call_stack_frames), frame) != RET_OK) {\n    call_stack_frame_destroy(frame);\n    return RET_OOM;\n  } else {\n    log_debug(\"enter %s\\n\", name);\n    return RET_OK;\n  }\n}\n\nstatic ret_t debugger_fscript_leave_func(debugger_t* debugger) {\n  call_stack_frame_t* frame = NULL;\n  debugger_fscript_t* d = DEBUGGER_FSCRIPT(debugger);\n  return_value_if_fail(d != NULL, RET_BAD_PARAMS);\n\n  frame = (call_stack_frame_t*)darray_pop(&(d->call_stack_frames));\n  return_value_if_fail(frame != NULL, RET_BAD_PARAMS);\n\n  log_debug(\"leave %s\\n\", frame->name);\n\n  return call_stack_frame_destroy(frame);\n}\n\nstatic ret_t debugger_fscript_lock(debugger_t* debugger) {\n  debugger_fscript_t* d = DEBUGGER_FSCRIPT(debugger);\n  return_value_if_fail(d != NULL && d->mutex != NULL, RET_BAD_PARAMS);\n\n  return tk_mutex_nest_lock(d->mutex);\n}\n\nstatic ret_t debugger_fscript_unlock(debugger_t* debugger) {\n  debugger_fscript_t* d = DEBUGGER_FSCRIPT(debugger);\n  return_value_if_fail(d != NULL && d->mutex != NULL, RET_BAD_PARAMS);\n\n  return tk_mutex_nest_unlock(d->mutex);\n}\n\nstatic ret_t debugger_fscript_stop(debugger_t* debugger) {\n  ret_t ret = RET_FAIL;\n  debugger_fscript_t* d = DEBUGGER_FSCRIPT(debugger);\n  return_value_if_fail(d != NULL, RET_BAD_PARAMS);\n\n  if (debugger_fscript_lock(debugger) == RET_OK) {\n    if (d->fscript != NULL) {\n      d->fscript->returned = TRUE;\n      debugger_clear_break_points(debugger);\n    }\n    debugger_fscript_unlock(debugger);\n  }\n\n  return ret;\n}\n\nstatic ret_t debugger_fscript_pause(debugger_t* debugger) {\n  ret_t ret = RET_FAIL;\n  debugger_fscript_t* d = DEBUGGER_FSCRIPT(debugger);\n  return_value_if_fail(d != NULL, RET_BAD_PARAMS);\n\n  if (debugger_fscript_lock(debugger) == RET_OK) {\n    if (d->fscript != NULL && d->paused == FALSE) {\n      ret = RET_OK;\n      /*停止到下一行要执行的代码*/\n      d->next_stop_executed_line = d->executed_lines + 1;\n      d->break_type = DEBUGGER_FSCRIPT_BREAK_STEP_IN;\n    }\n    ret = d->paused == TRUE ? RET_OK : RET_FAIL;\n    debugger_fscript_unlock(debugger);\n  }\n\n  return ret;\n}\n\nstatic bool_t debugger_fscript_match(debugger_t* debugger, const char* code_id) {\n  debugger_fscript_t* d = DEBUGGER_FSCRIPT(debugger);\n  return_value_if_fail(d != NULL, FALSE);\n\n  return tk_str_eq(d->code_id, code_id);\n}\n\nstatic bool_t debugger_fscript_is_paused(debugger_t* debugger) {\n  bool_t ret = FALSE;\n  debugger_fscript_t* d = DEBUGGER_FSCRIPT(debugger);\n  return_value_if_fail(d != NULL, FALSE);\n\n  if (debugger_fscript_lock(debugger) == RET_OK) {\n    ret = d->paused;\n    debugger_fscript_unlock(debugger);\n  }\n\n  return ret;\n}\n\nstatic ret_t debugger_fscript_clear_step_stops(debugger_fscript_t* d) {\n  d->next_stop_line = -1;\n  d->next_stop_executed_line = -1;\n  d->next_stop_call_frame_index = -1;\n  d->break_type = DEBUGGER_FSCRIPT_BREAK_NONE;\n\n  return RET_OK;\n}\n\nstatic ret_t debugger_fscript_step_in(debugger_t* debugger) {\n  ret_t ret = RET_FAIL;\n  debugger_fscript_t* d = DEBUGGER_FSCRIPT(debugger);\n  return_value_if_fail(d != NULL, RET_BAD_PARAMS);\n\n  if (debugger_fscript_lock(debugger) == RET_OK) {\n    if (d->fscript != NULL && d->paused) {\n      ret = RET_OK;\n      debugger_fscript_clear_step_stops(d);\n      d->next_stop_executed_line = d->executed_lines + 1;\n      d->break_type = DEBUGGER_FSCRIPT_BREAK_STEP_IN;\n      log_debug(\"step_in: %d %d\\n\", d->executed_lines, d->next_stop_executed_line);\n    }\n    debugger_fscript_unlock(debugger);\n\n    if (ret == RET_OK) {\n      tk_cond_var_awake(d->cond_var);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t debugger_fscript_next(debugger_t* debugger) {\n  ret_t ret = RET_FAIL;\n  debugger_fscript_t* d = DEBUGGER_FSCRIPT(debugger);\n  return_value_if_fail(d != NULL, RET_BAD_PARAMS);\n\n  if (debugger_fscript_lock(debugger) == RET_OK) {\n    if (d->fscript != NULL && d->paused) {\n      ret = RET_OK;\n      debugger_fscript_clear_step_stops(d);\n      d->next_stop_executed_line = d->executed_lines + 1;\n      d->next_stop_call_frame_index = d->call_stack_frames.size;\n      d->break_type = DEBUGGER_FSCRIPT_BREAK_NEXT;\n      log_debug(\"next:executed_lines=%d prev_executed_line=%d\\n\", d->executed_lines,\n                d->prev_executed_line);\n    }\n    debugger_fscript_unlock(debugger);\n\n    if (ret == RET_OK) {\n      tk_cond_var_awake(d->cond_var);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t debugger_fscript_step_out(debugger_t* debugger) {\n  ret_t ret = RET_FAIL;\n  debugger_fscript_t* d = DEBUGGER_FSCRIPT(debugger);\n  return_value_if_fail(d != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(d->call_stack_frames.size > 0, RET_BAD_PARAMS);\n\n  if (debugger_fscript_lock(debugger) == RET_OK) {\n    if (d->fscript != NULL && d->paused) {\n      ret = RET_OK;\n      debugger_fscript_clear_step_stops(d);\n      d->next_stop_call_frame_index = d->call_stack_frames.size - 1;\n      log_debug(\"step out:%d\\n\", d->next_stop_call_frame_index);\n      d->break_type = DEBUGGER_FSCRIPT_BREAK_STEP_OUT;\n    }\n    debugger_fscript_unlock(debugger);\n\n    if (ret == RET_OK) {\n      tk_cond_var_awake(d->cond_var);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t debugger_fscript_step_over(debugger_t* debugger) {\n  ret_t ret = RET_FAIL;\n  debugger_fscript_t* d = DEBUGGER_FSCRIPT(debugger);\n  return_value_if_fail(d != NULL, RET_BAD_PARAMS);\n\n  if (debugger_fscript_lock(debugger) == RET_OK) {\n    if (d->fscript != NULL && d->paused) {\n      ret = RET_OK;\n      debugger_fscript_clear_step_stops(d);\n      d->next_stop_line = d->prev_executed_line + 1;\n      d->break_type = DEBUGGER_FSCRIPT_BREAK_STEP_OVER;\n      log_debug(\"step over: %d %d\\n\", d->next_stop_line, d->prev_executed_line);\n    }\n    debugger_fscript_unlock(debugger);\n\n    if (ret == RET_OK) {\n      tk_cond_var_awake(d->cond_var);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t debugger_fscript_continue(debugger_t* debugger) {\n  ret_t ret = RET_FAIL;\n  debugger_fscript_t* d = DEBUGGER_FSCRIPT(debugger);\n  return_value_if_fail(d != NULL, RET_BAD_PARAMS);\n\n  if (debugger_fscript_lock(debugger) == RET_OK) {\n    if (d->fscript != NULL && d->paused) {\n      ret = RET_OK;\n      debugger_fscript_clear_step_stops(d);\n    }\n    debugger_fscript_unlock(debugger);\n\n    if (ret == RET_OK) {\n      tk_cond_var_awake(d->cond_var);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t debugger_fscript_get_code(debugger_t* debugger, binary_data_t* code) {\n  debugger_fscript_t* d = DEBUGGER_FSCRIPT(debugger);\n  return_value_if_fail(d != NULL && d->fscript != NULL, RET_BAD_PARAMS);\n\n  code->data = d->code.str;\n  code->size = d->code.size + 1;\n\n  return RET_OK;\n}\n\ntk_object_t* debugger_fscript_get_local(debugger_t* debugger, uint32_t frame_index) {\n  uint32_t index = 0;\n  call_stack_frame_t* frame = NULL;\n  tk_object_t* locals = object_default_create();\n  debugger_fscript_t* d = DEBUGGER_FSCRIPT(debugger);\n  return_value_if_fail(d != NULL && d->fscript != NULL, NULL);\n  return_value_if_fail(d->call_stack_frames.size > frame_index, NULL);\n\n  index = d->call_stack_frames.size - frame_index - 1;\n  frame = (call_stack_frame_t*)darray_get(&(d->call_stack_frames), index);\n  return_value_if_fail(frame != NULL, NULL);\n\n  if (frame->locals != NULL) {\n    uint32_t i = 0;\n    for (i = 0; i < frame->locals->size; i++) {\n      named_value_t* iter = (named_value_t*)darray_get(frame->locals, i);\n      if (iter->value.type != VALUE_TYPE_INVALID) {\n        tk_object_set_prop(locals, iter->name, &(iter->value));\n      }\n    }\n  }\n\n  return locals;\n}\n\ntk_object_t* debugger_fscript_get_self(debugger_t* debugger) {\n  debugger_fscript_t* d = DEBUGGER_FSCRIPT(debugger);\n  return_value_if_fail(d != NULL && d->fscript != NULL, NULL);\n\n  return TK_OBJECT_REF(d->fscript->obj);\n}\n\ntk_object_t* debugger_fscript_get_global(debugger_t* debugger) {\n  return TK_OBJECT_REF(fscript_get_global_object());\n}\n\nstatic ret_t debugger_fscript_get_callstack(debugger_t* debugger, binary_data_t* callstack) {\n  uint32_t i = 0;\n  debugger_fscript_t* d = DEBUGGER_FSCRIPT(debugger);\n  return_value_if_fail(d != NULL && d->fscript != NULL, RET_BAD_PARAMS);\n\n  str_clear(&(d->temp_str));\n  for (i = 0; i < d->call_stack_frames.size; i++) {\n    call_stack_frame_t* iter = (call_stack_frame_t*)darray_get(&(d->call_stack_frames), i);\n    str_append_more(&(d->temp_str), iter->name, \"\\n\", NULL);\n  }\n\n  callstack->data = d->temp_str.str;\n  callstack->size = d->temp_str.size + 1;\n\n  return RET_OK;\n}\n\nstatic ret_t debugger_fscript_get_break_points(debugger_t* debugger, binary_data_t* break_points) {\n  uint32_t i = 0;\n  debugger_fscript_t* d = DEBUGGER_FSCRIPT(debugger);\n  return_value_if_fail(d != NULL && d->fscript != NULL, RET_BAD_PARAMS);\n\n  str_clear(&(d->temp_str));\n  for (i = 0; i < d->break_points.size; i++) {\n    int32_t line = tk_pointer_to_int(darray_get(&(d->break_points), i));\n    str_append_int(&(d->temp_str), line);\n    str_append(&(d->temp_str), \"\\n\");\n  }\n\n  break_points->data = d->temp_str.str;\n  break_points->size = d->temp_str.size + 1;\n\n  return RET_OK;\n}\n\nstatic ret_t debugger_fscript_clear_break_points(debugger_t* debugger) {\n  ret_t ret = RET_FAIL;\n  bool_t paused = FALSE;\n  debugger_fscript_t* d = DEBUGGER_FSCRIPT(debugger);\n  return_value_if_fail(d != NULL, RET_BAD_PARAMS);\n\n  if (debugger_fscript_lock(debugger) == RET_OK) {\n    debugger_fscript_clear_step_stops(d);\nret = ",
    "raw_res": "0;",
    "prompt_res": "darray_clear(&(d->break_points));",
    "gt": "darray_clear(&(d->break_points));"
  },
  {
    "id": 551,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/debugger/debugger_server.c",
    "input": "﻿/**\n * File:   debugger_server.h\n * Author: AWTK Develop Team\n * Brief:  debugger server\n *\n * Copyright (c) 2022 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2022-01-12 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/thread.h\"\n#include \"tkc/buffer.h\"\n#include \"tkc/object_default.h\"\n#include \"ubjson/ubjson_writer.h\"\n#include \"debugger/debugger_factory.h\"\n#include \"debugger/debugger_server.h\"\n#include \"debugger/debugger_message.h\"\n\ntypedef struct _debugger_server_t {\n  darray_t debuggers;\n  debugger_t* debugger;\n  tk_thread_t* thread;\n\n  /*等待退出*/\n  bool_t quiting;\n  /*退出完成*/\n  bool_t quited;\n  /*启动完成*/\n  bool_t started;\n  bool_t single_mode;\n  tk_istream_t* in;\n  tk_ostream_t* out;\n  tk_iostream_t* io;\n  tk_mutex_nest_t* mutex;\n\n  /*读取数据的缓冲区*/\n  void* buff;\n  uint32_t capacity;\n} debugger_server_t;\n\nstatic bool_t s_single_mode = FALSE;\nstatic bool_t s_server_running = FALSE;\nstatic debugger_server_t* s_debugger_server = NULL;\n\nstatic void* debugger_server_run(void* ctx);\nstatic ret_t debugger_server_send_object(debugger_server_t* server, debugger_resp_t* resp,\n                                         tk_object_t* obj);\n\nstatic debugger_server_t* debugger_server_create(tk_iostream_t* io, bool_t single_mode) {\n  debugger_server_t* server = TKMEM_ZALLOC(debugger_server_t);\n  return_value_if_fail(server != NULL, NULL);\n\n  assert(io != NULL);\n\n  server->io = io;\n  server->single_mode = single_mode;\n  server->in = tk_iostream_get_istream(io);\n  server->out = tk_iostream_get_ostream(io);\n  darray_init(&(server->debuggers), 5, (tk_destroy_t)tk_object_unref, NULL);\n\n  server->mutex = tk_mutex_nest_create();\n  goto_error_if_fail(server->mutex != NULL);\n\n  server->thread = tk_thread_create(debugger_server_run, server);\n  goto_error_if_fail(server->thread != NULL);\n  tk_thread_start(server->thread);\n\n  while (!(server->started)) {\n    sleep_ms(100);\n  }\n  log_debug(\"debugger_server_thread started\\n\");\n\n  return server;\n\nerror:\n  TK_OBJECT_UNREF(io);\n  darray_deinit(&(server->debuggers));\n  TKMEM_FREE(server);\n\n  return NULL;\n}\n\nstatic ret_t debugger_server_extend(debugger_server_t* server, uint32_t size) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(server != NULL, RET_BAD_PARAMS);\n\n  if (server->capacity < size) {\n    void* buff = TKMEM_REALLOC(server->buff, size);\n    if (buff != NULL) {\n      server->buff = buff;\n      server->capacity = size;\n    } else {\n      ret = RET_FAIL;\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t debugger_server_write_data(tk_ostream_t* out, const void* data, uint32_t size) {\n  return tk_ostream_write_len(out, data, size, DEBUGGER_IO_WRITE_TIMEOUT) == size ? RET_OK : RET_IO;\n}\n\nstatic ret_t debugger_server_read_data(tk_istream_t* in, void* data, uint32_t size) {\n  return tk_istream_read_len(in, data, size, DEBUGGER_IO_READ_TIMEOUT) == size ? RET_OK : RET_IO;\n}\n\nstatic ret_t debugger_server_send_data_impl(tk_ostream_t* out, debugger_resp_t* resp,\n                                            binary_data_t* data) {\n  ret_t ret = RET_FAIL;\n  resp->version = DEBUGGER_VERSION;\n  resp->size = data != NULL ? data->size : 0;\n\n  ret = debugger_server_write_data(out, resp, sizeof(*resp));\n  return_value_if_fail(ret == RET_OK, RET_IO);\n\n  if (resp->size > 0) {\n    ret = debugger_server_write_data(out, data->data, data->size);\n  }\n\n  return ret;\n}\n\nstatic ret_t debugger_server_send_data(debugger_server_t* server, debugger_resp_t* resp,\n                                       binary_data_t* data) {\n  ret_t ret = RET_FAIL;\n\n  if (tk_mutex_nest_lock(server->mutex) == RET_OK) {\n    ret = debugger_server_send_data_impl(server->out, resp, data);\n    tk_mutex_nest_unlock(server->mutex);\n  }\n\n  return ret;\n}\n\nstatic ret_t debugger_server_send_object(debugger_server_t* server, debugger_resp_t* resp,\n                                         tk_object_t* obj) {\n  wbuffer_t wb;\n  ret_t ret = RET_FAIL;\n  ubjson_writer_t writer;\n  binary_data_t data = {0, NULL};\n  return_value_if_fail(wbuffer_init_extendable(&wb) != NULL, RET_OOM);\n\n  if (obj != NULL) {\n    ubjson_writer_init(&writer, (ubjson_write_callback_t)wbuffer_write_binary, &wb);\nret = ",
    "raw_res": "0;",
    "prompt_res": "ubjson_writer_write_object(&writer, obj);",
    "gt": "ubjson_writer_write_object(&writer, obj);"
  },
  {
    "id": 562,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/debugger/debugger_server.c",
    "input": "﻿/**\n * File:   debugger_server.h\n * Author: AWTK Develop Team\n * Brief:  debugger server\n *\n * Copyright (c) 2022 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2022-01-12 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/thread.h\"\n#include \"tkc/buffer.h\"\n#include \"tkc/object_default.h\"\n#include \"ubjson/ubjson_writer.h\"\n#include \"debugger/debugger_factory.h\"\n#include \"debugger/debugger_server.h\"\n#include \"debugger/debugger_message.h\"\n\ntypedef struct _debugger_server_t {\n  darray_t debuggers;\n  debugger_t* debugger;\n  tk_thread_t* thread;\n\n  /*等待退出*/\n  bool_t quiting;\n  /*退出完成*/\n  bool_t quited;\n  /*启动完成*/\n  bool_t started;\n  bool_t single_mode;\n  tk_istream_t* in;\n  tk_ostream_t* out;\n  tk_iostream_t* io;\n  tk_mutex_nest_t* mutex;\n\n  /*读取数据的缓冲区*/\n  void* buff;\n  uint32_t capacity;\n} debugger_server_t;\n\nstatic bool_t s_single_mode = FALSE;\nstatic bool_t s_server_running = FALSE;\nstatic debugger_server_t* s_debugger_server = NULL;\n\nstatic void* debugger_server_run(void* ctx);\nstatic ret_t debugger_server_send_object(debugger_server_t* server, debugger_resp_t* resp,\n                                         tk_object_t* obj);\n\nstatic debugger_server_t* debugger_server_create(tk_iostream_t* io, bool_t single_mode) {\n  debugger_server_t* server = TKMEM_ZALLOC(debugger_server_t);\n  return_value_if_fail(server != NULL, NULL);\n\n  assert(io != NULL);\n\n  server->io = io;\n  server->single_mode = single_mode;\n  server->in = tk_iostream_get_istream(io);\n  server->out = tk_iostream_get_ostream(io);\n  darray_init(&(server->debuggers), 5, (tk_destroy_t)tk_object_unref, NULL);\n\n  server->mutex = tk_mutex_nest_create();\n  goto_error_if_fail(server->mutex != NULL);\n\n  server->thread = tk_thread_create(debugger_server_run, server);\n  goto_error_if_fail(server->thread != NULL);\n  tk_thread_start(server->thread);\n\n  while (!(server->started)) {\n    sleep_ms(100);\n  }\n  log_debug(\"debugger_server_thread started\\n\");\n\n  return server;\n\nerror:\n  TK_OBJECT_UNREF(io);\n  darray_deinit(&(server->debuggers));\n  TKMEM_FREE(server);\n\n  return NULL;\n}\n\nstatic ret_t debugger_server_extend(debugger_server_t* server, uint32_t size) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(server != NULL, RET_BAD_PARAMS);\n\n  if (server->capacity < size) {\n    void* buff = TKMEM_REALLOC(server->buff, size);\n    if (buff != NULL) {\n      server->buff = buff;\n      server->capacity = size;\n    } else {\n      ret = RET_FAIL;\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t debugger_server_write_data(tk_ostream_t* out, const void* data, uint32_t size) {\n  return tk_ostream_write_len(out, data, size, DEBUGGER_IO_WRITE_TIMEOUT) == size ? RET_OK : RET_IO;\n}\n\nstatic ret_t debugger_server_read_data(tk_istream_t* in, void* data, uint32_t size) {\n  return tk_istream_read_len(in, data, size, DEBUGGER_IO_READ_TIMEOUT) == size ? RET_OK : RET_IO;\n}\n\nstatic ret_t debugger_server_send_data_impl(tk_ostream_t* out, debugger_resp_t* resp,\n                                            binary_data_t* data) {\n  ret_t ret = RET_FAIL;\n  resp->version = DEBUGGER_VERSION;\n  resp->size = data != NULL ? data->size : 0;\n\n  ret = debugger_server_write_data(out, resp, sizeof(*resp));\n  return_value_if_fail(ret == RET_OK, RET_IO);\n\n  if (resp->size > 0) {\n    ret = debugger_server_write_data(out, data->data, data->size);\n  }\n\n  return ret;\n}\n\nstatic ret_t debugger_server_send_data(debugger_server_t* server, debugger_resp_t* resp,\n                                       binary_data_t* data) {\n  ret_t ret = RET_FAIL;\n\n  if (tk_mutex_nest_lock(server->mutex) == RET_OK) {\n    ret = debugger_server_send_data_impl(server->out, resp, data);\n    tk_mutex_nest_unlock(server->mutex);\n  }\n\n  return ret;\n}\n\nstatic ret_t debugger_server_send_object(debugger_server_t* server, debugger_resp_t* resp,\n                                         tk_object_t* obj) {\n  wbuffer_t wb;\n  ret_t ret = RET_FAIL;\n  ubjson_writer_t writer;\n  binary_data_t data = {0, NULL};\n  return_value_if_fail(wbuffer_init_extendable(&wb) != NULL, RET_OOM);\n\n  if (obj != NULL) {\n    ubjson_writer_init(&writer, (ubjson_write_callback_t)wbuffer_write_binary, &wb);\n    ret = ubjson_writer_write_object(&writer, obj);\n    assert(ret == RET_OK);\n    goto_error_if_fail(ret == RET_OK);\n  } else {\n    wbuffer_write_string(&wb, \"{}\");\n  }\n\n  data.data = wb.data;\n  data.size = wb.cursor;\n  ret = debugger_server_send_data(server, resp, &data);\n\nerror:\n  wbuffer_deinit(&wb);\n\n  return ret;\n}\n\nstatic ret_t debugger_server_read_request_impl(debugger_server_t* server, debugger_req_t* req) {\n  tk_istream_t* in = server->in;\n  ret_t ret = debugger_server_read_data(in, req, sizeof(*req));\n  return_value_if_fail(ret == RET_OK, RET_IO);\n\n  assert(req->version == DEBUGGER_VERSION);\n  return_value_if_fail(debugger_server_extend(server, req->size) == RET_OK, RET_OOM);\n\n  if (req->size > 0) {\n    ret = debugger_server_read_data(in, server->buff, req->size);\n  } else {\n    ret = RET_OK;\n  }\n\n  return ret;\n}\n\nstatic ret_t debugger_server_read_request(debugger_server_t* server, debugger_req_t* req) {\n  ret_t ret = tk_istream_wait_for_data(server->in, 1000);\n\n  if (ret != RET_OK) {\n    return ret;\n  }\n\n  if (tk_mutex_nest_lock(server->mutex) == RET_OK) {\n    ret = debugger_server_read_request_impl(server, req);\n    tk_mutex_nest_unlock(server->mutex);\n  }\n\n  return ret;\n}\n\nstatic ret_t debugger_server_get_debuggers(debugger_server_t* server, str_t* debuggers) {\n  value_t v;\n  char buff[64];\n  uint32_t i = 0;\n  return_value_if_fail(server != NULL, RET_BAD_PARAMS);\n\n  if (tk_mutex_nest_lock(server->mutex) == RET_OK) {\n    for (i = 0; i < server->debuggers.size; i++) {\n      debugger_t* iter = (debugger_t*)darray_get(&(server->debuggers), i);\n      if (tk_object_get_prop(TK_OBJECT(iter), DEBUGGER_PROP_CODE_ID, &v) == RET_OK) {\n        str_append_more(debuggers, value_str_ex(&v, buff, sizeof(buff) - 1), \"\\n\", NULL);\n      }\n    }\n    tk_mutex_nest_unlock(server->mutex);\n  }\n\n  return RET_OK;\n}\n\nstatic debugger_t* debugger_server_find(debugger_server_t* server, const char* code_id) {\n  uint32_t i = 0;\n  debugger_t* debugger = NULL;\n  return_value_if_fail(server != NULL, NULL);\n\n  if (tk_mutex_nest_lock(server->mutex) == RET_OK) {\n    if (server->single_mode) {\n      if (code_id != NULL && server->debugger != NULL &&\n          debugger_match(server->debugger, code_id)) {\n        debugger = server->debugger;\n      }\n    } else {\n      for (i = 0; i < server->debuggers.size; i++) {\n        debugger_t* iter = (debugger_t*)darray_get(&(server->debuggers), i);\n        if (debugger_match(iter, code_id)) {\n          debugger = iter;\n          break;\n        }\n      }\n    }\n    tk_mutex_nest_unlock(server->mutex);\n  }\n\n  return debugger;\n}\n\nstatic ret_t debugger_server_on_events(void* ctx, event_t* e) {\n  ret_t ret = RET_OK;\n  debugger_resp_t msg;\n  tk_object_t* obj = NULL;\n  tk_ostream_t* out = NULL;\n  debugger_t* debugger = DEBUGGER(e->target);\n  debugger_server_t* server = (debugger_server_t*)ctx;\n  return_value_if_fail(debugger != NULL && server != NULL, RET_BAD_PARAMS);\n\n  out = server->out;\n  return_value_if_fail(out != NULL, RET_BAD_PARAMS);\n\n  obj = object_default_create();\n  return_value_if_fail(obj != NULL, RET_BAD_PARAMS);\n\n  memset(&msg, 0x00, sizeof(msg));\n  msg.code = e->type;\n  msg.error = RET_OK;\n\n  switch (e->type) {\n    case DEBUGGER_RESP_MSG_LOG: {\n      debugger_log_event_t* event = debugger_log_event_cast(e);\n      tk_object_set_prop_int(obj, STR_DEBUGGER_EVENT_PROP_LINE, event->line);\n      tk_object_set_prop_str(obj, STR_DEBUGGER_EVENT_PROP_MESSAGE, event->message);\n      ret = debugger_server_send_object(server, &msg, obj);\n      break;\n    }\n    case DEBUGGER_RESP_MSG_ERROR: {\n      debugger_error_event_t* event = debugger_error_event_cast(e);\n      tk_object_set_prop_int(obj, STR_DEBUGGER_EVENT_PROP_LINE, event->line);\n      tk_object_set_prop_str(obj, STR_DEBUGGER_EVENT_PROP_MESSAGE, event->message);\n      ret = debugger_server_send_object(server, &msg, obj);\n      break;\n    }\n    case DEBUGGER_RESP_MSG_BREAKED: {\n      debugger_breaked_event_t* event = debugger_breaked_event_cast(e);\n      tk_object_set_prop_int(obj, STR_DEBUGGER_EVENT_PROP_LINE, event->line);\n      ret = debugger_server_send_object(server, &msg, obj);\n      break;\n    }\n    case DEBUGGER_RESP_MSG_COMPLETED: {\n      debugger_server_send_data(server, &msg, NULL);\n      break;\n    }\n    default: {\n      log_debug(\"not supported event:%d\\n\", (int)(e->type));\n      break;\n    }\n  }\n\n  TK_OBJECT_UNREF(obj);\n\n  return ret == RET_OK ? RET_OK : RET_REMOVE;\n}\n\nstatic debugger_t* debugger_server_init_debugger(debugger_server_t* server, debugger_t* debugger) {\n  ret_t ret = RET_FAIL;\n  return_value_if_fail(debugger != NULL, NULL);\n\n  ret = darray_push(&(server->debuggers), debugger);\n  if (ret != RET_OK) {\n    OBJECT_UNREF(debugger);\n  } else {\n    emitter_on(EMITTER(debugger), DEBUGGER_RESP_MSG_LOG, debugger_server_on_events, server);\n    emitter_on(EMITTER(debugger), DEBUGGER_RESP_MSG_ERROR, debugger_server_on_events, server);\n    emitter_on(EMITTER(debugger), DEBUGGER_RESP_MSG_BREAKED, debugger_server_on_events, server);\n    emitter_on(EMITTER(debugger), DEBUGGER_RESP_MSG_COMPLETED, debugger_server_on_events, server);\n    server->debugger = debugger;\n  }\n\n  return debugger;\n}\n\nret_t debugger_server_create_debugger(debugger_server_t* server, const char* lang,\n                                      const char* code_id) {\n  debugger_t* debugger = NULL;\n  return_value_if_fail(server != NULL, RET_BAD_PARAMS);\n\n  if (tk_mutex_nest_lock(server->mutex) == RET_OK) {\n    debugger = debugger_server_find(server, code_id);\n    if (debugger == NULL) {\n      debugger = debugger_factory_attach_debugger(lang, code_id);\n      debugger_server_init_debugger(server, debugger);\n    }\n\n    tk_mutex_nest_unlock(server->mutex);\n  }\n\n  return debugger != NULL ? RET_OK : RET_FAIL;\n}\n\nstatic ret_t debugger_server_attach_debugger(debugger_server_t* server, const char* arg) {\n  char lang[TK_NAME_LEN + 1];\n  const char* code_id = NULL;\n  return_value_if_fail(server != NULL, RET_BAD_PARAMS);\n  code_id = strchr(arg, ':');\n  return_value_if_fail(code_id != NULL, RET_BAD_PARAMS);\n\n  tk_strncpy_s(lang, TK_NAME_LEN, arg, code_id - arg);\n  code_id++;\n\n  return debugger_server_create_debugger(server, lang, code_id);\n}\n\nstatic ret_t debugger_server_launch_debugger(debugger_server_t* server, binary_data_t* arg) {\n  const char* code = NULL;\n  char lang[TK_NAME_LEN + 1];\n  debugger_t* debugger = NULL;\n  return_value_if_fail(server != NULL, RET_BAD_PARAMS);\n  code = strchr((char*)(arg->data), ':');\n  return_value_if_fail(code != NULL, RET_BAD_PARAMS);\n\n  tk_strncpy_s(lang, TK_NAME_LEN, (char*)(arg->data), code - (char*)(arg->data));\n  code++;\n  if (tk_mutex_nest_lock(server->mutex) == RET_OK) {\n    binary_data_t data;\n\n    data.data = (uint8_t*)code;\n    data.size = arg->size - (code - (char*)(arg->data));\n    debugger = debugger_factory_launch_debugger(lang, &data);\n    debugger_server_init_debugger(server, debugger);\n\n    tk_mutex_nest_unlock(server->mutex);\n  }\n\n  return debugger != NULL ? RET_OK : RET_FAIL;\n}\n\nstatic ret_t debugger_server_destroy(debugger_server_t* server) {\n  return_value_if_fail(server != NULL, RET_BAD_PARAMS);\n\n  if (s_debugger_server == server) {\n    s_debugger_server = NULL;\n  }\n\n  server->quiting = TRUE;\n  while (!server->quited) {\n    sleep_ms(100);\n  }\n\n  tk_mutex_nest_destroy(server->mutex);\n  server->mutex = NULL;\n\n  darray_deinit(&(server->debuggers));\n  tk_thread_destroy(server->thread);\n  TK_OBJECT_UNREF(server->io);\n  TKMEM_FREE(server->buff);\n  TKMEM_FREE(server);\n\n  return RET_OK;\n}\n\nstatic ret_t debugger_server_dispatch(debugger_server_t* server) {\n  ret_t ret = RET_OK;\n  debugger_req_t req;\n  debugger_resp_t resp;\n  debugger_t* debugger = NULL;\n\n  server->started = TRUE;\n  while (!(server->quiting)) {\n    ret = debugger_server_read_request(server, &req);\n    if (ret == RET_TIMEOUT) {\n      continue;\n    } else if (ret != RET_OK) {\n      break;\n    }\n    resp.size = 0;\n    resp.code = req.code;\n    resp.error = RET_OK;\n\n    if (req.code == DEBUGGER_REQ_ATTACH) {\n      resp.error = debugger_server_attach_debugger(server, (const char*)(server->buff));\n      break_if_fail(debugger_server_send_data(server, &resp, NULL) == RET_OK);\n      continue;\n    } else if (req.code == DEBUGGER_REQ_LAUNCH) {\n      binary_data_t code = {req.size, server->buff};\n      resp.error = debugger_server_launch_debugger(server, &code);\n      break_if_fail(debugger_server_send_data(server, &resp, NULL) == RET_OK);\n      continue;\n    }\n\n    if (server->debugger == NULL) {\n      resp.error = RET_NOT_FOUND;\n      break_if_fail(debugger_server_send_data(server, &resp, NULL) == RET_OK);\n      continue;\n    }\n\n    debugger = server->debugger;\n\n    switch (req.code) {\n      case DEBUGGER_REQ_STOP: {\n        resp.error = debugger_stop(debugger);\n        break;\n      }\n      case DEBUGGER_REQ_PAUSE: {\n        resp.error = debugger_pause(debugger);\n        break;\n      }\n      case DEBUGGER_REQ_IS_PAUSED: {\nresp.error = ",
    "raw_res": "debugger_is_paused(debugger, &resp.value);",
    "prompt_res": "debugger_is_paused(debugger) ? RET_OK : RET_FAIL;",
    "gt": "debugger_is_paused(debugger) ? RET_OK : RET_FAIL;"
  },
  {
    "id": 567,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/debugger/debugger_server.c",
    "input": "﻿/**\n * File:   debugger_server.h\n * Author: AWTK Develop Team\n * Brief:  debugger server\n *\n * Copyright (c) 2022 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2022-01-12 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/thread.h\"\n#include \"tkc/buffer.h\"\n#include \"tkc/object_default.h\"\n#include \"ubjson/ubjson_writer.h\"\n#include \"debugger/debugger_factory.h\"\n#include \"debugger/debugger_server.h\"\n#include \"debugger/debugger_message.h\"\n\ntypedef struct _debugger_server_t {\n  darray_t debuggers;\n  debugger_t* debugger;\n  tk_thread_t* thread;\n\n  /*等待退出*/\n  bool_t quiting;\n  /*退出完成*/\n  bool_t quited;\n  /*启动完成*/\n  bool_t started;\n  bool_t single_mode;\n  tk_istream_t* in;\n  tk_ostream_t* out;\n  tk_iostream_t* io;\n  tk_mutex_nest_t* mutex;\n\n  /*读取数据的缓冲区*/\n  void* buff;\n  uint32_t capacity;\n} debugger_server_t;\n\nstatic bool_t s_single_mode = FALSE;\nstatic bool_t s_server_running = FALSE;\nstatic debugger_server_t* s_debugger_server = NULL;\n\nstatic void* debugger_server_run(void* ctx);\nstatic ret_t debugger_server_send_object(debugger_server_t* server, debugger_resp_t* resp,\n                                         tk_object_t* obj);\n\nstatic debugger_server_t* debugger_server_create(tk_iostream_t* io, bool_t single_mode) {\n  debugger_server_t* server = TKMEM_ZALLOC(debugger_server_t);\n  return_value_if_fail(server != NULL, NULL);\n\n  assert(io != NULL);\n\n  server->io = io;\n  server->single_mode = single_mode;\n  server->in = tk_iostream_get_istream(io);\n  server->out = tk_iostream_get_ostream(io);\n  darray_init(&(server->debuggers), 5, (tk_destroy_t)tk_object_unref, NULL);\n\n  server->mutex = tk_mutex_nest_create();\n  goto_error_if_fail(server->mutex != NULL);\n\n  server->thread = tk_thread_create(debugger_server_run, server);\n  goto_error_if_fail(server->thread != NULL);\n  tk_thread_start(server->thread);\n\n  while (!(server->started)) {\n    sleep_ms(100);\n  }\n  log_debug(\"debugger_server_thread started\\n\");\n\n  return server;\n\nerror:\n  TK_OBJECT_UNREF(io);\n  darray_deinit(&(server->debuggers));\n  TKMEM_FREE(server);\n\n  return NULL;\n}\n\nstatic ret_t debugger_server_extend(debugger_server_t* server, uint32_t size) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(server != NULL, RET_BAD_PARAMS);\n\n  if (server->capacity < size) {\n    void* buff = TKMEM_REALLOC(server->buff, size);\n    if (buff != NULL) {\n      server->buff = buff;\n      server->capacity = size;\n    } else {\n      ret = RET_FAIL;\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t debugger_server_write_data(tk_ostream_t* out, const void* data, uint32_t size) {\n  return tk_ostream_write_len(out, data, size, DEBUGGER_IO_WRITE_TIMEOUT) == size ? RET_OK : RET_IO;\n}\n\nstatic ret_t debugger_server_read_data(tk_istream_t* in, void* data, uint32_t size) {\n  return tk_istream_read_len(in, data, size, DEBUGGER_IO_READ_TIMEOUT) == size ? RET_OK : RET_IO;\n}\n\nstatic ret_t debugger_server_send_data_impl(tk_ostream_t* out, debugger_resp_t* resp,\n                                            binary_data_t* data) {\n  ret_t ret = RET_FAIL;\n  resp->version = DEBUGGER_VERSION;\n  resp->size = data != NULL ? data->size : 0;\n\n  ret = debugger_server_write_data(out, resp, sizeof(*resp));\n  return_value_if_fail(ret == RET_OK, RET_IO);\n\n  if (resp->size > 0) {\n    ret = debugger_server_write_data(out, data->data, data->size);\n  }\n\n  return ret;\n}\n\nstatic ret_t debugger_server_send_data(debugger_server_t* server, debugger_resp_t* resp,\n                                       binary_data_t* data) {\n  ret_t ret = RET_FAIL;\n\n  if (tk_mutex_nest_lock(server->mutex) == RET_OK) {\n    ret = debugger_server_send_data_impl(server->out, resp, data);\n    tk_mutex_nest_unlock(server->mutex);\n  }\n\n  return ret;\n}\n\nstatic ret_t debugger_server_send_object(debugger_server_t* server, debugger_resp_t* resp,\n                                         tk_object_t* obj) {\n  wbuffer_t wb;\n  ret_t ret = RET_FAIL;\n  ubjson_writer_t writer;\n  binary_data_t data = {0, NULL};\n  return_value_if_fail(wbuffer_init_extendable(&wb) != NULL, RET_OOM);\n\n  if (obj != NULL) {\n    ubjson_writer_init(&writer, (ubjson_write_callback_t)wbuffer_write_binary, &wb);\n    ret = ubjson_writer_write_object(&writer, obj);\n    assert(ret == RET_OK);\n    goto_error_if_fail(ret == RET_OK);\n  } else {\n    wbuffer_write_string(&wb, \"{}\");\n  }\n\n  data.data = wb.data;\n  data.size = wb.cursor;\n  ret = debugger_server_send_data(server, resp, &data);\n\nerror:\n  wbuffer_deinit(&wb);\n\n  return ret;\n}\n\nstatic ret_t debugger_server_read_request_impl(debugger_server_t* server, debugger_req_t* req) {\n  tk_istream_t* in = server->in;\n  ret_t ret = debugger_server_read_data(in, req, sizeof(*req));\n  return_value_if_fail(ret == RET_OK, RET_IO);\n\n  assert(req->version == DEBUGGER_VERSION);\n  return_value_if_fail(debugger_server_extend(server, req->size) == RET_OK, RET_OOM);\n\n  if (req->size > 0) {\n    ret = debugger_server_read_data(in, server->buff, req->size);\n  } else {\n    ret = RET_OK;\n  }\n\n  return ret;\n}\n\nstatic ret_t debugger_server_read_request(debugger_server_t* server, debugger_req_t* req) {\n  ret_t ret = tk_istream_wait_for_data(server->in, 1000);\n\n  if (ret != RET_OK) {\n    return ret;\n  }\n\n  if (tk_mutex_nest_lock(server->mutex) == RET_OK) {\n    ret = debugger_server_read_request_impl(server, req);\n    tk_mutex_nest_unlock(server->mutex);\n  }\n\n  return ret;\n}\n\nstatic ret_t debugger_server_get_debuggers(debugger_server_t* server, str_t* debuggers) {\n  value_t v;\n  char buff[64];\n  uint32_t i = 0;\n  return_value_if_fail(server != NULL, RET_BAD_PARAMS);\n\n  if (tk_mutex_nest_lock(server->mutex) == RET_OK) {\n    for (i = 0; i < server->debuggers.size; i++) {\n      debugger_t* iter = (debugger_t*)darray_get(&(server->debuggers), i);\n      if (tk_object_get_prop(TK_OBJECT(iter), DEBUGGER_PROP_CODE_ID, &v) == RET_OK) {\n        str_append_more(debuggers, value_str_ex(&v, buff, sizeof(buff) - 1), \"\\n\", NULL);\n      }\n    }\n    tk_mutex_nest_unlock(server->mutex);\n  }\n\n  return RET_OK;\n}\n\nstatic debugger_t* debugger_server_find(debugger_server_t* server, const char* code_id) {\n  uint32_t i = 0;\n  debugger_t* debugger = NULL;\n  return_value_if_fail(server != NULL, NULL);\n\n  if (tk_mutex_nest_lock(server->mutex) == RET_OK) {\n    if (server->single_mode) {\n      if (code_id != NULL && server->debugger != NULL &&\n          debugger_match(server->debugger, code_id)) {\n        debugger = server->debugger;\n      }\n    } else {\n      for (i = 0; i < server->debuggers.size; i++) {\n        debugger_t* iter = (debugger_t*)darray_get(&(server->debuggers), i);\n        if (debugger_match(iter, code_id)) {\n          debugger = iter;\n          break;\n        }\n      }\n    }\n    tk_mutex_nest_unlock(server->mutex);\n  }\n\n  return debugger;\n}\n\nstatic ret_t debugger_server_on_events(void* ctx, event_t* e) {\n  ret_t ret = RET_OK;\n  debugger_resp_t msg;\n  tk_object_t* obj = NULL;\n  tk_ostream_t* out = NULL;\n  debugger_t* debugger = DEBUGGER(e->target);\n  debugger_server_t* server = (debugger_server_t*)ctx;\n  return_value_if_fail(debugger != NULL && server != NULL, RET_BAD_PARAMS);\n\n  out = server->out;\n  return_value_if_fail(out != NULL, RET_BAD_PARAMS);\n\n  obj = object_default_create();\n  return_value_if_fail(obj != NULL, RET_BAD_PARAMS);\n\n  memset(&msg, 0x00, sizeof(msg));\n  msg.code = e->type;\n  msg.error = RET_OK;\n\n  switch (e->type) {\n    case DEBUGGER_RESP_MSG_LOG: {\n      debugger_log_event_t* event = debugger_log_event_cast(e);\n      tk_object_set_prop_int(obj, STR_DEBUGGER_EVENT_PROP_LINE, event->line);\n      tk_object_set_prop_str(obj, STR_DEBUGGER_EVENT_PROP_MESSAGE, event->message);\n      ret = debugger_server_send_object(server, &msg, obj);\n      break;\n    }\n    case DEBUGGER_RESP_MSG_ERROR: {\n      debugger_error_event_t* event = debugger_error_event_cast(e);\n      tk_object_set_prop_int(obj, STR_DEBUGGER_EVENT_PROP_LINE, event->line);\n      tk_object_set_prop_str(obj, STR_DEBUGGER_EVENT_PROP_MESSAGE, event->message);\n      ret = debugger_server_send_object(server, &msg, obj);\n      break;\n    }\n    case DEBUGGER_RESP_MSG_BREAKED: {\n      debugger_breaked_event_t* event = debugger_breaked_event_cast(e);\n      tk_object_set_prop_int(obj, STR_DEBUGGER_EVENT_PROP_LINE, event->line);\n      ret = debugger_server_send_object(server, &msg, obj);\n      break;\n    }\n    case DEBUGGER_RESP_MSG_COMPLETED: {\n      debugger_server_send_data(server, &msg, NULL);\n      break;\n    }\n    default: {\n      log_debug(\"not supported event:%d\\n\", (int)(e->type));\n      break;\n    }\n  }\n\n  TK_OBJECT_UNREF(obj);\n\n  return ret == RET_OK ? RET_OK : RET_REMOVE;\n}\n\nstatic debugger_t* debugger_server_init_debugger(debugger_server_t* server, debugger_t* debugger) {\n  ret_t ret = RET_FAIL;\n  return_value_if_fail(debugger != NULL, NULL);\n\n  ret = darray_push(&(server->debuggers), debugger);\n  if (ret != RET_OK) {\n    OBJECT_UNREF(debugger);\n  } else {\n    emitter_on(EMITTER(debugger), DEBUGGER_RESP_MSG_LOG, debugger_server_on_events, server);\n    emitter_on(EMITTER(debugger), DEBUGGER_RESP_MSG_ERROR, debugger_server_on_events, server);\n    emitter_on(EMITTER(debugger), DEBUGGER_RESP_MSG_BREAKED, debugger_server_on_events, server);\n    emitter_on(EMITTER(debugger), DEBUGGER_RESP_MSG_COMPLETED, debugger_server_on_events, server);\n    server->debugger = debugger;\n  }\n\n  return debugger;\n}\n\nret_t debugger_server_create_debugger(debugger_server_t* server, const char* lang,\n                                      const char* code_id) {\n  debugger_t* debugger = NULL;\n  return_value_if_fail(server != NULL, RET_BAD_PARAMS);\n\n  if (tk_mutex_nest_lock(server->mutex) == RET_OK) {\n    debugger = debugger_server_find(server, code_id);\n    if (debugger == NULL) {\n      debugger = debugger_factory_attach_debugger(lang, code_id);\n      debugger_server_init_debugger(server, debugger);\n    }\n\n    tk_mutex_nest_unlock(server->mutex);\n  }\n\n  return debugger != NULL ? RET_OK : RET_FAIL;\n}\n\nstatic ret_t debugger_server_attach_debugger(debugger_server_t* server, const char* arg) {\n  char lang[TK_NAME_LEN + 1];\n  const char* code_id = NULL;\n  return_value_if_fail(server != NULL, RET_BAD_PARAMS);\n  code_id = strchr(arg, ':');\n  return_value_if_fail(code_id != NULL, RET_BAD_PARAMS);\n\n  tk_strncpy_s(lang, TK_NAME_LEN, arg, code_id - arg);\n  code_id++;\n\n  return debugger_server_create_debugger(server, lang, code_id);\n}\n\nstatic ret_t debugger_server_launch_debugger(debugger_server_t* server, binary_data_t* arg) {\n  const char* code = NULL;\n  char lang[TK_NAME_LEN + 1];\n  debugger_t* debugger = NULL;\n  return_value_if_fail(server != NULL, RET_BAD_PARAMS);\n  code = strchr((char*)(arg->data), ':');\n  return_value_if_fail(code != NULL, RET_BAD_PARAMS);\n\n  tk_strncpy_s(lang, TK_NAME_LEN, (char*)(arg->data), code - (char*)(arg->data));\n  code++;\n  if (tk_mutex_nest_lock(server->mutex) == RET_OK) {\n    binary_data_t data;\n\n    data.data = (uint8_t*)code;\n    data.size = arg->size - (code - (char*)(arg->data));\n    debugger = debugger_factory_launch_debugger(lang, &data);\n    debugger_server_init_debugger(server, debugger);\n\n    tk_mutex_nest_unlock(server->mutex);\n  }\n\n  return debugger != NULL ? RET_OK : RET_FAIL;\n}\n\nstatic ret_t debugger_server_destroy(debugger_server_t* server) {\n  return_value_if_fail(server != NULL, RET_BAD_PARAMS);\n\n  if (s_debugger_server == server) {\n    s_debugger_server = NULL;\n  }\n\n  server->quiting = TRUE;\n  while (!server->quited) {\n    sleep_ms(100);\n  }\n\n  tk_mutex_nest_destroy(server->mutex);\n  server->mutex = NULL;\n\n  darray_deinit(&(server->debuggers));\n  tk_thread_destroy(server->thread);\n  TK_OBJECT_UNREF(server->io);\n  TKMEM_FREE(server->buff);\n  TKMEM_FREE(server);\n\n  return RET_OK;\n}\n\nstatic ret_t debugger_server_dispatch(debugger_server_t* server) {\n  ret_t ret = RET_OK;\n  debugger_req_t req;\n  debugger_resp_t resp;\n  debugger_t* debugger = NULL;\n\n  server->started = TRUE;\n  while (!(server->quiting)) {\n    ret = debugger_server_read_request(server, &req);\n    if (ret == RET_TIMEOUT) {\n      continue;\n    } else if (ret != RET_OK) {\n      break;\n    }\n    resp.size = 0;\n    resp.code = req.code;\n    resp.error = RET_OK;\n\n    if (req.code == DEBUGGER_REQ_ATTACH) {\n      resp.error = debugger_server_attach_debugger(server, (const char*)(server->buff));\n      break_if_fail(debugger_server_send_data(server, &resp, NULL) == RET_OK);\n      continue;\n    } else if (req.code == DEBUGGER_REQ_LAUNCH) {\n      binary_data_t code = {req.size, server->buff};\n      resp.error = debugger_server_launch_debugger(server, &code);\n      break_if_fail(debugger_server_send_data(server, &resp, NULL) == RET_OK);\n      continue;\n    }\n\n    if (server->debugger == NULL) {\n      resp.error = RET_NOT_FOUND;\n      break_if_fail(debugger_server_send_data(server, &resp, NULL) == RET_OK);\n      continue;\n    }\n\n    debugger = server->debugger;\n\n    switch (req.code) {\n      case DEBUGGER_REQ_STOP: {\n        resp.error = debugger_stop(debugger);\n        break;\n      }\n      case DEBUGGER_REQ_PAUSE: {\n        resp.error = debugger_pause(debugger);\n        break;\n      }\n      case DEBUGGER_REQ_IS_PAUSED: {\n        resp.error = debugger_is_paused(debugger) ? RET_OK : RET_FAIL;\n        break;\n      }\n      case DEBUGGER_REQ_NEXT: {\n        resp.error = debugger_next(debugger);\n        break;\n      }\n      case DEBUGGER_REQ_STEP_IN: {\n        resp.error = debugger_step_in(debugger);\n        break;\n      }\n      case DEBUGGER_REQ_STEP_OUT: {\n        resp.error = debugger_step_out(debugger);\n        break;\n      }\n      case DEBUGGER_REQ_STEP_OVER: {\n        resp.error = debugger_step_over(debugger);\n        break;\n      }\n      case DEBUGGER_REQ_CONTINUE: {\nresp.error = ",
    "raw_res": "0;",
    "prompt_res": "debugger_continue(debugger);",
    "gt": "debugger_continue(debugger);"
  },
  {
    "id": 604,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/fscript_ext/fscript_iostream_file.c",
    "input": "﻿/**\n * File:   fscript_iostream_file.c\n * Author: AWTK Develop Team\n * Brief:  iostream_file functions for fscript\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2021-01-06 Li XianJing <lixianjing@zlg.cn> created\n *\n */\n\n#include \"tkc/buffer.h\"\n#include \"tkc/fscript.h\"\n#include \"streams/file/istream_file.h\"\n#include \"streams/file/ostream_file.h\"\n\nstatic ret_t func_istream_file_create(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  const char* mode = NULL;\n  const char* filename = NULL;\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\nfilename = ",
    "raw_res": "fscript_get_string(args->params[0]);",
    "prompt_res": "value_str(args->args);",
    "gt": "value_str(args->args);"
  },
  {
    "id": 609,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/fscript_ext/fscript_bits.c",
    "input": "﻿/**\n * File:   fscript_bits.c\n * Author: AWTK Develop Team\n * Brief:  bits functions for fscript\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2021-01-03 Li XianJing <lixianjing@zlg.cn> created\n *\n */\n\n#include \"tkc/fscript.h\"\n\ntypedef enum _func_type_t {\n  FUNC_LSHIFT = 1,\n  FUNC_RSHIFT = 2,\n  FUNC_BIT_CLEAR = 3,\n} func_type_t;\n\nstatic ret_t func_lshift(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t n = 0;\n  value_t* value = NULL;\n  ret_t ret = RET_OK;\n\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value = args->args;\n  n = value_uint32(args->args + 1);\n\n  switch (value->type) {\n    case VALUE_TYPE_INT8: {\n      value_set_int8(result, value_int8(value) << n);\n      break;\n    }\n    case VALUE_TYPE_UINT8: {\n      value_set_uint8(result, value_uint8(value) << n);\n      break;\n    }\n    case VALUE_TYPE_INT16: {\n      value_set_int16(result, value_int16(value) << n);\n      break;\n    }\n    case VALUE_TYPE_UINT16: {\n      value_set_uint16(result, value_uint16(value) << n);\n      break;\n    }\n    case VALUE_TYPE_INT32: {\n      value_set_int32(result, value_int32(value) << n);\n      break;\n    }\n    case VALUE_TYPE_UINT32: {\n      value_set_uint32(result, value_uint32(value) << n);\n      break;\n    }\n    case VALUE_TYPE_INT64: {\n      value_set_int64(result, value_int64(value) << n);\n      break;\n    }\n    case VALUE_TYPE_UINT64: {\n      value_set_uint64(result, value_uint64(value) << n);\n      break;\n    }\n    default: {\n      ret = RET_BAD_PARAMS;\n      break;\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t func_rshift(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t n = 0;\n  value_t* value = NULL;\n  ret_t ret = RET_OK;\n\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value = args->args;\n  n = value_uint32(args->args + 1);\n\n  switch (value->type) {\n    case VALUE_TYPE_INT8: {\n      value_set_int8(result, value_int8(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_UINT8: {\n      value_set_uint8(result, value_uint8(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_INT16: {\n      value_set_int16(result, value_int16(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_UINT16: {\n      value_set_uint16(result, value_uint16(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_INT32: {\n      value_set_int32(result, value_int32(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_UINT32: {\n      value_set_uint32(result, value_uint32(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_INT64: {\n      value_set_int64(result, value_int64(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_UINT64: {\n      value_set_uint64(result, value_uint64(value) >> n);\n      break;\n    }\n    default: {\n      ret = RET_BAD_PARAMS;\n      break;\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t func_bit_set(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t n = 0;\n  value_t* value = NULL;\n  ret_t ret = RET_OK;\n\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value = args->args;\n  n = value_uint32(args->args + 1);\n\n  switch (value->type) {\n    case VALUE_TYPE_INT8: {\n      int8_t vv = value_int8(value);\n      TK_SET_BIT(vv, n);\n      value_set_int8(result, vv);\n      break;\n    }\n    case VALUE_TYPE_UINT8: {\n      uint8_t vv = value_uint8(value);\n      TK_SET_BIT(vv, n);\n      value_set_uint8(result, vv);\n      break;\n    }\n    case VALUE_TYPE_INT16: {\n      int16_t vv = value_int16(value);\n      TK_SET_BIT(vv, n);\n      value_set_int16(result, vv);\n      break;\n    }\n    case VALUE_TYPE_UINT16: {\nuint16_t vv = ",
    "raw_res": "0;",
    "prompt_res": "value_uint16(value);",
    "gt": "value_uint16(value);"
  },
  {
    "id": 613,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/fscript_ext/fscript_bits.c",
    "input": "﻿/**\n * File:   fscript_bits.c\n * Author: AWTK Develop Team\n * Brief:  bits functions for fscript\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2021-01-03 Li XianJing <lixianjing@zlg.cn> created\n *\n */\n\n#include \"tkc/fscript.h\"\n\ntypedef enum _func_type_t {\n  FUNC_LSHIFT = 1,\n  FUNC_RSHIFT = 2,\n  FUNC_BIT_CLEAR = 3,\n} func_type_t;\n\nstatic ret_t func_lshift(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t n = 0;\n  value_t* value = NULL;\n  ret_t ret = RET_OK;\n\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value = args->args;\n  n = value_uint32(args->args + 1);\n\n  switch (value->type) {\n    case VALUE_TYPE_INT8: {\n      value_set_int8(result, value_int8(value) << n);\n      break;\n    }\n    case VALUE_TYPE_UINT8: {\n      value_set_uint8(result, value_uint8(value) << n);\n      break;\n    }\n    case VALUE_TYPE_INT16: {\n      value_set_int16(result, value_int16(value) << n);\n      break;\n    }\n    case VALUE_TYPE_UINT16: {\n      value_set_uint16(result, value_uint16(value) << n);\n      break;\n    }\n    case VALUE_TYPE_INT32: {\n      value_set_int32(result, value_int32(value) << n);\n      break;\n    }\n    case VALUE_TYPE_UINT32: {\n      value_set_uint32(result, value_uint32(value) << n);\n      break;\n    }\n    case VALUE_TYPE_INT64: {\n      value_set_int64(result, value_int64(value) << n);\n      break;\n    }\n    case VALUE_TYPE_UINT64: {\n      value_set_uint64(result, value_uint64(value) << n);\n      break;\n    }\n    default: {\n      ret = RET_BAD_PARAMS;\n      break;\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t func_rshift(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t n = 0;\n  value_t* value = NULL;\n  ret_t ret = RET_OK;\n\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value = args->args;\n  n = value_uint32(args->args + 1);\n\n  switch (value->type) {\n    case VALUE_TYPE_INT8: {\n      value_set_int8(result, value_int8(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_UINT8: {\n      value_set_uint8(result, value_uint8(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_INT16: {\n      value_set_int16(result, value_int16(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_UINT16: {\n      value_set_uint16(result, value_uint16(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_INT32: {\n      value_set_int32(result, value_int32(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_UINT32: {\n      value_set_uint32(result, value_uint32(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_INT64: {\n      value_set_int64(result, value_int64(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_UINT64: {\n      value_set_uint64(result, value_uint64(value) >> n);\n      break;\n    }\n    default: {\n      ret = RET_BAD_PARAMS;\n      break;\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t func_bit_set(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t n = 0;\n  value_t* value = NULL;\n  ret_t ret = RET_OK;\n\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value = args->args;\n  n = value_uint32(args->args + 1);\n\n  switch (value->type) {\n    case VALUE_TYPE_INT8: {\n      int8_t vv = value_int8(value);\n      TK_SET_BIT(vv, n);\n      value_set_int8(result, vv);\n      break;\n    }\n    case VALUE_TYPE_UINT8: {\n      uint8_t vv = value_uint8(value);\n      TK_SET_BIT(vv, n);\n      value_set_uint8(result, vv);\n      break;\n    }\n    case VALUE_TYPE_INT16: {\n      int16_t vv = value_int16(value);\n      TK_SET_BIT(vv, n);\n      value_set_int16(result, vv);\n      break;\n    }\n    case VALUE_TYPE_UINT16: {\n      uint16_t vv = value_uint16(value);\n      TK_SET_BIT(vv, n);\n      value_set_uint16(result, vv);\n      break;\n    }\n    case VALUE_TYPE_INT32: {\n      int32_t vv = value_int32(value);\n      TK_SET_BIT(vv, n);\n      value_set_int32(result, vv);\n      break;\n    }\n    case VALUE_TYPE_UINT32: {\n      uint32_t vv = value_uint32(value);\n      TK_SET_BIT(vv, n);\n      value_set_uint32(result, vv);\n      break;\n    }\n    case VALUE_TYPE_INT64: {\n      int64_t vv = value_int64(value);\n      TK_SET_BIT(vv, n);\n      value_set_int64(result, vv);\n      break;\n    }\n    case VALUE_TYPE_UINT64: {\nuint64_t vv = ",
    "raw_res": "0;",
    "prompt_res": "value_uint64(value);",
    "gt": "value_uint64(value);"
  },
  {
    "id": 622,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/fscript_ext/fscript_rbuffer.c",
    "input": "﻿/**\n * File:   fscript_rbuffer.c\n * Author: AWTK Develop Team\n * Brief:  rbuffer functions for fscript\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2021-01-04 Li XianJing <lixianjing@zlg.cn> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/buffer.h\"\n#include \"tkc/fscript.h\"\n#include \"tkc/object_rbuffer.h\"\n#include \"fscript_utils.h\"\n\nstatic ret_t func_rbuffer_create(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t size = 0;\n  const uint8_t* data = NULL;\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n  FSCRIPT_FUNC_CHECK(fargs_get_data_and_size(args, &data, &size) == RET_OK, RET_BAD_PARAMS);\n\n  value_set_object(result, object_rbuffer_create(data, size));\n  result->free_handle = TRUE;\n\n  return RET_OK;\n}\n\nstatic ret_t func_rbuffer_skip(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  object_rbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  obj = OBJECT_RBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->rbuffer != NULL, RET_BAD_PARAMS);\n\n  value_set_bool(result, rbuffer_skip(obj->rbuffer, value_int32(args->args + 1)) == RET_OK);\n\n  return RET_OK;\n}\n\nstatic ret_t func_rbuffer_rewind(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  object_rbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = OBJECT_RBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->rbuffer != NULL, RET_BAD_PARAMS);\n\n  rbuffer_rewind(obj->rbuffer);\n  value_set_bool(result, TRUE);\n\n  return RET_OK;\n}\n\nstatic ret_t func_rbuffer_get_data(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  object_rbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = OBJECT_RBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->rbuffer != NULL, RET_BAD_PARAMS);\n\n  value_set_pointer(result, (void*)(obj->rbuffer->data));\n\n  return RET_OK;\n}\n\nstatic ret_t func_rbuffer_get_cursor(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  object_rbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = OBJECT_RBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->rbuffer != NULL, RET_BAD_PARAMS);\n\n  value_set_uint32(result, obj->rbuffer->cursor);\n\n  return RET_OK;\n}\n\nstatic ret_t func_rbuffer_get_capacity(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  object_rbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = OBJECT_RBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->rbuffer != NULL, RET_BAD_PARAMS);\n\n  value_set_uint32(result, obj->rbuffer->capacity);\n\n  return RET_OK;\n}\n\nstatic ret_t func_rbuffer_read_uint8(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint8_t v = 0;\n  ret_t ret = RET_OK;\n  object_rbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = OBJECT_RBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->rbuffer != NULL, RET_BAD_PARAMS);\n\n  ret = rbuffer_read_uint8(obj->rbuffer, &v);\n  value_set_uint8(result, v);\n\n  return ret;\n}\n\nstatic ret_t func_rbuffer_read_uint16(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint16_t v = 0;\n  ret_t ret = RET_OK;\n  object_rbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = OBJECT_RBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->rbuffer != NULL, RET_BAD_PARAMS);\n\n  ret = rbuffer_read_uint16(obj->rbuffer, &v);\n  value_set_uint16(result, v);\n\n  return ret;\n}\n\nstatic ret_t func_rbuffer_read_uint32(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t v = 0;\n  ret_t ret = RET_OK;\n  object_rbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = OBJECT_RBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->rbuffer != NULL, RET_BAD_PARAMS);\n\n  ret = rbuffer_read_uint32(obj->rbuffer, &v);\n  value_set_uint32(result, v);\n\n  return ret;\n}\n\nstatic ret_t func_rbuffer_read_uint64(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint64_t v = 0;\n  ret_t ret = RET_OK;\n  object_rbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = OBJECT_RBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->rbuffer != NULL, RET_BAD_PARAMS);\n\n  ret = rbuffer_read_uint64(obj->rbuffer, &v);\n  value_set_uint64(result, v);\n\n  return ret;\n}\n\nstatic ret_t func_rbuffer_read_int8(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint8_t v = 0;\n  ret_t ret = RET_OK;\n  object_rbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = OBJECT_RBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->rbuffer != NULL, RET_BAD_PARAMS);\n\n  ret = rbuffer_read_uint8(obj->rbuffer, &v);\n  value_set_int8(result, v);\n\n  return ret;\n}\n\nstatic ret_t func_rbuffer_read_int16(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint16_t v = 0;\n  ret_t ret = RET_OK;\n  object_rbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = OBJECT_RBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->rbuffer != NULL, RET_BAD_PARAMS);\n\n  ret = rbuffer_read_uint16(obj->rbuffer, &v);\n  value_set_int16(result, v);\n\n  return ret;\n}\n\nstatic ret_t func_rbuffer_read_int32(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t v = 0;\n  ret_t ret = RET_OK;\n  object_rbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = OBJECT_RBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->rbuffer != NULL, RET_BAD_PARAMS);\n\n  ret = rbuffer_read_uint32(obj->rbuffer, &v);\n  value_set_int32(result, v);\n\n  return ret;\n}\n\nstatic ret_t func_rbuffer_read_int64(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint64_t v = 0;\n  ret_t ret = RET_OK;\n  object_rbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = OBJECT_RBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->rbuffer != NULL, RET_BAD_PARAMS);\n\n  ret = rbuffer_read_uint64(obj->rbuffer, &v);\n  value_set_int64(result, v);\n\n  return ret;\n}\n\nstatic ret_t func_rbuffer_read_float(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  float v = 0;\n  ret_t ret = RET_OK;\n  object_rbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = OBJECT_RBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->rbuffer != NULL, RET_BAD_PARAMS);\n\n  ret = rbuffer_read_float(obj->rbuffer, &v);\n  value_set_float(result, v);\n\n  return ret;\n}\n\nstatic ret_t func_rbuffer_read_double(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  double v = 0;\n  ret_t ret = RET_OK;\n  object_rbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = OBJECT_RBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->rbuffer != NULL, RET_BAD_PARAMS);\n\n  ret = rbuffer_read_double(obj->rbuffer, &v);\n  value_set_double(result, v);\n\n  return ret;\n}\n\nstatic ret_t func_rbuffer_read_string(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  const char* v = 0;\n  ret_t ret = RET_OK;\n  object_rbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = OBJECT_RBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->rbuffer != NULL, RET_BAD_PARAMS);\n\n  ret = rbuffer_read_string(obj->rbuffer, &v);\n  value_set_str(result, v);\n\n  return ret;\n}\n\nstatic ret_t func_rbuffer_read_binary(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t size = 0;\n  ret_t ret = RET_OK;\n  const uint8_t* data = NULL;\n  object_rbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  obj = OBJECT_RBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->rbuffer != NULL, RET_BAD_PARAMS);\n  size = value_uint32(args->args + 1);\n  return_value_if_fail(size > 0, RET_BAD_PARAMS);\n\n  data = obj->rbuffer->data + obj->rbuffer->cursor;\nret = ",
    "raw_res": "0;",
    "prompt_res": "rbuffer_skip(obj->rbuffer, size);",
    "gt": "rbuffer_skip(obj->rbuffer, size);"
  },
  {
    "id": 623,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/fscript_ext/fscript_fs.c",
    "input": "﻿/**\n * File:   fscript_fs.c\n * Author: AWTK Develop Team\n * Brief:  fs functions for fscript\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2021-01-07 Li XianJing <lixianjing@zlg.cn> created\n *\n */\n\n#include \"tkc/fs.h\"\n#include \"tkc/path.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/fscript.h\"\n#include \"tkc/object_array.h\"\n#include \"tkc/object_default.h\"\n\nstatic ret_t func_file_read_text(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t size = 0;\n  char* content = NULL;\n  const char* filename = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\nfilename = ",
    "raw_res": "fscript_get_string(args->args[0]);",
    "prompt_res": "value_str(args->args);",
    "gt": "value_str(args->args);"
  },
  {
    "id": 652,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/fscript_ext/fscript_array.c",
    "input": "﻿/**\n * File:   fscript_array.c\n * Author: AWTK Develop Team\n * Brief:  array functions for fscript\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2021-01-03 Li XianJing <lixianjing@zlg.cn> created\n *\n */\n\n#include \"tkc/fscript.h\"\n#include \"tkc/object_array.h\"\nstatic ret_t func_array_create(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  tk_object_t* obj = object_array_create();\n  value_set_object(result, obj);\n  result->free_handle = TRUE;\n\n  for (i = 0; i < args->size; i++) {\n    ret_t ret = object_array_push(obj, args->args + i);\n    if (ret != RET_OK) {\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic value_type_t value_type_from_str(const char* type) {\n  if (type != NULL) {\n    if (*type == 'i') {\n      return VALUE_TYPE_INT32;\n    } else if (*type == 'd') {\n      return VALUE_TYPE_DOUBLE;\n    }\n  }\n\n  return VALUE_TYPE_STRING;\n}\n\nstatic ret_t func_array_create_with_str(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  tk_object_t* obj = NULL;\n  const char* str = NULL;\n  const char* sep = NULL;\n  const char* type = NULL;\n  FSCRIPT_FUNC_CHECK(args->size >= 2, RET_BAD_PARAMS);\n\nstr = ",
    "raw_res": "args->args[0].str;",
    "prompt_res": "value_str(args->args);",
    "gt": "value_str(args->args);"
  },
  {
    "id": 667,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/fscript_ext/fscript_iostream_inet.c",
    "input": "﻿/**\n * File:   fscript_iostream_inet.c\n * Author: AWTK Develop Team\n * Brief:  iostream_inet functions for fscript\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2021-01-06 Li XianJing <lixianjing@zlg.cn> created\n *\n */\n\n#include \"tkc/buffer.h\"\n#include \"tkc/fscript.h\"\n#include \"tkc/socket_helper.h\"\n#include \"streams/inet/iostream_tcp.h\"\n#include \"streams/inet/iostream_udp.h\"\n\nstatic ret_t func_iostream_tcp_create(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n#ifdef WITH_SOCKET\n  int port = 0;\n  int sock = 0;\n  const char* host = NULL;\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\nhost = ",
    "raw_res": "fscript_get_string(args->params[0]);",
    "prompt_res": "value_str(args->args);",
    "gt": "value_str(args->args);"
  },
  {
    "id": 669,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/fscript_ext/fscript_iostream_serial.c",
    "input": "﻿/**\n * File:   fscript_iostream_serial.c\n * Author: AWTK Develop Team\n * Brief:  iostream_serial functions for fscript\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2021-01-06 Li XianJing <lixianjing@zlg.cn> created\n *\n */\n\n#include \"tkc/buffer.h\"\n#include \"tkc/fscript.h\"\n#include \"tkc/socket_helper.h\"\n#include \"streams/serial/iostream_serial.h\"\n\nstatic ret_t func_iostream_serial_create(fscript_t* fscript, fscript_args_t* args,\n                                         value_t* result) {\n  int baudrate = 115200;\n  tk_object_t* obj = NULL;\n  const char* devname = NULL;\n  bytesize_t bytesize = eightbits;\n  parity_t parity = parity_none;\n  stopbits_t stopbits = stopbits_one;\n  flowcontrol_t flowcontrol = flowcontrol_none;\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n\ndevname = ",
    "raw_res": "fscript_get_string(args, 0);",
    "prompt_res": "value_str(args->args);",
    "gt": "value_str(args->args);"
  },
  {
    "id": 679,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/fscript_ext/fscript_istream.c",
    "input": "﻿/**\n * File:   fscript_istream.c\n * Author: AWTK Develop Team\n * Brief:  istream functions for fscript\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2021-01-06 Li XianJing <lixianjing@zlg.cn> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/buffer.h\"\n#include \"tkc/fscript.h\"\n#include \"tkc/istream.h\"\n\nstatic ret_t func_istream_seek(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t offset = 0;\n  tk_istream_t* istream = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  istream = TK_ISTREAM(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(istream != NULL && istream != NULL, RET_BAD_PARAMS);\noffset = ",
    "raw_res": "0;",
    "prompt_res": "value_uint32(args->args + 1);",
    "gt": "value_uint32(args->args + 1);"
  },
  {
    "id": 686,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/fscript_ext/fscript_module.c",
    "input": "﻿/**\n * File:   fscript_module.c\n * Author: AWTK Develop Team\n * Brief:  fscript module\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY { without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2022-03-29 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/fs.h\"\n#include \"tkc/mem.h\"\n#include \"tkc/value.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/data_reader.h\"\n#include \"fscript_ext/fscript_module.h\"\n\nstatic ret_t fscript_module_on_destroy(tk_object_t* obj) {\n  fscript_module_t* o = FSCRIPT_MODULE(obj);\n  return_value_if_fail(o != NULL && o->fscript != NULL, RET_BAD_PARAMS);\n\n  fscript_destroy(o->fscript);\n  o->fscript = NULL;\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_module_get_prop(tk_object_t* obj, const char* name, value_t* v) {\n  fscript_module_t* o = FSCRIPT_MODULE(obj);\n  return_value_if_fail(o != NULL && o->fscript != NULL, RET_BAD_PARAMS);\n\n  return tk_object_get_prop(o->fscript->funcs_def, name, v);\n}\n\nstatic ret_t fscript_module_foreach_prop(tk_object_t* obj, tk_visit_t on_prop, void* ctx) {\n  fscript_module_t* o = FSCRIPT_MODULE(obj);\n  return_value_if_fail(o != NULL && o->fscript != NULL, RET_BAD_PARAMS);\n\n  return tk_object_foreach_prop(o->fscript->funcs_def, on_prop, ctx);\n}\n\nstatic const object_vtable_t s_fscript_module_vtable = {\n    .type = \"fscript_module\",\n    .desc = \"fscript_module\",\n    .size = sizeof(fscript_module_t),\n    .is_collection = FALSE,\n    .on_destroy = fscript_module_on_destroy,\n    .get_prop = fscript_module_get_prop,\n    .foreach_prop = fscript_module_foreach_prop};\n\ntk_object_t* fscript_module_create_with_data(const char* data) {\n  value_t v;\n  fscript_t* fscript = NULL;\n  tk_object_t* o = tk_object_create(&s_fscript_module_vtable);\n  fscript_module_t* module = FSCRIPT_MODULE(o);\n  return_value_if_fail(module != NULL, NULL);\n  fscript = fscript_create(o, data);\n  goto_error_if_fail(fscript != NULL);\n\n  module->fscript = fscript;\n\n  value_set_int(&v, 0);\n  fscript_exec(fscript, &v);\n  value_reset(&v);\n\n  return o;\nerror:\n  TK_OBJECT_UNREF(o);\n\n  return NULL;\n}\n\ntk_object_t* fscript_module_create(const char* url) {\n  char* data = NULL;\n  uint32_t size = 0;\n  tk_object_t* o = NULL;\n  return_value_if_fail(url != NULL, NULL);\n  if (strstr(url, \"://\")) {\n    data = (char*)data_reader_read_all(url, &size);\n  } else {\n    data = file_read(url, &size);\n  }\n  return_value_if_fail(data != NULL, NULL);\n\n  o = fscript_module_create_with_data(data);\n  TKMEM_FREE(data);\n\n  return o;\n}\n\nfscript_module_t* fscript_module_cast(tk_object_t* obj) {\n  return_value_if_fail(obj != NULL && obj->vt == &s_fscript_module_vtable, NULL);\n\n  return (fscript_module_t*)(obj);\n}\n\nstatic ret_t func_require_str(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  const char* code = NULL;\n  tk_object_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\ncode = ",
    "raw_res": "value_to_str(args->data[0]);",
    "prompt_res": "value_str(args->args);",
    "gt": "value_str(args->args);"
  },
  {
    "id": 714,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/native_window/native_window_sdl.c",
    "input": "﻿/**\n * File:   native_window_sdl.h\n * Author: AWTK Develop Team\n * Brief:  native window sdl\n *\n * Copyright (c) 2019 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-07-21 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include <SDL.h>\n#include \"base/system_info.h\"\n#include \"base/window_manager.h\"\n\n#ifdef WITH_GPU_GL\n#ifndef WITHOUT_GLAD\n#include \"glad/glad.h\"\n#define loadGL gladLoadGL\n#else\n#define loadGL()\n#ifdef IOS\n#include <OpenGLES/gltypes.h>\n#include <OpenGLES/ES2/gl.h>\n#include <OpenGLES/ES2/glext.h>\n#define GL_ALPHA_TEST 0x0BC0\n#else\n#include <SDL_opengl.h>\n#include <SDL_opengl_glext.h>\n#endif /*IOS*/\n#endif /*WITHOUT_GLAD*/\n\n#endif /*WITH_GPU_GL*/\n\n#include \"lcd/lcd_sdl2.h\"\n#include \"lcd/lcd_nanovg.h\"\n#include \"lcd/lcd_sdl2_mono.h\"\n#include \"base/native_window.h\"\n\ntypedef struct _native_window_sdl_t {\n  native_window_t native_window;\n  bool_t is_init;\n  SDL_GLContext context;\n  SDL_Renderer* render;\n  SDL_Window* window;\n  canvas_t canvas;\n  SDL_Cursor* cursor;\n  SDL_Surface* cursor_surface;\n} native_window_sdl_t;\n\nstatic native_window_t* s_shared_win = NULL;\n\n#define NATIVE_WINDOW_SDL(win) ((native_window_sdl_t*)(win))\n\nstatic ret_t native_window_sdl_move(native_window_t* win, xy_t x, xy_t y) {\n  int oldx = 0;\n  int oldy = 0;\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n\n  win->rect.x = x;\n  win->rect.y = y;\n  SDL_GetWindowPosition(sdl->window, &oldx, &oldy);\n  if (oldx != x || oldy != y) {\n    SDL_SetWindowPosition(sdl->window, x, y);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_resize(native_window_t* win, wh_t w, wh_t h) {\n  lcd_t* lcd = NULL;\n  ret_t ret = RET_OK;\n  native_window_info_t info;\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n  return_value_if_fail(sdl != NULL, RET_BAD_PARAMS);\n  lcd = sdl->canvas.lcd;\n  native_window_get_info(win, &info);\n\n  win->rect.w = w;\n  win->rect.h = h;\n\n#if !defined(ANDROID) && !defined(IOS)\n  if (w != info.w || h != info.h) {\n#ifdef WIN32\n    w = w * win->ratio;\n    h = h * win->ratio;\n#endif /*WIN32*/\n\n    SDL_SetWindowSize(sdl->window, w, h);\n  }\n#endif /*ANDROID*/\n  if (lcd != NULL && (lcd->w != w || lcd->h != h)) {\n    ret = lcd_resize(lcd, w, h, 0);\n  }\n\n  return ret;\n}\n\nstatic ret_t native_window_sdl_set_orientation(native_window_t* win,\n                                               lcd_orientation_t old_orientation,\n                                               lcd_orientation_t new_orientation) {\n  wh_t w, h;\n  native_window_info_t info;\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n  return_value_if_fail(sdl != NULL, RET_BAD_PARAMS);\n  native_window_get_info(win, &info);\n  w = info.w;\n  h = info.h;\n  if (new_orientation == LCD_ORIENTATION_90 || new_orientation == LCD_ORIENTATION_270) {\n    w = info.h;\n    h = info.w;\n  }\n\n  win->rect.w = w;\n  win->rect.h = h;\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_minimize(native_window_t* win) {\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n\n  SDL_MinimizeWindow(sdl->window);\n\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_maximize(native_window_t* win) {\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n\n  SDL_MaximizeWindow(sdl->window);\n\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_restore(native_window_t* win) {\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n\n  SDL_RestoreWindow(sdl->window);\n\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_center(native_window_t* win) {\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n\n  SDL_SetWindowPosition(sdl->window, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED);\n\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_show_border(native_window_t* win, bool_t show) {\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n\n  SDL_SetWindowBordered(sdl->window, show);\n\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_set_fullscreen(native_window_t* win, bool_t fullscreen) {\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n\n  if (fullscreen) {\n    SDL_SetWindowFullscreen(sdl->window, SDL_WINDOW_FULLSCREEN_DESKTOP);\n  } else {\n    SDL_SetWindowFullscreen(sdl->window, 0);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_close(native_window_t* win) {\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n  lcd_t* lcd = sdl->canvas.lcd;\n\n  canvas_reset(&(sdl->canvas));\n  lcd_destroy(lcd);\n\n  if (sdl->render != NULL) {\n    SDL_DestroyRenderer(sdl->render);\n  }\n\n  if (sdl->context != NULL) {\n    SDL_GL_DeleteContext(sdl->context);\n  }\n\n  if (sdl->window != NULL) {\n    SDL_DestroyWindow(sdl->window);\n  }\n\n  sdl->render = NULL;\n  sdl->window = NULL;\n  sdl->context = NULL;\n\n  SDL_Quit();\n\n  return RET_OK;\n}\n\nstatic canvas_t* native_window_sdl_get_canvas(native_window_t* win) {\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n\n  return &(sdl->canvas);\n}\n\nstatic ret_t native_window_sdl_gl_make_current(native_window_t* win) {\n#ifdef WITH_GPU_GL\n  int fw = 0;\n  int fh = 0;\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n  SDL_Window* window = sdl->window;\n\n  SDL_GL_MakeCurrent(window, sdl->context);\n  SDL_GL_GetDrawableSize(window, &fw, &fh);\n\n  glViewport(0, 0, fw, fh);\n  if (!sdl->is_init) {\n    sdl->is_init = TRUE;\n    glClearColor(1.0f, 1.0f, 1.0f, 1.0f);\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);\n  } else {\n    glClear(GL_STENCIL_BUFFER_BIT);\n  }\n#endif /*WITH_GPU_GL*/\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_swap_buffer(native_window_t* win) {\n#ifdef WITH_GPU_GL\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n  SDL_GL_SwapWindow(sdl->window);\n#else\n#endif /*WITH_GPU_GL*/\n\n  return RET_OK;\n}\n\nextern ret_t tk_quit();\n\nstatic ret_t native_window_sdl_preprocess_event(native_window_t* win, event_t* e) {\n#if defined(ANDROID)\n  if (e->type == EVT_POINTER_DOWN || e->type == EVT_POINTER_MOVE || e->type == EVT_CLICK ||\n      e->type == EVT_POINTER_UP || e->type == EVT_CONTEXT_MENU) {\n    pointer_event_t* evt = pointer_event_cast(e);\n    evt->x /= win->ratio;\n    evt->y /= win->ratio;\n  } else if (e->type == EVT_KEY_DOWN) {\n    key_event_t* evt = key_event_cast(e);\n    if (evt->key == TK_KEY_AC_BACK) {\n      window_manager_back(window_manager());\n      if (widget_count_children(window_manager()) == 0) {\n        tk_quit();\n      }\n    }\n  }\n#endif /*ANDROID*/\n\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_get_info(native_window_t* win, native_window_info_t* info) {\n  int ww = 0;\n  int wh = 0;\n  int fw = 0;\n  int fh = 0;\n  int x = 0;\n  int y = 0;\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n  SDL_Window* window = sdl->window;\n\n  SDL_GetWindowPosition(window, &x, &y);\n  SDL_GetWindowSize(window, &ww, &wh);\n  SDL_GL_GetDrawableSize(window, &fw, &fh);\n\n  memset(info, 0x00, sizeof(*info));\n  info->x = x;\n  info->y = y;\n\n#if defined(ANDROID)\n  float dpi = 1;\n  SDL_GetDisplayDPI(0, &dpi, NULL, NULL);\n  float_t ratio = dpi / 160;\n\n  info->w = ww / ratio;\n  info->h = wh / ratio;\n  info->ratio = ratio;\n#elif defined(IOS)\n  info->w = ww;\n  info->h = wh;\n  info->ratio = (float_t)fw / (float_t)ww;\n#else\n  info->w = ww;\n  info->h = wh;\n  info->ratio = (float_t)fw / (float_t)ww;\n#endif /**/\n\n  win->rect.x = info->x;\n  win->rect.y = info->y;\n  win->rect.w = info->w;\n  win->rect.h = info->h;\n  win->ratio = info->ratio;\n\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_cursor_from_bitmap(native_window_t* win, bitmap_t* img) {\n  Uint32 depth = 32;\n  uint8_t* data = NULL;\n  uint32_t w = img->w;\n  uint32_t h = img->h;\n  uint32_t rmask = 0;\n  uint32_t gmask = 0;\n  uint32_t bmask = 0;\n  uint32_t amask = 0;\n  uint32_t pitch = 4 * w;\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n\n  if (img->format == BITMAP_FMT_BGRA8888) {\n    bmask = 0x000000ff;\n    gmask = 0x0000ff00;\n    rmask = 0x00ff0000;\n    amask = 0xff000000;\n  } else if (img->format == BITMAP_FMT_RGBA8888) {\n    rmask = 0x000000ff;\n    gmask = 0x0000ff00;\n    bmask = 0x00ff0000;\n    amask = 0xff000000;\n  } else {\n    /*\n     *assert(!\"not supported format!\");\n     */\n    return RET_FAIL;\n  }\n\n  if (sdl->cursor_surface != NULL) {\n    SDL_FreeSurface(sdl->cursor_surface);\n    sdl->cursor_surface = NULL;\n  }\n\n  data = bitmap_lock_buffer_for_read(img);\n  return_value_if_fail(data != NULL, RET_BAD_PARAMS);\n  sdl->cursor_surface =\n      SDL_CreateRGBSurfaceFrom(data, w, h, depth, pitch, rmask, gmask, bmask, amask);\n  bitmap_unlock_buffer(img);\n  return_value_if_fail(sdl->cursor_surface != NULL, RET_OOM);\n\n  sdl->cursor = SDL_CreateColorCursor(sdl->cursor_surface, 0, 0);\n  SDL_SetCursor(sdl->cursor);\n\n  return RET_OK;\n}\n\nstatic int map_to_sdl_cursor(const char* name) {\n  if (tk_str_eq(WIDGET_CURSOR_DEFAULT, name)) {\n    return SDL_SYSTEM_CURSOR_ARROW;\n  } else if (tk_str_eq(WIDGET_CURSOR_EDIT, name)) {\n    return SDL_SYSTEM_CURSOR_IBEAM;\n  } else if (tk_str_eq(WIDGET_CURSOR_HAND, name)) {\n    return SDL_SYSTEM_CURSOR_HAND;\n  } else if (tk_str_eq(WIDGET_CURSOR_WAIT, name)) {\n    return SDL_SYSTEM_CURSOR_WAIT;\n  } else if (tk_str_eq(WIDGET_CURSOR_CROSS, name)) {\n    return SDL_SYSTEM_CURSOR_CROSSHAIR;\n  } else if (tk_str_eq(WIDGET_CURSOR_NO, name)) {\n    return SDL_SYSTEM_CURSOR_NO;\n  } else if (tk_str_eq(WIDGET_CURSOR_SIZENWSE, name)) {\n    return SDL_SYSTEM_CURSOR_SIZENWSE;\n  } else if (tk_str_eq(WIDGET_CURSOR_SIZENESW, name)) {\n    return SDL_SYSTEM_CURSOR_SIZENESW;\n  } else if (tk_str_eq(WIDGET_CURSOR_SIZEWE, name)) {\n    return SDL_SYSTEM_CURSOR_SIZEWE;\n  } else if (tk_str_eq(WIDGET_CURSOR_SIZENS, name)) {\n    return SDL_SYSTEM_CURSOR_SIZENS;\n  } else if (tk_str_eq(WIDGET_CURSOR_SIZEALL, name)) {\n    return SDL_SYSTEM_CURSOR_SIZEALL;\n  }\n\n  return -1;\n}\n\nstatic ret_t native_window_sdl_set_cursor(native_window_t* win, const char* name, bitmap_t* img) {\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n\n  if (sdl->cursor != NULL) {\n    SDL_FreeCursor(sdl->cursor);\n    sdl->cursor = NULL;\n  }\n\n  if (system_info()->app_type == APP_DESKTOP) {\n    int system_cursor = map_to_sdl_cursor(name);\n    if (system_cursor >= 0) {\n      sdl->cursor = SDL_CreateSystemCursor((SDL_SystemCursor)system_cursor);\n      SDL_SetCursor(sdl->cursor);\n\n      return RET_OK;\n    }\n  } else if (img != NULL) {\n    return native_window_sdl_cursor_from_bitmap(win, img);\n  }\n\n  return RET_FAIL;\n}\n\nstatic const native_window_vtable_t s_native_window_vtable = {\n    .type = \"native_window_sdl\",\n    .move = native_window_sdl_move,\n    .resize = native_window_sdl_resize,\n    .set_orientation = native_window_sdl_set_orientation,\n    .minimize = native_window_sdl_minimize,\n    .maximize = native_window_sdl_maximize,\n    .restore = native_window_sdl_restore,\n    .center = native_window_sdl_center,\n    .show_border = native_window_sdl_show_border,\n    .set_fullscreen = native_window_sdl_set_fullscreen,\n    .get_info = native_window_sdl_get_info,\n    .preprocess_event = native_window_sdl_preprocess_event,\n    .swap_buffer = native_window_sdl_swap_buffer,\n    .gl_make_current = native_window_sdl_gl_make_current,\n    .set_cursor = native_window_sdl_set_cursor,\n    .get_canvas = native_window_sdl_get_canvas};\n\nstatic ret_t native_window_sdl_set_prop(tk_object_t* obj, const char* name, const value_t* v) {\n  native_window_t* win = NATIVE_WINDOW(obj);\n\n  if (tk_str_eq(NATIVE_WINDOW_PROP_SIZE, name)) {\n    rect_t* r = (rect_t*)value_pointer(v);\n    native_window_sdl_resize(win, r->w, r->h);\n\n    return RET_OK;\n  } else if (tk_str_eq(NATIVE_WINDOW_PROP_POSITION, name)) {\n    rect_t* r = (rect_t*)value_pointer(v);\n    native_window_sdl_move(win, r->x, r->y);\n\n    return RET_OK;\n  } else if (tk_str_eq(NATIVE_WINDOW_PROP_TITLE, name)) {\n    SDL_Window* sdlwin = (SDL_Window*)(win->handle);\n    const char* app_name = value_str(v);\n    SDL_SetWindowTitle(sdlwin, app_name);\n    system_info_set_app_name(system_info(), app_name);\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t native_window_sdl_get_prop(tk_object_t* obj, const char* name, value_t* v) {\n  native_window_t* win = NATIVE_WINDOW(obj);\n\n  if (tk_str_eq(NATIVE_WINDOW_PROP_SIZE, name) || tk_str_eq(NATIVE_WINDOW_PROP_POSITION, name)) {\n    int x = 0;\n    int y = 0;\n    int w = 0;\n    int h = 0;\n    SDL_Window* sdlwin = (SDL_Window*)(win->handle);\n\n    SDL_GetWindowSize(sdlwin, &w, &h);\n    SDL_GetWindowPosition(sdlwin, &x, &y);\n    win->rect = rect_init(x, y, w, h);\n    value_set_pointer(v, &(win->rect));\n\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t native_window_sdl_on_destroy(tk_object_t* obj) {\n  log_debug(\"Close native window.\\n\");\n  native_window_sdl_close(NATIVE_WINDOW(obj));\n\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_exec(tk_object_t* obj, const char* cmd, const char* args) {\n#ifdef WITH_GPU\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(obj);\n  if (tk_str_eq(cmd, \"reset_canvas\")) {\n    canvas_t* c = &(sdl->canvas);\n    vgcanvas_t* vg = canvas_get_vgcanvas(c);\n\n    vgcanvas_reset(vg);\n\n    return RET_OK;\n  }\n#endif /*WITH_GPU*/\n\n  return RET_NOT_FOUND;\n}\n\nstatic const object_vtable_t s_native_window_sdl_vtable = {\n    .type = \"native_window_sdl\",\n    .desc = \"native_window_sdl\",\n    .size = sizeof(native_window_sdl_t),\n    .get_prop = native_window_sdl_get_prop,\n    .set_prop = native_window_sdl_set_prop,\n    .exec = native_window_sdl_exec,\n    .on_destroy = native_window_sdl_on_destroy};\n\nstatic native_window_t* native_window_create_internal(const char* title, uint32_t flags, int32_t x,\n                                                      int32_t y, uint32_t w, uint32_t h) {\n  lcd_t* lcd = NULL;\n  native_window_info_t info;\n  tk_object_t* obj = tk_object_create(&s_native_window_sdl_vtable);\n  native_window_t* win = NATIVE_WINDOW(obj);\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n  canvas_t* c = &(sdl->canvas);\n\n#ifndef NATIVE_WINDOW_NOT_RESIZABLE\n  if (system_info()->app_type == APP_DESKTOP) {\n    flags |= SDL_WINDOW_RESIZABLE;\n  }\n#endif /*NATIVE_WINDOW_NOT_RESIZABLE*/\n\n#ifndef WITH_NANOVG_SOFT\n  flags |= SDL_WINDOW_OPENGL | SDL_WINDOW_ALLOW_HIGHDPI;\n#endif /*WITH_NANOVG_SOFT*/\n\n#ifdef NATIVE_WINDOW_BORDERLESS\n  flags |= SDL_WINDOW_BORDERLESS;\n#endif /*NATIVE_WINDOW_BORDERLESS*/\n\n  sdl->window = SDL_CreateWindow(title, x, y, w, h, flags);\n\n#ifdef WITH_NANOVG_SOFT\n  sdl->render =\n      SDL_CreateRenderer(sdl->window, -1, SDL_RENDERER_PRESENTVSYNC | SDL_RENDERER_ACCELERATED);\n  if (sdl->render == NULL) {\n    sdl->render = SDL_CreateRenderer(sdl->window, -1, SDL_RENDERER_SOFTWARE);\n  }\n#endif /*WITH_NANOVG_SOFT*/\n\n  win->handle = sdl->window;\n  win->vt = &s_native_window_vtable;\n\n#ifdef WITH_GPU_GL\n  sdl->context = SDL_GL_CreateContext(sdl->window);\n  SDL_GL_SetSwapInterval(1);\n\n  loadGL();\n  glDisable(GL_STENCIL_TEST);\n  glDisable(GL_ALPHA_TEST);\n  glDisable(GL_DEPTH_TEST);\n  glDisable(GL_SCISSOR_TEST);\n#endif /*WITH_GPU_GL*/\n\n  if (native_window_get_info(win, &info) == RET_OK) {\n    w = info.w;\n    h = info.h;\n  }\n  win->rect = rect_init(x, y, w, h);\n\n#ifdef WITH_LCD_MONO\n  lcd = lcd_sdl2_mono_init(sdl->render);\n#else\n#ifdef WITH_NANOVG_SOFT\n  lcd = lcd_sdl2_init(sdl->render);\n#elif WITH_NANOVG_GPU\n  lcd = lcd_nanovg_init(win);\n#endif /*WITH_NANOVG_SOFT*/\n#endif /*WITH_LCD_MONO*/\n\n  canvas_init(c, lcd, font_manager());\n\n  return win;\n}\n\nnative_window_t* native_window_create(widget_t* widget) {\n  int32_t x = widget->x;\n  int32_t y = widget->y;\n  int32_t w = widget->w;\n  int32_t h = widget->h;\n  native_window_t* nw = NULL;\n\n  if (s_shared_win != NULL) {\n    tk_object_ref(TK_OBJECT(s_shared_win));\n\n    nw = s_shared_win;\n  } else {\n    str_t str;\n\n    str_init(&str, 0);\n    str_from_wstr(&str, widget->text.str);\n    nw = native_window_create_internal(str.str, 0, x, y, w, h);\n    str_reset(&str);\n  }\n\n  widget_set_prop_pointer(widget, WIDGET_PROP_NATIVE_WINDOW, nw);\n\n  return nw;\n}\n\n#ifdef WITH_GPU_GL\nstatic ret_t sdl_init_gl(void) {\n  SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 8);\n  SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 8);\n  SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 8);\n  SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8);\n  SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);\n  SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\n  SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, \"nearest\");\n\n#ifdef WITH_GPU_GL2\n  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);\n  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);\n#elif defined(WITH_GPU_GL3)\n  SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG);\n  SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);\n  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);\n  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);\n#endif\n\n  log_debug(\"Init opengl done.\\n\");\n  return RET_OK;\n}\n#endif /*WITH_GPU_GL*/\n\nret_t native_window_sdl_init(bool_t shared, uint32_t w, uint32_t h) {\n  const char* title = system_info()->app_name;\n\n  SDL_SetHint(SDL_HINT_VIDEO_ALLOW_SCREENSAVER, \"1\");\n  if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_EVENTS | SDL_INIT_AUDIO) != 0) {\n    log_debug(\"Failed to initialize SDL: %s\", SDL_GetError());\n    exit(0);\n    return RET_FAIL;\n  }\n\n#ifdef WITH_GPU_GL\n  sdl_init_gl();\n#endif /*WITH_GPU_GL*/\n\n  SDL_StopTextInput();\n  if (shared) {\n    int32_t x = SDL_WINDOWPOS_UNDEFINED;\n    int32_t y = SDL_WINDOWPOS_UNDEFINED;\ns_shared_win = ",
    "raw_res": "native_window_create_internal(title, SDL_WINDOW_FULLSCREEN_DESKTOP, x, y, w, h);",
    "prompt_res": "native_window_create_internal(title, 0, x, y, w, h);",
    "gt": "native_window_create_internal(title, 0, x, y, w, h);"
  },
  {
    "id": 724,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/native_window/native_window_fb_gl.c",
    "input": "﻿/**\n * File:   native_window_fb_gl.c\n * Author: AWTK Develop Team\n * Brief:  native window for egl\n *\n * Copyright (c) 2019 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-10-31 Lou ZhiMing <luozhiming@zlg.com> created\n *\n */\n\n#ifdef WITH_GPU_GL\n#ifndef WITHOUT_GLAD\n#include \"glad/glad.h\"\n#define loadGL gladLoadGL\n#else\n#define loadGL()\n#endif /*WITHOUT_GLAD*/\n#endif /*WITH_GPU_GL*/\n\n#include \"base/widget.h\"\n#include \"lcd/lcd_nanovg.h\"\n#include \"base/widget_consts.h\"\n#include \"base/window_manager.h\"\n#include \"native_window/native_window_fb_gl.h\"\n\ntypedef struct _native_window_fb_gl_t {\n  native_window_t native_window;\n  uint32_t w;\n  uint32_t h;\n  float_t ratio;\n  native_window_swap_buffer_t swap_buffer;\n  native_window_gl_make_current_t make_current;\n  native_window_destroy_t destroy;\n  canvas_t canvas;\n} native_window_fb_gl_t;\n\nstatic native_window_t* s_shared_win = NULL;\n\n#define NATIVE_WINDOW_FB_GL(win) ((native_window_fb_gl_t*)(win))\n\nret_t native_window_fb_gl_set_swap_buffer_func(native_window_t* win,\n                                               native_window_swap_buffer_t swap_buffer) {\n  native_window_fb_gl_t* fb_gl = NATIVE_WINDOW_FB_GL(win);\n  return_value_if_fail(fb_gl != NULL && swap_buffer != NULL, RET_BAD_PARAMS);\n  fb_gl->swap_buffer = swap_buffer;\n  return RET_OK;\n}\n\nret_t native_window_fb_gl_set_make_current_func(native_window_t* win,\n                                                native_window_gl_make_current_t make_current) {\n  native_window_fb_gl_t* fb_gl = NATIVE_WINDOW_FB_GL(win);\n  return_value_if_fail(fb_gl != NULL && make_current != NULL, RET_BAD_PARAMS);\n  fb_gl->make_current = make_current;\n  return RET_OK;\n}\n\nret_t native_window_fb_gl_set_destroy_func(native_window_t* win, native_window_destroy_t destroy) {\n  native_window_fb_gl_t* fb_gl = NATIVE_WINDOW_FB_GL(win);\n  return_value_if_fail(fb_gl != NULL && destroy != NULL, RET_BAD_PARAMS);\n  fb_gl->destroy = destroy;\n  return RET_OK;\n}\n\nlcd_t* native_window_get_lcd(native_window_t* win) {\n  native_window_fb_gl_t* fb_gl = NATIVE_WINDOW_FB_GL(win);\n  return_value_if_fail(fb_gl != NULL, NULL);\n  return fb_gl->canvas.lcd;\n}\n\nstatic ret_t native_window_fb_gl_move(native_window_t* win, xy_t x, xy_t y) {\n  return RET_OK;\n}\n\nstatic ret_t native_window_fg_gl_on_resized_timer(const timer_info_t* info) {\n  widget_t* wm = window_manager();\n  native_window_t* win = NATIVE_WINDOW(info->ctx);\n  event_t e = event_init(EVT_NATIVE_WINDOW_RESIZED, NULL);\n  window_manager_dispatch_native_window_event(window_manager(), &e, win);\n  widget_set_need_relayout_children(wm);\n  widget_invalidate_force(wm, NULL);\n\n  log_debug(\"on_resized_idle\\n\");\n  return RET_REMOVE;\n}\n\nstatic ret_t native_window_fb_gl_resize(native_window_t* win, wh_t w, wh_t h) {\n  ret_t ret = RET_OK;\n  native_window_info_t info;\n  native_window_fb_gl_t* fb_gl = NATIVE_WINDOW_FB_GL(win);\n  native_window_get_info(win, &info);\n\n  fb_gl->w = win->rect.w = w;\n  fb_gl->h = win->rect.h = h;\n  if (w != info.w || h != info.h) {\nret = ",
    "raw_res": "RET_REMOVE;",
    "prompt_res": "lcd_resize(fb_gl->canvas.lcd, w, h, 0);",
    "gt": "lcd_resize(fb_gl->canvas.lcd, w, h, 0);"
  },
  {
    "id": 737,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/waitable_action_queue.c",
    "input": "﻿/**\n * File:   waitable_action_queue.c\n * Author: AWTK Develop Team\n * Brief:  waitable_action_queue\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2020-02-07 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/waitable_action_queue.h\"\n\nwaitable_action_queue_t* waitable_action_queue_create(uint16_t capacity) {\n  waitable_action_queue_t* q = TKMEM_ZALLOC(waitable_action_queue_t);\n  return_value_if_fail(q != NULL, NULL);\nq->queue = ",
    "raw_res": "0;",
    "prompt_res": "action_queue_create(capacity);",
    "gt": "action_queue_create(capacity);"
  },
  {
    "id": 741,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/waitable_action_queue.c",
    "input": "﻿/**\n * File:   waitable_action_queue.c\n * Author: AWTK Develop Team\n * Brief:  waitable_action_queue\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2020-02-07 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/waitable_action_queue.h\"\n\nwaitable_action_queue_t* waitable_action_queue_create(uint16_t capacity) {\n  waitable_action_queue_t* q = TKMEM_ZALLOC(waitable_action_queue_t);\n  return_value_if_fail(q != NULL, NULL);\n  q->queue = action_queue_create(capacity);\n  goto_error_if_fail(q->queue != NULL);\n\n  q->mutex = tk_mutex_create();\n  goto_error_if_fail(q->mutex != NULL);\n\n  q->sema_recv = tk_semaphore_create(0, NULL);\n  goto_error_if_fail(q->sema_recv != NULL);\n\n  q->sema_send = tk_semaphore_create(capacity, NULL);\n  goto_error_if_fail(q->sema_send != NULL);\n\n  return q;\nerror:\n  if (q != NULL) {\n    if (q->queue != NULL) {\n      action_queue_destroy(q->queue);\n    }\n\n    if (q->mutex != NULL) {\n      tk_mutex_destroy(q->mutex);\n    }\n\n    if (q->sema_recv != NULL) {\n      tk_semaphore_destroy(q->sema_recv);\n    }\n\n    if (q->sema_send != NULL) {\n      tk_semaphore_destroy(q->sema_send);\n    }\n\n    TKMEM_FREE(q);\n  }\n\n  return NULL;\n}\n\nret_t waitable_action_queue_recv(waitable_action_queue_t* q, qaction_t** action,\n                                 uint32_t timeout_ms) {\n  ret_t ret = RET_FAIL;\n  return_value_if_fail(q != NULL && action != NULL, RET_BAD_PARAMS);\n\n  if (tk_semaphore_wait(q->sema_recv, timeout_ms) == RET_OK) {\n    if (tk_mutex_lock(q->mutex) == RET_OK) {\nret = ",
    "raw_res": "0;",
    "prompt_res": "action_queue_recv(q->queue, action);",
    "gt": "action_queue_recv(q->queue, action);"
  },
  {
    "id": 803,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/fscript.c",
    "input": "﻿/**\n * File:   fscript.c\n * Author: AWTK Develop Team\n * Brief:  a simple script language\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2020-11-09 Li XianJing <lixianjing@zlg.cn> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/darray.h\"\n#include \"tkc/fscript.h\"\n#include \"tkc/object_default.h\"\n#include \"tkc/general_factory.h\"\n#include \"tkc/object_locker.h\"\n\n#ifndef WITHOUT_FSCRIPT\n#define value_id_index(v) (v)->value.id.index\n#define value_id_suboffset(v) (v)->value.id.suboffset\n\nstatic const fscript_hooks_t* s_hooks;\n\nret_t fscript_set_hooks(const fscript_hooks_t* hooks) {\n  s_hooks = hooks;\n  return RET_OK;\n}\n\nstatic ret_t func_function_def(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_if(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_while(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_until(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_repeat_times(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_repeat(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_for(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_for_in(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_noop(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_pending(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_return(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  if (args->size > 0) {\n    value_deep_copy(result, args->args);\n  }\n  fscript->returned = TRUE;\n  return RET_OK;\n}\nstatic ret_t func_get(fscript_t* fscript, fscript_args_t* args, value_t* result);\nstatic ret_t func_set(fscript_t* fscript, fscript_args_t* args, value_t* result);\nstatic ret_t func_unset(fscript_t* fscript, fscript_args_t* args, value_t* result);\nstatic ret_t func_set_local(fscript_t* fscript, fscript_args_t* args, value_t* result);\nstatic ret_t fscript_func_call_init_func(fscript_func_call_t* call, tk_object_t* obj,\n                                         tk_object_t* funcs_def, const char* name, uint32_t size);\n\nret_t fscript_ensure_locals(fscript_t* fscript) {\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n\n  if (fscript->locals == NULL) {\n    fscript->locals = darray_create(5, (tk_destroy_t)named_value_destroy,\n                                    (tk_compare_t)named_value_compare_by_name);\n  }\n\n  return fscript->locals != NULL ? RET_OK : RET_FAIL;\n}\n\nstatic ret_t fscript_locals_remove(fscript_t* fscript, uint32_t index) {\n  named_value_t* nv = (named_value_t*)(fscript->locals->elms[index]);\n  return value_reset(&(nv->value));\n}\n\nstatic tk_object_t* fscript_locals_get_object(fscript_t* fscript, const char* name) {\n  named_value_t* nv = (named_value_t*)darray_find(fscript->locals, (void*)name);\n\n  return nv != NULL ? value_object(&(nv->value)) : NULL;\n}\n\nstatic ret_t fscript_locals_get(fscript_t* fscript, const value_t* name, value_t* v) {\n  int32_t index = value_id_index(name);\n  int32_t suboffset = value_id_suboffset(name);\n  named_value_t* nv = (named_value_t*)(fscript->locals->elms[index]);\n  if (!suboffset) {\n    return value_copy(v, &(nv->value));\n  } else {\n    tk_object_t* obj = value_object(&(nv->value));\n    const char* subname = value_id(name) + suboffset;\n    return_value_if_fail(obj != NULL, RET_BAD_PARAMS);\n\n    return tk_object_get_prop(obj, subname, v);\n  }\n}\n\nstatic ret_t fscript_locals_set_with_index(fscript_t* fscript, uint32_t index, const value_t* v) {\n  named_value_t* nv = (named_value_t*)(fscript->locals->elms[index]);\n  if (nv->value.free_handle) {\n    value_reset(&(nv->value));\n  }\n  return value_deep_copy(&(nv->value), v);\n}\n\nstatic ret_t fscript_locals_set(fscript_t* fscript, const value_t* name, value_t* v) {\n  int32_t index = value_id_index(name);\n  int32_t suboffset = value_id_suboffset(name);\n  named_value_t* nv = (named_value_t*)(fscript->locals->elms[index]);\n  if (!suboffset) {\n    return fscript_locals_set_with_index(fscript, index, v);\n  } else {\n    tk_object_t* obj = value_object(&(nv->value));\n    const char* subname = value_id(name) + suboffset;\n    return_value_if_fail(obj != NULL, RET_BAD_PARAMS);\n\n    return tk_object_set_prop(obj, subname, v);\n  }\n}\n\nstatic ret_t fscript_locals_create(fscript_t* fscript, const char* name, const value_t* v) {\n  int32_t index = 0;\n  named_value_t* nv = NULL;\n  return_value_if_fail(fscript_ensure_locals(fscript) == RET_OK, RET_BAD_PARAMS);\n  index = darray_find_index(fscript->locals, (void*)name);\n\n  if (index >= 0) {\n    fscript_set_error(fscript, RET_FAIL, \"<>\", \"duplicated var name.\");\n    return fscript_locals_set_with_index(fscript, index, v);\n  }\n\n  nv = named_value_create_ex(name, v);\n  return_value_if_fail(nv != NULL, RET_BAD_PARAMS);\n\n  if (darray_push_unique(fscript->locals, nv) != RET_OK) {\n    named_value_destroy(nv);\n    return RET_FAIL;\n  }\n  return RET_OK;\n}\n\nstatic ret_t fscript_locals_destroy(fscript_t* fscript) {\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n  if (fscript->locals != NULL) {\n    darray_destroy(fscript->locals);\n    fscript->locals = NULL;\n  }\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_func(fscript_t* fscript, const char* name, fscript_func_call_t* iter,\n                               value_t* result) {\n  if (s_hooks != NULL && s_hooks->exec_func != NULL) {\n    return s_hooks->exec_func(fscript, name, iter, result);\n  } else {\n    return fscript_exec_func_default(fscript, iter, result);\n  }\n}\n\nret_t fscript_set_error(fscript_t* fscript, ret_t code, const char* func, const char* message) {\n  fscript->error_code = code;\n  fscript->error_func = fscript->curr;\n  fscript->error_row = fscript->curr->row;\n  fscript->error_col = fscript->curr->col;\n  fscript->error_message = tk_str_copy(fscript->error_message, message);\n  if (code != RET_OK) {\n    log_debug(\"(%d:%d): %s code=%d %s\\n\", fscript->curr->row, fscript->curr->col, func, code,\n              message);\n  }\n\n  if (fscript->on_error != NULL) {\n    fscript->on_error(fscript->on_error_ctx, fscript);\n  }\n\n  return RET_OK;\n}\n\nret_t fscript_set_on_error(fscript_t* fscript, fscript_on_error_t on_error, void* ctx) {\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n  fscript->on_error = on_error;\n  fscript->on_error_ctx = ctx;\n\n  return RET_OK;\n}\n\nret_t fscript_set_print_func(fscript_t* fscript, fscript_func_t print) {\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n\n  fscript->print = print;\n\n  return RET_OK;\n}\n\nstatic bool_t value_is_digit(value_t* v) {\n  uint32_t type = 0;\n  bool_t ret = TRUE;\n  return_value_if_fail(v != NULL, FALSE);\n\n  type = v->type;\n  if (type == VALUE_TYPE_INVALID || type == VALUE_TYPE_POINTER || type == VALUE_TYPE_STRING ||\n      type == VALUE_TYPE_WSTRING || type == VALUE_TYPE_OBJECT || type == VALUE_TYPE_SIZED_STRING ||\n      type == VALUE_TYPE_BINARY || type == VALUE_TYPE_UBJSON) {\n    ret = FALSE;\n  }\n\n  return ret;\n}\n\nstatic ret_t func_args_extend(fscript_args_t* args) {\n  if (args->size < args->capacity) {\n    return RET_OK;\n  }\n\n  if (args->capacity < FSCRIPT_MAX_ARGS) {\n    value_t* new_args = NULL;\n    uint16_t capacity = args->capacity + 2;\n    capacity = tk_min(capacity, FSCRIPT_MAX_ARGS);\n    new_args = TKMEM_REALLOC(args->args, capacity * sizeof(value_t));\n    return_value_if_fail(new_args != NULL, RET_OOM);\n    args->args = new_args;\n    args->capacity = capacity;\n    return RET_OK;\n  }\n\n  return RET_FAIL;\n}\n\nstatic ret_t func_args_push(fscript_args_t* args, value_t* v) {\n  return_value_if_fail(v != NULL && func_args_extend(args) == RET_OK, RET_BAD_PARAMS);\n  args->args[args->size++] = *v;\n  v->free_handle = FALSE;\n  value_reset(v);\n\n  return RET_OK;\n}\n\nstatic ret_t func_args_init(fscript_args_t* args, uint16_t init_args_capacity) {\n  memset(args, 0x00, sizeof(fscript_args_t));\n  if (init_args_capacity > 0) {\n    args->args = TKMEM_ZALLOCN(value_t, init_args_capacity);\n    return_value_if_fail(args->args != NULL, RET_OOM);\n    args->capacity = init_args_capacity;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_func_call_destroy(fscript_func_call_t* call);\n\nstatic ret_t func_args_reset(fscript_args_t* args) {\n  uint32_t i = 0;\n  for (i = 0; i < args->size; i++) {\n    value_t* v = args->args + i;\n    if (v->type == VALUE_TYPE_FSCRIPT_FUNC) {\n      fscript_func_call_destroy(value_func(v));\n    }\n    value_reset(args->args + i);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_args_deinit(fscript_args_t* args) {\n  func_args_reset(args);\n  TKMEM_FREE(args->args);\n  memset(args, 0x00, sizeof(fscript_args_t));\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_func_call_destroy(fscript_func_call_t* call) {\n  fscript_func_call_t* iter = call;\n  fscript_func_call_t* next = NULL;\n\n  while (iter != NULL) {\n    if (iter->func == func_pending) {\n      TKMEM_FREE(iter->ctx);\n    }\n    next = iter->next;\n    func_args_deinit(&(iter->args));\n    TKMEM_FREE(iter);\n    iter = next;\n  }\n\n  return RET_OK;\n}\n\nstatic fscript_function_def_t* fscript_function_def_create(const char* name,\n                                                           fscript_func_call_t* body) {\n  fscript_function_def_t* func = TKMEM_ZALLOC(fscript_function_def_t);\n  return_value_if_fail(func != NULL, NULL);\n  func->body = body;\n  func->name = tk_strdup(name);\n\n  darray_init(&(func->params), 3, default_destroy, NULL);\n  return func;\n}\n\nstatic ret_t fscript_function_def_destroy(fscript_function_def_t* func) {\n  return_value_if_fail(func != NULL, RET_BAD_PARAMS);\n  darray_deinit(&(func->params));\n  fscript_func_call_destroy(func->body);\n  TKMEM_FREE(func->name);\n  memset(func, 0x00, sizeof(fscript_function_def_t));\n  TKMEM_FREE(func);\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_function_def_add_param(fscript_function_def_t* func, const char* name) {\n  return_value_if_fail(func != NULL, RET_BAD_PARAMS);\n  return darray_push(&(func->params), tk_strdup(name));\n}\n\ntypedef enum _token_type_t {\n  TOKEN_ID = 1,\n  TOKEN_VAR,\n  TOKEN_FUNC,\n  TOKEN_RETURN,\n  TOKEN_FUNC_DEF,\n  TOKEN_STR,\n  TOKEN_NUMBER,\n  TOKEN_LPAREN,\n  TOKEN_RPAREN,\n  TOKEN_LBRACKET,\n  TOKEN_RBRACKET,\n  TOKEN_COMMA,\n  TOKEN_SEMICOLON,\n  /*for expr*/\n  TOKEN_QUESTION,\n  TOKEN_COLON,\n  TOKEN_EOF\n} token_type_t;\n\ntypedef struct _token_t {\n  const char* token;\n  token_type_t type;\n  uint32_t size;\n  bool_t valid;\n} token_t;\n\ntypedef struct _fscript_parser_t {\n  tk_object_t* obj;\n  token_t token;\n  char* code_id;\n  const char* str;\n  const char* cursor;\n\n  char c;\n  str_t temp;\n  uint16_t row;\n  uint16_t col;\n  tk_object_t* funcs_def;\n  fscript_func_call_t* first;\n  fscript_parser_error_t* error;\n  bool_t keep_func_name;\n  darray_t* symbols;\n} fscript_parser_t;\n\nstatic ret_t fexpr_parse(fscript_parser_t* parser, value_t* result);\nstatic ret_t fscript_parse_statements(fscript_parser_t* parser, fscript_func_call_t* acall);\nstatic fscript_func_call_t* fscript_func_call_create(fscript_parser_t* parser, const char* name,\n                                                     uint32_t size);\nstatic ret_t fscript_get_var(fscript_t* fscript, const char* name, value_t* value) {\n  value_set_str(value, NULL);\n  return_value_if_fail(name != NULL, RET_BAD_PARAMS);\n  if (*name == '$') {\n    name += 1;\n  }\n\n  if (strncmp(name, FSCRIPT_STR_GLOBAL_PREFIX, FSCRIPT_GLOBAL_PREFIX_LEN) == 0) {\n    return tk_object_get_prop(fscript_get_global_object(), name + FSCRIPT_GLOBAL_PREFIX_LEN, value);\n  }\n\n  return tk_object_get_prop(fscript->obj, name, value);\n}\n\nret_t fscript_set_var_default(fscript_t* fscript, const char* name, const value_t* value) {\n  if (strncmp(name, FSCRIPT_STR_GLOBAL_PREFIX, FSCRIPT_GLOBAL_PREFIX_LEN) == 0) {\n    return tk_object_set_prop(fscript_get_global_object(), name + FSCRIPT_GLOBAL_PREFIX_LEN, value);\n  }\n\n  return tk_object_set_prop(fscript->obj, name, value);\n}\n\nret_t fscript_set_var(fscript_t* fscript, const char* name, const value_t* value) {\n  if (s_hooks != NULL && s_hooks->set_var != NULL) {\n    return s_hooks->set_var(fscript, name, value);\n  } else {\n    return fscript_set_var_default(fscript, name, value);\n  }\n}\n\nstatic ret_t fscript_eval_arg(fscript_t* fscript, fscript_func_call_t* iter, uint32_t i,\n                              value_t* d) {\n  value_t v;\n  value_t* s = iter->args.args + i;\n  value_set_str(&v, NULL);\n  value_set_str(d, NULL);\n  if (s->type == VALUE_TYPE_FSCRIPT_ID) {\n    if ((iter->func == func_set_local || iter->func == func_set || iter->func == func_unset ||\n         iter->func == func_get) &&\n        i == 0) {\n      value_copy(d, s); /*func_set accept id/str as first param*/\n    } else {\n      const char* name = value_id(s);\n      if (value_id_index(s) >= 0) {\n        return fscript_locals_get(fscript, s, d);\n      }\n\n      if (fscript->loop_count > 0) {\n        if (tk_str_eq(name, \"break\")) {\n          fscript->breaked = TRUE;\n          return RET_OK;\n        } else if (tk_str_eq(name, \"continue\")) {\n          fscript->continued = TRUE;\n          return RET_OK;\n        }\n      } else if (tk_str_eq(name, \"return\")) {\n        fscript->returned = TRUE;\n        value_set_int(d, 0);\n        return RET_OK;\n      } else if (*name == '.') {\n        value_copy(d, s);\n        return RET_OK;\n      }\n\n      if (fscript_get_var(fscript, name, d) != RET_OK) {\n        if (name == NULL || *name != '$') {\n          char msg[128];\n          tk_snprintf(msg, sizeof(msg) - 1, \"not found var %s\", name);\n          fscript_set_error(fscript, RET_NOT_FOUND, \"get_var\", msg);\n          value_set_str(d, value_id(s));\n        } else if (*name == '$') {\n          value_reset(d);\n        }\n      }\n    }\n  } else if (s->type == VALUE_TYPE_FSCRIPT_FUNC) {\n    fscript_exec_func(fscript, NULL, value_func(s), d);\n  } else {\n    value_copy(d, s);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_if(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  uint32_t i = 0;\n  uint32_t n = 0;\n  value_t condition;\n  return_value_if_fail(iter->args.size >= 2, RET_FAIL);\n\n  n = iter->args.size / 2;\n  for (i = 0; i < n; i++) {\n    value_set_bool(&condition, FALSE);\n    return_value_if_fail(fscript_eval_arg(fscript, iter, 2 * i, &condition) == RET_OK, RET_FAIL);\n    if (value_bool(&condition)) {\n      return fscript_eval_arg(fscript, iter, 2 * i + 1, result);\n    }\n  }\n\n  if ((2 * i) < iter->args.size) {\n    return fscript_eval_arg(fscript, iter, 2 * i, result);\n  } else {\n    value_set_int(result, 0);\n    return RET_OK;\n  }\n}\n\nstatic ret_t fscript_exec_loop_body(fscript_t* fscript, fscript_func_call_t* iter, uint32_t start,\n                                    value_t* result, bool_t* done) {\n  uint32_t i = 1;\n  for (i = start; i < iter->args.size; i++) {\n    value_reset(result);\n    fscript_eval_arg(fscript, iter, i, result);\n    if (fscript->breaked) {\n      *done = TRUE;\n      fscript->breaked = FALSE;\n      break;\n    } else if (fscript->returned) {\n      *done = TRUE;\n    } else if (fscript->continued) {\n      fscript->continued = FALSE;\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_while_or_until(fscript_t* fscript, fscript_func_call_t* iter,\n                                         value_t* result, bool_t is_while) {\n  value_t condition;\n  bool_t done = FALSE;\n  FSCRIPT_FUNC_CHECK(iter->args.size > 1, RET_FAIL);\n\n  fscript->loop_count++;\n  value_set_int(&condition, 0);\n  while (!done && fscript_eval_arg(fscript, iter, 0, &condition) == RET_OK) {\n    if (is_while ? !value_bool(&condition) : value_bool(&condition)) {\n      break;\n    }\n    fscript_exec_loop_body(fscript, iter, 1, result, &done);\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\n\n/*repeat(a, 0, 100, 1) {*/\nstatic ret_t fscript_exec_repeat(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  value_t v;\n  int32_t start = 0;\n  int32_t end = 0;\n  int32_t delta = 0;\n  bool_t done = FALSE;\n  value_t* var = iter->args.args;\n  int32_t index = value_id_index(var);\n  const char* name = value_id(iter->args.args);\n  FSCRIPT_FUNC_CHECK(iter->args.size > 4, RET_FAIL);\n\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 1, &v) == RET_OK, RET_BAD_PARAMS);\n  start = value_int(&v);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 2, &v) == RET_OK, RET_BAD_PARAMS);\n  end = value_int(&v);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 3, &v) == RET_OK, RET_BAD_PARAMS);\n  delta = value_int(&v);\n\n  fscript->loop_count++;\n  while ((start != end) && !done) {\n    value_set_int(&v, start);\n    if (index >= 0) {\n      break_if_fail(fscript_locals_set(fscript, var, &v) == RET_OK);\n    } else {\n      break_if_fail(fscript_set_var(fscript, name, &v) == RET_OK);\n    }\n    fscript_exec_loop_body(fscript, iter, 4, result, &done);\n    start += delta;\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_for(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  value_t v;\n  bool_t done = FALSE;\n  FSCRIPT_FUNC_CHECK(iter->args.size > 3, RET_FAIL);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 0, &v) == RET_OK, RET_BAD_PARAMS);\n\n  fscript->loop_count++;\n  while (!done) {\n    break_if_fail(fscript_eval_arg(fscript, iter, 1, &v) == RET_OK);\n    if (!value_bool(&v)) {\n      break;\n    }\n    fscript_exec_loop_body(fscript, iter, 3, result, &done);\n    break_if_fail(fscript_eval_arg(fscript, iter, 2, &v) == RET_OK);\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_for_in(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  value_t v;\n  char prop[32];\n  uint32_t i = 0;\n  uint32_t n = 0;\n  bool_t done = FALSE;\n  object_t* obj = NULL;\n  value_t* var = iter->args.args;\n  int32_t index = value_id_index(var);\n  const char* name = value_id(var);\n\n  FSCRIPT_FUNC_CHECK(iter->args.size > 2, RET_FAIL);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 1, &v) == RET_OK, RET_BAD_PARAMS);\n  obj = value_object(&v);\n  FSCRIPT_FUNC_CHECK(obj != NULL, RET_FAIL);\n\n  fscript->loop_count++;\n  n = tk_object_get_prop_int(obj, TK_OBJECT_PROP_SIZE, 0);\n  for (i = 0; ((i < n) && !done); i++) {\n    tk_snprintf(prop, sizeof(prop) - 1, \"[%u]\", i);\n    break_if_fail(tk_object_get_prop(obj, prop, &v) == RET_OK);\n\n    if (index >= 0) {\n      fscript_locals_set(fscript, var, &v);\n    } else {\n      fscript_set_var(fscript, name, &v);\n    }\n    fscript_exec_loop_body(fscript, iter, 2, result, &done);\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_repeat_times(fscript_t* fscript, fscript_func_call_t* iter,\n                                       value_t* result) {\n  value_t v;\n  uint32_t i = 0;\n  uint32_t n = 0;\n  bool_t done = FALSE;\n  FSCRIPT_FUNC_CHECK(iter->args.size > 1, RET_FAIL);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 0, &v) == RET_OK, RET_BAD_PARAMS);\n\n  n = value_int(&v);\n  fscript->loop_count++;\n  for (i = 0; i < n && !done; i++) {\n    fscript_exec_loop_body(fscript, iter, 1, result, &done);\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\nstatic ret_t fscript_exec_while(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  return fscript_exec_while_or_until(fscript, iter, result, TRUE);\n}\n\nstatic ret_t fscript_exec_until(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  return fscript_exec_while_or_until(fscript, iter, result, FALSE);\n}\n\nstatic ret_t fscript_exec_core_func(fscript_t* fscript, fscript_func_call_t* iter,\n                                    value_t* result) {\n  if (iter->func == func_if) {\n    return fscript_exec_if(fscript, iter, result);\n  } else if (iter->func == func_while) {\n    return fscript_exec_while(fscript, iter, result);\n  } else if (iter->func == func_until) {\n    return fscript_exec_until(fscript, iter, result);\n  } else if (iter->func == func_repeat) {\n    return fscript_exec_repeat(fscript, iter, result);\n  } else if (iter->func == func_for) {\n    return fscript_exec_for(fscript, iter, result);\n  } else if (iter->func == func_for_in) {\n    return fscript_exec_for_in(fscript, iter, result);\n  } else if (iter->func == func_repeat_times) {\n    return fscript_exec_repeat_times(fscript, iter, result);\n  } else if (iter->func == func_function_def) {\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t fscript_exec_ext_func(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  value_t v;\n  uint32_t i = 0;\n  ret_t ret = RET_OK;\n  fscript_args_t args;\n  value_t args_values[5];\n\n  value_set_int(&v, 0);\n  if (iter->args.size <= ARRAY_SIZE(args_values)) {\n    memset(&args, 0x00, sizeof(args));\n    memset(&args_values, 0x00, sizeof(args_values));\n    args.capacity = ARRAY_SIZE(args_values);\n    args.args = args_values;\n  } else {\n    func_args_init(&args, iter->args.size);\n  }\n  args.size = iter->args.size;\n\n  return_value_if_fail((args.args != NULL || args.size == 0), RET_OOM);\n  for (i = 0; i < iter->args.size; i++) {\n    ret = fscript_eval_arg(fscript, iter, i, args.args + i);\n    if (fscript->breaked || fscript->continued || fscript->returned) {\n      value_deep_copy(result, args.args + i);\n      if (iter->args.size <= ARRAY_SIZE(args_values)) {\n        func_args_reset(&args);\n      } else {\n        func_args_deinit(&args);\n      }\n      return RET_OK;\n    }\n  }\n\n  value_set_int(result, 0);\n  fscript->curr = iter;\n  ret = iter->func(fscript, &args, result);\n\n  if (iter->args.size <= ARRAY_SIZE(args_values)) {\n    func_args_reset(&args);\n  } else {\n    func_args_deinit(&args);\n  }\n\n  return ret;\n}\n\nret_t fscript_exec_func_default(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  fscript->curr = iter;\n  result->type = VALUE_TYPE_INVALID;\n\n  if (iter->func == func_pending && iter->ctx != NULL) {\n    tk_object_t* obj = NULL;\n    void* ctx = iter->ctx;\n    char* name = (char*)(iter->ctx);\n    char* p = strchr(name, '.');\n    iter->ctx = NULL;\n\n    if (p != NULL) {\n      *p = '\\0';\n      obj = fscript_locals_get_object(fscript, name);\n      name = p + 1;\n    }\n    obj = obj != NULL ? obj : fscript->obj;\n    fscript_func_call_init_func(iter, obj, fscript->funcs_def, name, tk_strlen(name));\n\n    if (iter->func == func_noop) {\n      log_warn(\"not found func %s\\n\", name);\n    }\n    TKMEM_FREE(ctx);\n  }\n\n  if (fscript_exec_core_func(fscript, iter, result) == RET_NOT_FOUND) {\n    return_value_if_fail(fscript_exec_ext_func(fscript, iter, result) == RET_OK, RET_FAIL);\n  }\n\n  return RET_OK;\n}\n\nret_t fscript_exec(fscript_t* fscript, value_t* result) {\n  fscript_func_call_t* iter = NULL;\n  return_value_if_fail(fscript != NULL, RET_FAIL);\n\n  if (s_hooks != NULL && s_hooks->before_exec != NULL) {\n    s_hooks->before_exec(fscript);\n  }\n\n  value_set_str(result, NULL);\n  iter = fscript->first;\n  while (iter != NULL) {\n    break_if_fail(iter->func != NULL);\n    value_reset(result);\n    break_if_fail(fscript_exec_func(fscript, NULL, iter, result) == RET_OK);\n    if (fscript->returned) {\n      fscript->returned = FALSE;\n      break;\n    }\n    iter = iter->next;\n  }\n\n  if (s_hooks != NULL && s_hooks->after_exec != NULL) {\n    s_hooks->after_exec(fscript);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t on_free_func_def(void* ctx, const void* data) {\n  named_value_t* iter = (named_value_t*)(data);\n  fscript_function_def_destroy(value_func_def(&(iter->value)));\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_reset(fscript_t* fscript) {\n  return_value_if_fail(fscript != NULL, RET_FAIL);\n\n  if (s_hooks != NULL && s_hooks->on_deinit != NULL) {\n    s_hooks->on_deinit(fscript);\n  }\n\n  str_reset(&(fscript->str));\n  fscript_locals_destroy(fscript);\n  if (fscript->funcs_def != NULL) {\n    tk_object_foreach_prop(fscript->funcs_def, on_free_func_def, NULL);\n  }\n  TK_OBJECT_UNREF(fscript->funcs_def);\n  TKMEM_FREE(fscript->error_message);\n  fscript_func_call_destroy(fscript->first);\n  TKMEM_FREE(fscript->code_id);\n  memset(fscript, 0x00, sizeof(fscript_t));\n\n  return RET_OK;\n}\n\nret_t fscript_deinit(fscript_t* fscript) {\n  return fscript_reset(fscript);\n}\n\nret_t fscript_destroy(fscript_t* fscript) {\n  return_value_if_fail(fscript != NULL, RET_FAIL);\n  fscript_deinit(fscript);\n\n  TKMEM_FREE(fscript);\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_init(fscript_parser_t* parser, tk_object_t* obj, const char* str,\n                                 fscript_parser_error_t* error) {\n  memset(parser, 0x00, sizeof(fscript_parser_t));\n\n  parser->obj = obj;\n  parser->str = str;\n  parser->cursor = str;\n  parser->error = error;\n  parser->symbols = darray_create(5, NULL, (tk_compare_t)tk_str_cmp);\n\n  str_init(&(parser->temp), 64);\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_deinit(fscript_parser_t* parser) {\n  str_reset(&(parser->temp));\n  TKMEM_FREE(parser->code_id);\n  darray_destroy(parser->symbols);\n  fscript_func_call_destroy(parser->first);\n  if (parser->funcs_def != NULL) {\n    tk_object_foreach_prop(parser->funcs_def, on_free_func_def, NULL);\n  }\n  TK_OBJECT_UNREF(parser->funcs_def);\n\n  return RET_OK;\n}\n\nstatic char fscript_parser_get_char(fscript_parser_t* parser) {\n  char c = '\\0';\n  return_value_if_fail(parser != NULL, c);\n  if (parser->c) {\n    c = parser->c;\n    parser->c = '\\0';\n    return c;\n  }\n\n  c = parser->cursor[0];\n  if (c) {\n    if (c == '\\n') {\n      parser->row++;\n      parser->col = 0;\n    } else {\n      parser->col++;\n    }\n\n    parser->cursor++;\n  }\n\n  return c;\n}\n\nstatic ret_t fscript_parser_unget_char(fscript_parser_t* parser, char c) {\n  return_value_if_fail(parser->cursor > parser->str, RET_BAD_PARAMS);\n  parser->c = c;\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_set_error(fscript_parser_t* parser, const char* str) {\n  return_value_if_fail(parser != NULL && str != NULL, RET_BAD_PARAMS);\n\n  if (parser->error != NULL) {\n    parser->error->row = parser->row;\n    parser->error->col = parser->col;\n    parser->error->offset = parser->cursor - parser->str;\n    parser->error->message = tk_str_copy(parser->error->message, str);\n    parser->error->token = tk_str_copy(parser->error->token, parser->token.token);\n  }\n\n  log_warn(\"code: \\\"%s\\\"\\n\", parser->str);\n  log_warn(\"token: \\\"%s\\\"\\n\", parser->token.token);\n  log_warn(\"at line(%u) col (%u): %s\\n\", parser->row, parser->col, str);\n\n  return RET_FAIL;\n}\n\nstatic ret_t fscript_parser_skip_seperators(fscript_parser_t* parser) {\n  char c = '\\0';\n  do {\n    c = fscript_parser_get_char(parser);\n  } while (tk_isspace(c));\n  fscript_parser_unget_char(parser, c);\n\n  return RET_OK;\n}\n\n#define STR_CODE_ID_START \"code_id(\\\"\"\n#define STR_CODE_ID_END \"\\\")\"\n\nstatic ret_t fscript_parser_skip_line_comment(fscript_parser_t* parser) {\n  char c = '\\0';\n  str_t* str = &(parser->temp);\n  str_clear(str);\n  do {\n    c = fscript_parser_get_char(parser);\n    str_append_char(str, c);\n  } while (c != '\\0' && c != '\\r' && c != '\\n');\n\n  if (str->size > sizeof(STR_CODE_ID_START)) {\n    const char* end = NULL;\n    const char* start = strstr(str->str, STR_CODE_ID_START);\n    if (start != NULL) {\n      start += strlen(STR_CODE_ID_START);\n      end = strstr(start, STR_CODE_ID_END);\n      if (end != NULL) {\n        TKMEM_FREE(parser->code_id);\n        parser->code_id = tk_strndup(start, end - start);\n        log_debug(\"code_id:%s\\n\", parser->code_id);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_skip_block_comment(fscript_parser_t* parser) {\n  char c = '\\0';\n  do {\n    c = fscript_parser_get_char(parser);\n    if (c == '*' && parser->cursor[0] == '/') {\n      c = fscript_parser_get_char(parser);\n      break;\n    }\n  } while (c != '\\0');\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_skip_seperators_and_comments(fscript_parser_t* parser) {\n  char c = '\\0';\n\n  while (TRUE) {\n    fscript_parser_skip_seperators(parser);\n    c = fscript_parser_get_char(parser);\n    if (c == '/') {\n      if (parser->cursor[0] == '/') {\n        c = fscript_parser_get_char(parser);\n        fscript_parser_skip_line_comment(parser);\n      } else if (parser->cursor[0] == '*') {\n        c = fscript_parser_get_char(parser);\n        fscript_parser_skip_block_comment(parser);\n      } else {\n        break;\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (c) {\n    parser->cursor--;\n    if (parser->col > 0) {\n      parser->col--;\n    }\n  }\n\n  return RET_OK;\n}\n\n#define TOKEN_INIT(t, ttype, str) \\\n  t->type = ttype;                \\\n  t->token = str->str;            \\\n  t->size = str->size;\n\nstatic ret_t fscript_parser_parse_str(fscript_parser_t* parser, char quota) {\n  char c = '\\0';\n  bool_t escape = FALSE;\n  str_t* str = &(parser->temp);\n  token_t* t = &(parser->token);\n\n  str_set(str, \"\");\n  do {\n    c = fscript_parser_get_char(parser);\n    if (escape) {\n      if (c == 'r') {\n        str_append_char(str, '\\r');\n      } else if (c == 'n') {\n        str_append_char(str, '\\n');\n      } else if (c == 't') {\n        str_append_char(str, '\\t');\n      } else {\n        str_append_char(str, c);\n      }\n      escape = FALSE;\n      continue;\n    }\n\n    if (c == quota || c == '\\0') {\n      break;\n    } else if (c == '\\\\') {\n      escape = TRUE;\n      continue;\n    }\n    str_append_char(str, c);\n  } while (TRUE);\n\n  TOKEN_INIT(t, TOKEN_STR, str);\n  if (c != '\\0' && c != quota) {\n    fscript_parser_unget_char(parser, c);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_get_non_ascii_char(fscript_parser_t* parser, str_t* str, uint8_t c,\n                                               uint32_t n) {\n  str_append_char(str, c);\n  while (n > 1) {\n    c = fscript_parser_get_char(parser);\n    str_append_char(str, c);\n    n--;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_parse_id_or_number(fscript_parser_t* parser, token_type_t def_type) {\n  char c = '\\0';\n  str_t* str = &(parser->temp);\n  token_t* t = &(parser->token);\n  c = fscript_parser_get_char(parser);\n\n  str_set(str, \"\");\n  if (c) {\n    int32_t n = tk_utf8_get_bytes_of_leading((uint8_t)c);\n    fscript_parser_get_non_ascii_char(parser, str, c, n);\n  }\n\n  do {\n    c = fscript_parser_get_char(parser);\n    if (tk_isxdigit(c) || tk_isdigit(c) || tk_isalpha(c) || c == '.' || c == '_' || c == '[' ||\n        c == ']' || c == '#') {\n      str_append_char(str, c);\n    } else {\n      int32_t n = tk_utf8_get_bytes_of_leading((uint8_t)c);\n      if (n > 1) {\n        fscript_parser_get_non_ascii_char(parser, str, c, n);\n      } else {\n        break;\n      }\n    }\n  } while (TRUE);\n\n  if (tk_isspace(c)) {\n    fscript_parser_skip_seperators_and_comments(parser);\n    c = fscript_parser_get_char(parser);\n  }\n\n  str_trim(str, \" \\t\\r\\n\");\n  TOKEN_INIT(t, (c == '(' ? TOKEN_FUNC : def_type), str);\n  if (c != '\\0') {\n    fscript_parser_unget_char(parser, c);\n  }\n\n  if (t->type == TOKEN_ID) {\n    if (tk_str_eq(t->token, \"function\")) {\n      t->type = TOKEN_FUNC_DEF;\n    } else if (tk_str_eq(t->token, \"var\")) {\n      t->type = TOKEN_VAR;\n    } else if (tk_str_eq(t->token, \"return\")) {\n      t->type = TOKEN_RETURN;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_get_unary(fscript_parser_t* parser, char c, str_t* str) {\n  do {\n    fscript_parser_skip_seperators_and_comments(parser);\n    c = fscript_parser_get_char(parser);\n    if (c == str->str[0]) {\n      str_append_char(str, c);\n    } else {\n      fscript_parser_unget_char(parser, c);\n      break;\n    }\n  } while (TRUE);\n\n  return RET_OK;\n}\n\nstatic token_t* fscript_parser_get_token_ex(fscript_parser_t* parser, bool_t operator) {\n  char c = 0;\n  str_t* str = &(parser->temp);\n  token_t* t = &(parser->token);\n\n  if (t->valid) {\n    t->valid = FALSE;\n    return t;\n  }\n\n  fscript_parser_skip_seperators_and_comments(parser);\n  c = fscript_parser_get_char(parser);\n\n  str_set_with_len(str, &c, 1);\n  t->token = str->str;\n  t->size = 1;\n  switch (c) {\n    case '\\0': {\n      t->type = TOKEN_EOF;\n      return NULL;\n    }\n    case '(': {\n      t->type = TOKEN_LPAREN;\n      return t;\n    }\n    case ')': {\n      t->type = TOKEN_RPAREN;\n      return t;\n    }\n    case '{': {\n      t->type = TOKEN_LBRACKET;\n      return t;\n    }\n    case '}': {\n      t->type = TOKEN_RBRACKET;\n      return t;\n    }\n    case ',': {\n      t->type = TOKEN_COMMA;\n      return t;\n    }\n    case ';': {\n      t->type = TOKEN_SEMICOLON;\n      return t;\n    }\n    case '?': {\n      t->type = TOKEN_QUESTION;\n      return t;\n    }\n    case ':': {\n      t->type = TOKEN_COLON;\n      return t;\n    }\n    case '*':\n    case '/':\n    case '%':\n    case '^':\n    case '#': {\n      t->type = TOKEN_FUNC;\n      return t;\n    }\n    case '>':\n    case '<':\n    case '=': {\n      c = fscript_parser_get_char(parser);\n      if (str->str[0] == c || c == '=') {\n        str_append_char(str, c);\n      } else {\n        fscript_parser_unget_char(parser, c);\n      }\n      t->type = TOKEN_FUNC;\n      t->size = str->size;\n      return t;\n    }\n    case '~':\n    case '!': {\n      c = fscript_parser_get_char(parser);\n      if (c == '=') {\n        str_append_char(str, c);\n      } else {\n        fscript_parser_unget_char(parser, c);\n        fscript_parser_get_unary(parser, c, str);\n      }\n      TOKEN_INIT(t, TOKEN_FUNC, str);\n      return t;\n    }\n    case '|':\n    case '&': {\n      c = fscript_parser_get_char(parser);\n      if (c == str->str[0]) {\n        str_append_char(str, c);\n      } else {\n        fscript_parser_unget_char(parser, c);\n      }\n\n      t->type = TOKEN_FUNC;\n      t->size = str->size;\n      return t;\n    }\n    case '\\\"':\n    case '\\'': {\n      fscript_parser_parse_str(parser, c);\n      return t;\n    }\n    default: {\n      if (c == '+' || c == '-') {\n        fscript_parser_skip_seperators_and_comments(parser);\n        if (operator|| !tk_isdigit(parser->cursor[0])) {\n          fscript_parser_get_unary(parser, c, str);\n          TOKEN_INIT(t, TOKEN_FUNC, str);\n        } else {\n          fscript_parser_unget_char(parser, c);\n          fscript_parser_parse_id_or_number(parser, TOKEN_NUMBER);\n        }\n      } else if (tk_isdigit(c)) {\n        fscript_parser_unget_char(parser, c);\n        fscript_parser_parse_id_or_number(parser, TOKEN_NUMBER);\n      } else {\n        fscript_parser_unget_char(parser, c);\n        fscript_parser_parse_id_or_number(parser, TOKEN_ID);\n      }\n      return t;\n    }\n  }\n}\n\nstatic token_t* fscript_parser_get_token(fscript_parser_t* parser) {\n  return fscript_parser_get_token_ex(parser, FALSE);\n}\n\nstatic ret_t fscript_parser_expect_token(fscript_parser_t* parser, token_type_t type,\n                                         const char* msg) {\n  token_t* t = fscript_parser_get_token(parser);\n  if (t == NULL || t->type != type) {\n    return fscript_parser_set_error(parser, msg);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_unget_token(fscript_parser_t* parser) {\n  if (parser->token.type != TOKEN_EOF) {\n    parser->token.valid = TRUE;\n  }\n  return RET_OK;\n}\n\nstatic ret_t token_to_value(fscript_parser_t* parser, token_t* t, value_t* v) {\n  if (t->type == TOKEN_NUMBER) {\n    char number[64];\n    tk_strncpy_s(number, sizeof(number) - 1, t->token, t->size);\n    if (strchr(number, '.') != NULL) {\n      value_set_double(v, tk_atof(number));\n    } else {\n      uint64_t vv = 0;\n      const char* str = number;\n      bool_t has_minus = FALSE;\n      if (*str == '-') {\n        has_minus = TRUE;\n        str++;\n      }\n\n      vv = tk_atoul(str);\n      if (vv < INT_MAX) {\n        if (has_minus) {\n          value_set_int32(v, -vv);\n        } else {\n          value_set_int32(v, vv);\n        }\n      } else if (vv < UINT32_MAX) {\n        if (has_minus) {\n          value_set_int64(v, -vv);\n        } else {\n          value_set_uint32(v, vv);\n        }\n      } else {\n        if (has_minus) {\n          value_set_int64(v, -vv);\n        } else {\n          value_set_uint64(v, vv);\n        }\n      }\n    }\n  } else if (t->type == TOKEN_STR) {\n    value_dup_str_with_len(v, t->token, t->size);\n  } else if (t->type == TOKEN_ID) {\n    if (t->token[0] == 't' && strncmp(t->token, \"true\", 4) == 0) {\n      value_set_bool(v, TRUE);\n    } else if (t->token[0] == 'f' && strncmp(t->token, \"false\", 5) == 0) {\n      value_set_bool(v, FALSE);\n    } else {\n      const char* name = NULL;\n      const char* p = NULL;\n      value_set_id(v, t->token, t->size);\n      name = value_id(v);\n      p = strchr(name, '.');\n      if (p != NULL) {\n        char first_name[TK_NAME_LEN + 1];\n        tk_strncpy_s(first_name, TK_NAME_LEN, name, p - name);\n        value_id_suboffset(v) = p - name + 1;\n        value_id_index(v) = darray_find_index(parser->symbols, (void*)first_name);\n      } else {\n        value_id_suboffset(v) = 0;\n        value_id_index(v) = darray_find_index(parser->symbols, (void*)name);\n      }\n    }\n  } else {\n    return RET_FAIL;\n  }\n\n  return RET_OK;\n}\n\nret_t fscript_eval(tk_object_t* obj, const char* script, value_t* result) {\n  value_t v;\n  ret_t ret = RET_OK;\n  fscript_t* fscript = fscript_create(obj, script);\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n\n  if (fscript_exec(fscript, &v) == RET_OK && result != NULL) {\n    value_deep_copy(result, &v);\n  }\n  value_reset(&v);\n  fscript_destroy(fscript);\n\n  return ret;\n}\n\n/*expr parser*/\nstatic ret_t fexpr_parse_block(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  value_t v;\n  fscript_func_call_t* statements = fscript_func_call_create(parser, \"expr\", 4);\n  return_value_if_fail(statements != NULL, RET_OOM);\n\n  if (fscript_parse_statements(parser, statements) == RET_OK) {\n    func_args_push(&(acall->args), value_set_func(&v, statements));\n  } else {\n    fscript_func_call_destroy(statements);\n  }\n\n  fscript_parser_expect_token(parser, TOKEN_RBRACKET, \"expect \\\"}\\\"\");\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_function(fscript_parser_t* parser, value_t* result);\n\nstatic ret_t fexpr_parse_if(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  uint32_t i = 0;\n  token_t* t = NULL;\n  fexpr_parse_block(parser, acall);\n  t = fscript_parser_get_token(parser);\n\n  if (t != NULL && t->type == TOKEN_ID && tk_str_eq(t->token, \"else\")) {\n    t = fscript_parser_get_token(parser);\n    if (t != NULL && t->type == TOKEN_FUNC && tk_str_eq(t->token, \"if\")) {\n      value_t result;\n      fscript_func_call_t* elseif = NULL;\n      fscript_parser_unget_token(parser);\n      return_value_if_fail(fexpr_parse_function(parser, &result) == RET_OK, RET_FAIL);\n      elseif = value_func(&result);\n      for (i = 0; i < elseif->args.size; i++) {\n        func_args_push(&(acall->args), elseif->args.args + i);\n      }\n      elseif->args.size = 0;\n      fscript_func_call_destroy(elseif);\n      return RET_OK;\n    } else {\n      fscript_parser_unget_token(parser);\n      fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\");\n      return fexpr_parse_block(parser, acall);\n    }\n  } else {\n    fscript_parser_unget_token(parser);\n    return RET_OK;\n  }\n}\n\nstatic ret_t fexpr_parse_function(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  fscript_args_t* args = NULL;\n  token_t* t = fscript_parser_get_token(parser);\n  fscript_func_call_t* acall = NULL;\n  if (t->token[0] == '-' && t->size == 1) {\n    acall = fscript_func_call_create(parser, \"minus\", 5);\n  } else {\n    acall = fscript_func_call_create(parser, t->token, t->size);\n  }\n  value_set_func(result, acall);\n  return_value_if_fail(acall != NULL, RET_BAD_PARAMS);\n\n  args = &(acall->args);\n  return_value_if_fail(fscript_parser_expect_token(parser, TOKEN_LPAREN, \"expect \\\"(\\\"\") == RET_OK,\n                       RET_FAIL);\n\n  do {\n    t = fscript_parser_get_token(parser);\n    if (t == NULL) {\n      return fscript_parser_set_error(parser, \"expect \\\")\\\"\");\n    }\n\n    if (t->type == TOKEN_RPAREN) {\n      break;\n    } else {\n      fscript_parser_unget_token(parser);\n    }\n    value_set_int(&v, 0);\n    return_value_if_fail(fexpr_parse(parser, &v) == RET_OK, RET_FAIL);\n    func_args_push(args, &v);\n    t = fscript_parser_get_token(parser);\n\n    if (t == NULL) {\n      return fscript_parser_set_error(parser, \"expect \\\")\\\"\");\n    } else if (t->type == TOKEN_RPAREN) {\n      break;\n    }\n    fscript_parser_unget_token(parser);\n    if (acall->func == func_for) {\n      fscript_parser_expect_token(parser, TOKEN_SEMICOLON, \"expect \\\";\\\"\");\n    } else {\n      fscript_parser_expect_token(parser, TOKEN_COMMA, \"expect \\\",\\\"\");\n    }\n  } while (TRUE);\n\n  if (acall->func == func_if && acall->args.size == 1) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_if(parser, acall);\n    }\n  } else if ((acall->func == func_while || acall->func == func_until ||\n              acall->func == func_repeat_times) &&\n             acall->args.size == 1) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_block(parser, acall);\n    }\n  } else if (acall->func == func_for && acall->args.size == 3) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_block(parser, acall);\n    }\n  } else if (acall->func == func_for_in && acall->args.size == 2) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_block(parser, acall);\n    }\n  } else if (acall->func == func_repeat && acall->args.size == 4) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_block(parser, acall);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_term(fscript_parser_t* parser, value_t* result) {\n  ret_t ret = RET_OK;\n  token_t* t = fscript_parser_get_token(parser);\n  value_set_int(result, 0);\n  return_value_if_fail(t != NULL, RET_BAD_PARAMS);\n\n  if (t->type == TOKEN_NUMBER || t->type == TOKEN_ID || t->type == TOKEN_STR) {\n    if (t->type == TOKEN_ID && t->token[0] == '.') {\n      fscript_parser_set_error(parser, \"var can't begin with '.'\");\n    }\n    ret = token_to_value(parser, t, result);\n  } else if (t->type == TOKEN_FUNC) {\n    fscript_parser_unget_token(parser);\n    ret = fexpr_parse_function(parser, result);\n  } else if (t->type == TOKEN_RETURN) {\n    fscript_func_call_t* acall = fscript_func_call_create(parser, \"return\", 6);\n    return_value_if_fail(acall != NULL, RET_OOM);\n    value_set_func(result, acall);\n    t = fscript_parser_get_token(parser);\n    if (t != NULL && t->type != TOKEN_SEMICOLON && t->type != TOKEN_RBRACKET) {\n      value_t v;\n      value_set_int(&v, 0);\n      fscript_parser_unget_token(parser);\n      if (fexpr_parse(parser, &v) == RET_OK) {\n        func_args_push(&(acall->args), &v);\n      }\n    } else {\n      fscript_parser_unget_token(parser);\n    }\n  } else if (t->type == TOKEN_LPAREN) {\n    ret = fexpr_parse(parser, result);\n    return_value_if_fail(ret == RET_OK, ret);\n    ret = fscript_parser_expect_token(parser, TOKEN_RPAREN, \"expect )\");\n  } else {\n    fscript_parser_unget_token(parser);\n  }\n\n  return ret;\n}\n\nstatic ret_t fexpr_parse_unary(fscript_parser_t* parser, value_t* result) {\n  char c = '\\0';\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n  token_t* t = fscript_parser_get_token_ex(parser, FALSE);\n  if (t == NULL || t->type == TOKEN_EOF) {\n    return RET_OK;\n  }\n\n  c = t->token[0];\n  if (t->type == TOKEN_FUNC && (c == '!' || c == '~' || c == '-')) {\n    value_t v;\n    uint32_t i = 0;\n    bool_t valid = FALSE;\n    for (i = 0; i < t->size; i++) {\n      if (t->token[i] != c) {\n        return fscript_parser_set_error(parser, \"unexpected token\");\n      } else {\n        valid = !valid;\n      }\n    }\n\n    if (valid) {\n      acall = fscript_func_call_create(parser, &c, 1);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      value_set_func(result, acall);\n      return_value_if_fail(fexpr_parse_term(parser, &v) == RET_OK, RET_FAIL);\n      func_args_push(args, &v);\n    } else {\n      return_value_if_fail(fexpr_parse_term(parser, result) == RET_OK, RET_FAIL);\n    }\n  } else {\n    fscript_parser_unget_token(parser);\n    return_value_if_fail(fexpr_parse_term(parser, result) == RET_OK, RET_FAIL);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fsexpr_parse_product(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n  return_value_if_fail(fexpr_parse_unary(parser, result) == RET_OK, RET_FAIL);\n\n  while (TRUE) {\n    t = fscript_parser_get_token_ex(parser, TRUE);\n    if (t == NULL || t->type != TOKEN_FUNC) {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n\n    if (t->token[0] == '*' || t->token[0] == '/' || t->token[0] == '%') {\n      acall = fscript_func_call_create(parser, t->token, t->size);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      func_args_push(args, result);\n      value_set_func(result, acall);\n      v.type = VALUE_TYPE_INVALID;\n      fexpr_parse_unary(parser, &v);\n      if (v.type == VALUE_TYPE_INVALID) {\n        fscript_parser_set_error(parser, \"expect an expression\");\n      } else {\n        func_args_push(args, &v);\n      }\n    } else {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_sum(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n  return_value_if_fail(fsexpr_parse_product(parser, result) == RET_OK, RET_FAIL);\n\n  while (TRUE) {\n    t = fscript_parser_get_token_ex(parser, TRUE);\n    if (t == NULL || t->type != TOKEN_FUNC) {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n\n    if (t->token[0] == '+' || t->token[0] == '-') {\n      parser->token.valid = FALSE;\n      acall = fscript_func_call_create(parser, t->token, t->size);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      func_args_push(args, result);\n      value_set_func(result, acall);\n      v.type = VALUE_TYPE_INVALID;\n      fsexpr_parse_product(parser, &v);\n      if (v.type == VALUE_TYPE_INVALID) {\n        fscript_parser_set_error(parser, \"expect an expression\");\n      } else {\n        func_args_push(args, &v);\n      }\n    } else {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_compare(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n\n  value_set_int(result, 0);\n  return_value_if_fail(fexpr_parse_sum(parser, result) == RET_OK, RET_FAIL);\n\n  t = fscript_parser_get_token_ex(parser, TRUE);\n  if (t == NULL || t->type != TOKEN_FUNC || tk_str_eq(t->token, \"=\")) {\n    fscript_parser_unget_token(parser);\n    return RET_OK;\n  }\n\n  if (t->token[0] == '>' || t->token[0] == '<' || t->token[0] == '=' ||\n      (t->token[0] == '!' && t->token[1] == '=')) {\n    acall = fscript_func_call_create(parser, t->token, t->size);\n    return_value_if_fail(acall != NULL, RET_OOM);\n    args = &(acall->args);\n    func_args_push(args, result);\n    value_set_func(result, acall);\n    v.type = VALUE_TYPE_INVALID;\n    fexpr_parse_sum(parser, &v);\n    if (v.type == VALUE_TYPE_INVALID) {\n      fscript_parser_set_error(parser, \"expect an expression\");\n    } else {\n      func_args_push(args, &v);\n    }\n  } else {\n    fscript_parser_unget_token(parser);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_logic(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n\n  value_set_int(result, 0);\n  return_value_if_fail(fexpr_parse_compare(parser, result) == RET_OK, RET_FAIL);\n\n  while (TRUE) {\n    t = fscript_parser_get_token_ex(parser, TRUE);\n    if (t == NULL || t->type != TOKEN_FUNC || tk_str_eq(t->token, \"=\")) {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n\n    if (t->token[0] == '|' || t->token[0] == '&' || t->token[0] == '^') {\n      acall = fscript_func_call_create(parser, t->token, t->size);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      func_args_push(args, result);\n      value_set_func(result, acall);\n      v.type = VALUE_TYPE_INVALID;\n      fexpr_parse_compare(parser, &v);\n      if (v.type == VALUE_TYPE_INVALID) {\n        fscript_parser_set_error(parser, \"expect an expression\");\n      } else {\n        func_args_push(args, &v);\n      }\n    } else {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_question(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  ret_t ret = RET_OK;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n\n  value_set_str(&v, NULL);\n  if (fexpr_parse_logic(parser, result) == RET_OK) {\n    t = fscript_parser_get_token(parser);\n    if (t && t->type == TOKEN_QUESTION) {\n      acall = fscript_func_call_create(parser, \"if\", 2);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      func_args_push(args, result);\n      value_set_func(result, acall);\n\n      value_reset(&v);\n      return_value_if_fail(fexpr_parse_logic(parser, &v) == RET_OK, RET_FAIL);\n      func_args_push(args, &v);\n\n      return_value_if_fail(fscript_parser_expect_token(parser, TOKEN_COLON, \"expect :\") == RET_OK,\n                           RET_FAIL);\n      return_value_if_fail(fexpr_parse_logic(parser, &v) == RET_OK, RET_FAIL);\n      func_args_push(args, &v);\n    } else {\n      fscript_parser_unget_token(parser);\n    }\n  } else {\n    ret = RET_FAIL;\n  }\n\n  return ret;\n}\n\nstatic ret_t fexpr_parse(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  bool_t is_local = FALSE;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n  value_set_int(result, 0);\n\n  t = fscript_parser_get_token_ex(parser, TRUE);\n  if (t == NULL || t->type == TOKEN_RBRACKET || t->type == TOKEN_SEMICOLON) {\n    value_reset(result);\n    fscript_parser_unget_token(parser);\n    return RET_OK;\n  }\n\n  if (t->type == TOKEN_VAR) {\n    is_local = TRUE;\n  } else {\n    fscript_parser_unget_token(parser);\n  }\n  return_value_if_fail(fexpr_parse_question(parser, result) == RET_OK, RET_FAIL);\n\n  t = fscript_parser_get_token_ex(parser, TRUE);\n  if (t != NULL && tk_str_eq(t->token, \"=\")) {\n    const char* name = is_local ? \"set_local\" : \"=\";\n    acall = fscript_func_call_create(parser, name, strlen(name));\n    return_value_if_fail(acall != NULL, RET_OOM);\n    args = &(acall->args);\n    func_args_push(args, result);\n    value_set_func(result, acall);\n    v.type = VALUE_TYPE_INVALID;\n    fexpr_parse_question(parser, &v);\n    if (v.type == VALUE_TYPE_INVALID) {\n      fscript_parser_set_error(parser, \"expect an expression\");\n    } else {\n      func_args_push(args, &v);\n    }\n\n    if (is_local) {\n      darray_push_unique(parser->symbols, (void*)value_id(args->args));\n    }\n  } else {\n    fscript_parser_unget_token(parser);\n  }\n\n  return RET_OK;\n}\n\nstatic fscript_t* fscript_init_with_parser(fscript_t* fscript, fscript_parser_t* parser) {\n  fscript = fscript != NULL ? fscript : TKMEM_ZALLOC(fscript_t);\n  return_value_if_fail(fscript != NULL, NULL);\n  fscript->str = parser->temp;\n  fscript->obj = parser->obj;\n  fscript->first = parser->first;\n  fscript->funcs_def = parser->funcs_def;\n  fscript->code_id = parser->code_id;\n  fscript->lines = parser->row + 1;\n\n  if (s_hooks != NULL && s_hooks->on_init != NULL) {\n    s_hooks->on_init(fscript, parser->str);\n  }\n\n  parser->obj = NULL;\n  parser->first = NULL;\n  parser->temp.str = NULL;\n  parser->funcs_def = NULL;\n  parser->code_id = NULL;\n\n  return fscript;\n}\n\nstatic ret_t func_function(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  ret_t ret = RET_OK;\n  darray_t* saved_locals = fscript->locals;\n  fscript_function_def_t* func_def = (fscript_function_def_t*)(fscript->curr->ctx);\n  fscript_func_call_t* func = func_def->body;\n\n  func->func = func_noop;\n  fscript->locals = NULL;\n  if (func_def->params.size > 0 && args->size > 0) {\n    uint32_t i = 0;\n    uint32_t n = tk_min(func_def->params.size, args->size);\n    for (i = 0; i < n; i++) {\n      const value_t* value = args->args + i;\n      const char* name = (const char*)(func_def->params.elms[i]);\n      fscript_locals_create(fscript, name, value);\n    }\n  }\n\n  ret = fscript_exec_func(fscript, func_def->name, func, result);\n\n  fscript_locals_destroy(fscript);\n  fscript->locals = saved_locals;\n  fscript->returned = FALSE;\n\n  return ret;\n}\n\nstatic ret_t fscript_parse_function_def(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  value_t v;\n  char func_name[TK_NAME_LEN + 1];\n  fscript_function_def_t* func_def = NULL;\n  fscript_func_call_t* statements = NULL;\n  token_t* t = fscript_parser_get_token(parser);\n  darray_t* saved_symbols = parser->symbols;\n\n  if (t->type != TOKEN_FUNC) {\n    return fscript_parser_set_error(parser, \"expect function name\\n\");\n  }\n  tk_strncpy(func_name, t->token, TK_NAME_LEN);\n  fscript_parser_expect_token(parser, TOKEN_LPAREN, \"expect \\\"(\\\"\");\n  if (parser->funcs_def == NULL) {\n    parser->funcs_def = object_default_create();\n  }\n\n  if (tk_object_get_prop(parser->funcs_def, func_name, &v) == RET_OK) {\n    return fscript_parser_set_error(parser, \"duplicate function\\n\");\n  }\n  statements = fscript_func_call_create(parser, \"func\", 4);\n  return_value_if_fail(statements != NULL, RET_OOM);\n\n  func_def = fscript_function_def_create(func_name, statements);\n  return_value_if_fail(func_def != NULL, RET_OOM);\n  value_set_func_def(&v, func_def);\n  tk_object_set_prop(parser->funcs_def, func_name, &v);\n\n  parser->symbols = darray_create(5, NULL, (tk_compare_t)tk_str_cmp);\n  while (TRUE) {\n    t = fscript_parser_get_token(parser);\n    if (t == NULL || t->type == TOKEN_EOF || t->type == TOKEN_RPAREN) {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n    if (t->type == TOKEN_ID) {\n      fscript_function_def_add_param(func_def, t->token);\n      darray_push_unique(parser->symbols,\n                         (void*)darray_get(&(func_def->params), func_def->params.size - 1));\n    } else if (t->type == TOKEN_COMMA) {\n    } else {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n  }\n  fscript_parser_expect_token(parser, TOKEN_RPAREN, \"expect \\\")\\\"\");\n  fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\");\n  fscript_parse_statements(parser, statements);\n  fscript_parser_expect_token(parser, TOKEN_RBRACKET, \"expect \\\"}\\\"\");\n  darray_destroy(parser->symbols);\n  parser->symbols = saved_symbols;\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parse_statements(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  value_t v;\n  ret_t ret = RET_OK;\n  fscript_args_t* args = NULL;\n  return_value_if_fail(parser != NULL && acall != NULL, RET_BAD_PARAMS);\n\n  args = &(acall->args);\n\n  do {\n    token_t* t = NULL;\n    value_set_int(&v, 0);\n    ret = fexpr_parse(parser, &v);\n    if (ret == RET_OK) {\n      if (v.type != VALUE_TYPE_INVALID) {\n        func_args_push(args, &v);\n      }\n      t = fscript_parser_get_token(parser);\n      if (t == NULL) {\n        break;\n      }\n\n      if (t->type == TOKEN_FUNC || t->type == TOKEN_ID || t->type == TOKEN_NUMBER ||\n          t->type == TOKEN_STR || t->type == TOKEN_VAR || t->type == TOKEN_RETURN) {\n        fscript_parser_unget_token(parser);\n      } else if (t->type == TOKEN_RBRACKET || t->type == TOKEN_FUNC_DEF) {\n        fscript_parser_unget_token(parser);\n        break;\n      } else if (t->type != TOKEN_COMMA && t->type != TOKEN_SEMICOLON) {\n        return fscript_parser_set_error(parser, \"unexpected token\\n\");\n      }\n    } else {\n      if (v.type == VALUE_TYPE_FSCRIPT_FUNC) {\n        fscript_func_call_destroy(value_func(&v));\n      } else {\n        value_reset(&v);\n      }\n\n      break;\n    }\n  } while (parser->token.type != TOKEN_EOF);\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parse_all(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  ret_t ret = RET_OK;\n  while (ret == RET_OK) {\n    token_t* t = fscript_parser_get_token(parser);\n    if (t && t->type == TOKEN_FUNC_DEF) {\n      ret = fscript_parse_function_def(parser, acall);\n    } else if (t == NULL || t->type == TOKEN_EOF) {\n      break;\n    } else if (t->type == TOKEN_RBRACKET) {\n      fscript_parser_set_error(parser, \"unexpected token\");\n      break;\n    } else {\n      fscript_parser_unget_token(parser);\n      ret = fscript_parse_statements(parser, acall);\n    }\n  }\n\n  return ret;\n}\n\nfscript_parser_error_t* fscript_parser_error_init(fscript_parser_error_t* error) {\n  return_value_if_fail(error != NULL, NULL);\n  memset(error, 0x00, sizeof(fscript_parser_error_t));\n\n  return error;\n}\n\nret_t fscript_parser_error_deinit(fscript_parser_error_t* error) {\n  return_value_if_fail(error != NULL, RET_BAD_PARAMS);\n  TKMEM_FREE(error->token);\n  TKMEM_FREE(error->message);\n\n  return RET_OK;\n}\n\nret_t fscript_syntax_check(tk_object_t* obj, const char* script, fscript_parser_error_t* error) {\n  ret_t ret = RET_OK;\n  fscript_parser_t parser;\n  return_value_if_fail(obj != NULL && script != NULL && error != NULL, RET_BAD_PARAMS);\n  fscript_parser_error_init(error);\n  fscript_parser_init(&parser, obj, script, error);\n\n  parser.first = fscript_func_call_create(&parser, \"expr\", 4);\n  ret = fscript_parse_all(&parser, parser.first);\n  fscript_parser_deinit(&parser);\n\n  return ret;\n}\n\nstatic fscript_t* fscript_load(fscript_t* fscript, tk_object_t* obj, const char* script,\n                               const char* first_call_name, bool_t keep_func_name) {\n  ret_t ret = RET_OK;\n  fscript_parser_t parser;\n  fscript_parser_error_t error;\n  return_value_if_fail(script != NULL, NULL);\n\n  fscript_parser_error_init(&error);\n  fscript_parser_init(&parser, obj, script, &error);\n  parser.keep_func_name = keep_func_name;\n  parser.first = fscript_func_call_create(&parser, first_call_name, strlen(first_call_name));\n  ret = fscript_parse_all(&parser, parser.first);\n  if (ret == RET_OK) {\n    fscript = fscript_init_with_parser(fscript, &parser);\n    fscript_parser_deinit(&parser);\n  } else {\n    log_warn(\"parser error:%s\\n\", script);\n    fscript_parser_deinit(&parser);\n  }\n  fscript_parser_error_deinit(&error);\n\n  return fscript;\n}\n\nret_t fscript_reload(fscript_t* fscript, const char* script) {\n  tk_object_t* obj = NULL;\n  return_value_if_fail(fscript != NULL && fscript->obj != NULL && script != NULL, RET_BAD_PARAMS);\n  obj = fscript->obj;\n  fscript_reset(fscript);\n\n  return fscript_load(fscript, obj, script, \"expr\", FALSE) != NULL ? RET_OK : RET_FAIL;\n}\n\nfscript_t* fscript_init(fscript_t* fscript, tk_object_t* obj, const char* script,\n                        const char* first_call_name, bool_t keep_func_name) {\n  return fscript_load(fscript, obj, script, first_call_name, keep_func_name);\n}\n\nfscript_t* fscript_create_ex(tk_object_t* obj, const char* script, bool_t keep_func_name) {\n  return fscript_load(NULL, obj, script, \"expr\", keep_func_name);\n}\n\nfscript_t* fscript_create(tk_object_t* obj, const char* script) {\n  return fscript_create_ex(obj, script, FALSE);\n}\n\n/*functions*/\nstatic ret_t func_get_last_error(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  if (fscript->error_code != RET_OK) {\n    tk_object_t* obj = object_default_create();\n    return_value_if_fail(obj != NULL, RET_OOM);\n    tk_object_set_prop_int(obj, \"col\", fscript->error_col);\n    tk_object_set_prop_int(obj, \"line\", fscript->error_row);\n    tk_object_set_prop_int(obj, \"code\", fscript->error_code);\n    tk_object_set_prop_str(obj, \"message\", fscript->error_message);\n    value_set_object(result, obj);\n    result->free_handle = TRUE;\n  } else {\n    value_set_int(result, 0);\n    value_reset(result);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_has_error(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  value_set_bool(result, fscript->error_code != RET_OK);\n  return RET_OK;\n}\n\nstatic ret_t func_clear_error(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  fscript_set_error(fscript, RET_OK, NULL, NULL);\n  return RET_OK;\n}\n\nstatic ret_t func_sum(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  double v = 0;\n  uint32_t i = 0;\n  bool_t has_str = FALSE;\n  bool_t has_float = FALSE;\n  FSCRIPT_FUNC_CHECK(args->size > 0, RET_BAD_PARAMS);\n\n  for (i = 0; i < args->size; i++) {\n    int type = args->args[i].type;\n    if (type == VALUE_TYPE_STRING) {\n      has_str = TRUE;\n    }\n    if (type == VALUE_TYPE_FLOAT || type == VALUE_TYPE_DOUBLE || type == VALUE_TYPE_FLOAT32) {\n      has_float = TRUE;\n    }\n  }\n\n  if (has_str) {\n    str_t str;\n    char buff[64];\n    str_init(&str, 100);\n    for (i = 0; i < args->size; i++) {\n      str_append(&str, value_str_ex(args->args + i, buff, sizeof(buff) - 1));\n    }\n    value_dup_str(result, str.str);\n    str_reset(&str);\n  } else {\n    for (i = 0; i < args->size; i++) {\n      v += value_double(args->args + i);\n    }\n    if (has_float) {\n      value_set_double(result, v);\n    } else {\n      value_set_int(result, (int)v);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_int(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int(result, value_int(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_i8(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int8(result, value_int8(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_i16(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int16(result, value_int16(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_i32(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int(result, value_int(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_i64(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int64(result, value_int64(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_u8(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_uint8(result, value_uint8(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_u16(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_uint16(result, value_uint16(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_u32(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_uint32(result, value_uint32(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_u64(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_uint64(result, value_uint64(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_f32(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_float32(result, value_float32(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_double(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_double(result, value_double(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_binary(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  void* p = NULL;\n  uint32_t size = 0;\n  /*基本类型默认拷贝*/\n  bool_t clone = TRUE;\n  value_t* v = args->args;\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n\n  switch (v->type) {\n    case VALUE_TYPE_BOOL: {\n      size = sizeof(int8_t);\n      p = &(v->value.b);\n      break;\n    }\n    case VALUE_TYPE_INT8: {\n      size = sizeof(int8_t);\n      p = &(v->value.i8);\n      break;\n    }\n    case VALUE_TYPE_UINT8: {\n      size = sizeof(uint8_t);\n      p = &(v->value.u8);\n      break;\n    }\n    case VALUE_TYPE_INT16: {\n      size = sizeof(int16_t);\n      p = &(v->value.i16);\n      break;\n    }\n    case VALUE_TYPE_UINT16: {\n      size = sizeof(uint16_t);\n      p = &(v->value.u16);\n      break;\n    }\n    case VALUE_TYPE_INT32: {\n      size = sizeof(int32_t);\n      p = &(v->value.i32);\n      break;\n    }\n    case VALUE_TYPE_UINT32: {\n      size = sizeof(uint32_t);\n      p = &(v->value.u32);\n      break;\n    }\n    case VALUE_TYPE_INT64: {\n      size = sizeof(int64_t);\n      p = &(v->value.i64);\n      break;\n    }\n    case VALUE_TYPE_UINT64: {\n      size = sizeof(uint64_t);\n      p = &(v->value.u64);\n      break;\n    }\n    case VALUE_TYPE_FLOAT: {\n      size = sizeof(float_t);\n      p = &(v->value.f32);\n      break;\n    }\n    case VALUE_TYPE_FLOAT32: {\n      size = sizeof(float);\n      p = &(v->value.f32);\n      break;\n    }\n    case VALUE_TYPE_DOUBLE: {\n      size = sizeof(double);\n      p = &(v->value.f64);\n      break;\n    }\n    case VALUE_TYPE_STRING: {\n      p = (void*)value_str(v);\n      size = tk_strlen(value_str(v));\n      clone = FALSE;\n      break;\n    }\n    case VALUE_TYPE_WSTRING: {\n      p = (void*)value_wstr(v);\n      size = wcslen(value_wstr(v)) * sizeof(wchar_t);\n      clone = FALSE;\n      break;\n    }\n    case VALUE_TYPE_POINTER: {\n      p = value_pointer(v);\n      size = args->size > 1 ? value_uint32(args->args + 1) : 0;\n      clone = FALSE;\n      break;\n    }\n    case VALUE_TYPE_BINARY: {\n      p = v->value.binary_data.data;\n      size = v->value.binary_data.size;\n      clone = FALSE;\n      break;\n    }\n    case VALUE_TYPE_SIZED_STRING: {\n      p = v->value.sized_str.str;\n      size = v->value.sized_str.size;\n      clone = FALSE;\n      break;\n    }\n    default: {\n      log_debug(\"not supported type\\n\");\n      break;\n    }\n  }\n\n  if (p == NULL || size == 0) {\n    value_set_binary_data(result, p, size);\n    return RET_OK;\n  }\n\n  /*参数1指定长度*/\n  if (args->size > 1) {\n    uint32_t esize = value_uint32(args->args + 1);\n    if (esize <= size) {\n      size = esize;\n    } else {\n      log_debug(\"size is too large, use default\\n\");\n    }\n  }\n\n  /*参数2要求复制*/\n  if (args->size > 2 && value_bool(args->args + 2)) {\n    clone = TRUE;\n  }\n\n  if (clone) {\n    p = tk_memdup(p, size);\n    value_set_binary_data(result, p, size);\n    result->free_handle = TRUE;\n  } else {\n    value_set_binary_data(result, p, size);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_str(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  str_t* str = &(fscript->str);\n  value_t* v = args->args;\n  bool_t force_pointer_as_str = args->size == 2 && value_bool(args->args + 1);\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n\n  if (force_pointer_as_str) {\n    if (v->type == VALUE_TYPE_POINTER) {\n      value_set_str(result, (const char*)value_pointer(v));\n      return RET_OK;\n    } else if (v->type == VALUE_TYPE_BINARY) {\n      value_set_str(result, (const char*)(v->value.binary_data.data));\n      return RET_OK;\n    }\n  }\n  str_from_value(str, args->args);\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}\n\nstatic ret_t func_one_of(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  char sep = ';';\n  int32_t index = 0;\n  const char* strs = NULL;\n  const char* start = NULL;\n\n  value_set_str(result, \"\");\n  FSCRIPT_FUNC_CHECK(args->size >= 2, RET_BAD_PARAMS);\n  FSCRIPT_FUNC_CHECK(args->args[0].type == VALUE_TYPE_STRING, RET_BAD_PARAMS);\n  strs = value_str(args->args);\n  FSCRIPT_FUNC_CHECK(strs != NULL, RET_BAD_PARAMS);\n\n  if (args->size > 2 && args->args[2].type == VALUE_TYPE_STRING) {\n    const char* p = value_str(args->args + 2);\n    if (p != NULL) {\n      sep = *p;\n    }\n  }\n\n  start = strs;\n  index = value_int(args->args + 1);\n\n  while (index > 0) {\n    while (*start && *start != sep) {\n      start++;\n    }\n    if (*start == '\\0') {\n      break;\n    }\n    index--;\n    start++;\n  }\n\n  if (start != NULL) {\n    const char* end = strchr(start, sep);\n    if (end != NULL) {\n      value_dup_str_with_len(result, start, end - start);\n    } else {\n      value_dup_str(result, start);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_join(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  char buff[64];\n  str_t* str = &(fscript->str);\n  value_set_bool(result, FALSE);\n  FSCRIPT_FUNC_CHECK(args->size > 1, RET_BAD_PARAMS);\n\n  str_set(str, \"\");\n  value_set_bool(result, TRUE);\n  for (i = 1; i < args->size; i++) {\n    if (i > 1) {\n      str_append(str, value_str_ex(args->args, buff, sizeof(buff)));\n    }\n    str_append(str, value_str_ex(args->args + i, buff, sizeof(buff)));\n  }\n\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}\n\nstatic ret_t func_set_local(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  const char* name = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\nname = ",
    "raw_res": "",
    "prompt_res": "value_id(args->args);",
    "gt": "value_id(args->args);"
  },
  {
    "id": 834,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/rlog.c",
    "input": "﻿/**\n * File:   rlog.c\n * Author: AWTK Develop Team\n * Brief:  rotate log api\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2020-11-18 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/rlog.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/mutex_nest.h\"\n\n#ifdef HAS_STDIO\n#define my_return_value_if_fail(p, value)                                \\\n  if (!(p)) {                                                            \\\n    printf(\"%s:%d condition(\" #p \") failed!\\n\", __FUNCTION__, __LINE__); \\\n    fflush(stdout);                                                      \\\n    return (value);                                                      \\\n  }\n#else\n#define my_return_value_if_fail(p, value) \\\n  if (!(p)) {                             \\\n    return (value);                       \\\n  }\n#endif\n\nrlog_t* rlog_create(const char* filename_pattern, uint32_t max_size, uint32_t buff_size) {\n  rlog_t* log = NULL;\n  fs_stat_info_t fst;\n  fs_file_t* fp = NULL;\n  uint32_t index = 0;\n  char filename[MAX_PATH + 1];\n  my_return_value_if_fail(filename_pattern != NULL && max_size > 1000 && buff_size > 32, NULL);\n\n  memset(filename, 0x00, sizeof(filename));\n  tk_snprintf(filename, MAX_PATH, filename_pattern, (int)index);\n  if (fs_stat(os_fs(), filename, &fst) == RET_OK) {\n    if (fst.size < (max_size - buff_size)) {\n      fp = fs_open_file(os_fs(), filename, \"ab+\");\n    } else {\n      index = 1;\n      tk_snprintf(filename, MAX_PATH, filename_pattern, (int)(index));\n      fp = fs_open_file(os_fs(), filename, \"ab+\");\n    }\n  } else {\n    fp = fs_open_file(os_fs(), filename, \"wb+\");\n  }\n  my_return_value_if_fail(fp != NULL, NULL);\n\n  log = TKMEM_ZALLOC(rlog_t);\n  if (log != NULL) {\n    log->index = index;\n    log->max_size = max_size;\n    log->buff_size = buff_size;\n    log->mutex = tk_mutex_nest_create();\n    log->filename_pattern = tk_strdup(filename_pattern);\n\n    if (log->filename_pattern != NULL) {\n      log->fp = fp;\n    } else {\n      fs_file_close(fp);\n      TKMEM_FREE(log);\n    }\n  } else {\n    fs_file_close(fp);\n  }\n\n  return log;\n}\n\nret_t rlog_write(rlog_t* log, const char* str) {\n  uint32_t len = 0;\n  fs_stat_info_t fst;\n  my_return_value_if_fail(log != NULL && log->fp != NULL && str != NULL, RET_BAD_PARAMS);\n  my_return_value_if_fail(fs_file_stat(log->fp, &fst) == RET_OK, RET_BAD_PARAMS);\n\n  if (tk_mutex_nest_lock(log->mutex) == RET_OK) {\n    len = strlen(str);\n    if ((fst.size + len) > log->max_size) {\n      char filename0[MAX_PATH + 1];\n      char filename1[MAX_PATH + 1];\n\n      fs_file_close(log->fp);\n      memset(filename1, 0x00, sizeof(filename1));\n      tk_snprintf(filename1, MAX_PATH, log->filename_pattern, (int)1);\n      if (log->index == 1) {\n        memset(filename0, 0x00, sizeof(filename0));\n        tk_snprintf(filename0, MAX_PATH, log->filename_pattern, (int)0);\n        fs_remove_file(os_fs(), filename0);\n        fs_file_rename(os_fs(), filename1, filename0);\n      }\n      log->index = 1;\n      log->fp = fs_open_file(os_fs(), filename1, \"wb+\");\n    }\n    if (log->fp != NULL) {\n      fs_file_write(log->fp, str, len);\n      fs_file_sync(log->fp);\n    }\n    tk_mutex_nest_unlock(log->mutex);\n  }\n\n  return RET_OK;\n}\n\nret_t rlog_print(rlog_t* log, const char* format, ...) {\n  va_list va;\n  ret_t ret = RET_OK;\n  my_return_value_if_fail(log != NULL && log->fp != NULL && format != NULL, RET_BAD_PARAMS);\n  my_return_value_if_fail(log->buff_size > 0, RET_BAD_PARAMS);\n\n  if (tk_mutex_nest_lock(log->mutex) == RET_OK) {\n    if (log->buff == NULL) {\n      log->buff = TKMEM_ALLOC(log->buff_size + 1);\n      if (log->buff == NULL) {\n        tk_mutex_nest_unlock(log->mutex);\n        return RET_OOM;\n      }\n      memset(log->buff, 0x00, log->buff_size + 1);\n    }\n\n    va_start(va, format);\n    tk_vsnprintf(log->buff, log->buff_size, format, va);\n    va_end(va);\n\nret = ",
    "raw_res": "0;",
    "prompt_res": "rlog_write(log, log->buff);",
    "gt": "rlog_write(log, log->buff);"
  },
  {
    "id": 867,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/object_wbuffer.c",
    "input": "﻿/**\n * File:   object_wbuffer.c\n * Author: AWTK Develop Team\n * Brief:  wrap wbuffer to an object.\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY { without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2021-01-03 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/value.h\"\n#include \"tkc/utils.h\"\n#include \"object_wbuffer.h\"\n\nstatic ret_t object_wbuffer_on_destroy(tk_object_t* obj) {\n  object_wbuffer_t* o = OBJECT_WBUFFER(obj);\n  return_value_if_fail(o != NULL && o->wbuffer != NULL, RET_BAD_PARAMS);\n\n  wbuffer_deinit(o->wbuffer);\n  o->wbuffer = NULL;\n\n  return RET_OK;\n}\n\nstatic ret_t object_wbuffer_set_prop(tk_object_t* obj, const char* name, const value_t* v) {\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t object_wbuffer_get_prop(tk_object_t* obj, const char* name, value_t* v) {\n  ret_t ret = RET_NOT_FOUND;\n  object_wbuffer_t* o = OBJECT_WBUFFER(obj);\n  return_value_if_fail(o != NULL && o->wbuffer != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, \"cursor\")) {\n    value_set_uint32(v, o->wbuffer->cursor);\n    ret = RET_OK;\n  } else if (tk_str_eq(name, \"capacity\")) {\n    value_set_uint32(v, o->wbuffer->capacity);\n    ret = RET_OK;\n  } else if (tk_str_eq(name, \"data\")) {\n    value_set_pointer(v, o->wbuffer->data);\n    ret = RET_OK;\n  }\n\n  return ret;\n}\n\nstatic const object_vtable_t s_object_wbuffer_vtable = {.type = \"object_wbuffer\",\n                                                        .desc = \"object_wbuffer\",\n                                                        .size = sizeof(object_wbuffer_t),\n                                                        .is_collection = FALSE,\n                                                        .on_destroy = object_wbuffer_on_destroy,\n                                                        .get_prop = object_wbuffer_get_prop,\n                                                        .set_prop = object_wbuffer_set_prop};\n\ntk_object_t* object_wbuffer_create_ex(bool_t extendable, uint8_t* data, uint32_t capacity) {\n  tk_object_t* o = NULL;\n  object_wbuffer_t* wrapper = NULL;\n  o = tk_object_create(&s_object_wbuffer_vtable);\n  return_value_if_fail(o != NULL, NULL);\n\n  wrapper = OBJECT_WBUFFER(o);\n  return_value_if_fail(wrapper != NULL, NULL);\n\n  if (extendable) {\n    wrapper->wbuffer = wbuffer_init_extendable(&(wrapper->awbuffer));\n  } else {\nwrapper->wbuffer = ",
    "raw_res": "wbuffer_init(data, capacity);",
    "prompt_res": "wbuffer_init(&(wrapper->awbuffer), data, capacity);",
    "gt": "wbuffer_init(&(wrapper->awbuffer), data, capacity);"
  },
  {
    "id": 894,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/object_array.c",
    "input": "﻿/**\n * File:   object_array.c\n * Author: AWTK Develop Team\n * Brief:  object array\n *\n * Copyright (c) 2019 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY { without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-01-10 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/value.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/named_value.h\"\n#include \"tkc/object_array.h\"\n\nstatic ret_t object_array_clean_invalid_props(tk_object_t* obj) {\n  object_array_t* o = OBJECT_ARRAY(obj);\n  event_t e = event_init(EVT_ITEMS_CHANGED, o);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n  if (o->size > 0) {\n    uint32_t i = 0;\n    value_t* dst = o->props;\n\n    for (i = 0; i < o->size; i++) {\n      value_t* iter = o->props + i;\n\n      if (iter->type != VALUE_TYPE_INVALID) {\n        if (dst != iter) {\n          memcpy(dst, iter, sizeof(value_t));\n        }\n        dst++;\n      }\n    }\n\n    o->size = dst - o->props;\n  }\n\n  emitter_dispatch(EMITTER(o), &e);\n\n  return RET_OK;\n}\n\nret_t object_array_clear_props(tk_object_t* obj) {\n  uint32_t i = 0;\n  object_array_t* o = OBJECT_ARRAY(obj);\n  event_t e = event_init(EVT_ITEMS_CHANGED, o);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n\n  for (i = 0; i < o->size; i++) {\n    value_t* iter = o->props + i;\n    value_reset(iter);\n  }\n\n  o->size = 0;\n  emitter_dispatch(EMITTER(o), &e);\n\n  return RET_OK;\n}\n\nstatic ret_t object_array_on_destroy(tk_object_t* obj) {\n  object_array_t* o = OBJECT_ARRAY(obj);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n\n  object_array_clear_props(obj);\n  o->capacity = 0;\n  TKMEM_FREE(o->props);\n\n  return RET_OK;\n}\n\nstatic int32_t object_array_compare(tk_object_t* obj, tk_object_t* other) {\n  return tk_str_cmp(obj->name, other->name);\n}\n\nstatic ret_t object_array_extend(tk_object_t* obj) {\n  ret_t ret = RET_OOM;\n  object_array_t* o = OBJECT_ARRAY(obj);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n\n  if (o->size < o->capacity) {\n    ret = RET_OK;\n  } else {\n    value_t* props = NULL;\n    uint32_t capacity = o->capacity + (o->capacity >> 1) + 1;\n    props = TKMEM_REALLOCT(value_t, o->props, capacity);\n\n    if (props != NULL) {\n      o->props = props;\n      o->capacity = capacity;\n      ret = RET_OK;\n    }\n  }\n\n  return ret;\n}\n\nret_t object_array_insert(tk_object_t* obj, uint32_t index, const value_t* v) {\n  value_t* s = NULL;\n  value_t* d = NULL;\n  value_t* p = NULL;\n  object_array_t* o = OBJECT_ARRAY(obj);\n  event_t e = event_init(EVT_ITEMS_CHANGED, o);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n\n  return_value_if_fail(o != NULL && v != NULL, RET_BAD_PARAMS);\n  index = tk_min(index, o->size);\n  return_value_if_fail(object_array_extend(obj) == RET_OK, RET_OOM);\n\n  p = o->props + index;\n  d = o->props + o->size;\n  s = d - 1;\n\n  while (s >= p) {\n    *d-- = *s--;\n  }\n  value_deep_copy(p, v);\n  o->size++;\n  emitter_dispatch(EMITTER(o), &e);\n\n  return RET_OK;\n}\n\nret_t object_array_push(tk_object_t* obj, const value_t* v) {\n  object_array_t* o = OBJECT_ARRAY(obj);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n\n  return object_array_insert(obj, o->size, v);\n}\n\nstatic int32_t object_array_parse_index(const char* name) {\n  if (tk_isdigit(*name)) {\n    return tk_atoi(name);\n  } else if (*name == '[') {\n    return tk_atoi(name + 1);\n  } else if (tk_str_eq(name, \"-1\")) {\n    return -1;\n  } else {\n    return -2;\n  }\n}\n\nint32_t object_array_index_of(tk_object_t* obj, const value_t* v) {\n  int32_t i = 0;\n  object_array_t* o = OBJECT_ARRAY(obj);\n  return_value_if_fail(o != NULL, -1);\n\n  for (i = 0; i < o->size; i++) {\n    value_t* iter = o->props + i;\n    if (value_equal(iter, v)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nint32_t object_array_last_index_of(tk_object_t* obj, const value_t* v) {\n  int32_t i = 0;\n  object_array_t* o = OBJECT_ARRAY(obj);\n  return_value_if_fail(o != NULL, -1);\n\n  if (o->size > 0) {\n    for (i = o->size - 1; i >= 0; i--) {\n      value_t* iter = o->props + i;\n      if (value_equal(iter, v)) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n}\n\nret_t object_array_remove(tk_object_t* obj, uint32_t index) {\n  return object_array_get_and_remove(obj, index, NULL);\n}\n\nret_t object_array_get_and_remove(tk_object_t* obj, uint32_t index, value_t* v) {\n  ret_t ret = RET_NOT_FOUND;\n  object_array_t* o = OBJECT_ARRAY(obj);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n\n  if (index < o->size) {\n    value_t* iter = o->props + index;\n    if (v != NULL) {\n      *v = *iter;\n      memset(iter, 0x00, sizeof(*iter));\n    } else {\n      value_reset(iter);\n    }\n    ret = object_array_clean_invalid_props(obj);\n  }\n\n  return ret;\n}\n\nret_t object_array_shift(tk_object_t* obj, value_t* v) {\n  return object_array_get_and_remove(obj, 0, v);\n}\n\nstatic ret_t object_array_remove_prop(tk_object_t* obj, const char* name) {\n  int32_t index = object_array_parse_index(name);\n\n  return object_array_remove(obj, index);\n}\n\nret_t object_array_pop(tk_object_t* obj, value_t* v) {\n  value_t* last = NULL;\n  object_array_t* o = OBJECT_ARRAY(obj);\n  event_t e = event_init(EVT_ITEMS_CHANGED, o);\n  return_value_if_fail(o != NULL && o->size > 0, RET_BAD_PARAMS);\n  last = o->props + o->size - 1;\n  *v = *last;\n  memset(last, 0x00, sizeof(value_t));\n  o->size--;\n\n  emitter_dispatch(EMITTER(o), &e);\n\n  return RET_OK;\n}\n\nret_t object_array_set(tk_object_t* obj, uint32_t index, const value_t* v) {\n  ret_t ret = RET_NOT_FOUND;\n  object_array_t* o = OBJECT_ARRAY(obj);\n  event_t e = event_init(EVT_ITEMS_CHANGED, o);\n  return_value_if_fail(object_array_extend(obj) == RET_OK, RET_OOM);\n\n  if (index < o->size) {\n    value_t* iter = o->props + index;\n    value_reset(iter);\n    ret = value_deep_copy(iter, v);\n    emitter_dispatch(EMITTER(o), &e);\n  } else if (index == 0xffffffff) {\nret = ",
    "raw_res": "0;",
    "prompt_res": "object_array_push(obj, v);",
    "gt": "object_array_push(obj, v);"
  },
  {
    "id": 909,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/object_locker.c",
    "input": "﻿/**\n * File:   object_locker.c\n * Author: AWTK Develop Team\n * Brief:  decorate object with lock\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY { without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2020-06-12 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/value.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/object_locker.h\"\n\nstatic ret_t object_locker_on_destroy(tk_object_t* obj) {\n  object_locker_t* o = OBJECT_LOCKER(obj);\n  return_value_if_fail(o != NULL && o->mutex != NULL, RET_BAD_PARAMS);\n  tk_mutex_nest_destroy(o->mutex);\n  emitter_off_by_ctx(EMITTER(o->obj), o);\n  TK_OBJECT_UNREF(o->obj);\n\n  return RET_OK;\n}\n\nstatic int32_t object_locker_compare(tk_object_t* obj, tk_object_t* other) {\n  object_locker_t* o = OBJECT_LOCKER(obj);\n  return_value_if_fail(o != NULL && o->obj != NULL, -1);\n  return tk_object_compare(o->obj, other);\n}\n\nstatic ret_t object_locker_remove_prop(tk_object_t* obj, const char* name) {\n  ret_t ret = RET_NOT_FOUND;\n  object_locker_t* o = OBJECT_LOCKER(obj);\n  return_value_if_fail(o != NULL && o->mutex != NULL, RET_BAD_PARAMS);\n  if (tk_mutex_nest_lock(o->mutex) == RET_OK) {\nret = ",
    "raw_res": "0;",
    "prompt_res": "tk_object_remove_prop(o->obj, name);",
    "gt": "tk_object_remove_prop(o->obj, name);"
  },
  {
    "id": 927,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/mem.c",
    "input": "﻿/**\n * File:   mem.c\n * Author: AWTK Develop Team\n * Brief:  simple memory manager\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-13 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include <stdarg.h>\n#include \"tkc/mem.h\"\n#include \"tkc/time_now.h\"\n#include \"tkc/mem_allocator_oom.h\"\n#include \"tkc/mem_allocator_pool.h\"\n\nstatic mem_allocator_oom_t s_oom;\n\n#ifdef ENABLE_MEM_LEAK_CHECK\n#include \"tkc/mem_allocator_debug.h\"\nstatic mem_allocator_debug_t s_debug;\n#endif /*ENABLE_MEM_LEAK_CHECK*/\n\nstatic mem_allocator_t* s_allocator = NULL;\n\n#define MAX_BLOCK_SIZE 0xffff0000\n\n#ifdef HAS_STD_MALLOC\n#include \"tkc/mem_allocator_std.h\"\n\n#ifdef ENABLE_MEM_LEAK_CHECK\n#include \"tkc/mem_allocator_lock.h\"\nstatic mem_allocator_lock_t s_lock;\n#endif /*ENABLE_MEM_LEAK_CHECK*/\n\nbool_t tk_mem_is_valid_addr(void* addr) {\n  return ((uintptr_t)addr > 0x10000);\n}\n\nstatic mem_allocator_t* mem_allocator_get(void) {\n  static mem_allocator_std_t std;\n  if (s_allocator != NULL) {\n    return s_allocator;\n  }\n\n  s_allocator = mem_allocator_std_init(&std);\n#ifdef ENABLE_MEM_LEAK_CHECK\n  s_allocator = mem_allocator_debug_init(&s_debug, s_allocator);\n  s_allocator = mem_allocator_lock_init(&s_lock, s_allocator);\n#endif /*ENABLE_MEM_LEAK_CHECK*/\n  s_allocator = mem_allocator_oom_init(&s_oom, s_allocator);\n\n  return s_allocator;\n}\n\nret_t tk_mem_init_stage2(void) {\n  return RET_OK;\n}\n\n#else /*non std memory manager*/\n#include \"tkc/mem_allocator_lock.h\"\n#include \"tkc/mem_allocator_composite.h\"\n\nstatic mem_allocator_lock_t s_lock;\n\nstatic mem_allocator_pool_t pool;\nstatic mem_allocator_composite_t composite;\n\nbool_t tk_mem_is_valid_addr(void* addr) {\n  return mem_allocator_composite_is_valid_addr(MEM_ALLOCATOR(&composite), addr);\n}\n\nret_t tk_mem_init_ex(void* buffer, uint32_t size, ...) {\n  va_list va;\n  va_start(va, size);\n  s_allocator = mem_allocator_composite_init_va(&composite, buffer, size, va);\n  va_end(va);\n\n  return_value_if_fail(s_allocator != NULL, RET_BAD_PARAMS);\n\n  if (size > 32 * 1024) {\n    if (size < 100 * 1024) {\n      s_allocator = mem_allocator_pool_init(&pool, s_allocator, 100, 100, 80, 80, 32);\n    } else if (size < 1000 * 1024) {\n      s_allocator = mem_allocator_pool_init(&pool, s_allocator, 500, 500, 500, 200, 200);\n    } else {\n      s_allocator = mem_allocator_pool_init(&pool, s_allocator, 1000, 1000, 1000, 500, 500);\n    }\n  }\n#ifdef ENABLE_MEM_LEAK_CHECK\n  s_allocator = mem_allocator_debug_init(&s_debug, s_allocator);\n#endif /*ENABLE_MEM_LEAK_CHECK*/\n\n  return s_allocator != NULL ? RET_OK : RET_FAIL;\n}\n\nret_t tk_mem_init(void* buffer, uint32_t size) {\n  return tk_mem_init_ex(buffer, size, NULL, 0);\n}\n\nret_t tk_mem_init_stage2(void) {\n  return_value_if_fail(s_allocator != NULL, RET_FAIL);\n  s_allocator = mem_allocator_lock_init(&s_lock, s_allocator);\n  s_allocator = mem_allocator_oom_init(&s_oom, s_allocator);\n\n  return RET_OK;\n}\n\nstatic mem_allocator_t* mem_allocator_get(void) {\n  return s_allocator;\n}\n\n#if (!defined(WITH_SDL) && !defined(LINUX))\n#define EXPORT_STD_MALLOC 1\n#endif\n\n#if defined(EXPORT_STD_MALLOC)\n/*export std malloc*/\nvoid* calloc(size_t count, size_t size) {\n  return tk_calloc(count, size, __FUNCTION__, __LINE__);\n}\n\nvoid free(void* ptr) {\n  tk_free(ptr);\n}\n\nvoid* malloc(size_t size) {\n  return tk_alloc(size, __FUNCTION__, __LINE__);\n}\n\nvoid* realloc(void* ptr, size_t size) {\n  return tk_realloc(ptr, size, __FUNCTION__, __LINE__);\n}\n#endif /*WITH_SDL*/\n\n#endif /*HAS_STD_MALLOC*/\n\nvoid* tk_calloc(uint32_t nmemb, uint32_t size, const char* func, uint32_t line) {\n  void* addr = NULL;\n  uint32_t total_size = size * nmemb;\n  mem_allocator_t* allocator = mem_allocator_get();\n  return_value_if_fail(allocator != NULL, NULL);\n\naddr = ",
    "raw_res": "mem_allocator_calloc(allocator, total_size, func, line);",
    "prompt_res": "mem_allocator_alloc(allocator, total_size, func, line);",
    "gt": "mem_allocator_alloc(allocator, total_size, func, line);"
  },
  {
    "id": 936,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/event_source_idle.c",
    "input": "﻿/**\n * File:   event_source_idle.h\n * Author: AWTK Develop Team\n * Brief:  event source idle\n *\n * Copyright (c) 2019 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-09-30 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/event_source_idle.h\"\n\nstatic const object_vtable_t s_event_source_idle_vtable = {\n    .type = \"event_source_idle\", .desc = \"event_source_idle\", .size = sizeof(event_source_idle_t)};\n\nstatic int32_t event_source_idle_get_fd(event_source_t* source) {\n  return -1;\n}\n\nstatic ret_t event_source_idle_check(event_source_t* source) {\n  return RET_OK;\n}\n\nstatic ret_t event_source_idle_dispatch(event_source_t* source) {\n  event_source_idle_t* event_source_idle = EVENT_SOURCE_IDLE(source);\n\n  return idle_manager_dispatch(event_source_idle->idle_manager);\n}\n\nuint32_t event_source_idle_get_wakeup_time(event_source_t* source) {\n  event_source_idle_t* event_source_idle = EVENT_SOURCE_IDLE(source);\n  uint32_t nr = idle_manager_count(event_source_idle->idle_manager);\n\n  return nr > 0 ? 0 : 0xffff;\n}\n\nevent_source_t* event_source_idle_create(idle_manager_t* idle_manager) {\n  tk_object_t* obj = NULL;\n  event_source_t* event_source = NULL;\n  event_source_idle_t* event_source_idle = NULL;\n  return_value_if_fail(idle_manager != NULL, NULL);\n\nobj = ",
    "raw_res": "0;",
    "prompt_res": "tk_object_create(&s_event_source_idle_vtable);",
    "gt": "tk_object_create(&s_event_source_idle_vtable);"
  },
  {
    "id": 953,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/fs.c",
    "input": "﻿/**\n * File:   fs.h\n * Author: AWTK Develop Team\n * Brief:  simple fs api\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-04-27 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/fs.h\"\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/path.h\"\n\nint32_t fs_file_read(fs_file_t* file, void* buffer, uint32_t size) {\n  return_value_if_fail(file != NULL && file->vt != NULL && buffer != NULL && file->vt->read != NULL,\n                       -1);\n\n  return file->vt->read(file, buffer, size);\n}\n\nint32_t fs_file_write(fs_file_t* file, const void* buffer, uint32_t size) {\n  return_value_if_fail(\n      file != NULL && file->vt != NULL && buffer != NULL && file->vt->write != NULL, -1);\n\n  return file->vt->write(file, buffer, size);\n}\n\nint32_t fs_file_printf(fs_file_t* file, const char* const format_str, ...) {\n  va_list v_l;\n  int32_t ret = 0;\n  return_value_if_fail(file != NULL && file->vt != NULL && file->vt->printf != NULL, -1);\n\n  va_start(v_l, format_str);\n  ret = file->vt->printf(file, format_str, v_l);\n  va_end(v_l);\n\n  return ret;\n}\n\nret_t fs_file_seek(fs_file_t* file, int32_t offset) {\n  return_value_if_fail(file != NULL && file->vt != NULL && file->vt->seek != NULL, RET_BAD_PARAMS);\n\n  return file->vt->seek(file, offset);\n}\n\nret_t fs_file_truncate(fs_file_t* file, int32_t offset) {\n  return_value_if_fail(file != NULL && file->vt != NULL && file->vt->truncate != NULL,\n                       RET_BAD_PARAMS);\n  fs_file_seek(file, 0);\n  return file->vt->truncate(file, offset);\n}\n\nbool_t fs_file_eof(fs_file_t* file) {\n  return_value_if_fail(file != NULL && file->vt != NULL && file->vt->eof != NULL, TRUE);\n\n  return file->vt->eof(file);\n}\n\nint64_t fs_file_tell(fs_file_t* file) {\n  return_value_if_fail(file != NULL && file->vt != NULL && file->vt->tell != NULL, -1);\n\n  return file->vt->tell(file);\n}\n\nint64_t fs_file_size(fs_file_t* file) {\n  return_value_if_fail(file != NULL && file->vt != NULL && file->vt->size != NULL, -1);\n\n  return file->vt->size(file);\n}\n\nret_t fs_file_close(fs_file_t* file) {\n  return_value_if_fail(file != NULL && file->vt != NULL && file->vt->close != NULL, RET_BAD_PARAMS);\n\n  return file->vt->close(file);\n}\n\nret_t fs_file_sync(fs_file_t* file) {\n  return_value_if_fail(file != NULL && file->vt != NULL && file->vt->sync != NULL, RET_BAD_PARAMS);\n\n  return file->vt->sync(file);\n}\n\nret_t fs_file_stat(fs_file_t* file, fs_stat_info_t* fst) {\n  return_value_if_fail(file != NULL && file->vt != NULL && file->vt->stat != NULL && fst != NULL,\n                       RET_BAD_PARAMS);\n\n  return file->vt->stat(file, fst);\n}\n\nret_t fs_dir_rewind(fs_dir_t* dir) {\n  return_value_if_fail(dir != NULL && dir->vt != NULL && dir->vt->rewind != NULL, RET_BAD_PARAMS);\n\n  return dir->vt->rewind(dir);\n}\n\nret_t fs_dir_read(fs_dir_t* dir, fs_item_t* item) {\n  return_value_if_fail(dir != NULL && dir->vt != NULL && dir->vt->read != NULL && item != NULL,\n                       RET_BAD_PARAMS);\n\n  return dir->vt->read(dir, item);\n}\n\nret_t fs_dir_close(fs_dir_t* dir) {\n  return_value_if_fail(dir != NULL && dir->vt != NULL && dir->vt->close != NULL, RET_BAD_PARAMS);\n\n  return dir->vt->close(dir);\n}\n\nfs_file_t* fs_open_file(fs_t* fs, const char* name, const char* mode) {\n  return_value_if_fail(fs != NULL && name != NULL && mode != NULL, NULL);\n\n  return fs->open_file(fs, name, mode);\n}\n\nret_t fs_remove_file(fs_t* fs, const char* name) {\n  return_value_if_fail(fs != NULL && fs->remove_file != NULL && name != NULL, RET_BAD_PARAMS);\n\n  return fs->remove_file(fs, name);\n}\n\nbool_t fs_file_exist(fs_t* fs, const char* name) {\n  return_value_if_fail(fs != NULL && fs->file_exist != NULL && name != NULL, FALSE);\n\n  return fs->file_exist(fs, name);\n}\n\nret_t fs_file_rename(fs_t* fs, const char* name, const char* new_name) {\n  return_value_if_fail(fs != NULL && fs->file_rename != NULL && name != NULL && new_name != NULL,\n                       RET_BAD_PARAMS);\n\n  return fs->file_rename(fs, name, new_name);\n}\n\nfs_dir_t* fs_open_dir(fs_t* fs, const char* name) {\n  return_value_if_fail(fs != NULL && fs->open_dir != NULL && name != NULL, NULL);\n\n  return fs->open_dir(fs, name);\n}\n\nret_t fs_remove_dir(fs_t* fs, const char* name) {\n  return_value_if_fail(fs != NULL && fs->remove_dir != NULL && name != NULL, RET_BAD_PARAMS);\n\n  return fs->remove_dir(fs, name);\n}\n\nret_t fs_change_dir(fs_t* fs, const char* name) {\n  return_value_if_fail(fs != NULL && fs->change_dir != NULL && name != NULL, RET_BAD_PARAMS);\n\n  return fs->change_dir(fs, name);\n}\n\nret_t fs_create_dir(fs_t* fs, const char* name) {\n  return_value_if_fail(fs != NULL && fs->create_dir != NULL && name != NULL, RET_BAD_PARAMS);\n\n  return fs->create_dir(fs, name);\n}\n\nbool_t fs_dir_exist(fs_t* fs, const char* name) {\n  return_value_if_fail(fs != NULL && fs->dir_exist != NULL && name != NULL, FALSE);\n\n  return fs->dir_exist(fs, name);\n}\n\nret_t fs_dir_rename(fs_t* fs, const char* name, const char* new_name) {\n  return_value_if_fail(fs != NULL && fs->dir_rename != NULL && name != NULL && new_name,\n                       RET_BAD_PARAMS);\n\n  return fs->dir_rename(fs, name, new_name);\n}\n\nint32_t fs_get_file_size(fs_t* fs, const char* name) {\n  return_value_if_fail(fs != NULL && fs->get_file_size != NULL && name != NULL, -1);\n\n  return fs->get_file_size(fs, name);\n}\n\nret_t fs_get_disk_info(fs_t* fs, const char* volume, int32_t* free_kb, int32_t* total_kb) {\n  return_value_if_fail(fs != NULL && free_kb != NULL && total_kb != NULL, RET_BAD_PARAMS);\n\n  return fs->get_disk_info(fs, volume, free_kb, total_kb);\n}\n\nret_t fs_get_exe(fs_t* fs, char path[MAX_PATH + 1]) {\n  return_value_if_fail(fs != NULL && fs->get_exe != NULL && path != NULL, RET_BAD_PARAMS);\n\n  return fs->get_exe(fs, path);\n}\n\nret_t fs_get_user_storage_path(fs_t* fs, char path[MAX_PATH + 1]) {\n  return_value_if_fail(fs != NULL && fs->get_user_storage_path != NULL && path != NULL,\n                       RET_BAD_PARAMS);\n\n  return fs->get_user_storage_path(fs, path);\n}\n\nret_t fs_get_temp_path(fs_t* fs, char path[MAX_PATH + 1]) {\n  return_value_if_fail(fs != NULL && fs->get_temp_path != NULL && path != NULL, RET_BAD_PARAMS);\n\n  return fs->get_temp_path(fs, path);\n}\n\nret_t fs_get_cwd(fs_t* fs, char path[MAX_PATH + 1]) {\n  return_value_if_fail(fs != NULL && fs->get_cwd != NULL && path != NULL, RET_BAD_PARAMS);\n\n  return fs->get_cwd(fs, path);\n}\n\nint32_t file_get_size(const char* name) {\n  return fs_get_file_size(os_fs(), name);\n}\n\nret_t fs_stat(fs_t* fs, const char* name, fs_stat_info_t* fst) {\n  return_value_if_fail(fs != NULL && fs->stat != NULL && name != NULL, RET_BAD_PARAMS);\n\n  return fs->stat(fs, name, fst);\n}\n\nint32_t file_read_part(const char* name, void* buff, uint32_t size, uint32_t offset) {\n  int32_t ret = 0;\n  fs_file_t* fp = NULL;\n  return_value_if_fail(name != NULL && buff != NULL, -1);\n\n  fp = fs_open_file(os_fs(), name, \"rb\");\n  if (fp != NULL) {\n    if (fs_file_seek(fp, offset) == RET_OK) {\n      ret = fs_file_read(fp, buff, size);\n    }\n    fs_file_close(fp);\n  }\n\n  return ret;\n}\n\nvoid* file_read(const char* name, uint32_t* size) {\n  uint8_t* buff = NULL;\n  int32_t len = file_get_size(name);\n  return_value_if_fail(name != NULL && len > 0, NULL);\n\n  buff = (uint8_t*)TKMEM_ALLOC(len + 1);\n  return_value_if_fail(buff != NULL, NULL);\n\n  if (file_read_part(name, buff, len, 0) == len) {\n    if (size != NULL) {\n      *size = len;\n    }\n    buff[len] = '\\0';\n\n    return buff;\n  } else {\n    if (size != NULL) {\n      *size = 0;\n    }\n    TKMEM_FREE(buff);\n\n    return NULL;\n  }\n}\n\nret_t file_write(const char* name, const void* buff, uint32_t size) {\n  ret_t ret = RET_OK;\n  fs_file_t* fp = NULL;\n  return_value_if_fail(name != NULL && buff != NULL, RET_BAD_PARAMS);\n\n  fp = fs_open_file(os_fs(), name, \"wb+\");\n  return_value_if_fail(fp != NULL, RET_FAIL);\n\n  if (fs_file_write(fp, buff, size) != size) {\n    ret = RET_FAIL;\n  }\n\n  fs_file_close(fp);\n\n  return ret;\n}\n\nret_t file_remove(const char* name) {\n  return_value_if_fail(name != NULL, RET_BAD_PARAMS);\n\n  return fs_remove_file(os_fs(), name);\n}\n\nbool_t file_exist(const char* name) {\n  return_value_if_fail(name != NULL, FALSE);\n\n  return fs_file_exist(os_fs(), name);\n}\n\nbool_t dir_exist(const char* name) {\n  return_value_if_fail(name != NULL, FALSE);\n\n  return fs_dir_exist(os_fs(), name);\n}\n\nret_t fs_test_file(fs_t* fs) {\n  char buff[32];\n  fs_file_t* fp = NULL;\n  const char* filename = \"./test.txt\";\n\n  memset(buff, 0x00, sizeof(buff));\n  fp = fs_open_file(fs, filename, \"w+\");\n  assert(fs_file_write(fp, \"hello\", 5) == 5);\n  assert(fs_file_tell(fp) == 5);\n  assert(fs_file_sync(fp) == RET_OK);\n  assert(fs_file_size(fp) == 5);\n  assert(fs_file_truncate(fp, 0) == RET_OK);\n  assert(fs_file_write(fp, \"world\", 5) == 5);\n  assert(fs_file_seek(fp, 0) == RET_OK);\n  assert(fs_file_write(fp, \"WORLD\", 5) == 5);\n  assert(fs_file_close(fp) == RET_OK);\n  assert(fs_file_exist(fs, filename) == TRUE);\n\n  fp = fs_open_file(fs, filename, \"a\");\n  assert(fs_file_write(fp, \"world\", 5) == 5);\n  assert(fs_file_close(fp) == RET_OK);\n  assert(fs_get_file_size(fs, filename) == 10);\n\n  fp = fs_open_file(fs, filename, \"r\");\n  assert(fs_file_read(fp, buff, 10) == 10);\n  assert(strcmp(buff, \"WORLDworld\") == 0);\n  assert(fs_file_close(fp) == RET_OK);\n  assert(fs_get_file_size(fs, filename) == 10);\n\n  fp = fs_open_file(fs, filename, \"w+\");\n  assert(fs_file_printf(fp, \"%s:%d\", \"hello\", 10) == 8);\n  assert(fs_file_close(fp) == RET_OK);\n\n  assert(fs_file_rename(fs, filename, \"./test.bin\") == RET_OK);\n  assert(!fs_file_exist(fs, filename));\n  assert(fs_file_exist(fs, \"./test.bin\"));\n  assert(fs_remove_file(fs, \"./test.bin\") == RET_OK);\n  assert(!fs_file_exist(fs, \"./test.bin\"));\n\n  return RET_OK;\n}\n\nret_t fs_test_dir(fs_t* fs) {\n  fs_item_t item;\n  fs_dir_t* dir = NULL;\n\n  fs_remove_dir_r(fs, \"./a\");\n  fs_remove_dir_r(fs, \"./b\");\n  assert(!fs_dir_exist(fs, \"./a\"));\n  assert(fs_create_dir(fs, \"./a\") == RET_OK);\n  assert(fs_dir_exist(fs, \"./a\"));\n\n  assert(fs_create_dir(fs, \"./a/b\") == RET_OK);\n  assert(fs_dir_exist(fs, \"./a/b\"));\n\n  assert(fs_create_dir(fs, \"./a/b/c1\") == RET_OK);\n  assert(fs_dir_exist(fs, \"./a/b/c1\"));\n\n  assert(fs_create_dir(fs, \"./a/b/c2\") == RET_OK);\n  assert(fs_dir_exist(fs, \"./a/b/c2\"));\n\n  dir = fs_open_dir(fs, \"./a/b\");\n  assert(dir != NULL);\n\n  do {\n    assert(fs_dir_read(dir, &item) == RET_OK);\n    if (item.name[0] != '.') {\n      break;\n    } else {\n      assert(!item.is_reg_file);\n      assert(item.is_dir);\n    }\n  } while (TRUE);\n\n  assert(strcmp(item.name, \"c1\") == 0 || strcmp(item.name, \"c2\") == 0);\n  assert(!item.is_reg_file);\n  assert(item.is_dir);\n\n  assert(fs_dir_read(dir, &item) == RET_OK);\n  assert(!item.is_reg_file);\n  assert(item.is_dir);\n\n  assert(fs_dir_close(dir) == RET_OK);\n\n  if (fs_dir_rename(fs, \"./a/b/c2\", \"./a/b/c3\") == RET_OK) {\n    assert(!fs_dir_exist(fs, \"./a/b/c2\"));\n    assert(fs_dir_exist(fs, \"./a/b/c3\"));\n    assert(fs_dir_rename(fs, \"./a/b/c3\", \"./a/b/c2\") == RET_OK);\n  }\n  assert(fs_remove_dir(fs, \"./a/b/c1\") == RET_OK);\n  assert(fs_remove_dir(fs, \"./a/b/c2\") == RET_OK);\n  assert(fs_remove_dir(fs, \"./a/b\") == RET_OK);\n  assert(fs_remove_dir(fs, \"./a\") == RET_OK);\n\n  return RET_OK;\n}\n\nret_t fs_test(fs_t* fs) {\n  fs_test_file(fs);\n  return fs_test_dir(fs);\n}\n\nint32_t fs_file_read_line(fs_file_t* file, char* buffer, uint32_t size) {\n  char tbuff[128];\n  char* d = buffer;\n  char* s = tbuff;\n  int32_t i = 0;\n  int32_t ret = 0;\n  int64_t offset = 0;\n  bool_t done = FALSE;\n  return_value_if_fail(file != NULL && buffer != NULL && size > 1, 0);\n\n  while (((d - buffer) < size) && !done) {\n    offset = fs_file_tell(file);\n    ret = fs_file_read(file, tbuff, sizeof(tbuff) - 1);\n    if (ret <= 0) {\n      break;\n    }\n    tbuff[ret] = '\\0';\n    for (i = 0; (i < ret) && ((d - buffer) < size); i++) {\n      offset++;\n      if (s[i] == '\\r') {\n        i++;\n        if (s[i] == '\\n') {\n          offset++;\n        } else if (s[i] == '\\0') {\n          char c = 0;\n          fs_file_read(file, &c, 1);\n          if (c == '\\n') {\n            offset++;\n          }\n        }\n        done = TRUE;\n        break;\n      } else if (s[i] == '\\n') {\n        done = TRUE;\n        break;\n      } else {\n        *d++ = s[i];\n      }\n    }\n\n    if (ret < (sizeof(tbuff) - 1)) {\n      break;\n    }\n  }\n\n  ret = d - buffer;\n  if (ret > 0) {\n    *d = '\\0';\n    fs_file_seek(file, offset);\n  }\n\n  return ret;\n}\n\nret_t fs_build_user_storage_file_name(char filename[MAX_PATH + 1], const char* appname,\n                                      const char* name) {\n  char home[MAX_PATH + 1];\n  char path[MAX_PATH + 1];\n  return_value_if_fail(filename != NULL && appname != NULL && name != NULL, RET_FAIL);\n  return_value_if_fail(fs_get_user_storage_path(os_fs(), home) == RET_OK, RET_FAIL);\n  return_value_if_fail(path_build(path, MAX_PATH, home, appname, NULL) == RET_OK, RET_FAIL);\n  if (!path_exist(path)) {\n    fs_create_dir(os_fs(), path);\n  }\n\n  return path_build(filename, MAX_PATH, path, name, NULL);\n}\n\n#include \"tkc/tokenizer.h\"\n\nret_t fs_create_dir_r(fs_t* fs, const char* name) {\n  int32_t len = 0;\n  char path[MAX_PATH + 1];\n  tokenizer_t tokenizer;\n  tokenizer_t* t = NULL;\n  return_value_if_fail(fs != NULL && name != NULL, RET_BAD_PARAMS);\n  t = tokenizer_init(&tokenizer, name, strlen(name), \"/\\\\\");\n  return_value_if_fail(t != NULL, RET_BAD_PARAMS);\n\n  while (tokenizer_has_more(t)) {\n    tokenizer_next(t);\n\n    len = tk_min(MAX_PATH, t->cursor);\n    tk_strncpy(path, name, len);\n\n    if (len > 0) {\n      if (path[len - 1] == '/' || path[len - 1] == '\\\\') {\n        path[len - 1] = '\\0';\n      }\n    }\n\n    if (!fs_dir_exist(fs, path)) {\n      if (fs_create_dir(fs, path) != RET_OK) {\n        log_debug(\"create %s failed\\n\", path);\n        break;\n      }\n    }\n  }\n  tokenizer_deinit(t);\n\n  return RET_OK;\n}\n\nret_t fs_remove_dir_r(fs_t* fs, const char* name) {\n  fs_item_t item;\n  ret_t ret = RET_OK;\n  fs_dir_t* dir = NULL;\n  return_value_if_fail(fs != NULL && name != NULL, RET_BAD_PARAMS);\n\n  dir = fs_open_dir(fs, name);\n  return_value_if_fail(dir != NULL, RET_BAD_PARAMS);\n  do {\n    if (fs_dir_read(dir, &item) != RET_OK) {\n      break;\n    }\n\n    if (tk_str_eq(item.name, \".\") || tk_str_eq(item.name, \"..\")) {\n      continue;\n    } else {\n      char subname[MAX_PATH + 1];\n      path_build(subname, MAX_PATH, name, item.name, NULL);\n      if (item.is_dir) {\n        ret = fs_remove_dir_r(fs, subname);\n      } else {\n        ret = fs_remove_file(fs, subname);\n      }\n    }\n    if (ret != RET_OK) {\n      break;\n    }\n  } while (TRUE);\n  fs_dir_close(dir);\n  ret = fs_remove_dir(fs, name);\n\n  return ret;\n}\n\n#ifndef TK_COPY_BUFF_SIZE\n#define TK_COPY_BUFF_SIZE 4096\n#endif /*TK_COPY_BUFF_SIZE*/\n\nstatic ret_t fs_copy_file_fd(fs_file_t* fsrc, fs_file_t* fdst) {\n  int32_t r = 0;\n  ret_t ret = RET_OK;\n  uint8_t* buff = TKMEM_ALLOC(TK_COPY_BUFF_SIZE + 1);\n\n  return_value_if_fail(buff != NULL, RET_OOM);\n  while ((r = fs_file_read(fsrc, buff, TK_COPY_BUFF_SIZE)) > 0) {\n    buff[r] = '\\0';\n    if (fs_file_write(fdst, buff, r) < r) {\n      log_debug(\"write file failed\\n\");\n      ret = RET_IO;\n      break;\n    }\n  }\n  TKMEM_FREE(buff);\n\n  return ret;\n}\n\nret_t fs_copy_file(fs_t* fs, const char* src, const char* dst) {\n  ret_t ret = RET_FAIL;\n  fs_file_t* fsrc = NULL;\n  fs_file_t* fdst = NULL;\n  char dirname[MAX_PATH + 1];\n  return_value_if_fail(fs != NULL && src != NULL && dst != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(file_exist(src), RET_BAD_PARAMS);\n\n  path_dirname(dst, dirname, MAX_PATH);\n  if (!dir_exist(dirname)) {\n    return_value_if_fail(fs_create_dir_r(fs, dirname) == RET_OK, RET_IO);\n  }\n\n  fdst = fs_open_file(fs, dst, \"wb+\");\n  return_value_if_fail(fdst != NULL, RET_IO);\n\nfsrc = ",
    "raw_res": "0;",
    "prompt_res": "fs_open_file(fs, src, \"rb\");",
    "gt": "fs_open_file(fs, src, \"rb\");"
  },
  {
    "id": 954,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/fs.c",
    "input": "﻿/**\n * File:   fs.h\n * Author: AWTK Develop Team\n * Brief:  simple fs api\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-04-27 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/fs.h\"\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/path.h\"\n\nint32_t fs_file_read(fs_file_t* file, void* buffer, uint32_t size) {\n  return_value_if_fail(file != NULL && file->vt != NULL && buffer != NULL && file->vt->read != NULL,\n                       -1);\n\n  return file->vt->read(file, buffer, size);\n}\n\nint32_t fs_file_write(fs_file_t* file, const void* buffer, uint32_t size) {\n  return_value_if_fail(\n      file != NULL && file->vt != NULL && buffer != NULL && file->vt->write != NULL, -1);\n\n  return file->vt->write(file, buffer, size);\n}\n\nint32_t fs_file_printf(fs_file_t* file, const char* const format_str, ...) {\n  va_list v_l;\n  int32_t ret = 0;\n  return_value_if_fail(file != NULL && file->vt != NULL && file->vt->printf != NULL, -1);\n\n  va_start(v_l, format_str);\n  ret = file->vt->printf(file, format_str, v_l);\n  va_end(v_l);\n\n  return ret;\n}\n\nret_t fs_file_seek(fs_file_t* file, int32_t offset) {\n  return_value_if_fail(file != NULL && file->vt != NULL && file->vt->seek != NULL, RET_BAD_PARAMS);\n\n  return file->vt->seek(file, offset);\n}\n\nret_t fs_file_truncate(fs_file_t* file, int32_t offset) {\n  return_value_if_fail(file != NULL && file->vt != NULL && file->vt->truncate != NULL,\n                       RET_BAD_PARAMS);\n  fs_file_seek(file, 0);\n  return file->vt->truncate(file, offset);\n}\n\nbool_t fs_file_eof(fs_file_t* file) {\n  return_value_if_fail(file != NULL && file->vt != NULL && file->vt->eof != NULL, TRUE);\n\n  return file->vt->eof(file);\n}\n\nint64_t fs_file_tell(fs_file_t* file) {\n  return_value_if_fail(file != NULL && file->vt != NULL && file->vt->tell != NULL, -1);\n\n  return file->vt->tell(file);\n}\n\nint64_t fs_file_size(fs_file_t* file) {\n  return_value_if_fail(file != NULL && file->vt != NULL && file->vt->size != NULL, -1);\n\n  return file->vt->size(file);\n}\n\nret_t fs_file_close(fs_file_t* file) {\n  return_value_if_fail(file != NULL && file->vt != NULL && file->vt->close != NULL, RET_BAD_PARAMS);\n\n  return file->vt->close(file);\n}\n\nret_t fs_file_sync(fs_file_t* file) {\n  return_value_if_fail(file != NULL && file->vt != NULL && file->vt->sync != NULL, RET_BAD_PARAMS);\n\n  return file->vt->sync(file);\n}\n\nret_t fs_file_stat(fs_file_t* file, fs_stat_info_t* fst) {\n  return_value_if_fail(file != NULL && file->vt != NULL && file->vt->stat != NULL && fst != NULL,\n                       RET_BAD_PARAMS);\n\n  return file->vt->stat(file, fst);\n}\n\nret_t fs_dir_rewind(fs_dir_t* dir) {\n  return_value_if_fail(dir != NULL && dir->vt != NULL && dir->vt->rewind != NULL, RET_BAD_PARAMS);\n\n  return dir->vt->rewind(dir);\n}\n\nret_t fs_dir_read(fs_dir_t* dir, fs_item_t* item) {\n  return_value_if_fail(dir != NULL && dir->vt != NULL && dir->vt->read != NULL && item != NULL,\n                       RET_BAD_PARAMS);\n\n  return dir->vt->read(dir, item);\n}\n\nret_t fs_dir_close(fs_dir_t* dir) {\n  return_value_if_fail(dir != NULL && dir->vt != NULL && dir->vt->close != NULL, RET_BAD_PARAMS);\n\n  return dir->vt->close(dir);\n}\n\nfs_file_t* fs_open_file(fs_t* fs, const char* name, const char* mode) {\n  return_value_if_fail(fs != NULL && name != NULL && mode != NULL, NULL);\n\n  return fs->open_file(fs, name, mode);\n}\n\nret_t fs_remove_file(fs_t* fs, const char* name) {\n  return_value_if_fail(fs != NULL && fs->remove_file != NULL && name != NULL, RET_BAD_PARAMS);\n\n  return fs->remove_file(fs, name);\n}\n\nbool_t fs_file_exist(fs_t* fs, const char* name) {\n  return_value_if_fail(fs != NULL && fs->file_exist != NULL && name != NULL, FALSE);\n\n  return fs->file_exist(fs, name);\n}\n\nret_t fs_file_rename(fs_t* fs, const char* name, const char* new_name) {\n  return_value_if_fail(fs != NULL && fs->file_rename != NULL && name != NULL && new_name != NULL,\n                       RET_BAD_PARAMS);\n\n  return fs->file_rename(fs, name, new_name);\n}\n\nfs_dir_t* fs_open_dir(fs_t* fs, const char* name) {\n  return_value_if_fail(fs != NULL && fs->open_dir != NULL && name != NULL, NULL);\n\n  return fs->open_dir(fs, name);\n}\n\nret_t fs_remove_dir(fs_t* fs, const char* name) {\n  return_value_if_fail(fs != NULL && fs->remove_dir != NULL && name != NULL, RET_BAD_PARAMS);\n\n  return fs->remove_dir(fs, name);\n}\n\nret_t fs_change_dir(fs_t* fs, const char* name) {\n  return_value_if_fail(fs != NULL && fs->change_dir != NULL && name != NULL, RET_BAD_PARAMS);\n\n  return fs->change_dir(fs, name);\n}\n\nret_t fs_create_dir(fs_t* fs, const char* name) {\n  return_value_if_fail(fs != NULL && fs->create_dir != NULL && name != NULL, RET_BAD_PARAMS);\n\n  return fs->create_dir(fs, name);\n}\n\nbool_t fs_dir_exist(fs_t* fs, const char* name) {\n  return_value_if_fail(fs != NULL && fs->dir_exist != NULL && name != NULL, FALSE);\n\n  return fs->dir_exist(fs, name);\n}\n\nret_t fs_dir_rename(fs_t* fs, const char* name, const char* new_name) {\n  return_value_if_fail(fs != NULL && fs->dir_rename != NULL && name != NULL && new_name,\n                       RET_BAD_PARAMS);\n\n  return fs->dir_rename(fs, name, new_name);\n}\n\nint32_t fs_get_file_size(fs_t* fs, const char* name) {\n  return_value_if_fail(fs != NULL && fs->get_file_size != NULL && name != NULL, -1);\n\n  return fs->get_file_size(fs, name);\n}\n\nret_t fs_get_disk_info(fs_t* fs, const char* volume, int32_t* free_kb, int32_t* total_kb) {\n  return_value_if_fail(fs != NULL && free_kb != NULL && total_kb != NULL, RET_BAD_PARAMS);\n\n  return fs->get_disk_info(fs, volume, free_kb, total_kb);\n}\n\nret_t fs_get_exe(fs_t* fs, char path[MAX_PATH + 1]) {\n  return_value_if_fail(fs != NULL && fs->get_exe != NULL && path != NULL, RET_BAD_PARAMS);\n\n  return fs->get_exe(fs, path);\n}\n\nret_t fs_get_user_storage_path(fs_t* fs, char path[MAX_PATH + 1]) {\n  return_value_if_fail(fs != NULL && fs->get_user_storage_path != NULL && path != NULL,\n                       RET_BAD_PARAMS);\n\n  return fs->get_user_storage_path(fs, path);\n}\n\nret_t fs_get_temp_path(fs_t* fs, char path[MAX_PATH + 1]) {\n  return_value_if_fail(fs != NULL && fs->get_temp_path != NULL && path != NULL, RET_BAD_PARAMS);\n\n  return fs->get_temp_path(fs, path);\n}\n\nret_t fs_get_cwd(fs_t* fs, char path[MAX_PATH + 1]) {\n  return_value_if_fail(fs != NULL && fs->get_cwd != NULL && path != NULL, RET_BAD_PARAMS);\n\n  return fs->get_cwd(fs, path);\n}\n\nint32_t file_get_size(const char* name) {\n  return fs_get_file_size(os_fs(), name);\n}\n\nret_t fs_stat(fs_t* fs, const char* name, fs_stat_info_t* fst) {\n  return_value_if_fail(fs != NULL && fs->stat != NULL && name != NULL, RET_BAD_PARAMS);\n\n  return fs->stat(fs, name, fst);\n}\n\nint32_t file_read_part(const char* name, void* buff, uint32_t size, uint32_t offset) {\n  int32_t ret = 0;\n  fs_file_t* fp = NULL;\n  return_value_if_fail(name != NULL && buff != NULL, -1);\n\n  fp = fs_open_file(os_fs(), name, \"rb\");\n  if (fp != NULL) {\n    if (fs_file_seek(fp, offset) == RET_OK) {\n      ret = fs_file_read(fp, buff, size);\n    }\n    fs_file_close(fp);\n  }\n\n  return ret;\n}\n\nvoid* file_read(const char* name, uint32_t* size) {\n  uint8_t* buff = NULL;\n  int32_t len = file_get_size(name);\n  return_value_if_fail(name != NULL && len > 0, NULL);\n\n  buff = (uint8_t*)TKMEM_ALLOC(len + 1);\n  return_value_if_fail(buff != NULL, NULL);\n\n  if (file_read_part(name, buff, len, 0) == len) {\n    if (size != NULL) {\n      *size = len;\n    }\n    buff[len] = '\\0';\n\n    return buff;\n  } else {\n    if (size != NULL) {\n      *size = 0;\n    }\n    TKMEM_FREE(buff);\n\n    return NULL;\n  }\n}\n\nret_t file_write(const char* name, const void* buff, uint32_t size) {\n  ret_t ret = RET_OK;\n  fs_file_t* fp = NULL;\n  return_value_if_fail(name != NULL && buff != NULL, RET_BAD_PARAMS);\n\n  fp = fs_open_file(os_fs(), name, \"wb+\");\n  return_value_if_fail(fp != NULL, RET_FAIL);\n\n  if (fs_file_write(fp, buff, size) != size) {\n    ret = RET_FAIL;\n  }\n\n  fs_file_close(fp);\n\n  return ret;\n}\n\nret_t file_remove(const char* name) {\n  return_value_if_fail(name != NULL, RET_BAD_PARAMS);\n\n  return fs_remove_file(os_fs(), name);\n}\n\nbool_t file_exist(const char* name) {\n  return_value_if_fail(name != NULL, FALSE);\n\n  return fs_file_exist(os_fs(), name);\n}\n\nbool_t dir_exist(const char* name) {\n  return_value_if_fail(name != NULL, FALSE);\n\n  return fs_dir_exist(os_fs(), name);\n}\n\nret_t fs_test_file(fs_t* fs) {\n  char buff[32];\n  fs_file_t* fp = NULL;\n  const char* filename = \"./test.txt\";\n\n  memset(buff, 0x00, sizeof(buff));\n  fp = fs_open_file(fs, filename, \"w+\");\n  assert(fs_file_write(fp, \"hello\", 5) == 5);\n  assert(fs_file_tell(fp) == 5);\n  assert(fs_file_sync(fp) == RET_OK);\n  assert(fs_file_size(fp) == 5);\n  assert(fs_file_truncate(fp, 0) == RET_OK);\n  assert(fs_file_write(fp, \"world\", 5) == 5);\n  assert(fs_file_seek(fp, 0) == RET_OK);\n  assert(fs_file_write(fp, \"WORLD\", 5) == 5);\n  assert(fs_file_close(fp) == RET_OK);\n  assert(fs_file_exist(fs, filename) == TRUE);\n\n  fp = fs_open_file(fs, filename, \"a\");\n  assert(fs_file_write(fp, \"world\", 5) == 5);\n  assert(fs_file_close(fp) == RET_OK);\n  assert(fs_get_file_size(fs, filename) == 10);\n\n  fp = fs_open_file(fs, filename, \"r\");\n  assert(fs_file_read(fp, buff, 10) == 10);\n  assert(strcmp(buff, \"WORLDworld\") == 0);\n  assert(fs_file_close(fp) == RET_OK);\n  assert(fs_get_file_size(fs, filename) == 10);\n\n  fp = fs_open_file(fs, filename, \"w+\");\n  assert(fs_file_printf(fp, \"%s:%d\", \"hello\", 10) == 8);\n  assert(fs_file_close(fp) == RET_OK);\n\n  assert(fs_file_rename(fs, filename, \"./test.bin\") == RET_OK);\n  assert(!fs_file_exist(fs, filename));\n  assert(fs_file_exist(fs, \"./test.bin\"));\n  assert(fs_remove_file(fs, \"./test.bin\") == RET_OK);\n  assert(!fs_file_exist(fs, \"./test.bin\"));\n\n  return RET_OK;\n}\n\nret_t fs_test_dir(fs_t* fs) {\n  fs_item_t item;\n  fs_dir_t* dir = NULL;\n\n  fs_remove_dir_r(fs, \"./a\");\n  fs_remove_dir_r(fs, \"./b\");\n  assert(!fs_dir_exist(fs, \"./a\"));\n  assert(fs_create_dir(fs, \"./a\") == RET_OK);\n  assert(fs_dir_exist(fs, \"./a\"));\n\n  assert(fs_create_dir(fs, \"./a/b\") == RET_OK);\n  assert(fs_dir_exist(fs, \"./a/b\"));\n\n  assert(fs_create_dir(fs, \"./a/b/c1\") == RET_OK);\n  assert(fs_dir_exist(fs, \"./a/b/c1\"));\n\n  assert(fs_create_dir(fs, \"./a/b/c2\") == RET_OK);\n  assert(fs_dir_exist(fs, \"./a/b/c2\"));\n\n  dir = fs_open_dir(fs, \"./a/b\");\n  assert(dir != NULL);\n\n  do {\n    assert(fs_dir_read(dir, &item) == RET_OK);\n    if (item.name[0] != '.') {\n      break;\n    } else {\n      assert(!item.is_reg_file);\n      assert(item.is_dir);\n    }\n  } while (TRUE);\n\n  assert(strcmp(item.name, \"c1\") == 0 || strcmp(item.name, \"c2\") == 0);\n  assert(!item.is_reg_file);\n  assert(item.is_dir);\n\n  assert(fs_dir_read(dir, &item) == RET_OK);\n  assert(!item.is_reg_file);\n  assert(item.is_dir);\n\n  assert(fs_dir_close(dir) == RET_OK);\n\n  if (fs_dir_rename(fs, \"./a/b/c2\", \"./a/b/c3\") == RET_OK) {\n    assert(!fs_dir_exist(fs, \"./a/b/c2\"));\n    assert(fs_dir_exist(fs, \"./a/b/c3\"));\n    assert(fs_dir_rename(fs, \"./a/b/c3\", \"./a/b/c2\") == RET_OK);\n  }\n  assert(fs_remove_dir(fs, \"./a/b/c1\") == RET_OK);\n  assert(fs_remove_dir(fs, \"./a/b/c2\") == RET_OK);\n  assert(fs_remove_dir(fs, \"./a/b\") == RET_OK);\n  assert(fs_remove_dir(fs, \"./a\") == RET_OK);\n\n  return RET_OK;\n}\n\nret_t fs_test(fs_t* fs) {\n  fs_test_file(fs);\n  return fs_test_dir(fs);\n}\n\nint32_t fs_file_read_line(fs_file_t* file, char* buffer, uint32_t size) {\n  char tbuff[128];\n  char* d = buffer;\n  char* s = tbuff;\n  int32_t i = 0;\n  int32_t ret = 0;\n  int64_t offset = 0;\n  bool_t done = FALSE;\n  return_value_if_fail(file != NULL && buffer != NULL && size > 1, 0);\n\n  while (((d - buffer) < size) && !done) {\n    offset = fs_file_tell(file);\n    ret = fs_file_read(file, tbuff, sizeof(tbuff) - 1);\n    if (ret <= 0) {\n      break;\n    }\n    tbuff[ret] = '\\0';\n    for (i = 0; (i < ret) && ((d - buffer) < size); i++) {\n      offset++;\n      if (s[i] == '\\r') {\n        i++;\n        if (s[i] == '\\n') {\n          offset++;\n        } else if (s[i] == '\\0') {\n          char c = 0;\n          fs_file_read(file, &c, 1);\n          if (c == '\\n') {\n            offset++;\n          }\n        }\n        done = TRUE;\n        break;\n      } else if (s[i] == '\\n') {\n        done = TRUE;\n        break;\n      } else {\n        *d++ = s[i];\n      }\n    }\n\n    if (ret < (sizeof(tbuff) - 1)) {\n      break;\n    }\n  }\n\n  ret = d - buffer;\n  if (ret > 0) {\n    *d = '\\0';\n    fs_file_seek(file, offset);\n  }\n\n  return ret;\n}\n\nret_t fs_build_user_storage_file_name(char filename[MAX_PATH + 1], const char* appname,\n                                      const char* name) {\n  char home[MAX_PATH + 1];\n  char path[MAX_PATH + 1];\n  return_value_if_fail(filename != NULL && appname != NULL && name != NULL, RET_FAIL);\n  return_value_if_fail(fs_get_user_storage_path(os_fs(), home) == RET_OK, RET_FAIL);\n  return_value_if_fail(path_build(path, MAX_PATH, home, appname, NULL) == RET_OK, RET_FAIL);\n  if (!path_exist(path)) {\n    fs_create_dir(os_fs(), path);\n  }\n\n  return path_build(filename, MAX_PATH, path, name, NULL);\n}\n\n#include \"tkc/tokenizer.h\"\n\nret_t fs_create_dir_r(fs_t* fs, const char* name) {\n  int32_t len = 0;\n  char path[MAX_PATH + 1];\n  tokenizer_t tokenizer;\n  tokenizer_t* t = NULL;\n  return_value_if_fail(fs != NULL && name != NULL, RET_BAD_PARAMS);\n  t = tokenizer_init(&tokenizer, name, strlen(name), \"/\\\\\");\n  return_value_if_fail(t != NULL, RET_BAD_PARAMS);\n\n  while (tokenizer_has_more(t)) {\n    tokenizer_next(t);\n\n    len = tk_min(MAX_PATH, t->cursor);\n    tk_strncpy(path, name, len);\n\n    if (len > 0) {\n      if (path[len - 1] == '/' || path[len - 1] == '\\\\') {\n        path[len - 1] = '\\0';\n      }\n    }\n\n    if (!fs_dir_exist(fs, path)) {\n      if (fs_create_dir(fs, path) != RET_OK) {\n        log_debug(\"create %s failed\\n\", path);\n        break;\n      }\n    }\n  }\n  tokenizer_deinit(t);\n\n  return RET_OK;\n}\n\nret_t fs_remove_dir_r(fs_t* fs, const char* name) {\n  fs_item_t item;\n  ret_t ret = RET_OK;\n  fs_dir_t* dir = NULL;\n  return_value_if_fail(fs != NULL && name != NULL, RET_BAD_PARAMS);\n\n  dir = fs_open_dir(fs, name);\n  return_value_if_fail(dir != NULL, RET_BAD_PARAMS);\n  do {\n    if (fs_dir_read(dir, &item) != RET_OK) {\n      break;\n    }\n\n    if (tk_str_eq(item.name, \".\") || tk_str_eq(item.name, \"..\")) {\n      continue;\n    } else {\n      char subname[MAX_PATH + 1];\n      path_build(subname, MAX_PATH, name, item.name, NULL);\n      if (item.is_dir) {\n        ret = fs_remove_dir_r(fs, subname);\n      } else {\n        ret = fs_remove_file(fs, subname);\n      }\n    }\n    if (ret != RET_OK) {\n      break;\n    }\n  } while (TRUE);\n  fs_dir_close(dir);\n  ret = fs_remove_dir(fs, name);\n\n  return ret;\n}\n\n#ifndef TK_COPY_BUFF_SIZE\n#define TK_COPY_BUFF_SIZE 4096\n#endif /*TK_COPY_BUFF_SIZE*/\n\nstatic ret_t fs_copy_file_fd(fs_file_t* fsrc, fs_file_t* fdst) {\n  int32_t r = 0;\n  ret_t ret = RET_OK;\n  uint8_t* buff = TKMEM_ALLOC(TK_COPY_BUFF_SIZE + 1);\n\n  return_value_if_fail(buff != NULL, RET_OOM);\n  while ((r = fs_file_read(fsrc, buff, TK_COPY_BUFF_SIZE)) > 0) {\n    buff[r] = '\\0';\n    if (fs_file_write(fdst, buff, r) < r) {\n      log_debug(\"write file failed\\n\");\n      ret = RET_IO;\n      break;\n    }\n  }\n  TKMEM_FREE(buff);\n\n  return ret;\n}\n\nret_t fs_copy_file(fs_t* fs, const char* src, const char* dst) {\n  ret_t ret = RET_FAIL;\n  fs_file_t* fsrc = NULL;\n  fs_file_t* fdst = NULL;\n  char dirname[MAX_PATH + 1];\n  return_value_if_fail(fs != NULL && src != NULL && dst != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(file_exist(src), RET_BAD_PARAMS);\n\n  path_dirname(dst, dirname, MAX_PATH);\n  if (!dir_exist(dirname)) {\n    return_value_if_fail(fs_create_dir_r(fs, dirname) == RET_OK, RET_IO);\n  }\n\n  fdst = fs_open_file(fs, dst, \"wb+\");\n  return_value_if_fail(fdst != NULL, RET_IO);\n\n  fsrc = fs_open_file(fs, src, \"rb\");\n  if (fsrc != NULL) {\n    ret = fs_copy_file_fd(fsrc, fdst);\n    fs_file_close(fsrc);\n  }\n  fs_file_close(fdst);\n\n  return ret;\n}\n\nstatic ret_t fs_copy_item(fs_t* fs, fs_item_t* item, const char* src, const char* dst) {\n  char subsrc[MAX_PATH + 1];\n  char subdst[MAX_PATH + 1];\n  path_build(subsrc, MAX_PATH, src, item->name, NULL);\n  path_build(subdst, MAX_PATH, dst, item->name, NULL);\n\n  if (!fs_dir_exist(fs, dst)) {\n    return_value_if_fail(fs_create_dir_r(fs, dst) == RET_OK, RET_IO);\n  }\n\n  log_debug(\"%s ==> %s\\n\", subsrc, subdst);\n  if (item->is_dir) {\n    return fs_copy_dir(fs, subsrc, subdst);\n  } else {\n    return fs_copy_file(fs, subsrc, subdst);\n  }\n}\n\nret_t fs_copy_dir(fs_t* fs, const char* src, const char* dst) {\n  fs_item_t item;\n  ret_t ret = RET_OK;\n  fs_dir_t* dir = NULL;\n  return_value_if_fail(fs != NULL && src != NULL && dst != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(fs_dir_exist(fs, src), RET_BAD_PARAMS);\n\n  if (!fs_dir_exist(fs, dst)) {\n    return_value_if_fail(fs_create_dir_r(fs, dst) == RET_OK, RET_IO);\n  }\n\ndir = ",
    "raw_res": "0;",
    "prompt_res": "fs_open_dir(fs, src);",
    "gt": "fs_open_dir(fs, src);"
  },
  {
    "id": 976,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/typed_array.c",
    "input": "﻿/**\n * File:   typed_array.c\n * Author: AWTK Develop Team\n * Brief:  dynamic typed_array.\n *\n * Copyright (c) 2021 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2021-01-03 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/value.h\"\n#include \"tkc/typed_array.h\"\n\nstatic bool_t typed_array_is_type_supported(value_type_t type) {\n  switch (type) {\n    case VALUE_TYPE_BOOL:\n    case VALUE_TYPE_INT8:\n    case VALUE_TYPE_UINT8:\n    case VALUE_TYPE_INT16:\n    case VALUE_TYPE_UINT16:\n    case VALUE_TYPE_INT32:\n    case VALUE_TYPE_UINT32:\n    case VALUE_TYPE_INT64:\n    case VALUE_TYPE_UINT64:\n    case VALUE_TYPE_FLOAT:\n    case VALUE_TYPE_FLOAT32:\n    case VALUE_TYPE_DOUBLE: {\n      return TRUE;\n    }\n    default: {\n      return FALSE;\n    }\n  }\n}\n\ntyped_array_t* typed_array_create(value_type_t type, uint32_t capacity) {\n  typed_array_t* typed_array = NULL;\n  uint32_t element_size = value_type_size(type);\n  return_value_if_fail(typed_array_is_type_supported(type), NULL);\n  typed_array = TKMEM_ZALLOC(typed_array_t);\n  return_value_if_fail(typed_array != NULL, NULL);\n\n  typed_array->type = type;\n  typed_array->element_size = element_size;\n  if (capacity > 0) {\n    if (typed_array_extend(typed_array, capacity) != RET_OK) {\n      TKMEM_FREE(typed_array);\n      return NULL;\n    }\n  }\n\n  return typed_array;\n}\n\nret_t typed_array_get(typed_array_t* typed_array, uint32_t index, value_t* v) {\n  uint8_t* p = NULL;\n  return_value_if_fail(typed_array != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(typed_array->data != NULL && index < typed_array->size, RET_BAD_PARAMS);\n  p = typed_array->data + index * typed_array->element_size;\n\n  switch (typed_array->type) {\n    case VALUE_TYPE_BOOL: {\n      value_set_bool(v, *(bool_t*)p);\n      return RET_OK;\n    }\n    case VALUE_TYPE_INT8: {\n      value_set_int8(v, *(int8_t*)p);\n      return RET_OK;\n    }\n    case VALUE_TYPE_UINT8: {\n      value_set_uint8(v, *(uint8_t*)p);\n      return RET_OK;\n    }\n    case VALUE_TYPE_INT16: {\n      value_set_int16(v, *(int16_t*)p);\n      return RET_OK;\n    }\n    case VALUE_TYPE_UINT16: {\n      value_set_uint16(v, *(uint16_t*)p);\n      return RET_OK;\n    }\n    case VALUE_TYPE_INT32: {\n      value_set_int32(v, *(int32_t*)p);\n      return RET_OK;\n    }\n    case VALUE_TYPE_UINT32: {\n      value_set_uint32(v, *(uint32_t*)p);\n      return RET_OK;\n    }\n    case VALUE_TYPE_INT64: {\n      value_set_int64(v, *(int64_t*)p);\n      return RET_OK;\n    }\n    case VALUE_TYPE_UINT64: {\n      value_set_uint64(v, *(uint64_t*)p);\n      return RET_OK;\n    }\n    case VALUE_TYPE_FLOAT: {\n      value_set_float(v, *(float_t*)p);\n      return RET_OK;\n    }\n    case VALUE_TYPE_FLOAT32: {\n      value_set_float32(v, *(float*)p);\n      return RET_OK;\n    }\n    case VALUE_TYPE_DOUBLE: {\n      value_set_double(v, *(double*)p);\n      return RET_OK;\n    }\n    default: {\n      assert(!\"not supported type\");\n      return RET_NOT_IMPL;\n    }\n  }\n}\n\nret_t typed_array_set(typed_array_t* typed_array, uint32_t index, const value_t* v) {\n  uint8_t* p = NULL;\n  return_value_if_fail(typed_array != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(typed_array->data != NULL && index < typed_array->size, RET_BAD_PARAMS);\n  p = typed_array->data + index * typed_array->element_size;\n\n  switch (typed_array->type) {\n    case VALUE_TYPE_BOOL: {\n*(bool_t*)p = ",
    "raw_res": "value_get_bool(v);",
    "prompt_res": "value_bool(v);",
    "gt": "value_bool(v);"
  },
  {
    "id": 1016,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/value.c",
    "input": "﻿/**\n * File:   value.h\n * Author: AWTK Develop Team\n * Brief:  generic value type\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-27 Li XianJing <xianjimli@hotmail.com> adapt from uclib\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/value.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/object.h\"\n\nbool_t value_bool(const value_t* v) {\n  return_value_if_fail(v->type != VALUE_TYPE_INVALID, 0);\n\n  switch (v->type) {\n    case VALUE_TYPE_BOOL: {\n      return v->value.b;\n    }\n    case VALUE_TYPE_STRING: {\n      return tk_atob(v->value.str);\n    }\n    case VALUE_TYPE_WSTRING: {\n      return tk_watob(v->value.wstr);\n    }\n    default: {\n      return value_int(v) ? TRUE : FALSE;\n    }\n  }\n}\n\nvalue_t* value_init(value_t* v, uint32_t type) {\n  v->type = type;\n  v->free_handle = FALSE;\n\n  return v;\n}\n\nvalue_t* value_set_bool(value_t* v, bool_t value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.b = value;\n  return value_init(v, VALUE_TYPE_BOOL);\n}\n\nvalue_t* value_set_int8(value_t* v, int8_t value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.i8 = value;\n  return value_init(v, VALUE_TYPE_INT8);\n}\n\nint8_t value_int8(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n\n  if (v->type == VALUE_TYPE_INT8) {\n    return v->value.i8;\n  } else {\n    return (int8_t)value_int(v);\n  }\n}\n\nvalue_t* value_set_uint8(value_t* v, uint8_t value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.u8 = value;\n\n  return value_init(v, VALUE_TYPE_UINT8);\n}\n\nuint8_t value_uint8(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n\n  if (v->type == VALUE_TYPE_UINT8) {\n    return v->value.u8;\n  } else {\n    return (uint8_t)value_int(v);\n  }\n}\n\nvalue_t* value_set_int16(value_t* v, int16_t value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.i16 = value;\n\n  return value_init(v, VALUE_TYPE_INT16);\n}\n\nint16_t value_int16(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n\n  if (v->type == VALUE_TYPE_INT16) {\n    return v->value.i16;\n  } else {\n    return (int16_t)value_int(v);\n  }\n}\n\nvalue_t* value_set_uint16(value_t* v, uint16_t value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.u16 = value;\n\n  return value_init(v, VALUE_TYPE_UINT16);\n}\n\nuint16_t value_uint16(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n\n  if (v->type == VALUE_TYPE_UINT16) {\n    return v->value.u16;\n  } else {\n    return (uint16_t)value_int(v);\n  }\n}\n\nvalue_t* value_set_int32(value_t* v, int32_t value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.i32 = value;\n  return value_init(v, VALUE_TYPE_INT32);\n}\n\nint32_t value_int32(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n\n  if (v->type == VALUE_TYPE_INT32) {\n    return v->value.i32;\n  } else {\n    return (int32_t)value_int(v);\n  }\n}\n\nvalue_t* value_set_uint32(value_t* v, uint32_t value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.u32 = value;\n  return value_init(v, VALUE_TYPE_UINT32);\n}\n\nuint32_t value_uint32(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n\n  if (v->type == VALUE_TYPE_UINT32) {\n    return v->value.u32;\n  } else {\n    return (uint32_t)value_int(v);\n  }\n}\n\nvalue_t* value_set_int64(value_t* v, int64_t value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.i64 = value;\n  return value_init(v, VALUE_TYPE_INT64);\n}\n\nint64_t value_int64(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n\n  if (v->type == VALUE_TYPE_INT64) {\n    return v->value.i64;\n  } else if (v->type == VALUE_TYPE_UINT64) {\n    return v->value.u64;\n  } else if (v->type == VALUE_TYPE_STRING) {\n    return tk_atol(v->value.str);\n  } else {\n    return (int64_t)value_int(v);\n  }\n}\n\nvalue_t* value_set_uint64(value_t* v, uint64_t value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.u64 = value;\n\n  return value_init(v, VALUE_TYPE_UINT64);\n}\n\nuint64_t value_uint64(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n\n  if (v->type == VALUE_TYPE_UINT64) {\n    return v->value.u64;\n  } else if (v->type == VALUE_TYPE_INT64) {\n    return v->value.i64;\n  } else if (v->type == VALUE_TYPE_STRING) {\n    return tk_atoul(v->value.str);\n  } else {\n    return (uint64_t)value_int(v);\n  }\n}\n\nvalue_t* value_set_pointer(value_t* v, void* value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.ptr = value;\n  return value_init(v, VALUE_TYPE_POINTER);\n}\n\nvoid* value_pointer(const value_t* v) {\n  return_value_if_fail(v != NULL, NULL);\n  switch (v->type) {\n    case VALUE_TYPE_STRING: {\n      return (void*)(v->value.str);\n    }\n    case VALUE_TYPE_WSTRING: {\n      return (void*)(v->value.wstr);\n    }\n    case VALUE_TYPE_OBJECT: {\n      return (v->value.object);\n    }\n    case VALUE_TYPE_POINTER: {\n      return (v->value.ptr);\n    }\n    default:\n      break;\n  }\n\n  return NULL;\n}\n\nvalue_t* value_set_float(value_t* v, float_t value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.f = value;\n\n  return value_init(v, VALUE_TYPE_FLOAT);\n}\n\nfloat_t value_float(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n  return_value_if_fail(v->type != VALUE_TYPE_INVALID, 0);\n\n  switch (v->type) {\n    case VALUE_TYPE_BOOL: {\n      return (float_t)v->value.b;\n    }\n    case VALUE_TYPE_INT8: {\n      return (float_t)v->value.i8;\n    }\n    case VALUE_TYPE_UINT8: {\n      return (float_t)v->value.u8;\n    }\n    case VALUE_TYPE_INT16: {\n      return (float_t)v->value.i16;\n    }\n    case VALUE_TYPE_UINT16: {\n      return (float_t)v->value.u16;\n    }\n    case VALUE_TYPE_INT32: {\n      return (float_t)v->value.i32;\n    }\n    case VALUE_TYPE_UINT32: {\n      return (float_t)v->value.u32;\n    }\n    case VALUE_TYPE_INT64: {\n      return (float_t)v->value.i64;\n    }\n    case VALUE_TYPE_UINT64: {\n      return (float_t)v->value.u64;\n    }\n    case VALUE_TYPE_FLOAT: {\n      return (float_t)v->value.f;\n    }\n    case VALUE_TYPE_FLOAT32: {\n      return (float_t)v->value.f32;\n    }\n    case VALUE_TYPE_DOUBLE: {\n      return (float_t)v->value.f64;\n    }\n    case VALUE_TYPE_STRING: {\n      return (float_t)tk_atof(v->value.str);\n    }\n    case VALUE_TYPE_WSTRING: {\n      return (float_t)tk_watof(v->value.wstr);\n    }\n    default:\n      break;\n  }\n\n  return 0;\n}\n\nvalue_t* value_set_float32(value_t* v, float value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.f32 = value;\n\n  return value_init(v, VALUE_TYPE_FLOAT32);\n}\n\nfloat value_float32(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n\n  if (v->type == VALUE_TYPE_FLOAT32) {\n    return v->value.f32;\n  } else {\n    return (float)value_float(v);\n  }\n}\n\nvalue_t* value_set_double(value_t* v, double value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.f64 = value;\n\n  return value_init(v, VALUE_TYPE_DOUBLE);\n}\n\ndouble value_double(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n\n  return_value_if_fail(v->type != VALUE_TYPE_INVALID, 0);\n\n  switch (v->type) {\n    case VALUE_TYPE_INT8: {\n      return (double)v->value.i8;\n    }\n    case VALUE_TYPE_UINT8: {\n      return (double)v->value.u8;\n    }\n    case VALUE_TYPE_INT16: {\n      return (double)v->value.i16;\n    }\n    case VALUE_TYPE_UINT16: {\n      return (double)v->value.u16;\n    }\n    case VALUE_TYPE_INT32: {\n      return (double)v->value.i32;\n    }\n    case VALUE_TYPE_UINT32: {\n      return (double)v->value.u32;\n    }\n    case VALUE_TYPE_INT64: {\n      return (double)v->value.i64;\n    }\n    case VALUE_TYPE_UINT64: {\n      return (double)v->value.u64;\n    }\n    case VALUE_TYPE_FLOAT: {\n      return (double)v->value.f;\n    }\n    case VALUE_TYPE_FLOAT32: {\n      return (double)v->value.f32;\n    }\n    case VALUE_TYPE_DOUBLE: {\n      return v->value.f64;\n    }\n    case VALUE_TYPE_STRING: {\n      return (double)tk_atof(v->value.str);\n    }\n    case VALUE_TYPE_WSTRING: {\n      return (double)tk_watof(v->value.wstr);\n    }\n    case VALUE_TYPE_BOOL: {\n      return value_bool(v) ? 1 : 0;\n    }\n    default:\n      break;\n  }\n\n  return 0;\n}\n\nvalue_t* value_set_str(value_t* v, const char* value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.str = value;\n  return value_init(v, VALUE_TYPE_STRING);\n}\n\nvalue_t* value_dup_str(value_t* v, const char* value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  value_init(v, VALUE_TYPE_STRING);\n  v->value.str = tk_strdup(value);\n  v->free_handle = TRUE;\n\n  return v;\n}\n\nvalue_t* value_dup_str_with_len(value_t* v, const char* value, uint32_t len) {\n  return_value_if_fail(v != NULL, NULL);\n\n  value_init(v, VALUE_TYPE_STRING);\n  v->value.str = tk_strndup(value, len);\n  v->free_handle = TRUE;\n\n  return v;\n}\n\nvalue_t* value_set_wstr(value_t* v, const wchar_t* value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.wstr = value;\n  return value_init(v, VALUE_TYPE_WSTRING);\n}\n\nconst char* value_str(const value_t* v) {\n  return_value_if_fail(v != NULL, NULL);\n  return_value_if_fail(v->type == VALUE_TYPE_STRING, NULL);\n\n  return v->value.str;\n}\n\nconst wchar_t* value_wstr(const value_t* v) {\n  return_value_if_fail(v != NULL, NULL);\n  return_value_if_fail(v->type == VALUE_TYPE_WSTRING, NULL);\n\n  return v->value.wstr;\n}\n\nret_t value_copy(value_t* dst, const value_t* src) {\n  return_value_if_fail(dst != NULL && src != NULL, RET_BAD_PARAMS);\n\n  if (dst == src) {\n    return RET_OK;\n  }\n\n  memcpy(dst, src, sizeof(value_t));\n  dst->free_handle = FALSE;\n\n  return RET_OK;\n}\n\nret_t value_deep_copy(value_t* dst, const value_t* src) {\n  return_value_if_fail(dst != NULL && src != NULL, RET_BAD_PARAMS);\n\n  value_copy(dst, src);\n\n  switch (dst->type) {\n    case VALUE_TYPE_STRING: {\n      dst->value.str = src->value.str != NULL ? tk_strdup(src->value.str) : NULL;\n      dst->free_handle = dst->value.str != NULL;\n      break;\n    }\n    case VALUE_TYPE_BINARY:\n    case VALUE_TYPE_GRADIENT:\n    case VALUE_TYPE_UBJSON: {\n      if (src->value.binary_data.data != NULL) {\n        uint32_t size = src->value.binary_data.size;\n        void* data = tk_memdup(src->value.binary_data.data, size);\n        return_value_if_fail(data != NULL, RET_OOM);\n\n        dst->free_handle = TRUE;\n        dst->value.binary_data.data = data;\n        dst->value.binary_data.size = size;\n      } else {\n        dst->free_handle = FALSE;\n      }\n      break;\n    }\n    case VALUE_TYPE_WSTRING: {\n      dst->value.wstr = tk_wstrdup(src->value.wstr);\n      dst->free_handle = dst->value.wstr != NULL;\n      break;\n    }\n    case VALUE_TYPE_OBJECT: {\n      tk_object_ref(dst->value.object);\n      dst->free_handle = dst->value.object != NULL;\n      break;\n    }\n    default:\n      break;\n  }\n\n  return RET_OK;\n}\n\nbool_t value_is_null(value_t* v) {\n  return v == NULL || v->type == VALUE_TYPE_INVALID;\n}\n\nint value_int(const value_t* v) {\n  return_value_if_fail(v->type != VALUE_TYPE_INVALID, 0);\n\n  switch (v->type) {\n    case VALUE_TYPE_INT8: {\n      return (int)v->value.i8;\n    }\n    case VALUE_TYPE_UINT8: {\n      return (int)v->value.u8;\n    }\n    case VALUE_TYPE_INT16: {\n      return (int)v->value.i16;\n    }\n    case VALUE_TYPE_UINT16: {\n      return (int)v->value.u16;\n    }\n    case VALUE_TYPE_INT32: {\n      return (int)v->value.i32;\n    }\n    case VALUE_TYPE_UINT32: {\n      return (int)v->value.u32;\n    }\n    case VALUE_TYPE_INT64: {\n      return (int)v->value.i64;\n    }\n    case VALUE_TYPE_UINT64: {\n      return (int)v->value.u64;\n    }\n    case VALUE_TYPE_FLOAT: {\n      return (int)v->value.f;\n    }\n    case VALUE_TYPE_FLOAT32: {\n      return (int)v->value.f32;\n    }\n    case VALUE_TYPE_DOUBLE: {\n      return (int)v->value.f64;\n    }\n    case VALUE_TYPE_BOOL: {\n      return (int)v->value.b;\n    }\n    case VALUE_TYPE_STRING: {\n      return tk_atoi(v->value.str);\n    }\n    case VALUE_TYPE_WSTRING: {\n      return tk_watoi(v->value.wstr);\n    }\n    default: {\n      assert(!\"not supported type\");\n    }\n  }\n\n  return 0;\n}\n\nbool_t value_equal(const value_t* v, const value_t* other) {\n  return_value_if_fail(v != NULL && other != NULL, FALSE);\n  if (v->type != other->type) {\n    return FALSE;\n  }\n\n  switch (v->type) {\n    case VALUE_TYPE_INT8: {\n      return v->value.i8 == other->value.i8;\n    }\n    case VALUE_TYPE_UINT8: {\n      return v->value.u8 == other->value.u8;\n    }\n    case VALUE_TYPE_INT16: {\n      return v->value.i16 == other->value.i16;\n    }\n    case VALUE_TYPE_UINT16: {\n      return v->value.u16 == other->value.u16;\n    }\n    case VALUE_TYPE_INT32: {\n      return v->value.i32 == other->value.i32;\n    }\n    case VALUE_TYPE_UINT32: {\n      return v->value.u32 == other->value.u32;\n    }\n    case VALUE_TYPE_INT64: {\n      return v->value.i64 == other->value.i64;\n    }\n    case VALUE_TYPE_BOOL: {\n      return v->value.b == other->value.b;\n    }\n    case VALUE_TYPE_POINTER: {\n      return v->value.ptr == other->value.ptr;\n    }\n    case VALUE_TYPE_UINT64: {\n      return v->value.u64 == other->value.u64;\n    }\n    case VALUE_TYPE_FLOAT: {\n      return tk_fequal(v->value.f, other->value.f32);\n    }\n    case VALUE_TYPE_FLOAT32: {\n      return tk_fequal(v->value.f32, other->value.f32);\n    }\n    case VALUE_TYPE_DOUBLE: {\n      return tk_lfequal(v->value.f64, other->value.f64);\n    }\n    case VALUE_TYPE_STRING: {\n      return (v->value.str == other->value.str) || tk_str_eq(v->value.str, other->value.str);\n    }\n    case VALUE_TYPE_WSTRING: {\n      return (v->value.wstr == other->value.wstr) || tk_wstr_eq(v->value.wstr, other->value.wstr);\n    }\n    case VALUE_TYPE_BINARY:\n    case VALUE_TYPE_GRADIENT:\n    case VALUE_TYPE_UBJSON: {\n      return (v->value.binary_data.data == other->value.binary_data.data);\n    }\n    case VALUE_TYPE_OBJECT: {\n      return tk_object_compare(v->value.object, other->value.object) == 0;\n    }\n    default:\n      break;\n  }\n\n  return FALSE;\n}\n\nvalue_t* value_set_int(value_t* v, int32_t value) {\n  return value_set_int32(v, value);\n}\n\nvalue_t* value_create() {\n  return TKMEM_ZALLOC(value_t);\n}\n\nret_t value_reset(value_t* v) {\n  return_value_if_fail(v != NULL, RET_BAD_PARAMS);\n\n  if (v->free_handle) {\n    switch (v->type) {\n      case VALUE_TYPE_SIZED_STRING: {\n        TKMEM_FREE(v->value.sized_str.str);\n        break;\n      }\n      case VALUE_TYPE_BINARY:\n      case VALUE_TYPE_UBJSON:\n      case VALUE_TYPE_GRADIENT: {\n        TKMEM_FREE(v->value.binary_data.data);\n        break;\n      }\n      case VALUE_TYPE_STRING: {\n        TKMEM_FREE(v->value.str);\n        break;\n      }\n      case VALUE_TYPE_WSTRING: {\n        TKMEM_FREE(v->value.wstr);\n        break;\n      }\n      case VALUE_TYPE_OBJECT: {\n        tk_object_t* obj = v->value.object;\n        v->value.object = NULL;\n        TK_OBJECT_UNREF(obj);\n        break;\n      }\n      case VALUE_TYPE_ID: {\n        TKMEM_FREE(v->value.id.id);\n        break;\n      }\n      case VALUE_TYPE_FUNC: {\n        TKMEM_FREE(v->value.func.func);\n        break;\n      }\n      default:\n        break;\n    }\n  }\n\n  memset(v, 0x00, sizeof(value_t));\n\n  return RET_OK;\n}\n\nret_t value_destroy(value_t* v) {\n  return_value_if_fail(v != NULL, RET_BAD_PARAMS);\n\n  value_reset(v);\n  TKMEM_FREE(v);\n\n  return RET_OK;\n}\n\nvalue_t* value_set_object(value_t* v, tk_object_t* value) {\n  return_value_if_fail(v != NULL && value != NULL, NULL);\n\n  v->value.object = value;\n  return value_init(v, VALUE_TYPE_OBJECT);\n}\n\ntk_object_t* value_object(const value_t* v) {\n  return_value_if_fail(v != NULL && v->type == VALUE_TYPE_OBJECT, NULL);\n\n  return v->value.object;\n}\n\nvalue_t* value_cast(value_t* value) {\n  return_value_if_fail(value != NULL, NULL);\n\n  return value;\n}\n\nvalue_t* value_set_token(value_t* v, uint32_t value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.token = value;\n\n  return value_init(v, VALUE_TYPE_TOKEN);\n}\n\nuint32_t value_token(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n  return_value_if_fail(v->type == VALUE_TYPE_TOKEN, 0);\n\n  return v->value.token;\n}\n\nvalue_t* value_set_sized_str(value_t* v, char* str, uint32_t size) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.sized_str.str = str;\n  v->value.sized_str.size = size;\n\n  return value_init(v, VALUE_TYPE_SIZED_STRING);\n}\n\nsized_str_t* value_sized_str(const value_t* v) {\n  return_value_if_fail(v != NULL, NULL);\n  return_value_if_fail(v->type == VALUE_TYPE_SIZED_STRING, NULL);\n\n  return (sized_str_t*)&(v->value.sized_str);\n}\n\nvalue_t* value_set_binary_data(value_t* v, void* data, uint32_t size) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.binary_data.data = data;\n  v->value.binary_data.size = size;\n\n  return value_init(v, VALUE_TYPE_BINARY);\n}\n\nvalue_t* value_dup_binary_data(value_t* v, const void* data, uint32_t size) {\n  void* new_data = NULL;\n  return_value_if_fail(v != NULL && data != NULL, NULL);\n\n  new_data = TKMEM_ALLOC(size);\n  return_value_if_fail(new_data != NULL, NULL);\n  memcpy(new_data, data, size);\n\n  value_init(v, VALUE_TYPE_BINARY);\n  v->value.binary_data.data = new_data;\n  v->value.binary_data.size = size;\n  v->free_handle = TRUE;\n\n  return v;\n}\n\nbinary_data_t* value_binary_data(const value_t* v) {\n  return_value_if_fail(v != NULL, NULL);\n  return_value_if_fail(v->type == VALUE_TYPE_BINARY || v->type == VALUE_TYPE_GRADIENT ||\n                           v->type == VALUE_TYPE_UBJSON,\n                       NULL);\n\n  return (binary_data_t*)&(v->value.binary_data);\n}\n\nvalue_t* value_set_ubjson(value_t* v, void* data, uint32_t size) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.binary_data.data = data;\n  v->value.binary_data.size = size;\n\n  return value_init(v, VALUE_TYPE_UBJSON);\n}\n\nbinary_data_t* value_ubjson(const value_t* v) {\n  return_value_if_fail(v != NULL, NULL);\n  return_value_if_fail(v->type == VALUE_TYPE_UBJSON, NULL);\n\n  return (binary_data_t*)&(v->value.binary_data);\n}\n\nvalue_t* value_set_gradient(value_t* v, void* data, uint32_t size) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.binary_data.data = data;\n  v->value.binary_data.size = size;\n\n  return value_init(v, VALUE_TYPE_GRADIENT);\n}\n\nbinary_data_t* value_gradient(const value_t* v) {\n  return_value_if_fail(v != NULL, NULL);\n  return_value_if_fail(v->type == VALUE_TYPE_GRADIENT, NULL);\n\n  return (binary_data_t*)&(v->value.binary_data);\n}\n\nconst char* value_str_ex(const value_t* v, char* buff, uint32_t size) {\n  return_value_if_fail(v != NULL && buff != NULL && size > 0, NULL);\n\n  if (v->type == VALUE_TYPE_STRING) {\n    return value_str(v);\n  } else if (v->type == VALUE_TYPE_DOUBLE || v->type == VALUE_TYPE_FLOAT32 ||\n             v->type == VALUE_TYPE_FLOAT) {\n    tk_snprintf(buff, size, \"%lf\", value_double(v));\n  } else if (v->type == VALUE_TYPE_WSTRING) {\n    tk_utf8_from_utf16(value_wstr(v), buff, size);\n  } else if (v->type == VALUE_TYPE_BOOL) {\n    tk_snprintf(buff, size, \"%s\", value_bool(v) ? \"true\" : \"false\");\n  } else if (v->type == VALUE_TYPE_UINT8 || v->type == VALUE_TYPE_UINT16 ||\n             v->type == VALUE_TYPE_UINT32) {\n    tk_snprintf(buff, size, \"%u\", value_uint32(v));\n  } else if (v->type == VALUE_TYPE_UINT64) {\n    tk_snprintf(buff, size, \"%\" PRIu64, value_uint64(v));\n  } else if (v->type == VALUE_TYPE_INT64) {\n    tk_snprintf(buff, size, \"%\" PRId64, value_int64(v));\n  } else if (v->type == VALUE_TYPE_ID) {\n    assert(v->value.id.id != NULL);\n    return v->value.id.id;\n  } else if (v->type == VALUE_TYPE_BINARY) {\n    binary_data_t* bin = value_binary_data(v);\n    if (bin != NULL) {\n      tk_snprintf(buff, size, \"binary(%p:%u)\", bin->data, bin->size);\n    } else {\n      tk_snprintf(buff, size, \"(null)\");\n    }\n  } else if (v->type == VALUE_TYPE_FUNC) {\n    return \"func\";\n  } else if (v->type == VALUE_TYPE_FUNC_DEF) {\n    return \"func_def\";\n  } else if (v->type == VALUE_TYPE_POINTER) {\n    tk_snprintf(buff, size, \"%p\", value_pointer(v));\n  } else if (v->type == VALUE_TYPE_OBJECT) {\ntk_object_t* obj = ",
    "raw_res": "0;",
    "prompt_res": "value_object(v);",
    "gt": "value_object(v);"
  },
  {
    "id": 1041,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/streams/mem/iostream_mem.c",
    "input": "﻿/**\n * File:   iostream_mem.c\n * Author: AWTK Develop Team\n * Brief:  iostream base on mem\n *\n * Copyright (c) 2019 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-09-18 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"streams/mem/istream_mem.h\"\n#include \"streams/mem/ostream_mem.h\"\n#include \"streams/mem/iostream_mem.h\"\n\nstatic ret_t tk_iostream_mem_on_destroy(tk_object_t* obj) {\n  tk_iostream_mem_t* iostream_mem = TK_IOSTREAM_MEM(obj);\n\n  tk_object_unref(TK_OBJECT(iostream_mem->istream));\n  tk_object_unref(TK_OBJECT(iostream_mem->ostream));\n\n  return RET_OK;\n}\n\nstatic const object_vtable_t s_tk_iostream_mem_vtable = {.type = \"tk_iostream_mem\",\n                                                         .desc = \"tk_iostream_mem\",\n                                                         .size = sizeof(tk_iostream_mem_t),\n                                                         .on_destroy = tk_iostream_mem_on_destroy};\n\nstatic tk_istream_t* tk_iostream_mem_get_istream(tk_iostream_t* stream) {\n  tk_iostream_mem_t* iostream_mem = TK_IOSTREAM_MEM(stream);\n\n  return iostream_mem->istream;\n}\n\nstatic tk_ostream_t* tk_iostream_mem_get_ostream(tk_iostream_t* stream) {\n  tk_iostream_mem_t* iostream_mem = TK_IOSTREAM_MEM(stream);\n\n  return iostream_mem->ostream;\n}\n\ntk_iostream_t* tk_iostream_mem_create(void* buff_in, uint32_t size_in, void* buff_out,\n                                      uint32_t size_out, bool_t own_buff) {\n  tk_object_t* obj = NULL;\n  tk_iostream_mem_t* iostream_mem = NULL;\n  return_value_if_fail(buff_in != NULL && size_in > 0, NULL);\n  return_value_if_fail(buff_out != NULL && size_out > 0, NULL);\n\n  obj = tk_object_create(&s_tk_iostream_mem_vtable);\n  iostream_mem = TK_IOSTREAM_MEM(obj);\n  if (iostream_mem == NULL) {\n    return_value_if_fail(iostream_mem != NULL, NULL);\n  }\n\n  iostream_mem->istream = tk_istream_mem_create(buff_in, size_in, 0, own_buff);\niostream_mem->ostream = ",
    "raw_res": "0;",
    "prompt_res": "tk_ostream_mem_create(buff_out, size_out, 0, own_buff);",
    "gt": "tk_ostream_mem_create(buff_out, size_out, 0, own_buff);"
  },
  {
    "id": 1050,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/streams/statistics/ostream_stats.c",
    "input": "﻿/**\n * File:   p_this.c\n * Author: AWTK Develop Team\n * Brief:  output stream base on memory\n *\n * Copyright (c) 2019 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 20220308 vih created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"ostream_stats.h\"\n#include \"iostream_stats.h\"\n\nstatic int32_t tk_ostream_stats_write(tk_ostream_t* stream, const uint8_t* buff,\n                                      uint32_t max_size) {\n  int32_t size = 0;\n  tk_ostream_stats_t* p_this = TK_OSTREAM_STATS(stream);\n\n  size = tk_ostream_write(p_this->impl_ostream, buff, max_size);\n  if (size > 0) {\n    p_this->count += size;\n  }\n  return size;\n}\n\nstatic ret_t tk_ostream_stats_seek(tk_ostream_t* stream, uint32_t offset) {\n  tk_ostream_stats_t* p_this = TK_OSTREAM_STATS(stream);\n  return tk_ostream_seek(p_this->impl_ostream, offset);\n}\n\nstatic int32_t tk_ostream_stats_tell(tk_ostream_t* stream) {\n  tk_ostream_stats_t* p_this = TK_OSTREAM_STATS(stream);\n  return tk_ostream_tell(p_this->impl_ostream);\n}\n\nstatic ret_t tk_ostream_stats_flush(tk_ostream_t* stream) {\n  tk_ostream_stats_t* p_this = TK_OSTREAM_STATS(stream);\n  return tk_ostream_flush(p_this->impl_ostream);\n}\n\nstatic ret_t tk_ostream_stats_set_prop(tk_object_t* obj, const char* name, const value_t* v) {\n  tk_ostream_stats_t* p_this = TK_OSTREAM_STATS(obj);\n  return tk_object_set_prop(TK_OBJECT(p_this->impl_ostream), name, v);\n}\n\nstatic ret_t tk_ostream_stats_get_prop(tk_object_t* obj, const char* name, value_t* v) {\n  tk_ostream_stats_t* p_this = TK_OSTREAM_STATS(obj);\n  if (tk_str_eq(name, TK_OSTREAM_STATS_PROP_WRITE)) {\n    value_set_int(v, p_this->count);\n    return RET_OK;\n  }\n\n  return tk_object_get_prop(TK_OBJECT(p_this->impl_ostream), name, v);\n}\n\nstatic ret_t tk_ostream_stats_exec(tk_object_t* obj, const char* name, const char* args) {\n  tk_ostream_stats_t* p_this = TK_OSTREAM_STATS(obj);\n  if (tk_str_eq(name, TK_OSTREAM_STATS_CMD_RESET)) {\n    p_this->count = 0;\n    return RET_OK;\n  }\n  return tk_object_exec(TK_OBJECT(p_this->impl_ostream), name, args);\n}\n\nstatic ret_t tk_ostream_stats_on_destroy(tk_object_t* obj) {\n  return RET_OK;\n}\n\nstatic const object_vtable_t s_tk_ostream_stats_vtable = {\n    .type = \"tk_ostream_stats\",\n    .desc = \"tk_ostream_stats\",\n    .size = sizeof(tk_ostream_stats_t),\n    .on_destroy = tk_ostream_stats_on_destroy,\n    .get_prop = tk_ostream_stats_get_prop,\n    .set_prop = tk_ostream_stats_set_prop,\n    .exec = tk_ostream_stats_exec,\n};\n\ntk_ostream_t* tk_ostream_stats_create(tk_ostream_t* impl) {\n  tk_object_t* obj = NULL;\n  tk_ostream_stats_t* p_this = NULL;\n  return_value_if_fail(impl, NULL);\n\nobj = ",
    "raw_res": "0;",
    "prompt_res": "tk_object_create(&s_tk_ostream_stats_vtable);",
    "gt": "tk_object_create(&s_tk_ostream_stats_vtable);"
  },
  {
    "id": 1089,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/streams/inet/iostream_tcp.c",
    "input": "﻿/**\n * File:   iostream_tcp.c\n * Author: AWTK Develop Team\n * Brief:  input stream base on socket\n *\n * Copyright (c) 2019 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-09-05 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN 1\n#endif /*WIN32_LEAN_AND_MEAN*/\n\n#include \"tkc/mem.h\"\n#include \"tkc/socket_helper.h\"\n#include \"streams/inet/istream_tcp.h\"\n#include \"streams/inet/ostream_tcp.h\"\n#include \"streams/inet/iostream_tcp.h\"\n\nstatic ret_t tk_iostream_tcp_get_prop(tk_object_t* obj, const char* name, value_t* v) {\n  tk_iostream_tcp_t* iostream_tcp = TK_IOSTREAM_TCP(obj);\n\n  if (tk_str_eq(name, TK_STREAM_PROP_FD)) {\n    value_set_int(v, iostream_tcp->sock);\n    return RET_OK;\n  } else if (tk_str_eq(name, TK_STREAM_PROP_IS_OK)) {\n    bool_t is_ok1 =\n        tk_object_get_prop_bool(TK_OBJECT(iostream_tcp->istream), TK_STREAM_PROP_IS_OK, TRUE);\n    bool_t is_ok2 =\n        tk_object_get_prop_bool(TK_OBJECT(iostream_tcp->ostream), TK_STREAM_PROP_IS_OK, TRUE);\n\n    value_set_bool(v, is_ok1 && is_ok2);\n\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t tk_iostream_tcp_on_destroy(tk_object_t* obj) {\n  tk_iostream_tcp_t* iostream_tcp = TK_IOSTREAM_TCP(obj);\n\n  tk_socket_close(iostream_tcp->sock);\n  tk_object_unref(TK_OBJECT(iostream_tcp->istream));\n  tk_object_unref(TK_OBJECT(iostream_tcp->ostream));\n\n  return RET_OK;\n}\n\nstatic const object_vtable_t s_tk_iostream_tcp_vtable = {.type = \"tk_iostream_tcp\",\n                                                         .desc = \"tk_iostream_tcp\",\n                                                         .size = sizeof(tk_iostream_tcp_t),\n                                                         .get_prop = tk_iostream_tcp_get_prop,\n                                                         .on_destroy = tk_iostream_tcp_on_destroy};\n\nstatic tk_istream_t* tk_iostream_tcp_get_istream(tk_iostream_t* stream) {\n  tk_iostream_tcp_t* iostream_tcp = TK_IOSTREAM_TCP(stream);\n\n  return iostream_tcp->istream;\n}\n\nstatic tk_ostream_t* tk_iostream_tcp_get_ostream(tk_iostream_t* stream) {\n  tk_iostream_tcp_t* iostream_tcp = TK_IOSTREAM_TCP(stream);\n\n  return iostream_tcp->ostream;\n}\n\ntk_iostream_t* tk_iostream_tcp_create(int sock) {\n  tk_object_t* obj = NULL;\n  tk_iostream_tcp_t* iostream_tcp = NULL;\n  return_value_if_fail(sock >= 0, NULL);\n\n  obj = tk_object_create(&s_tk_iostream_tcp_vtable);\n  iostream_tcp = TK_IOSTREAM_TCP(obj);\n  if (iostream_tcp == NULL) {\n    tk_socket_close(sock);\n    return_value_if_fail(iostream_tcp != NULL, NULL);\n  }\n\n  iostream_tcp->sock = sock;\niostream_tcp->istream = ",
    "raw_res": "0;",
    "prompt_res": "tk_istream_tcp_create(sock);",
    "gt": "tk_istream_tcp_create(sock);"
  },
  {
    "id": 1106,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/streams/tools/udp_send.c",
    "input": "﻿#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN 1\n#endif /*WIN32_LEAN_AND_MEAN*/\n\n#include \"tkc/utils.h\"\n#include \"tkc/platform.h\"\n#include \"streams/inet/iostream_udp.h\"\n#include \"tkc/socket_helper.h\"\n\nvoid do_send(tk_iostream_t* iostream, const char* msg) {\n  char buff[1024];\n  int32_t ret = 0;\n  uint32_t size = strlen(msg) + 1;\n  tk_istream_t* istream = tk_iostream_get_istream(iostream);\n  tk_ostream_t* ostream = tk_iostream_get_ostream(iostream);\n\n  memset(buff, 0x00, sizeof(buff));\nret = ",
    "raw_res": "0;",
    "prompt_res": "tk_ostream_write(ostream, (uint8_t*)msg, size);",
    "gt": "tk_ostream_write(ostream, (uint8_t*)msg, size);"
  },
  {
    "id": 1108,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/streams/tools/udp_send.c",
    "input": "﻿#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN 1\n#endif /*WIN32_LEAN_AND_MEAN*/\n\n#include \"tkc/utils.h\"\n#include \"tkc/platform.h\"\n#include \"streams/inet/iostream_udp.h\"\n#include \"tkc/socket_helper.h\"\n\nvoid do_send(tk_iostream_t* iostream, const char* msg) {\n  char buff[1024];\n  int32_t ret = 0;\n  uint32_t size = strlen(msg) + 1;\n  tk_istream_t* istream = tk_iostream_get_istream(iostream);\n  tk_ostream_t* ostream = tk_iostream_get_ostream(iostream);\n\n  memset(buff, 0x00, sizeof(buff));\n  ret = tk_ostream_write(ostream, (uint8_t*)msg, size);\n  log_debug(\"send ret=%d %s\\n\", ret, msg);\n\n  ret = tk_istream_read(istream, (uint8_t*)buff, sizeof(buff));\n  log_debug(\"%d: %s\\n\", ret, buff);\n\n  tk_object_unref(TK_OBJECT(iostream));\n\n  return;\n}\n\nint main(int argc, char* argv[]) {\n  int port = 0;\n  int local_port = -1;\n  const char* msg = NULL;\n  const char* host = NULL;\n  const char* local_ip = NULL;\n\n  if (argc != 4 && argc != 6) {\n    printf(\"Usage: %s host port msg\\n\", argv[0]);\n    printf(\"       %s host port local_ip local_port msg\\n\", argv[0]);\n    return 0;\n  }\n\n  tk_socket_init();\n  platform_prepare();\n  TK_ENABLE_CONSOLE();\n\n  host = argv[1];\nport = ",
    "raw_res": "0;",
    "prompt_res": "tk_atoi(argv[2]);",
    "gt": "tk_atoi(argv[2]);"
  },
  {
    "id": 1110,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/streams/tools/tcp_send.c",
    "input": "﻿#include \"tkc/platform.h\"\n#include \"streams/inet/iostream_tcp.h\"\n\nint main(int argc, char* argv[]) {\n  int32_t ret = 0;\n  int32_t sock = 0;\n  tk_iostream_t* io = NULL;\n  const char* request = \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\";\n\n  tk_socket_init();\n  platform_prepare();\n  sock = tk_tcp_connect(\"localhost\", 8080);\n  return_value_if_fail(sock > 0, 0);\n\nio = ",
    "raw_res": "0;",
    "prompt_res": "tk_iostream_tcp_create(sock);",
    "gt": "tk_iostream_tcp_create(sock);"
  },
  {
    "id": 1111,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/streams/tools/tcp_send.c",
    "input": "﻿#include \"tkc/platform.h\"\n#include \"streams/inet/iostream_tcp.h\"\n\nint main(int argc, char* argv[]) {\n  int32_t ret = 0;\n  int32_t sock = 0;\n  tk_iostream_t* io = NULL;\n  const char* request = \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\";\n\n  tk_socket_init();\n  platform_prepare();\n  sock = tk_tcp_connect(\"localhost\", 8080);\n  return_value_if_fail(sock > 0, 0);\n\n  io = tk_iostream_tcp_create(sock);\n  if (io != NULL) {\n    char buff[1024] = {0};\ntk_istream_t* in = ",
    "raw_res": "0;",
    "prompt_res": "tk_iostream_get_istream(io);",
    "gt": "tk_iostream_get_istream(io);"
  },
  {
    "id": 1112,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/streams/tools/tcp_send.c",
    "input": "﻿#include \"tkc/platform.h\"\n#include \"streams/inet/iostream_tcp.h\"\n\nint main(int argc, char* argv[]) {\n  int32_t ret = 0;\n  int32_t sock = 0;\n  tk_iostream_t* io = NULL;\n  const char* request = \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\";\n\n  tk_socket_init();\n  platform_prepare();\n  sock = tk_tcp_connect(\"localhost\", 8080);\n  return_value_if_fail(sock > 0, 0);\n\n  io = tk_iostream_tcp_create(sock);\n  if (io != NULL) {\n    char buff[1024] = {0};\n    tk_istream_t* in = tk_iostream_get_istream(io);\ntk_ostream_t* out = ",
    "raw_res": "0;",
    "prompt_res": "tk_iostream_get_ostream(io);",
    "gt": "tk_iostream_get_ostream(io);"
  },
  {
    "id": 1116,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/streams/tools/serial_at.c",
    "input": "﻿#include \"tkc/utils.h\"\n#include \"tkc/platform.h\"\n#include \"streams/serial/iostream_serial.h\"\n#include \"streams/serial/serial_helper.h\"\n\nvoid do_send(tk_iostream_t* iostream, const char* msg) {\n  char buff[128];\n  int32_t ret = 0;\n  tk_istream_t* istream = tk_iostream_get_istream(iostream);\ntk_ostream_t* ostream = ",
    "raw_res": "0;",
    "prompt_res": "tk_iostream_get_ostream(iostream);",
    "gt": "tk_iostream_get_ostream(iostream);"
  },
  {
    "id": 1117,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/streams/tools/serial_at.c",
    "input": "﻿#include \"tkc/utils.h\"\n#include \"tkc/platform.h\"\n#include \"streams/serial/iostream_serial.h\"\n#include \"streams/serial/serial_helper.h\"\n\nvoid do_send(tk_iostream_t* iostream, const char* msg) {\n  char buff[128];\n  int32_t ret = 0;\n  tk_istream_t* istream = tk_iostream_get_istream(iostream);\n  tk_ostream_t* ostream = tk_iostream_get_ostream(iostream);\n\n  tk_snprintf(buff, sizeof(buff), \"%s\\r\\n\", msg);\n\nret = ",
    "raw_res": "0;",
    "prompt_res": "tk_ostream_write(ostream, (uint8_t*)buff, strlen(buff));",
    "gt": "tk_ostream_write(ostream, (uint8_t*)buff, strlen(buff));"
  },
  {
    "id": 1122,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/streams/tools/https_server.c",
    "input": "﻿#include \"tkc/platform.h\"\n#include \"streams/inet/iostream_mbedtls.h\"\n#include \"streams/inet/mbedtls_server.h\"\n\nint main(int argc, char* argv[]) {\n  int32_t ret = 0;\n  mbedtls_server_t* server = NULL;\n\n  platform_prepare();\n  server =\n      mbedtls_server_create(\"4433\", (const uint8_t*)mbedtls_test_srv_crt, mbedtls_test_srv_crt_len,\n                            (const uint8_t*)mbedtls_test_srv_key, mbedtls_test_srv_key_len,\n                            (const uint8_t*)mbedtls_test_cas_pem, mbedtls_test_cas_pem_len);\n\n  if (server != NULL) {\n    char buff[1024];\n    mbedtls_conn_t* conn = mbedtls_server_accept(server);\n    tk_iostream_t* io = tk_iostream_mbedtls_create(conn);\ntk_istream_t* in = ",
    "raw_res": "tk_istream_create(io);",
    "prompt_res": "tk_iostream_get_istream(io);",
    "gt": "tk_iostream_get_istream(io);"
  },
  {
    "id": 1137,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/streams/tools/shdlc_send.c",
    "input": "﻿#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN 1\n#endif /*WIN32_LEAN_AND_MEAN*/\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/platform.h\"\n#include \"streams/inet/iostream_tcp.h\"\n#include \"streams/noisy/iostream_noisy.h\"\n#include \"streams/shdlc/iostream_shdlc.h\"\n#include \"tkc/socket_helper.h\"\n\nvoid do_send(tk_iostream_t* tcp, const char* msg, uint32_t times) {\n  uint32_t i = 0;\n  int32_t s_ret = 0;\n  int32_t r_ret = 0;\n  char buff[1024 * 50];\n  tk_iostream_t* noisy = tk_iostream_noisy_create(tcp);\n  tk_iostream_t* iostream = tk_iostream_shdlc_create(noisy);\n  tk_istream_t* istream = tk_iostream_get_istream(iostream);\n  tk_ostream_t* ostream = tk_iostream_get_ostream(iostream);\n\n  for (i = 0; i < times; i++) {\n    tk_snprintf(buff, sizeof(buff), \"(%u) %s\", i, msg);\n\ns_ret = ",
    "raw_res": "0;",
    "prompt_res": "tk_ostream_write(ostream, (uint8_t*)buff, strlen(buff));",
    "gt": "tk_ostream_write(ostream, (uint8_t*)buff, strlen(buff));"
  },
  {
    "id": 1146,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/streams/tools/tcp_recv.c",
    "input": "﻿#include \"tkc/platform.h\"\n#include \"streams/inet/iostream_tcp.h\"\n\nint main(int argc, char* argv[]) {\n  int32_t ret = 0;\n  int32_t lsock = 0;\n  tk_iostream_t* io = NULL;\n  const char* response = \"200 OK\\n\";\n\n  tk_socket_init();\n  platform_prepare();\n  lsock = tk_tcp_listen(8080);\n  return_value_if_fail(lsock > 0, 0);\n\n  log_debug(\"listen at 8080...\\n\");\n  while (1) {\n    int32_t sock = 0;\n    sock = tk_tcp_accept(lsock);\n    if (sock < 0) {\n      break;\n    }\n    log_debug(\"%d client come in...\\n\", sock);\nio = ",
    "raw_res": "io = tk_iostream_new(sock);",
    "prompt_res": "tk_iostream_tcp_create(sock);",
    "gt": "tk_iostream_tcp_create(sock);"
  },
  {
    "id": 1147,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/streams/tools/tcp_recv.c",
    "input": "﻿#include \"tkc/platform.h\"\n#include \"streams/inet/iostream_tcp.h\"\n\nint main(int argc, char* argv[]) {\n  int32_t ret = 0;\n  int32_t lsock = 0;\n  tk_iostream_t* io = NULL;\n  const char* response = \"200 OK\\n\";\n\n  tk_socket_init();\n  platform_prepare();\n  lsock = tk_tcp_listen(8080);\n  return_value_if_fail(lsock > 0, 0);\n\n  log_debug(\"listen at 8080...\\n\");\n  while (1) {\n    int32_t sock = 0;\n    sock = tk_tcp_accept(lsock);\n    if (sock < 0) {\n      break;\n    }\n    log_debug(\"%d client come in...\\n\", sock);\n    io = tk_iostream_tcp_create(sock);\n    if (io != NULL) {\n      char buff[1024] = {0};\ntk_istream_t* in = ",
    "raw_res": "0;",
    "prompt_res": "tk_iostream_get_istream(io);",
    "gt": "tk_iostream_get_istream(io);"
  },
  {
    "id": 1148,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/streams/tools/tcp_recv.c",
    "input": "﻿#include \"tkc/platform.h\"\n#include \"streams/inet/iostream_tcp.h\"\n\nint main(int argc, char* argv[]) {\n  int32_t ret = 0;\n  int32_t lsock = 0;\n  tk_iostream_t* io = NULL;\n  const char* response = \"200 OK\\n\";\n\n  tk_socket_init();\n  platform_prepare();\n  lsock = tk_tcp_listen(8080);\n  return_value_if_fail(lsock > 0, 0);\n\n  log_debug(\"listen at 8080...\\n\");\n  while (1) {\n    int32_t sock = 0;\n    sock = tk_tcp_accept(lsock);\n    if (sock < 0) {\n      break;\n    }\n    log_debug(\"%d client come in...\\n\", sock);\n    io = tk_iostream_tcp_create(sock);\n    if (io != NULL) {\n      char buff[1024] = {0};\n      tk_istream_t* in = tk_iostream_get_istream(io);\ntk_ostream_t* out = ",
    "raw_res": "0;",
    "prompt_res": "tk_iostream_get_ostream(io);",
    "gt": "tk_iostream_get_ostream(io);"
  },
  {
    "id": 1151,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/streams/tools/https_client.c",
    "input": "﻿#include \"tkc/platform.h\"\n#include \"streams/inet/iostream_mbedtls.h\"\n#include \"streams/inet/mbedtls_client.h\"\n\nint main(int argc, char* argv[]) {\n  int32_t ret = 0;\n  mbedtls_conn_t* conn = NULL;\n  const char* request = \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\";\n\n  platform_prepare();\n  conn = mbedtls_conn_client_create(\"localhost\", \"4433\", (const uint8_t*)mbedtls_test_cas_pem,\n                                    mbedtls_test_cas_pem_len);\n\n  if (conn != NULL) {\n    char buff[1024] = {0};\ntk_iostream_t* io = ",
    "raw_res": "0;",
    "prompt_res": "tk_iostream_mbedtls_create(conn);",
    "gt": "tk_iostream_mbedtls_create(conn);"
  },
  {
    "id": 1152,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/streams/tools/https_client.c",
    "input": "﻿#include \"tkc/platform.h\"\n#include \"streams/inet/iostream_mbedtls.h\"\n#include \"streams/inet/mbedtls_client.h\"\n\nint main(int argc, char* argv[]) {\n  int32_t ret = 0;\n  mbedtls_conn_t* conn = NULL;\n  const char* request = \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\";\n\n  platform_prepare();\n  conn = mbedtls_conn_client_create(\"localhost\", \"4433\", (const uint8_t*)mbedtls_test_cas_pem,\n                                    mbedtls_test_cas_pem_len);\n\n  if (conn != NULL) {\n    char buff[1024] = {0};\n    tk_iostream_t* io = tk_iostream_mbedtls_create(conn);\ntk_istream_t* in = ",
    "raw_res": "tk_istream_create(io);",
    "prompt_res": "tk_iostream_get_istream(io);",
    "gt": "tk_iostream_get_istream(io);"
  },
  {
    "id": 1153,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/streams/tools/https_client.c",
    "input": "﻿#include \"tkc/platform.h\"\n#include \"streams/inet/iostream_mbedtls.h\"\n#include \"streams/inet/mbedtls_client.h\"\n\nint main(int argc, char* argv[]) {\n  int32_t ret = 0;\n  mbedtls_conn_t* conn = NULL;\n  const char* request = \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\";\n\n  platform_prepare();\n  conn = mbedtls_conn_client_create(\"localhost\", \"4433\", (const uint8_t*)mbedtls_test_cas_pem,\n                                    mbedtls_test_cas_pem_len);\n\n  if (conn != NULL) {\n    char buff[1024] = {0};\n    tk_iostream_t* io = tk_iostream_mbedtls_create(conn);\n    tk_istream_t* in = tk_iostream_get_istream(io);\ntk_ostream_t* out = ",
    "raw_res": "0;",
    "prompt_res": "tk_iostream_get_ostream(io);",
    "gt": "tk_iostream_get_ostream(io);"
  },
  {
    "id": 1193,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/image_loader/image_loader_stb.c",
    "input": "﻿/**\n * File:   image_loader.h\n * Author: AWTK Develop Team\n * Brief:  stb image loader\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-21 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#define STB_IMAGE_IMPLEMENTATION\n#define STBI_FREE TKMEM_FREE\n#define STBI_MALLOC TKMEM_ALLOC\n#define STBI_REALLOC(p, s) TKMEM_REALLOC(p, s)\n\n#include \"tkc/mem.h\"\n#include \"base/bitmap.h\"\n#include \"stb/stb_image.h\"\n#include \"base/system_info.h\"\n#include \"image_loader/image_loader_stb.h\"\n\nstatic uint8_t* convert_2_to_4(uint8_t* src, uint32_t w, uint32_t h) {\n  uint32_t i = 0;\n  uint8_t* s = src;\n  uint8_t* d = NULL;\n  uint8_t* data = NULL;\n  uint32_t size = w * h;\n  return_value_if_fail(src != NULL, NULL);\n\n  data = TKMEM_ALLOC(size * 4);\n  return_value_if_fail(data != NULL, NULL);\n\n  d = data;\n  for (i = 0; i < size; i++) {\n    d[0] = s[0];\n    d[1] = s[0];\n    d[2] = s[0];\n    d[3] = s[1];\n\n    d += 4;\n    s += 2;\n  }\n\n  return data;\n}\n\nret_t stb_load_image(int32_t subtype, const uint8_t* buff, uint32_t buff_size, bitmap_t* image,\n                     bool_t require_bgra, bool_t enable_bgr565, bool_t enable_rgb565,\n                     lcd_orientation_t o) {\n  int w = 0;\n  int h = 0;\n  int n = 0;\n  ret_t ret = RET_FAIL;\n\n  if (subtype != ASSET_TYPE_IMAGE_GIF) {\n    uint8_t* data = NULL;\n    int out_channel_order;\n    uint8_t* stb_data =\n        stbi_load_from_memory_ex(buff, buff_size, &w, &h, &n, &out_channel_order, 0);\n    return_value_if_fail(stb_data != NULL, RET_FAIL);\n\n    if (n == 2) {\n      n = 4;\n      data = convert_2_to_4(stb_data, w, h);\n    } else {\n      data = stb_data;\n    }\n#ifdef WITH_LCD_MONO\n    if (out_channel_order == STBI_ORDER_RGB) {\n      ret = bitmap_init_from_rgba(image, w, h, BITMAP_FMT_MONO, data, n, o);\n    } else {\n      ret = bitmap_init_from_bgra(image, w, h, BITMAP_FMT_MONO, data, n, o);\n    }\n#else\n    if (out_channel_order == STBI_ORDER_RGB) {\n      if (enable_bgr565 && rgba_data_is_opaque(data, w, h, n)) {\n        ret = bitmap_init_from_rgba(image, w, h, BITMAP_FMT_BGR565, data, n, o);\n      } else if (enable_rgb565 && rgba_data_is_opaque(data, w, h, n)) {\n        ret = bitmap_init_from_rgba(image, w, h, BITMAP_FMT_RGB565, data, n, o);\n      } else if (require_bgra) {\n        ret = bitmap_init_from_rgba(image, w, h, BITMAP_FMT_BGRA8888, data, n, o);\n      } else {\n        ret = bitmap_init_from_rgba(image, w, h, BITMAP_FMT_RGBA8888, data, n, o);\n      }\n    } else {\n      if (enable_bgr565 && rgba_data_is_opaque(data, w, h, n)) {\nret = ",
    "raw_res": "bitmap_init_from_rgba(image, w, h, BITMAP_FMT_BGR565, data, n, o);",
    "prompt_res": "bitmap_init_from_bgra(image, w, h, BITMAP_FMT_BGR565, data, n, o);",
    "gt": "bitmap_init_from_bgra(image, w, h, BITMAP_FMT_BGR565, data, n, o);"
  },
  {
    "id": 1212,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/window_manager/window_manager_default.c",
    "input": "﻿/**\n * File:   window_manager_default.c\n * Author: AWTK Develop Team\n * Brief:  default window manager\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-13 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"base/keys.h\"\n#include \"tkc/mem.h\"\n#include \"base/idle.h\"\n#include \"tkc/utils.h\"\n#include \"base/timer.h\"\n#include \"base/layout.h\"\n#include \"tkc/time_now.h\"\n#include \"base/dialog.h\"\n#include \"base/locale_info.h\"\n#include \"base/system_info.h\"\n#include \"base/input_method.h\"\n#include \"base/image_manager.h\"\n#include \"base/canvas_offline.h\"\n#include \"base/dirty_rects.inc\"\n#include \"base/dialog_highlighter_factory.h\"\n#include \"window_manager/window_manager_default.h\"\n\nstatic ret_t window_manager_animate_done(widget_t* widget);\nstatic ret_t window_manager_default_update_fps(widget_t* widget);\nstatic ret_t window_manager_invalidate_system_bar(widget_t* widget);\nstatic ret_t window_manager_default_reset_window_animator(widget_t* widget);\nstatic ret_t window_manager_default_reset_dialog_highlighter(widget_t* widget);\nstatic ret_t window_manager_default_invalidate(widget_t* widget, const rect_t* r);\nstatic ret_t window_manager_default_get_client_r(widget_t* widget, rect_t* r);\nstatic ret_t window_manager_default_do_open_window(widget_t* wm, widget_t* window);\nstatic ret_t window_manager_default_layout_child(widget_t* widget, widget_t* window);\nstatic ret_t window_manager_default_paint_always_on_top(widget_t* widget, canvas_t* c);\nstatic ret_t window_manager_default_layout_system_bar(widget_t* widget, widget_t* window);\nstatic ret_t window_manager_default_create_dialog_highlighter(widget_t* widget, widget_t* curr_win);\nstatic ret_t window_manager_default_layout_not_system_bar(widget_t* widget, widget_t* window,\n                                                          rect_t client_r);\n\nstatic bool_t window_is_fullscreen(widget_t* widget) {\n  value_t v;\n  value_set_bool(&v, FALSE);\n  widget_get_prop(widget, WIDGET_PROP_FULLSCREEN, &v);\n\n  return value_bool(&v);\n}\n\nstatic bool_t window_is_opened(widget_t* widget) {\n  int32_t stage = widget_get_prop_int(widget, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n\n  return stage == WINDOW_STAGE_OPENED || stage == WINDOW_STAGE_SUSPEND;\n}\n\nstatic ret_t wm_on_screen_saver_timer(const timer_info_t* info) {\n  window_manager_default_t* wm = WINDOW_MANAGER_DEFAULT(info->ctx);\n  event_t e = event_init(EVT_SCREEN_SAVER, wm);\n  wm->screen_saver_timer_id = TK_INVALID_ID;\n\n  widget_dispatch(WIDGET(wm), &e);\n  log_debug(\"emit: EVT_SCREEN_SAVER\\n\");\n\n  return RET_REMOVE;\n}\n\nstatic ret_t window_manager_start_or_reset_screen_saver_timer(window_manager_default_t* wm) {\n  if (wm->screen_saver_time > 0) {\n    if (wm->screen_saver_timer_id == TK_INVALID_ID) {\n      wm->screen_saver_timer_id = timer_add(wm_on_screen_saver_timer, wm, wm->screen_saver_time);\n    } else {\n      timer_modify(wm->screen_saver_timer_id, wm->screen_saver_time);\n    }\n  } else {\n    if (wm->screen_saver_timer_id != TK_INVALID_ID) {\n      timer_remove(wm->screen_saver_timer_id);\n      wm->screen_saver_timer_id = TK_INVALID_ID;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic widget_t* window_manager_find_prev_window(widget_t* widget) {\n  int32_t i = 0;\n  int32_t nr = 0;\n  return_value_if_fail(widget != NULL, NULL);\n\n  if (widget->children != NULL && widget->children->size > 0) {\n    nr = widget->children->size;\n    for (i = nr - 2; i >= 0; i--) {\n      widget_t* iter = (widget_t*)(widget->children->elms[i]);\n      if (widget_is_normal_window(iter) || widget_is_dialog(iter) || widget_is_popup(iter)) {\n        return iter;\n      }\n    }\n  }\n\n  return NULL;\n}\n\nstatic widget_t* window_manager_find_prev_normal_window(widget_t* widget) {\n  return_value_if_fail(widget != NULL, NULL);\n\n  if (widget->children != NULL && widget->children->size >= 2) {\n    WIDGET_FOR_EACH_CHILD_BEGIN_R(widget, iter, i)\n    if (i <= widget->children->size - 2 && widget_is_normal_window(iter) && iter->visible) {\n      return iter;\n    }\n    WIDGET_FOR_EACH_CHILD_END();\n  }\n\n  return NULL;\n}\n\nret_t window_manager_default_snap_curr_window(widget_t* widget, widget_t* curr_win, bitmap_t* img) {\n#ifndef WITHOUT_WINDOW_ANIMATORS\n  canvas_t* c = NULL;\n  rect_t r = {0};\n  canvas_t* canvas = NULL;\n  window_manager_default_t* wm = WINDOW_MANAGER_DEFAULT(widget);\n  return_value_if_fail(img != NULL && wm != NULL && curr_win != NULL, RET_BAD_PARAMS);\n\n  c = native_window_get_canvas(wm->native_window);\n  return_value_if_fail(c != NULL && c->lcd != NULL, RET_BAD_PARAMS);\n  window_manager_check_and_layout(widget);\n\n  r = rect_init(curr_win->x, curr_win->y, curr_win->w, curr_win->h);\n\n  canvas_save(c);\n  canvas = canvas_offline_create(lcd_get_physical_width(c->lcd), lcd_get_physical_height(c->lcd),\n                                 lcd_get_desired_bitmap_format(c->lcd));\n\n  canvas_offline_begin_draw(canvas);\n  canvas_set_clip_rect(canvas, &r);\n  ENSURE(widget_on_paint_background(widget, canvas) == RET_OK);\n  ENSURE(widget_paint(curr_win, canvas) == RET_OK);\n  canvas_offline_end_draw(canvas);\n  ENSURE(canvas_offline_bitmap_move_to_new_bitmap(canvas, img) == RET_OK);\n  ENSURE(canvas_offline_destroy(canvas) == RET_OK);\n  img->flags |= BITMAP_FLAG_OPAQUE;\n  canvas_restore(c);\n  /* 清除在线画布的缓存，确保绘制完窗口动画后，lcd对象的数据能和在线画布同步 */\n  canvas_reset_cache(c);\n#endif\n  return RET_OK;\n}\n\n#ifndef WITHOUT_WINDOW_ANIMATORS\nstatic ret_t window_manager_default_snap_prev_window_draw_dialog_highlighter_and_get_alpha(\n    widget_t* widget, canvas_t* c, uint8_t* alpha) {\n  value_t v;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  if (widget_get_prop(widget, WIDGET_PROP_HIGHLIGHT, &v) == RET_OK) {\n    const char* args = value_str(&v);\n    if (args != NULL) {\n      dialog_highlighter_factory_t* f = dialog_highlighter_factory();\n      dialog_highlighter_t* dialog_highlighter =\n          dialog_highlighter_factory_create_highlighter(f, args, widget);\n\n      if (dialog_highlighter != NULL) {\n        dialog_highlighter_draw_mask(dialog_highlighter, c, 1.0f);\n        *alpha = dialog_highlighter_get_alpha(dialog_highlighter, 1.0f);\n        widget_off_by_func(widget, EVT_DESTROY, dialog_highlighter_on_dialog_destroy,\n                           dialog_highlighter);\n        dialog_highlighter_destroy(dialog_highlighter);\n        return RET_OK;\n      }\n    }\n  }\n  return RET_FAIL;\n}\n#endif\n\nret_t window_manager_default_snap_prev_window(widget_t* widget, widget_t* prev_win, bitmap_t* img) {\n#ifndef WITHOUT_WINDOW_ANIMATORS\n  rect_t r = {0};\n  canvas_t* c = NULL;\n  canvas_t* canvas = NULL;\n  window_manager_default_t* wm = WINDOW_MANAGER_DEFAULT(widget);\n  dialog_highlighter_t* dialog_highlighter = NULL;\n  int32_t end = -1, start = -1;\n  const char* curr_highlight = widget_get_prop_str(wm->curr_win, WIDGET_PROP_HIGHLIGHT, NULL);\n\n  return_value_if_fail(img != NULL && wm != NULL && prev_win != NULL, RET_BAD_PARAMS);\n\n  c = native_window_get_canvas(wm->native_window);\n  return_value_if_fail(c != NULL && c->lcd != NULL, RET_BAD_PARAMS);\n  dialog_highlighter = wm->dialog_highlighter;\n  window_manager_check_and_layout(widget);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN_R(widget, iter, i)\n  if (iter == prev_win) {\n    start = i;\n    end = widget->children->size - 2;\n    break;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\nr = ",
    "raw_res": "0;",
    "prompt_res": "rect_init(prev_win->x, prev_win->y, prev_win->w, prev_win->h);",
    "gt": "rect_init(prev_win->x, prev_win->y, prev_win->w, prev_win->h);"
  },
  {
    "id": 1268,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/window_animators/window_animator_fade.c",
    "input": "﻿/**\n * File:   window_animator_fade.c\n * Author: AWTK Develop Team\n * Brief:  fade window animator\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-04-22 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"window_animators/window_animator_fade.h\"\n\nstatic ret_t window_animator_fade_draw_curr(window_animator_t* wa) {\n  ret_t ret = RET_OK;\n  canvas_t* c = wa->canvas;\n  widget_t* win = wa->curr_win;\n\n  uint8_t global_alpha = wa->percent * 0xff;\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  rectf_t dst = rectf_init(win->x, win->y, win->w, win->h);\n  rectf_t src = rectf_init(win->x, win->y, win->w, win->h);\n  lcd_set_global_alpha(c->lcd, global_alpha);\n\n  ret = lcd_draw_image(c->lcd, &(wa->curr_img), rectf_scale(&src, wa->ratio), &dst);\n#else\n  lcd_set_global_alpha(c->lcd, global_alpha);\n\nret = ",
    "raw_res": "lcd_draw_image(c->lcd, win->surface, win->x, win->y, win->w, win->h);",
    "prompt_res": "widget_paint(win, c);",
    "gt": "widget_paint(win, c);"
  },
  {
    "id": 1272,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/window_animators/window_animator_vtranslate.c",
    "input": "﻿/**\n * File:   window_animator_vtranslate.c\n * Author: AWTK Develop Team\n * Brief:  vertical translate window animator\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-04-22 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"window_animators/window_animator_vtranslate.h\"\n\nstatic ret_t window_animator_vtranslate_update_percent(window_animator_t* wa) {\n  float_t percent = 0.2f + 0.8f * wa->easing(wa->time_percent);\n  if (wa->open) {\n    wa->percent = percent;\n  } else {\n    wa->percent = 1.0f - percent;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t window_animator_vtranslate_draw_prev(window_animator_t* wa) {\n  canvas_t* c = wa->canvas;\n  widget_t* win = wa->prev_win;\n  widget_t* curr_win = wa->curr_win;\n  float_t percent = wa->percent;\n  float_t y = tk_roundi(curr_win->h * percent);\n  float_t h = win->h - y;\n\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  rectf_t src = rectf_init(win->x, y + win->y, win->w, h);\nrectf_t dst = ",
    "raw_res": "rectf_init(curr_win->x, curr_win->y, curr_win->w, curr_win->h);",
    "prompt_res": "rectf_init(win->x, win->y, win->w, h);",
    "gt": "rectf_init(win->x, win->y, win->w, h);"
  },
  {
    "id": 1273,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/window_animators/window_animator_vtranslate.c",
    "input": "﻿/**\n * File:   window_animator_vtranslate.c\n * Author: AWTK Develop Team\n * Brief:  vertical translate window animator\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-04-22 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"window_animators/window_animator_vtranslate.h\"\n\nstatic ret_t window_animator_vtranslate_update_percent(window_animator_t* wa) {\n  float_t percent = 0.2f + 0.8f * wa->easing(wa->time_percent);\n  if (wa->open) {\n    wa->percent = percent;\n  } else {\n    wa->percent = 1.0f - percent;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t window_animator_vtranslate_draw_prev(window_animator_t* wa) {\n  canvas_t* c = wa->canvas;\n  widget_t* win = wa->prev_win;\n  widget_t* curr_win = wa->curr_win;\n  float_t percent = wa->percent;\n  float_t y = tk_roundi(curr_win->h * percent);\n  float_t h = win->h - y;\n\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  rectf_t src = rectf_init(win->x, y + win->y, win->w, h);\n  rectf_t dst = rectf_init(win->x, win->y, win->w, h);\n  return lcd_draw_image(c->lcd, &(wa->prev_img), rectf_scale(&src, wa->ratio), &dst);\n#else\n  canvas_translate(c, 0, -y);\n  widget_paint(win, c);\n  canvas_untranslate(c, 0, -y);\n  return RET_OK;\n#endif /*WITHOUT_WINDOW_ANIMATOR_CACHE*/\n}\n\nstatic ret_t window_animator_vtranslate_draw_curr(window_animator_t* wa) {\n  canvas_t* c = wa->canvas;\n  widget_t* win = wa->curr_win;\n  float_t percent = wa->percent;\n  float_t h = tk_roundi(win->h * percent);\n  float_t y = win->parent->h - h;\n\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  rectf_t src = rectf_init(win->x, win->y, win->w, h);\nrectf_t dst = ",
    "raw_res": "rectf_init(win->x, y + win->y, win->w, h);",
    "prompt_res": "rectf_init(win->x, y, win->w, h);",
    "gt": "rectf_init(win->x, y, win->w, h);"
  },
  {
    "id": 1278,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/window_animators/window_animator_common.c",
    "input": "﻿/**\n * File:   window_animator_common.c\n * Author: AWTK Develop Team\n * Brief:  window animator common used functions.\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-03-28 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#ifdef AWTK_WEB\n#include <emscripten.h>\n#endif /*AWTK_WEB*/\n\n#include \"base/window_manager.h\"\n#include \"base/window_animator.h\"\n#include \"base/dialog_highlighter_factory.h\"\n#include \"window_manager/window_manager_default.h\"\n#include \"window_animators/window_animator_common.h\"\n\nret_t window_animator_to_bottom_draw_curr(window_animator_t* wa) {\n  canvas_t* c = wa->canvas;\n  widget_t* win = wa->curr_win;\n  float_t percent = wa->percent;\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  int32_t y = win->y;\n  int32_t h = tk_roundi(win->h * percent);\n\n  rectf_t src = rectf_init(win->x, win->y + win->h - h, win->w, h);\nrectf_t dst = ",
    "raw_res": "rectf_init(win->x, y + win->h, win->w, h);",
    "prompt_res": "rectf_init(win->x, y, win->w, h);",
    "gt": "rectf_init(win->x, y, win->w, h);"
  },
  {
    "id": 1282,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/window_animators/window_animator_common.c",
    "input": "﻿/**\n * File:   window_animator_common.c\n * Author: AWTK Develop Team\n * Brief:  window animator common used functions.\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-03-28 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#ifdef AWTK_WEB\n#include <emscripten.h>\n#endif /*AWTK_WEB*/\n\n#include \"base/window_manager.h\"\n#include \"base/window_animator.h\"\n#include \"base/dialog_highlighter_factory.h\"\n#include \"window_manager/window_manager_default.h\"\n#include \"window_animators/window_animator_common.h\"\n\nret_t window_animator_to_bottom_draw_curr(window_animator_t* wa) {\n  canvas_t* c = wa->canvas;\n  widget_t* win = wa->curr_win;\n  float_t percent = wa->percent;\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  int32_t y = win->y;\n  int32_t h = tk_roundi(win->h * percent);\n\n  rectf_t src = rectf_init(win->x, win->y + win->h - h, win->w, h);\n  rectf_t dst = rectf_init(win->x, y, win->w, h);\n\n  if (h == 0) {\n    return RET_OK;\n  }\n\n  return lcd_draw_image(c->lcd, &(wa->curr_img), rectf_scale(&src, wa->ratio), &dst);\n#else\n  int32_t y = -win->h * (1 - percent);\n  canvas_translate(c, 0, y);\n  widget_paint(win, c);\n  canvas_untranslate(c, 0, y);\n  return RET_OK;\n#endif /*WITHOUT_WINDOW_ANIMATOR_CACHE*/\n}\n\nret_t window_animator_to_top_draw_curr(window_animator_t* wa) {\n  canvas_t* c = wa->canvas;\n  widget_t* win = wa->curr_win;\n  float_t percent = wa->percent;\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  int32_t y = win->y + tk_roundi(win->h * (1 - percent));\n  int32_t h = win->y + win->h - y;\n\n  rectf_t src = rectf_init(win->x, win->y, win->w, h);\n  rectf_t dst = rectf_init(win->x, y, win->w, h);\n\n  if (h == 0) {\n    return RET_OK;\n  }\n\n  return lcd_draw_image(c->lcd, &(wa->curr_img), rectf_scale(&src, wa->ratio), &dst);\n#else\n  int32_t y = win->h * (1 - percent);\n  canvas_translate(c, 0, y);\n  widget_paint(win, c);\n  canvas_untranslate(c, 0, y);\n  return RET_OK;\n#endif /*WITHOUT_WINDOW_ANIMATOR_CACHE*/\n}\n\nret_t window_animator_to_left_draw_curr(window_animator_t* wa) {\n  canvas_t* c = wa->canvas;\n  widget_t* win = wa->curr_win;\n  float_t percent = wa->percent;\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  int32_t x = win->x + tk_roundi(win->w * (1 - percent));\n  int32_t w = win->x + win->w - x;\n\n  rectf_t src = rectf_init(win->x, win->y, w, win->h);\n  rectf_t dst = rectf_init(x, win->y, w, win->h);\n\n  if (w == 0) {\n    return RET_OK;\n  }\n\n  return lcd_draw_image(c->lcd, &(wa->curr_img), rectf_scale(&src, wa->ratio), &dst);\n#else\n  int32_t x = -win->w * (1 - percent);\n\n  canvas_translate(c, x, 0);\n  widget_paint(win, c);\n  canvas_untranslate(c, x, 0);\n  return RET_OK;\n#endif /*WITHOUT_WINDOW_ANIMATOR_CACHE*/\n}\n\nret_t window_animator_to_right_draw_curr(window_animator_t* wa) {\n  canvas_t* c = wa->canvas;\n  widget_t* win = wa->curr_win;\n  float_t percent = wa->percent;\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  int32_t x = win->x;\n  int32_t w = tk_roundi(win->w * percent);\nrectf_t src = ",
    "raw_res": "rectf_init(win->x, win->y, w, win->h);",
    "prompt_res": "rectf_init(win->x + win->w - w, win->y, w, win->h);",
    "gt": "rectf_init(win->x + win->w - w, win->y, w, win->h);"
  },
  {
    "id": 1289,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/window_animators/window_animator_center_scale.c",
    "input": "﻿/**\n * File:   window_animator_center_scale.c\n * Author: AWTK Develop Team\n * Brief:  center_scale window animator\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-04-22 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"window_animators/window_animator_center_scale.h\"\n\n#ifdef WITH_GPU\n#define START_PERCENT 0.5f\n#else\n#define START_PERCENT 0.9f\n#endif\n\nstatic ret_t window_animator_center_scale_update_percent(window_animator_t* wa) {\n  if (wa->open) {\n    wa->percent = START_PERCENT + (1 - START_PERCENT) * wa->easing(wa->time_percent);\n    if (wa->easing(wa->time_percent) == 0) {\n      wa->percent = 0;\n    }\n  } else {\n    wa->percent = 1.0f - (1 - START_PERCENT) * wa->easing(wa->time_percent);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t window_animator_center_scale_draw_curr(window_animator_t* wa) {\n  canvas_t* c = wa->canvas;\n  widget_t* win = wa->curr_win;\n  float_t scale = wa->percent;\n\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  ret_t ret = RET_OK;\nrectf_t src = ",
    "raw_res": "0;",
    "prompt_res": "rectf_init(win->x, win->y, win->w, win->h);",
    "gt": "rectf_init(win->x, win->y, win->w, win->h);"
  },
  {
    "id": 1296,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/dialog_highlighters/dialog_highlighter_builtins.c",
    "input": "﻿/**\n * File:   dialog_highlighter_builts.h\n * Author: AWTK Develop Team\n * Brief:  builts dialog_highlighter\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied highlighterrranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-03-27 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"base/dialog_highlighter_factory.h\"\n#include \"dialog_highlighters/dialog_highlighter_builtins.h\"\n#include \"dialog_highlighters/dialog_highlighter_default.h\"\n\nret_t dialog_highlighter_register_builtins(void) {\ndialog_highlighter_factory_t* f = ",
    "raw_res": "dialog_highlighter_factory_get();",
    "prompt_res": "dialog_highlighter_factory();",
    "gt": "dialog_highlighter_factory();"
  },
  {
    "id": 1417,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/ext_widgets/combo_box_ex/combo_box_ex.c",
    "input": "﻿/**\n * File:   combo_box_ex.c\n * Author: AWTK Develop Team\n * Brief:  combo_box_ex\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-08-21 Li DaHeng <linany1990@163.com> created\n *\n */\n\n#include \"base/layout.h\"\n#include \"widgets/popup.h\"\n#include \"widgets/combo_box_item.h\"\n#include \"ext_widgets/scroll_view/list_view.h\"\n#include \"ext_widgets/scroll_view/scroll_view.h\"\n#include \"ext_widgets/scroll_view/scroll_bar.h\"\n#include \"ext_widgets/combo_box_ex/combo_box_ex.h\"\n\n#define COMBO_BOX_EX_DEFAULT_MAXNR 5\n#define COMBO_BOX_EX_DEFAULT_MARGIN 1\n\nstatic ret_t combo_box_ex_create_popup_items(combo_box_t* combo_box, widget_t* parent) {\n  combo_box_option_t* iter = NULL;\n  return_value_if_fail(combo_box != NULL, RET_BAD_PARAMS);\n\n  iter = combo_box->option_items;\n  while (iter != NULL) {\n    widget_t* item = combo_box_item_create(parent, 0, 0, 0, 0);\n\n    widget_set_value(item, iter->value);\n    if (combo_box->localize_options) {\n      widget_set_tr_text(item, iter->text);\n    } else {\n      widget_set_text_utf8(item, iter->text);\n    }\n\n    iter = iter->next;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t combo_box_ex_on_layout_children_for_combobox_popup(widget_t* widget) {\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  return_value_if_fail(combo_box != NULL, RET_BAD_PARAMS);\n\n  if (combo_box->combobox_popup != NULL && combo_box->open_window == NULL) {\n    point_t p = {0, 0};\n    int32_t margin = COMBO_BOX_EX_DEFAULT_MARGIN;\n    int32_t item_height = combo_box->item_height;\n    int32_t nr = combo_box_count_options(widget);\n    int32_t h = nr * item_height + 2 * margin;\n    if (nr <= COMBO_BOX_EX_DEFAULT_MAXNR) {\n      h = nr * item_height + 2 * margin;\n    } else {\n      h = COMBO_BOX_EX_DEFAULT_MAXNR * item_height + 2 * margin;\n    }\n\n    combo_box_combobox_popup_calc_position(widget, h, &p);\n    widget_move_resize(combo_box->combobox_popup, p.x, p.y, widget->w, h);\n  }\n  return RET_OK;\n}\n\nstatic widget_t* combo_box_ex_create_scroll_popup(combo_box_t* combo_box) {\n  value_t v;\n  widget_t* win = NULL;\n  widget_t* list_view = NULL;\n  widget_t* scroll_view = NULL;\n  widget_t* scroll_bar = NULL;\n  widget_t* widget = WIDGET(combo_box);\n  int32_t margin = COMBO_BOX_EX_DEFAULT_MARGIN;\n  int32_t item_height = combo_box->item_height;\n  int32_t nr = combo_box_count_options(widget);\n  int32_t w = widget->w;\n  int32_t h = nr * item_height + 2 * margin;\n  if (nr <= COMBO_BOX_EX_DEFAULT_MAXNR) {\n    h = nr * item_height + 2 * margin;\n  } else {\n    h = COMBO_BOX_EX_DEFAULT_MAXNR * item_height + 2 * margin;\n  }\n\n  // create popup\nwin = ",
    "raw_res": "popup_create(widget->parent, widget->x, widget->y, w, h, 0);",
    "prompt_res": "popup_create(NULL, 0, 0, w, h);",
    "gt": "popup_create(NULL, 0, 0, w, h);"
  },
  {
    "id": 1456,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/ext_widgets/rich_text/rich_text_render_node.c",
    "input": "﻿/**\n * File:   rich_text_render_node.c\n * Author: AWTK Develop Team\n * Brief:  rich_text_render_node\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is dirich_text_render_nodeibuted in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-07-28 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"base/line_break.h\"\n#include \"base/image_manager.h\"\n#include \"rich_text/rich_text.h\"\n#include \"rich_text/rich_text_render_node.h\"\n\n#define ICON_SIZE 128\n\nrich_text_render_node_t* rich_text_render_node_create(rich_text_node_t* node) {\n  rich_text_render_node_t* render_node = NULL;\n  return_value_if_fail(node != NULL, NULL);\n\n  render_node = TKMEM_ZALLOC(rich_text_render_node_t);\n  return_value_if_fail(render_node != NULL, NULL);\n\n  render_node->node = node;\n\n  return render_node;\n}\n\nstatic const wchar_t* s_flexable_w_chars = L\" ,.?!;:>}]　，。？！；：》｝】』\";\n\nbool_t rich_text_is_flexable_w_char(wchar_t c) {\n  return wcschr(s_flexable_w_chars, c) != NULL;\n}\n\nret_t rich_text_render_node_tune_row(rich_text_render_node_t* row_first_node, int32_t row_h,\n                                     int32_t flexible_w, int32_t client_w) {\n  int32_t dx = 0;\n  int32_t flexible_w_chars = 0;\n  int32_t flexible_w_chars_w = 0;\n  int32_t align_h_w = flexible_w > 0 ? 0 : client_w;\n  rich_text_render_node_t* iter = row_first_node;\n\n  while (iter != NULL) {\n    if (flexible_w > 0) {\n      if (iter->node->type == RICH_TEXT_TEXT) {\n        int32_t i = 0;\n        for (i = 0; i < iter->size; i++) {\n          if (rich_text_is_flexable_w_char(iter->text[i])) {\n            iter->flexible_w_chars++;\n            flexible_w_chars++;\n          }\n        }\n      }\n    } else {\n      align_h_w -= iter->rect.w;\n    }\n\n    iter = iter->next;\n  }\n\n  if (flexible_w_chars > 0) {\n    flexible_w_chars_w = tk_max(1, (flexible_w / flexible_w_chars));\n  } else {\n    flexible_w_chars_w = 0;\n  }\n\n  iter = row_first_node;\n  while (iter != NULL) {\n    iter->align_h_w = align_h_w;\n    iter->rect.h = row_h;\n    iter->rect.x += dx;\n\n    switch (iter->node->type) {\n      case RICH_TEXT_TEXT: {\n        if (flexible_w > 0) {\n          int32_t spacing = iter->flexible_w_chars * flexible_w_chars_w;\n          iter->spacing = tk_min(spacing, flexible_w);\n          iter->flexible_w_char_delta_w = flexible_w_chars_w;\n\n          flexible_w -= iter->spacing;\n          dx += iter->spacing;\n        }\n        break;\n      }\n      case RICH_TEXT_IMAGE: {\n        break;\n      }\n      default:\n        break;\n    }\n\n    iter = iter->next;\n  }\n\n  return RET_OK;\n}\n\n#define MOVE_TO_NEXT_ROW()                                                       \\\n  x = margin;                                                                    \\\n  y += row_h + line_gap;                                                         \\\n  if (row_first_node != NULL) {                                                  \\\n    rich_text_render_node_tune_row(row_first_node, row_h, flexible_w, client_w); \\\n    row_first_node = NULL;                                                       \\\n  }                                                                              \\\n  row_h = 0;\n\nbreak_type_t rich_text_line_break_check(wchar_t c1, wchar_t c2) {\n  break_type_t break_type = line_break_check(c1, c2);\n  if (break_type == LINE_BREAK_NO) {\n    break_type = word_break_check(c1, c2);\n  }\n\n  return break_type;\n}\n\nrich_text_render_node_t* rich_text_render_node_layout(widget_t* widget, rich_text_node_t* node,\n                                                      canvas_t* c, int32_t w, int32_t h,\n                                                      int32_t margin, int32_t line_gap) {\n  int32_t row_h = 0;\n  int32_t x = margin;\n  int32_t y = margin;\n  int32_t right = w - margin;\n  int32_t client_w = w - 2 * margin;\n  int32_t client_h = h - 2 * margin;\n  rich_text_node_t* iter = node;\n  rich_text_t* rich_text = RICH_TEXT(widget);\n  rich_text_render_node_t* new_node = NULL;\n  rich_text_render_node_t* render_node = NULL;\n  rich_text_render_node_t* row_first_node = NULL;\n  return_value_if_fail(node != NULL && c != NULL && client_w > 0 && client_h > 0, NULL);\n\n  while (iter != NULL) {\n    switch (iter->type) {\n      case RICH_TEXT_IMAGE: {\n        bitmap_t bitmap;\n        int32_t flexible_w = 0;\n        rich_text_image_t* image = &(iter->u.image);\n        const char* name = image->name;\nnew_node = ",
    "raw_res": "0;",
    "prompt_res": "rich_text_render_node_create(iter);",
    "gt": "rich_text_render_node_create(iter);"
  },
  {
    "id": 1473,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/ext_widgets/vpage/vpage.c",
    "input": "﻿/**\n * File:   vpage.c\n * Author: AWTK Develop Team\n * Brief:  虚拟页面(根据情况自动加载/卸载页面)。\n *\n * Copyright (c) 2021 - 2021 Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2021-06-09 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"base/ui_loader.h\"\n#include \"base/window_manager.h\"\n#include \"ui_loader/ui_serializer.h\"\n#include \"widget_animators/widget_animator_prop.h\"\n\n#include \"vpage.h\"\n\n#define PROP_VPAGE_ANIMATOR \"vpage_animator\"\n\nstatic ret_t vpage_on_leave_animation_done(void* ctx, event_t* e);\n\nret_t vpage_set_ui_asset(widget_t* widget, const char* ui_asset) {\n  vpage_t* vpage = VPAGE(widget);\n  return_value_if_fail(vpage != NULL, RET_BAD_PARAMS);\n\n  vpage->ui_asset = tk_str_copy(vpage->ui_asset, ui_asset);\n\n  return RET_OK;\n}\n\nret_t vpage_set_anim_hint(widget_t* widget, const char* anim_hint) {\n  vpage_t* vpage = VPAGE(widget);\n  return_value_if_fail(vpage != NULL, RET_BAD_PARAMS);\n\n  vpage->anim_hint = tk_str_copy(vpage->anim_hint, anim_hint);\n\n  return RET_OK;\n}\n\nstatic ret_t vpage_get_prop(widget_t* widget, const char* name, value_t* v) {\n  vpage_t* vpage = VPAGE(widget);\n  return_value_if_fail(vpage != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(VPAGE_PROP_UI_ASSET, name)) {\n    value_set_str(v, vpage->ui_asset);\n    return RET_OK;\n  } else if (tk_str_eq(WIDGET_PROP_ANIM_HINT, name)) {\n    value_set_str(v, vpage->anim_hint);\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t vpage_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(VPAGE_PROP_UI_ASSET, name)) {\n    vpage_set_ui_asset(widget, value_str(v));\n    return RET_OK;\n  } else if (tk_str_eq(WIDGET_PROP_ANIM_HINT, name)) {\n    vpage_set_anim_hint(widget, value_str(v));\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t vpage_on_destroy(widget_t* widget) {\n  vpage_t* vpage = VPAGE(widget);\n  return_value_if_fail(widget != NULL && vpage != NULL, RET_BAD_PARAMS);\n\n  TKMEM_FREE(vpage->ui_asset);\n  TKMEM_FREE(vpage->anim_hint);\n\n  return RET_OK;\n}\n\nstatic ret_t vpage_dispatch_event(widget_t* widget, int32_t etype) {\n  event_t e = event_init(etype, widget);\n\n  return widget_dispatch_async(widget, &e);\n}\n\nstatic ret_t vpage_on_enter_done(widget_t* widget) {\n  vpage_dispatch_event(widget, EVT_VPAGE_OPEN);\n  return RET_OK;\n}\n\nstatic ret_t vpage_on_enter_animation_done(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  widget_set_prop_pointer(widget, PROP_VPAGE_ANIMATOR, NULL);\n  return vpage_on_enter_done(widget);\n}\n\nstatic ret_t vpage_on_enter(widget_t* widget, uint32_t index, uint32_t old_index) {\n  uint32_t nr = 0;\n  bool_t can_animate = 0;\n  vpage_t* vpage = VPAGE(widget);\n  widget_animator_t* am = NULL;\n  return_value_if_fail(vpage != NULL, RET_BAD_PARAMS);\n\n  nr = widget_count_children(widget->parent);\n  can_animate = old_index < nr && widget_is_window_opened(widget);\n\n  if (vpage->anim_hint != NULL && can_animate) {\n    if (tk_str_eq(vpage->anim_hint, \"htranslate\")) {\n      am = widget_animator_prop_create(widget, TK_ANIMATING_TIME, 0, EASING_SIN_INOUT, \"x\");\n      if (old_index < index) {\n        widget_animator_prop_set_params(am, widget->w, 0);\n      } else {\n        widget_animator_prop_set_params(am, -widget->w, 0);\n      }\n    } else {\nam = ",
    "raw_res": "0;",
    "prompt_res": "widget_animator_prop_create(widget, TK_ANIMATING_TIME, 0, EASING_SIN_INOUT, \"y\");",
    "gt": "widget_animator_prop_create(widget, TK_ANIMATING_TIME, 0, EASING_SIN_INOUT, \"y\");"
  },
  {
    "id": 1560,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/ext_widgets/scroll_label/hscroll_label.c",
    "input": "﻿/**\n * File:   hscroll_label.h\n * Author: AWTK Develop Team\n * Brief:  hscroll_label\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-07-05 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/time_now.h\"\n#include \"base/widget_vtable.h\"\n#include \"scroll_label/hscroll_label.h\"\n\nstatic ret_t hscroll_label_remove_timer(widget_t* widget);\nstatic ret_t hscroll_label_check_and_start(widget_t* widget);\n\nstatic bool_t hscroll_label_is_running(widget_t* widget) {\n  hscroll_label_t* hscroll_label = HSCROLL_LABEL(widget);\n  return_value_if_fail(hscroll_label != NULL, RET_BAD_PARAMS);\n\n  return hscroll_label->timer_id != TK_INVALID_ID;\n}\n\nstatic ret_t hscroll_label_do_paint_self(widget_t* widget, canvas_t* c, uint32_t left_margin,\n                                         uint32_t right_margin) {\n  rect_t r = {0, 0, 0, 0};\n  wstr_t* text = &(widget->text);\n  uint32_t w = widget->w - left_margin - right_margin;\n  hscroll_label_t* hscroll_label = HSCROLL_LABEL(widget);\n\n  hscroll_label->text_w = canvas_measure_text(c, text->str, text->size);\n  if (hscroll_label->text_w != hscroll_label->old_text_w) {\n    if (tk_str_eq(widget->state, WIDGET_STATE_FOCUSED)) {\n      hscroll_label_start(widget);\n    } else {\n      hscroll_label_check_and_start(widget);\n    }\n    hscroll_label->old_text_w = hscroll_label->text_w;\n  }\n  if (w < hscroll_label->text_w && hscroll_label->ellipses && !hscroll_label->yoyo &&\n      !hscroll_label_is_running(widget)) {\n    r = rect_init(left_margin, 0, w, widget->h);\n\n    return widget_draw_text_in_rect(widget, c, text->str, text->size, &r, TRUE);\n  }\n\n  if (w > hscroll_label->text_w) {\n    int32_t align_v = style_get_int(widget->astyle, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    int32_t align_h = style_get_int(widget->astyle, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_LEFT);\n    canvas_set_text_align(c, (align_h_t)align_h, (align_v_t)align_v);\n  } else {\n    canvas_set_text_align(c, ALIGN_H_LEFT, ALIGN_V_MIDDLE);\n  }\n\n  r = rect_init(left_margin - hscroll_label->xoffset, 0, w, widget->h);\n  return widget_draw_text_in_rect(widget, c, text->str, text->size, &r, FALSE);\n}\n\nstatic ret_t hscroll_label_on_paint_self(widget_t* widget, canvas_t* c) {\n  point_t p = {0, 0};\n  rect_t save_r = {0, 0, 0, 0};\n  rect_t clip_r = {0, 0, 0, 0};\n  rect_t edit_r = {0, 0, 0, 0};\n\n  if (widget->text.size > 0) {\n    style_t* style = widget->astyle;\n    color_t black = color_init(0, 0, 0, 0xff);\n    const char* font = style_get_str(style, STYLE_ID_FONT_NAME, NULL);\n    int32_t left_margin = style_get_int(style, STYLE_ID_MARGIN_LEFT, 2);\n    int32_t right_margin = style_get_int(style, STYLE_ID_MARGIN_RIGHT, 2);\n    int32_t font_size = style_get_int(style, STYLE_ID_FONT_SIZE, TK_DEFAULT_FONT_SIZE);\n    color_t text_color = style_get_color(style, STYLE_ID_TEXT_COLOR, black);\n    int32_t w = widget->w - left_margin - right_margin;\n\n    canvas_get_clip_rect(c, &save_r);\n    widget_to_screen(widget, &p);\n\nedit_r = ",
    "raw_res": "rect_init(p.x, p.y, w, widget->h);",
    "prompt_res": "rect_init(p.x + left_margin, p.y, w, widget->h);",
    "gt": "rect_init(p.x + left_margin, p.y, w, widget->h);"
  },
  {
    "id": 1561,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/ext_widgets/scroll_label/hscroll_label.c",
    "input": "﻿/**\n * File:   hscroll_label.h\n * Author: AWTK Develop Team\n * Brief:  hscroll_label\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-07-05 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/time_now.h\"\n#include \"base/widget_vtable.h\"\n#include \"scroll_label/hscroll_label.h\"\n\nstatic ret_t hscroll_label_remove_timer(widget_t* widget);\nstatic ret_t hscroll_label_check_and_start(widget_t* widget);\n\nstatic bool_t hscroll_label_is_running(widget_t* widget) {\n  hscroll_label_t* hscroll_label = HSCROLL_LABEL(widget);\n  return_value_if_fail(hscroll_label != NULL, RET_BAD_PARAMS);\n\n  return hscroll_label->timer_id != TK_INVALID_ID;\n}\n\nstatic ret_t hscroll_label_do_paint_self(widget_t* widget, canvas_t* c, uint32_t left_margin,\n                                         uint32_t right_margin) {\n  rect_t r = {0, 0, 0, 0};\n  wstr_t* text = &(widget->text);\n  uint32_t w = widget->w - left_margin - right_margin;\n  hscroll_label_t* hscroll_label = HSCROLL_LABEL(widget);\n\n  hscroll_label->text_w = canvas_measure_text(c, text->str, text->size);\n  if (hscroll_label->text_w != hscroll_label->old_text_w) {\n    if (tk_str_eq(widget->state, WIDGET_STATE_FOCUSED)) {\n      hscroll_label_start(widget);\n    } else {\n      hscroll_label_check_and_start(widget);\n    }\n    hscroll_label->old_text_w = hscroll_label->text_w;\n  }\n  if (w < hscroll_label->text_w && hscroll_label->ellipses && !hscroll_label->yoyo &&\n      !hscroll_label_is_running(widget)) {\n    r = rect_init(left_margin, 0, w, widget->h);\n\n    return widget_draw_text_in_rect(widget, c, text->str, text->size, &r, TRUE);\n  }\n\n  if (w > hscroll_label->text_w) {\n    int32_t align_v = style_get_int(widget->astyle, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    int32_t align_h = style_get_int(widget->astyle, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_LEFT);\n    canvas_set_text_align(c, (align_h_t)align_h, (align_v_t)align_v);\n  } else {\n    canvas_set_text_align(c, ALIGN_H_LEFT, ALIGN_V_MIDDLE);\n  }\n\n  r = rect_init(left_margin - hscroll_label->xoffset, 0, w, widget->h);\n  return widget_draw_text_in_rect(widget, c, text->str, text->size, &r, FALSE);\n}\n\nstatic ret_t hscroll_label_on_paint_self(widget_t* widget, canvas_t* c) {\n  point_t p = {0, 0};\n  rect_t save_r = {0, 0, 0, 0};\n  rect_t clip_r = {0, 0, 0, 0};\n  rect_t edit_r = {0, 0, 0, 0};\n\n  if (widget->text.size > 0) {\n    style_t* style = widget->astyle;\n    color_t black = color_init(0, 0, 0, 0xff);\n    const char* font = style_get_str(style, STYLE_ID_FONT_NAME, NULL);\n    int32_t left_margin = style_get_int(style, STYLE_ID_MARGIN_LEFT, 2);\n    int32_t right_margin = style_get_int(style, STYLE_ID_MARGIN_RIGHT, 2);\n    int32_t font_size = style_get_int(style, STYLE_ID_FONT_SIZE, TK_DEFAULT_FONT_SIZE);\n    color_t text_color = style_get_color(style, STYLE_ID_TEXT_COLOR, black);\n    int32_t w = widget->w - left_margin - right_margin;\n\n    canvas_get_clip_rect(c, &save_r);\n    widget_to_screen(widget, &p);\n\n    edit_r = rect_init(p.x + left_margin, p.y, w, widget->h);\n\nclip_r = ",
    "raw_res": "rect_init(p.x + left_margin, p.y, w, widget->h);",
    "prompt_res": "rect_intersect(&save_r, &edit_r);",
    "gt": "rect_intersect(&save_r, &edit_r);"
  },
  {
    "id": 1631,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/ext_widgets/text_selector/text_selector.c",
    "input": "﻿/**\n * File:   text_selector.h\n * Author: AWTK Develop Team\n * Brief:  text_selector\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-09-25 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/easing.h\"\n#include \"widgets/button.h\"\n#include \"base/layout.h\"\n#include \"widgets/popup.h\"\n#include \"base/window.h\"\n#include \"tkc/tokenizer.h\"\n#include \"text_selector/text_selector.h\"\n#include \"base/widget_animator_manager.h\"\n#include \"widget_animators/widget_animator_scroll.h\"\n\n#define TEXT_SELECTOR_WA_NAME \"text_selector@wa\"\n\nstatic const wchar_t* text_selector_get_wtext(widget_t* widget);\nstatic ret_t text_selector_set_all_options_localize_text(widget_t* widget);\nstatic ret_t text_selector_scroll_to(widget_t* widget, int32_t yoffset_end);\nstatic ret_t text_selector_sync_yoffset_with_selected_index(text_selector_t* text_selector,\n                                                            bool_t is_anim);\n\nconst char* s_text_selector_properties[] = {WIDGET_PROP_TEXT,\n                                            WIDGET_PROP_VALUE,\n                                            WIDGET_PROP_OPTIONS,\n                                            TEXT_SELECTOR_PROP_VISIBLE_NR,\n                                            WIDGET_PROP_SELECTED_INDEX,\n                                            WIDGET_PROP_LOCALIZE_OPTIONS,\n                                            TEXT_SELECTOR_PROP_Y_SPEED_SCALE,\n                                            TEXT_SELECTOR_PROP_LOOP_OPTIONS,\n                                            TEXT_SELECTOR_PROP_ANIMATION_TIME,\n                                            NULL};\n\nstatic ret_t text_selector_paint_mask(widget_t* widget, canvas_t* c) {\n  int32_t i = 0;\n  int32_t y = 0;\n  int32_t n = widget->h / 2;\n  style_t* style = widget->astyle;\n  color_t trans = color_init(0, 0, 0, 0);\n  easing_func_t easing = easing_get(EASING_CUBIC_IN);\n  color_t fc = style_get_color(style, STYLE_ID_FG_COLOR, trans);\n  const char* fg_image = style_get_str(style, STYLE_ID_FG_IMAGE, NULL);\n  color_t mask_color = style_get_color(style, STYLE_ID_MASK_COLOR, trans);\n\n  text_selector_t* text_selector = TEXT_SELECTOR(widget);\n  int32_t visible_nr = text_selector->visible_nr;\n  int32_t item_height = text_selector->draw_widget_h / visible_nr;\n\n  if (fc.rgba.a) {\n    canvas_set_stroke_color(c, fc);\n    for (i = 1; i < visible_nr; i++) {\n      y = i * item_height;\n      canvas_draw_hline(c, 0, y, widget->w);\n    }\n  }\n\n  if (mask_color.rgba.a) {\n    for (i = 0; i < n; i++) {\n      y = n - i - 1;\n\n      mask_color.rgba.a = 0xff * easing((float_t)i / (float_t)n);\n      canvas_set_stroke_color(c, mask_color);\n      canvas_draw_hline(c, 0, y, widget->w);\n    }\n\n    for (i = 0; i < n; i++) {\n      y = widget->h - n + i;\n\n      mask_color.rgba.a = 0xff * easing((float_t)i / (float_t)n);\n      canvas_set_stroke_color(c, mask_color);\n      canvas_draw_hline(c, 0, y, widget->w);\n    }\n  }\n\n  if (fg_image != NULL && *fg_image) {\n    bitmap_t img;\n    rect_t r = rect_init(0, 0, widget->w, widget->h);\n    if (widget_load_image(widget, fg_image, &img) == RET_OK) {\n      image_draw_type_t draw_type =\n          (image_draw_type_t)style_get_int(style, STYLE_ID_FG_IMAGE_DRAW_TYPE, IMAGE_DRAW_CENTER);\n      canvas_draw_image_ex(c, &img, draw_type, (const rect_t*)&r);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic int32_t text_selector_range_yoffset(int32_t value, int32_t min_yoffset, int32_t max_yoffset,\n                                           int32_t item_height, int32_t empty_item_height,\n                                           bool_t loop_options) {\n  if (value < min_yoffset) {\n    int32_t tmp = max_yoffset + empty_item_height + item_height;\n    if (loop_options && tmp != 0) {\n      int32_t n = tk_abs(value / tmp) + 1;\n      value = value + tmp * n;\n    } else {\n      value = min_yoffset;\n    }\n  } else if (value > max_yoffset) {\n    int32_t tmp = max_yoffset + empty_item_height + item_height;\n    if (loop_options && tmp != 0) {\n      value = value % tmp;\n    } else {\n      value = max_yoffset;\n    }\n  }\n  return value;\n}\n\nstatic ret_t text_selector_prepare_highlight_style(widget_t* widget, canvas_t* c, float_t d,\n                                                   bool_t set_color) {\n  style_t* style = widget->astyle;\n  color_t trans = color_init(0, 0, 0, 0);\ncolor_t tc = ",
    "raw_res": "0;",
    "prompt_res": "style_get_color(style, STYLE_ID_TEXT_COLOR, trans);",
    "gt": "style_get_color(style, STYLE_ID_TEXT_COLOR, trans);"
  },
  {
    "id": 1685,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/ext_widgets/file_browser/file_browser_view.c",
    "input": "﻿/**\n * File:   file_browser_view.c\n * Author: AWTK Develop Team\n * Brief:  file manager/browser/choosor\n *\n * Copyright (c) 2020 - 2021 Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2020-01-08 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"file_browser_view.h\"\n#include \"base/date_time_format.h\"\n\n#define SORT_BY_NAME \"name\"\n#define SORT_BY_TYPE \"type\"\n#define SORT_BY_SIZE \"size\"\n#define SORT_BY_MTIME \"mtime\"\n\n#ifndef FB_DATE_TIME_FORMAT\n#define FB_DATE_TIME_FORMAT \"YY-MM-DD hh:mm:ss\"\n#endif /*FB_DATE_TIME_FORMAT*/\n\nret_t file_browser_view_reload(widget_t* widget);\n\nret_t file_browser_view_set_top_dir(widget_t* widget, const char* top_dir) {\n  file_browser_view_t* file_browser_view = FILE_BROWSER_VIEW(widget);\n  return_value_if_fail(file_browser_view != NULL, RET_BAD_PARAMS);\n\n  file_browser_view->top_dir = tk_str_copy(file_browser_view->top_dir, top_dir);\n  file_browser_set_top_dir(file_browser_view->fb, top_dir);\n\n  return RET_OK;\n}\n\nret_t file_browser_view_set_init_dir(widget_t* widget, const char* init_dir) {\n  file_browser_view_t* file_browser_view = FILE_BROWSER_VIEW(widget);\n  return_value_if_fail(file_browser_view != NULL, RET_BAD_PARAMS);\n\n  file_browser_view->init_dir = tk_str_copy(file_browser_view->init_dir, init_dir);\n  file_browser_set_cwd(file_browser_view->fb, init_dir);\n\n  return RET_OK;\n}\n\nret_t file_browser_view_set_filter(widget_t* widget, const char* filter) {\n  file_browser_view_t* file_browser_view = FILE_BROWSER_VIEW(widget);\n  return_value_if_fail(file_browser_view != NULL && filter != NULL, RET_BAD_PARAMS);\n\n  file_browser_view->filter = tk_str_copy(file_browser_view->filter, filter);\n\n  if (tk_str_eq(filter, STR_FILTER_FILES_ONLY)) {\n    file_browser_set_filter(file_browser_view->fb, fb_filter_files_only, NULL);\n  } else if (tk_str_eq(filter, STR_FILTER_DIR_ONLY)) {\n    file_browser_set_filter(file_browser_view->fb, fb_filter_directories_only, NULL);\n  } else if (filter != NULL) {\n    file_browser_set_filter(file_browser_view->fb, fb_filter_by_ext_names,\n                            file_browser_view->filter);\n  } else {\n    file_browser_set_filter(file_browser_view->fb, NULL, NULL);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t file_browser_view_sync_sort(widget_t* widget) {\n  const char* sort_by = NULL;\n  bool_t sort_ascending = FALSE;\n  file_browser_view_t* file_browser_view = FILE_BROWSER_VIEW(widget);\n  return_value_if_fail(file_browser_view != NULL, RET_BAD_PARAMS);\n  sort_by = file_browser_view->sort_by;\n  sort_ascending = file_browser_view->sort_ascending;\n\n  if (sort_by != NULL) {\n    if (tk_str_eq(sort_by, SORT_BY_NAME)) {\n      file_browser_sort_by_name(file_browser_view->fb, sort_ascending);\n    } else if (tk_str_eq(sort_by, SORT_BY_SIZE)) {\n      file_browser_sort_by_name(file_browser_view->fb, sort_ascending);\n    } else if (tk_str_eq(sort_by, SORT_BY_MTIME)) {\n      file_browser_sort_by_mtime(file_browser_view->fb, sort_ascending);\n    } else if (tk_str_eq(sort_by, SORT_BY_TYPE)) {\n      file_browser_sort_by_type(file_browser_view->fb, sort_ascending);\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t file_browser_view_set_ignore_hidden_files(widget_t* widget, bool_t ignore_hidden_files) {\n  file_browser_view_t* file_browser_view = FILE_BROWSER_VIEW(widget);\n  return_value_if_fail(file_browser_view != NULL, RET_BAD_PARAMS);\n\n  file_browser_view->ignore_hidden_files = ignore_hidden_files;\n  file_browser_set_ignore_hidden_files(file_browser_view->fb, ignore_hidden_files);\n\n  return RET_OK;\n}\n\nret_t file_browser_view_set_sort_ascending(widget_t* widget, bool_t sort_ascending) {\n  file_browser_view_t* file_browser_view = FILE_BROWSER_VIEW(widget);\n  return_value_if_fail(file_browser_view != NULL, RET_BAD_PARAMS);\n\n  file_browser_view->sort_ascending = sort_ascending;\n  file_browser_view_sync_sort(widget);\n\n  return RET_OK;\n}\n\nret_t file_browser_view_set_show_check_button(widget_t* widget, bool_t show_check_button) {\n  file_browser_view_t* file_browser_view = FILE_BROWSER_VIEW(widget);\n  return_value_if_fail(file_browser_view != NULL, RET_BAD_PARAMS);\n\n  file_browser_view->show_check_button = show_check_button;\n  file_browser_view_reload(widget);\n\n  return RET_OK;\n}\n\nret_t file_browser_view_set_sort_by(widget_t* widget, const char* sort_by) {\n  file_browser_view_t* file_browser_view = FILE_BROWSER_VIEW(widget);\n  return_value_if_fail(file_browser_view != NULL, RET_BAD_PARAMS);\n\n  file_browser_view->sort_by = tk_str_copy(file_browser_view->sort_by, sort_by);\n  file_browser_view_sync_sort(widget);\n\n  return RET_OK;\n}\n\nstatic ret_t file_browser_view_get_prop(widget_t* widget, const char* name, value_t* v) {\n  file_browser_view_t* file_browser_view = FILE_BROWSER_VIEW(widget);\n  return_value_if_fail(file_browser_view != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(FILE_BROWSER_VIEW_PROP_INIT_DIR, name)) {\n    value_set_str(v, file_browser_view->init_dir);\n    return RET_OK;\n  } else if (tk_str_eq(FILE_BROWSER_VIEW_PROP_TOP_DIR, name)) {\n    value_set_str(v, file_browser_view->top_dir);\n    return RET_OK;\n  } else if (tk_str_eq(FILE_BROWSER_VIEW_PROP_IGNORE_HIDDEN_FILES, name)) {\n    value_set_bool(v, file_browser_view->ignore_hidden_files);\n    return RET_OK;\n  } else if (tk_str_eq(FILE_BROWSER_VIEW_PROP_SORT_ASCENDING, name)) {\n    value_set_bool(v, file_browser_view->sort_ascending);\n    return RET_OK;\n  } else if (tk_str_eq(FILE_BROWSER_VIEW_PROP_SHOW_CHECK_BUTTON, name)) {\n    value_set_bool(v, file_browser_view->show_check_button);\n    return RET_OK;\n  } else if (tk_str_eq(FILE_BROWSER_VIEW_PROP_SORT_BY, name)) {\n    value_set_str(v, file_browser_view->sort_by);\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t file_browser_view_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(FILE_BROWSER_VIEW_PROP_INIT_DIR, name)) {\n    file_browser_view_set_init_dir(widget, value_str(v));\n    return RET_OK;\n  } else if (tk_str_eq(FILE_BROWSER_VIEW_PROP_TOP_DIR, name)) {\n    file_browser_view_set_top_dir(widget, value_str(v));\n    return RET_OK;\n  } else if (tk_str_eq(FILE_BROWSER_VIEW_PROP_IGNORE_HIDDEN_FILES, name)) {\n    file_browser_view_set_ignore_hidden_files(widget, value_bool(v));\n    return RET_OK;\n  } else if (tk_str_eq(FILE_BROWSER_VIEW_PROP_SORT_ASCENDING, name)) {\n    file_browser_view_set_sort_ascending(widget, value_bool(v));\n    return RET_OK;\n  } else if (tk_str_eq(FILE_BROWSER_VIEW_PROP_SHOW_CHECK_BUTTON, name)) {\n    file_browser_view_set_show_check_button(widget, value_bool(v));\n    return RET_OK;\n  } else if (tk_str_eq(FILE_BROWSER_VIEW_PROP_SORT_BY, name)) {\n    file_browser_view_set_sort_by(widget, value_str(v));\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t file_browser_view_on_destroy(widget_t* widget) {\n  file_browser_view_t* file_browser_view = FILE_BROWSER_VIEW(widget);\n  return_value_if_fail(widget != NULL && file_browser_view != NULL, RET_BAD_PARAMS);\n\n  TKMEM_FREE(file_browser_view->filter);\n  TKMEM_FREE(file_browser_view->sort_by);\n  TKMEM_FREE(file_browser_view->init_dir);\n  TKMEM_FREE(file_browser_view->top_dir);\n  file_browser_destroy(file_browser_view->fb);\n\n  widget_destroy(file_browser_view->file_template);\n  widget_destroy(file_browser_view->folder_template);\n  darray_deinit(&(file_browser_view->selected_items));\n  darray_deinit(&(file_browser_view->file_items_cache));\n  darray_deinit(&(file_browser_view->folder_items_cache));\n\n  return RET_OK;\n}\n\nstatic ret_t file_browser_view_on_paint_self(widget_t* widget, canvas_t* c) {\n  file_browser_view_t* file_browser_view = FILE_BROWSER_VIEW(widget);\n\n  (void)file_browser_view;\n\n  return RET_OK;\n}\n\nstatic ret_t file_browser_view_reload_in_idle(const idle_info_t* info) {\n  widget_t* widget = WIDGET(info->ctx);\n\n  file_browser_view_reload(widget);\n\n  return RET_REMOVE;\n}\n\nstatic ret_t file_browser_view_on_item_clicked(void* ctx, event_t* e) {\n  value_change_event_t changed;\n  widget_t* target = WIDGET(e->target);\n  file_browser_view_t* file_browser_view = FILE_BROWSER_VIEW(ctx);\n  return_value_if_fail(target != NULL && file_browser_view != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(target->name, FILE_BROWSER_VIEW_RETURN_UP)) {\n    file_browser_up(file_browser_view->fb);\n    widget_add_idle(WIDGET(file_browser_view), file_browser_view_reload_in_idle);\n  } else if (tk_str_eq(target->name, FILE_BROWSER_VIEW_FOLDER)) {\n    uint32_t index = widget_index_of(target);\n    fb_item_t* info = file_browser_get_item(file_browser_view->fb, index - 1);\n    return_value_if_fail(info != NULL, RET_FAIL);\n\n    file_browser_enter(file_browser_view->fb, info->name);\n    widget_add_idle(WIDGET(file_browser_view), file_browser_view_reload_in_idle);\n  } else {\n    uint32_t index = widget_index_of(target);\n    fb_item_t* info = file_browser_get_item(file_browser_view->fb, index - 1);\n    return_value_if_fail(info != NULL, RET_FAIL);\n\n    if (file_browser_view->selected_file != NULL) {\n      widget_set_text_utf8(file_browser_view->selected_file, info->name);\n    }\n  }\n\n  value_change_event_init(&changed, EVT_VALUE_CHANGED, ctx);\n  value_set_str(&(changed.new_value), file_browser_view->fb->cwd);\n  widget_dispatch(WIDGET(ctx), (event_t*)&changed);\n\n  log_debug(\"cwd: %s\\n\", value_str(&(changed.new_value)));\n\n  return RET_OK;\n}\n\nstatic ret_t file_browser_view_recycle_items(widget_t* widget) {\n  widget_t* container = NULL;\n  darray_t* file_items_cache = NULL;\n  darray_t* folder_items_cache = NULL;\n  file_browser_view_t* file_browser_view = FILE_BROWSER_VIEW(widget);\n  return_value_if_fail(file_browser_view != NULL, RET_BAD_PARAMS);\n  container = file_browser_view->container;\n  file_items_cache = &(file_browser_view->file_items_cache);\n  folder_items_cache = &(file_browser_view->folder_items_cache);\n\n  if (container != NULL && container->children != NULL) {\n    WIDGET_FOR_EACH_CHILD_BEGIN(container, iter, i)\n    widget_remove_child_prepare(container, iter);\n    if (tk_str_eq(iter->name, FILE_BROWSER_VIEW_FILE)) {\n      darray_push(file_items_cache, iter);\n    } else if (tk_str_eq(iter->name, FILE_BROWSER_VIEW_FOLDER)) {\n      darray_push(folder_items_cache, iter);\n    }\n    container->children->elms[i] = NULL;\n    WIDGET_FOR_EACH_CHILD_END();\n    container->children->size = 0;\n  }\n\n  return RET_OK;\n}\n\nstatic widget_t* file_browser_view_create_file_item(widget_t* widget) {\n  widget_t* item = NULL;\n  darray_t* cache = NULL;\n  widget_t* container = NULL;\n  file_browser_view_t* file_browser_view = FILE_BROWSER_VIEW(widget);\n  return_value_if_fail(file_browser_view != NULL, NULL);\n  container = file_browser_view->container;\n  cache = &(file_browser_view->file_items_cache);\n\n  if (cache->size > 0) {\n    item = WIDGET(darray_pop(cache));\n    widget_add_child(container, item);\n  } else {\n    item = widget_clone(file_browser_view->file_template, container);\n    widget_on(item, EVT_CLICK, file_browser_view_on_item_clicked, widget);\n  }\n\n  return item;\n}\n\nstatic widget_t* file_browser_view_create_folder_item(widget_t* widget) {\n  widget_t* item = NULL;\n  darray_t* cache = NULL;\n  widget_t* container = NULL;\n  file_browser_view_t* file_browser_view = FILE_BROWSER_VIEW(widget);\n  return_value_if_fail(file_browser_view != NULL, NULL);\n  container = file_browser_view->container;\n  cache = &(file_browser_view->folder_items_cache);\n\n  if (cache->size > 0) {\n    item = WIDGET(darray_pop(cache));\n    widget_add_child(container, item);\n  } else {\n    item = widget_clone(file_browser_view->folder_template, container);\n    widget_on(item, EVT_CLICK, file_browser_view_on_item_clicked, widget);\n  }\n  return item;\n}\n\nret_t file_browser_view_reload(widget_t* widget) {\n  uint32_t i = 0;\n  uint32_t nr = 0;\n  widget_t* item = NULL;\n  widget_t* item_child = NULL;\n  file_browser_view_t* file_browser_view = FILE_BROWSER_VIEW(widget);\n  widget_t* container = file_browser_view != NULL ? file_browser_view->container : NULL;\n  return_value_if_fail(container != NULL && file_browser_view != NULL, RET_BAD_PARAMS);\n\n  file_browser_view_recycle_items(widget);\n\n  if (file_browser_view->cwd != NULL) {\n    widget_set_text_utf8(file_browser_view->cwd, file_browser_view->fb->cwd);\n  }\n\n  item = file_browser_view->return_up_template;\n  widget_add_child(container, item);\n\n  nr = file_browser_get_items_nr(file_browser_view->fb);\n  for (i = 0; i < nr; i++) {\n    fb_item_t* info = file_browser_get_item(file_browser_view->fb, i);\n    if (info->is_dir) {\n      item = file_browser_view_create_folder_item(widget);\n    } else {\n      value_t v;\n      char prop[TK_NAME_LEN + 1];\n      const char* ext = strrchr(info->name, '.');\n      item = file_browser_view_create_file_item(widget);\n      item_child = widget_lookup(item, FILE_BROWSER_VIEW_ICON, TRUE);\n\n      if (item_child != NULL && ext != NULL) {\n        ext++;\n        tk_snprintf(prop, sizeof(prop), \"icon_%s\", ext);\n\n        if (widget_get_prop(widget, prop, &v) == RET_OK && value_str(&v) != NULL) {\n          widget_set_prop_str(item_child, WIDGET_PROP_IMAGE, value_str(&v));\n        }\n      }\n    }\n\n    item_child = widget_lookup(item, FILE_BROWSER_VIEW_NAME, TRUE);\n    if (item_child != NULL) {\n      widget_set_text_utf8(item_child, info->name);\n    }\n\nitem_child = ",
    "raw_res": "0;",
    "prompt_res": "widget_lookup(item, FILE_BROWSER_VIEW_SIZE, TRUE);",
    "gt": "widget_lookup(item, FILE_BROWSER_VIEW_SIZE, TRUE);"
  },
  {
    "id": 1712,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/ext_widgets/progress_circle/progress_circle.c",
    "input": "﻿/**\n * File:   progress_circle.c\n * Author: AWTK Develop Team\n * Brief:  progress_circle\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-11-10 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"base/widget_vtable.h\"\n#include \"base/image_manager.h\"\n#include \"progress_circle/progress_circle.h\"\n\nstatic ret_t progress_circle_on_paint_background(widget_t* widget, canvas_t* c) {\n  bitmap_t img;\n  style_t* style = widget->astyle;\n  color_t trans = color_init(0, 0, 0, 0);\n  vgcanvas_t* vg = canvas_get_vgcanvas(c);\n  progress_circle_t* progress_circle = PROGRESS_CIRCLE(widget);\n  color_t color = style_get_color(style, STYLE_ID_BG_COLOR, trans);\n  const char* image_name = style_get_str(style, STYLE_ID_BG_IMAGE, NULL);\n  bool_t has_image = image_name && widget_load_image(widget, image_name, &img) == RET_OK;\n\n  if (vg != NULL && (has_image || color.rgba.a)) {\n    xy_t cx = widget->w / 2;\n    xy_t cy = widget->h / 2;\n    float_t r = tk_min(cx, cy) - progress_circle->line_width / 2;\n    vgcanvas_save(vg);\n    vgcanvas_translate(vg, c->ox, c->oy);\n    vgcanvas_set_stroke_color(vg, color);\n    vgcanvas_set_line_width(vg, progress_circle->line_width);\n    vgcanvas_begin_path(vg);\n    vgcanvas_arc(vg, cx, cy, r, 0, M_PI * 2, FALSE);\n    if (has_image) {\n      vgcanvas_paint(vg, TRUE, &img);\n    } else {\n      vgcanvas_stroke(vg);\n    }\n\n    vgcanvas_restore(vg);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t progress_circle_update_text(widget_t* widget) {\n  char format[TK_NUM_MAX_LEN + 1];\n  char str[TK_NUM_MAX_LEN + 1];\n  progress_circle_t* progress_circle = PROGRESS_CIRCLE(widget);\n  return_value_if_fail(progress_circle != NULL, RET_BAD_PARAMS);\n\n  const char* unit = widget_get_prop_str(widget, PROGRESS_CIRCLE_PROP_UNIT, NULL);\n  if (progress_circle->format == NULL) {\n    const char* temp = unit != NULL ? unit : \"\";\n    tk_snprintf(format, TK_NUM_MAX_LEN, \"%u%s\", (uint32_t)progress_circle->value, temp);\n  } else {\n    uint32_t len = tk_strlen(progress_circle->format);\n    tk_strncpy_s(format, TK_NUM_MAX_LEN, progress_circle->format, len);\n  }\n\n  if (strchr(format, 'd') != NULL || strchr(format, 'x') != NULL || strchr(format, 'X') != NULL) {\n    tk_snprintf(str, TK_NUM_MAX_LEN, format, tk_roundi(progress_circle->value));\n  } else {\n    tk_snprintf(str, TK_NUM_MAX_LEN, format, progress_circle->value);\n  }\n\n  return widget_set_text_utf8(widget, str);\n}\n\nstatic float_t progress_circle_value_to_angle(widget_t* widget, float_t value) {\n  float_t end_angle = 0;\n  progress_circle_t* progress_circle = PROGRESS_CIRCLE(widget);\n  bool_t ccw = progress_circle->counter_clock_wise;\n  float_t start_angle = TK_D2R(progress_circle->start_angle);\n  float_t angle = (M_PI * 2 * value) / progress_circle->max;\n\n  if (ccw) {\n    end_angle = start_angle - angle + M_PI * 2;\n    if (fabs(end_angle - start_angle) < 0.001f) {\n      end_angle = start_angle + 0.001f;\n    }\n  } else {\n    end_angle = start_angle + angle;\n  }\n\n  return end_angle;\n}\n\nstatic float_t progress_circle_get_radius(widget_t* widget) {\n  xy_t cx = widget->w / 2;\n  xy_t cy = widget->h / 2;\n  progress_circle_t* progress_circle = PROGRESS_CIRCLE(widget);\n\n  return tk_min(cx, cy) - progress_circle->line_width / 2;\n}\n\nrect_t progress_circle_calc_text_dirty_rect(widget_t* widget) {\n  rect_t r = {0, 0, 0, 0};\n  canvas_t* c = widget_get_canvas(widget);\n  progress_circle_t* progress_circle = PROGRESS_CIRCLE(widget);\n\n  if (widget->w < 1 || widget->h < 1) {\n    return r;\n  }\n\n  if (c != NULL && progress_circle->show_text) {\n    wstr_t* text = &(widget->text);\n    widget_prepare_text_style(widget, c);\n    progress_circle_update_text(widget);\n\n    r.w = canvas_measure_text(c, text->str, text->size) + 10;\n    r.h = c->font_size + 4;\n\n    r.x = (widget->w - r.w) / 2;\n    r.y = (widget->h - r.h) / 2;\n  }\n\n  return r;\n}\n\nrect_t progress_circle_calc_line_dirty_rect(widget_t* widget, float_t old_value,\n                                            float_t new_value) {\n  int32_t min_x = 0;\n  int32_t min_y = 0;\n  int32_t max_x = 0;\n  int32_t max_y = 0;\n  float_t start_angle = 0;\n  float_t end_angle = 0;\n  rect_t rect = {0, 0, 0, 0};\n  point_t start_p = {0, 0};\n  point_t end_p = {0, 0};\n  progress_circle_t* progress_circle = PROGRESS_CIRCLE(widget);\n  float_t line_width = progress_circle->line_width;\n\n  start_angle = progress_circle_value_to_angle(widget, old_value);\n  end_angle = progress_circle_value_to_angle(widget, new_value);\n\n  if (widget->w < 1 || widget->h < 1) {\n    return rect;\n  }\n\n  if (start_angle > end_angle) {\n    float_t t = start_angle;\n    start_angle = end_angle;\n    end_angle = t;\n  }\n\n  if ((end_angle - start_angle) < (M_PI / 2)) {\n    xy_t cx = widget->w / 2;\n    xy_t cy = widget->h / 2;\n    int32_t delta = line_width / 2 + 1;\n    float_t r = progress_circle_get_radius(widget);\n\n    start_p.y = round(r * sin(start_angle));\n    start_p.x = round(r * cos(start_angle));\n\n    end_p.y = round(r * sin(end_angle));\n    end_p.x = round(r * cos(end_angle));\n\n    min_x = tk_min(start_p.x, end_p.x) - delta;\n    max_x = tk_max(start_p.x, end_p.x) + delta;\n    min_y = tk_min(start_p.y, end_p.y) - delta;\n    max_y = tk_max(start_p.y, end_p.y) + delta;\n    if (start_p.x > 0 && end_p.x < 0) {\n      /*跨越第1和2象限*/\n      max_y = tk_max_int(r, max_y);\n    } else if (start_p.y > 0 && end_p.y < 0) {\n      /*跨越第2和3象限*/\n      min_x = tk_min_int(-r, min_x);\n    } else if (start_p.x < 0 && end_p.x > 0) {\n      /*跨越第3和4象限*/\n      min_y = tk_min_int(-r, min_y);\n    } else if (start_p.y < 0 && end_p.y > 0) {\n      /*跨越第4和1象限*/\n      max_x = tk_max_int(r, max_x);\n    }\n\n    assert(min_x <= max_x);\n    assert(min_y <= max_y);\n    rect = rect_init(min_x, min_y, max_x - min_x, max_y - min_y);\n    rect.x += cx;\n    rect.y += cy;\n  } else {\nrect = ",
    "raw_res": "{0, 0, 0, 0};",
    "prompt_res": "rect_init(0, 0, widget->w, widget->h);",
    "gt": "rect_init(0, 0, widget->w, widget->h);"
  },
  {
    "id": 1828,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/layouters/self_layouter_builtins.c",
    "input": "﻿/**\n * File:   self_layouter_builts.h\n * Author: AWTK Develop Team\n * Brief:  builts self_layouter\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied highlighterrranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-03-27 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"base/self_layouter_factory.h\"\n#include \"layouters/self_layouter_builtins.h\"\n#include \"layouters/self_layouter_menu.h\"\n#include \"layouters/self_layouter_default.h\"\n\nret_t self_layouter_register_builtins(void) {\nself_layouter_factory_t* f = ",
    "raw_res": "self_layouter_factory_get();",
    "prompt_res": "self_layouter_factory();",
    "gt": "self_layouter_factory();"
  },
  {
    "id": 1836,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/layouters/self_layouter_parser.c",
    "input": "﻿/**\n * File:   self_layouter_parser.c\n * Author: AWTK Develop Team\n * Brief:  self layouter parser\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-12-16 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/func_call_parser.h\"\n#include \"base/self_layouter_factory.h\"\n#include \"layouters/self_layouter_default.h\"\n\ntypedef struct _self_layouter_parser_t {\n  func_call_parser_t base;\n\n  self_layouter_t* layouter;\n} self_layouter_parser_t;\n\nstatic ret_t self_layouter_parser_on_name(func_call_parser_t* parser, const char* func_name) {\nself_layouter_factory_t* f = ",
    "raw_res": "0;",
    "prompt_res": "self_layouter_factory();",
    "gt": "self_layouter_factory();"
  },
  {
    "id": 1838,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/layouters/children_layouter_builtins.c",
    "input": "﻿/**\n * File:   children_layouter_builts.h\n * Author: AWTK Develop Team\n * Brief:  builts children_layouter\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied highlighterrranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-05-13 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"base/children_layouter_factory.h\"\n#include \"layouters/children_layouter_builtins.h\"\n#include \"layouters/children_layouter_default.h\"\n\nret_t children_layouter_register_builtins(void) {\nchildren_layouter_factory_t* f = ",
    "raw_res": "children_layouter_factory_get();",
    "prompt_res": "children_layouter_factory();",
    "gt": "children_layouter_factory();"
  },
  {
    "id": 1851,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/layouters/children_layouter_parser.c",
    "input": "﻿/**\n * File:   children_layouter_parser.c\n * Author: AWTK Develop Team\n * Brief:  children layouter factory\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-12-16 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/utils.h\"\n#include \"tkc/tokenizer.h\"\n#include \"tkc/func_call_parser.h\"\n#include \"base/children_layouter_factory.h\"\n#include \"layouters/children_layouter_default.h\"\n\ntypedef struct _children_layouter_parser_t {\n  func_call_parser_t base;\n\n  children_layouter_t* layouter;\n} children_layouter_parser_t;\n\nstatic ret_t children_layouter_parser_on_name(func_call_parser_t* parser, const char* func_name) {\n  children_layouter_factory_t* f = children_layouter_factory();\n  children_layouter_parser_t* children_layouter_parser = (children_layouter_parser_t*)parser;\n\n  return_value_if_fail(func_name != NULL, RET_BAD_PARAMS);\n\n  children_layouter_parser->layouter = children_layouter_factory_create_layouter(f, func_name);\n  return_value_if_fail(children_layouter_parser->layouter != NULL, RET_NOT_IMPL);\n\n  return RET_OK;\n}\n\nstatic ret_t children_layouter_parser_on_param(func_call_parser_t* parser, const char* name,\n                                               const char* value) {\n  children_layouter_parser_t* children_layouter_parser = (children_layouter_parser_t*)parser;\n  children_layouter_set_param_str(children_layouter_parser->layouter, name, value);\n\n  return RET_OK;\n}\n\nchildren_layouter_t* children_layouter_create_new(const char* params) {\n  children_layouter_t* layouter = NULL;\n  children_layouter_parser_t parser;\n  return_value_if_fail(params != NULL, NULL);\n\n  memset(&parser, 0x00, sizeof(parser));\n  return_value_if_fail(func_call_parser_init(&(parser.base), params, strlen(params)) != NULL, NULL);\n\n  parser.base.on_name = children_layouter_parser_on_name;\n  parser.base.on_param = children_layouter_parser_on_param;\n\n  parser.layouter = NULL;\n  func_call_parser_parse(&(parser.base));\n  layouter = parser.layouter;\n  func_call_parser_deinit(&(parser.base));\n\n  return layouter;\n}\n\nchildren_layouter_t* children_layouter_create_old(const char* params) {\n  value_t v;\n  char name[2];\n  tokenizer_t tokenizer;\n  tokenizer_t* t = &tokenizer;\n  children_layouter_t* layout = children_layouter_default_create();\n  return_value_if_fail(layout != NULL && params != NULL, NULL);\n\n  name[1] = '\\0';\n  tokenizer_init(t, params, strlen(params), \" ,\");\n  while (tokenizer_has_more(t)) {\nconst char* key = ",
    "raw_res": "0;",
    "prompt_res": "tokenizer_next(t);",
    "gt": "tokenizer_next(t);"
  },
  {
    "id": 1890,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/csv/csv_file_object.c",
    "input": "﻿/**\n * File:   csv_file_object.h\n * Author: AWTK Develop Team\n * Brief:  csv file object\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2020-07-19 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/str.h\"\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/object.h\"\n#include \"csv_file.h\"\n\ntypedef struct _csv_file_object_t {\n  tk_object_t object;\n\n  /*private*/\n  csv_file_t* csv;\n  str_t str;\n} csv_file_object_t;\n\nstatic csv_file_object_t* csv_file_object_cast(tk_object_t* obj);\n#define CSV_FILE_OBJECT(obj) csv_file_object_cast((tk_object_t*)obj)\n\ntypedef struct _csv_path_t {\n  int32_t row;\n  int32_t col;\n  const char* col_name;\n} csv_path_t;\n\nstatic ret_t csv_path_parse(csv_path_t* path, csv_file_t* csv, const char* name) {\n  const char* p = name;\n  memset(path, 0x00, sizeof(*path));\n\n  while (*p && *p != '[') p++;\n  return_value_if_fail(*p == '[', RET_FAIL);\n\n  p++;\n  path->row = tk_atoi(p);\n  p = strchr(p, '.');\n  if (p == NULL) {\n    return RET_OK;\n  } else {\n    p++;\n  }\n\n  if (tk_str_eq(p, TK_OBJECT_PROP_CHECKED)) {\n    path->col_name = p;\n\n    return RET_OK;\n  }\n\n  if (*p == '[') {\n    path->col = tk_atoi(p + 1);\n  } else {\n    path->col = csv_file_get_col_of_name(csv, p);\n    if (path->col < 0) {\n      path->col = tk_atoi(p);\n    }\n  }\n  return_value_if_fail((path->col >= 0) && (path->col < csv_file_get_cols(csv)), RET_BAD_PARAMS);\n  return_value_if_fail((path->row >= 0) && (path->row < csv_file_get_rows(csv)), RET_BAD_PARAMS);\n\n  return RET_OK;\n}\n\nstatic ret_t csv_file_object_remove_prop(tk_object_t* obj, const char* name) {\n  csv_path_t p;\n  csv_file_object_t* o = CSV_FILE_OBJECT(obj);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(csv_path_parse(&p, o->csv, name) == RET_OK, RET_FAIL);\n\n  return csv_file_remove_row(o->csv, p.row);\n}\n\nstatic ret_t csv_file_object_set_prop(tk_object_t* obj, const char* name, const value_t* v) {\n  csv_path_t p;\n  uint32_t rows = 0;\n  csv_file_object_t* o = CSV_FILE_OBJECT(obj);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n\n  rows = csv_file_get_rows(o->csv);\n  if (rows <= 0) {\n    return RET_NOT_FOUND;\n  }\n\n  return_value_if_fail(csv_path_parse(&p, o->csv, name) == RET_OK, RET_FAIL);\n  if (p.col_name != NULL && tk_str_ieq(p.col_name, TK_OBJECT_PROP_CHECKED)) {\n    return csv_file_set_row_checked(o->csv, p.row, value_bool(v));\n  }\n\n  str_from_value(&(o->str), v);\n  return csv_file_set(o->csv, p.row, p.col, o->str.str);\n}\n\nstatic ret_t csv_file_object_get_prop(tk_object_t* obj, const char* name, value_t* v) {\n  csv_path_t p;\n  uint32_t rows = 0;\n  const char* str = NULL;\n  csv_file_object_t* o = CSV_FILE_OBJECT(obj);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n\n  rows = csv_file_get_rows(o->csv);\n  if (tk_str_ieq(name, TK_OBJECT_PROP_SIZE)) {\n    value_set_int(v, rows);\n    return RET_OK;\n  }\n\n  if (rows <= 0) {\n    return RET_NOT_FOUND;\n  }\n\n  return_value_if_fail(csv_path_parse(&p, o->csv, name) == RET_OK, RET_FAIL);\n  if (p.col_name != NULL && tk_str_ieq(p.col_name, TK_OBJECT_PROP_CHECKED)) {\n    return_value_if_fail(p.row < rows, RET_FAIL);\n\n    value_set_bool(v, csv_file_is_row_checked(o->csv, p.row));\n    return RET_OK;\n  }\n\n  value_set_str(v, \"\");\n  str = csv_file_get(o->csv, p.row, p.col);\n  return_value_if_fail(str != NULL, RET_FAIL);\n  value_set_str(v, str);\n\n  return RET_OK;\n}\n\nstatic bool_t csv_file_object_can_exec(tk_object_t* obj, const char* name, const char* args) {\n  csv_file_object_t* o = CSV_FILE_OBJECT(obj);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_ieq(name, TK_OBJECT_CMD_SAVE)) {\n    return TRUE;\n  } else if (tk_str_ieq(name, TK_OBJECT_CMD_RELOAD)) {\n    return TRUE;\n  } else if (tk_str_ieq(name, TK_OBJECT_CMD_CLEAR)) {\n    return TRUE;\n  } else if (tk_str_ieq(name, TK_OBJECT_CMD_REMOVE)) {\n    return TRUE;\n  } else if (tk_str_ieq(name, TK_OBJECT_CMD_REMOVE_CHECKED)) {\n    return csv_file_get_checked_rows(o->csv) > 0;\n  } else if (tk_str_ieq(name, TK_OBJECT_CMD_ADD)) {\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\nstatic ret_t csv_file_object_exec(tk_object_t* obj, const char* name, const char* args) {\n  ret_t ret = RET_NOT_IMPL;\n  csv_file_object_t* o = CSV_FILE_OBJECT(obj);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_ieq(name, TK_OBJECT_CMD_SAVE)) {\n    ret = csv_file_save(o->csv, NULL);\n  } else if (tk_str_ieq(name, TK_OBJECT_CMD_RELOAD)) {\n    csv_file_reload(o->csv);\n    ret = RET_ITEMS_CHANGED;\n  } else if (tk_str_ieq(name, TK_OBJECT_CMD_CLEAR)) {\n    csv_file_clear(o->csv);\n    ret = RET_ITEMS_CHANGED;\n  } else if (tk_str_ieq(name, TK_OBJECT_CMD_REMOVE)) {\n    const char* index = strrchr(args, '[');\n    if (index != NULL) {\n      index++;\n    } else {\n      index = args;\n    }\n    return_value_if_fail(index != NULL, RET_FAIL);\n    ret = csv_file_remove_row(o->csv, tk_atoi(index)) == RET_OK ? RET_ITEMS_CHANGED : RET_FAIL;\n  } else if (tk_str_ieq(name, TK_OBJECT_CMD_REMOVE_CHECKED)) {\nret = ",
    "raw_res": "0;",
    "prompt_res": "csv_file_remove_checked_rows(o->csv) == RET_OK ? RET_ITEMS_CHANGED : RET_FAIL;",
    "gt": "csv_file_remove_checked_rows(o->csv) == RET_OK ? RET_ITEMS_CHANGED : RET_FAIL;"
  },
  {
    "id": 1934,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/conf_io/conf_node.c",
    "input": "﻿/**\n * File:   conf_node.c\n * Author: AWTK Develop Team\n * Brief:  conf node\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2020-05-11 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"conf_io/conf_node.h\"\n\nstatic ret_t conf_node_destroy(conf_doc_t* doc, conf_node_t* node);\n\nconf_node_t* conf_node_get_first_child(conf_node_t* node) {\n  return_value_if_fail(node != NULL, NULL);\n  if (node->value_type != CONF_NODE_VALUE_NODE && node->value_type != CONF_NODE_VALUE_NONE) {\n    return NULL;\n  }\n\n  return node->value.first_child;\n}\n\nret_t conf_node_set_first_child(conf_node_t* node, conf_node_t* child) {\n  return_value_if_fail(node != NULL, RET_BAD_PARAMS);\n  node->value_type = CONF_NODE_VALUE_NODE;\n  node->value.first_child = child;\n\n  if (child != NULL) {\n    child->parent = node;\n  }\n\n  return RET_OK;\n}\n\nconf_doc_t* conf_doc_create(uint32_t prealloc_nodes_nr) {\n  uint32_t size = prealloc_nodes_nr * sizeof(conf_node_t);\n  conf_doc_t* doc = TKMEM_ZALLOC(conf_doc_t);\n  return_value_if_fail(doc != NULL, NULL);\n\n  if (prealloc_nodes_nr > 0) {\n    doc->prealloc_nodes = TKMEM_ALLOC(size);\n    if (doc->prealloc_nodes == NULL) {\n      TKMEM_FREE(doc);\n    } else {\n      memset(doc->prealloc_nodes, 0x00, size);\n      doc->prealloc_nodes_nr = prealloc_nodes_nr;\n    }\n  }\n  doc->max_deep_level = 0xffff;\n  tokenizer_init(&(doc->tokenizer), \"\", 0, \".\");\n\n  return doc;\n}\n\nstatic conf_node_t* conf_doc_find_free_node(conf_doc_t* doc) {\n  uint32_t i = 0;\n  return_value_if_fail(doc != NULL, NULL);\n  if (doc->prealloc_nodes_used >= doc->prealloc_nodes_nr) {\n    return NULL;\n  }\n\n  for (i = doc->prealloc_nodes_index; i < doc->prealloc_nodes_nr; i++) {\n    conf_node_t* iter = doc->prealloc_nodes + i;\n    if (iter->node_type == CONF_NODE_NONE) {\n      doc->prealloc_nodes_index = i;\n      doc->prealloc_nodes_used++;\n      return iter;\n    }\n  }\n\n  for (i = 0; i < doc->prealloc_nodes_index; i++) {\n    conf_node_t* iter = doc->prealloc_nodes + i;\n    if (iter->node_type == CONF_NODE_NONE) {\n      doc->prealloc_nodes_index = i;\n      doc->prealloc_nodes_used++;\n      return iter;\n    }\n  }\n\n  return NULL;\n}\n\nconf_node_t* conf_doc_create_node(conf_doc_t* doc, const char* name) {\n  conf_node_t* node = NULL;\n  return_value_if_fail(doc != NULL, NULL);\n  node = conf_doc_find_free_node(doc);\n\n  if (node != NULL) {\n    memset(node, 0x00, sizeof(conf_node_t));\n  } else {\n    node = TKMEM_ZALLOC(conf_node_t);\n  }\n  return_value_if_fail(node != NULL, NULL);\n\n  node->node_type = CONF_NODE_OBJECT;\n  if (name != NULL) {\n    uint32_t size = strlen(name);\n    if (size < sizeof(node->name)) {\n      node->is_small_name = TRUE;\n      strcpy(node->name.small_str, name);\n    } else {\n      node->is_small_name = FALSE;\n      node->name.str = tk_strdup(name);\n    }\n  }\n\n  return node;\n}\n\nstatic conf_node_t* conf_doc_dup_node_impl(conf_doc_t* doc, conf_node_t* node,\n                                           const char* new_name) {\n  conf_node_t* new_node = NULL;\n  return_value_if_fail(doc != NULL && node != NULL, NULL);\n\n  if (new_name == NULL) {\n    new_name = conf_node_get_name(node);\n  }\n  new_node = conf_doc_create_node(doc, new_name);\n  return_value_if_fail(new_node != NULL, NULL);\n\n  new_node->value_type = node->value_type;\n  if (node->value_type == CONF_NODE_VALUE_NODE) {\n    conf_node_t* iter = conf_node_get_first_child(node);\n    while (iter != NULL) {\n      conf_node_t* new_iter = conf_doc_dup_node_impl(doc, iter, NULL);\n      break_if_fail(new_iter != NULL);\n      conf_doc_append_child(doc, new_node, new_iter);\n\n      iter = iter->next;\n    }\n  } else if (node->value_type != CONF_NODE_VALUE_NONE) {\n    value_t v;\n    if (conf_node_get_value(node, &v) == RET_OK) {\n      conf_node_set_value(new_node, &v);\n    }\n  }\n\n  return new_node;\n}\n\nconf_node_t* conf_doc_dup_node(conf_doc_t* doc, conf_node_t* node, const char* new_name) {\n  conf_node_t* new_node = NULL;\n  return_value_if_fail(doc != NULL && node != NULL, NULL);\n  new_node = conf_doc_dup_node_impl(doc, node, new_name);\n  return_value_if_fail(new_node != NULL, NULL);\n\n  new_node->next = node->next;\n  node->next = new_node;\n  new_node->parent = node->parent;\n\n  return new_node;\n}\n\nret_t conf_doc_set_node_prop(conf_doc_t* doc, conf_node_t* node, const char* name,\n                             const value_t* v) {\n  conf_node_t* child = NULL;\n  return_value_if_fail(doc != NULL && node != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  child = conf_node_find_child(node, name);\n  if (child == NULL) {\n    child = conf_doc_create_node(doc, name);\n    return_value_if_fail(child != NULL, RET_BAD_PARAMS);\n\n    conf_node_set_value(child, v);\n    return conf_doc_append_child(doc, node, child);\n  } else {\n    return conf_node_set_value(child, v);\n  }\n}\n\nret_t conf_doc_destroy_node(conf_doc_t* doc, conf_node_t* node) {\n  return_value_if_fail(doc != NULL && node != NULL, RET_BAD_PARAMS);\n\n  if (!node->is_small_name) {\n    TKMEM_FREE(node->name.str);\n  }\n\n  if (node->value_type == CONF_NODE_VALUE_STRING) {\n    TKMEM_FREE(node->value.str);\n  }\n\n  memset(node, 0x00, sizeof(*node));\n\n  if (node >= doc->prealloc_nodes && node < (doc->prealloc_nodes + doc->prealloc_nodes_nr)) {\n    node->node_type = CONF_NODE_NONE;\n    doc->prealloc_nodes_used--;\n\n    return RET_OK;\n  }\n\n  TKMEM_FREE(node);\n\n  return RET_OK;\n}\n\nret_t conf_doc_append_sibling(conf_doc_t* doc, conf_node_t* node, conf_node_t* sibling) {\n  conf_node_t* iter = node;\n  return_value_if_fail(doc != NULL && node != NULL && sibling != NULL, RET_BAD_PARAMS);\n\n  sibling->parent = node->parent;\n  while (iter->next != NULL) iter = iter->next;\n  iter->next = sibling;\n\n  return RET_OK;\n}\n\nret_t conf_doc_append_child(conf_doc_t* doc, conf_node_t* node, conf_node_t* child) {\n  conf_node_t* first_child = conf_node_get_first_child(node);\n  return_value_if_fail(doc != NULL && node != NULL && child != NULL, RET_BAD_PARAMS);\n\n  if (first_child == NULL) {\n    conf_node_set_first_child(node, child);\n    return RET_OK;\n  } else {\n    return conf_doc_append_sibling(doc, first_child, child);\n  }\n}\n\nret_t conf_doc_remove_sibling(conf_doc_t* doc, conf_node_t* node, conf_node_t* sibling) {\n  conf_node_t* iter = node;\n  return_value_if_fail(doc != NULL && node != NULL && sibling != NULL, RET_BAD_PARAMS);\n\n  if (node == sibling) {\n    return conf_doc_remove_child(doc, node->parent, node);\n  } else {\n    while (iter->next != NULL) {\n      if (iter->next == sibling) {\n        iter->next = sibling->next;\n        sibling->next = NULL;\n        conf_doc_destroy_node(doc, sibling);\n        return RET_OK;\n      }\n      iter = iter->next;\n    }\n  }\n\n  return RET_NOT_FOUND;\n}\n\nret_t conf_doc_remove_child(conf_doc_t* doc, conf_node_t* node, conf_node_t* child) {\n  conf_node_t* first_child = conf_node_get_first_child(node);\n  return_value_if_fail(doc != NULL && node != NULL && child != NULL, RET_BAD_PARAMS);\n\n  if (first_child == child) {\n    conf_node_set_first_child(node, child->next);\n    conf_doc_destroy_node(doc, child);\n\n    return RET_OK;\n  } else {\n    return conf_doc_remove_sibling(doc, first_child, child);\n  }\n}\n\nret_t conf_doc_remove_child_by_name(conf_doc_t* doc, conf_node_t* node, const char* name) {\n  conf_node_t* iter = NULL;\n  conf_node_t* prev = NULL;\n  conf_node_t* first_child = conf_node_get_first_child(node);\n  return_value_if_fail(doc != NULL && node != NULL, RET_BAD_PARAMS);\n\n  iter = first_child;\n  prev = first_child;\n  while (iter != NULL) {\n    if (tk_str_eq(conf_node_get_name(iter), name)) {\n      if (iter == first_child) {\n        conf_node_set_first_child(node, iter->next);\n      } else {\n        prev->next = iter->next;\n      }\n      conf_doc_destroy_node(doc, iter);\n\n      return RET_OK;\n    }\n    prev = iter;\n    iter = iter->next;\n  }\n\n  return RET_NOT_FOUND;\n}\n\nret_t conf_doc_remove_children(conf_doc_t* doc, conf_node_t* node) {\n  conf_node_t* iter = NULL;\n  conf_node_t* first_child = conf_node_get_first_child(node);\n  return_value_if_fail(doc != NULL && node != NULL, RET_BAD_PARAMS);\n\n  if (first_child == NULL) {\n    return RET_OK;\n  }\n\n  iter = first_child;\n  return_value_if_fail(iter != NULL, RET_BAD_PARAMS);\n  conf_node_set_first_child(node, NULL);\n\n  while (iter != NULL) {\n    conf_node_t* next = iter->next;\n\n    conf_doc_remove_children(doc, iter);\n    conf_doc_destroy_node(doc, iter);\n    iter = next;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t conf_node_destroy(conf_doc_t* doc, conf_node_t* node) {\n  conf_node_t* iter = node;\n  return_value_if_fail(doc != NULL && node != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    conf_node_t* next = iter->next;\n    conf_doc_remove_children(doc, iter);\n    conf_doc_destroy_node(doc, iter);\n    iter = next;\n  }\n\n  return RET_OK;\n}\n\nconst char* conf_node_get_name(conf_node_t* node) {\n  return_value_if_fail(node != NULL, NULL);\n\n  return node->is_small_name ? node->name.small_str : node->name.str;\n}\n\nuint32_t conf_node_count_children(conf_node_t* node) {\n  uint32_t i = 0;\n  conf_node_t* first = conf_node_get_first_child(node);\n  return_value_if_fail(node != NULL, 0);\n\n  while (first != NULL) {\n    i++;\n    first = first->next;\n  }\n\n  return i;\n}\n\nstatic int32_t conf_node_get_index(conf_node_t* node) {\n  uint32_t i = 0;\n  conf_node_t* iter = NULL;\n  return_value_if_fail(node != NULL, 0);\n  iter = conf_node_get_first_child(node->parent);\n\n  while (iter != NULL) {\n    if (iter == node) {\n      return i;\n    }\n    i++;\n    iter = iter->next;\n  }\n  assert(!\"impossible\");\n  return -1;\n}\n\nconf_node_t* conf_node_find_sibling(conf_node_t* node, const char* name) {\n  conf_node_t* iter = NULL;\n  if (node == NULL) {\n    return NULL;\n  }\n\n  return_value_if_fail(name != NULL, NULL);\n\n  if (node->parent != NULL) {\n    iter = conf_node_get_first_child(node->parent);\n  } else {\n    iter = node;\n  }\n  while (iter != NULL) {\n    if (tk_str_eq(conf_node_get_name(iter), name)) {\n      return iter;\n    }\n\n    iter = iter->next;\n  }\n\n  return NULL;\n}\n\nconf_node_t* conf_node_find_sibling_by_index(conf_node_t* node, int32_t index) {\n  int32_t i = 0;\n  conf_node_t* iter = NULL;\n  return_value_if_fail(node != NULL && index >= 0, NULL);\n\n  if (node->parent != NULL) {\n    iter = conf_node_get_first_child(node->parent);\n  } else {\n    iter = node;\n  }\n\n  for (i = 0; i < index && iter != NULL; i++) {\n    iter = iter->next;\n  }\n\n  return iter;\n}\n\nconf_node_t* conf_node_find_child(conf_node_t* node, const char* name) {\n  conf_node_t* first_child = conf_node_get_first_child(node);\n  return_value_if_fail(node != NULL && name != NULL, NULL);\n\n  return conf_node_find_sibling(first_child, name);\n}\n\nconf_node_t* conf_node_find_child_by_index(conf_node_t* node, int32_t index) {\n  conf_node_t* first_child = conf_node_get_first_child(node);\n  return_value_if_fail(node != NULL, NULL);\n\n  return conf_node_find_sibling_by_index(first_child, index);\n}\n\nret_t conf_doc_destroy(conf_doc_t* doc) {\n  return_value_if_fail(doc != NULL, RET_BAD_PARAMS);\n\n  conf_node_destroy(doc, doc->root);\n  doc->root = NULL;\n  tokenizer_deinit(&(doc->tokenizer));\n  TKMEM_FREE(doc->prealloc_nodes);\n\n  TKMEM_FREE(doc);\n\n  return RET_OK;\n}\n\nret_t conf_node_set_value(conf_node_t* node, const value_t* v) {\n  return_value_if_fail(node != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(node->value_type != CONF_NODE_VALUE_NODE, RET_BAD_PARAMS);\n\n  if (node->value_type == CONF_NODE_VALUE_STRING) {\n    TKMEM_FREE(node->value.str);\n  }\n\n  switch (v->type) {\n    case VALUE_TYPE_BOOL: {\n      node->value_type = CONF_NODE_VALUE_BOOL;\n      node->value.b = value_bool(v);\n      break;\n    }\n    case VALUE_TYPE_INT8: {\n      node->value_type = CONF_NODE_VALUE_INT8;\n      node->value.i8 = value_int8(v);\n      break;\n    }\n    case VALUE_TYPE_UINT8: {\n      node->value_type = CONF_NODE_VALUE_UINT8;\n      node->value.u8 = value_uint8(v);\n      break;\n    }\n    case VALUE_TYPE_INT16: {\n      node->value_type = CONF_NODE_VALUE_INT16;\n      node->value.i16 = value_int16(v);\n      break;\n    }\n    case VALUE_TYPE_UINT16: {\n      node->value_type = CONF_NODE_VALUE_UINT16;\n      node->value.u16 = value_uint16(v);\n      break;\n    }\n    case VALUE_TYPE_INT32: {\n      node->value_type = CONF_NODE_VALUE_INT32;\n      node->value.i32 = value_int32(v);\n      break;\n    }\n    case VALUE_TYPE_UINT32: {\n      node->value_type = CONF_NODE_VALUE_UINT32;\n      node->value.u32 = value_uint32(v);\n      break;\n    }\n    case VALUE_TYPE_INT64: {\n      node->value_type = CONF_NODE_VALUE_INT64;\n      node->value.i64 = value_int64(v);\n      break;\n    }\n    case VALUE_TYPE_UINT64: {\n      node->value_type = CONF_NODE_VALUE_UINT64;\n      node->value.u64 = value_uint64(v);\n      break;\n    }\n    case VALUE_TYPE_FLOAT:\n    case VALUE_TYPE_FLOAT32: {\n      node->value_type = CONF_NODE_VALUE_FLOAT32;\n      node->value.f32 = value_float32(v);\n      break;\n    }\n    case VALUE_TYPE_DOUBLE: {\n      node->value_type = CONF_NODE_VALUE_DOUBLE;\nnode->value.f64 = ",
    "raw_res": "value_float64(v);",
    "prompt_res": "value_double(v);",
    "gt": "value_double(v);"
  },
  {
    "id": 1970,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/conf_io/conf_xml.c",
    "input": "﻿/**\n * File:   conf_xml.c\n * Author: AWTK Develop Team\n * Brief:  xml \n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2022-05-31 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"xml/xml_parser.h\"\n#include \"conf_io/conf_xml.h\"\n#include \"tkc/data_writer_factory.h\"\n\ntypedef struct _xml_builter_t {\n  XmlBuilder builder;\n  conf_doc_t* doc;\n  conf_node_t* node;\n  uint32_t level;\n  str_t str;\n} xml_builter_t;\n\nstatic void my_xml_builder_on_start(XmlBuilder* thiz, const char* tag, const char** attrs) {\n  uint32_t i = 0;\n  xml_builter_t* b = (xml_builter_t*)thiz;\n  str_t* str = &(b->str);\n  conf_node_t* node = conf_doc_create_node(b->doc, tag);\n  return_if_fail(node != NULL);\n\n  conf_doc_append_child(b->doc, b->node, node);\n  node->value_type = CONF_NODE_VALUE_NODE;\n  b->node = node;\n  b->level++;\n\n  while (attrs[i]) {\n    value_t v;\n    const char* name = attrs[i];\n    const char* value = attrs[i + 1];\n\n    str_clear(str);\n    str_decode_xml_entity(str, value);\n    node = conf_doc_create_node(b->doc, name);\n    return_if_fail(node != NULL);\n\n    conf_doc_append_child(b->doc, b->node, node);\n    value_set_str(&v, str->str);\n    conf_node_set_value(node, &v);\n\n    i += 2;\n  }\n\n  return;\n}\n\nstatic void my_xml_builder_on_end(XmlBuilder* thiz, const char* tag) {\n  xml_builter_t* b = (xml_builter_t*)thiz;\n\n  if (b->node != NULL) {\n    b->node = b->node->parent;\n  }\n  b->level--;\n\n  return;\n}\n\nstatic void my_xml_builder_on_error(XmlBuilder* thiz, int line, int row, const char* message) {\n  log_debug(\"%d:%d %s\\n\", line, row, message);\n}\n\nstatic void my_xml_builder_on_text(XmlBuilder* thiz, const char* text, size_t length) {\n  return;\n}\n\nstatic void my_xml_builder_destroy(XmlBuilder* thiz) {\n  xml_builter_t* b = (xml_builter_t*)thiz;\n  str_reset(&(b->str));\n  return;\n}\n\nstatic XmlBuilder* builder_init(xml_builter_t* b, conf_doc_t* doc) {\n  b->builder.on_start = my_xml_builder_on_start;\n  b->builder.on_end = my_xml_builder_on_end;\n  b->builder.on_text = my_xml_builder_on_text;\n  b->builder.on_error = my_xml_builder_on_error;\n  b->builder.destroy = my_xml_builder_destroy;\n\n  b->level = 0;\n  b->doc = doc;\n  b->node = doc->root;\n  str_init(&(b->str), 100);\n\n  return (XmlBuilder*)b;\n}\n\nconf_doc_t* conf_doc_load_xml(const char* data) {\n  conf_doc_t* doc = NULL;\n  return_value_if_fail(data != NULL, NULL);\n\n  doc = conf_doc_create(100);\n  return_value_if_fail(doc != NULL, NULL);\n\n  doc->max_deep_level = 20;\n  doc->root = conf_doc_create_node(doc, CONF_NODE_ROOT_NAME);\n  if (doc->root == NULL) {\n    TKMEM_FREE(doc);\n    return NULL;\n  } else {\n    xml_builter_t b;\nXmlParser* p = ",
    "raw_res": "0;",
    "prompt_res": "xml_parser_create();",
    "gt": "xml_parser_create();"
  },
  {
    "id": 2046,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/asset_loader_default.c",
    "input": "﻿/**\n * File:   asset_loader_default.c\n * Author: AWTK Develop Team\n * Brief:  asset_loader_default\n *\n * Copyright (c) 2019 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2020-02-26 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/fs.h\"\n#include \"base/asset_loader_default.h\"\n\n#define MMAP_ASSET_MIN_SIZE 4 * 1024\n\nstatic asset_info_t* load_asset_with_mmap(uint16_t type, uint16_t subtype, const char* path,\n                                          const char* name) {\n#ifdef LOAD_ASSET_WITH_MMAP\n  if (file_get_size(path) >= MMAP_ASSET_MIN_SIZE) {\n    asset_info_t* info = asset_info_create(type, subtype, name, 0);\n    return_value_if_fail(info != NULL, NULL);\n\n    info->map = mmap_create(path, FALSE, FALSE);\n    if (info->map != NULL) {\n      info->data = info->map->data;\n      info->size = info->map->size;\n      return info;\n    } else {\n      asset_info_destroy(info);\n    }\n  }\n#endif /*LOAD_ASSET_WITH_MMAP*/\n  return NULL;\n}\n\n#ifdef WITH_SDL\n#include <SDL.h>\nstatic asset_info_t* load_asset(uint16_t type, uint16_t subtype, const char* path,\n                                const char* name) {\n  asset_info_t* info = load_asset_with_mmap(type, subtype, path, name);\n  if (info == NULL) {\n    SDL_RWops* rwops = SDL_RWFromFile(path, \"rb\");\n    if (rwops != NULL) {\n      int32_t size = rwops->size(rwops);\ninfo = ",
    "raw_res": "asset_info_create(type, subtype, name, 0);",
    "prompt_res": "asset_info_create(type, subtype, name, size);",
    "gt": "asset_info_create(type, subtype, name, size);"
  },
  {
    "id": 2057,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/bitmap.c",
    "input": "﻿/**\n * File:   bitmap.c\n * Author: AWTK Develop Team\n * Brief:  bitmap interface\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-13 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"base/pixel.h\"\n#include \"base/bitmap.h\"\n#include \"base/graphic_buffer.h\"\n\nbitmap_t* bitmap_create(void) {\n  bitmap_t* bitmap = TKMEM_ZALLOC(bitmap_t);\n  return_value_if_fail(bitmap != NULL, NULL);\n\n  bitmap->should_free_handle = TRUE;\n\n  return bitmap;\n}\n\nret_t bitmap_destroy_with_self(bitmap_t* bitmap) {\n  return_value_if_fail(bitmap != NULL, RET_BAD_PARAMS);\n  bitmap->should_free_handle = TRUE;\n\n  return bitmap_destroy(bitmap);\n}\n\nret_t bitmap_destroy(bitmap_t* bitmap) {\n  return_value_if_fail(bitmap != NULL, RET_BAD_PARAMS);\n\n  if (bitmap->specific_destroy != NULL) {\n    bitmap->specific_destroy(bitmap);\n  }\n\n  if (bitmap->destroy != NULL) {\n    bitmap->destroy(bitmap);\n  }\n\n  if (bitmap->should_free_data) {\n    if (bitmap->buffer != NULL) {\n      graphic_buffer_destroy(bitmap->buffer);\n    }\n\n    if (bitmap->gif_delays != NULL) {\n      TKMEM_FREE(bitmap->gif_delays);\n      bitmap->gif_delays = NULL;\n    }\n\n    TKMEM_FREE(bitmap->data_free_ptr);\n  }\n\n  if (bitmap->should_free_handle) {\n    memset(bitmap, 0x00, sizeof(bitmap_t));\n    TKMEM_FREE(bitmap);\n  } else {\n    memset(bitmap, 0x00, sizeof(bitmap_t));\n  }\n\n  return RET_OK;\n}\n\n#include \"base/pixel_pack_unpack.h\"\n\nuint32_t bitmap_get_bpp_of_format(bitmap_format_t format) {\n  switch (format) {\n    case BITMAP_FMT_RGBA8888:\n    case BITMAP_FMT_ABGR8888:\n    case BITMAP_FMT_BGRA8888:\n    case BITMAP_FMT_ARGB8888:\n      return 4;\n    case BITMAP_FMT_RGB565:\n    case BITMAP_FMT_BGR565:\n      return 2;\n    case BITMAP_FMT_RGB888:\n    case BITMAP_FMT_BGR888:\n      return 3;\n    case BITMAP_FMT_GRAY:\n      return 1;\n    default:\n      break;\n  }\n\n  return 0;\n}\n\nuint32_t bitmap_get_bpp(bitmap_t* bitmap) {\n  return_value_if_fail(bitmap != NULL, 0);\n\n  return bitmap_get_bpp_of_format((bitmap_format_t)(bitmap->format));\n}\n\nret_t bitmap_alloc_data(bitmap_t* bitmap) {\n  return_value_if_fail(bitmap != NULL && bitmap->w > 0 && bitmap->h > 0, RET_BAD_PARAMS);\n\n  return GRAPHIC_BUFFER_CREATE_FOR_BITMAP(bitmap);\n}\n\nbool_t bitmap_flag_is_lcd_orientation(bitmap_t* bitmap) {\n  return bitmap->flags & BITMAP_FLAG_LCD_ORIENTATION;\n}\n\n#ifdef AWTK_WEB\n#include <emscripten.h>\nstatic ret_t bitmap_web_destroy(bitmap_t* bitmap) {\n  int32_t id = tk_pointer_to_int(bitmap->specific);\n  EM_ASM_INT({ return VGCanvas.destroyMutableImage($0); }, id);\n\n  return RET_OK;\n}\n\n#endif /*AWTK_WEB*/\n\nbitmap_t* bitmap_create_ex(uint32_t w, uint32_t h, uint32_t line_length, bitmap_format_t format) {\n  bitmap_t* bitmap = TKMEM_ZALLOC(bitmap_t);\n  uint32_t bpp = bitmap_get_bpp_of_format(format);\n\n  return_value_if_fail(bitmap != NULL, NULL);\n\n  bitmap->w = w;\n  bitmap->h = h;\n  bitmap->format = format;\n  bitmap->should_free_handle = TRUE;\n\n  if (bpp < 4) {\n    bitmap->flags = BITMAP_FLAG_OPAQUE;\n  }\n\n  bitmap_set_line_length(bitmap, line_length);\n\n  bitmap_alloc_data(bitmap);\n  if (bitmap->buffer == NULL) {\n    TKMEM_FREE(bitmap);\n    bitmap = NULL;\n  } else {\n#ifdef AWTK_WEB\n    uint8_t* data = bitmap_lock_buffer_for_write(bitmap);\n    return_value_if_fail(format == BITMAP_FMT_RGBA8888, NULL);\n    int32_t id = EM_ASM_INT({ return VGCanvas.createMutableImage($0, $1, $2, $3, $4); }, data, w, h,\n                            line_length, format);\n    bitmap->specific = tk_pointer_from_int(id);\n    bitmap->specific_destroy = bitmap_web_destroy;\n    bitmap_unlock_buffer(bitmap);\n#endif /*AWTK_WEB*/\n  }\n\n  return bitmap;\n}\n\nret_t bitmap_get_pixel(bitmap_t* bitmap, uint32_t x, uint32_t y, rgba_t* rgba) {\n  ret_t ret = RET_OK;\n  const uint8_t* data = NULL;\n  uint8_t* bitmap_data = NULL;\n  uint32_t w = bitmap_get_physical_width(bitmap);\n  uint32_t h = bitmap_get_physical_height(bitmap);\n  uint32_t bpp = bitmap_get_bpp(bitmap);\n  return_value_if_fail(bitmap != NULL && bitmap->buffer != NULL && rgba != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(x < w && y < h, RET_BAD_PARAMS);\n\nbitmap_data = ",
    "raw_res": "0;",
    "prompt_res": "bitmap_lock_buffer_for_read(bitmap);",
    "gt": "bitmap_lock_buffer_for_read(bitmap);"
  },
  {
    "id": 2143,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/canvas.c",
    "input": "﻿/**\n * File:   canvas.c\n * Author: AWTK Develop Team\n * Brief:  canvas provides basic drawings functions.\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-13 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/wstr.h\"\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/utils.h\"\n#include \"base/bidi.h\"\n#include \"base/canvas.h\"\n#include \"base/vgcanvas.h\"\n#include \"tkc/time_now.h\"\n#include \"tkc/color_parser.h\"\n#include \"base/system_info.h\"\n\n#include \"base/lcd_profile.h\"\n\n#ifndef CANVAS_MEASURE_TEXT_CACHE_MAX_LENGTH\n#define CANVAS_MEASURE_TEXT_CACHE_MAX_LENGTH 127\n#endif\n\nstatic ret_t canvas_draw_fps(canvas_t* c);\nstatic ret_t canvas_draw_icon_ex(canvas_t* c, bitmap_t* img, const rect_t* src_r, xy_t cx, xy_t cy);\nstatic ret_t canvas_draw_image_center_ex(canvas_t* c, bitmap_t* img, const rect_t* src_r,\n                                         const rect_t* dst_in);\n\nstatic bool_t bitmap_check_rect(bitmap_t* img, const rect_t* r) {\n  return_value_if_fail(img != NULL && r != NULL, FALSE);\n\n  return r->x >= 0 && r->y >= 0 && r->w > 0 && r->h > 0 && (r->x + r->w) <= img->w &&\n         (r->y + r->h) <= img->h;\n}\n\nstatic rect_t* canvas_fix_rect(const rect_t* r, rect_t* o) {\n  if (r != NULL) {\n    *o = *r;\n\n    if (o->w < 0) {\n      o->w = -o->w;\n      o->x = o->x - o->w + 1;\n    }\n\n    if (o->h < 0) {\n      o->h = -o->h;\n      o->y = o->y - o->h + 1;\n    }\n\n    return o;\n  } else {\n    return NULL;\n  }\n}\n\nret_t canvas_translate(canvas_t* c, xy_t dx, xy_t dy) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  c->ox += dx;\n  c->oy += dy;\n\n  return RET_OK;\n}\n\nret_t canvas_untranslate(canvas_t* c, xy_t dx, xy_t dy) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  c->ox -= dx;\n  c->oy -= dy;\n\n  return RET_OK;\n}\n\ncanvas_t* canvas_init(canvas_t* c, lcd_t* lcd, font_manager_t* font_manager) {\n  return_value_if_fail(c != NULL && lcd != NULL && font_manager != NULL, NULL);\n\n  memset(c, 0x00, sizeof(canvas_t));\n\n  c->lcd = lcd_profile_create(lcd);\n  c->font_manager = font_manager;\n\n  c->clip_left = 0;\n  c->clip_top = 0;\n  c->clip_right = canvas_get_width(c) - 1;\n  c->clip_bottom = canvas_get_height(c) - 1;\n\n  c->last_text_str = TKMEM_ZALLOCN(wchar_t, CANVAS_MEASURE_TEXT_CACHE_MAX_LENGTH + 1);\n  return c;\n}\n\nwh_t canvas_get_width(canvas_t* c) {\n  return_value_if_fail(c != NULL, 0);\n\n  return lcd_get_width(c->lcd);\n}\n\nwh_t canvas_get_height(canvas_t* c) {\n  return_value_if_fail(c != NULL, 0);\n\n  return lcd_get_height(c->lcd);\n}\n\nret_t canvas_set_font_manager(canvas_t* c, font_manager_t* font_manager) {\n  return_value_if_fail(c != NULL && font_manager != NULL, RET_BAD_PARAMS);\n\n  c->font_manager = font_manager;\n\n  return RET_OK;\n}\n\nret_t canvas_set_assets_manager(canvas_t* c, assets_manager_t* assets_manager) {\n  vgcanvas_t* vgcanvas = NULL;\n  return_value_if_fail(c != NULL && assets_manager != NULL, RET_BAD_PARAMS);\n\n  vgcanvas = lcd_get_vgcanvas(c->lcd);\n  c->assets_manager = assets_manager;\n  if (vgcanvas != NULL) {\n    vgcanvas_set_assets_manager(vgcanvas, assets_manager);\n  }\n  if (c->font_manager != NULL) {\n    font_manager_set_assets_manager(c->font_manager, assets_manager);\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_get_clip_rect(canvas_t* c, rect_t* r) {\n  return_value_if_fail(c != NULL && r != NULL, RET_BAD_PARAMS);\n\n  r->x = c->clip_left;\n  r->y = c->clip_top;\n  r->w = c->clip_right - c->clip_left + 1;\n  r->h = c->clip_bottom - c->clip_top + 1;\n\n  if (c->lcd->get_clip_rect != NULL) {\n    return lcd_get_clip_rect(c->lcd, r);\n  }\n  return RET_OK;\n}\n\nbool_t canvas_is_rect_in_clip_rect(canvas_t* c, xy_t left, xy_t top, xy_t right, xy_t bottom) {\n  if (c->lcd->is_rect_in_clip_rect != NULL) {\n    return c->lcd->is_rect_in_clip_rect(c->lcd, left, top, right, bottom);\n  } else {\n    if (left > c->clip_right || right < c->clip_left || top > c->clip_bottom ||\n        bottom < c->clip_top) {\n      return FALSE;\n    }\n    return TRUE;\n  }\n}\n\nret_t canvas_set_clip_rect(canvas_t* c, const rect_t* r_in) {\n  wh_t lcd_w = 0;\n  wh_t lcd_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* r = canvas_fix_rect(r_in, &r_fix);\n\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  lcd_w = lcd_get_width(c->lcd);\n  lcd_h = lcd_get_height(c->lcd);\n\n  if (c->lcd->set_clip_rect != NULL) {\n    if (r != NULL) {\n      rect_t clip_r = rect_init(tk_max(0, r->x), tk_max(0, r->y), tk_max(0, r->w), tk_max(0, r->h));\n      lcd_set_clip_rect(c->lcd, &clip_r);\n    } else {\n      rect_t clip_r = rect_init(0, 0, lcd_w, lcd_h);\n      lcd_set_clip_rect(c->lcd, &clip_r);\n    }\n#ifdef WITH_GPU\n    /* 兼容以前的逻辑，以免以前的用户不使用 canvas_is_rect_in_clip_rect 来判断出问题 */\n    /* 把 canvas 的裁剪区设置为无限大，在 opengl 的状态下让 vg 来处理裁剪区的问题 */\n    c->clip_left = 0;\n    c->clip_top = 0;\n    c->clip_right = 0x7fffffff;\n    c->clip_bottom = 0x7fffffff;\n#endif\n  } else {\n    if (r != NULL) {\n      c->clip_left = tk_max(0, r->x);\n      c->clip_top = tk_max(0, r->y);\n      c->clip_right = tk_min(lcd_w - 1, r->x + r->w - 1);\n      c->clip_bottom = tk_min(lcd_h - 1, r->y + r->h - 1);\n    } else {\n      c->clip_left = 0;\n      c->clip_top = 0;\n      c->clip_right = lcd_w - 1;\n      c->clip_bottom = lcd_h - 1;\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_set_clip_rect_ex(canvas_t* c, const rect_t* r_in, bool_t translate) {\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* r = canvas_fix_rect(r_in, &r_fix);\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  if (r != NULL && translate) {\n    rect_t rr = *r;\n\n    rr.x += c->ox;\n    rr.y += c->oy;\n    return canvas_set_clip_rect(c, &rr);\n  } else {\n    return canvas_set_clip_rect(c, r);\n  }\n}\n\nret_t canvas_set_fill_color(canvas_t* c, color_t color) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  lcd_set_fill_color(c->lcd, color);\n\n  return RET_OK;\n}\n\nret_t canvas_set_text_color(canvas_t* c, color_t color) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  lcd_set_text_color(c->lcd, color);\n\n  return RET_OK;\n}\n\nret_t canvas_set_stroke_color(canvas_t* c, color_t color) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  lcd_set_stroke_color(c->lcd, color);\n\n  return RET_OK;\n}\n\nret_t canvas_set_global_alpha(canvas_t* c, uint8_t alpha) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  c->global_alpha = alpha;\n  lcd_set_global_alpha(c->lcd, alpha);\n\n  return RET_OK;\n}\n\nret_t canvas_set_font(canvas_t* c, const char* name, font_size_t size) {\n  return_value_if_fail(c != NULL && c->lcd != NULL, RET_BAD_PARAMS);\n\n  name = system_info_fix_font_name(name);\n  size = system_info()->font_scale * size;\n\n  if (c->font_size != size) {\n    c->font_size = size;\n    c->last_text_length = 0;\n  }\n  if (!tk_str_eq(name, c->font_name)) {\n    c->last_text_length = 0;\n    c->font_name = tk_str_copy(c->font_name, name);\n  }\n\n  if (c->last_text_length == 0) {\n    if (c->lcd->set_font_name != NULL) {\n      lcd_set_font_name(c->lcd, c->font_name);\n      lcd_set_font_size(c->lcd, size);\n    } else {\n      c->font = font_manager_get_font(c->font_manager, c->font_name, c->font_size);\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_reset_font(canvas_t* c) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  c->font_size = 0;\n  c->last_text_length = 0;\n  c->font = NULL;\n  TKMEM_FREE(c->font_name);\n\n  return RET_OK;\n}\n\nret_t canvas_set_text_align(canvas_t* c, align_h_t align_h, align_v_t align_v) {\n  return_value_if_fail(c != NULL && c->lcd != NULL, RET_BAD_PARAMS);\n\n  c->text_align_h = align_h;\n  c->text_align_v = align_v;\n\n  return RET_OK;\n}\n\nstatic float_t canvas_measure_text_default(canvas_t* c, const wchar_t* str, uint32_t nr) {\n  glyph_t g;\n  float_t w = 0;\n  uint32_t i = 0;\n  return_value_if_fail(c != NULL && str != NULL && c->font != NULL, 0);\n\n  for (i = 0; i < nr; i++) {\n    wchar_t chr = str[i];\n    if (font_get_glyph(c->font, chr, c->font_size, &g) == RET_OK) {\n      w += g.advance + 1;\n    } else {\n      w += 4;\n    }\n  }\n\n  return w;\n}\n\nfloat_t canvas_measure_text(canvas_t* c, const wchar_t* str, uint32_t nr) {\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, 0);\n\n  if (c->last_text_length != 0 && c->last_text_nr == nr && tk_wstr_eq(c->last_text_str, str)) {\n    return c->last_text_length;\n  } else {\n    if (nr > CANVAS_MEASURE_TEXT_CACHE_MAX_LENGTH) {\n      c->last_text_nr = 0;\n      c->last_text_str[0] = 0;\n    } else {\n      tk_memcpy(c->last_text_str, str, nr * sizeof(wchar_t));\n      c->last_text_nr = nr;\n      c->last_text_str[nr] = 0;\n    }\n  }\n\n  if (c->lcd->measure_text) {\n    c->last_text_length = lcd_measure_text(c->lcd, str, nr);\n  } else {\n    c->last_text_length = canvas_measure_text_default(c, str, nr);\n  }\n  return c->last_text_length;\n}\n\nfloat_t canvas_measure_utf8(canvas_t* c, const char* str) {\n  wstr_t s;\n  float_t ret = 0;\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, 0);\n\n  wstr_init(&s, 0);\n  return_value_if_fail(wstr_set_utf8(&s, str) == RET_OK, 0);\n\n  ret = canvas_measure_text(c, s.str, s.size);\n  wstr_reset(&s);\n\n  return ret;\n}\n\nret_t canvas_begin_frame(canvas_t* c, const dirty_rects_t* dirty_rects, lcd_draw_mode_t draw_mode) {\n  rect_t dirty_rect;\n  ret_t ret = RET_OK;\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  if (c->began_frame) {\n    return RET_OK;\n  } else {\n    c->began_frame = TRUE;\n  }\n\n  if (c->begin_frame) {\n    return c->begin_frame(c, dirty_rects, draw_mode);\n  }\n\n  c->ox = 0;\n  c->oy = 0;\n\n  canvas_set_global_alpha(c, 0xff);\n  lcd_set_canvas(c->lcd, c);\n  /* 把当前帧的脏矩形列表传入到 lcd 中和 fb 的脏矩形列表合并得出新的脏矩形列表。*/\n  if (c->lcd->support_dirty_rect) {\n    ret = lcd_begin_frame(c->lcd, dirty_rects, draw_mode);\n  } else {\n    ret = lcd_begin_frame(c->lcd, NULL, draw_mode);\n  }\n  return_value_if_fail(ret == RET_OK, ret);\n  /* 获取新的最大的脏矩形，然后设置裁剪区 */\n  ret = lcd_get_dirty_rect(c->lcd, &dirty_rect);\n  if (c->lcd->support_dirty_rect && ret == RET_OK) {\n    if (draw_mode == LCD_DRAW_NORMAL && c->lcd->type == LCD_VGCANVAS) {\n      rect_t r = dirty_rect;\n\n      /*for vgcanvas anti alias*/\n      r.x--;\n      r.y--;\n      r.w += 2;\n      r.h += 2;\n\n      canvas_set_clip_rect(c, &r);\n    } else {\n      canvas_set_clip_rect(c, &dirty_rect);\n    }\n  } else {\n    canvas_set_clip_rect(c, NULL);\n  }\n\n  return ret;\n}\n\nstatic ret_t canvas_draw_hline_impl(canvas_t* c, xy_t x, xy_t y, wh_t w) {\n  rect_t r;\n  xy_t x2 = x + w - 1;\n\n  if (!canvas_is_rect_in_clip_rect(c, x, y, x2, y)) {\n    return RET_OK;\n  }\n  canvas_get_clip_rect(c, &r);\n\n  x = tk_max(x, r.x);\n  x2 = tk_min(x2, r.x + r.w - 1);\n  w = x2 - x + 1;\n\n  return lcd_draw_hline(c->lcd, x, y, w);\n}\n\nret_t canvas_draw_hline(canvas_t* c, xy_t x, xy_t y, wh_t w) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  if (w < 0) {\n    w = -w;\n    x = x - w + 1;\n  }\n\n  return canvas_draw_hline_impl(c, c->ox + x, c->oy + y, w);\n}\n\nstatic ret_t canvas_draw_vline_impl(canvas_t* c, xy_t x, xy_t y, wh_t h) {\n  rect_t r;\n  xy_t y2 = y + h - 1;\n\n  if (!canvas_is_rect_in_clip_rect(c, x, y, x, y2)) {\n    return RET_OK;\n  }\n  canvas_get_clip_rect(c, &r);\n\n  y = tk_max(y, r.y);\n  y2 = tk_min(y2, r.y + r.h - 1);\n  h = y2 - y + 1;\n\n  return lcd_draw_vline(c->lcd, x, y, h);\n}\n\nret_t canvas_draw_vline(canvas_t* c, xy_t x, xy_t y, wh_t h) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  if (h < 0) {\n    h = -h;\n    y = y - h + 1;\n  }\n\n  return canvas_draw_vline_impl(c, c->ox + x, c->oy + y, h);\n}\n\nstatic ret_t canvas_draw_line_impl(canvas_t* c, xy_t x1, xy_t y1, xy_t x2, xy_t y2) {\n  if (x1 == x2) {\n    return canvas_draw_vline_impl(c, x1, y1, tk_abs(y2 - y1) + 1);\n  } else if (y1 == y2) {\n    return canvas_draw_hline_impl(c, x1, y1, tk_abs(x2 - x1) + 1);\n  } else {\n    assert(!\"Not implemented yet, please use vgcanvas to draw line\");\n    return RET_NOT_IMPL;\n  }\n}\n\nret_t canvas_draw_line(canvas_t* c, xy_t x1, xy_t y1, xy_t x2, xy_t y2) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  return canvas_draw_line_impl(c, c->ox + x1, c->oy + y1, c->ox + x2, c->oy + y2);\n}\n\n#define MAX_POINTS_PER_DRAW 20\n\nstatic ret_t canvas_do_draw_points(canvas_t* c, const point_t* points, uint32_t nr) {\n  uint32_t i = 0;\n  uint32_t real_nr = 0;\n\n  point_t real_points[MAX_POINTS_PER_DRAW];\n  return_value_if_fail(nr <= MAX_POINTS_PER_DRAW, RET_BAD_PARAMS);\n\n  for (i = 0; i < nr; i++) {\n    const point_t* p = points + i;\n    xy_t x = p->x + c->ox;\n    xy_t y = p->y + c->oy;\n    if (!canvas_is_rect_in_clip_rect(c, x, y, x, y)) {\n      continue;\n    }\n\n    real_points[real_nr].x = x;\n    real_points[real_nr].y = y;\n\n    real_nr++;\n  }\n\n  return lcd_draw_points(c->lcd, real_points, real_nr);\n}\n\nstatic ret_t canvas_draw_points_impl(canvas_t* c, const point_t* points, uint32_t nr) {\n  uint32_t i = 0;\n  const point_t* p = points;\n  uint32_t n = (nr / MAX_POINTS_PER_DRAW);\n  uint32_t r = (nr % MAX_POINTS_PER_DRAW);\n\n  for (i = 0; i <= n; i++) {\n    if (i == n) {\n      canvas_do_draw_points(c, p, r);\n    } else {\n      canvas_do_draw_points(c, p, MAX_POINTS_PER_DRAW);\n      p += MAX_POINTS_PER_DRAW;\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_draw_points(canvas_t* c, const point_t* points, uint32_t nr) {\n  return_value_if_fail(c != NULL && points != NULL, RET_BAD_PARAMS);\n\n  return canvas_draw_points_impl(c, points, nr);\n}\n\nstatic ret_t canvas_fill_rect_impl(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  rect_t r;\n  xy_t x2 = x + w - 1;\n  xy_t y2 = y + h - 1;\n\n  if (!canvas_is_rect_in_clip_rect(c, x, y, x2, y2)) {\n    return RET_OK;\n  }\n  canvas_get_clip_rect(c, &r);\n\n  x = tk_max(x, r.x);\n  y = tk_max(y, r.y);\n  x2 = tk_min(x2, r.x + r.w - 1);\n  y2 = tk_min(y2, r.y + r.h - 1);\n  w = x2 - x + 1;\n  h = y2 - y + 1;\n\n  return lcd_fill_rect(c->lcd, x, y, w, h);\n}\n\nret_t canvas_fill_rect(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  fix_xywh(x, y, w, h);\n  return canvas_fill_rect_impl(c, c->ox + x, c->oy + y, w, h);\n}\n\nstatic ret_t canvas_fill_rect_gradient_impl(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h,\n                                            gradient_t* gradient) {\n  rect_t r;\n  xy_t x2 = x + w - 1;\n  xy_t y2 = y + h - 1;\n  vgcanvas_t* vg = NULL;\n\n  if (!canvas_is_rect_in_clip_rect(c, x, y, x2, y2)) {\n    return RET_OK;\n  }\n\n  canvas_get_clip_rect(c, &r);\n\n  x = tk_max(x, r.x);\n  y = tk_max(y, r.y);\n  x2 = tk_min(x2, r.x + r.w - 1);\n  y2 = tk_min(y2, r.y + r.h - 1);\n  w = x2 - x + 1;\n  h = y2 - y + 1;\n  if (w == 0 || h == 0) {\n    return RET_OK;\n  }\n\n  /*FIXME: to support general cases*/\n  return_value_if_fail(gradient->type == GRADIENT_LINEAR && gradient->degree == 180,\n                       RET_BAD_PARAMS);\n\n#ifndef WITH_GPU\n  if (gradient->type == GRADIENT_LINEAR) {\n    if (gradient->degree == 180) {\n      uint32_t i = 0;\n      lcd_t* lcd = c->lcd;\n      for (i = 0; i < h; i++) {\n        float offset = (float)i / (float)h;\n        color_t color = gradient_get_color(gradient, offset);\n        lcd_set_stroke_color(lcd, color);\n        lcd_draw_hline(lcd, x, y + i, w);\n      }\n      return RET_OK;\n    }\n  }\n#endif\n  vg = canvas_get_vgcanvas(c);\n  if (vg != NULL) {\n    vg_gradient_t vg_gradient;\n    rect_t rect = {x, y, w, h};\n    vgcanvas_save(vg);\n    vgcanvas_set_antialias(vg, FALSE);\n    vg_gradient_init_with_gradient(&vg_gradient, &rect, gradient);\n    vgcanvas_set_fill_gradient(vg, &vg_gradient);\n    vgcanvas_rect(vg, x, y, w, h);\n    vgcanvas_fill(vg);\n    vgcanvas_restore(vg);\n  }\n\n  return RET_NOT_IMPL;\n}\n\nret_t canvas_fill_rect_gradient(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h, gradient_t* gradient) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  fix_xywh(x, y, w, h);\n  return canvas_fill_rect_gradient_impl(c, c->ox + x, c->oy + y, w, h, gradient);\n}\n\nstatic ret_t canvas_clear_rect_impl(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  rect_t r;\n  xy_t x2 = x + w - 1;\n  xy_t y2 = y + h - 1;\n\n  if (!canvas_is_rect_in_clip_rect(c, x, y, x2, y2)) {\n    return RET_OK;\n  }\n\n  canvas_get_clip_rect(c, &r);\n\n  x = tk_max(x, r.x);\n  y = tk_max(y, r.y);\n  x2 = tk_min(x2, r.x + r.w - 1);\n  y2 = tk_min(y2, r.y + r.h - 1);\n  w = x2 - x + 1;\n  h = y2 - y + 1;\n\n  return lcd_clear_rect(c->lcd, x, y, w, h);\n}\n\nret_t canvas_clear_rect(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  fix_xywh(x, y, w, h);\n  return canvas_clear_rect_impl(c, c->ox + x, c->oy + y, w, h);\n}\n\nstatic ret_t canvas_stroke_rect_impl(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return_value_if_fail(c != NULL && c->lcd != NULL && w > 0 && h > 0, RET_BAD_PARAMS);\n\n  if (c->lcd->stroke_rect != NULL) {\n    lcd_stroke_rect(c->lcd, x, y, w, h);\n  } else {\n    canvas_draw_hline_impl(c, x, y, w);\n    canvas_draw_hline_impl(c, x, y + h - 1, w);\n    canvas_draw_vline_impl(c, x, y, h);\n    canvas_draw_vline_impl(c, x + w - 1, y, h);\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_stroke_rect(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  fix_xywh(x, y, w, h);\n  return canvas_stroke_rect_impl(c, c->ox + x, c->oy + y, w, h);\n}\n\nstatic ret_t canvas_draw_glyph(canvas_t* c, glyph_t* g, xy_t x, xy_t y) {\n  rect_t r;\n  rect_t src;\n  rect_t dst;\n  xy_t x2 = x + g->w - 1;\n  xy_t y2 = y + g->h - 1;\n\n  if (g->data == NULL || !canvas_is_rect_in_clip_rect(c, x, y, x2, y2)) {\n    return RET_OK;\n  }\n  canvas_get_clip_rect(c, &r);\n\n  dst.x = tk_max(x, r.x);\n  dst.y = tk_max(y, r.y);\n  dst.w = tk_min(x2, r.x + r.w - 1) - dst.x + 1;\n  dst.h = tk_min(y2, r.y + r.h - 1) - dst.y + 1;\n\n  src.x = dst.x - x;\n  src.y = dst.y - y;\n  src.w = dst.w;\n  src.h = dst.h;\n\n  return lcd_draw_glyph(c->lcd, g, &src, dst.x, dst.y);\n}\n\nstatic ret_t canvas_draw_char_impl(canvas_t* c, wchar_t chr, xy_t x, xy_t y) {\n  glyph_t g;\n  font_size_t font_size = c->font_size;\n  font_vmetrics_t vmetrics = font_get_vmetrics(c->font, c->font_size);\n  return_value_if_fail(font_get_glyph(c->font, chr, font_size, &g) == RET_OK, RET_BAD_PARAMS);\n\n  x += g.x;\n  y += vmetrics.ascent + g.y;\n\n  return canvas_draw_glyph(c, &g, x, y);\n}\n\nret_t canvas_draw_char(canvas_t* c, wchar_t chr, xy_t x, xy_t y) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  return canvas_draw_char_impl(c, chr, c->ox + x, c->oy + y);\n}\n\nstatic ret_t canvas_draw_text_impl(canvas_t* c, const wchar_t* str, uint32_t nr, xy_t x, xy_t y,\n                                   bool_t line_breaker) {\n  glyph_t g;\n  uint32_t i = 0;\n  xy_t left = x;\n  font_vmetrics_t vmetrics = font_get_vmetrics(c->font, c->font_size);\n  font_size_t font_size = c->font_size;\n  int32_t baseline = vmetrics.ascent;\n  return_value_if_fail(c->font != NULL, RET_BAD_PARAMS);\n  for (i = 0; i < nr; i++) {\n    wchar_t chr = str[i];\n\n    if (chr == '\\r' || chr == '\\n') {\n      if ((i + 1) == nr) {\n        break;\n      }\n\n      if (chr == '\\r' && str[i + 1] == '\\n') {\n        i++;\n      }\n\n      if (line_breaker) {\n        y += font_size;\n        x = left;\n        continue;\n      } else {\n        chr = ' ';\n      }\n    }\n\n    if (font_get_glyph(c->font, chr, c->font_size, &g) == RET_OK) {\n      xy_t xx = x + g.x;\n      xy_t yy = y + g.y + baseline;\n\n      canvas_draw_glyph(c, &g, xx, yy);\n      x += g.advance + 1;\n    } else {\n      x += 4;\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_draw_text(canvas_t* c, const wchar_t* str, uint32_t nr, xy_t x, xy_t y) {\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, RET_BAD_PARAMS);\n  if (c->lcd->draw_text != NULL) {\n    return lcd_draw_text(c->lcd, str, nr, c->ox + x, c->oy + y);\n  } else {\n    return canvas_draw_text_impl(c, str, nr, c->ox + x, c->oy + y, FALSE);\n  }\n}\n\nret_t canvas_draw_utf8(canvas_t* c, const char* str, xy_t x, xy_t y) {\n  wstr_t s;\n  ret_t ret = RET_FAIL;\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, RET_BAD_PARAMS);\n\n  wstr_init(&s, 0);\n  return_value_if_fail(wstr_set_utf8(&s, str) == RET_OK, RET_OOM);\n\n  ret = canvas_draw_text(c, s.str, s.size, x, y);\n  wstr_reset(&s);\n\n  return ret;\n}\n\nstatic ret_t canvas_do_draw_image(canvas_t* c, bitmap_t* img, const rect_t* s, const rect_t* d) {\n  rect_t r;\n  rectf_t src;\n  rectf_t dst;\n  float_t scale_w = 0;\n  float_t scale_h = 0;\n\n  xy_t x = d->x;\n  xy_t y = d->y;\n  xy_t x2 = d->x + d->w - 1;\n  xy_t y2 = d->y + d->h - 1;\n\n  if (d->w <= 0 || d->h <= 0 || s->w <= 0 || s->h <= 0 ||\n      !canvas_is_rect_in_clip_rect(c, x, y, x2, y2)) {\n    return RET_OK;\n  }\n  canvas_get_clip_rect(c, &r);\n\n  dst.x = tk_max(x, r.x);\n  dst.y = tk_max(y, r.y);\n  dst.w = tk_min(x2, r.x + r.w - 1) - dst.x + 1;\n  dst.h = tk_min(y2, r.y + r.h - 1) - dst.y + 1;\n\n  /* 因为 blend 函数中缩放，使用 256 倍的定点数，所以这里为了减低多次转换数据出现误差 */\n  scale_w = ((s->w << 8) / d->w / 256.0f);\n  scale_h = ((s->h << 8) / d->h / 256.0f);\n\n  src.x = s->x + (dst.x - x) * scale_w;\n  src.y = s->y + (dst.y - y) * scale_h;\n  src.w = dst.w * s->w / d->w;\n  src.h = dst.h * s->h / d->h;\n\n  if (src.x >= img->w || src.y >= img->h) {\n    return RET_OK;\n  }\n\n  src.w = tk_min((img->w - src.x), src.w);\n  src.h = tk_min((img->h - src.y), src.h);\n\n  if (src.w <= 0 || src.h <= 0 || dst.w <= 0 || dst.h <= 0) {\n    return RET_OK;\n  }\n\n  return lcd_draw_image(c->lcd, img, &src, &dst);\n}\n\nret_t canvas_draw_image(canvas_t* c, bitmap_t* img, const rect_t* src, const rect_t* dst_in) {\n  rect_t d;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && src != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  d.x = c->ox + dst->x;\n  d.y = c->oy + dst->y;\n  d.w = dst->w;\n  d.h = dst->h;\n\n  return canvas_do_draw_image(c, img, src, &d);\n}\n\nstatic ret_t canvas_draw_image_repeat_default(canvas_t* c, bitmap_t* img, const rect_t* src_in,\n                                              const rect_t* dst_in, wh_t dst_w, wh_t dst_h) {\n  rect_t s;\n  rect_t d;\n  xy_t x = 0;\n  xy_t y = 0;\n  wh_t sw = 0;\n  wh_t sh = 0;\n  wh_t dw = 0;\n  wh_t dh = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL && src_in != NULL && dst_in != NULL,\n                       RET_BAD_PARAMS);\n\n  s.x = src_in->x;\n  s.y = src_in->y;\n  s.w = src_in->w;\n  s.h = src_in->h;\n\n  d = *dst;\n\n  while (y < dst->h) {\n    dh = tk_min(dst_h, dst->h - y);\n    sh = tk_min(src_in->h, dst->h - y);\n    while (x < dst->w) {\n      dw = tk_min(dst_w, dst->w - x);\n      sw = tk_min(src_in->w, dst->w - x);\n\n      s.w = sw;\n      s.h = sh;\n\n      d.w = dw;\n      d.h = dh;\n      d.x = x + dst->x;\n      d.y = y + dst->y;\n      canvas_draw_image(c, img, &s, &d);\n      x += dw;\n    }\n    y += dh;\n    x = 0;\n  }\n  return RET_OK;\n}\n\nstatic ret_t canvas_draw_image_repeat_x_impl(canvas_t* c, bitmap_t* img, const rect_t* src_in,\n                                             const rect_t* dst_in) {\n  rect_t d;\n  return_value_if_fail(\n      c != NULL && c->lcd != NULL && img != NULL && src_in != NULL && dst_in != NULL,\n      RET_BAD_PARAMS);\n  d.x = dst_in->x + c->ox;\n  d.y = dst_in->y + c->oy;\n  d.w = dst_in->w;\n  d.h = dst_in->h;\n\n  if (c->lcd->draw_image_repeat != NULL &&\n      c->lcd->draw_image_repeat(c->lcd, img, src_in, &d, src_in->w, dst_in->h) == RET_OK) {\n    return RET_OK;\n  }\n\n  return canvas_draw_image_repeat_default(c, img, src_in, dst_in, src_in->w, dst_in->h);\n}\n\nstatic ret_t canvas_draw_image_repeat_y_impl(canvas_t* c, bitmap_t* img, const rect_t* src_in,\n                                             const rect_t* dst_in) {\n  rect_t d;\n  return_value_if_fail(\n      c != NULL && c->lcd != NULL && img != NULL && src_in != NULL && dst_in != NULL,\n      RET_BAD_PARAMS);\n  d.x = dst_in->x + c->ox;\n  d.y = dst_in->y + c->oy;\n  d.w = dst_in->w;\n  d.h = dst_in->h;\n\n  if (c->lcd->draw_image_repeat != NULL &&\n      c->lcd->draw_image_repeat(c->lcd, img, src_in, &d, dst_in->w, src_in->h) == RET_OK) {\n    return RET_OK;\n  }\n\n  return canvas_draw_image_repeat_default(c, img, src_in, dst_in, dst_in->w, src_in->h);\n}\n\nstatic ret_t canvas_draw_image_repeat_impl(canvas_t* c, bitmap_t* img, const rect_t* src_in,\n                                           const rect_t* dst_in) {\n  rect_t d;\n  return_value_if_fail(\n      c != NULL && c->lcd != NULL && img != NULL && src_in != NULL && dst_in != NULL,\n      RET_BAD_PARAMS);\n  d.x = dst_in->x + c->ox;\n  d.y = dst_in->y + c->oy;\n  d.w = dst_in->w;\n  d.h = dst_in->h;\n\n  if (c->lcd->draw_image_repeat != NULL &&\n      c->lcd->draw_image_repeat(c->lcd, img, src_in, &d, src_in->w, src_in->h) == RET_OK) {\n    return RET_OK;\n  }\n\n  return canvas_draw_image_repeat_default(c, img, src_in, dst_in, src_in->w, src_in->h);\n}\n\nret_t canvas_draw_image_repeat(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  s.x = 0;\n  s.y = 0;\n  s.w = img->w;\n  s.h = img->h;\n  canvas_draw_image_repeat_impl(c, img, &s, dst_in);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_repeat9(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t x = 0;\n  xy_t y = 0;\n  wh_t w = 0;\n  wh_t h = 0;\n  wh_t w_w = 0;\n  wh_t h_h = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  wh_t image_w = 0;\n  wh_t image_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  image_w = tk_min(img_w, dst_w);\n  image_h = tk_min(img_h, dst_h);\n  w = image_w >> 1;\n  h = image_h >> 1;\n\n  w_w = dst_w - w * 2;\n  h_h = dst_h - h * 2;\n\n  /*draw four corners*/\n  /*left top*/\n  s = rect_init(0, 0, w, h);\n  d = rect_init(0, 0, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*right top*/\n  s = rect_init(img_w - w, 0, w, h);\n  d = rect_init(dst_w - w, 0, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*left bottom*/\n  s = rect_init(0, img_h - h, w, h);\n  d = rect_init(0, dst_h - h, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*right bottom*/\n  s = rect_init(img_w - w, img_h - h, w, h);\n  d = rect_init(dst_w - w, dst_h - h, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*fill center*/\n  x = w;\n  if (w_w > 0) {\n    int32_t tmp = image_w - w - w;\n    s = rect_init(tmp > 0 ? w : w - 1, 0, tmp > 0 ? tmp : 2, h);\n    d = rect_init(w, 0, w_w, h);\n    canvas_draw_image_repeat_x_impl(c, img, &s, &d);\n\n    s = rect_init(tmp > 0 ? w : w - 1, img_h - h, tmp > 0 ? tmp : 2, h);\n    d = rect_init(w, h + h_h, w_w, h);\n    canvas_draw_image_repeat_x_impl(c, img, &s, &d);\n  }\n\n  /*fill middle*/\n  y = h;\n  if (h_h > 0) {\n    int32_t tmp = image_h - h - h;\n    s = rect_init(0, tmp > 0 ? h : h - 1, w, tmp > 0 ? tmp : 2);\n    d = rect_init(0, h, w, h_h);\n    canvas_draw_image_repeat_y_impl(c, img, &s, &d);\n\n    s = rect_init(img_w - w, tmp > 0 ? h : h - 1, w, tmp > 0 ? tmp : 2);\n    d = rect_init(w + w_w, h, w, h_h);\n    canvas_draw_image_repeat_y_impl(c, img, &s, &d);\n  }\n\n  /*fill center/middle*/\n  if (w_w > 0 && h_h > 0) {\n    int32_t tmp_w = image_w - w - w;\n    int32_t tmp_h = image_h - h - h;\n    s = rect_init(tmp_w > 0 ? w : w - 1, tmp_h > 0 ? h : h - 1, tmp_w > 0 ? tmp_w : 2,\n                  tmp_h > 0 ? tmp_h : 2);\n    d = rect_init(w, h, w_w, h_h);\n    canvas_draw_image_repeat_impl(c, img, &s, &d);\n  }\n\n  canvas_untranslate(c, dst->x, dst->y);\n\n  (void)x;\n  (void)y;\n  (void)dst_w;\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_repeat_x(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  s.x = 0;\n  s.y = 0;\n  s.w = img->w;\n  s.h = img->h;\n\n  canvas_draw_image_repeat_x_impl(c, img, &s, dst_in);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_repeat3_x(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t y = 0;\n  wh_t w = 0;\n  wh_t w_w = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  wh_t image_w = 0;\n  int32_t tmp = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  image_w = tk_min(img_w, dst_w);\n  w = image_w >> 1;\n  w_w = dst_w - (w << 1);\n\n  y = (dst_h - img_h) >> 1;\n  if (y < 0) {\n    img_h += y;\n    y = 0;\n  }\n\n  /*left*/\n  s = rect_init(0, 0, w, img_h);\n  d = rect_init(0, y, w, img_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*center*/\n  tmp = image_w - w - w;\n  if (dst_w > img_w) {\n    s = rect_init(w, 0, tmp > 0 ? tmp : 2, img_h);\n    d = rect_init(w, y, w_w, img_h);\n    canvas_draw_image_repeat_x_impl(c, img, &s, &d);\n  }\n\n  /*right*/\n  s = rect_init(img_w - w, 0, w, img_h);\n  d = rect_init(dst_w - w, y, w, img_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  canvas_untranslate(c, dst->x, dst->y);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_repeat_y(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  s.x = 0;\n  s.y = 0;\n  s.w = img->w;\n  s.h = img->h;\n  canvas_draw_image_repeat_y_impl(c, img, &s, dst_in);\n  return RET_OK;\n}\n\nret_t canvas_draw_image_repeat3_y(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t x = 0;\n  wh_t h = 0;\n  wh_t h_h = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  wh_t image_h = 0;\n  int32_t tmp = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  image_h = tk_min(img_h, dst_h);\n  h = image_h >> 1;\n  h_h = dst_h - (h << 1);\n\n  x = (dst->w - img->w) >> 1;\n  if (x < 0) {\n    img_w += x;\n    x = 0;\n  }\n  /*top*/\n  s = rect_init(0, 0, img_w, h);\n  d = rect_init(x, 0, img_w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*middle*/\n  tmp = image_h - h - h;\n  if (dst_h > img_h) {\n    s = rect_init(0, tmp > 0 ? h : h - 1, img_w, tmp > 0 ? tmp : 2);\n    d = rect_init(x, h, img_w, h_h);\n    canvas_draw_image_repeat_y_impl(c, img, &s, &d);\n  }\n\n  /*bottom*/\n  s = rect_init(0, img_h - h, img_w, h);\n  d = rect_init(x, dst_h - h, img_w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  canvas_untranslate(c, dst->x, dst->y);\n  (void)dst_w;\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_repeat_y_inverse(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t y = 0;\n  wh_t h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  s.x = 0;\n  s.y = 0;\n  s.w = img->w;\n  s.h = img->h;\n\n  d = *dst;\n\n  while (y < dst->h) {\n    h = tk_min(img->h, dst->h - y);\n    s.h = h;\n    d.h = h;\n    y += h;\n    d.y = dst->y + (dst->h - y);\n\n    if (s.h < img->h) {\n      s.y = img->h - s.h;\n      canvas_draw_image(c, img, &s, &d);\n    } else {\n      s.y = 0;\n      canvas_draw_image(c, img, &s, &d);\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_patch3_y_scale_x(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  wh_t h = 0;\n  wh_t h_h = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  h = tk_min(img_h, dst_h) / 3;\n  h_h = dst_h - h * 2;\n\n  /*top*/\n  s = rect_init(0, 0, img_w, h);\n  d = rect_init(0, 0, dst_w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*middle*/\n  s = rect_init(0, h, img_w, img_h - 2 * h);\n  d = rect_init(0, h, dst_w, h_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*bottom*/\n  s = rect_init(0, img_h - h, img_w, h);\n  d = rect_init(0, dst_h - h, dst_w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  canvas_untranslate(c, dst->x, dst->y);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_patch3_y(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t x = 0;\n  wh_t h = 0;\n  wh_t h_h = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  h = tk_min(img_h, dst_h) / 3;\n  h_h = dst_h - h * 2;\n\n  x = (dst->w - img->w) >> 1;\n  /*top*/\n  s = rect_init(0, 0, img_w, h);\n  d = rect_init(x, 0, img_w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*middle*/\n  s = rect_init(0, h, img_w, img_h - 2 * h);\n  d = rect_init(x, h, img_w, h_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*bottom*/\n  s = rect_init(0, img_h - h, img_w, h);\n  d = rect_init(x, dst_h - h, img_w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  canvas_untranslate(c, dst->x, dst->y);\n  (void)dst_w;\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_patch3_x_scale_y(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  wh_t w = 0;\n  wh_t w_w = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  w = tk_min(img_w, dst_w) / 3;\n  w_w = dst_w - w * 2;\n\n  /*left*/\n  s = rect_init(0, 0, w, img_h);\n  d = rect_init(0, 0, w, dst_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*center*/\n  s = rect_init(w, 0, img_w - 2 * w, img_h);\n  d = rect_init(w, 0, w_w, dst_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*right*/\n  s = rect_init(img_w - w, 0, w, img_h);\n  d = rect_init(dst_w - w, 0, w, dst_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  canvas_untranslate(c, dst->x, dst->y);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_patch3_x(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t y = 0;\n  wh_t w = 0;\n  wh_t w_w = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  w = tk_min(img_w, dst_w) / 3;\n  w_w = dst_w - w * 2;\n\n  y = (dst_h - img_h) >> 1;\n  /*left*/\n  s = rect_init(0, 0, w, img_h);\n  d = rect_init(0, y, w, img_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*center*/\n  s = rect_init(w, 0, img_w - 2 * w, img_h);\n  d = rect_init(w, y, w_w, img_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*right*/\n  s = rect_init(img_w - w, 0, w, img_h);\n  d = rect_init(dst_w - w, y, w, img_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  canvas_untranslate(c, dst->x, dst->y);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_patch9(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t x = 0;\n  xy_t y = 0;\n  wh_t w = 0;\n  wh_t h = 0;\n  wh_t w_w = 0;\n  wh_t h_h = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  w = tk_min(img_w, dst_w) / 3;\n  h = tk_min(img_h, dst_h) / 3;\n\n  w_w = dst_w - w * 2;\n  h_h = dst_h - h * 2;\n\n  /*draw four corners*/\n  /*left top*/\n  s = rect_init(0, 0, w, h);\n  d = rect_init(0, 0, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*right top*/\n  s = rect_init(img_w - w, 0, w, h);\n  d = rect_init(dst_w - w, 0, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*left bottom*/\n  s = rect_init(0, img_h - h, w, h);\n  d = rect_init(0, dst_h - h, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*right bottom*/\n  s = rect_init(img_w - w, img_h - h, w, h);\n  d = rect_init(dst_w - w, dst_h - h, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*fill center*/\n  x = w;\n  if (w_w > 0) {\n    s = rect_init(w, 0, img_w - 2 * w, h);\n    d = rect_init(w, 0, w_w, h);\n    canvas_draw_image(c, img, &s, &d);\n\n    s = rect_init(w, img_h - h, img_w - 2 * w, h);\n    d = rect_init(w, h + h_h, w_w, h);\n    canvas_draw_image(c, img, &s, &d);\n  }\n\n  /*fill middle*/\n  y = h;\n  if (h_h > 0) {\n    s = rect_init(0, h, w, img_h - 2 * h);\n    d = rect_init(0, h, w, h_h);\n    canvas_draw_image(c, img, &s, &d);\n\n    s = rect_init(img_w - w, h, w, img_h - 2 * h);\n    d = rect_init(w + w_w, h, w, h_h);\n    canvas_draw_image(c, img, &s, &d);\n  }\n\n  /*fill center/middle*/\n  if (w_w > 0 && h_h > 0) {\n    s = rect_init(w, h, img_w - 2 * w, img_h - 2 * h);\n    d = rect_init(w, h, w_w, h_h);\n    canvas_draw_image(c, img, &s, &d);\n  }\n\n  canvas_untranslate(c, dst->x, dst->y);\n\n  (void)x;\n  (void)y;\n  (void)dst_w;\n\n  return RET_OK;\n}\n\nret_t canvas_end_frame(canvas_t* c) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  if (c->began_frame) {\n    c->began_frame = FALSE;\n  } else {\n    return RET_OK;\n  }\n\n  if (c->end_frame != NULL) {\n    return c->end_frame(c);\n  }\n\n  canvas_draw_fps(c);\n  canvas_set_global_alpha(c, 0xff);\n\n  return lcd_end_frame(c->lcd);\n}\n\nret_t canvas_draw_image_scale_w(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  wh_t src_h = 0;\n  wh_t dst_h = 0;\n  float scale = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  scale = (float)(dst->w) / img->w;\n  dst_h = tk_min(img->h * scale, dst->h);\n  src_h = tk_min(img->h, dst_h / scale);\n\n  s.x = 0;\n  s.y = 0;\n  s.w = img->w;\n  s.h = src_h;\n\n  d = *dst;\n  d.h = dst_h;\n\n  return canvas_draw_image(c, img, &s, &d);\n}\n\nret_t canvas_draw_image_scale_h(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  wh_t src_w = 0;\n  wh_t dst_w = 0;\n  float scale = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  scale = (float)(dst->h) / img->h;\n  dst_w = tk_min(img->w * scale, dst->w);\n  src_w = tk_min(img->w, dst_w / scale);\n\n  s.x = 0;\n  s.y = 0;\n  s.h = img->h;\n  s.w = src_w;\n\n  d = *dst;\n  d.w = dst_w;\n\n  return canvas_draw_image(c, img, &s, &d);\n}\n\nret_t canvas_draw_image_scale(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  float scale = 0;\n  float scalex = 0;\n  float scaley = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  s.x = 0;\n  s.y = 0;\n  s.h = img->h;\n  s.w = img->w;\n\n  scalex = (float)(dst->w) / img->w;\n  scaley = (float)(dst->h) / img->h;\n  scale = tk_min(scalex, scaley);\n\n  d.w = img->w * scale;\n  d.h = img->h * scale;\n  d.x = dst->x + ((dst->w - d.w) >> 1);\n  d.y = dst->y + ((dst->h - d.h) >> 1);\n\n  return canvas_draw_image(c, img, &s, &d);\n}\n\nret_t canvas_draw_image_scale_down(canvas_t* c, bitmap_t* img, const rect_t* src,\n                                   const rect_t* dst_in) {\n  rect_t d;\n  float scale = 0;\n  float scalex = 0;\n  float scaley = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && src != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  scalex = (float)(dst->w) / src->w;\n  scaley = (float)(dst->h) / src->h;\n  scale = tk_min(scalex, scaley);\n\n  if (scale >= 1) {\n    d.w = src->w;\n    d.h = src->h;\n  } else {\n    d.w = src->w * scale;\n    d.h = src->h * scale;\n  }\n  d.x = dst->x + ((dst->w - d.w) >> 1);\n  d.y = dst->y + ((dst->h - d.h) >> 1);\n\n  return canvas_draw_image(c, img, src, &d);\n}\n\nret_t canvas_draw_image_matrix(canvas_t* c, bitmap_t* img, matrix_t* matrix) {\n  draw_image_info_t info;\n  return_value_if_fail(c != NULL && img != NULL && matrix != NULL && c->lcd != NULL,\n                       RET_BAD_PARAMS);\n\n  info.img = img;\n  info.matrix = *matrix;\n  info.src = rect_init(0, 0, img->w, img->h);\n  info.dst = rect_init(0, 0, img->w, img->h);\n  canvas_get_clip_rect(c, &info.clip);\n\n  return lcd_draw_image_matrix(c->lcd, &info);\n}\n\nret_t canvas_draw_image_ex(canvas_t* c, bitmap_t* img, image_draw_type_t draw_type,\n                           const rect_t* dst_in) {\n  rect_t src;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n  switch (draw_type) {\n    case IMAGE_DRAW_DEFAULT:\n      src = rect_init(0, 0, tk_min(dst->w, img->w), tk_min(dst->h, img->h));\n      dst->w = src.w;\n      dst->h = src.h;\n      return canvas_draw_image(c, img, &src, dst);\n    case IMAGE_DRAW_CENTER:\n      return canvas_draw_image_center(c, img, dst);\n    case IMAGE_DRAW_SCALE:\n      src = rect_init(0, 0, img->w, img->h);\n      return canvas_draw_image(c, img, &src, dst);\n    case IMAGE_DRAW_SCALE_AUTO:\n      return canvas_draw_image_scale(c, img, dst);\n    case IMAGE_DRAW_SCALE_DOWN: {\n      rect_t src = rect_init(0, 0, img->w, img->h);\n      return canvas_draw_image_scale_down(c, img, &src, dst);\n    }\n#ifndef AWTK_LITE\n    case IMAGE_DRAW_ICON: {\n      xy_t cx = dst->x + (dst->w >> 1);\n      xy_t cy = dst->y + (dst->h >> 1);\n      return canvas_draw_icon(c, img, cx, cy);\n    }\n    case IMAGE_DRAW_SCALE_W:\n      return canvas_draw_image_scale_w(c, img, dst);\n    case IMAGE_DRAW_SCALE_H:\n      return canvas_draw_image_scale_h(c, img, dst);\n    case IMAGE_DRAW_REPEAT:\n      return canvas_draw_image_repeat(c, img, dst);\n    case IMAGE_DRAW_REPEAT_X:\n      return canvas_draw_image_repeat_x(c, img, dst);\n    case IMAGE_DRAW_REPEAT_Y:\n      return canvas_draw_image_repeat_y(c, img, dst);\n    case IMAGE_DRAW_REPEAT_Y_INVERSE:\n      return canvas_draw_image_repeat_y_inverse(c, img, dst);\n    case IMAGE_DRAW_PATCH9:\n      return canvas_draw_image_patch9(c, img, dst);\n    case IMAGE_DRAW_PATCH3_X:\n      return canvas_draw_image_patch3_x(c, img, dst);\n    case IMAGE_DRAW_PATCH3_Y:\n      return canvas_draw_image_patch3_y(c, img, dst);\n    case IMAGE_DRAW_PATCH3_X_SCALE_Y:\n      return canvas_draw_image_patch3_x_scale_y(c, img, dst);\n    case IMAGE_DRAW_PATCH3_Y_SCALE_X:\n      return canvas_draw_image_patch3_y_scale_x(c, img, dst);\n    case IMAGE_DRAW_REPEAT9:\n      return canvas_draw_image_repeat9(c, img, dst);\n    case IMAGE_DRAW_REPEAT3_X:\n      return canvas_draw_image_repeat3_x(c, img, dst);\n    case IMAGE_DRAW_REPEAT3_Y:\n      return canvas_draw_image_repeat3_y(c, img, dst);\n#endif /*AWTK_LITE*/\n    default:\n      return canvas_draw_image_center(c, img, dst);\n  }\n}\n\nret_t canvas_draw_image_ex2(canvas_t* c, bitmap_t* img, image_draw_type_t draw_type,\n                            const rect_t* src_in, const rect_t* dst_in) {\n  rect_t src;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(bitmap_check_rect(img, src_in), RET_BAD_PARAMS);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  switch (draw_type) {\n    case IMAGE_DRAW_DEFAULT:\n      src = *src_in;\n      dst->w = src.w;\n      dst->h = src.h;\n      return canvas_draw_image(c, img, &src, dst);\n    case IMAGE_DRAW_ICON: {\n      xy_t cx = dst->x + (dst->w >> 1);\n      xy_t cy = dst->y + (dst->h >> 1);\n      return canvas_draw_icon_ex(c, img, src_in, cx, cy);\n    }\n    case IMAGE_DRAW_CENTER:\n      return canvas_draw_image_center_ex(c, img, src_in, dst);\n    case IMAGE_DRAW_SCALE:\n      return canvas_draw_image(c, img, src_in, dst);\n    default:\n      /*TODO*/\n      assert(!\"not supported yet!\");\n      return RET_FAIL;\n  }\n}\n\nstatic ret_t canvas_draw_icon_ex(canvas_t* c, bitmap_t* img, const rect_t* src_r, xy_t cx,\n                                 xy_t cy) {\n  rect_t src;\n  rect_t dst;\n  wh_t hw = 0;\n  wh_t hh = 0;\n  float_t ratio = 0;\n  return_value_if_fail(c != NULL && c->lcd != NULL && img != NULL && src_r != NULL, RET_BAD_PARAMS);\n\n  src = *src_r;\n  ratio = c->lcd->ratio;\n  if (ratio > 1) {\n    float_t w = (src.w / ratio);\n    float_t h = (src.h / ratio);\n    float_t hw = w / 2;\n    float_t hh = h / 2;\n\n    dst = rect_init(cx - hw, cy - hh, w, h);\n  } else {\n    hw = src.w >> 1;\n    hh = src.h >> 1;\n    dst = rect_init(cx - hw, cy - hh, src.w, src.h);\n  }\n\n  return canvas_draw_image(c, img, &src, &dst);\n}\n\nret_t canvas_draw_icon(canvas_t* c, bitmap_t* img, xy_t cx, xy_t cy) {\n  rect_t src;\n  return_value_if_fail(c != NULL && c->lcd != NULL && img != NULL, RET_BAD_PARAMS);\n  src = rect_init(0, 0, img->w, img->h);\n\n  return canvas_draw_icon_ex(c, img, &src, cx, cy);\n}\n\nret_t canvas_draw_icon_in_rect(canvas_t* c, bitmap_t* img, const rect_t* r_in) {\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* r = canvas_fix_rect(r_in, &r_fix);\n  return_value_if_fail(c != NULL && c->lcd != NULL && img != NULL && r != NULL, RET_BAD_PARAMS);\n\n  return canvas_draw_icon(c, img, r->x + (r->w >> 1), r->y + (r->h >> 1));\n}\n\nstatic ret_t canvas_draw_image_center_ex(canvas_t* c, bitmap_t* img, const rect_t* src_r,\n                                         const rect_t* dst_in) {\n  xy_t dx = 0;\n  xy_t dy = 0;\n  xy_t sx = 0;\n  xy_t sy = 0;\n  wh_t sw = 0;\n  wh_t sh = 0;\n  rect_t src;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  dx = ((dst->w - src_r->w) >> 1);\n  dy = ((dst->h - src_r->h) >> 1);\n\n  if (dx < 0) {\n    sx = -dx;\n    dx = 0;\n    sw = src_r->w - 2 * sx;\n  } else {\n    sw = src_r->w;\n  }\n\n  if (dy < 0) {\n    sy = -dy;\n    dy = 0;\n    sh = src_r->h - 2 * sy;\n  } else {\n    sh = src_r->h;\n  }\n\n  dx += dst->x;\n  dy += dst->y;\n\n  src = rect_init(sx + src_r->x, sy + src_r->y, sw, sh);\n  *dst = rect_init(dx, dy, sw, sh);\n\n  return canvas_draw_image(c, img, &src, dst);\n}\n\nret_t canvas_draw_image_center(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t src;\n  return_value_if_fail(c != NULL && img != NULL && dst_in != NULL, RET_BAD_PARAMS);\n  src = rect_init(0, 0, img->w, img->h);\n\n  return canvas_draw_image_center_ex(c, img, &src, dst_in);\n}\n\nret_t canvas_draw_image_at(canvas_t* c, bitmap_t* img, xy_t x, xy_t y) {\n  rect_t src;\n  rect_t dst;\n  float_t ratio = 0;\n  return_value_if_fail(c != NULL && c->lcd != NULL && img != NULL, RET_BAD_PARAMS);\n\n  x += c->ox;\n  y += c->oy;\n  ratio = c->lcd->ratio;\n  src = rect_init(0, 0, img->w, img->h);\n\n  if (ratio > 1) {\n    dst = rect_init(x, y, img->w / ratio, img->h / ratio);\n  } else {\n    dst = rect_init(x, y, img->w, img->h);\n  }\n\n  return canvas_do_draw_image(c, img, &src, &dst);\n}\n\nret_t canvas_set_fps(canvas_t* c, bool_t show_fps, uint32_t fps) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  c->show_fps = show_fps;\n  c->fps = fps;\n\n  return RET_OK;\n}\n\nstatic ret_t canvas_draw_fps(canvas_t* c) {\n  lcd_t* lcd = c->lcd;\n\n  if (c->show_fps && c->lcd->draw_mode == LCD_DRAW_NORMAL) {\n    rect_t r;\n    char fps[20];\n    wchar_t wfps[20];\n\n    r = rect_init(0, 0, 60, 30);\n    canvas_set_font(c, NULL, 16);\n    canvas_set_text_color(c, color_init(0xf0, 0xf0, 0xf0, 0xff));\n    canvas_set_fill_color(c, color_init(0x20, 0x20, 0x20, 0xff));\n\n    lcd->fps_rect = r;\n    tk_snprintf(fps, sizeof(fps), \"%dfps\", (int)(c->fps));\n\n    tk_utf8_to_utf16(fps, wfps, strlen(fps) + 1);\n    canvas_fill_rect(c, r.x, r.y, r.w, r.h);\n    canvas_draw_text(c, wfps, wcslen(wfps), r.x + 8, r.y + 8);\n  } else {\n    lcd->fps_rect.w = 0;\n    lcd->fps_rect.h = 0;\n  }\n\n  return RET_OK;\n}\n\nfloat_t canvas_get_font_height(canvas_t* c) {\n  font_vmetrics_t vmetrics;\n  return_value_if_fail(c != NULL && c->font_size > 0, 0);\n  vmetrics = font_get_vmetrics(c->font, c->font_size);\n\n  return vmetrics.ascent - vmetrics.descent;\n}\n\nret_t canvas_draw_text_in_rect(canvas_t* c, const wchar_t* str, uint32_t nr, const rect_t* r_in) {\n  int x = 0;\n  int y = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  int32_t text_w = 0;\n  int32_t height = canvas_get_font_height(c);\n  rect_t* r = canvas_fix_rect(r_in, &r_fix);\n  return_value_if_fail(c != NULL && str != NULL && r != NULL, RET_BAD_PARAMS);\n\n  text_w = canvas_measure_text(c, str, nr);\n\n  switch (c->text_align_v) {\n    case ALIGN_V_TOP:\n      y = r->y;\n      break;\n    case ALIGN_V_BOTTOM:\n      y = r->y + (r->h - height);\n      break;\n    default:\n      y = r->y + ((r->h - height) >> 1);\n      break;\n  }\n\n  switch (c->text_align_h) {\n    case ALIGN_H_LEFT:\n      x = r->x;\n      break;\n    case ALIGN_H_RIGHT:\n      x = r->x + (r->w - text_w);\n      break;\n    default:\n      x = r->x + ((r->w - text_w) >> 1);\n      break;\n  }\n\n  return canvas_draw_text(c, str, nr, x, y);\n}\n\n#define STR_ELLIPSES L\"...\"\n\nstatic ret_t canvas_draw_text_in_rect_ellipses(canvas_t* c, const wchar_t* str, uint32_t nr,\n                                               const rect_t* r_in, bidi_type_t type) {\n  uint32_t i = 0;\n  rect_t r = *r_in;\n  float_t text_w = 0;\n  float_t ellipses_w = canvas_measure_text(c, STR_ELLIPSES, wcslen(STR_ELLIPSES));\n\n  for (i = 0; i < nr; i++) {\n    float_t char_w = canvas_measure_text(c, str + i, 1);\n    if ((text_w + char_w + ellipses_w) >= r.w) {\n      break;\n    }\n\n    text_w += char_w;\n  }\n\n  r.w = text_w;\n  canvas_draw_text_in_rect(c, str, i, &r);\n  r.x = text_w;\n  r.w = ellipses_w;\n  canvas_draw_text_in_rect(c, STR_ELLIPSES, wcslen(STR_ELLIPSES), &r);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_text_bidi_in_rect(canvas_t* c, const wchar_t* str, uint32_t nr,\n                                    const rect_t* r_in, const char* bidi_type, bool_t ellipses) {\n  bidi_t b;\n  ret_t ret = RET_FAIL;\n  return_value_if_fail(c != NULL && str != NULL && r_in != NULL, RET_BAD_PARAMS);\n\n  if (nr == 0) {\n    return RET_OK;\n  }\n\n  bidi_init(&b, FALSE, FALSE, bidi_type_from_name(bidi_type));\n  if (bidi_log2vis(&b, str, nr) == RET_OK) {\n    float_t text_w = canvas_measure_text(c, b.vis_str, b.vis_str_size);\n    if (ellipses && text_w > r_in->w) {\n      ret = canvas_draw_text_in_rect_ellipses(c, b.vis_str, b.vis_str_size, r_in, b.resolved_type);\n    } else {\nret = ",
    "raw_res": "",
    "prompt_res": "canvas_draw_text_in_rect(c, b.vis_str, b.vis_str_size, r_in);",
    "gt": "canvas_draw_text_in_rect(c, b.vis_str, b.vis_str_size, r_in);"
  },
  {
    "id": 2144,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/canvas.c",
    "input": "﻿/**\n * File:   canvas.c\n * Author: AWTK Develop Team\n * Brief:  canvas provides basic drawings functions.\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-13 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/wstr.h\"\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/utils.h\"\n#include \"base/bidi.h\"\n#include \"base/canvas.h\"\n#include \"base/vgcanvas.h\"\n#include \"tkc/time_now.h\"\n#include \"tkc/color_parser.h\"\n#include \"base/system_info.h\"\n\n#include \"base/lcd_profile.h\"\n\n#ifndef CANVAS_MEASURE_TEXT_CACHE_MAX_LENGTH\n#define CANVAS_MEASURE_TEXT_CACHE_MAX_LENGTH 127\n#endif\n\nstatic ret_t canvas_draw_fps(canvas_t* c);\nstatic ret_t canvas_draw_icon_ex(canvas_t* c, bitmap_t* img, const rect_t* src_r, xy_t cx, xy_t cy);\nstatic ret_t canvas_draw_image_center_ex(canvas_t* c, bitmap_t* img, const rect_t* src_r,\n                                         const rect_t* dst_in);\n\nstatic bool_t bitmap_check_rect(bitmap_t* img, const rect_t* r) {\n  return_value_if_fail(img != NULL && r != NULL, FALSE);\n\n  return r->x >= 0 && r->y >= 0 && r->w > 0 && r->h > 0 && (r->x + r->w) <= img->w &&\n         (r->y + r->h) <= img->h;\n}\n\nstatic rect_t* canvas_fix_rect(const rect_t* r, rect_t* o) {\n  if (r != NULL) {\n    *o = *r;\n\n    if (o->w < 0) {\n      o->w = -o->w;\n      o->x = o->x - o->w + 1;\n    }\n\n    if (o->h < 0) {\n      o->h = -o->h;\n      o->y = o->y - o->h + 1;\n    }\n\n    return o;\n  } else {\n    return NULL;\n  }\n}\n\nret_t canvas_translate(canvas_t* c, xy_t dx, xy_t dy) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  c->ox += dx;\n  c->oy += dy;\n\n  return RET_OK;\n}\n\nret_t canvas_untranslate(canvas_t* c, xy_t dx, xy_t dy) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  c->ox -= dx;\n  c->oy -= dy;\n\n  return RET_OK;\n}\n\ncanvas_t* canvas_init(canvas_t* c, lcd_t* lcd, font_manager_t* font_manager) {\n  return_value_if_fail(c != NULL && lcd != NULL && font_manager != NULL, NULL);\n\n  memset(c, 0x00, sizeof(canvas_t));\n\n  c->lcd = lcd_profile_create(lcd);\n  c->font_manager = font_manager;\n\n  c->clip_left = 0;\n  c->clip_top = 0;\n  c->clip_right = canvas_get_width(c) - 1;\n  c->clip_bottom = canvas_get_height(c) - 1;\n\n  c->last_text_str = TKMEM_ZALLOCN(wchar_t, CANVAS_MEASURE_TEXT_CACHE_MAX_LENGTH + 1);\n  return c;\n}\n\nwh_t canvas_get_width(canvas_t* c) {\n  return_value_if_fail(c != NULL, 0);\n\n  return lcd_get_width(c->lcd);\n}\n\nwh_t canvas_get_height(canvas_t* c) {\n  return_value_if_fail(c != NULL, 0);\n\n  return lcd_get_height(c->lcd);\n}\n\nret_t canvas_set_font_manager(canvas_t* c, font_manager_t* font_manager) {\n  return_value_if_fail(c != NULL && font_manager != NULL, RET_BAD_PARAMS);\n\n  c->font_manager = font_manager;\n\n  return RET_OK;\n}\n\nret_t canvas_set_assets_manager(canvas_t* c, assets_manager_t* assets_manager) {\n  vgcanvas_t* vgcanvas = NULL;\n  return_value_if_fail(c != NULL && assets_manager != NULL, RET_BAD_PARAMS);\n\n  vgcanvas = lcd_get_vgcanvas(c->lcd);\n  c->assets_manager = assets_manager;\n  if (vgcanvas != NULL) {\n    vgcanvas_set_assets_manager(vgcanvas, assets_manager);\n  }\n  if (c->font_manager != NULL) {\n    font_manager_set_assets_manager(c->font_manager, assets_manager);\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_get_clip_rect(canvas_t* c, rect_t* r) {\n  return_value_if_fail(c != NULL && r != NULL, RET_BAD_PARAMS);\n\n  r->x = c->clip_left;\n  r->y = c->clip_top;\n  r->w = c->clip_right - c->clip_left + 1;\n  r->h = c->clip_bottom - c->clip_top + 1;\n\n  if (c->lcd->get_clip_rect != NULL) {\n    return lcd_get_clip_rect(c->lcd, r);\n  }\n  return RET_OK;\n}\n\nbool_t canvas_is_rect_in_clip_rect(canvas_t* c, xy_t left, xy_t top, xy_t right, xy_t bottom) {\n  if (c->lcd->is_rect_in_clip_rect != NULL) {\n    return c->lcd->is_rect_in_clip_rect(c->lcd, left, top, right, bottom);\n  } else {\n    if (left > c->clip_right || right < c->clip_left || top > c->clip_bottom ||\n        bottom < c->clip_top) {\n      return FALSE;\n    }\n    return TRUE;\n  }\n}\n\nret_t canvas_set_clip_rect(canvas_t* c, const rect_t* r_in) {\n  wh_t lcd_w = 0;\n  wh_t lcd_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* r = canvas_fix_rect(r_in, &r_fix);\n\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  lcd_w = lcd_get_width(c->lcd);\n  lcd_h = lcd_get_height(c->lcd);\n\n  if (c->lcd->set_clip_rect != NULL) {\n    if (r != NULL) {\n      rect_t clip_r = rect_init(tk_max(0, r->x), tk_max(0, r->y), tk_max(0, r->w), tk_max(0, r->h));\n      lcd_set_clip_rect(c->lcd, &clip_r);\n    } else {\n      rect_t clip_r = rect_init(0, 0, lcd_w, lcd_h);\n      lcd_set_clip_rect(c->lcd, &clip_r);\n    }\n#ifdef WITH_GPU\n    /* 兼容以前的逻辑，以免以前的用户不使用 canvas_is_rect_in_clip_rect 来判断出问题 */\n    /* 把 canvas 的裁剪区设置为无限大，在 opengl 的状态下让 vg 来处理裁剪区的问题 */\n    c->clip_left = 0;\n    c->clip_top = 0;\n    c->clip_right = 0x7fffffff;\n    c->clip_bottom = 0x7fffffff;\n#endif\n  } else {\n    if (r != NULL) {\n      c->clip_left = tk_max(0, r->x);\n      c->clip_top = tk_max(0, r->y);\n      c->clip_right = tk_min(lcd_w - 1, r->x + r->w - 1);\n      c->clip_bottom = tk_min(lcd_h - 1, r->y + r->h - 1);\n    } else {\n      c->clip_left = 0;\n      c->clip_top = 0;\n      c->clip_right = lcd_w - 1;\n      c->clip_bottom = lcd_h - 1;\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_set_clip_rect_ex(canvas_t* c, const rect_t* r_in, bool_t translate) {\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* r = canvas_fix_rect(r_in, &r_fix);\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  if (r != NULL && translate) {\n    rect_t rr = *r;\n\n    rr.x += c->ox;\n    rr.y += c->oy;\n    return canvas_set_clip_rect(c, &rr);\n  } else {\n    return canvas_set_clip_rect(c, r);\n  }\n}\n\nret_t canvas_set_fill_color(canvas_t* c, color_t color) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  lcd_set_fill_color(c->lcd, color);\n\n  return RET_OK;\n}\n\nret_t canvas_set_text_color(canvas_t* c, color_t color) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  lcd_set_text_color(c->lcd, color);\n\n  return RET_OK;\n}\n\nret_t canvas_set_stroke_color(canvas_t* c, color_t color) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  lcd_set_stroke_color(c->lcd, color);\n\n  return RET_OK;\n}\n\nret_t canvas_set_global_alpha(canvas_t* c, uint8_t alpha) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  c->global_alpha = alpha;\n  lcd_set_global_alpha(c->lcd, alpha);\n\n  return RET_OK;\n}\n\nret_t canvas_set_font(canvas_t* c, const char* name, font_size_t size) {\n  return_value_if_fail(c != NULL && c->lcd != NULL, RET_BAD_PARAMS);\n\n  name = system_info_fix_font_name(name);\n  size = system_info()->font_scale * size;\n\n  if (c->font_size != size) {\n    c->font_size = size;\n    c->last_text_length = 0;\n  }\n  if (!tk_str_eq(name, c->font_name)) {\n    c->last_text_length = 0;\n    c->font_name = tk_str_copy(c->font_name, name);\n  }\n\n  if (c->last_text_length == 0) {\n    if (c->lcd->set_font_name != NULL) {\n      lcd_set_font_name(c->lcd, c->font_name);\n      lcd_set_font_size(c->lcd, size);\n    } else {\n      c->font = font_manager_get_font(c->font_manager, c->font_name, c->font_size);\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_reset_font(canvas_t* c) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  c->font_size = 0;\n  c->last_text_length = 0;\n  c->font = NULL;\n  TKMEM_FREE(c->font_name);\n\n  return RET_OK;\n}\n\nret_t canvas_set_text_align(canvas_t* c, align_h_t align_h, align_v_t align_v) {\n  return_value_if_fail(c != NULL && c->lcd != NULL, RET_BAD_PARAMS);\n\n  c->text_align_h = align_h;\n  c->text_align_v = align_v;\n\n  return RET_OK;\n}\n\nstatic float_t canvas_measure_text_default(canvas_t* c, const wchar_t* str, uint32_t nr) {\n  glyph_t g;\n  float_t w = 0;\n  uint32_t i = 0;\n  return_value_if_fail(c != NULL && str != NULL && c->font != NULL, 0);\n\n  for (i = 0; i < nr; i++) {\n    wchar_t chr = str[i];\n    if (font_get_glyph(c->font, chr, c->font_size, &g) == RET_OK) {\n      w += g.advance + 1;\n    } else {\n      w += 4;\n    }\n  }\n\n  return w;\n}\n\nfloat_t canvas_measure_text(canvas_t* c, const wchar_t* str, uint32_t nr) {\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, 0);\n\n  if (c->last_text_length != 0 && c->last_text_nr == nr && tk_wstr_eq(c->last_text_str, str)) {\n    return c->last_text_length;\n  } else {\n    if (nr > CANVAS_MEASURE_TEXT_CACHE_MAX_LENGTH) {\n      c->last_text_nr = 0;\n      c->last_text_str[0] = 0;\n    } else {\n      tk_memcpy(c->last_text_str, str, nr * sizeof(wchar_t));\n      c->last_text_nr = nr;\n      c->last_text_str[nr] = 0;\n    }\n  }\n\n  if (c->lcd->measure_text) {\n    c->last_text_length = lcd_measure_text(c->lcd, str, nr);\n  } else {\n    c->last_text_length = canvas_measure_text_default(c, str, nr);\n  }\n  return c->last_text_length;\n}\n\nfloat_t canvas_measure_utf8(canvas_t* c, const char* str) {\n  wstr_t s;\n  float_t ret = 0;\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, 0);\n\n  wstr_init(&s, 0);\n  return_value_if_fail(wstr_set_utf8(&s, str) == RET_OK, 0);\n\n  ret = canvas_measure_text(c, s.str, s.size);\n  wstr_reset(&s);\n\n  return ret;\n}\n\nret_t canvas_begin_frame(canvas_t* c, const dirty_rects_t* dirty_rects, lcd_draw_mode_t draw_mode) {\n  rect_t dirty_rect;\n  ret_t ret = RET_OK;\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  if (c->began_frame) {\n    return RET_OK;\n  } else {\n    c->began_frame = TRUE;\n  }\n\n  if (c->begin_frame) {\n    return c->begin_frame(c, dirty_rects, draw_mode);\n  }\n\n  c->ox = 0;\n  c->oy = 0;\n\n  canvas_set_global_alpha(c, 0xff);\n  lcd_set_canvas(c->lcd, c);\n  /* 把当前帧的脏矩形列表传入到 lcd 中和 fb 的脏矩形列表合并得出新的脏矩形列表。*/\n  if (c->lcd->support_dirty_rect) {\n    ret = lcd_begin_frame(c->lcd, dirty_rects, draw_mode);\n  } else {\n    ret = lcd_begin_frame(c->lcd, NULL, draw_mode);\n  }\n  return_value_if_fail(ret == RET_OK, ret);\n  /* 获取新的最大的脏矩形，然后设置裁剪区 */\n  ret = lcd_get_dirty_rect(c->lcd, &dirty_rect);\n  if (c->lcd->support_dirty_rect && ret == RET_OK) {\n    if (draw_mode == LCD_DRAW_NORMAL && c->lcd->type == LCD_VGCANVAS) {\n      rect_t r = dirty_rect;\n\n      /*for vgcanvas anti alias*/\n      r.x--;\n      r.y--;\n      r.w += 2;\n      r.h += 2;\n\n      canvas_set_clip_rect(c, &r);\n    } else {\n      canvas_set_clip_rect(c, &dirty_rect);\n    }\n  } else {\n    canvas_set_clip_rect(c, NULL);\n  }\n\n  return ret;\n}\n\nstatic ret_t canvas_draw_hline_impl(canvas_t* c, xy_t x, xy_t y, wh_t w) {\n  rect_t r;\n  xy_t x2 = x + w - 1;\n\n  if (!canvas_is_rect_in_clip_rect(c, x, y, x2, y)) {\n    return RET_OK;\n  }\n  canvas_get_clip_rect(c, &r);\n\n  x = tk_max(x, r.x);\n  x2 = tk_min(x2, r.x + r.w - 1);\n  w = x2 - x + 1;\n\n  return lcd_draw_hline(c->lcd, x, y, w);\n}\n\nret_t canvas_draw_hline(canvas_t* c, xy_t x, xy_t y, wh_t w) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  if (w < 0) {\n    w = -w;\n    x = x - w + 1;\n  }\n\n  return canvas_draw_hline_impl(c, c->ox + x, c->oy + y, w);\n}\n\nstatic ret_t canvas_draw_vline_impl(canvas_t* c, xy_t x, xy_t y, wh_t h) {\n  rect_t r;\n  xy_t y2 = y + h - 1;\n\n  if (!canvas_is_rect_in_clip_rect(c, x, y, x, y2)) {\n    return RET_OK;\n  }\n  canvas_get_clip_rect(c, &r);\n\n  y = tk_max(y, r.y);\n  y2 = tk_min(y2, r.y + r.h - 1);\n  h = y2 - y + 1;\n\n  return lcd_draw_vline(c->lcd, x, y, h);\n}\n\nret_t canvas_draw_vline(canvas_t* c, xy_t x, xy_t y, wh_t h) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  if (h < 0) {\n    h = -h;\n    y = y - h + 1;\n  }\n\n  return canvas_draw_vline_impl(c, c->ox + x, c->oy + y, h);\n}\n\nstatic ret_t canvas_draw_line_impl(canvas_t* c, xy_t x1, xy_t y1, xy_t x2, xy_t y2) {\n  if (x1 == x2) {\n    return canvas_draw_vline_impl(c, x1, y1, tk_abs(y2 - y1) + 1);\n  } else if (y1 == y2) {\n    return canvas_draw_hline_impl(c, x1, y1, tk_abs(x2 - x1) + 1);\n  } else {\n    assert(!\"Not implemented yet, please use vgcanvas to draw line\");\n    return RET_NOT_IMPL;\n  }\n}\n\nret_t canvas_draw_line(canvas_t* c, xy_t x1, xy_t y1, xy_t x2, xy_t y2) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  return canvas_draw_line_impl(c, c->ox + x1, c->oy + y1, c->ox + x2, c->oy + y2);\n}\n\n#define MAX_POINTS_PER_DRAW 20\n\nstatic ret_t canvas_do_draw_points(canvas_t* c, const point_t* points, uint32_t nr) {\n  uint32_t i = 0;\n  uint32_t real_nr = 0;\n\n  point_t real_points[MAX_POINTS_PER_DRAW];\n  return_value_if_fail(nr <= MAX_POINTS_PER_DRAW, RET_BAD_PARAMS);\n\n  for (i = 0; i < nr; i++) {\n    const point_t* p = points + i;\n    xy_t x = p->x + c->ox;\n    xy_t y = p->y + c->oy;\n    if (!canvas_is_rect_in_clip_rect(c, x, y, x, y)) {\n      continue;\n    }\n\n    real_points[real_nr].x = x;\n    real_points[real_nr].y = y;\n\n    real_nr++;\n  }\n\n  return lcd_draw_points(c->lcd, real_points, real_nr);\n}\n\nstatic ret_t canvas_draw_points_impl(canvas_t* c, const point_t* points, uint32_t nr) {\n  uint32_t i = 0;\n  const point_t* p = points;\n  uint32_t n = (nr / MAX_POINTS_PER_DRAW);\n  uint32_t r = (nr % MAX_POINTS_PER_DRAW);\n\n  for (i = 0; i <= n; i++) {\n    if (i == n) {\n      canvas_do_draw_points(c, p, r);\n    } else {\n      canvas_do_draw_points(c, p, MAX_POINTS_PER_DRAW);\n      p += MAX_POINTS_PER_DRAW;\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_draw_points(canvas_t* c, const point_t* points, uint32_t nr) {\n  return_value_if_fail(c != NULL && points != NULL, RET_BAD_PARAMS);\n\n  return canvas_draw_points_impl(c, points, nr);\n}\n\nstatic ret_t canvas_fill_rect_impl(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  rect_t r;\n  xy_t x2 = x + w - 1;\n  xy_t y2 = y + h - 1;\n\n  if (!canvas_is_rect_in_clip_rect(c, x, y, x2, y2)) {\n    return RET_OK;\n  }\n  canvas_get_clip_rect(c, &r);\n\n  x = tk_max(x, r.x);\n  y = tk_max(y, r.y);\n  x2 = tk_min(x2, r.x + r.w - 1);\n  y2 = tk_min(y2, r.y + r.h - 1);\n  w = x2 - x + 1;\n  h = y2 - y + 1;\n\n  return lcd_fill_rect(c->lcd, x, y, w, h);\n}\n\nret_t canvas_fill_rect(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  fix_xywh(x, y, w, h);\n  return canvas_fill_rect_impl(c, c->ox + x, c->oy + y, w, h);\n}\n\nstatic ret_t canvas_fill_rect_gradient_impl(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h,\n                                            gradient_t* gradient) {\n  rect_t r;\n  xy_t x2 = x + w - 1;\n  xy_t y2 = y + h - 1;\n  vgcanvas_t* vg = NULL;\n\n  if (!canvas_is_rect_in_clip_rect(c, x, y, x2, y2)) {\n    return RET_OK;\n  }\n\n  canvas_get_clip_rect(c, &r);\n\n  x = tk_max(x, r.x);\n  y = tk_max(y, r.y);\n  x2 = tk_min(x2, r.x + r.w - 1);\n  y2 = tk_min(y2, r.y + r.h - 1);\n  w = x2 - x + 1;\n  h = y2 - y + 1;\n  if (w == 0 || h == 0) {\n    return RET_OK;\n  }\n\n  /*FIXME: to support general cases*/\n  return_value_if_fail(gradient->type == GRADIENT_LINEAR && gradient->degree == 180,\n                       RET_BAD_PARAMS);\n\n#ifndef WITH_GPU\n  if (gradient->type == GRADIENT_LINEAR) {\n    if (gradient->degree == 180) {\n      uint32_t i = 0;\n      lcd_t* lcd = c->lcd;\n      for (i = 0; i < h; i++) {\n        float offset = (float)i / (float)h;\n        color_t color = gradient_get_color(gradient, offset);\n        lcd_set_stroke_color(lcd, color);\n        lcd_draw_hline(lcd, x, y + i, w);\n      }\n      return RET_OK;\n    }\n  }\n#endif\n  vg = canvas_get_vgcanvas(c);\n  if (vg != NULL) {\n    vg_gradient_t vg_gradient;\n    rect_t rect = {x, y, w, h};\n    vgcanvas_save(vg);\n    vgcanvas_set_antialias(vg, FALSE);\n    vg_gradient_init_with_gradient(&vg_gradient, &rect, gradient);\n    vgcanvas_set_fill_gradient(vg, &vg_gradient);\n    vgcanvas_rect(vg, x, y, w, h);\n    vgcanvas_fill(vg);\n    vgcanvas_restore(vg);\n  }\n\n  return RET_NOT_IMPL;\n}\n\nret_t canvas_fill_rect_gradient(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h, gradient_t* gradient) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  fix_xywh(x, y, w, h);\n  return canvas_fill_rect_gradient_impl(c, c->ox + x, c->oy + y, w, h, gradient);\n}\n\nstatic ret_t canvas_clear_rect_impl(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  rect_t r;\n  xy_t x2 = x + w - 1;\n  xy_t y2 = y + h - 1;\n\n  if (!canvas_is_rect_in_clip_rect(c, x, y, x2, y2)) {\n    return RET_OK;\n  }\n\n  canvas_get_clip_rect(c, &r);\n\n  x = tk_max(x, r.x);\n  y = tk_max(y, r.y);\n  x2 = tk_min(x2, r.x + r.w - 1);\n  y2 = tk_min(y2, r.y + r.h - 1);\n  w = x2 - x + 1;\n  h = y2 - y + 1;\n\n  return lcd_clear_rect(c->lcd, x, y, w, h);\n}\n\nret_t canvas_clear_rect(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  fix_xywh(x, y, w, h);\n  return canvas_clear_rect_impl(c, c->ox + x, c->oy + y, w, h);\n}\n\nstatic ret_t canvas_stroke_rect_impl(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return_value_if_fail(c != NULL && c->lcd != NULL && w > 0 && h > 0, RET_BAD_PARAMS);\n\n  if (c->lcd->stroke_rect != NULL) {\n    lcd_stroke_rect(c->lcd, x, y, w, h);\n  } else {\n    canvas_draw_hline_impl(c, x, y, w);\n    canvas_draw_hline_impl(c, x, y + h - 1, w);\n    canvas_draw_vline_impl(c, x, y, h);\n    canvas_draw_vline_impl(c, x + w - 1, y, h);\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_stroke_rect(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  fix_xywh(x, y, w, h);\n  return canvas_stroke_rect_impl(c, c->ox + x, c->oy + y, w, h);\n}\n\nstatic ret_t canvas_draw_glyph(canvas_t* c, glyph_t* g, xy_t x, xy_t y) {\n  rect_t r;\n  rect_t src;\n  rect_t dst;\n  xy_t x2 = x + g->w - 1;\n  xy_t y2 = y + g->h - 1;\n\n  if (g->data == NULL || !canvas_is_rect_in_clip_rect(c, x, y, x2, y2)) {\n    return RET_OK;\n  }\n  canvas_get_clip_rect(c, &r);\n\n  dst.x = tk_max(x, r.x);\n  dst.y = tk_max(y, r.y);\n  dst.w = tk_min(x2, r.x + r.w - 1) - dst.x + 1;\n  dst.h = tk_min(y2, r.y + r.h - 1) - dst.y + 1;\n\n  src.x = dst.x - x;\n  src.y = dst.y - y;\n  src.w = dst.w;\n  src.h = dst.h;\n\n  return lcd_draw_glyph(c->lcd, g, &src, dst.x, dst.y);\n}\n\nstatic ret_t canvas_draw_char_impl(canvas_t* c, wchar_t chr, xy_t x, xy_t y) {\n  glyph_t g;\n  font_size_t font_size = c->font_size;\n  font_vmetrics_t vmetrics = font_get_vmetrics(c->font, c->font_size);\n  return_value_if_fail(font_get_glyph(c->font, chr, font_size, &g) == RET_OK, RET_BAD_PARAMS);\n\n  x += g.x;\n  y += vmetrics.ascent + g.y;\n\n  return canvas_draw_glyph(c, &g, x, y);\n}\n\nret_t canvas_draw_char(canvas_t* c, wchar_t chr, xy_t x, xy_t y) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  return canvas_draw_char_impl(c, chr, c->ox + x, c->oy + y);\n}\n\nstatic ret_t canvas_draw_text_impl(canvas_t* c, const wchar_t* str, uint32_t nr, xy_t x, xy_t y,\n                                   bool_t line_breaker) {\n  glyph_t g;\n  uint32_t i = 0;\n  xy_t left = x;\n  font_vmetrics_t vmetrics = font_get_vmetrics(c->font, c->font_size);\n  font_size_t font_size = c->font_size;\n  int32_t baseline = vmetrics.ascent;\n  return_value_if_fail(c->font != NULL, RET_BAD_PARAMS);\n  for (i = 0; i < nr; i++) {\n    wchar_t chr = str[i];\n\n    if (chr == '\\r' || chr == '\\n') {\n      if ((i + 1) == nr) {\n        break;\n      }\n\n      if (chr == '\\r' && str[i + 1] == '\\n') {\n        i++;\n      }\n\n      if (line_breaker) {\n        y += font_size;\n        x = left;\n        continue;\n      } else {\n        chr = ' ';\n      }\n    }\n\n    if (font_get_glyph(c->font, chr, c->font_size, &g) == RET_OK) {\n      xy_t xx = x + g.x;\n      xy_t yy = y + g.y + baseline;\n\n      canvas_draw_glyph(c, &g, xx, yy);\n      x += g.advance + 1;\n    } else {\n      x += 4;\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_draw_text(canvas_t* c, const wchar_t* str, uint32_t nr, xy_t x, xy_t y) {\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, RET_BAD_PARAMS);\n  if (c->lcd->draw_text != NULL) {\n    return lcd_draw_text(c->lcd, str, nr, c->ox + x, c->oy + y);\n  } else {\n    return canvas_draw_text_impl(c, str, nr, c->ox + x, c->oy + y, FALSE);\n  }\n}\n\nret_t canvas_draw_utf8(canvas_t* c, const char* str, xy_t x, xy_t y) {\n  wstr_t s;\n  ret_t ret = RET_FAIL;\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, RET_BAD_PARAMS);\n\n  wstr_init(&s, 0);\n  return_value_if_fail(wstr_set_utf8(&s, str) == RET_OK, RET_OOM);\n\n  ret = canvas_draw_text(c, s.str, s.size, x, y);\n  wstr_reset(&s);\n\n  return ret;\n}\n\nstatic ret_t canvas_do_draw_image(canvas_t* c, bitmap_t* img, const rect_t* s, const rect_t* d) {\n  rect_t r;\n  rectf_t src;\n  rectf_t dst;\n  float_t scale_w = 0;\n  float_t scale_h = 0;\n\n  xy_t x = d->x;\n  xy_t y = d->y;\n  xy_t x2 = d->x + d->w - 1;\n  xy_t y2 = d->y + d->h - 1;\n\n  if (d->w <= 0 || d->h <= 0 || s->w <= 0 || s->h <= 0 ||\n      !canvas_is_rect_in_clip_rect(c, x, y, x2, y2)) {\n    return RET_OK;\n  }\n  canvas_get_clip_rect(c, &r);\n\n  dst.x = tk_max(x, r.x);\n  dst.y = tk_max(y, r.y);\n  dst.w = tk_min(x2, r.x + r.w - 1) - dst.x + 1;\n  dst.h = tk_min(y2, r.y + r.h - 1) - dst.y + 1;\n\n  /* 因为 blend 函数中缩放，使用 256 倍的定点数，所以这里为了减低多次转换数据出现误差 */\n  scale_w = ((s->w << 8) / d->w / 256.0f);\n  scale_h = ((s->h << 8) / d->h / 256.0f);\n\n  src.x = s->x + (dst.x - x) * scale_w;\n  src.y = s->y + (dst.y - y) * scale_h;\n  src.w = dst.w * s->w / d->w;\n  src.h = dst.h * s->h / d->h;\n\n  if (src.x >= img->w || src.y >= img->h) {\n    return RET_OK;\n  }\n\n  src.w = tk_min((img->w - src.x), src.w);\n  src.h = tk_min((img->h - src.y), src.h);\n\n  if (src.w <= 0 || src.h <= 0 || dst.w <= 0 || dst.h <= 0) {\n    return RET_OK;\n  }\n\n  return lcd_draw_image(c->lcd, img, &src, &dst);\n}\n\nret_t canvas_draw_image(canvas_t* c, bitmap_t* img, const rect_t* src, const rect_t* dst_in) {\n  rect_t d;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && src != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  d.x = c->ox + dst->x;\n  d.y = c->oy + dst->y;\n  d.w = dst->w;\n  d.h = dst->h;\n\n  return canvas_do_draw_image(c, img, src, &d);\n}\n\nstatic ret_t canvas_draw_image_repeat_default(canvas_t* c, bitmap_t* img, const rect_t* src_in,\n                                              const rect_t* dst_in, wh_t dst_w, wh_t dst_h) {\n  rect_t s;\n  rect_t d;\n  xy_t x = 0;\n  xy_t y = 0;\n  wh_t sw = 0;\n  wh_t sh = 0;\n  wh_t dw = 0;\n  wh_t dh = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL && src_in != NULL && dst_in != NULL,\n                       RET_BAD_PARAMS);\n\n  s.x = src_in->x;\n  s.y = src_in->y;\n  s.w = src_in->w;\n  s.h = src_in->h;\n\n  d = *dst;\n\n  while (y < dst->h) {\n    dh = tk_min(dst_h, dst->h - y);\n    sh = tk_min(src_in->h, dst->h - y);\n    while (x < dst->w) {\n      dw = tk_min(dst_w, dst->w - x);\n      sw = tk_min(src_in->w, dst->w - x);\n\n      s.w = sw;\n      s.h = sh;\n\n      d.w = dw;\n      d.h = dh;\n      d.x = x + dst->x;\n      d.y = y + dst->y;\n      canvas_draw_image(c, img, &s, &d);\n      x += dw;\n    }\n    y += dh;\n    x = 0;\n  }\n  return RET_OK;\n}\n\nstatic ret_t canvas_draw_image_repeat_x_impl(canvas_t* c, bitmap_t* img, const rect_t* src_in,\n                                             const rect_t* dst_in) {\n  rect_t d;\n  return_value_if_fail(\n      c != NULL && c->lcd != NULL && img != NULL && src_in != NULL && dst_in != NULL,\n      RET_BAD_PARAMS);\n  d.x = dst_in->x + c->ox;\n  d.y = dst_in->y + c->oy;\n  d.w = dst_in->w;\n  d.h = dst_in->h;\n\n  if (c->lcd->draw_image_repeat != NULL &&\n      c->lcd->draw_image_repeat(c->lcd, img, src_in, &d, src_in->w, dst_in->h) == RET_OK) {\n    return RET_OK;\n  }\n\n  return canvas_draw_image_repeat_default(c, img, src_in, dst_in, src_in->w, dst_in->h);\n}\n\nstatic ret_t canvas_draw_image_repeat_y_impl(canvas_t* c, bitmap_t* img, const rect_t* src_in,\n                                             const rect_t* dst_in) {\n  rect_t d;\n  return_value_if_fail(\n      c != NULL && c->lcd != NULL && img != NULL && src_in != NULL && dst_in != NULL,\n      RET_BAD_PARAMS);\n  d.x = dst_in->x + c->ox;\n  d.y = dst_in->y + c->oy;\n  d.w = dst_in->w;\n  d.h = dst_in->h;\n\n  if (c->lcd->draw_image_repeat != NULL &&\n      c->lcd->draw_image_repeat(c->lcd, img, src_in, &d, dst_in->w, src_in->h) == RET_OK) {\n    return RET_OK;\n  }\n\n  return canvas_draw_image_repeat_default(c, img, src_in, dst_in, dst_in->w, src_in->h);\n}\n\nstatic ret_t canvas_draw_image_repeat_impl(canvas_t* c, bitmap_t* img, const rect_t* src_in,\n                                           const rect_t* dst_in) {\n  rect_t d;\n  return_value_if_fail(\n      c != NULL && c->lcd != NULL && img != NULL && src_in != NULL && dst_in != NULL,\n      RET_BAD_PARAMS);\n  d.x = dst_in->x + c->ox;\n  d.y = dst_in->y + c->oy;\n  d.w = dst_in->w;\n  d.h = dst_in->h;\n\n  if (c->lcd->draw_image_repeat != NULL &&\n      c->lcd->draw_image_repeat(c->lcd, img, src_in, &d, src_in->w, src_in->h) == RET_OK) {\n    return RET_OK;\n  }\n\n  return canvas_draw_image_repeat_default(c, img, src_in, dst_in, src_in->w, src_in->h);\n}\n\nret_t canvas_draw_image_repeat(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  s.x = 0;\n  s.y = 0;\n  s.w = img->w;\n  s.h = img->h;\n  canvas_draw_image_repeat_impl(c, img, &s, dst_in);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_repeat9(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t x = 0;\n  xy_t y = 0;\n  wh_t w = 0;\n  wh_t h = 0;\n  wh_t w_w = 0;\n  wh_t h_h = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  wh_t image_w = 0;\n  wh_t image_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  image_w = tk_min(img_w, dst_w);\n  image_h = tk_min(img_h, dst_h);\n  w = image_w >> 1;\n  h = image_h >> 1;\n\n  w_w = dst_w - w * 2;\n  h_h = dst_h - h * 2;\n\n  /*draw four corners*/\n  /*left top*/\n  s = rect_init(0, 0, w, h);\n  d = rect_init(0, 0, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*right top*/\n  s = rect_init(img_w - w, 0, w, h);\n  d = rect_init(dst_w - w, 0, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*left bottom*/\n  s = rect_init(0, img_h - h, w, h);\n  d = rect_init(0, dst_h - h, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*right bottom*/\n  s = rect_init(img_w - w, img_h - h, w, h);\n  d = rect_init(dst_w - w, dst_h - h, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*fill center*/\n  x = w;\n  if (w_w > 0) {\n    int32_t tmp = image_w - w - w;\n    s = rect_init(tmp > 0 ? w : w - 1, 0, tmp > 0 ? tmp : 2, h);\n    d = rect_init(w, 0, w_w, h);\n    canvas_draw_image_repeat_x_impl(c, img, &s, &d);\n\n    s = rect_init(tmp > 0 ? w : w - 1, img_h - h, tmp > 0 ? tmp : 2, h);\n    d = rect_init(w, h + h_h, w_w, h);\n    canvas_draw_image_repeat_x_impl(c, img, &s, &d);\n  }\n\n  /*fill middle*/\n  y = h;\n  if (h_h > 0) {\n    int32_t tmp = image_h - h - h;\n    s = rect_init(0, tmp > 0 ? h : h - 1, w, tmp > 0 ? tmp : 2);\n    d = rect_init(0, h, w, h_h);\n    canvas_draw_image_repeat_y_impl(c, img, &s, &d);\n\n    s = rect_init(img_w - w, tmp > 0 ? h : h - 1, w, tmp > 0 ? tmp : 2);\n    d = rect_init(w + w_w, h, w, h_h);\n    canvas_draw_image_repeat_y_impl(c, img, &s, &d);\n  }\n\n  /*fill center/middle*/\n  if (w_w > 0 && h_h > 0) {\n    int32_t tmp_w = image_w - w - w;\n    int32_t tmp_h = image_h - h - h;\n    s = rect_init(tmp_w > 0 ? w : w - 1, tmp_h > 0 ? h : h - 1, tmp_w > 0 ? tmp_w : 2,\n                  tmp_h > 0 ? tmp_h : 2);\n    d = rect_init(w, h, w_w, h_h);\n    canvas_draw_image_repeat_impl(c, img, &s, &d);\n  }\n\n  canvas_untranslate(c, dst->x, dst->y);\n\n  (void)x;\n  (void)y;\n  (void)dst_w;\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_repeat_x(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  s.x = 0;\n  s.y = 0;\n  s.w = img->w;\n  s.h = img->h;\n\n  canvas_draw_image_repeat_x_impl(c, img, &s, dst_in);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_repeat3_x(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t y = 0;\n  wh_t w = 0;\n  wh_t w_w = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  wh_t image_w = 0;\n  int32_t tmp = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  image_w = tk_min(img_w, dst_w);\n  w = image_w >> 1;\n  w_w = dst_w - (w << 1);\n\n  y = (dst_h - img_h) >> 1;\n  if (y < 0) {\n    img_h += y;\n    y = 0;\n  }\n\n  /*left*/\n  s = rect_init(0, 0, w, img_h);\n  d = rect_init(0, y, w, img_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*center*/\n  tmp = image_w - w - w;\n  if (dst_w > img_w) {\n    s = rect_init(w, 0, tmp > 0 ? tmp : 2, img_h);\n    d = rect_init(w, y, w_w, img_h);\n    canvas_draw_image_repeat_x_impl(c, img, &s, &d);\n  }\n\n  /*right*/\n  s = rect_init(img_w - w, 0, w, img_h);\n  d = rect_init(dst_w - w, y, w, img_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  canvas_untranslate(c, dst->x, dst->y);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_repeat_y(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  s.x = 0;\n  s.y = 0;\n  s.w = img->w;\n  s.h = img->h;\n  canvas_draw_image_repeat_y_impl(c, img, &s, dst_in);\n  return RET_OK;\n}\n\nret_t canvas_draw_image_repeat3_y(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t x = 0;\n  wh_t h = 0;\n  wh_t h_h = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  wh_t image_h = 0;\n  int32_t tmp = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  image_h = tk_min(img_h, dst_h);\n  h = image_h >> 1;\n  h_h = dst_h - (h << 1);\n\n  x = (dst->w - img->w) >> 1;\n  if (x < 0) {\n    img_w += x;\n    x = 0;\n  }\n  /*top*/\n  s = rect_init(0, 0, img_w, h);\n  d = rect_init(x, 0, img_w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*middle*/\n  tmp = image_h - h - h;\n  if (dst_h > img_h) {\n    s = rect_init(0, tmp > 0 ? h : h - 1, img_w, tmp > 0 ? tmp : 2);\n    d = rect_init(x, h, img_w, h_h);\n    canvas_draw_image_repeat_y_impl(c, img, &s, &d);\n  }\n\n  /*bottom*/\n  s = rect_init(0, img_h - h, img_w, h);\n  d = rect_init(x, dst_h - h, img_w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  canvas_untranslate(c, dst->x, dst->y);\n  (void)dst_w;\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_repeat_y_inverse(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t y = 0;\n  wh_t h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  s.x = 0;\n  s.y = 0;\n  s.w = img->w;\n  s.h = img->h;\n\n  d = *dst;\n\n  while (y < dst->h) {\n    h = tk_min(img->h, dst->h - y);\n    s.h = h;\n    d.h = h;\n    y += h;\n    d.y = dst->y + (dst->h - y);\n\n    if (s.h < img->h) {\n      s.y = img->h - s.h;\n      canvas_draw_image(c, img, &s, &d);\n    } else {\n      s.y = 0;\n      canvas_draw_image(c, img, &s, &d);\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_patch3_y_scale_x(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  wh_t h = 0;\n  wh_t h_h = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  h = tk_min(img_h, dst_h) / 3;\n  h_h = dst_h - h * 2;\n\n  /*top*/\n  s = rect_init(0, 0, img_w, h);\n  d = rect_init(0, 0, dst_w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*middle*/\n  s = rect_init(0, h, img_w, img_h - 2 * h);\n  d = rect_init(0, h, dst_w, h_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*bottom*/\n  s = rect_init(0, img_h - h, img_w, h);\n  d = rect_init(0, dst_h - h, dst_w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  canvas_untranslate(c, dst->x, dst->y);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_patch3_y(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t x = 0;\n  wh_t h = 0;\n  wh_t h_h = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  h = tk_min(img_h, dst_h) / 3;\n  h_h = dst_h - h * 2;\n\n  x = (dst->w - img->w) >> 1;\n  /*top*/\n  s = rect_init(0, 0, img_w, h);\n  d = rect_init(x, 0, img_w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*middle*/\n  s = rect_init(0, h, img_w, img_h - 2 * h);\n  d = rect_init(x, h, img_w, h_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*bottom*/\n  s = rect_init(0, img_h - h, img_w, h);\n  d = rect_init(x, dst_h - h, img_w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  canvas_untranslate(c, dst->x, dst->y);\n  (void)dst_w;\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_patch3_x_scale_y(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  wh_t w = 0;\n  wh_t w_w = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  w = tk_min(img_w, dst_w) / 3;\n  w_w = dst_w - w * 2;\n\n  /*left*/\n  s = rect_init(0, 0, w, img_h);\n  d = rect_init(0, 0, w, dst_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*center*/\n  s = rect_init(w, 0, img_w - 2 * w, img_h);\n  d = rect_init(w, 0, w_w, dst_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*right*/\n  s = rect_init(img_w - w, 0, w, img_h);\n  d = rect_init(dst_w - w, 0, w, dst_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  canvas_untranslate(c, dst->x, dst->y);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_patch3_x(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t y = 0;\n  wh_t w = 0;\n  wh_t w_w = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  w = tk_min(img_w, dst_w) / 3;\n  w_w = dst_w - w * 2;\n\n  y = (dst_h - img_h) >> 1;\n  /*left*/\n  s = rect_init(0, 0, w, img_h);\n  d = rect_init(0, y, w, img_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*center*/\n  s = rect_init(w, 0, img_w - 2 * w, img_h);\n  d = rect_init(w, y, w_w, img_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*right*/\n  s = rect_init(img_w - w, 0, w, img_h);\n  d = rect_init(dst_w - w, y, w, img_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  canvas_untranslate(c, dst->x, dst->y);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_patch9(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t x = 0;\n  xy_t y = 0;\n  wh_t w = 0;\n  wh_t h = 0;\n  wh_t w_w = 0;\n  wh_t h_h = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  w = tk_min(img_w, dst_w) / 3;\n  h = tk_min(img_h, dst_h) / 3;\n\n  w_w = dst_w - w * 2;\n  h_h = dst_h - h * 2;\n\n  /*draw four corners*/\n  /*left top*/\n  s = rect_init(0, 0, w, h);\n  d = rect_init(0, 0, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*right top*/\n  s = rect_init(img_w - w, 0, w, h);\n  d = rect_init(dst_w - w, 0, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*left bottom*/\n  s = rect_init(0, img_h - h, w, h);\n  d = rect_init(0, dst_h - h, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*right bottom*/\n  s = rect_init(img_w - w, img_h - h, w, h);\n  d = rect_init(dst_w - w, dst_h - h, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*fill center*/\n  x = w;\n  if (w_w > 0) {\n    s = rect_init(w, 0, img_w - 2 * w, h);\n    d = rect_init(w, 0, w_w, h);\n    canvas_draw_image(c, img, &s, &d);\n\n    s = rect_init(w, img_h - h, img_w - 2 * w, h);\n    d = rect_init(w, h + h_h, w_w, h);\n    canvas_draw_image(c, img, &s, &d);\n  }\n\n  /*fill middle*/\n  y = h;\n  if (h_h > 0) {\n    s = rect_init(0, h, w, img_h - 2 * h);\n    d = rect_init(0, h, w, h_h);\n    canvas_draw_image(c, img, &s, &d);\n\n    s = rect_init(img_w - w, h, w, img_h - 2 * h);\n    d = rect_init(w + w_w, h, w, h_h);\n    canvas_draw_image(c, img, &s, &d);\n  }\n\n  /*fill center/middle*/\n  if (w_w > 0 && h_h > 0) {\n    s = rect_init(w, h, img_w - 2 * w, img_h - 2 * h);\n    d = rect_init(w, h, w_w, h_h);\n    canvas_draw_image(c, img, &s, &d);\n  }\n\n  canvas_untranslate(c, dst->x, dst->y);\n\n  (void)x;\n  (void)y;\n  (void)dst_w;\n\n  return RET_OK;\n}\n\nret_t canvas_end_frame(canvas_t* c) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  if (c->began_frame) {\n    c->began_frame = FALSE;\n  } else {\n    return RET_OK;\n  }\n\n  if (c->end_frame != NULL) {\n    return c->end_frame(c);\n  }\n\n  canvas_draw_fps(c);\n  canvas_set_global_alpha(c, 0xff);\n\n  return lcd_end_frame(c->lcd);\n}\n\nret_t canvas_draw_image_scale_w(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  wh_t src_h = 0;\n  wh_t dst_h = 0;\n  float scale = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  scale = (float)(dst->w) / img->w;\n  dst_h = tk_min(img->h * scale, dst->h);\n  src_h = tk_min(img->h, dst_h / scale);\n\n  s.x = 0;\n  s.y = 0;\n  s.w = img->w;\n  s.h = src_h;\n\n  d = *dst;\n  d.h = dst_h;\n\n  return canvas_draw_image(c, img, &s, &d);\n}\n\nret_t canvas_draw_image_scale_h(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  wh_t src_w = 0;\n  wh_t dst_w = 0;\n  float scale = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  scale = (float)(dst->h) / img->h;\n  dst_w = tk_min(img->w * scale, dst->w);\n  src_w = tk_min(img->w, dst_w / scale);\n\n  s.x = 0;\n  s.y = 0;\n  s.h = img->h;\n  s.w = src_w;\n\n  d = *dst;\n  d.w = dst_w;\n\n  return canvas_draw_image(c, img, &s, &d);\n}\n\nret_t canvas_draw_image_scale(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  float scale = 0;\n  float scalex = 0;\n  float scaley = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  s.x = 0;\n  s.y = 0;\n  s.h = img->h;\n  s.w = img->w;\n\n  scalex = (float)(dst->w) / img->w;\n  scaley = (float)(dst->h) / img->h;\n  scale = tk_min(scalex, scaley);\n\n  d.w = img->w * scale;\n  d.h = img->h * scale;\n  d.x = dst->x + ((dst->w - d.w) >> 1);\n  d.y = dst->y + ((dst->h - d.h) >> 1);\n\n  return canvas_draw_image(c, img, &s, &d);\n}\n\nret_t canvas_draw_image_scale_down(canvas_t* c, bitmap_t* img, const rect_t* src,\n                                   const rect_t* dst_in) {\n  rect_t d;\n  float scale = 0;\n  float scalex = 0;\n  float scaley = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && src != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  scalex = (float)(dst->w) / src->w;\n  scaley = (float)(dst->h) / src->h;\n  scale = tk_min(scalex, scaley);\n\n  if (scale >= 1) {\n    d.w = src->w;\n    d.h = src->h;\n  } else {\n    d.w = src->w * scale;\n    d.h = src->h * scale;\n  }\n  d.x = dst->x + ((dst->w - d.w) >> 1);\n  d.y = dst->y + ((dst->h - d.h) >> 1);\n\n  return canvas_draw_image(c, img, src, &d);\n}\n\nret_t canvas_draw_image_matrix(canvas_t* c, bitmap_t* img, matrix_t* matrix) {\n  draw_image_info_t info;\n  return_value_if_fail(c != NULL && img != NULL && matrix != NULL && c->lcd != NULL,\n                       RET_BAD_PARAMS);\n\n  info.img = img;\n  info.matrix = *matrix;\n  info.src = rect_init(0, 0, img->w, img->h);\n  info.dst = rect_init(0, 0, img->w, img->h);\n  canvas_get_clip_rect(c, &info.clip);\n\n  return lcd_draw_image_matrix(c->lcd, &info);\n}\n\nret_t canvas_draw_image_ex(canvas_t* c, bitmap_t* img, image_draw_type_t draw_type,\n                           const rect_t* dst_in) {\n  rect_t src;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n  switch (draw_type) {\n    case IMAGE_DRAW_DEFAULT:\n      src = rect_init(0, 0, tk_min(dst->w, img->w), tk_min(dst->h, img->h));\n      dst->w = src.w;\n      dst->h = src.h;\n      return canvas_draw_image(c, img, &src, dst);\n    case IMAGE_DRAW_CENTER:\n      return canvas_draw_image_center(c, img, dst);\n    case IMAGE_DRAW_SCALE:\n      src = rect_init(0, 0, img->w, img->h);\n      return canvas_draw_image(c, img, &src, dst);\n    case IMAGE_DRAW_SCALE_AUTO:\n      return canvas_draw_image_scale(c, img, dst);\n    case IMAGE_DRAW_SCALE_DOWN: {\n      rect_t src = rect_init(0, 0, img->w, img->h);\n      return canvas_draw_image_scale_down(c, img, &src, dst);\n    }\n#ifndef AWTK_LITE\n    case IMAGE_DRAW_ICON: {\n      xy_t cx = dst->x + (dst->w >> 1);\n      xy_t cy = dst->y + (dst->h >> 1);\n      return canvas_draw_icon(c, img, cx, cy);\n    }\n    case IMAGE_DRAW_SCALE_W:\n      return canvas_draw_image_scale_w(c, img, dst);\n    case IMAGE_DRAW_SCALE_H:\n      return canvas_draw_image_scale_h(c, img, dst);\n    case IMAGE_DRAW_REPEAT:\n      return canvas_draw_image_repeat(c, img, dst);\n    case IMAGE_DRAW_REPEAT_X:\n      return canvas_draw_image_repeat_x(c, img, dst);\n    case IMAGE_DRAW_REPEAT_Y:\n      return canvas_draw_image_repeat_y(c, img, dst);\n    case IMAGE_DRAW_REPEAT_Y_INVERSE:\n      return canvas_draw_image_repeat_y_inverse(c, img, dst);\n    case IMAGE_DRAW_PATCH9:\n      return canvas_draw_image_patch9(c, img, dst);\n    case IMAGE_DRAW_PATCH3_X:\n      return canvas_draw_image_patch3_x(c, img, dst);\n    case IMAGE_DRAW_PATCH3_Y:\n      return canvas_draw_image_patch3_y(c, img, dst);\n    case IMAGE_DRAW_PATCH3_X_SCALE_Y:\n      return canvas_draw_image_patch3_x_scale_y(c, img, dst);\n    case IMAGE_DRAW_PATCH3_Y_SCALE_X:\n      return canvas_draw_image_patch3_y_scale_x(c, img, dst);\n    case IMAGE_DRAW_REPEAT9:\n      return canvas_draw_image_repeat9(c, img, dst);\n    case IMAGE_DRAW_REPEAT3_X:\n      return canvas_draw_image_repeat3_x(c, img, dst);\n    case IMAGE_DRAW_REPEAT3_Y:\n      return canvas_draw_image_repeat3_y(c, img, dst);\n#endif /*AWTK_LITE*/\n    default:\n      return canvas_draw_image_center(c, img, dst);\n  }\n}\n\nret_t canvas_draw_image_ex2(canvas_t* c, bitmap_t* img, image_draw_type_t draw_type,\n                            const rect_t* src_in, const rect_t* dst_in) {\n  rect_t src;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(bitmap_check_rect(img, src_in), RET_BAD_PARAMS);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  switch (draw_type) {\n    case IMAGE_DRAW_DEFAULT:\n      src = *src_in;\n      dst->w = src.w;\n      dst->h = src.h;\n      return canvas_draw_image(c, img, &src, dst);\n    case IMAGE_DRAW_ICON: {\n      xy_t cx = dst->x + (dst->w >> 1);\n      xy_t cy = dst->y + (dst->h >> 1);\n      return canvas_draw_icon_ex(c, img, src_in, cx, cy);\n    }\n    case IMAGE_DRAW_CENTER:\n      return canvas_draw_image_center_ex(c, img, src_in, dst);\n    case IMAGE_DRAW_SCALE:\n      return canvas_draw_image(c, img, src_in, dst);\n    default:\n      /*TODO*/\n      assert(!\"not supported yet!\");\n      return RET_FAIL;\n  }\n}\n\nstatic ret_t canvas_draw_icon_ex(canvas_t* c, bitmap_t* img, const rect_t* src_r, xy_t cx,\n                                 xy_t cy) {\n  rect_t src;\n  rect_t dst;\n  wh_t hw = 0;\n  wh_t hh = 0;\n  float_t ratio = 0;\n  return_value_if_fail(c != NULL && c->lcd != NULL && img != NULL && src_r != NULL, RET_BAD_PARAMS);\n\n  src = *src_r;\n  ratio = c->lcd->ratio;\n  if (ratio > 1) {\n    float_t w = (src.w / ratio);\n    float_t h = (src.h / ratio);\n    float_t hw = w / 2;\n    float_t hh = h / 2;\n\n    dst = rect_init(cx - hw, cy - hh, w, h);\n  } else {\n    hw = src.w >> 1;\n    hh = src.h >> 1;\n    dst = rect_init(cx - hw, cy - hh, src.w, src.h);\n  }\n\n  return canvas_draw_image(c, img, &src, &dst);\n}\n\nret_t canvas_draw_icon(canvas_t* c, bitmap_t* img, xy_t cx, xy_t cy) {\n  rect_t src;\n  return_value_if_fail(c != NULL && c->lcd != NULL && img != NULL, RET_BAD_PARAMS);\n  src = rect_init(0, 0, img->w, img->h);\n\n  return canvas_draw_icon_ex(c, img, &src, cx, cy);\n}\n\nret_t canvas_draw_icon_in_rect(canvas_t* c, bitmap_t* img, const rect_t* r_in) {\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* r = canvas_fix_rect(r_in, &r_fix);\n  return_value_if_fail(c != NULL && c->lcd != NULL && img != NULL && r != NULL, RET_BAD_PARAMS);\n\n  return canvas_draw_icon(c, img, r->x + (r->w >> 1), r->y + (r->h >> 1));\n}\n\nstatic ret_t canvas_draw_image_center_ex(canvas_t* c, bitmap_t* img, const rect_t* src_r,\n                                         const rect_t* dst_in) {\n  xy_t dx = 0;\n  xy_t dy = 0;\n  xy_t sx = 0;\n  xy_t sy = 0;\n  wh_t sw = 0;\n  wh_t sh = 0;\n  rect_t src;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  dx = ((dst->w - src_r->w) >> 1);\n  dy = ((dst->h - src_r->h) >> 1);\n\n  if (dx < 0) {\n    sx = -dx;\n    dx = 0;\n    sw = src_r->w - 2 * sx;\n  } else {\n    sw = src_r->w;\n  }\n\n  if (dy < 0) {\n    sy = -dy;\n    dy = 0;\n    sh = src_r->h - 2 * sy;\n  } else {\n    sh = src_r->h;\n  }\n\n  dx += dst->x;\n  dy += dst->y;\n\n  src = rect_init(sx + src_r->x, sy + src_r->y, sw, sh);\n  *dst = rect_init(dx, dy, sw, sh);\n\n  return canvas_draw_image(c, img, &src, dst);\n}\n\nret_t canvas_draw_image_center(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t src;\n  return_value_if_fail(c != NULL && img != NULL && dst_in != NULL, RET_BAD_PARAMS);\n  src = rect_init(0, 0, img->w, img->h);\n\n  return canvas_draw_image_center_ex(c, img, &src, dst_in);\n}\n\nret_t canvas_draw_image_at(canvas_t* c, bitmap_t* img, xy_t x, xy_t y) {\n  rect_t src;\n  rect_t dst;\n  float_t ratio = 0;\n  return_value_if_fail(c != NULL && c->lcd != NULL && img != NULL, RET_BAD_PARAMS);\n\n  x += c->ox;\n  y += c->oy;\n  ratio = c->lcd->ratio;\n  src = rect_init(0, 0, img->w, img->h);\n\n  if (ratio > 1) {\n    dst = rect_init(x, y, img->w / ratio, img->h / ratio);\n  } else {\n    dst = rect_init(x, y, img->w, img->h);\n  }\n\n  return canvas_do_draw_image(c, img, &src, &dst);\n}\n\nret_t canvas_set_fps(canvas_t* c, bool_t show_fps, uint32_t fps) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  c->show_fps = show_fps;\n  c->fps = fps;\n\n  return RET_OK;\n}\n\nstatic ret_t canvas_draw_fps(canvas_t* c) {\n  lcd_t* lcd = c->lcd;\n\n  if (c->show_fps && c->lcd->draw_mode == LCD_DRAW_NORMAL) {\n    rect_t r;\n    char fps[20];\n    wchar_t wfps[20];\n\n    r = rect_init(0, 0, 60, 30);\n    canvas_set_font(c, NULL, 16);\n    canvas_set_text_color(c, color_init(0xf0, 0xf0, 0xf0, 0xff));\n    canvas_set_fill_color(c, color_init(0x20, 0x20, 0x20, 0xff));\n\n    lcd->fps_rect = r;\n    tk_snprintf(fps, sizeof(fps), \"%dfps\", (int)(c->fps));\n\n    tk_utf8_to_utf16(fps, wfps, strlen(fps) + 1);\n    canvas_fill_rect(c, r.x, r.y, r.w, r.h);\n    canvas_draw_text(c, wfps, wcslen(wfps), r.x + 8, r.y + 8);\n  } else {\n    lcd->fps_rect.w = 0;\n    lcd->fps_rect.h = 0;\n  }\n\n  return RET_OK;\n}\n\nfloat_t canvas_get_font_height(canvas_t* c) {\n  font_vmetrics_t vmetrics;\n  return_value_if_fail(c != NULL && c->font_size > 0, 0);\n  vmetrics = font_get_vmetrics(c->font, c->font_size);\n\n  return vmetrics.ascent - vmetrics.descent;\n}\n\nret_t canvas_draw_text_in_rect(canvas_t* c, const wchar_t* str, uint32_t nr, const rect_t* r_in) {\n  int x = 0;\n  int y = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  int32_t text_w = 0;\n  int32_t height = canvas_get_font_height(c);\n  rect_t* r = canvas_fix_rect(r_in, &r_fix);\n  return_value_if_fail(c != NULL && str != NULL && r != NULL, RET_BAD_PARAMS);\n\n  text_w = canvas_measure_text(c, str, nr);\n\n  switch (c->text_align_v) {\n    case ALIGN_V_TOP:\n      y = r->y;\n      break;\n    case ALIGN_V_BOTTOM:\n      y = r->y + (r->h - height);\n      break;\n    default:\n      y = r->y + ((r->h - height) >> 1);\n      break;\n  }\n\n  switch (c->text_align_h) {\n    case ALIGN_H_LEFT:\n      x = r->x;\n      break;\n    case ALIGN_H_RIGHT:\n      x = r->x + (r->w - text_w);\n      break;\n    default:\n      x = r->x + ((r->w - text_w) >> 1);\n      break;\n  }\n\n  return canvas_draw_text(c, str, nr, x, y);\n}\n\n#define STR_ELLIPSES L\"...\"\n\nstatic ret_t canvas_draw_text_in_rect_ellipses(canvas_t* c, const wchar_t* str, uint32_t nr,\n                                               const rect_t* r_in, bidi_type_t type) {\n  uint32_t i = 0;\n  rect_t r = *r_in;\n  float_t text_w = 0;\n  float_t ellipses_w = canvas_measure_text(c, STR_ELLIPSES, wcslen(STR_ELLIPSES));\n\n  for (i = 0; i < nr; i++) {\n    float_t char_w = canvas_measure_text(c, str + i, 1);\n    if ((text_w + char_w + ellipses_w) >= r.w) {\n      break;\n    }\n\n    text_w += char_w;\n  }\n\n  r.w = text_w;\n  canvas_draw_text_in_rect(c, str, i, &r);\n  r.x = text_w;\n  r.w = ellipses_w;\n  canvas_draw_text_in_rect(c, STR_ELLIPSES, wcslen(STR_ELLIPSES), &r);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_text_bidi_in_rect(canvas_t* c, const wchar_t* str, uint32_t nr,\n                                    const rect_t* r_in, const char* bidi_type, bool_t ellipses) {\n  bidi_t b;\n  ret_t ret = RET_FAIL;\n  return_value_if_fail(c != NULL && str != NULL && r_in != NULL, RET_BAD_PARAMS);\n\n  if (nr == 0) {\n    return RET_OK;\n  }\n\n  bidi_init(&b, FALSE, FALSE, bidi_type_from_name(bidi_type));\n  if (bidi_log2vis(&b, str, nr) == RET_OK) {\n    float_t text_w = canvas_measure_text(c, b.vis_str, b.vis_str_size);\n    if (ellipses && text_w > r_in->w) {\n      ret = canvas_draw_text_in_rect_ellipses(c, b.vis_str, b.vis_str_size, r_in, b.resolved_type);\n    } else {\n      ret = canvas_draw_text_in_rect(c, b.vis_str, b.vis_str_size, r_in);\n    }\n  } else {\n    assert(!\"log2vis failed!\");\n  }\n\n  bidi_deinit(&b);\n\n  return ret;\n}\n\nret_t canvas_draw_utf8_in_rect(canvas_t* c, const char* str, const rect_t* r) {\n  wstr_t s;\n  ret_t ret = RET_FAIL;\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL && r != NULL, RET_BAD_PARAMS);\n\n  wstr_init(&s, 0);\n  return_value_if_fail(wstr_set_utf8(&s, str) == RET_OK, RET_OOM);\n\nret = ",
    "raw_res": "",
    "prompt_res": "canvas_draw_text_in_rect(c, s.str, s.size, r);",
    "gt": "canvas_draw_text_in_rect(c, s.str, s.size, r);"
  },
  {
    "id": 2157,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/events.c",
    "input": "﻿/**\n * File:   events.c\n * Author: AWTK Develop Team\n * Brief:  events structs\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-03-02 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"base/events.h\"\n#include \"tkc/time_now.h\"\n#include \"base/lcd_orientation_helper.h\"\n\nwheel_event_t* wheel_event_cast(event_t* event) {\n  return_value_if_fail(event != NULL, NULL);\n  return_value_if_fail(event->type == EVT_WHEEL || event->type == EVT_WHEEL_BEFORE_CHILDREN, NULL);\n  return_value_if_fail(event->size == sizeof(wheel_event_t), NULL);\n\n  return (wheel_event_t*)event;\n}\n\norientation_event_t* orientation_event_cast(event_t* event) {\n  return_value_if_fail(event != NULL, NULL);\n  return_value_if_fail(\n      event->type == EVT_ORIENTATION_CHANGED || event->type == EVT_ORIENTATION_WILL_CHANGED, NULL);\n  return_value_if_fail(event->size == sizeof(orientation_event_t), NULL);\n\n  return (orientation_event_t*)event;\n}\n\npointer_event_t* pointer_event_cast(event_t* event) {\n  return_value_if_fail(event != NULL, NULL);\n  return_value_if_fail(event->type >= EVT_POINTER_DOWN && event->type <= EVT_CLICK, NULL);\n  return_value_if_fail(event->size == sizeof(pointer_event_t), NULL);\n\n  return (pointer_event_t*)event;\n}\n\nvalue_change_event_t* value_change_event_cast(event_t* event) {\n  return_value_if_fail(event != NULL, NULL);\n  return_value_if_fail(event->type >= EVT_VALUE_WILL_CHANGE && event->type <= EVT_VALUE_CHANGING,\n                       NULL);\n  return_value_if_fail(event->size == sizeof(value_change_event_t), NULL);\n\n  return (value_change_event_t*)event;\n}\n\noffset_change_event_t* offset_change_event_cast(event_t* event) {\n  return_value_if_fail(event != NULL, NULL);\n  return_value_if_fail(event->size == sizeof(offset_change_event_t), NULL);\n\n  return (offset_change_event_t*)event;\n}\n\nkey_event_t* key_event_cast(event_t* event) {\n  return_value_if_fail(event != NULL, NULL);\n  return_value_if_fail(event->type >= EVT_KEY_DOWN && event->type <= EVT_KEY_UP_BEFORE_CHILDREN,\n                       NULL);\n  return_value_if_fail(event->size == sizeof(key_event_t), NULL);\n\n  return (key_event_t*)event;\n}\n\npaint_event_t* paint_event_cast(event_t* event) {\n  return_value_if_fail(event != NULL, NULL);\n  return_value_if_fail(\n      event->type == EVT_PAINT || event->type == EVT_BEFORE_PAINT || event->type == EVT_AFTER_PAINT,\n      NULL);\n  return_value_if_fail(event->size == sizeof(paint_event_t), NULL);\n\n  return (paint_event_t*)event;\n}\n\nwindow_event_t* window_event_cast(event_t* event) {\n  return_value_if_fail(event != NULL, NULL);\n  return_value_if_fail(event->type == EVT_WINDOW_WILL_OPEN || event->type == EVT_WINDOW_OPEN ||\n                           event->type == EVT_WINDOW_CLOSE,\n                       NULL);\n  return_value_if_fail(event->size == sizeof(window_event_t), NULL);\n\n  return (window_event_t*)event;\n}\n\nret_t pointer_event_rotate(pointer_event_t* evt, system_info_t* info) {\n  return_value_if_fail(evt != NULL && info != NULL, RET_BAD_PARAMS);\n  return lcd_orientation_point_rotate_by_clockwise(&evt->x, &evt->y, info->lcd_orientation,\n                                                   info->lcd_w, info->lcd_h);\n}\n\nevent_t* wheel_event_init(wheel_event_t* event, uint32_t type, void* target, int32_t dy) {\n  return_value_if_fail(event != NULL, NULL);\n  memset(event, 0x00, sizeof(wheel_event_t));\n\nevent->e = ",
    "raw_res": "0;",
    "prompt_res": "event_init(type, target);",
    "gt": "event_init(type, target);"
  },
  {
    "id": 2167,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/self_layouter_factory.c",
    "input": "﻿/**\n * File:   self_layouter_factory.c\n * Author: AWTK Develop Team\n * Brief:  self layouter factory\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-03-27 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"base/enums.h\"\n#include \"tkc/easing.h\"\n#include \"base/window_manager.h\"\n#include \"tkc/func_call_parser.h\"\n#include \"base/self_layouter_factory.h\"\n\nstatic self_layouter_factory_t* self_layouter_factory_init(self_layouter_factory_t* factory);\nstatic ret_t self_layouter_factory_deinit(self_layouter_factory_t* factory);\n\nstatic self_layouter_factory_t* s_self_layouter_factory = NULL;\n\ntypedef struct _creator_item_t {\n  char type[TK_NAME_LEN + 1];\n  self_layouter_create_t create;\n} creator_item_t;\n\nstatic int32_t creator_item_cmp(const creator_item_t* iter, const char* type) {\n  return strcmp(iter->type, type);\n}\n\nself_layouter_factory_t* self_layouter_factory(void) {\n  return s_self_layouter_factory;\n}\n\nself_layouter_factory_t* self_layouter_factory_create(void) {\n  self_layouter_factory_t* factory = TKMEM_ZALLOC(self_layouter_factory_t);\n  return_value_if_fail(factory != NULL, NULL);\n\n  return self_layouter_factory_init(factory);\n}\n\nstatic self_layouter_factory_t* self_layouter_factory_init(self_layouter_factory_t* factory) {\n  return_value_if_fail(factory != NULL, NULL);\n\n  darray_init(&(factory->creators), 0, default_destroy, (tk_compare_t)creator_item_cmp);\n\n  return factory;\n}\n\nret_t self_layouter_factory_register(self_layouter_factory_t* factory, const char* type,\n                                     self_layouter_create_t create) {\n  creator_item_t* item = NULL;\n  return_value_if_fail(factory != NULL && type != NULL && create != NULL, RET_BAD_PARAMS);\n\n  item = TKMEM_ZALLOC(creator_item_t);\n  return_value_if_fail(item != NULL, RET_OOM);\n\n  item->create = create;\n  tk_strncpy(item->type, type, TK_NAME_LEN);\n  darray_push(&(factory->creators), item);\n\n  return RET_OK;\n}\n\nself_layouter_t* self_layouter_factory_create_layouter(self_layouter_factory_t* factory,\n                                                       const char* type) {\n  const creator_item_t* iter = NULL;\n  return_value_if_fail(factory != NULL && type != NULL, NULL);\n\niter = ",
    "raw_res": "darray_find(&(factory->creators), type, (tk_compare_t)creator_item_cmp);",
    "prompt_res": "darray_find(&(factory->creators), (void*)type);",
    "gt": "darray_find(&(factory->creators), (void*)type);"
  },
  {
    "id": 2195,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/children_layouter_factory.c",
    "input": "﻿/**\n * File:   children_layouter_factory.c\n * Author: AWTK Develop Team\n * Brief:  children layouter factory\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-03-27 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"base/enums.h\"\n#include \"tkc/easing.h\"\n#include \"base/window_manager.h\"\n#include \"tkc/func_call_parser.h\"\n#include \"base/children_layouter_factory.h\"\n\nstatic children_layouter_factory_t* children_layouter_factory_init(\n    children_layouter_factory_t* factory);\nstatic ret_t children_layouter_factory_deinit(children_layouter_factory_t* factory);\n\nstatic children_layouter_factory_t* s_children_layouter_factory = NULL;\n\ntypedef struct _creator_item_t {\n  char type[TK_NAME_LEN + 1];\n  children_layouter_create_t create;\n} creator_item_t;\n\nstatic int32_t creator_item_cmp(const creator_item_t* iter, const char* type) {\n  return strcmp(iter->type, type);\n}\n\nchildren_layouter_factory_t* children_layouter_factory(void) {\n  return s_children_layouter_factory;\n}\n\nchildren_layouter_factory_t* children_layouter_factory_create(void) {\n  children_layouter_factory_t* factory = TKMEM_ZALLOC(children_layouter_factory_t);\n  return_value_if_fail(factory != NULL, NULL);\n\n  return children_layouter_factory_init(factory);\n}\n\nstatic children_layouter_factory_t* children_layouter_factory_init(\n    children_layouter_factory_t* factory) {\n  return_value_if_fail(factory != NULL, NULL);\n\n  darray_init(&(factory->creators), 0, default_destroy, (tk_compare_t)creator_item_cmp);\n\n  return factory;\n}\n\nret_t children_layouter_factory_register(children_layouter_factory_t* factory, const char* type,\n                                         children_layouter_create_t create) {\n  creator_item_t* item = NULL;\n  return_value_if_fail(factory != NULL && type != NULL && create != NULL, RET_BAD_PARAMS);\n\n  item = TKMEM_ZALLOC(creator_item_t);\n  return_value_if_fail(item != NULL, RET_OOM);\n\n  item->create = create;\n  tk_strncpy(item->type, type, TK_NAME_LEN);\n  darray_push(&(factory->creators), item);\n\n  return RET_OK;\n}\n\nchildren_layouter_t* children_layouter_factory_create_layouter(children_layouter_factory_t* factory,\n                                                               const char* type) {\n  const creator_item_t* iter = NULL;\n  return_value_if_fail(factory != NULL && type != NULL, NULL);\n\niter = ",
    "raw_res": "darray_find(&(factory->creators), type);",
    "prompt_res": "darray_find(&(factory->creators), (void*)type);",
    "gt": "darray_find(&(factory->creators), (void*)type);"
  },
  {
    "id": 2203,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/widget_animator.c",
    "input": "﻿/**\n * File:   widget_animator.h\n * Author: AWTK Develop Team\n * Brief:  widget animator interface\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-05-15 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"base/widget_animator.h\"\n#include \"base/widget_animator_manager.h\"\n\nstatic ret_t widget_animator_update(widget_animator_t* animator, float_t percent);\n\nstatic ret_t widget_animator_on_widget_destroy(void* ctx, event_t* e) {\n  widget_animator_t* animator = (widget_animator_t*)ctx;\n\n  animator->widget_destroy_id = TK_INVALID_ID;\n  widget_animator_destroy(animator);\n\n  return RET_OK;\n}\n\nret_t widget_animator_init(widget_animator_t* animator, widget_t* widget, uint32_t duration,\n                           uint32_t delay, easing_func_t easing) {\n  return_value_if_fail(animator != NULL && widget != NULL, RET_BAD_PARAMS);\n\n  animator->delay = delay;\n  animator->widget = widget;\n  animator->repeat_times = 0;\n  animator->time_scale = 1;\n  animator->duration = duration;\n  animator->state = ANIMATOR_CREATED;\n  emitter_init(&(animator->emitter));\n  animator->easing = easing != NULL ? easing : easing_get(EASING_LINEAR);\n  animator->widget_destroy_id =\n      widget_on(widget, EVT_DESTROY, widget_animator_on_widget_destroy, animator);\n  widget_animator_set_destroy_when_done(animator, TRUE);\n\n  widget_animator_manager_add(widget_animator_manager(), animator);\n\n  return RET_OK;\n}\n\nret_t widget_animator_time_elapse(widget_animator_t* animator, uint32_t delta_time) {\n  uint32_t end_time = 0;\n  float_t time_percent = 0;\n  uint32_t elapsed_time = 0;\n  return_value_if_fail(animator != NULL, RET_BAD_PARAMS);\n\n  if (animator->state != ANIMATOR_RUNNING) {\n    return RET_OK;\n  }\n\n  elapsed_time = delta_time * animator->time_scale;\n  if (animator->delay > 0) {\n    int32_t delay = animator->delay - elapsed_time;\n    if (delay > 0) {\n      animator->delay = delay;\n      return RET_OK;\n    } else {\n      elapsed_time = -delay;\n      animator->now = 0;\n      animator->delay = 0;\n      animator->start_time = 0;\n    }\n  }\n\n  animator->now += elapsed_time;\n  end_time = animator->start_time + animator->duration;\n  time_percent = ((float_t)(animator->now - animator->start_time)) / animator->duration;\n\n  if (time_percent > 1) {\n    time_percent = 1;\n  }\n\n  if (animator->reversed) {\n    time_percent = 1 - time_percent;\n  }\n\n  widget_animator_update(animator, animator->easing(time_percent));\n\n  if (animator->now >= end_time) {\n    if (animator->repeat_times > 0) {\n      event_t e = event_init(EVT_ANIM_ONCE, animator);\n      animator->start_time = animator->now;\n      animator->repeat_times--;\n\n      if (animator->repeat_times == 0 && animator->forever) {\n        animator->repeat_times = TK_UINT32_MAX;\n      }\n\n      emitter_dispatch(&(animator->emitter), &e);\n    } else if (animator->yoyo_times > 0) {\n      event_t e = event_init(EVT_ANIM_ONCE, animator);\n      animator->start_time = animator->now;\n      animator->reversed = !animator->reversed;\n\n      if (!animator->reversed) {\n        animator->yoyo_times--;\n      }\n\n      if (animator->yoyo_times == 0 && animator->forever) {\n        animator->yoyo_times = TK_UINT32_MAX;\n      }\n\n      emitter_dispatch(&(animator->emitter), &e);\n    }\n\n    if (animator->repeat_times == 0 && animator->yoyo_times == 0) {\n      event_t e = event_init(EVT_ANIM_END, animator);\n\n      animator->state = ANIMATOR_DONE;\n      emitter_dispatch(&(animator->emitter), &e);\n\n      if (animator->destroy_when_done) {\n        widget_animator_destroy(animator);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_animator_start(widget_animator_t* animator) {\nevent_t e = ",
    "raw_res": "0;",
    "prompt_res": "event_init(EVT_ANIM_START, animator);",
    "gt": "event_init(EVT_ANIM_START, animator);"
  },
  {
    "id": 2213,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/vgcanvas.c",
    "input": "﻿/**\n * File:   vgcanvas.c\n * Author: AWTK Develop Team\n * Brief:  vector graphics canvas interface.\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-03-24 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"base/vgcanvas.h\"\n#include \"base/system_info.h\"\n#include \"tkc/color_parser.h\"\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n\nret_t vgcanvas_set_assets_manager(vgcanvas_t* vg, assets_manager_t* assets_manager) {\n  return_value_if_fail(vg != NULL, RET_BAD_PARAMS);\n\n  if (vg->vt->set_assets_manager != NULL) {\n    return vg->vt->set_assets_manager(vg, assets_manager);\n  } else {\n    vg->assets_manager = assets_manager;\n  }\n\n  return RET_OK;\n}\n\nret_t vgcanvas_reset(vgcanvas_t* vg) {\n  return_value_if_fail(vg != NULL && vg->vt->reset != NULL, RET_BAD_PARAMS);\n\n  return vg->vt->reset(vg);\n}\n\nret_t vgcanvas_reset_curr_state(vgcanvas_t* vg) {\n  return_value_if_fail(vg != NULL, RET_BAD_PARAMS);\n  if (vg->vt->reset_curr_state != NULL) {\n    return vg->vt->reset_curr_state(vg);\n  } else {\n    return RET_NOT_IMPL;\n  }\n}\n\nret_t vgcanvas_flush(vgcanvas_t* vg) {\n  return_value_if_fail(vg != NULL && vg->vt->flush != NULL, RET_BAD_PARAMS);\n\n  return vg->vt->flush(vg);\n}\n\nret_t vgcanvas_clear_rect(vgcanvas_t* vg, float_t x, float_t y, float_t w, float_t h, color_t c) {\n  return_value_if_fail(vg != NULL && vg->vt->clear_rect != NULL, RET_BAD_PARAMS);\n\n  fix_xywh(x, y, w, h);\n  return vg->vt->clear_rect(vg, x, y, w, h, c);\n}\n\nret_t vgcanvas_move_to(vgcanvas_t* vg, float_t x, float_t y) {\n  return_value_if_fail(vg != NULL && vg->vt->move_to != NULL, RET_BAD_PARAMS);\n\n  return vg->vt->move_to(vg, x, y);\n}\n\nret_t vgcanvas_line_to(vgcanvas_t* vg, float_t x, float_t y) {\n  return_value_if_fail(vg != NULL && vg->vt->line_to != NULL, RET_BAD_PARAMS);\n\n  return vg->vt->line_to(vg, x, y);\n}\n\nret_t vgcanvas_rotate(vgcanvas_t* vg, float_t rad) {\n  return_value_if_fail(vg != NULL && vg->vt->rotate != NULL, RET_BAD_PARAMS);\n\n  return vg->vt->rotate(vg, rad);\n}\n\nret_t vgcanvas_scale(vgcanvas_t* vg, float_t x, float_t y) {\n  return_value_if_fail(vg != NULL && vg->vt->scale != NULL, RET_BAD_PARAMS);\n\n  return vg->vt->scale(vg, x, y);\n}\n\nret_t vgcanvas_translate(vgcanvas_t* vg, float_t x, float_t y) {\n  return_value_if_fail(vg != NULL && vg->vt->translate != NULL, RET_BAD_PARAMS);\n\n  return vg->vt->translate(vg, x, y);\n}\n\nret_t vgcanvas_clip_path(vgcanvas_t* vg) {\n  return_value_if_fail(vg != NULL && vg->vt->clip_path != NULL, RET_BAD_PARAMS);\n\n  return vg->vt->clip_path(vg);\n}\n\nbool_t vgcanvas_is_rectf_in_clip_rect(vgcanvas_t* vg, float_t left, float_t top, float_t right,\n                                      float_t bottom) {\n  return_value_if_fail(vg != NULL && vg->vt->is_rectf_in_clip_rect != NULL, FALSE);\n\n  return vg->vt->is_rectf_in_clip_rect(vg, left, top, right, bottom);\n}\n\nconst rectf_t* vgcanvas_get_clip_rect(vgcanvas_t* vg) {\n  return_value_if_fail(vg != NULL, NULL);\n  if (vg->vt->get_clip_rect == NULL) {\n    return &vg->clip_rect;\n  } else {\n    return vg->vt->get_clip_rect(vg);\n  }\n}\n\nret_t vgcanvas_clip_rect(vgcanvas_t* vg, float_t x, float_t y, float_t w, float_t h) {\n  return_value_if_fail(vg != NULL && vg->vt->clip_rect != NULL, RET_BAD_PARAMS);\n  fix_xywh(x, y, w, h);\nvg->clip_rect = ",
    "raw_res": "(rectf_t){x,y,w,h};",
    "prompt_res": "rectf_init(x, y, w, h);",
    "gt": "rectf_init(x, y, w, h);"
  },
  {
    "id": 2256,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/asset_loader_zip.c",
    "input": "﻿/**\n * File:   asset_loader_zip.c\n * Author: AWTK Develop Team\n * Brief:  asset_loader_zip\n *\n * Copyright (c) 2019 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2020-02-26 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n\n#ifdef WITH_ASSET_LOADER_ZIP\n#include \"miniz/miniz.h\"\n#include \"miniz/miniz_zip.h\"\n#include \"base/asset_loader_zip.h\"\n#include \"base/assets_manager.h\"\n\ntypedef struct _asset_loader_zip_t {\n  asset_loader_t asset_loader;\n  void* data;\n  uint32_t size;\n  mz_zip_archive archive;\n\n  data_reader_t* reader;\n  bool_t own_the_reader;\n} asset_loader_zip_t;\n\n#ifdef WITH_SDL\n#include <SDL.h>\nstatic void* load_asset(const char* filename, uint32_t* data_size) {\n  SDL_RWops* rwops = SDL_RWFromFile(filename, \"rb\");\n  if (rwops != NULL) {\n    uint32_t size = rwops->size(rwops);\n    void* data = TKMEM_ALLOC(size + 1);\n\n    if (data != NULL) {\n      memset(data, 0x00, size + 1);\n      if (rwops->read(rwops, data, 1, size) != size) {\n        TKMEM_FREE(data);\n        data = NULL;\n        log_warn(\"!!! rwops->read [name=%s size=%u] failed!!!\\n\", filename, size);\n      }\n    }\n    rwops->close(rwops);\n    *data_size = size;\n\n    return data;\n  } else {\n    return NULL;\n  }\n}\n#else\nstatic void* load_asset(const char* filename, uint32_t* data_size) {\n  return file_read(filename, data_size);\n}\n#endif /*WITH_SDL*/\n\nstatic void* miniz_awtk_alloc_func(void* opaque, size_t items, size_t size) {\n  (void)opaque, (void)items, (void)size;\n  return TKMEM_ALLOC(items * size);\n}\n\nstatic void miniz_awtk_free_func(void* opaque, void* address) {\n  (void)opaque, (void)address;\n  TKMEM_FREE(address);\n}\n\nstatic void* miniz_awtk_realloc_func(void* opaque, void* address, size_t items, size_t size) {\n  (void)opaque, (void)address, (void)items, (void)size;\n  return TKMEM_REALLOC(address, items * size);\n}\n\nstatic bool_t asset_loader_zip_exist(asset_loader_t* loader, const char* path) {\n  asset_loader_zip_t* zip = (asset_loader_zip_t*)loader;\n  const char* res_root = assets_manager_get_res_root(assets_manager());\n  uint32_t res_root_len = res_root == NULL ? 0 : strlen(res_root);\n  const char* p = path + ((res_root_len == 0) ? 0 : (res_root_len + 1));\n  int file_index = mz_zip_reader_locate_file(&(zip->archive), p, NULL, 0);\n\n  return file_index >= 0;\n}\n\nstatic asset_info_t* asset_loader_zip_load(asset_loader_t* loader, uint16_t type, uint16_t subtype,\n                                           const char* path, const char* name) {\n  size_t size = 0;\n  void* data = NULL;\n  int file_index = 0;\n  asset_info_t* info = NULL;\n  asset_loader_zip_t* zip = (asset_loader_zip_t*)loader;\n  const char* res_root = assets_manager_get_res_root(assets_manager());\n  uint32_t res_root_len = res_root == NULL ? 0 : strlen(res_root);\n  const char* p = path + ((res_root_len == 0) ? 0 : (res_root_len));\n\n  while (*p == '/' || *p == TK_PATH_SEP) p++;\n  file_index = mz_zip_reader_locate_file(&(zip->archive), p, NULL, 0);\n\n  if (file_index < 0) {\n    return NULL;\n  }\n\n  data = mz_zip_reader_extract_to_heap(&(zip->archive), file_index, &size, 0);\n  return_value_if_fail(data != NULL, NULL);\n\ninfo = ",
    "raw_res": "0;",
    "prompt_res": "asset_info_create(type, subtype, name, size);",
    "gt": "asset_info_create(type, subtype, name, size);"
  },
  {
    "id": 2261,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/ui_loader.c",
    "input": "﻿/**\n * File:   ui_loader.h\n * Author: AWTK Develop Team\n * Brief:  ui_loader interface\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-02-14 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/path.h\"\n#include \"base/ui_loader.h\"\n#include \"base/assets_manager.h\"\n#include \"ui_loader/ui_loader_xml.h\"\n#include \"ui_loader/ui_loader_default.h\"\n#include \"ui_loader/ui_builder_default.h\"\n\nret_t ui_loader_load(ui_loader_t* loader, const uint8_t* data, uint32_t size, ui_builder_t* b) {\n  return_value_if_fail(loader != NULL && loader->load != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(data != NULL && b != NULL, RET_BAD_PARAMS);\n\n  return loader->load(loader, data, size, b);\n}\n\nwidget_t* ui_loader_load_widget(const char* name) {\n  return ui_loader_load_widget_with_parent(name, NULL);\n}\n\nwidget_t* ui_loader_load_widget_with_parent(const char* name, widget_t* parent) {\n  char rname[128];\n  widget_t* root = NULL;\n  ui_builder_t* builder = NULL;\n  ui_loader_t* loader = default_ui_loader();\n  const asset_info_t* ui = assets_manager_ref(assets_manager(), ASSET_TYPE_UI, name);\n  return_value_if_fail(ui != NULL, NULL);\n\n  if (strncmp(name, STR_SCHEMA_FILE, strlen(STR_SCHEMA_FILE)) == 0 || ui->data[0] == '<') {\n    path_basename(name, rname, sizeof(rname) - 1);\n    name = rname;\n    if (strstr(name, \".xml\") != NULL || ui->data[0] == '<') {\nloader = ",
    "raw_res": "ui_loader_xml();",
    "prompt_res": "xml_ui_loader();",
    "gt": "xml_ui_loader();"
  },
  {
    "id": 2292,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/dialog_highlighter_factory.c",
    "input": "﻿/**\n * File:   dialog_highlighter_factory.c\n * Author: AWTK Develop Team\n * Brief:  window highlighter factory\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-03-27 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"base/enums.h\"\n#include \"tkc/easing.h\"\n#include \"base/window_manager.h\"\n#include \"tkc/func_call_parser.h\"\n#include \"base/dialog_highlighter_factory.h\"\n\nstatic dialog_highlighter_factory_t* dialog_highlighter_factory_init(\n    dialog_highlighter_factory_t* factory);\nstatic ret_t dialog_highlighter_factory_deinit(dialog_highlighter_factory_t* factory);\n\nstatic dialog_highlighter_factory_t* s_dialog_highlighter_factory = NULL;\n\ntypedef struct _creator_item_t {\n  char type[TK_NAME_LEN + 1];\n  dialog_highlighter_create_t create;\n} creator_item_t;\n\nstatic int32_t creator_item_cmp(const creator_item_t* iter, const char* type) {\n  return strcmp(iter->type, type);\n}\n\ndialog_highlighter_factory_t* dialog_highlighter_factory(void) {\n  return s_dialog_highlighter_factory;\n}\n\ndialog_highlighter_factory_t* dialog_highlighter_factory_create(void) {\n  dialog_highlighter_factory_t* factory = TKMEM_ZALLOC(dialog_highlighter_factory_t);\n  return_value_if_fail(factory != NULL, NULL);\n\n  return dialog_highlighter_factory_init(factory);\n}\n\nstatic dialog_highlighter_factory_t* dialog_highlighter_factory_init(\n    dialog_highlighter_factory_t* factory) {\n  return_value_if_fail(factory != NULL, NULL);\n\n  darray_init(&(factory->creators), 0, default_destroy, (tk_compare_t)creator_item_cmp);\n\n  return factory;\n}\n\nret_t dialog_highlighter_factory_register(dialog_highlighter_factory_t* factory, const char* type,\n                                          dialog_highlighter_create_t create) {\n  creator_item_t* item = NULL;\n  return_value_if_fail(factory != NULL && type != NULL && create != NULL, RET_BAD_PARAMS);\n\n  item = TKMEM_ZALLOC(creator_item_t);\n  return_value_if_fail(item != NULL, RET_OOM);\n\n  item->create = create;\n  tk_strncpy(item->type, type, TK_NAME_LEN);\n  darray_push(&(factory->creators), item);\n\n  return RET_OK;\n}\n\nret_t dialog_highlighter_on_dialog_destroy(void* ctx, event_t* e) {\n  dialog_highlighter_t* h = (dialog_highlighter_t*)ctx;\n\n  dialog_highlighter_destroy(h);\n\n  log_debug(\"dialog_highlighter_on_dialog_destroy\\n\");\n\n  return RET_REMOVE;\n}\n\ndialog_highlighter_t* dialog_highlighter_factory_create_highlighter(\n    dialog_highlighter_factory_t* factory, const char* args, widget_t* dialog) {\n#ifndef WITHOUT_DIALOG_HIGHLIGHTER\n  tk_object_t* args_obj = NULL;\n  dialog_highlighter_t* h = NULL;\n  const creator_item_t* iter = NULL;\n  return_value_if_fail(factory != NULL, NULL);\n  args_obj = func_call_parse(args, tk_strlen(args));\n  return_value_if_fail(args_obj != NULL, NULL);\n\niter = ",
    "raw_res": "darray_find(&(factory->creators), args_obj->name);",
    "prompt_res": "darray_find(&(factory->creators), (void*)args_obj->name);",
    "gt": "darray_find(&(factory->creators), (void*)args_obj->name);"
  },
  {
    "id": 2326,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/image_manager.c",
    "input": "﻿/**\n * File:   image_manager.c\n * Author: AWTK Develop Team\n * Brief:  bitmap manager\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-14 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/time_now.h\"\n#include \"base/locale_info.h\"\n#include \"base/image_manager.h\"\n\ntypedef struct _bitmap_cache_t {\n  bitmap_t image;\n  char* name;\n  uint32_t access_count;\n  uint64_t created_time;\n  uint64_t last_access_time;\n} bitmap_cache_t;\n\nstatic int bitmap_cache_cmp_time(bitmap_cache_t* a, bitmap_cache_t* b) {\n  return (a->last_access_time <= b->last_access_time) ? 0 : -1;\n}\n\nstatic int bitmap_cache_cmp_name(bitmap_cache_t* a, bitmap_cache_t* b) {\n  return strcmp(a->name, b->name);\n}\n\nstatic int bitmap_cache_cmp_data(bitmap_cache_t* a, bitmap_cache_t* b) {\n  return (char*)(a->image.buffer) - (char*)(b->image.buffer);\n}\n\nstatic int bitmap_cache_cmp_access_time_dec(bitmap_cache_t* a, bitmap_cache_t* b) {\n  return (b->last_access_time) - (a->last_access_time);\n}\n\nstatic ret_t bitmap_cache_destroy(bitmap_cache_t* cache) {\n  return_value_if_fail(cache != NULL, RET_BAD_PARAMS);\n  bitmap_t* image = &(cache->image);\n  image_manager_t* imm = image->image_manager;\n\n  if (imm != NULL && image->should_free_data) {\n    imm->mem_size_of_cached_images -= bitmap_get_mem_size(image);\n  }\n  log_debug(\"unload image %s\\n\", cache->name);\n  bitmap_destroy(&(cache->image));\n  TKMEM_FREE(cache->name);\n  TKMEM_FREE(cache);\n\n  return RET_OK;\n}\n\nstatic image_manager_t* s_image_manager = NULL;\nimage_manager_t* image_manager() {\n  return s_image_manager;\n}\n\nret_t image_manager_set(image_manager_t* imm) {\n  s_image_manager = imm;\n\n  return RET_OK;\n}\n\nimage_manager_t* image_manager_create(void) {\n  image_manager_t* imm = TKMEM_ZALLOC(image_manager_t);\n  return_value_if_fail(imm != NULL, NULL);\n\n  return image_manager_init(imm);\n}\n\nstatic locale_info_t* image_manager_get_locale_info(image_manager_t* imm) {\n  return_value_if_fail(imm != NULL, NULL);\n  locale_info_t* locale = locale_info();\n\n  if (imm->assets_manager != NULL && imm->assets_manager->locale_info != NULL) {\n    locale = imm->assets_manager->locale_info;\n  }\n\n  return locale;\n}\n\nimage_manager_t* image_manager_init(image_manager_t* imm) {\n  return_value_if_fail(imm != NULL, NULL);\n\n  darray_init(&(imm->images), 0, (tk_destroy_t)bitmap_cache_destroy, NULL);\n  imm->assets_manager = assets_manager();\n  pthread_mutexattr_t attr;\n  pthread_mutexattr_init(&attr);\n  pthread_mutexattr_settype(&(attr), PTHREAD_MUTEX_RECURSIVE);\n  pthread_mutex_init(&(imm->mutex), &attr);\n\n  return imm;\n}\n\nstatic ret_t image_manager_clear_cache(image_manager_t* imm) {\n  bitmap_cache_t* iter = NULL;\n  return_value_if_fail(imm != NULL, RET_BAD_PARAMS);\n  if (imm->images.size == 0 || imm->max_mem_size_of_cached_images == 0 ||\n      imm->mem_size_of_cached_images < imm->max_mem_size_of_cached_images) {\n    return RET_OK;\n  }\n\n  pthread_mutex_lock(&(imm->mutex));\n  darray_sort(&(imm->images), (tk_compare_t)bitmap_cache_cmp_access_time_dec);\n  do {\n    iter = (bitmap_cache_t*)darray_pop(&(imm->images));\n    bitmap_cache_destroy(iter);\n    log_debug(\"clear cache: mem_size_of_cached_images=%u nr=%u\", imm->mem_size_of_cached_images,\n              imm->images.size);\n  } while (imm->images.size > 0 &&\n           imm->mem_size_of_cached_images > imm->max_mem_size_of_cached_images);\n\n  pthread_mutex_unlock(&(imm->mutex));\n  return RET_OK;\n}\n\nret_t image_manager_add(image_manager_t* imm, const char* name, const bitmap_t* image) {\n  bitmap_cache_t* cache = NULL;\n  return_value_if_fail(imm != NULL && name != NULL && image != NULL, RET_BAD_PARAMS);\n\n  cache = TKMEM_ZALLOC(bitmap_cache_t);\n  return_value_if_fail(cache != NULL, RET_OOM);\n\n  cache->image = *image;\n  cache->access_count = 1;\n  cache->created_time = time_now_s();\n  cache->image.should_free_handle = FALSE;\n  cache->name = tk_strdup(name);\n  cache->image.name = cache->name;\n  cache->last_access_time = cache->created_time;\n\n  pthread_mutex_lock(&(imm->mutex));\n  cache->image.image_manager = imm;\n  if (image->should_free_data) {\n    imm->mem_size_of_cached_images += bitmap_get_mem_size((bitmap_t*)image);\n    image_manager_clear_cache(imm);\n  }\n\n  ret_t ret = darray_push(&(imm->images), cache);\n  pthread_mutex_unlock(&(imm->mutex));\n  return ret;\n}\n\nret_t image_manager_lookup(image_manager_t* imm, const char* name, bitmap_t* image) {\n  bitmap_cache_t info;\n  bitmap_cache_t* iter = NULL;\n  return_value_if_fail(imm != NULL && name != NULL && image != NULL, RET_BAD_PARAMS);\n\n  memset(&info, 0x00, sizeof(info));\n\n  pthread_mutex_lock(&(imm->mutex));\n\n  info.name = (char*)name;\n  imm->images.compare = (tk_compare_t)bitmap_cache_cmp_name;\niter = ",
    "raw_res": "(bitmap_cache_t*)darray_find(&(imm->images), &info);",
    "prompt_res": "darray_find(&(imm->images), &info);",
    "gt": "darray_find(&(imm->images), &info);"
  },
  {
    "id": 2350,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/shortcut.c",
    "input": "﻿/**\n * File:   shortcut.c\n * Author: AWTK Develop Team\n * Brief:  shortcut\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-05-27 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include <tkc/mem.h>\n#include \"tkc/tokenizer.h\"\n\n#include \"base/enums.h\"\n#include \"base/shortcut.h\"\n\nshortcut_t* shortcut_init(shortcut_t* shortcut, uint32_t key) {\n  return_value_if_fail(shortcut != NULL, NULL);\n  memset(shortcut, 0x00, sizeof(shortcut_t));\n\n  shortcut->key = key;\n  shortcut->is_valid = TRUE;\n\n  return shortcut;\n}\n\nshortcut_t* shortcut_init_with_str(shortcut_t* shortcut, const char* str) {\n  tokenizer_t t;\n  const char* k = NULL;\n  return_value_if_fail(shortcut != NULL && str != NULL, NULL);\n  return_value_if_fail(tokenizer_init_ex(&t, str, strlen(str), \" _+\", NULL) != NULL, NULL);\n\n  memset(shortcut, 0, sizeof(shortcut_t));\n  while (tokenizer_has_more(&t)) {\nk = ",
    "raw_res": "0;",
    "prompt_res": "tokenizer_next(&t);",
    "gt": "tokenizer_next(&t);"
  },
  {
    "id": 2468,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/widget.c",
    "input": "﻿/**\n * File:   widget.c\n * Author: AWTK Develop Team\n * Brief:  basic class of all widget\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-13 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/fscript.h\"\n#include \"tkc/tokenizer.h\"\n#include \"tkc/color_parser.h\"\n#include \"tkc/object_default.h\"\n\n#include \"base/keys.h\"\n#include \"base/enums.h\"\n#include \"base/theme.h\"\n#include \"tkc/time_now.h\"\n#include \"base/idle.h\"\n#include \"base/widget.h\"\n#include \"base/layout.h\"\n#include \"native_window.h\"\n#include \"base/main_loop.h\"\n#include \"base/ui_feedback.h\"\n#include \"base/system_info.h\"\n#include \"base/window_manager.h\"\n#include \"base/widget_vtable.h\"\n#include \"base/style_mutable.h\"\n#include \"base/style_factory.h\"\n#include \"base/widget_animator_manager.h\"\n#include \"base/widget_animator_factory.h\"\n#include \"base/window_base.h\"\n#include \"blend/image_g2d.h\"\n\nret_t widget_focus_up(widget_t* widget);\nret_t widget_focus_down(widget_t* widget);\nret_t widget_focus_left(widget_t* widget);\nret_t widget_focus_right(widget_t* widget);\nstatic ret_t widget_unref_async(widget_t* widget);\nstatic ret_t widget_ensure_style_mutable(widget_t* widget);\nstatic ret_t widget_dispatch_blur_event(widget_t* widget);\n/*虚函数的包装*/\nstatic ret_t widget_on_paint_done(widget_t* widget, canvas_t* c);\nstatic ret_t widget_on_paint_begin(widget_t* widget, canvas_t* c);\nstatic ret_t widget_on_paint_end(widget_t* widget, canvas_t* c);\n\ntypedef widget_t* (*widget_find_wanted_focus_widget_t)(widget_t* widget, darray_t* all_focusable);\nstatic ret_t widget_move_focus(widget_t* widget, widget_find_wanted_focus_widget_t find);\n\n#define widget_set_xywh(widget, val, update_layout, invalidate)    \\\n  do {                                                             \\\n    if (widget->val != val) {                                      \\\n      if (invalidate) widget_invalidate_force(widget, NULL);       \\\n      widget->val = val;                                           \\\n      if (invalidate) widget_invalidate_force(widget, NULL);       \\\n    }                                                              \\\n    if (update_layout && widget->self_layout != NULL) {            \\\n      self_layouter_set_param_str(widget->self_layout, #val, \"n\"); \\\n    }                                                              \\\n  } while (0)\n\nstatic ret_t widget_set_x(widget_t* widget, xy_t x, bool_t update_layout) {\n  widget_set_xywh(widget, x, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_y(widget_t* widget, xy_t y, bool_t update_layout) {\n  widget_set_xywh(widget, y, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_w(widget_t* widget, wh_t w, bool_t update_layout) {\n  widget_set_xywh(widget, w, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_h(widget_t* widget, xy_t h, bool_t update_layout) {\n  widget_set_xywh(widget, h, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic bool_t widget_is_strongly_focus(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n  if (win != NULL) {\n    return WINDOW_BASE(win)->strongly_focus;\n  } else {\n    return FALSE;\n  }\n}\n\nret_t widget_set_need_update_style(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (!widget->need_update_style) {\n    widget_invalidate_force(widget, NULL);\n  }\n\n  widget->need_update_style = TRUE;\n\n  return RET_OK;\n}\n\nret_t widget_update_style_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_update_style(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_update_style_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_set_need_update_style_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_need_update_style(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_set_need_update_style_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_update_style(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->astyle != NULL, RET_BAD_PARAMS);\n\n  if (widget->need_update_style) {\n    widget->need_update_style = FALSE;\n    return style_notify_widget_state_changed(widget->astyle, widget);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_real_destroy(widget_t* widget) {\n  ENSURE(widget->ref_count == 1);\n\n  if (widget->vt->on_destroy) {\n    widget->vt->on_destroy(widget);\n  }\n\n  TKMEM_FREE(widget->name);\n  TKMEM_FREE(widget->state);\n  TKMEM_FREE(widget->style);\n  TKMEM_FREE(widget->tr_text);\n  TKMEM_FREE(widget->animation);\n  TKMEM_FREE(widget->pointer_cursor);\n  TK_OBJECT_UNREF(widget->custom_props);\n  wstr_reset(&(widget->text));\n  style_destroy(widget->astyle);\n\n  memset(widget, 0x00, sizeof(widget_t));\n  TKMEM_FREE(widget);\n\n  return RET_OK;\n}\n\nstatic widget_t* widget_real_create(const widget_vtable_t* vt) {\n  widget_t* widget = TKMEM_ALLOC(vt->size);\n  return_value_if_fail(widget != NULL, NULL);\n\n  memset(widget, 0x00, vt->size);\n  widget->vt = vt;\n\n  return widget;\n}\n\nstatic bool_t widget_is_scrollable(widget_t* widget) {\n  return widget != NULL && widget->vt != NULL && widget->vt->scrollable;\n}\n\nstatic bool_t widget_with_focus_state(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n  value_set_bool(&v, FALSE);\n  widget_get_prop(widget, WIDGET_PROP_WITH_FOCUS_STATE, &v);\n\n  return value_bool(&v);\n}\n\nbool_t widget_is_focusable(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  if (!widget->visible || !widget->sensitive || !widget->enable) {\n    return FALSE;\n  }\n\n  return widget->focusable || widget->vt->focusable;\n}\n\nret_t widget_move(widget_t* widget, xy_t x, xy_t y) {\n  event_t e = event_init(EVT_WILL_MOVE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->x != x || widget->y != y) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, x, TRUE, FALSE);\n    widget_set_xywh(widget, y, TRUE, FALSE);\n    widget_invalidate_force(widget, NULL);\n\n    e.type = EVT_MOVE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_to_center(widget_t* widget) {\n  int32_t x = 0;\n  int32_t y = 0;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, RET_BAD_PARAMS);\n\n  x = (widget->parent->w - widget->w) / 2;\n  y = (widget->parent->h - widget->h) / 2;\n\n  return widget_move(widget, x, y);\n}\n\nret_t widget_resize(widget_t* widget, wh_t w, wh_t h) {\n  event_t e = event_init(EVT_WILL_RESIZE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->w != w || widget->h != h) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, w, TRUE, FALSE);\n    widget_set_xywh(widget, h, TRUE, FALSE);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget);\n\n    e.type = EVT_RESIZE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_resize_ex(widget_t* widget, xy_t x, xy_t y, wh_t w, wh_t h,\n                            bool_t update_layout) {\n  event_t e = event_init(EVT_WILL_MOVE_RESIZE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->x != x || widget->y != y || widget->w != w || widget->h != h) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, x, update_layout, FALSE);\n    widget_set_xywh(widget, y, update_layout, FALSE);\n    widget_set_xywh(widget, w, update_layout, FALSE);\n    widget_set_xywh(widget, h, update_layout, FALSE);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget);\n\n    e.type = EVT_MOVE_RESIZE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_resize(widget_t* widget, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return widget_move_resize_ex(widget, x, y, w, h, TRUE);\n}\n\nfloat_t widget_get_value(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_VALUE, &v) == RET_OK ? value_float32(&v) : 0.0f;\n}\n\nret_t widget_set_value(widget_t* widget, float_t value) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_VALUE, value_set_float32(&v, value));\n}\n\nret_t widget_add_value(widget_t* widget, float_t delta) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_value(widget, widget_get_value(widget) + delta);\n}\n\nint32_t widget_get_value_int(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_VALUE, &v) == RET_OK ? value_int(&v) : 0;\n}\n\nret_t widget_set_value_int(widget_t* widget, int32_t value) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_VALUE, value_set_int(&v, value));\n}\n\nret_t widget_add_value_int(widget_t* widget, int32_t delta) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_value_int(widget, widget_get_value_int(widget) + delta);\n}\n\nstatic ret_t widget_animate_prop_float_to(widget_t* widget, const char* name, float_t value,\n                                          uint32_t duration) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL, RET_BAD_PARAMS);\n  if (duration == 0) {\n    ret = widget_set_prop_float(widget, name, value);\n  } else {\n    float_t prev_value = widget_get_prop_float(widget, name, 0.0f);\n    widget_destroy_animator(widget, name);\n\n    if (prev_value != value) {\n      char params[128] = {0};\n      tk_snprintf(params, sizeof(params) - 1, \"%s(from=%f,to=%f,duration=%d)\", name, prev_value,\n                  value, duration);\n      ret = widget_create_animator(widget, params);\n    }\n  }\n  return ret;\n}\n\nret_t widget_animate_value_to(widget_t* widget, float_t value, uint32_t duration) {\n  return widget_animate_prop_float_to(widget, WIDGET_PROP_VALUE, value, duration);\n}\n\nbool_t widget_is_window_opened(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n    return WINDOW_STAGE_OPENED == stage || WINDOW_STAGE_SUSPEND == stage;\n  } else {\n    return FALSE;\n  }\n}\n\nbool_t widget_is_window_created(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n    return WINDOW_STAGE_OPENED == stage || WINDOW_STAGE_SUSPEND == stage ||\n           WINDOW_STAGE_LOADED == stage || WINDOW_STAGE_CREATED == stage;\n  } else {\n    return FALSE;\n  }\n}\n\nret_t widget_get_window_theme(widget_t* widget, theme_t** win_theme, theme_t** default_theme) {\n  value_t v;\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    if (widget_get_prop(win, WIDGET_PROP_THEME_OBJ, &v) == RET_OK) {\n      *win_theme = (theme_t*)value_pointer(&v);\n    }\n\n    if (widget_get_prop(win, WIDGET_PROP_DEFAULT_THEME_OBJ, &v) == RET_OK) {\n      *default_theme = (theme_t*)value_pointer(&v);\n    }\n  }\n  return RET_OK;\n}\n\nbool_t widget_is_style_exist(widget_t* widget, const char* style_name, const char* state_name) {\n  const void* data = NULL;\n  const char* style = NULL;\n  const char* state = NULL;\n  theme_t* win_theme = NULL;\n  theme_t* default_theme = NULL;\n  const char* type = widget_get_type(widget);\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(widget != NULL && win != NULL, FALSE);\n\n  if (style_name == NULL || *style_name == 0) {\n    style = TK_DEFAULT_STYLE;\n  } else {\n    style = style_name;\n  }\n\n  if (state_name == NULL || *state_name == 0) {\n    state = WIDGET_STATE_NORMAL;\n  } else {\n    state = state_name;\n  }\n\n  return_value_if_fail(widget_get_window_theme(widget, &win_theme, &default_theme) == RET_OK,\n                       FALSE);\n\n  if (win_theme != NULL) {\n    data = theme_find_style(win_theme, type, style, state);\n  }\n\n  if (data == NULL && default_theme != NULL) {\n    data = theme_find_style(default_theme, type, style, state);\n  }\n\n  return data != NULL;\n}\n\nret_t widget_use_style(widget_t* widget, const char* value) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_need_update_style(widget);\n  widget->style = tk_str_copy(widget->style, value);\n\n  if (widget_is_window_opened(widget)) {\n    widget_update_style(widget);\n    return widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_text(widget_t* widget, const wchar_t* text) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_wstr(&v, text));\n}\n\nret_t widget_set_text_utf8(widget_t* widget, const char* text) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_str(&v, text));\n}\n\nret_t widget_get_text_utf8(widget_t* widget, char* text, uint32_t size) {\n  value_t v;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && text != NULL && size > 0, RET_BAD_PARAMS);\n\n  value_set_str(&v, NULL);\n  memset(text, 0x00, size);\n  if (widget_get_prop(widget, WIDGET_PROP_TEXT, &v) == RET_OK) {\n    if (v.type == VALUE_TYPE_STRING) {\n      tk_strncpy(text, value_str(&v), size - 1);\n      ret = RET_OK;\n    } else if (v.type == VALUE_TYPE_WSTRING) {\n      tk_utf8_from_utf16(value_wstr(&v), text, size);\n      ret = RET_OK;\n    }\n  }\n\n  return ret;\n}\n\nimage_manager_t* widget_get_image_manager(widget_t* widget) {\n  image_manager_t* ret = image_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = image_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_IMAGE_MANAGER, &v) == RET_OK) {\n      ret = (image_manager_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nlocale_info_t* widget_get_locale_info(widget_t* widget) {\n  locale_info_t* ret = locale_info();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = locale_info();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_LOCALE_INFO, &v) == RET_OK) {\n      ret = (locale_info_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nassets_manager_t* widget_get_assets_manager(widget_t* widget) {\n  assets_manager_t* am = assets_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, am);\n\n  if (widget->assets_manager != NULL) {\n    return widget->assets_manager;\n  }\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    am = assets_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_ASSETS_MANAGER, &v) == RET_OK) {\n      am = (assets_manager_t*)value_pointer(&v);\n    }\n  }\n  widget->assets_manager = am;\n\n  return am;\n}\n\nfont_manager_t* widget_get_font_manager(widget_t* widget) {\n  font_manager_t* ret = font_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = font_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_FONT_MANAGER, &v) == RET_OK) {\n      ret = (font_manager_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_apply_tr_text_before_paint(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  if (widget->tr_text != NULL) {\n    const char* text = locale_info_tr(widget_get_locale_info(widget), widget->tr_text);\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n  }\n\n  return RET_REMOVE;\n}\n\nret_t widget_set_tr_text(widget_t* widget, const char* text) {\n  const char* tr_text = NULL;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(widget != NULL, RET_OK);\n\n  if (text == NULL || *text == '\\0') {\n    if (widget->tr_text != NULL) {\n      TKMEM_FREE(widget->tr_text);\n      widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n    }\n\n    return RET_OK;\n  }\n\n  widget->tr_text = tk_str_copy(widget->tr_text, text);\n  if (win != NULL) {\n    tr_text = locale_info_tr(widget_get_locale_info(widget), text);\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, tr_text);\n  } else {\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n    widget_on(widget, EVT_BEFORE_PAINT, widget_apply_tr_text_before_paint, widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_re_translate_text(widget_t* widget) {\n  if (widget->vt->on_re_translate != NULL) {\n    widget->vt->on_re_translate(widget);\n  }\n  if (widget->tr_text != NULL) {\n    value_t v;\n    const char* tr_text = locale_info_tr(widget_get_locale_info(widget), widget->tr_text);\n    widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_str(&v, tr_text));\n    widget_invalidate(widget, NULL);\n  }\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_re_translate_text(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nconst wchar_t* widget_get_text(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_TEXT, &v) == RET_OK ? value_wstr(&v) : 0;\n}\n\nret_t widget_set_name(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (name != NULL) {\n    widget->name = tk_str_copy(widget->name, name);\n  } else {\n    TKMEM_FREE(widget->name);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_theme(widget_t* widget, const char* name) {\n  theme_change_event_t will_event;\n  event_t* will_evt = theme_change_event_init(&will_event, EVT_THEME_WILL_CHANGE, name);\n  widget_dispatch(window_manager(), will_evt);\n#ifdef WITH_FS_RES\n  const asset_info_t* info = NULL;\n  theme_change_event_t event;\n  event_t* evt = theme_change_event_init(&event, EVT_THEME_CHANGED, name);\n  widget_t* wm = widget_get_window_manager(widget);\n  font_manager_t* fm = widget_get_font_manager(widget);\n  image_manager_t* imm = widget_get_image_manager(widget);\n  assets_manager_t* am = widget_get_assets_manager(widget);\n  locale_info_t* locale_info = widget_get_locale_info(widget);\n  return_value_if_fail(am != NULL && name != NULL, RET_BAD_PARAMS);\n\n  font_manager_unload_all(fm);\n  image_manager_unload_all(imm);\n  locale_info_reload(locale_info);\n  assets_manager_set_theme(am, name);\n  widget_reset_canvas(widget);\n\n  info = assets_manager_ref(am, ASSET_TYPE_STYLE, \"default\");\n  if (info != NULL) {\n    theme_set(theme_load_from_data(info->name, info->data, info->size));\n    assets_manager_unref(assets_manager(), info);\n  }\n\n  widget_dispatch(wm, evt);\n  widget_invalidate_force(wm, NULL);\n\n  log_debug(\"theme changed: %s\\n\", name);\n#endif\n\n  return RET_OK;\n}\n\nret_t widget_set_pointer_cursor(widget_t* widget, const char* cursor) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (!tk_str_eq(widget->pointer_cursor, cursor)) {\n    widget->pointer_cursor = tk_str_copy(widget->pointer_cursor, cursor);\n    widget_update_pointer_cursor(widget);\n  }\n\n  return RET_OK;\n}\n\n#ifndef WITHOUT_WIDGET_ANIMATORS\nret_t widget_set_animation(widget_t* widget, const char* animation) {\n  return_value_if_fail(widget != NULL && animation != NULL, RET_BAD_PARAMS);\n\n  widget->animation = tk_str_copy(widget->animation, animation);\n\n  return widget_create_animator(widget, animation);\n}\n\nret_t widget_create_animator(widget_t* widget, const char* animation) {\n  tokenizer_t t;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && animation != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(tokenizer_init(&t, animation, strlen(animation), \";\") != NULL, RET_OOM);\n\n  while (tokenizer_has_more(&t)) {\n    const char* params = tokenizer_next(&t);\n    if (widget_animator_create(widget, params) == NULL) {\n      ret = RET_BAD_PARAMS;\n      break;\n    }\n  }\n  tokenizer_deinit(&t);\n  widget_invalidate(widget, NULL);\n\n  return ret;\n}\n\nret_t widget_start_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_start(widget_animator_manager(), widget, name);\n}\n\nret_t widget_set_animator_time_scale(widget_t* widget, const char* name, float_t time_scale) {\n  return widget_animator_manager_set_time_scale(widget_animator_manager(), widget, name,\n                                                time_scale);\n}\n\nret_t widget_pause_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_pause(widget_animator_manager(), widget, name);\n}\n\nwidget_animator_t* widget_find_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_find(widget_animator_manager(), widget, name);\n}\n\nret_t widget_stop_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_stop(widget_animator_manager(), widget, name);\n}\n\nret_t widget_destroy_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_remove_all(widget_animator_manager(), widget, name);\n}\n#else\nret_t widget_start_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nret_t widget_create_animator(widget_t* widget, const char* animation) {\n  return RET_OK;\n}\nret_t widget_set_animation(widget_t* widget, const char* animation) {\n  return RET_OK;\n}\nret_t widget_set_animator_time_scale(widget_t* widget, const char* name, float_t time_scale) {\n  return RET_OK;\n}\nret_t widget_pause_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nwidget_animator_t* widget_find_animator(widget_t* widget, const char* name) {\n  return NULL;\n}\nret_t widget_stop_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nret_t widget_destroy_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\n#endif /*WITHOUT_WIDGET_ANIMATORS*/\n\nret_t widget_set_enable(widget_t* widget, bool_t enable) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->enable != enable) {\n    widget->enable = enable;\n    widget_set_need_update_style_recursive(widget);\n    widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_feedback(widget_t* widget, bool_t feedback) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->feedback = feedback;\n\n  return RET_OK;\n}\n\nret_t widget_set_auto_adjust_size(widget_t* widget, bool_t auto_adjust_size) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->auto_adjust_size = auto_adjust_size;\n  widget_set_need_relayout(widget);\n\n  return RET_OK;\n}\n\nret_t widget_set_floating(widget_t* widget, bool_t floating) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->floating = floating;\n\n  return RET_OK;\n}\n\nret_t widget_set_focused_internal(widget_t* widget, bool_t focused) {\n  widget_t* win = widget_get_window(widget);\n  int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (WINDOW_STAGE_SUSPEND == stage) {\n    log_debug(\"You can not set focus of a widget when window is in background\");\n    return RET_FAIL;\n  }\n\n  if (widget->focused != focused) {\n    widget->focused = focused;\n    widget_set_need_update_style(widget);\n\n    if (focused) {\n      event_t e = event_init(EVT_FOCUS, widget);\n      widget_set_as_key_target(widget);\n\n      widget_dispatch(widget, &e);\n    } else {\n      event_t e = event_init(EVT_BLUR, widget);\n      widget_dispatch(widget, &e);\n      widget_dispatch_blur_event(widget);\n    }\n\n    widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_focused(widget_t* widget, bool_t focused) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_focused_internal(widget, focused);\n  if (focused) {\n    widget_ensure_visible_in_viewport(widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_focusable(widget_t* widget, bool_t focusable) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->focusable = focusable;\n\n  return RET_OK;\n}\n\nret_t widget_set_state(widget_t* widget, const char* state) {\n  return_value_if_fail(widget != NULL && state != NULL, RET_BAD_PARAMS);\n\n  if (!tk_str_eq(widget->state, state)) {\n    widget_invalidate_force(widget, NULL);\n    widget->state = tk_str_copy(widget->state, state);\n    widget_set_need_update_style(widget);\n    widget_invalidate_force(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_state_for_style(widget_t* widget, bool_t active, bool_t checked) {\n  const char* state = WIDGET_STATE_NORMAL;\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, state);\n\n  state = (const char*)(widget->state);\n\n  while (iter != NULL) {\n    if (!iter->enable) {\n      if (active) return WIDGET_STATE_DISABLE_OF_ACTIVE;\n      if (checked) return WIDGET_STATE_DISABLE_OF_CHECKED;\n      return WIDGET_STATE_DISABLE;\n    }\n    iter = iter->parent;\n  }\n\n  if (widget_is_focusable(widget) || widget_with_focus_state(widget)) {\n    if (widget->focused) {\n      if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n        state = WIDGET_STATE_FOCUSED;\n      }\n    } else {\n      if (tk_str_eq(state, WIDGET_STATE_FOCUSED)) {\n        state = WIDGET_STATE_NORMAL;\n      }\n    }\n  }\n\n  if (active) {\n    if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n      state = WIDGET_STATE_NORMAL_OF_ACTIVE;\n    } else if (tk_str_eq(state, WIDGET_STATE_PRESSED)) {\n      state = WIDGET_STATE_PRESSED_OF_ACTIVE;\n    } else if (tk_str_eq(state, WIDGET_STATE_OVER)) {\n      state = WIDGET_STATE_OVER_OF_ACTIVE;\n    } else if (widget_is_focusable(widget) && widget->focused) {\n      state = WIDGET_STATE_FOCUSED_OF_ACTIVE;\n    }\n  } else if (checked) {\n    if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n      state = WIDGET_STATE_NORMAL_OF_CHECKED;\n    } else if (tk_str_eq(state, WIDGET_STATE_PRESSED)) {\n      state = WIDGET_STATE_PRESSED_OF_CHECKED;\n    } else if (tk_str_eq(state, WIDGET_STATE_OVER)) {\n      state = WIDGET_STATE_OVER_OF_CHECKED;\n    } else if (widget_is_focusable(widget) && widget->focused) {\n      state = WIDGET_STATE_FOCUSED_OF_CHECKED;\n    }\n  }\n\n  return state;\n}\n\nret_t widget_set_opacity(widget_t* widget, uint8_t opacity) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->opacity = opacity;\n  widget_invalidate(widget, NULL);\n\n  return RET_OK;\n}\n\nret_t widget_set_dirty_rect_tolerance(widget_t* widget, uint16_t dirty_rect_tolerance) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->dirty_rect_tolerance = dirty_rect_tolerance;\n  widget_invalidate(widget, NULL);\n\n  return RET_OK;\n}\n\nret_t widget_destroy_children(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->children != NULL) {\n    WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n\n    widget_remove_child_prepare(widget, iter);\n    widget_unref(iter);\n\n    widget->children->elms[i] = NULL;\n\n    WIDGET_FOR_EACH_CHILD_END();\n    widget->children->size = 0;\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_style_type(widget_t* widget) {\n  theme_t* win_theme = NULL;\n  theme_t* default_theme = NULL;\n  const char* style_type = THEME_DEFAULT_STYLE_TYPE;\n\n  if (widget_get_window_theme(widget, &win_theme, &default_theme) == RET_OK) {\n    theme_t* t = win_theme != NULL ? win_theme : (default_theme != NULL ? default_theme : theme());\n    if (t != NULL) {\n      style_type = theme_get_style_type(t);\n    }\n  }\n\n  return style_type;\n}\n\nstatic ret_t widget_update_style_object(widget_t* widget) {\n  const char* style_type = widget_get_style_type(widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  if (widget->astyle == NULL) {\n    widget->astyle = style_factory_create_style(style_factory(), style_type);\n    ENSURE(widget->astyle != NULL);\n\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  } else if (widget->astyle != NULL &&\n             !tk_str_eq(style_get_style_type(widget->astyle), style_type)) {\n    style_t* style = style_factory_create_style(style_factory(), style_type);\n    ENSURE(style != NULL);\n    if (style_is_mutable(widget->astyle)) {\n      style_mutable_set_default_style(widget->astyle, style);\n    } else {\n      style_destroy(widget->astyle);\n      widget->astyle = style;\n    }\n\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  }\n  return RET_OK;\n}\n\nstatic ret_t widget_update_style_object_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_update_style_object(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_update_style_object_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_add_child(widget_t* widget, widget_t* child) {\n  event_t e = event_init(EVT_WIDGET_ADD_CHILD, widget);\n  return_value_if_fail(widget != NULL && child != NULL && child->parent == NULL, RET_BAD_PARAMS);\n\n  child->parent = widget;\n\n  if (widget->children == NULL) {\n    widget->children = darray_create(4, NULL, NULL);\n  }\n\n  if (widget->vt->on_add_child) {\n    if (widget->vt->on_add_child(widget, child) == RET_OK) {\n      return RET_OK;\n    }\n  }\n\n  if (child->vt->on_attach_parent) {\n    child->vt->on_attach_parent(child, widget);\n  }\n\n  ENSURE(darray_push(widget->children, child) == RET_OK);\n\n  if (!widget_is_window_manager(widget)) {\n    widget_set_need_relayout_children(widget);\n  }\n\n  if (!(child->initializing) && widget_get_window(child) != NULL) {\n    widget_set_need_update_style_recursive(child);\n    widget_update_style_object_recursive(child);\n  }\n\n  widget_dispatch(widget, &e);\n\n  return RET_OK;\n}\n\nret_t widget_remove_child_prepare(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n\n  if (!widget_is_window_manager(widget)) {\n    widget_set_need_relayout_children(widget);\n  }\n\n  widget_invalidate_force(child, NULL);\n  if (widget->target == child) {\n    widget->target = NULL;\n  }\n\n  if (widget->grab_widget == child) {\n    widget->grab_widget = NULL;\n    widget->grab_widget_count = 0;\n  }\n\n  if (widget->key_target == child) {\n    widget_dispatch_blur_event(widget->key_target);\n    widget->key_target = NULL;\n  }\n\n  if (widget->vt->on_remove_child) {\n    if (widget->vt->on_remove_child(widget, child) == RET_OK) {\n      return RET_OK;\n    }\n  }\n\n  if (child->vt->on_detach_parent) {\n    child->vt->on_detach_parent(child, widget);\n  }\n  child->parent = NULL;\n\n  return RET_OK;\n}\n\nret_t widget_remove_child(widget_t* widget, widget_t* child) {\n  ret_t ret = RET_OK;\n  event_t e = event_init(EVT_WIDGET_REMOVE_CHILD, widget);\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n\n  widget_remove_child_prepare(widget, child);\n  ret = darray_remove(widget->children, child);\n\n  if (ret == RET_OK) {\n    widget_dispatch(widget, &e);\n  }\n\n  return ret;\n}\n\nret_t widget_insert_child(widget_t* widget, uint32_t index, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget_add_child(widget, child) == RET_OK, RET_FAIL);\n\n  return widget_restack(child, index);\n}\n\nret_t widget_restack(widget_t* widget, uint32_t index) {\n  uint32_t i = 0;\n  uint32_t nr = 0;\n  int32_t old_index = 0;\n  widget_t** children = NULL;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, RET_BAD_PARAMS);\n\n  old_index = widget_index_of(widget);\n  nr = widget_count_children(widget->parent);\n  return_value_if_fail(old_index >= 0 && nr > 0, RET_BAD_PARAMS);\n\n  if (index >= nr) {\n    index = nr - 1;\n  }\n\n  if (index == old_index || nr == 1) {\n    return RET_OK;\n  }\n\n  children = (widget_t**)(widget->parent->children->elms);\n  if (index < old_index) {\n    for (i = old_index; i > index; i--) {\n      children[i] = children[i - 1];\n    }\n  } else {\n    for (i = old_index; i < index; i++) {\n      children[i] = children[i + 1];\n    }\n  }\n  children[index] = widget;\n\n  return RET_OK;\n}\n\nstatic widget_t* widget_lookup_child(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL && name != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (iter->name != NULL && tk_str_eq(iter->name, name)) {\n    return iter;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return NULL;\n}\n\nwidget_t* widget_child(widget_t* widget, const char* path) {\n  return widget_lookup_child(widget, path);\n}\n\nwidget_t* widget_get_focused_widget(widget_t* widget) {\n  widget_t* iter = NULL;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(win != NULL, NULL);\n\n  iter = win->key_target;\n  for (iter = win->key_target; iter != NULL; iter = iter->key_target) {\n    if (iter->focusable && iter->focused) {\n      return iter;\n    }\n\n    if (iter->key_target == NULL) {\n      return iter;\n    }\n  }\n\n  return NULL;\n}\n\nstatic widget_t* widget_lookup_all(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL && name != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (iter->name != NULL && tk_str_eq(iter->name, name)) {\n    return iter;\n  } else {\n    iter = widget_lookup_all(iter, name);\n    if (iter != NULL) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nwidget_t* widget_lookup(widget_t* widget, const char* name, bool_t recursive) {\n  if (recursive) {\n    return widget_lookup_all(widget, name);\n  } else {\n    return widget_lookup_child(widget, name);\n  }\n}\n\nstatic widget_t* widget_lookup_by_type_child(widget_t* widget, const char* type) {\n  return_value_if_fail(widget != NULL && type != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (tk_str_eq(iter->vt->type, type)) {\n    return iter;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return NULL;\n}\n\nstatic widget_t* widget_lookup_by_type_all(widget_t* widget, const char* type) {\n  return_value_if_fail(widget != NULL && type != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (tk_str_eq(iter->vt->type, type)) {\n    return iter;\n  } else {\n    iter = widget_lookup_by_type_all(iter, type);\n    if (iter != NULL) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nwidget_t* widget_lookup_by_type(widget_t* widget, const char* type, bool_t recursive) {\n  if (recursive) {\n    return widget_lookup_by_type_all(widget, type);\n  } else {\n    return widget_lookup_by_type_child(widget, type);\n  }\n}\n\nstatic ret_t widget_set_visible_self(widget_t* widget, bool_t visible) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->visible != visible) {\n    widget_invalidate_force(widget, NULL);\n    widget->visible = visible;\n    widget_set_need_update_style(widget);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget->parent);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_sensitive(widget_t* widget, bool_t sensitive) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->sensitive = sensitive;\n\n  return RET_OK;\n}\n\nret_t widget_set_visible_only(widget_t* widget, bool_t visible) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->visible = visible;\n\n  return RET_OK;\n}\n\nret_t widget_set_visible(widget_t* widget, bool_t visible, ...) {\n  return widget_set_visible_self(widget, visible);\n}\n\nwidget_t* widget_find_target(widget_t* widget, xy_t x, xy_t y) {\n  widget_t* ret = NULL;\n  return_value_if_fail(widget != NULL, NULL);\n\n  if (widget->vt && widget->vt->find_target) {\n    ret = widget->vt->find_target(widget, x, y);\n  } else {\n    ret = widget_find_target_default(widget, x, y);\n  }\n\n  return ret;\n}\n\nret_t widget_on_event_before_children(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt && widget->vt->on_event_before_children) {\n    ret = widget->vt->on_event_before_children(widget, e);\n  }\n\n  return ret;\n}\n\nstatic const char* widget_get_pointer_cursor(widget_t* widget) {\n  if (widget->pointer_cursor != NULL) {\n    return widget->pointer_cursor;\n  } else if (widget->vt->pointer_cursor != NULL) {\n    return widget->vt->pointer_cursor;\n  }\n\n  return WIDGET_CURSOR_DEFAULT;\n}\n\nret_t widget_update_pointer_cursor(widget_t* widget) {\n  widget_t* wm = widget_get_window_manager(widget);\n  return_value_if_fail(wm != NULL, RET_BAD_PARAMS);\n\n  return window_manager_set_cursor(wm, widget_get_pointer_cursor(widget));\n}\n\nret_t widget_dispatch(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  if (e->target == NULL) {\n    e->target = widget;\n  }\n\n  if (widget->vt && widget->vt->on_event) {\n    ret = widget->vt->on_event(widget, e);\n  } else {\n    ret = widget_on_event_default(widget, e);\n  }\n\n  if (ret != RET_STOP) {\n    if (widget->emitter != NULL) {\n      void* saved_target = e->target;\n\n      e->target = widget;\n      ret = emitter_dispatch(widget->emitter, e);\n      e->target = saved_target;\n    }\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t dispatch_in_idle(const idle_info_t* info) {\n  event_t* e = (event_t*)(info->ctx);\n  widget_t* widget = WIDGET(e->target);\n\n  widget_dispatch(widget, e);\n  widget_unref(widget);\n  event_destroy(e);\n\n  return RET_REMOVE;\n}\n\nret_t widget_dispatch_async(widget_t* widget, event_t* e) {\n  event_t* evt = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(e->target == widget, RET_BAD_PARAMS);\n\n  evt = event_clone(e);\n  return_value_if_fail(evt != NULL, RET_OOM);\n\n  widget_ref(widget);\n  idle_add(dispatch_in_idle, evt);\n\n  return RET_OK;\n}\n\nstatic ret_t widget_dispatch_callback(void* ctx, const void* data) {\n  widget_t* widget = WIDGET(data);\n\n  return widget_dispatch(widget, (event_t*)ctx);\n}\n\nret_t widget_dispatch_recursive(widget_t* widget, event_t* e) {\n  return widget_foreach(widget, widget_dispatch_callback, e);\n}\n\nuint32_t widget_on_with_tag(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx,\n                            uint32_t tag) {\n  return_value_if_fail(widget != NULL && on_event != NULL, RET_BAD_PARAMS);\n  if (widget->emitter == NULL) {\n    widget->emitter = emitter_create();\n  }\n\n  return emitter_on_with_tag(widget->emitter, type, on_event, ctx, tag);\n}\n\nuint32_t widget_on(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx) {\n  return widget_on_with_tag(widget, type, on_event, ctx, 0);\n}\n\nuint32_t widget_child_on(widget_t* widget, const char* name, uint32_t type, event_func_t on_event,\n                         void* ctx) {\n  return widget_on(widget_lookup(widget, name, TRUE), type, on_event, ctx);\n}\n\nret_t widget_off(widget_t* widget, uint32_t id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->emitter != NULL, RET_BAD_PARAMS);\n\n  return emitter_off(widget->emitter, id);\n}\n\nret_t widget_off_by_tag(widget_t* widget, uint32_t tag) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_tag(widget->emitter, tag);\n}\n\nret_t widget_off_by_ctx(widget_t* widget, void* ctx) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_ctx(widget->emitter, ctx);\n}\n\nret_t widget_off_by_func(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx) {\n  return_value_if_fail(widget != NULL && on_event != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_func(widget->emitter, type, on_event, ctx);\n}\n\nret_t widget_calc_icon_text_rect(const rect_t* ir, int32_t font_size, float_t text_size,\n                                 int32_t icon_at, uint32_t img_w, uint32_t img_h, int32_t spacer,\n                                 rect_t* r_text, rect_t* r_icon) {\n  return_value_if_fail(ir != NULL && (r_text != NULL || r_icon != NULL), RET_BAD_PARAMS);\n\n  if (r_icon == NULL) {\n    *r_text = *ir;\n\n    return RET_OK;\n  }\n\n  if (r_text == NULL) {\n    *r_icon = *ir;\n\n    return RET_OK;\n  }\n\n  return_value_if_fail(spacer < ir->h && spacer < ir->w, RET_BAD_PARAMS);\n  switch (icon_at) {\n    case ICON_AT_CENTRE: {\n      int32_t w = ir->w - spacer - text_size - img_w;\n      int32_t icon_h = ir->h - img_h;\n      *r_text = rect_init(ir->x + img_w + spacer + w / 2, ir->y, text_size, ir->h);\n      *r_icon = rect_init(ir->x + w / 2, ir->y + icon_h / 2, img_w, img_h);\n      break;\n    }\n    case ICON_AT_RIGHT: {\n      uint32_t w = img_w;\n      float_t ratio = system_info()->device_pixel_ratio;\n      if (ratio > 1) {\n        w = img_w / ratio;\n      }\n      w = tk_min(tk_max(w, ir->h), ir->w);\n      *r_icon = rect_init(ir->x + ir->w - w, ir->y, w, ir->h);\n      *r_text = rect_init(ir->x, ir->y, ir->w - ir->h - spacer, ir->h);\n      break;\n    }\n    case ICON_AT_TOP: {\n      int32_t icon_h = ir->h - font_size - spacer;\n      *r_icon = rect_init(ir->x, ir->y, ir->w, icon_h);\n      *r_text = rect_init(ir->x, icon_h + spacer, ir->w, font_size);\n      break;\n    }\n    case ICON_AT_BOTTOM: {\n      int32_t icon_h = ir->h - font_size - spacer;\n      *r_icon = rect_init(ir->x, ir->y + ir->h - icon_h, ir->w, icon_h);\n      *r_text = rect_init(ir->x, ir->y, ir->w, font_size);\n      break;\n    }\n    case ICON_AT_LEFT:\n    default: {\n      *r_icon = rect_init(ir->x, ir->y, ir->h, ir->h);\n      *r_text = rect_init(ir->x + ir->h + spacer, ir->y, ir->w - ir->h - spacer, ir->h);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_bidi(widget_t* widget) {\n  value_t v;\n  if (widget_get_prop(widget, WIDGET_PROP_BIDI, &v) == RET_OK) {\n    return value_str(&v);\n  }\n\n  return NULL;\n}\n\nret_t widget_draw_icon_text(widget_t* widget, canvas_t* c, const char* icon, wstr_t* text) {\n  rect_t ir;\n  wh_t w = 0;\n  wh_t h = 0;\n  bitmap_t img;\n  rect_t r_icon;\n  rect_t r_text;\n  int32_t margin = 0;\n  int32_t spacer = 0;\n  int32_t icon_at = 0;\n  uint16_t font_size = 0;\n  float_t text_size = 0.0f;\n  int32_t margin_left = 0;\n  int32_t margin_right = 0;\n  int32_t margin_top = 0;\n  int32_t margin_bottom = 0;\n  style_t* style = widget->astyle;\n  int32_t align_h = ALIGN_H_LEFT;\n  int32_t align_v = ALIGN_V_MIDDLE;\n  return_value_if_fail(widget->astyle != NULL, RET_BAD_PARAMS);\n\n  spacer = style_get_int(style, STYLE_ID_SPACER, 2);\n  margin = style_get_int(style, STYLE_ID_MARGIN, 0);\n  margin_top = style_get_int(style, STYLE_ID_MARGIN_TOP, margin);\n  margin_left = style_get_int(style, STYLE_ID_MARGIN_LEFT, margin);\n  margin_right = style_get_int(style, STYLE_ID_MARGIN_RIGHT, margin);\n  margin_bottom = style_get_int(style, STYLE_ID_MARGIN_BOTTOM, margin);\n  icon_at = style_get_int(style, STYLE_ID_ICON_AT, ICON_AT_AUTO);\n\n  w = widget->w - margin_left - margin_right;\n  h = widget->h - margin_top - margin_bottom;\n  ir = rect_init(margin_left, margin_top, w, h);\n\n  if (text == NULL) {\n    text = &(widget->text);\n  }\n\n  if (icon == NULL) {\n    icon = style_get_str(style, STYLE_ID_ICON, NULL);\n  }\n\n  widget_prepare_text_style(widget, c);\n\n  font_size = c->font_size;\n  text_size = text->str ? canvas_measure_text(c, text->str, text->size) : 0;\n  if (icon_at == ICON_AT_RIGHT || icon_at == ICON_AT_LEFT) {\n    align_v = style_get_int(style, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    align_h = style_get_int(style, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_LEFT);\n  } else {\n    align_v = style_get_int(style, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    align_h = style_get_int(style, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_CENTER);\n  }\n  canvas_set_text_align(c, (align_h_t)align_h, (align_v_t)align_v);\n\n  if (icon != NULL && widget_load_image(widget, icon, &img) == RET_OK) {\n    float_t dpr = system_info()->device_pixel_ratio;\n\n    if (text->size > 0) {\n      if ((h > (img.h / dpr + font_size) && icon_at == ICON_AT_AUTO)) {\n        icon_at = ICON_AT_TOP;\n      }\n\n      widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer, &r_text,\n                                 &r_icon);\n\n      canvas_draw_icon_in_rect(c, &img, &r_icon);\n      widget_draw_text_in_rect(widget, c, text->str, text->size, &r_text, FALSE);\n    } else {\n      if (icon_at == ICON_AT_AUTO) {\n        widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer, NULL,\n                                   &r_icon);\n      } else {\n        widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer,\n                                   &r_text, &r_icon);\n      }\n      canvas_draw_icon_in_rect(c, &img, &r_icon);\n    }\n  } else if (text != NULL && text->size > 0) {\n    widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, 0, 0, spacer, &r_text, NULL);\n    widget_draw_text_in_rect(widget, c, text->str, text->size, &r_text, FALSE);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_fill_rect(widget_t* widget, canvas_t* c, const rect_t* r, bool_t bg,\n                       image_draw_type_t draw_type) {\n  bitmap_t img;\n  ret_t ret = RET_OK;\n  gradient_t agradient;\n  style_t* style = widget->astyle;\n  uint32_t radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  const char* color_key = bg ? STYLE_ID_BG_COLOR : STYLE_ID_FG_COLOR;\n  const char* image_key = bg ? STYLE_ID_BG_IMAGE : STYLE_ID_FG_IMAGE;\n  rect_t bg_r = rect_init(widget->x, widget->y, widget->w, widget->h);\n  uint32_t radius_tl = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_LEFT, radius);\n  uint32_t radius_tr = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_RIGHT, radius);\n  uint32_t radius_bl = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_LEFT, radius);\n  uint32_t radius_br = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_RIGHT, radius);\n  uint32_t clear_bg = style_get_uint(style, STYLE_ID_CLEAR_BG, 0);\n  const char* draw_type_key = bg ? STYLE_ID_BG_IMAGE_DRAW_TYPE : STYLE_ID_FG_IMAGE_DRAW_TYPE;\n  gradient_t* gradient = style_get_gradient(style, color_key, &agradient);\n  const char* image_name = style_get_str(style, image_key, NULL);\n\n  if (gradient != NULL && r->w > 0 && r->h > 0) {\n    color_t color = gradient_get_first_color(gradient);\n    canvas_set_fill_color(c, color);\n    if (gradient->nr > 1 || color.rgba.a) {\n      if (radius_tl > 3 || radius_tr > 3 || radius_bl > 3 || radius_br > 3) {\n        /*TODO: support gradient*/\n        if (bg) {\n          ret = canvas_fill_rounded_rect_gradient_ex(c, r, NULL, gradient, radius_tl, radius_tr,\n                                                     radius_bl, radius_br);\n        } else {\n          ret = canvas_fill_rounded_rect_gradient_ex(c, r, &bg_r, gradient, radius_tl, radius_tr,\n                                                     radius_bl, radius_br);\n        }\n        if (ret == RET_FAIL) {\n          canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n        }\n      } else if (gradient->nr > 1) {\n        canvas_fill_rect_gradient(c, r->x, r->y, r->w, r->h, gradient);\n      } else {\n        if (clear_bg) {\n          canvas_clear_rect(c, r->x, r->y, r->w, r->h);\n        } else {\n          canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n        }\n      }\n    } else if (clear_bg) {\n      canvas_clear_rect(c, r->x, r->y, r->w, r->h);\n    }\n  }\n\n  if (image_name != NULL && *image_name && r->w > 0 && r->h > 0) {\n    char name[MAX_PATH + 1];\n    const char* region = strrchr(image_name, '#');\n    if (region != NULL) {\n      memset(name, 0x00, sizeof(name));\n      tk_strncpy(name, image_name, region - image_name);\n      image_name = name;\n    }\n\n    if (widget_load_image(widget, image_name, &img) == RET_OK) {\n      draw_type = (image_draw_type_t)style_get_int(style, draw_type_key, draw_type);\n\n      if (region == NULL) {\n        canvas_draw_image_ex(c, &img, draw_type, r);\n      } else {\n        rect_t src;\n        rect_t dst = *r;\n        if (tk_str_eq(region, \"#\")) {\n          src = rect_init(widget->x, widget->y, widget->w, widget->h);\n        } else if (tk_str_eq(region, \"#g\")) {\n          point_t p = {widget->x, widget->y};\n          widget_to_global(widget, &p);\n          src = rect_init(p.x, p.y, widget->w, widget->h);\n        } else {\n          image_region_parse(img.w, img.h, region, &src);\n        }\n\n        canvas_draw_image_ex2(c, &img, draw_type, &src, &dst);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_stroke_border_rect_for_border_type(canvas_t* c, const rect_t* r, color_t bd,\n                                                int32_t border, uint32_t border_width) {\n  wh_t w = r->w;\n  wh_t h = r->h;\n  xy_t x = r->x + 0.5;\n  xy_t y = r->y + 0.5;\n  xy_t y1 = y;\n  wh_t h1 = h;\n  bool_t draw_top = FALSE;\n  bool_t draw_bottom = FALSE;\n  canvas_set_fill_color(c, bd);\n  if (border & BORDER_TOP) {\n    draw_top = TRUE;\n    canvas_fill_rect(c, x, y, w, border_width);\n  }\n  if (border & BORDER_BOTTOM) {\n    draw_bottom = TRUE;\n    canvas_fill_rect(c, x, y + h - border_width, w, border_width);\n  }\n  /* 减少重复绘制的部分，可以修复有透明的时候重叠区域显示不正常为问题 */\n  if (draw_top) {\n    y1 += border_width;\n    h1 -= border_width;\n  }\n  if (draw_bottom) {\n    h1 -= border_width;\n  }\n  if (border & BORDER_LEFT) {\n    canvas_fill_rect(c, x, y1, border_width, h1);\n  }\n  if (border & BORDER_RIGHT) {\n    canvas_fill_rect(c, x + w - border_width, y1, border_width, h1);\n  }\n  return RET_OK;\n}\n\nret_t widget_stroke_border_rect(widget_t* widget, canvas_t* c, const rect_t* r) {\n  style_t* style = widget->astyle;\n  color_t trans = color_init(0, 0, 0, 0);\n  color_t bd = style_get_color(style, STYLE_ID_BORDER_COLOR, trans);\n  uint32_t radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  int32_t border = style_get_int(style, STYLE_ID_BORDER, BORDER_ALL);\n  uint32_t border_width = style_get_int(style, STYLE_ID_BORDER_WIDTH, 1);\n  uint32_t radius_tl = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_LEFT, radius);\n  uint32_t radius_tr = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_RIGHT, radius);\n  uint32_t radius_bl = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_LEFT, radius);\n  uint32_t radius_br = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_RIGHT, radius);\n\n  if (bd.rgba.a) {\n    canvas_set_stroke_color(c, bd);\n    if (radius_tl > 3 || radius_tr > 3 || radius_bl > 3 || radius_br > 3) {\n      if (canvas_stroke_rounded_rect_ex(c, r, NULL, &bd, radius_tl, radius_tr, radius_bl, radius_br,\n                                        border_width, border) != RET_OK) {\n        widget_stroke_border_rect_for_border_type(c, r, bd, border, border_width);\n      }\n    } else {\n      widget_stroke_border_rect_for_border_type(c, r, bd, border, border_width);\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_draw_background(widget_t* widget, canvas_t* c) {\n  rect_t r;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  r = rect_init(0, 0, widget->w, widget->h);\n\n  return widget_fill_rect(widget, c, &r, TRUE, IMAGE_DRAW_CENTER);\n}\n\nret_t widget_fill_bg_rect(widget_t* widget, canvas_t* c, const rect_t* r,\n                          image_draw_type_t draw_type) {\n  return widget_fill_rect(widget, c, r, TRUE, draw_type);\n}\n\nret_t widget_fill_fg_rect(widget_t* widget, canvas_t* c, const rect_t* r,\n                          image_draw_type_t draw_type) {\n  return widget_fill_rect(widget, c, r, FALSE, draw_type);\n}\n\nstatic ret_t widget_draw_border(widget_t* widget, canvas_t* c) {\n  rect_t r;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  r = rect_init(0, 0, widget->w, widget->h);\n  return widget_stroke_border_rect(widget, c, &r);\n}\n\nret_t widget_paint_helper(widget_t* widget, canvas_t* c, const char* icon, wstr_t* text) {\n  if (style_is_valid(widget->astyle)) {\n    widget_draw_icon_text(widget, c, icon, text);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_paint_impl(widget_t* widget, canvas_t* c) {\n  int32_t ox = widget->x;\n  int32_t oy = widget->y;\n  uint8_t save_alpha = c->global_alpha;\n\n  if (widget->opacity < TK_OPACITY_ALPHA) {\n    canvas_set_global_alpha(c, (widget->opacity * save_alpha) / 0xff);\n  }\n\n  if (widget->astyle != NULL) {\n    ox += style_get_int(widget->astyle, STYLE_ID_X_OFFSET, 0);\n    oy += style_get_int(widget->astyle, STYLE_ID_Y_OFFSET, 0);\n  }\n\n  canvas_translate(c, ox, oy);\n  widget_on_paint_begin(widget, c);\n  widget_on_paint_background(widget, c);\n  widget_on_paint_self(widget, c);\n  widget_on_paint_children(widget, c);\n  widget_on_paint_border(widget, c);\n  widget_on_paint_end(widget, c);\n\n  canvas_untranslate(c, ox, oy);\n  if (widget->opacity < TK_OPACITY_ALPHA) {\n    canvas_set_global_alpha(c, save_alpha);\n  }\n\n  widget_on_paint_done(widget, c);\n\n  return RET_OK;\n}\n\nret_t widget_paint(widget_t* widget, canvas_t* c) {\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  if (!widget->visible || widget->opacity <= 0x08 || widget->w <= 0 || widget->h <= 0) {\n    widget->dirty = FALSE;\n    return RET_OK;\n  }\n\n  if (widget->need_update_style) {\n    widget_update_style(widget);\n  }\n\n  canvas_save(c);\n  widget_paint_impl(widget, c);\n  canvas_restore(c);\n\n  widget->dirty = FALSE;\n\n  return RET_OK;\n}\n\nstatic const widget_cmd_t s_widget_cmds[] = {\n    {WIDGET_EXEC_START_ANIMATOR, widget_start_animator},\n    {WIDGET_EXEC_STOP_ANIMATOR, widget_stop_animator},\n    {WIDGET_EXEC_PAUSE_ANIMATOR, widget_pause_animator},\n    {WIDGET_EXEC_DESTROY_ANIMATOR, widget_destroy_animator}};\n\nstatic ret_t widget_do_exec(widget_t* widget, const char* cmd, const char* args) {\n  uint32_t i = 0;\n\n  for (i = 0; i < ARRAY_SIZE(s_widget_cmds); i++) {\n    const widget_cmd_t* iter = s_widget_cmds + i;\n    if (tk_str_eq(cmd, iter->name)) {\n      return iter->exec(widget, args);\n    }\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t widget_exec(widget_t* widget, const char* str) {\n  if (str != NULL) {\n    char cmd[TK_NAME_LEN + 1] = {0};\n    const char* args = strchr(str, ':');\n\n    if (args != NULL) {\n      return_value_if_fail((args - str) < TK_NAME_LEN, RET_BAD_PARAMS);\n      tk_strncpy(cmd, str, args - str);\n      args += 1;\n    } else {\n      return_value_if_fail(strlen(str) < TK_NAME_LEN, RET_BAD_PARAMS);\n      tk_strcpy(cmd, str);\n    }\n\n    return widget_do_exec(widget, cmd, args);\n  } else {\n    return RET_NOT_FOUND;\n  }\n}\n\nstatic widget_t* widget_get_top_widget_grab_key(widget_t* widget) {\n  return_value_if_fail(widget != NULL, NULL);\n  WIDGET_FOR_EACH_CHILD_BEGIN_R(widget, iter, i)\n  value_t v;\n  widget_t* widget_grab_key = widget_get_top_widget_grab_key(iter);\n  if (widget_grab_key == NULL && iter != NULL && iter->visible && iter->custom_props != NULL) {\n    ret_t ret = tk_object_get_prop(iter->custom_props, WIDGET_PROP_GRAB_KEYS, &v);\n    if (ret == RET_OK && value_bool(&v)) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nstatic ret_t widget_on_ungrab_keys(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  window_manager_t* wm = WINDOW_MANAGER(widget_get_window_manager(widget));\n\n  wm->widget_grab_key = widget_get_top_widget_grab_key(WIDGET(wm));\n\n  return RET_REMOVE;\n}\n\nstatic ret_t widget_exec_code(void* ctx, event_t* evt) {\n#ifndef WITHOUT_FSCRIPT\n  value_t v;\n  value_t result;\n  ret_t ret = RET_OK;\n  tk_object_t* obj = NULL;\n  widget_t* widget = WIDGET(evt->target);\n  const char* code = (const char*)ctx;\n  if (widget_get_prop(widget, STR_PROP_MODEL, &v) == RET_OK) {\n    obj = value_object(&v);\n  }\n  if (obj != NULL) {\n    TK_OBJECT_REF(obj);\n  } else {\n    obj = object_default_create();\n  }\n  return_value_if_fail(obj != NULL && code != NULL, RET_REMOVE);\n\n  tk_object_set_prop_pointer(obj, STR_PROP_SELF, widget);\n\n  switch (evt->type) {\n    case EVT_CLICK:\n    case EVT_POINTER_DOWN:\n    case EVT_POINTER_MOVE:\n    case EVT_POINTER_UP: {\n      pointer_event_t* e = pointer_event_cast(evt);\n      tk_object_set_prop_int(obj, \"x\", e->x);\n      tk_object_set_prop_int(obj, \"y\", e->y);\n      tk_object_set_prop_bool(obj, \"alt\", e->alt);\n      tk_object_set_prop_bool(obj, \"cmd\", e->cmd);\n      tk_object_set_prop_bool(obj, \"menu\", e->menu);\n      tk_object_set_prop_bool(obj, \"ctrl\", e->ctrl);\n      break;\n    }\n    case EVT_KEY_DOWN:\n    case EVT_KEY_LONG_PRESS:\n    case EVT_KEY_UP: {\n      key_event_t* e = key_event_cast(evt);\n      const key_type_value_t* kv = keys_type_find_by_value(e->key);\n      if (kv != NULL) {\n        tk_object_set_prop_str(obj, \"key\", kv->name);\n      } else {\n        tk_object_set_prop_str(obj, \"key\", \"unkown\");\n      }\n      tk_object_set_prop_bool(obj, \"alt\", e->alt);\n      tk_object_set_prop_bool(obj, \"cmd\", e->cmd);\n      tk_object_set_prop_bool(obj, \"menu\", e->menu);\n      tk_object_set_prop_bool(obj, \"ctrl\", e->ctrl);\n      break;\n    }\n    default:\n      break;\n  }\n\n  value_set_int(&result, 0);\n  fscript_eval(obj, code, &result);\n  if (tk_object_get_prop_bool(obj, \"RET_STOP\", FALSE)) {\n    ret = RET_STOP;\n  }\n  if (tk_object_get_prop_bool(obj, \"RET_REMOVE\", FALSE)) {\n    ret = RET_REMOVE;\n  }\n  value_reset(&result);\n  TK_OBJECT_UNREF(obj);\n\n  return ret;\n#else\n  return RET_OK;\n#endif\n}\n\nstatic ret_t widget_free_code(void* ctx, event_t* evt) {\n  widget_t* widget = WIDGET(evt->target);\n  widget_off_by_ctx(widget, ctx);\n  TKMEM_FREE(ctx);\n\n  return RET_REMOVE;\n}\n\n#define STR_ANIMATE_PREFIX \"animate:\"\n#define TK_ANIMATING_TIME 500 /* 单位：毫秒（ms） */\nret_t widget_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  ret_t ret = RET_OK;\n  prop_change_event_t e;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_EXEC)) {\n    ret = widget_exec(widget, value_str(v));\n    if (ret != RET_NOT_FOUND) {\n      return ret;\n    }\n  }\n\n  e.value = v;\n  e.name = name;\n  e.e = event_init(EVT_PROP_WILL_CHANGE, widget);\n  widget_dispatch(widget, (event_t*)&e);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    widget_set_x(widget, (xy_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    widget_set_y(widget, (xy_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    widget_set_w(widget, (wh_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    widget_set_h(widget, (wh_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    widget->opacity = (uint8_t)value_int(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    widget_set_visible(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    widget->sensitive = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    widget->floating = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    widget->focusable = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    widget->with_focus_state = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    widget->dirty_rect_tolerance = value_int(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    const char* name = value_str(v);\n    return widget_use_style(widget, name);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    widget_set_enable(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    widget->feedback = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    widget_set_auto_adjust_size(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    widget_set_name(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_TR_TEXT)) {\n    widget_set_tr_text(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    widget_set_animation(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    widget_set_self_layout(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_LAYOUT) || tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    widget_set_children_layout(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_POINTER_CURSOR)) {\n    widget_set_pointer_cursor(widget, value_str(v));\n  } else {\n    ret = RET_NOT_FOUND;\n  }\n\n  if (widget->vt->set_prop) {\n    if (tk_str_start_with(name, STR_ANIMATE_PREFIX)) {\n      return widget_animate_prop_float_to(widget, name + strlen(STR_ANIMATE_PREFIX),\n                                          value_float32(v), TK_ANIMATING_TIME);\n    } else {\n      ret_t ret1 = widget->vt->set_prop(widget, name, v);\n      if (ret == RET_NOT_FOUND) {\n        ret = ret1;\n      }\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_FOCUSED) || tk_str_eq(name, WIDGET_PROP_FOCUS)) {\n      widget_set_focused(widget, value_bool(v));\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n      wstr_from_value(&(widget->text), v);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_EXEC)) {\n      ret = RET_NOT_FOUND;\n    } else if (tk_str_start_with(name, \"style:\") || tk_str_start_with(name, \"style.\")) {\n      return widget_set_style(widget, name + 6, v);\n    } else {\n      if (widget->custom_props == NULL) {\n        widget->custom_props = object_default_create();\n      }\n\n      if (tk_str_eq(name, WIDGET_PROP_GRAB_KEYS)) {\n        window_manager_t* wm = WINDOW_MANAGER(widget_get_window_manager(widget));\n\n        if (value_bool(v)) {\n          widget_on(widget, EVT_DESTROY, widget_on_ungrab_keys, widget);\n          wm->widget_grab_key = widget;\n        }\n      }\n\n      if (strncmp(name, STR_ON_EVENT_PREFIX, sizeof(STR_ON_EVENT_PREFIX) - 1) == 0) {\n        int32_t etype = event_from_name(name + sizeof(STR_ON_EVENT_PREFIX) - 1);\n        if (etype != EVT_NONE) {\n          char* code = tk_strdup(value_str(v));\n          if (code != NULL) {\n            name += sizeof(STR_ON_EVENT_PREFIX) - 1;\n            if (strncmp(name, STR_GLOBAL_EVENT_PREFIX, sizeof(STR_GLOBAL_EVENT_PREFIX) - 1) == 0) {\n              widget_t* wm = window_manager();\n              widget_on(wm, etype, widget_exec_code, code);\n              widget_on(wm, EVT_DESTROY, widget_free_code, code);\n            } else {\n              widget_on(widget, etype, widget_exec_code, code);\n              widget_on(widget, EVT_DESTROY, widget_free_code, code);\n            }\n            ret = RET_OK;\n          }\n        } else {\n          log_debug(\"not found event %s\\n\", name);\n        }\n      } else {\n        ret = tk_object_set_prop(widget->custom_props, name, v);\n      }\n    }\n  }\n\n  if (ret != RET_NOT_FOUND) {\n    e.e.type = EVT_PROP_CHANGED;\n    widget_dispatch(widget, (event_t*)&e);\n    widget_invalidate(widget, NULL);\n  }\n\n  return ret;\n}\n\nret_t widget_get_prop(widget_t* widget, const char* name, value_t* v) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    value_set_int32(v, widget->x);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    value_set_int32(v, widget->y);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    value_set_int32(v, widget->w);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    value_set_int32(v, widget->h);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    value_set_int32(v, widget->opacity);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    value_set_bool(v, widget->visible);\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    value_set_bool(v, widget->sensitive);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    value_set_bool(v, widget->floating);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    value_set_bool(v, widget_is_focusable(widget));\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSED)) {\n    value_set_bool(v, widget->focused);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    value_set_bool(v, widget->with_focus_state);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    value_set_int(v, widget->dirty_rect_tolerance);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    value_set_str(v, widget->style);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    value_set_bool(v, widget->enable);\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    value_set_bool(v, widget->feedback);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    value_set_bool(v, widget->auto_adjust_size);\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    value_set_str(v, widget->name);\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    value_set_str(v, widget->animation);\n  } else if (tk_str_eq(name, WIDGET_PROP_POINTER_CURSOR)) {\n    value_set_str(v, widget->pointer_cursor);\n  } else if (tk_str_eq(name, WIDGET_PROP_LOADING)) {\n    value_set_bool(v, widget->loading);\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    if (widget->self_layout != NULL) {\n      value_set_str(v, self_layouter_to_string(widget->self_layout));\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  } else if (tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    if (widget->children_layout != NULL) {\n      value_set_str(v, children_layouter_to_string(widget->children_layout));\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  } else {\n    if (widget->vt->get_prop) {\n      ret = widget->vt->get_prop(widget, name, v);\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  }\n\n  /*default*/\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_LAYOUT_W)) {\n      value_set_int32(v, widget->w);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_LAYOUT_H)) {\n      value_set_int32(v, widget->h);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n      wchar_t* text = widget->text.str;\n      if (text != NULL) {\n        text[widget->text.size] = 0;\n      }\n      value_set_wstr(v, text);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_STATE_FOR_STYLE)) {\n      value_set_str(v, widget_get_state_for_style(widget, FALSE, FALSE));\n      ret = RET_OK;\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (widget->custom_props != NULL) {\n      ret = tk_object_get_prop(widget->custom_props, name, v);\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_TYPE)) {\n      value_set_str(v, widget->vt->type);\n      ret = RET_OK;\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_set_prop_str(widget_t* widget, const char* name, const char* str) {\n  value_t v;\n  value_set_str(&v, str);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nconst char* widget_get_prop_str(widget_t* widget, const char* name, const char* defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_str(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_pointer(widget_t* widget, const char* name, void* pointer) {\n  value_t v;\n  value_set_pointer(&v, pointer);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nvoid* widget_get_prop_pointer(widget_t* widget, const char* name) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_pointer(&v);\n  } else {\n    return NULL;\n  }\n}\n\nret_t widget_set_prop_float(widget_t* widget, const char* name, float_t num) {\n  value_t v;\n  value_set_float32(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nfloat_t widget_get_prop_float(widget_t* widget, const char* name, float_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_float32(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_int(widget_t* widget, const char* name, int32_t num) {\n  value_t v;\n  value_set_int(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nint32_t widget_get_prop_int(widget_t* widget, const char* name, int32_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_int(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_bool(widget_t* widget, const char* name, bool_t num) {\n  value_t v;\n  value_set_bool(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nbool_t widget_get_prop_bool(widget_t* widget, const char* name, bool_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_bool(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_on_paint_background(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_background) {\n    ret = widget->vt->on_paint_background(widget, c);\n  } else {\n    if (style_is_valid(widget->astyle)) {\n      widget_draw_background(widget, c);\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_self(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_self) {\n    ret = widget->vt->on_paint_self(widget, c);\n  } else {\n    paint_event_t e;\n    widget_dispatch(widget, paint_event_init(&e, EVT_PAINT, widget, c));\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_children(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_children) {\n    ret = widget->vt->on_paint_children(widget, c);\n  } else {\n    ret = widget_on_paint_children_default(widget, c);\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_border(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_border) {\n    ret = widget->vt->on_paint_border(widget, c);\n  } else {\n    if (style_is_valid(widget->astyle)) {\n      ret = widget_draw_border(widget, c);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_begin(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_begin) {\n    ret = widget->vt->on_paint_begin(widget, c);\n  }\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_BEFORE_PAINT, widget, c));\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_done(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_PAINT_DONE, widget, c));\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_end(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_end) {\n    ret = widget->vt->on_paint_end(widget, c);\n  }\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_AFTER_PAINT, widget, c));\n\n  return ret;\n}\n\nret_t widget_dispatch_to_target(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  e->target = widget;\n  widget_dispatch(widget, e);\n\n  if (widget->target) {\n    ret = widget_dispatch_to_target(widget->target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_map_key(widget_t* widget, key_event_t* e) {\n  value_t v;\n  const key_type_value_t* kv = NULL;\n\n  if (widget->custom_props != NULL) {\n    kv = keys_type_find_by_value(e->key);\n    if (kv != NULL) {\n      const char* to = NULL;\n      char from[TK_NAME_LEN + 1] = {0};\n      char fixed_name[TK_NAME_LEN + 1];\n\n      tk_snprintf(from, sizeof(from), \"map_key:%s\", kv->name);\n      if (tk_object_get_prop(widget->custom_props, from, &v) == RET_OK) {\n        to = value_str(&v);\n      } else if (strlen(kv->name) > 1) {\n        tk_strcpy(fixed_name, kv->name);\n        tk_str_tolower(fixed_name);\n        tk_snprintf(from, sizeof(from), \"map_key:%s\", fixed_name);\n        if (tk_object_get_prop(widget->custom_props, from, &v) == RET_OK) {\n          to = value_str(&v);\n        }\n      }\n\n      if (to != NULL) {\n        kv = keys_type_find(to);\n        if (kv != NULL) {\n          e->key = kv->value;\n          log_debug(\"map key %s to %s\\n\", from, to);\n        }\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_dispatch_to_key_target(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  e->target = widget;\n  widget_dispatch(widget, e);\n\n  if (widget->key_target) {\n    ret = widget_dispatch_to_target(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_before_children(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    key_event_t before = *e;\n    before.e.type = EVT_KEY_DOWN_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_keydown_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_keydown(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_after_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_keydown) {\n    ret = widget->vt->on_keydown(widget, e);\n  }\n\n  return ret;\n}\n\nbool_t widget_is_activate_key(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL && e != NULL, FALSE);\n\n  return (widget->vt->space_key_to_activate && e->key == TK_KEY_SPACE) ||\n         (widget->vt->return_key_to_activate && key_code_is_enter(e->key));\n}\n\nstatic bool_t shortcut_fast_match(const char* shortcut, key_event_t* e) {\n  uint32_t key = e->key;\n  const char* kname = strrchr(shortcut, '+');\n  bool_t cmd = strstr(shortcut, \"cmd\") != NULL;\n  bool_t ctrl = strstr(shortcut, \"ctrl\") != NULL;\n  bool_t shift = strstr(shortcut, \"shift\") != NULL;\n  const key_type_value_t* kv = keys_type_find_by_value(key);\n\n  if (kv != NULL) {\n    if (kname == NULL) {\n      kname = shortcut;\n    } else {\n      kname++;\n    }\n\n    if (tk_str_ieq(kname, kv->name) && cmd == e->cmd && ctrl == e->ctrl && shift == e->shift) {\n      return TRUE;\n    }\n  }\n\n  return FALSE;\n}\n\nstatic bool_t widget_match_key(widget_t* widget, const char* prop, key_event_t* e) {\n  const char* shortcut = NULL;\n  widget_t* win = widget_get_window(widget);\n\n  if (widget_is_window_manager(widget)) {\n    return FALSE;\n  }\n\n  return_value_if_fail(win != NULL, FALSE);\n  shortcut = widget_get_prop_str(win, prop, NULL);\n\n  if (shortcut != NULL) {\n    return shortcut_fast_match(shortcut, e);\n  }\n\n  return FALSE;\n}\n\nstatic bool_t widget_is_move_focus_prev_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_PREV_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_next_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_NEXT_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_up_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_UP_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_down_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_DOWN_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_left_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_LEFT_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_right_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_RIGHT_KEY, e);\n}\n\nbool_t widget_is_change_focus_key(widget_t* widget, key_event_t* e) {\n  return widget_is_move_focus_prev_key(widget, e) || widget_is_move_focus_next_key(widget, e) ||\n         widget_is_move_focus_up_key(widget, e) || widget_is_move_focus_down_key(widget, e) ||\n         widget_is_move_focus_left_key(widget, e) || widget_is_move_focus_right_key(widget, e);\n}\n\nstatic ret_t widget_on_keydown_general(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  if (!widget_is_window_manager(widget)) {\n    if (widget_is_activate_key(widget, e)) {\n      ret = RET_STOP;\n      widget_set_state(widget, WIDGET_STATE_PRESSED);\n    } else if (widget_is_move_focus_next_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_next(widget);\n      } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n        ret = RET_STOP;\n        widget_focus_first(widget);\n      }\n    } else if (widget_is_move_focus_prev_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_prev(widget);\n      } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n        ret = RET_STOP;\n        widget_focus_first(widget);\n      }\n    } else if (widget_is_move_focus_up_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_up(widget);\n      }\n    } else if (widget_is_move_focus_down_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_down(widget);\n      }\n    } else if (widget_is_move_focus_left_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_left(widget);\n      }\n    } else if (widget_is_move_focus_right_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_right(widget);\n      }\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_impl(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_keydown_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keydown_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keydown_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_keydown(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  uint32_t key = e->key;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  widget_map_key(widget, e);\n  if (e->e.type == EVT_KEY_DOWN) {\n    ret = widget_on_keydown_impl(widget, e);\n    if (widget->feedback) {\n      ui_feedback_request(widget, (event_t*)e);\n    }\n\n    e->key = key;\n    if (ret != RET_STOP) {\n      ret = widget_on_keydown_general(widget, e);\n    }\n  } else if (e->e.type == EVT_KEY_LONG_PRESS) {\n    return_value_if_equal(widget_on_keydown_children(widget, e), RET_STOP);\n    ret = widget_on_keydown_after_children(widget, e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_before_children(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    key_event_t before = *e;\n    before.e.type = EVT_KEY_UP_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_keyup_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_keyup(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_after_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_keyup) {\n    ret = widget->vt->on_keyup(widget, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_impl(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_keyup_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keyup_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keyup_after_children(widget, e), RET_STOP);\n\n  if (widget_is_activate_key(widget, e)) {\n    pointer_event_t click;\n    if (widget_is_focusable(widget)) {\n      widget_set_state(widget, WIDGET_STATE_FOCUSED);\n    } else {\n      widget_set_state(widget, WIDGET_STATE_NORMAL);\n    }\n    widget_dispatch_async(widget, pointer_event_init(&click, EVT_CLICK, widget, 0, 0));\n\n    ret = RET_STOP;\n  } else if (widget_is_move_focus_next_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_prev_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_up_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_down_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_left_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_right_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_on_keyup(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  uint32_t key = e->key;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  widget_map_key(widget, e);\n  ret = widget_on_keyup_impl(widget, e);\n  if (widget->feedback) {\n    ui_feedback_request(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  e->key = key;\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_before_children(widget_t* widget, wheel_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    wheel_event_t before = *e;\n    before.e.type = EVT_WHEEL_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_wheel_children(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_wheel(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_after_children(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_wheel) {\n    ret = widget->vt->on_wheel(widget, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_impl(widget_t* widget, wheel_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_wheel_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_wheel_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_wheel_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_wheel(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_wheel_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}\n\nret_t widget_on_multi_gesture(widget_t* widget, multi_gesture_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\nret = ",
    "raw_res": "widget_on_multi_gesture(target, e);",
    "prompt_res": "widget_dispatch(target, (event_t*)e);",
    "gt": "widget_dispatch(target, (event_t*)e);"
  },
  {
    "id": 2491,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/widget.c",
    "input": "﻿/**\n * File:   widget.c\n * Author: AWTK Develop Team\n * Brief:  basic class of all widget\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-13 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/fscript.h\"\n#include \"tkc/tokenizer.h\"\n#include \"tkc/color_parser.h\"\n#include \"tkc/object_default.h\"\n\n#include \"base/keys.h\"\n#include \"base/enums.h\"\n#include \"base/theme.h\"\n#include \"tkc/time_now.h\"\n#include \"base/idle.h\"\n#include \"base/widget.h\"\n#include \"base/layout.h\"\n#include \"native_window.h\"\n#include \"base/main_loop.h\"\n#include \"base/ui_feedback.h\"\n#include \"base/system_info.h\"\n#include \"base/window_manager.h\"\n#include \"base/widget_vtable.h\"\n#include \"base/style_mutable.h\"\n#include \"base/style_factory.h\"\n#include \"base/widget_animator_manager.h\"\n#include \"base/widget_animator_factory.h\"\n#include \"base/window_base.h\"\n#include \"blend/image_g2d.h\"\n\nret_t widget_focus_up(widget_t* widget);\nret_t widget_focus_down(widget_t* widget);\nret_t widget_focus_left(widget_t* widget);\nret_t widget_focus_right(widget_t* widget);\nstatic ret_t widget_unref_async(widget_t* widget);\nstatic ret_t widget_ensure_style_mutable(widget_t* widget);\nstatic ret_t widget_dispatch_blur_event(widget_t* widget);\n/*虚函数的包装*/\nstatic ret_t widget_on_paint_done(widget_t* widget, canvas_t* c);\nstatic ret_t widget_on_paint_begin(widget_t* widget, canvas_t* c);\nstatic ret_t widget_on_paint_end(widget_t* widget, canvas_t* c);\n\ntypedef widget_t* (*widget_find_wanted_focus_widget_t)(widget_t* widget, darray_t* all_focusable);\nstatic ret_t widget_move_focus(widget_t* widget, widget_find_wanted_focus_widget_t find);\n\n#define widget_set_xywh(widget, val, update_layout, invalidate)    \\\n  do {                                                             \\\n    if (widget->val != val) {                                      \\\n      if (invalidate) widget_invalidate_force(widget, NULL);       \\\n      widget->val = val;                                           \\\n      if (invalidate) widget_invalidate_force(widget, NULL);       \\\n    }                                                              \\\n    if (update_layout && widget->self_layout != NULL) {            \\\n      self_layouter_set_param_str(widget->self_layout, #val, \"n\"); \\\n    }                                                              \\\n  } while (0)\n\nstatic ret_t widget_set_x(widget_t* widget, xy_t x, bool_t update_layout) {\n  widget_set_xywh(widget, x, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_y(widget_t* widget, xy_t y, bool_t update_layout) {\n  widget_set_xywh(widget, y, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_w(widget_t* widget, wh_t w, bool_t update_layout) {\n  widget_set_xywh(widget, w, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_h(widget_t* widget, xy_t h, bool_t update_layout) {\n  widget_set_xywh(widget, h, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic bool_t widget_is_strongly_focus(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n  if (win != NULL) {\n    return WINDOW_BASE(win)->strongly_focus;\n  } else {\n    return FALSE;\n  }\n}\n\nret_t widget_set_need_update_style(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (!widget->need_update_style) {\n    widget_invalidate_force(widget, NULL);\n  }\n\n  widget->need_update_style = TRUE;\n\n  return RET_OK;\n}\n\nret_t widget_update_style_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_update_style(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_update_style_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_set_need_update_style_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_need_update_style(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_set_need_update_style_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_update_style(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->astyle != NULL, RET_BAD_PARAMS);\n\n  if (widget->need_update_style) {\n    widget->need_update_style = FALSE;\n    return style_notify_widget_state_changed(widget->astyle, widget);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_real_destroy(widget_t* widget) {\n  ENSURE(widget->ref_count == 1);\n\n  if (widget->vt->on_destroy) {\n    widget->vt->on_destroy(widget);\n  }\n\n  TKMEM_FREE(widget->name);\n  TKMEM_FREE(widget->state);\n  TKMEM_FREE(widget->style);\n  TKMEM_FREE(widget->tr_text);\n  TKMEM_FREE(widget->animation);\n  TKMEM_FREE(widget->pointer_cursor);\n  TK_OBJECT_UNREF(widget->custom_props);\n  wstr_reset(&(widget->text));\n  style_destroy(widget->astyle);\n\n  memset(widget, 0x00, sizeof(widget_t));\n  TKMEM_FREE(widget);\n\n  return RET_OK;\n}\n\nstatic widget_t* widget_real_create(const widget_vtable_t* vt) {\n  widget_t* widget = TKMEM_ALLOC(vt->size);\n  return_value_if_fail(widget != NULL, NULL);\n\n  memset(widget, 0x00, vt->size);\n  widget->vt = vt;\n\n  return widget;\n}\n\nstatic bool_t widget_is_scrollable(widget_t* widget) {\n  return widget != NULL && widget->vt != NULL && widget->vt->scrollable;\n}\n\nstatic bool_t widget_with_focus_state(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n  value_set_bool(&v, FALSE);\n  widget_get_prop(widget, WIDGET_PROP_WITH_FOCUS_STATE, &v);\n\n  return value_bool(&v);\n}\n\nbool_t widget_is_focusable(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  if (!widget->visible || !widget->sensitive || !widget->enable) {\n    return FALSE;\n  }\n\n  return widget->focusable || widget->vt->focusable;\n}\n\nret_t widget_move(widget_t* widget, xy_t x, xy_t y) {\n  event_t e = event_init(EVT_WILL_MOVE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->x != x || widget->y != y) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, x, TRUE, FALSE);\n    widget_set_xywh(widget, y, TRUE, FALSE);\n    widget_invalidate_force(widget, NULL);\n\n    e.type = EVT_MOVE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_to_center(widget_t* widget) {\n  int32_t x = 0;\n  int32_t y = 0;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, RET_BAD_PARAMS);\n\n  x = (widget->parent->w - widget->w) / 2;\n  y = (widget->parent->h - widget->h) / 2;\n\n  return widget_move(widget, x, y);\n}\n\nret_t widget_resize(widget_t* widget, wh_t w, wh_t h) {\n  event_t e = event_init(EVT_WILL_RESIZE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->w != w || widget->h != h) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, w, TRUE, FALSE);\n    widget_set_xywh(widget, h, TRUE, FALSE);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget);\n\n    e.type = EVT_RESIZE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_resize_ex(widget_t* widget, xy_t x, xy_t y, wh_t w, wh_t h,\n                            bool_t update_layout) {\n  event_t e = event_init(EVT_WILL_MOVE_RESIZE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->x != x || widget->y != y || widget->w != w || widget->h != h) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, x, update_layout, FALSE);\n    widget_set_xywh(widget, y, update_layout, FALSE);\n    widget_set_xywh(widget, w, update_layout, FALSE);\n    widget_set_xywh(widget, h, update_layout, FALSE);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget);\n\n    e.type = EVT_MOVE_RESIZE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_resize(widget_t* widget, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return widget_move_resize_ex(widget, x, y, w, h, TRUE);\n}\n\nfloat_t widget_get_value(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_VALUE, &v) == RET_OK ? value_float32(&v) : 0.0f;\n}\n\nret_t widget_set_value(widget_t* widget, float_t value) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_VALUE, value_set_float32(&v, value));\n}\n\nret_t widget_add_value(widget_t* widget, float_t delta) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_value(widget, widget_get_value(widget) + delta);\n}\n\nint32_t widget_get_value_int(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_VALUE, &v) == RET_OK ? value_int(&v) : 0;\n}\n\nret_t widget_set_value_int(widget_t* widget, int32_t value) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_VALUE, value_set_int(&v, value));\n}\n\nret_t widget_add_value_int(widget_t* widget, int32_t delta) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_value_int(widget, widget_get_value_int(widget) + delta);\n}\n\nstatic ret_t widget_animate_prop_float_to(widget_t* widget, const char* name, float_t value,\n                                          uint32_t duration) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL, RET_BAD_PARAMS);\n  if (duration == 0) {\n    ret = widget_set_prop_float(widget, name, value);\n  } else {\n    float_t prev_value = widget_get_prop_float(widget, name, 0.0f);\n    widget_destroy_animator(widget, name);\n\n    if (prev_value != value) {\n      char params[128] = {0};\n      tk_snprintf(params, sizeof(params) - 1, \"%s(from=%f,to=%f,duration=%d)\", name, prev_value,\n                  value, duration);\n      ret = widget_create_animator(widget, params);\n    }\n  }\n  return ret;\n}\n\nret_t widget_animate_value_to(widget_t* widget, float_t value, uint32_t duration) {\n  return widget_animate_prop_float_to(widget, WIDGET_PROP_VALUE, value, duration);\n}\n\nbool_t widget_is_window_opened(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n    return WINDOW_STAGE_OPENED == stage || WINDOW_STAGE_SUSPEND == stage;\n  } else {\n    return FALSE;\n  }\n}\n\nbool_t widget_is_window_created(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n    return WINDOW_STAGE_OPENED == stage || WINDOW_STAGE_SUSPEND == stage ||\n           WINDOW_STAGE_LOADED == stage || WINDOW_STAGE_CREATED == stage;\n  } else {\n    return FALSE;\n  }\n}\n\nret_t widget_get_window_theme(widget_t* widget, theme_t** win_theme, theme_t** default_theme) {\n  value_t v;\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    if (widget_get_prop(win, WIDGET_PROP_THEME_OBJ, &v) == RET_OK) {\n      *win_theme = (theme_t*)value_pointer(&v);\n    }\n\n    if (widget_get_prop(win, WIDGET_PROP_DEFAULT_THEME_OBJ, &v) == RET_OK) {\n      *default_theme = (theme_t*)value_pointer(&v);\n    }\n  }\n  return RET_OK;\n}\n\nbool_t widget_is_style_exist(widget_t* widget, const char* style_name, const char* state_name) {\n  const void* data = NULL;\n  const char* style = NULL;\n  const char* state = NULL;\n  theme_t* win_theme = NULL;\n  theme_t* default_theme = NULL;\n  const char* type = widget_get_type(widget);\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(widget != NULL && win != NULL, FALSE);\n\n  if (style_name == NULL || *style_name == 0) {\n    style = TK_DEFAULT_STYLE;\n  } else {\n    style = style_name;\n  }\n\n  if (state_name == NULL || *state_name == 0) {\n    state = WIDGET_STATE_NORMAL;\n  } else {\n    state = state_name;\n  }\n\n  return_value_if_fail(widget_get_window_theme(widget, &win_theme, &default_theme) == RET_OK,\n                       FALSE);\n\n  if (win_theme != NULL) {\n    data = theme_find_style(win_theme, type, style, state);\n  }\n\n  if (data == NULL && default_theme != NULL) {\n    data = theme_find_style(default_theme, type, style, state);\n  }\n\n  return data != NULL;\n}\n\nret_t widget_use_style(widget_t* widget, const char* value) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_need_update_style(widget);\n  widget->style = tk_str_copy(widget->style, value);\n\n  if (widget_is_window_opened(widget)) {\n    widget_update_style(widget);\n    return widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_text(widget_t* widget, const wchar_t* text) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_wstr(&v, text));\n}\n\nret_t widget_set_text_utf8(widget_t* widget, const char* text) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_str(&v, text));\n}\n\nret_t widget_get_text_utf8(widget_t* widget, char* text, uint32_t size) {\n  value_t v;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && text != NULL && size > 0, RET_BAD_PARAMS);\n\n  value_set_str(&v, NULL);\n  memset(text, 0x00, size);\n  if (widget_get_prop(widget, WIDGET_PROP_TEXT, &v) == RET_OK) {\n    if (v.type == VALUE_TYPE_STRING) {\n      tk_strncpy(text, value_str(&v), size - 1);\n      ret = RET_OK;\n    } else if (v.type == VALUE_TYPE_WSTRING) {\n      tk_utf8_from_utf16(value_wstr(&v), text, size);\n      ret = RET_OK;\n    }\n  }\n\n  return ret;\n}\n\nimage_manager_t* widget_get_image_manager(widget_t* widget) {\n  image_manager_t* ret = image_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = image_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_IMAGE_MANAGER, &v) == RET_OK) {\n      ret = (image_manager_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nlocale_info_t* widget_get_locale_info(widget_t* widget) {\n  locale_info_t* ret = locale_info();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = locale_info();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_LOCALE_INFO, &v) == RET_OK) {\n      ret = (locale_info_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nassets_manager_t* widget_get_assets_manager(widget_t* widget) {\n  assets_manager_t* am = assets_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, am);\n\n  if (widget->assets_manager != NULL) {\n    return widget->assets_manager;\n  }\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    am = assets_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_ASSETS_MANAGER, &v) == RET_OK) {\n      am = (assets_manager_t*)value_pointer(&v);\n    }\n  }\n  widget->assets_manager = am;\n\n  return am;\n}\n\nfont_manager_t* widget_get_font_manager(widget_t* widget) {\n  font_manager_t* ret = font_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = font_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_FONT_MANAGER, &v) == RET_OK) {\n      ret = (font_manager_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_apply_tr_text_before_paint(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  if (widget->tr_text != NULL) {\n    const char* text = locale_info_tr(widget_get_locale_info(widget), widget->tr_text);\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n  }\n\n  return RET_REMOVE;\n}\n\nret_t widget_set_tr_text(widget_t* widget, const char* text) {\n  const char* tr_text = NULL;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(widget != NULL, RET_OK);\n\n  if (text == NULL || *text == '\\0') {\n    if (widget->tr_text != NULL) {\n      TKMEM_FREE(widget->tr_text);\n      widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n    }\n\n    return RET_OK;\n  }\n\n  widget->tr_text = tk_str_copy(widget->tr_text, text);\n  if (win != NULL) {\n    tr_text = locale_info_tr(widget_get_locale_info(widget), text);\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, tr_text);\n  } else {\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n    widget_on(widget, EVT_BEFORE_PAINT, widget_apply_tr_text_before_paint, widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_re_translate_text(widget_t* widget) {\n  if (widget->vt->on_re_translate != NULL) {\n    widget->vt->on_re_translate(widget);\n  }\n  if (widget->tr_text != NULL) {\n    value_t v;\n    const char* tr_text = locale_info_tr(widget_get_locale_info(widget), widget->tr_text);\n    widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_str(&v, tr_text));\n    widget_invalidate(widget, NULL);\n  }\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_re_translate_text(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nconst wchar_t* widget_get_text(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_TEXT, &v) == RET_OK ? value_wstr(&v) : 0;\n}\n\nret_t widget_set_name(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (name != NULL) {\n    widget->name = tk_str_copy(widget->name, name);\n  } else {\n    TKMEM_FREE(widget->name);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_theme(widget_t* widget, const char* name) {\n  theme_change_event_t will_event;\n  event_t* will_evt = theme_change_event_init(&will_event, EVT_THEME_WILL_CHANGE, name);\n  widget_dispatch(window_manager(), will_evt);\n#ifdef WITH_FS_RES\n  const asset_info_t* info = NULL;\n  theme_change_event_t event;\n  event_t* evt = theme_change_event_init(&event, EVT_THEME_CHANGED, name);\n  widget_t* wm = widget_get_window_manager(widget);\n  font_manager_t* fm = widget_get_font_manager(widget);\n  image_manager_t* imm = widget_get_image_manager(widget);\n  assets_manager_t* am = widget_get_assets_manager(widget);\n  locale_info_t* locale_info = widget_get_locale_info(widget);\n  return_value_if_fail(am != NULL && name != NULL, RET_BAD_PARAMS);\n\n  font_manager_unload_all(fm);\n  image_manager_unload_all(imm);\n  locale_info_reload(locale_info);\n  assets_manager_set_theme(am, name);\n  widget_reset_canvas(widget);\n\n  info = assets_manager_ref(am, ASSET_TYPE_STYLE, \"default\");\n  if (info != NULL) {\n    theme_set(theme_load_from_data(info->name, info->data, info->size));\n    assets_manager_unref(assets_manager(), info);\n  }\n\n  widget_dispatch(wm, evt);\n  widget_invalidate_force(wm, NULL);\n\n  log_debug(\"theme changed: %s\\n\", name);\n#endif\n\n  return RET_OK;\n}\n\nret_t widget_set_pointer_cursor(widget_t* widget, const char* cursor) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (!tk_str_eq(widget->pointer_cursor, cursor)) {\n    widget->pointer_cursor = tk_str_copy(widget->pointer_cursor, cursor);\n    widget_update_pointer_cursor(widget);\n  }\n\n  return RET_OK;\n}\n\n#ifndef WITHOUT_WIDGET_ANIMATORS\nret_t widget_set_animation(widget_t* widget, const char* animation) {\n  return_value_if_fail(widget != NULL && animation != NULL, RET_BAD_PARAMS);\n\n  widget->animation = tk_str_copy(widget->animation, animation);\n\n  return widget_create_animator(widget, animation);\n}\n\nret_t widget_create_animator(widget_t* widget, const char* animation) {\n  tokenizer_t t;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && animation != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(tokenizer_init(&t, animation, strlen(animation), \";\") != NULL, RET_OOM);\n\n  while (tokenizer_has_more(&t)) {\n    const char* params = tokenizer_next(&t);\n    if (widget_animator_create(widget, params) == NULL) {\n      ret = RET_BAD_PARAMS;\n      break;\n    }\n  }\n  tokenizer_deinit(&t);\n  widget_invalidate(widget, NULL);\n\n  return ret;\n}\n\nret_t widget_start_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_start(widget_animator_manager(), widget, name);\n}\n\nret_t widget_set_animator_time_scale(widget_t* widget, const char* name, float_t time_scale) {\n  return widget_animator_manager_set_time_scale(widget_animator_manager(), widget, name,\n                                                time_scale);\n}\n\nret_t widget_pause_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_pause(widget_animator_manager(), widget, name);\n}\n\nwidget_animator_t* widget_find_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_find(widget_animator_manager(), widget, name);\n}\n\nret_t widget_stop_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_stop(widget_animator_manager(), widget, name);\n}\n\nret_t widget_destroy_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_remove_all(widget_animator_manager(), widget, name);\n}\n#else\nret_t widget_start_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nret_t widget_create_animator(widget_t* widget, const char* animation) {\n  return RET_OK;\n}\nret_t widget_set_animation(widget_t* widget, const char* animation) {\n  return RET_OK;\n}\nret_t widget_set_animator_time_scale(widget_t* widget, const char* name, float_t time_scale) {\n  return RET_OK;\n}\nret_t widget_pause_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nwidget_animator_t* widget_find_animator(widget_t* widget, const char* name) {\n  return NULL;\n}\nret_t widget_stop_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nret_t widget_destroy_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\n#endif /*WITHOUT_WIDGET_ANIMATORS*/\n\nret_t widget_set_enable(widget_t* widget, bool_t enable) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->enable != enable) {\n    widget->enable = enable;\n    widget_set_need_update_style_recursive(widget);\n    widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_feedback(widget_t* widget, bool_t feedback) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->feedback = feedback;\n\n  return RET_OK;\n}\n\nret_t widget_set_auto_adjust_size(widget_t* widget, bool_t auto_adjust_size) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->auto_adjust_size = auto_adjust_size;\n  widget_set_need_relayout(widget);\n\n  return RET_OK;\n}\n\nret_t widget_set_floating(widget_t* widget, bool_t floating) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->floating = floating;\n\n  return RET_OK;\n}\n\nret_t widget_set_focused_internal(widget_t* widget, bool_t focused) {\n  widget_t* win = widget_get_window(widget);\n  int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (WINDOW_STAGE_SUSPEND == stage) {\n    log_debug(\"You can not set focus of a widget when window is in background\");\n    return RET_FAIL;\n  }\n\n  if (widget->focused != focused) {\n    widget->focused = focused;\n    widget_set_need_update_style(widget);\n\n    if (focused) {\n      event_t e = event_init(EVT_FOCUS, widget);\n      widget_set_as_key_target(widget);\n\n      widget_dispatch(widget, &e);\n    } else {\n      event_t e = event_init(EVT_BLUR, widget);\n      widget_dispatch(widget, &e);\n      widget_dispatch_blur_event(widget);\n    }\n\n    widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_focused(widget_t* widget, bool_t focused) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_focused_internal(widget, focused);\n  if (focused) {\n    widget_ensure_visible_in_viewport(widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_focusable(widget_t* widget, bool_t focusable) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->focusable = focusable;\n\n  return RET_OK;\n}\n\nret_t widget_set_state(widget_t* widget, const char* state) {\n  return_value_if_fail(widget != NULL && state != NULL, RET_BAD_PARAMS);\n\n  if (!tk_str_eq(widget->state, state)) {\n    widget_invalidate_force(widget, NULL);\n    widget->state = tk_str_copy(widget->state, state);\n    widget_set_need_update_style(widget);\n    widget_invalidate_force(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_state_for_style(widget_t* widget, bool_t active, bool_t checked) {\n  const char* state = WIDGET_STATE_NORMAL;\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, state);\n\n  state = (const char*)(widget->state);\n\n  while (iter != NULL) {\n    if (!iter->enable) {\n      if (active) return WIDGET_STATE_DISABLE_OF_ACTIVE;\n      if (checked) return WIDGET_STATE_DISABLE_OF_CHECKED;\n      return WIDGET_STATE_DISABLE;\n    }\n    iter = iter->parent;\n  }\n\n  if (widget_is_focusable(widget) || widget_with_focus_state(widget)) {\n    if (widget->focused) {\n      if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n        state = WIDGET_STATE_FOCUSED;\n      }\n    } else {\n      if (tk_str_eq(state, WIDGET_STATE_FOCUSED)) {\n        state = WIDGET_STATE_NORMAL;\n      }\n    }\n  }\n\n  if (active) {\n    if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n      state = WIDGET_STATE_NORMAL_OF_ACTIVE;\n    } else if (tk_str_eq(state, WIDGET_STATE_PRESSED)) {\n      state = WIDGET_STATE_PRESSED_OF_ACTIVE;\n    } else if (tk_str_eq(state, WIDGET_STATE_OVER)) {\n      state = WIDGET_STATE_OVER_OF_ACTIVE;\n    } else if (widget_is_focusable(widget) && widget->focused) {\n      state = WIDGET_STATE_FOCUSED_OF_ACTIVE;\n    }\n  } else if (checked) {\n    if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n      state = WIDGET_STATE_NORMAL_OF_CHECKED;\n    } else if (tk_str_eq(state, WIDGET_STATE_PRESSED)) {\n      state = WIDGET_STATE_PRESSED_OF_CHECKED;\n    } else if (tk_str_eq(state, WIDGET_STATE_OVER)) {\n      state = WIDGET_STATE_OVER_OF_CHECKED;\n    } else if (widget_is_focusable(widget) && widget->focused) {\n      state = WIDGET_STATE_FOCUSED_OF_CHECKED;\n    }\n  }\n\n  return state;\n}\n\nret_t widget_set_opacity(widget_t* widget, uint8_t opacity) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->opacity = opacity;\n  widget_invalidate(widget, NULL);\n\n  return RET_OK;\n}\n\nret_t widget_set_dirty_rect_tolerance(widget_t* widget, uint16_t dirty_rect_tolerance) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->dirty_rect_tolerance = dirty_rect_tolerance;\n  widget_invalidate(widget, NULL);\n\n  return RET_OK;\n}\n\nret_t widget_destroy_children(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->children != NULL) {\n    WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n\n    widget_remove_child_prepare(widget, iter);\n    widget_unref(iter);\n\n    widget->children->elms[i] = NULL;\n\n    WIDGET_FOR_EACH_CHILD_END();\n    widget->children->size = 0;\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_style_type(widget_t* widget) {\n  theme_t* win_theme = NULL;\n  theme_t* default_theme = NULL;\n  const char* style_type = THEME_DEFAULT_STYLE_TYPE;\n\n  if (widget_get_window_theme(widget, &win_theme, &default_theme) == RET_OK) {\n    theme_t* t = win_theme != NULL ? win_theme : (default_theme != NULL ? default_theme : theme());\n    if (t != NULL) {\n      style_type = theme_get_style_type(t);\n    }\n  }\n\n  return style_type;\n}\n\nstatic ret_t widget_update_style_object(widget_t* widget) {\n  const char* style_type = widget_get_style_type(widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  if (widget->astyle == NULL) {\n    widget->astyle = style_factory_create_style(style_factory(), style_type);\n    ENSURE(widget->astyle != NULL);\n\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  } else if (widget->astyle != NULL &&\n             !tk_str_eq(style_get_style_type(widget->astyle), style_type)) {\n    style_t* style = style_factory_create_style(style_factory(), style_type);\n    ENSURE(style != NULL);\n    if (style_is_mutable(widget->astyle)) {\n      style_mutable_set_default_style(widget->astyle, style);\n    } else {\n      style_destroy(widget->astyle);\n      widget->astyle = style;\n    }\n\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  }\n  return RET_OK;\n}\n\nstatic ret_t widget_update_style_object_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_update_style_object(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_update_style_object_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_add_child(widget_t* widget, widget_t* child) {\n  event_t e = event_init(EVT_WIDGET_ADD_CHILD, widget);\n  return_value_if_fail(widget != NULL && child != NULL && child->parent == NULL, RET_BAD_PARAMS);\n\n  child->parent = widget;\n\n  if (widget->children == NULL) {\n    widget->children = darray_create(4, NULL, NULL);\n  }\n\n  if (widget->vt->on_add_child) {\n    if (widget->vt->on_add_child(widget, child) == RET_OK) {\n      return RET_OK;\n    }\n  }\n\n  if (child->vt->on_attach_parent) {\n    child->vt->on_attach_parent(child, widget);\n  }\n\n  ENSURE(darray_push(widget->children, child) == RET_OK);\n\n  if (!widget_is_window_manager(widget)) {\n    widget_set_need_relayout_children(widget);\n  }\n\n  if (!(child->initializing) && widget_get_window(child) != NULL) {\n    widget_set_need_update_style_recursive(child);\n    widget_update_style_object_recursive(child);\n  }\n\n  widget_dispatch(widget, &e);\n\n  return RET_OK;\n}\n\nret_t widget_remove_child_prepare(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n\n  if (!widget_is_window_manager(widget)) {\n    widget_set_need_relayout_children(widget);\n  }\n\n  widget_invalidate_force(child, NULL);\n  if (widget->target == child) {\n    widget->target = NULL;\n  }\n\n  if (widget->grab_widget == child) {\n    widget->grab_widget = NULL;\n    widget->grab_widget_count = 0;\n  }\n\n  if (widget->key_target == child) {\n    widget_dispatch_blur_event(widget->key_target);\n    widget->key_target = NULL;\n  }\n\n  if (widget->vt->on_remove_child) {\n    if (widget->vt->on_remove_child(widget, child) == RET_OK) {\n      return RET_OK;\n    }\n  }\n\n  if (child->vt->on_detach_parent) {\n    child->vt->on_detach_parent(child, widget);\n  }\n  child->parent = NULL;\n\n  return RET_OK;\n}\n\nret_t widget_remove_child(widget_t* widget, widget_t* child) {\n  ret_t ret = RET_OK;\n  event_t e = event_init(EVT_WIDGET_REMOVE_CHILD, widget);\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n\n  widget_remove_child_prepare(widget, child);\n  ret = darray_remove(widget->children, child);\n\n  if (ret == RET_OK) {\n    widget_dispatch(widget, &e);\n  }\n\n  return ret;\n}\n\nret_t widget_insert_child(widget_t* widget, uint32_t index, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget_add_child(widget, child) == RET_OK, RET_FAIL);\n\n  return widget_restack(child, index);\n}\n\nret_t widget_restack(widget_t* widget, uint32_t index) {\n  uint32_t i = 0;\n  uint32_t nr = 0;\n  int32_t old_index = 0;\n  widget_t** children = NULL;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, RET_BAD_PARAMS);\n\n  old_index = widget_index_of(widget);\n  nr = widget_count_children(widget->parent);\n  return_value_if_fail(old_index >= 0 && nr > 0, RET_BAD_PARAMS);\n\n  if (index >= nr) {\n    index = nr - 1;\n  }\n\n  if (index == old_index || nr == 1) {\n    return RET_OK;\n  }\n\n  children = (widget_t**)(widget->parent->children->elms);\n  if (index < old_index) {\n    for (i = old_index; i > index; i--) {\n      children[i] = children[i - 1];\n    }\n  } else {\n    for (i = old_index; i < index; i++) {\n      children[i] = children[i + 1];\n    }\n  }\n  children[index] = widget;\n\n  return RET_OK;\n}\n\nstatic widget_t* widget_lookup_child(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL && name != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (iter->name != NULL && tk_str_eq(iter->name, name)) {\n    return iter;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return NULL;\n}\n\nwidget_t* widget_child(widget_t* widget, const char* path) {\n  return widget_lookup_child(widget, path);\n}\n\nwidget_t* widget_get_focused_widget(widget_t* widget) {\n  widget_t* iter = NULL;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(win != NULL, NULL);\n\n  iter = win->key_target;\n  for (iter = win->key_target; iter != NULL; iter = iter->key_target) {\n    if (iter->focusable && iter->focused) {\n      return iter;\n    }\n\n    if (iter->key_target == NULL) {\n      return iter;\n    }\n  }\n\n  return NULL;\n}\n\nstatic widget_t* widget_lookup_all(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL && name != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (iter->name != NULL && tk_str_eq(iter->name, name)) {\n    return iter;\n  } else {\n    iter = widget_lookup_all(iter, name);\n    if (iter != NULL) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nwidget_t* widget_lookup(widget_t* widget, const char* name, bool_t recursive) {\n  if (recursive) {\n    return widget_lookup_all(widget, name);\n  } else {\n    return widget_lookup_child(widget, name);\n  }\n}\n\nstatic widget_t* widget_lookup_by_type_child(widget_t* widget, const char* type) {\n  return_value_if_fail(widget != NULL && type != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (tk_str_eq(iter->vt->type, type)) {\n    return iter;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return NULL;\n}\n\nstatic widget_t* widget_lookup_by_type_all(widget_t* widget, const char* type) {\n  return_value_if_fail(widget != NULL && type != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (tk_str_eq(iter->vt->type, type)) {\n    return iter;\n  } else {\n    iter = widget_lookup_by_type_all(iter, type);\n    if (iter != NULL) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nwidget_t* widget_lookup_by_type(widget_t* widget, const char* type, bool_t recursive) {\n  if (recursive) {\n    return widget_lookup_by_type_all(widget, type);\n  } else {\n    return widget_lookup_by_type_child(widget, type);\n  }\n}\n\nstatic ret_t widget_set_visible_self(widget_t* widget, bool_t visible) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->visible != visible) {\n    widget_invalidate_force(widget, NULL);\n    widget->visible = visible;\n    widget_set_need_update_style(widget);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget->parent);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_sensitive(widget_t* widget, bool_t sensitive) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->sensitive = sensitive;\n\n  return RET_OK;\n}\n\nret_t widget_set_visible_only(widget_t* widget, bool_t visible) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->visible = visible;\n\n  return RET_OK;\n}\n\nret_t widget_set_visible(widget_t* widget, bool_t visible, ...) {\n  return widget_set_visible_self(widget, visible);\n}\n\nwidget_t* widget_find_target(widget_t* widget, xy_t x, xy_t y) {\n  widget_t* ret = NULL;\n  return_value_if_fail(widget != NULL, NULL);\n\n  if (widget->vt && widget->vt->find_target) {\n    ret = widget->vt->find_target(widget, x, y);\n  } else {\n    ret = widget_find_target_default(widget, x, y);\n  }\n\n  return ret;\n}\n\nret_t widget_on_event_before_children(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt && widget->vt->on_event_before_children) {\n    ret = widget->vt->on_event_before_children(widget, e);\n  }\n\n  return ret;\n}\n\nstatic const char* widget_get_pointer_cursor(widget_t* widget) {\n  if (widget->pointer_cursor != NULL) {\n    return widget->pointer_cursor;\n  } else if (widget->vt->pointer_cursor != NULL) {\n    return widget->vt->pointer_cursor;\n  }\n\n  return WIDGET_CURSOR_DEFAULT;\n}\n\nret_t widget_update_pointer_cursor(widget_t* widget) {\n  widget_t* wm = widget_get_window_manager(widget);\n  return_value_if_fail(wm != NULL, RET_BAD_PARAMS);\n\n  return window_manager_set_cursor(wm, widget_get_pointer_cursor(widget));\n}\n\nret_t widget_dispatch(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  if (e->target == NULL) {\n    e->target = widget;\n  }\n\n  if (widget->vt && widget->vt->on_event) {\n    ret = widget->vt->on_event(widget, e);\n  } else {\n    ret = widget_on_event_default(widget, e);\n  }\n\n  if (ret != RET_STOP) {\n    if (widget->emitter != NULL) {\n      void* saved_target = e->target;\n\n      e->target = widget;\n      ret = emitter_dispatch(widget->emitter, e);\n      e->target = saved_target;\n    }\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t dispatch_in_idle(const idle_info_t* info) {\n  event_t* e = (event_t*)(info->ctx);\n  widget_t* widget = WIDGET(e->target);\n\n  widget_dispatch(widget, e);\n  widget_unref(widget);\n  event_destroy(e);\n\n  return RET_REMOVE;\n}\n\nret_t widget_dispatch_async(widget_t* widget, event_t* e) {\n  event_t* evt = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(e->target == widget, RET_BAD_PARAMS);\n\n  evt = event_clone(e);\n  return_value_if_fail(evt != NULL, RET_OOM);\n\n  widget_ref(widget);\n  idle_add(dispatch_in_idle, evt);\n\n  return RET_OK;\n}\n\nstatic ret_t widget_dispatch_callback(void* ctx, const void* data) {\n  widget_t* widget = WIDGET(data);\n\n  return widget_dispatch(widget, (event_t*)ctx);\n}\n\nret_t widget_dispatch_recursive(widget_t* widget, event_t* e) {\n  return widget_foreach(widget, widget_dispatch_callback, e);\n}\n\nuint32_t widget_on_with_tag(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx,\n                            uint32_t tag) {\n  return_value_if_fail(widget != NULL && on_event != NULL, RET_BAD_PARAMS);\n  if (widget->emitter == NULL) {\n    widget->emitter = emitter_create();\n  }\n\n  return emitter_on_with_tag(widget->emitter, type, on_event, ctx, tag);\n}\n\nuint32_t widget_on(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx) {\n  return widget_on_with_tag(widget, type, on_event, ctx, 0);\n}\n\nuint32_t widget_child_on(widget_t* widget, const char* name, uint32_t type, event_func_t on_event,\n                         void* ctx) {\n  return widget_on(widget_lookup(widget, name, TRUE), type, on_event, ctx);\n}\n\nret_t widget_off(widget_t* widget, uint32_t id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->emitter != NULL, RET_BAD_PARAMS);\n\n  return emitter_off(widget->emitter, id);\n}\n\nret_t widget_off_by_tag(widget_t* widget, uint32_t tag) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_tag(widget->emitter, tag);\n}\n\nret_t widget_off_by_ctx(widget_t* widget, void* ctx) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_ctx(widget->emitter, ctx);\n}\n\nret_t widget_off_by_func(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx) {\n  return_value_if_fail(widget != NULL && on_event != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_func(widget->emitter, type, on_event, ctx);\n}\n\nret_t widget_calc_icon_text_rect(const rect_t* ir, int32_t font_size, float_t text_size,\n                                 int32_t icon_at, uint32_t img_w, uint32_t img_h, int32_t spacer,\n                                 rect_t* r_text, rect_t* r_icon) {\n  return_value_if_fail(ir != NULL && (r_text != NULL || r_icon != NULL), RET_BAD_PARAMS);\n\n  if (r_icon == NULL) {\n    *r_text = *ir;\n\n    return RET_OK;\n  }\n\n  if (r_text == NULL) {\n    *r_icon = *ir;\n\n    return RET_OK;\n  }\n\n  return_value_if_fail(spacer < ir->h && spacer < ir->w, RET_BAD_PARAMS);\n  switch (icon_at) {\n    case ICON_AT_CENTRE: {\n      int32_t w = ir->w - spacer - text_size - img_w;\n      int32_t icon_h = ir->h - img_h;\n      *r_text = rect_init(ir->x + img_w + spacer + w / 2, ir->y, text_size, ir->h);\n      *r_icon = rect_init(ir->x + w / 2, ir->y + icon_h / 2, img_w, img_h);\n      break;\n    }\n    case ICON_AT_RIGHT: {\n      uint32_t w = img_w;\n      float_t ratio = system_info()->device_pixel_ratio;\n      if (ratio > 1) {\n        w = img_w / ratio;\n      }\n      w = tk_min(tk_max(w, ir->h), ir->w);\n      *r_icon = rect_init(ir->x + ir->w - w, ir->y, w, ir->h);\n      *r_text = rect_init(ir->x, ir->y, ir->w - ir->h - spacer, ir->h);\n      break;\n    }\n    case ICON_AT_TOP: {\n      int32_t icon_h = ir->h - font_size - spacer;\n      *r_icon = rect_init(ir->x, ir->y, ir->w, icon_h);\n      *r_text = rect_init(ir->x, icon_h + spacer, ir->w, font_size);\n      break;\n    }\n    case ICON_AT_BOTTOM: {\n      int32_t icon_h = ir->h - font_size - spacer;\n      *r_icon = rect_init(ir->x, ir->y + ir->h - icon_h, ir->w, icon_h);\n      *r_text = rect_init(ir->x, ir->y, ir->w, font_size);\n      break;\n    }\n    case ICON_AT_LEFT:\n    default: {\n      *r_icon = rect_init(ir->x, ir->y, ir->h, ir->h);\n      *r_text = rect_init(ir->x + ir->h + spacer, ir->y, ir->w - ir->h - spacer, ir->h);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_bidi(widget_t* widget) {\n  value_t v;\n  if (widget_get_prop(widget, WIDGET_PROP_BIDI, &v) == RET_OK) {\n    return value_str(&v);\n  }\n\n  return NULL;\n}\n\nret_t widget_draw_icon_text(widget_t* widget, canvas_t* c, const char* icon, wstr_t* text) {\n  rect_t ir;\n  wh_t w = 0;\n  wh_t h = 0;\n  bitmap_t img;\n  rect_t r_icon;\n  rect_t r_text;\n  int32_t margin = 0;\n  int32_t spacer = 0;\n  int32_t icon_at = 0;\n  uint16_t font_size = 0;\n  float_t text_size = 0.0f;\n  int32_t margin_left = 0;\n  int32_t margin_right = 0;\n  int32_t margin_top = 0;\n  int32_t margin_bottom = 0;\n  style_t* style = widget->astyle;\n  int32_t align_h = ALIGN_H_LEFT;\n  int32_t align_v = ALIGN_V_MIDDLE;\n  return_value_if_fail(widget->astyle != NULL, RET_BAD_PARAMS);\n\n  spacer = style_get_int(style, STYLE_ID_SPACER, 2);\n  margin = style_get_int(style, STYLE_ID_MARGIN, 0);\n  margin_top = style_get_int(style, STYLE_ID_MARGIN_TOP, margin);\n  margin_left = style_get_int(style, STYLE_ID_MARGIN_LEFT, margin);\n  margin_right = style_get_int(style, STYLE_ID_MARGIN_RIGHT, margin);\n  margin_bottom = style_get_int(style, STYLE_ID_MARGIN_BOTTOM, margin);\n  icon_at = style_get_int(style, STYLE_ID_ICON_AT, ICON_AT_AUTO);\n\n  w = widget->w - margin_left - margin_right;\n  h = widget->h - margin_top - margin_bottom;\n  ir = rect_init(margin_left, margin_top, w, h);\n\n  if (text == NULL) {\n    text = &(widget->text);\n  }\n\n  if (icon == NULL) {\n    icon = style_get_str(style, STYLE_ID_ICON, NULL);\n  }\n\n  widget_prepare_text_style(widget, c);\n\n  font_size = c->font_size;\n  text_size = text->str ? canvas_measure_text(c, text->str, text->size) : 0;\n  if (icon_at == ICON_AT_RIGHT || icon_at == ICON_AT_LEFT) {\n    align_v = style_get_int(style, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    align_h = style_get_int(style, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_LEFT);\n  } else {\n    align_v = style_get_int(style, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    align_h = style_get_int(style, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_CENTER);\n  }\n  canvas_set_text_align(c, (align_h_t)align_h, (align_v_t)align_v);\n\n  if (icon != NULL && widget_load_image(widget, icon, &img) == RET_OK) {\n    float_t dpr = system_info()->device_pixel_ratio;\n\n    if (text->size > 0) {\n      if ((h > (img.h / dpr + font_size) && icon_at == ICON_AT_AUTO)) {\n        icon_at = ICON_AT_TOP;\n      }\n\n      widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer, &r_text,\n                                 &r_icon);\n\n      canvas_draw_icon_in_rect(c, &img, &r_icon);\n      widget_draw_text_in_rect(widget, c, text->str, text->size, &r_text, FALSE);\n    } else {\n      if (icon_at == ICON_AT_AUTO) {\n        widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer, NULL,\n                                   &r_icon);\n      } else {\n        widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer,\n                                   &r_text, &r_icon);\n      }\n      canvas_draw_icon_in_rect(c, &img, &r_icon);\n    }\n  } else if (text != NULL && text->size > 0) {\n    widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, 0, 0, spacer, &r_text, NULL);\n    widget_draw_text_in_rect(widget, c, text->str, text->size, &r_text, FALSE);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_fill_rect(widget_t* widget, canvas_t* c, const rect_t* r, bool_t bg,\n                       image_draw_type_t draw_type) {\n  bitmap_t img;\n  ret_t ret = RET_OK;\n  gradient_t agradient;\n  style_t* style = widget->astyle;\n  uint32_t radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  const char* color_key = bg ? STYLE_ID_BG_COLOR : STYLE_ID_FG_COLOR;\n  const char* image_key = bg ? STYLE_ID_BG_IMAGE : STYLE_ID_FG_IMAGE;\n  rect_t bg_r = rect_init(widget->x, widget->y, widget->w, widget->h);\n  uint32_t radius_tl = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_LEFT, radius);\n  uint32_t radius_tr = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_RIGHT, radius);\n  uint32_t radius_bl = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_LEFT, radius);\n  uint32_t radius_br = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_RIGHT, radius);\n  uint32_t clear_bg = style_get_uint(style, STYLE_ID_CLEAR_BG, 0);\n  const char* draw_type_key = bg ? STYLE_ID_BG_IMAGE_DRAW_TYPE : STYLE_ID_FG_IMAGE_DRAW_TYPE;\n  gradient_t* gradient = style_get_gradient(style, color_key, &agradient);\n  const char* image_name = style_get_str(style, image_key, NULL);\n\n  if (gradient != NULL && r->w > 0 && r->h > 0) {\n    color_t color = gradient_get_first_color(gradient);\n    canvas_set_fill_color(c, color);\n    if (gradient->nr > 1 || color.rgba.a) {\n      if (radius_tl > 3 || radius_tr > 3 || radius_bl > 3 || radius_br > 3) {\n        /*TODO: support gradient*/\n        if (bg) {\n          ret = canvas_fill_rounded_rect_gradient_ex(c, r, NULL, gradient, radius_tl, radius_tr,\n                                                     radius_bl, radius_br);\n        } else {\n          ret = canvas_fill_rounded_rect_gradient_ex(c, r, &bg_r, gradient, radius_tl, radius_tr,\n                                                     radius_bl, radius_br);\n        }\n        if (ret == RET_FAIL) {\n          canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n        }\n      } else if (gradient->nr > 1) {\n        canvas_fill_rect_gradient(c, r->x, r->y, r->w, r->h, gradient);\n      } else {\n        if (clear_bg) {\n          canvas_clear_rect(c, r->x, r->y, r->w, r->h);\n        } else {\n          canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n        }\n      }\n    } else if (clear_bg) {\n      canvas_clear_rect(c, r->x, r->y, r->w, r->h);\n    }\n  }\n\n  if (image_name != NULL && *image_name && r->w > 0 && r->h > 0) {\n    char name[MAX_PATH + 1];\n    const char* region = strrchr(image_name, '#');\n    if (region != NULL) {\n      memset(name, 0x00, sizeof(name));\n      tk_strncpy(name, image_name, region - image_name);\n      image_name = name;\n    }\n\n    if (widget_load_image(widget, image_name, &img) == RET_OK) {\n      draw_type = (image_draw_type_t)style_get_int(style, draw_type_key, draw_type);\n\n      if (region == NULL) {\n        canvas_draw_image_ex(c, &img, draw_type, r);\n      } else {\n        rect_t src;\n        rect_t dst = *r;\n        if (tk_str_eq(region, \"#\")) {\n          src = rect_init(widget->x, widget->y, widget->w, widget->h);\n        } else if (tk_str_eq(region, \"#g\")) {\n          point_t p = {widget->x, widget->y};\n          widget_to_global(widget, &p);\n          src = rect_init(p.x, p.y, widget->w, widget->h);\n        } else {\n          image_region_parse(img.w, img.h, region, &src);\n        }\n\n        canvas_draw_image_ex2(c, &img, draw_type, &src, &dst);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_stroke_border_rect_for_border_type(canvas_t* c, const rect_t* r, color_t bd,\n                                                int32_t border, uint32_t border_width) {\n  wh_t w = r->w;\n  wh_t h = r->h;\n  xy_t x = r->x + 0.5;\n  xy_t y = r->y + 0.5;\n  xy_t y1 = y;\n  wh_t h1 = h;\n  bool_t draw_top = FALSE;\n  bool_t draw_bottom = FALSE;\n  canvas_set_fill_color(c, bd);\n  if (border & BORDER_TOP) {\n    draw_top = TRUE;\n    canvas_fill_rect(c, x, y, w, border_width);\n  }\n  if (border & BORDER_BOTTOM) {\n    draw_bottom = TRUE;\n    canvas_fill_rect(c, x, y + h - border_width, w, border_width);\n  }\n  /* 减少重复绘制的部分，可以修复有透明的时候重叠区域显示不正常为问题 */\n  if (draw_top) {\n    y1 += border_width;\n    h1 -= border_width;\n  }\n  if (draw_bottom) {\n    h1 -= border_width;\n  }\n  if (border & BORDER_LEFT) {\n    canvas_fill_rect(c, x, y1, border_width, h1);\n  }\n  if (border & BORDER_RIGHT) {\n    canvas_fill_rect(c, x + w - border_width, y1, border_width, h1);\n  }\n  return RET_OK;\n}\n\nret_t widget_stroke_border_rect(widget_t* widget, canvas_t* c, const rect_t* r) {\n  style_t* style = widget->astyle;\n  color_t trans = color_init(0, 0, 0, 0);\n  color_t bd = style_get_color(style, STYLE_ID_BORDER_COLOR, trans);\n  uint32_t radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  int32_t border = style_get_int(style, STYLE_ID_BORDER, BORDER_ALL);\n  uint32_t border_width = style_get_int(style, STYLE_ID_BORDER_WIDTH, 1);\n  uint32_t radius_tl = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_LEFT, radius);\n  uint32_t radius_tr = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_RIGHT, radius);\n  uint32_t radius_bl = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_LEFT, radius);\n  uint32_t radius_br = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_RIGHT, radius);\n\n  if (bd.rgba.a) {\n    canvas_set_stroke_color(c, bd);\n    if (radius_tl > 3 || radius_tr > 3 || radius_bl > 3 || radius_br > 3) {\n      if (canvas_stroke_rounded_rect_ex(c, r, NULL, &bd, radius_tl, radius_tr, radius_bl, radius_br,\n                                        border_width, border) != RET_OK) {\n        widget_stroke_border_rect_for_border_type(c, r, bd, border, border_width);\n      }\n    } else {\n      widget_stroke_border_rect_for_border_type(c, r, bd, border, border_width);\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_draw_background(widget_t* widget, canvas_t* c) {\n  rect_t r;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  r = rect_init(0, 0, widget->w, widget->h);\n\n  return widget_fill_rect(widget, c, &r, TRUE, IMAGE_DRAW_CENTER);\n}\n\nret_t widget_fill_bg_rect(widget_t* widget, canvas_t* c, const rect_t* r,\n                          image_draw_type_t draw_type) {\n  return widget_fill_rect(widget, c, r, TRUE, draw_type);\n}\n\nret_t widget_fill_fg_rect(widget_t* widget, canvas_t* c, const rect_t* r,\n                          image_draw_type_t draw_type) {\n  return widget_fill_rect(widget, c, r, FALSE, draw_type);\n}\n\nstatic ret_t widget_draw_border(widget_t* widget, canvas_t* c) {\n  rect_t r;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  r = rect_init(0, 0, widget->w, widget->h);\n  return widget_stroke_border_rect(widget, c, &r);\n}\n\nret_t widget_paint_helper(widget_t* widget, canvas_t* c, const char* icon, wstr_t* text) {\n  if (style_is_valid(widget->astyle)) {\n    widget_draw_icon_text(widget, c, icon, text);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_paint_impl(widget_t* widget, canvas_t* c) {\n  int32_t ox = widget->x;\n  int32_t oy = widget->y;\n  uint8_t save_alpha = c->global_alpha;\n\n  if (widget->opacity < TK_OPACITY_ALPHA) {\n    canvas_set_global_alpha(c, (widget->opacity * save_alpha) / 0xff);\n  }\n\n  if (widget->astyle != NULL) {\n    ox += style_get_int(widget->astyle, STYLE_ID_X_OFFSET, 0);\n    oy += style_get_int(widget->astyle, STYLE_ID_Y_OFFSET, 0);\n  }\n\n  canvas_translate(c, ox, oy);\n  widget_on_paint_begin(widget, c);\n  widget_on_paint_background(widget, c);\n  widget_on_paint_self(widget, c);\n  widget_on_paint_children(widget, c);\n  widget_on_paint_border(widget, c);\n  widget_on_paint_end(widget, c);\n\n  canvas_untranslate(c, ox, oy);\n  if (widget->opacity < TK_OPACITY_ALPHA) {\n    canvas_set_global_alpha(c, save_alpha);\n  }\n\n  widget_on_paint_done(widget, c);\n\n  return RET_OK;\n}\n\nret_t widget_paint(widget_t* widget, canvas_t* c) {\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  if (!widget->visible || widget->opacity <= 0x08 || widget->w <= 0 || widget->h <= 0) {\n    widget->dirty = FALSE;\n    return RET_OK;\n  }\n\n  if (widget->need_update_style) {\n    widget_update_style(widget);\n  }\n\n  canvas_save(c);\n  widget_paint_impl(widget, c);\n  canvas_restore(c);\n\n  widget->dirty = FALSE;\n\n  return RET_OK;\n}\n\nstatic const widget_cmd_t s_widget_cmds[] = {\n    {WIDGET_EXEC_START_ANIMATOR, widget_start_animator},\n    {WIDGET_EXEC_STOP_ANIMATOR, widget_stop_animator},\n    {WIDGET_EXEC_PAUSE_ANIMATOR, widget_pause_animator},\n    {WIDGET_EXEC_DESTROY_ANIMATOR, widget_destroy_animator}};\n\nstatic ret_t widget_do_exec(widget_t* widget, const char* cmd, const char* args) {\n  uint32_t i = 0;\n\n  for (i = 0; i < ARRAY_SIZE(s_widget_cmds); i++) {\n    const widget_cmd_t* iter = s_widget_cmds + i;\n    if (tk_str_eq(cmd, iter->name)) {\n      return iter->exec(widget, args);\n    }\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t widget_exec(widget_t* widget, const char* str) {\n  if (str != NULL) {\n    char cmd[TK_NAME_LEN + 1] = {0};\n    const char* args = strchr(str, ':');\n\n    if (args != NULL) {\n      return_value_if_fail((args - str) < TK_NAME_LEN, RET_BAD_PARAMS);\n      tk_strncpy(cmd, str, args - str);\n      args += 1;\n    } else {\n      return_value_if_fail(strlen(str) < TK_NAME_LEN, RET_BAD_PARAMS);\n      tk_strcpy(cmd, str);\n    }\n\n    return widget_do_exec(widget, cmd, args);\n  } else {\n    return RET_NOT_FOUND;\n  }\n}\n\nstatic widget_t* widget_get_top_widget_grab_key(widget_t* widget) {\n  return_value_if_fail(widget != NULL, NULL);\n  WIDGET_FOR_EACH_CHILD_BEGIN_R(widget, iter, i)\n  value_t v;\n  widget_t* widget_grab_key = widget_get_top_widget_grab_key(iter);\n  if (widget_grab_key == NULL && iter != NULL && iter->visible && iter->custom_props != NULL) {\n    ret_t ret = tk_object_get_prop(iter->custom_props, WIDGET_PROP_GRAB_KEYS, &v);\n    if (ret == RET_OK && value_bool(&v)) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nstatic ret_t widget_on_ungrab_keys(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  window_manager_t* wm = WINDOW_MANAGER(widget_get_window_manager(widget));\n\n  wm->widget_grab_key = widget_get_top_widget_grab_key(WIDGET(wm));\n\n  return RET_REMOVE;\n}\n\nstatic ret_t widget_exec_code(void* ctx, event_t* evt) {\n#ifndef WITHOUT_FSCRIPT\n  value_t v;\n  value_t result;\n  ret_t ret = RET_OK;\n  tk_object_t* obj = NULL;\n  widget_t* widget = WIDGET(evt->target);\n  const char* code = (const char*)ctx;\n  if (widget_get_prop(widget, STR_PROP_MODEL, &v) == RET_OK) {\n    obj = value_object(&v);\n  }\n  if (obj != NULL) {\n    TK_OBJECT_REF(obj);\n  } else {\n    obj = object_default_create();\n  }\n  return_value_if_fail(obj != NULL && code != NULL, RET_REMOVE);\n\n  tk_object_set_prop_pointer(obj, STR_PROP_SELF, widget);\n\n  switch (evt->type) {\n    case EVT_CLICK:\n    case EVT_POINTER_DOWN:\n    case EVT_POINTER_MOVE:\n    case EVT_POINTER_UP: {\n      pointer_event_t* e = pointer_event_cast(evt);\n      tk_object_set_prop_int(obj, \"x\", e->x);\n      tk_object_set_prop_int(obj, \"y\", e->y);\n      tk_object_set_prop_bool(obj, \"alt\", e->alt);\n      tk_object_set_prop_bool(obj, \"cmd\", e->cmd);\n      tk_object_set_prop_bool(obj, \"menu\", e->menu);\n      tk_object_set_prop_bool(obj, \"ctrl\", e->ctrl);\n      break;\n    }\n    case EVT_KEY_DOWN:\n    case EVT_KEY_LONG_PRESS:\n    case EVT_KEY_UP: {\n      key_event_t* e = key_event_cast(evt);\n      const key_type_value_t* kv = keys_type_find_by_value(e->key);\n      if (kv != NULL) {\n        tk_object_set_prop_str(obj, \"key\", kv->name);\n      } else {\n        tk_object_set_prop_str(obj, \"key\", \"unkown\");\n      }\n      tk_object_set_prop_bool(obj, \"alt\", e->alt);\n      tk_object_set_prop_bool(obj, \"cmd\", e->cmd);\n      tk_object_set_prop_bool(obj, \"menu\", e->menu);\n      tk_object_set_prop_bool(obj, \"ctrl\", e->ctrl);\n      break;\n    }\n    default:\n      break;\n  }\n\n  value_set_int(&result, 0);\n  fscript_eval(obj, code, &result);\n  if (tk_object_get_prop_bool(obj, \"RET_STOP\", FALSE)) {\n    ret = RET_STOP;\n  }\n  if (tk_object_get_prop_bool(obj, \"RET_REMOVE\", FALSE)) {\n    ret = RET_REMOVE;\n  }\n  value_reset(&result);\n  TK_OBJECT_UNREF(obj);\n\n  return ret;\n#else\n  return RET_OK;\n#endif\n}\n\nstatic ret_t widget_free_code(void* ctx, event_t* evt) {\n  widget_t* widget = WIDGET(evt->target);\n  widget_off_by_ctx(widget, ctx);\n  TKMEM_FREE(ctx);\n\n  return RET_REMOVE;\n}\n\n#define STR_ANIMATE_PREFIX \"animate:\"\n#define TK_ANIMATING_TIME 500 /* 单位：毫秒（ms） */\nret_t widget_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  ret_t ret = RET_OK;\n  prop_change_event_t e;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_EXEC)) {\n    ret = widget_exec(widget, value_str(v));\n    if (ret != RET_NOT_FOUND) {\n      return ret;\n    }\n  }\n\n  e.value = v;\n  e.name = name;\n  e.e = event_init(EVT_PROP_WILL_CHANGE, widget);\n  widget_dispatch(widget, (event_t*)&e);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    widget_set_x(widget, (xy_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    widget_set_y(widget, (xy_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    widget_set_w(widget, (wh_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    widget_set_h(widget, (wh_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    widget->opacity = (uint8_t)value_int(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    widget_set_visible(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    widget->sensitive = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    widget->floating = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    widget->focusable = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    widget->with_focus_state = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    widget->dirty_rect_tolerance = value_int(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    const char* name = value_str(v);\n    return widget_use_style(widget, name);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    widget_set_enable(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    widget->feedback = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    widget_set_auto_adjust_size(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    widget_set_name(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_TR_TEXT)) {\n    widget_set_tr_text(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    widget_set_animation(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    widget_set_self_layout(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_LAYOUT) || tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    widget_set_children_layout(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_POINTER_CURSOR)) {\n    widget_set_pointer_cursor(widget, value_str(v));\n  } else {\n    ret = RET_NOT_FOUND;\n  }\n\n  if (widget->vt->set_prop) {\n    if (tk_str_start_with(name, STR_ANIMATE_PREFIX)) {\n      return widget_animate_prop_float_to(widget, name + strlen(STR_ANIMATE_PREFIX),\n                                          value_float32(v), TK_ANIMATING_TIME);\n    } else {\n      ret_t ret1 = widget->vt->set_prop(widget, name, v);\n      if (ret == RET_NOT_FOUND) {\n        ret = ret1;\n      }\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_FOCUSED) || tk_str_eq(name, WIDGET_PROP_FOCUS)) {\n      widget_set_focused(widget, value_bool(v));\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n      wstr_from_value(&(widget->text), v);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_EXEC)) {\n      ret = RET_NOT_FOUND;\n    } else if (tk_str_start_with(name, \"style:\") || tk_str_start_with(name, \"style.\")) {\n      return widget_set_style(widget, name + 6, v);\n    } else {\n      if (widget->custom_props == NULL) {\n        widget->custom_props = object_default_create();\n      }\n\n      if (tk_str_eq(name, WIDGET_PROP_GRAB_KEYS)) {\n        window_manager_t* wm = WINDOW_MANAGER(widget_get_window_manager(widget));\n\n        if (value_bool(v)) {\n          widget_on(widget, EVT_DESTROY, widget_on_ungrab_keys, widget);\n          wm->widget_grab_key = widget;\n        }\n      }\n\n      if (strncmp(name, STR_ON_EVENT_PREFIX, sizeof(STR_ON_EVENT_PREFIX) - 1) == 0) {\n        int32_t etype = event_from_name(name + sizeof(STR_ON_EVENT_PREFIX) - 1);\n        if (etype != EVT_NONE) {\n          char* code = tk_strdup(value_str(v));\n          if (code != NULL) {\n            name += sizeof(STR_ON_EVENT_PREFIX) - 1;\n            if (strncmp(name, STR_GLOBAL_EVENT_PREFIX, sizeof(STR_GLOBAL_EVENT_PREFIX) - 1) == 0) {\n              widget_t* wm = window_manager();\n              widget_on(wm, etype, widget_exec_code, code);\n              widget_on(wm, EVT_DESTROY, widget_free_code, code);\n            } else {\n              widget_on(widget, etype, widget_exec_code, code);\n              widget_on(widget, EVT_DESTROY, widget_free_code, code);\n            }\n            ret = RET_OK;\n          }\n        } else {\n          log_debug(\"not found event %s\\n\", name);\n        }\n      } else {\n        ret = tk_object_set_prop(widget->custom_props, name, v);\n      }\n    }\n  }\n\n  if (ret != RET_NOT_FOUND) {\n    e.e.type = EVT_PROP_CHANGED;\n    widget_dispatch(widget, (event_t*)&e);\n    widget_invalidate(widget, NULL);\n  }\n\n  return ret;\n}\n\nret_t widget_get_prop(widget_t* widget, const char* name, value_t* v) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    value_set_int32(v, widget->x);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    value_set_int32(v, widget->y);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    value_set_int32(v, widget->w);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    value_set_int32(v, widget->h);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    value_set_int32(v, widget->opacity);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    value_set_bool(v, widget->visible);\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    value_set_bool(v, widget->sensitive);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    value_set_bool(v, widget->floating);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    value_set_bool(v, widget_is_focusable(widget));\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSED)) {\n    value_set_bool(v, widget->focused);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    value_set_bool(v, widget->with_focus_state);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    value_set_int(v, widget->dirty_rect_tolerance);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    value_set_str(v, widget->style);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    value_set_bool(v, widget->enable);\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    value_set_bool(v, widget->feedback);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    value_set_bool(v, widget->auto_adjust_size);\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    value_set_str(v, widget->name);\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    value_set_str(v, widget->animation);\n  } else if (tk_str_eq(name, WIDGET_PROP_POINTER_CURSOR)) {\n    value_set_str(v, widget->pointer_cursor);\n  } else if (tk_str_eq(name, WIDGET_PROP_LOADING)) {\n    value_set_bool(v, widget->loading);\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    if (widget->self_layout != NULL) {\n      value_set_str(v, self_layouter_to_string(widget->self_layout));\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  } else if (tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    if (widget->children_layout != NULL) {\n      value_set_str(v, children_layouter_to_string(widget->children_layout));\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  } else {\n    if (widget->vt->get_prop) {\n      ret = widget->vt->get_prop(widget, name, v);\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  }\n\n  /*default*/\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_LAYOUT_W)) {\n      value_set_int32(v, widget->w);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_LAYOUT_H)) {\n      value_set_int32(v, widget->h);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n      wchar_t* text = widget->text.str;\n      if (text != NULL) {\n        text[widget->text.size] = 0;\n      }\n      value_set_wstr(v, text);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_STATE_FOR_STYLE)) {\n      value_set_str(v, widget_get_state_for_style(widget, FALSE, FALSE));\n      ret = RET_OK;\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (widget->custom_props != NULL) {\n      ret = tk_object_get_prop(widget->custom_props, name, v);\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_TYPE)) {\n      value_set_str(v, widget->vt->type);\n      ret = RET_OK;\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_set_prop_str(widget_t* widget, const char* name, const char* str) {\n  value_t v;\n  value_set_str(&v, str);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nconst char* widget_get_prop_str(widget_t* widget, const char* name, const char* defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_str(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_pointer(widget_t* widget, const char* name, void* pointer) {\n  value_t v;\n  value_set_pointer(&v, pointer);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nvoid* widget_get_prop_pointer(widget_t* widget, const char* name) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_pointer(&v);\n  } else {\n    return NULL;\n  }\n}\n\nret_t widget_set_prop_float(widget_t* widget, const char* name, float_t num) {\n  value_t v;\n  value_set_float32(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nfloat_t widget_get_prop_float(widget_t* widget, const char* name, float_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_float32(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_int(widget_t* widget, const char* name, int32_t num) {\n  value_t v;\n  value_set_int(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nint32_t widget_get_prop_int(widget_t* widget, const char* name, int32_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_int(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_bool(widget_t* widget, const char* name, bool_t num) {\n  value_t v;\n  value_set_bool(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nbool_t widget_get_prop_bool(widget_t* widget, const char* name, bool_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_bool(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_on_paint_background(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_background) {\n    ret = widget->vt->on_paint_background(widget, c);\n  } else {\n    if (style_is_valid(widget->astyle)) {\n      widget_draw_background(widget, c);\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_self(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_self) {\n    ret = widget->vt->on_paint_self(widget, c);\n  } else {\n    paint_event_t e;\n    widget_dispatch(widget, paint_event_init(&e, EVT_PAINT, widget, c));\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_children(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_children) {\n    ret = widget->vt->on_paint_children(widget, c);\n  } else {\n    ret = widget_on_paint_children_default(widget, c);\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_border(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_border) {\n    ret = widget->vt->on_paint_border(widget, c);\n  } else {\n    if (style_is_valid(widget->astyle)) {\n      ret = widget_draw_border(widget, c);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_begin(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_begin) {\n    ret = widget->vt->on_paint_begin(widget, c);\n  }\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_BEFORE_PAINT, widget, c));\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_done(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_PAINT_DONE, widget, c));\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_end(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_end) {\n    ret = widget->vt->on_paint_end(widget, c);\n  }\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_AFTER_PAINT, widget, c));\n\n  return ret;\n}\n\nret_t widget_dispatch_to_target(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  e->target = widget;\n  widget_dispatch(widget, e);\n\n  if (widget->target) {\n    ret = widget_dispatch_to_target(widget->target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_map_key(widget_t* widget, key_event_t* e) {\n  value_t v;\n  const key_type_value_t* kv = NULL;\n\n  if (widget->custom_props != NULL) {\n    kv = keys_type_find_by_value(e->key);\n    if (kv != NULL) {\n      const char* to = NULL;\n      char from[TK_NAME_LEN + 1] = {0};\n      char fixed_name[TK_NAME_LEN + 1];\n\n      tk_snprintf(from, sizeof(from), \"map_key:%s\", kv->name);\n      if (tk_object_get_prop(widget->custom_props, from, &v) == RET_OK) {\n        to = value_str(&v);\n      } else if (strlen(kv->name) > 1) {\n        tk_strcpy(fixed_name, kv->name);\n        tk_str_tolower(fixed_name);\n        tk_snprintf(from, sizeof(from), \"map_key:%s\", fixed_name);\n        if (tk_object_get_prop(widget->custom_props, from, &v) == RET_OK) {\n          to = value_str(&v);\n        }\n      }\n\n      if (to != NULL) {\n        kv = keys_type_find(to);\n        if (kv != NULL) {\n          e->key = kv->value;\n          log_debug(\"map key %s to %s\\n\", from, to);\n        }\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_dispatch_to_key_target(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  e->target = widget;\n  widget_dispatch(widget, e);\n\n  if (widget->key_target) {\n    ret = widget_dispatch_to_target(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_before_children(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    key_event_t before = *e;\n    before.e.type = EVT_KEY_DOWN_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_keydown_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_keydown(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_after_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_keydown) {\n    ret = widget->vt->on_keydown(widget, e);\n  }\n\n  return ret;\n}\n\nbool_t widget_is_activate_key(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL && e != NULL, FALSE);\n\n  return (widget->vt->space_key_to_activate && e->key == TK_KEY_SPACE) ||\n         (widget->vt->return_key_to_activate && key_code_is_enter(e->key));\n}\n\nstatic bool_t shortcut_fast_match(const char* shortcut, key_event_t* e) {\n  uint32_t key = e->key;\n  const char* kname = strrchr(shortcut, '+');\n  bool_t cmd = strstr(shortcut, \"cmd\") != NULL;\n  bool_t ctrl = strstr(shortcut, \"ctrl\") != NULL;\n  bool_t shift = strstr(shortcut, \"shift\") != NULL;\n  const key_type_value_t* kv = keys_type_find_by_value(key);\n\n  if (kv != NULL) {\n    if (kname == NULL) {\n      kname = shortcut;\n    } else {\n      kname++;\n    }\n\n    if (tk_str_ieq(kname, kv->name) && cmd == e->cmd && ctrl == e->ctrl && shift == e->shift) {\n      return TRUE;\n    }\n  }\n\n  return FALSE;\n}\n\nstatic bool_t widget_match_key(widget_t* widget, const char* prop, key_event_t* e) {\n  const char* shortcut = NULL;\n  widget_t* win = widget_get_window(widget);\n\n  if (widget_is_window_manager(widget)) {\n    return FALSE;\n  }\n\n  return_value_if_fail(win != NULL, FALSE);\n  shortcut = widget_get_prop_str(win, prop, NULL);\n\n  if (shortcut != NULL) {\n    return shortcut_fast_match(shortcut, e);\n  }\n\n  return FALSE;\n}\n\nstatic bool_t widget_is_move_focus_prev_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_PREV_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_next_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_NEXT_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_up_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_UP_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_down_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_DOWN_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_left_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_LEFT_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_right_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_RIGHT_KEY, e);\n}\n\nbool_t widget_is_change_focus_key(widget_t* widget, key_event_t* e) {\n  return widget_is_move_focus_prev_key(widget, e) || widget_is_move_focus_next_key(widget, e) ||\n         widget_is_move_focus_up_key(widget, e) || widget_is_move_focus_down_key(widget, e) ||\n         widget_is_move_focus_left_key(widget, e) || widget_is_move_focus_right_key(widget, e);\n}\n\nstatic ret_t widget_on_keydown_general(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  if (!widget_is_window_manager(widget)) {\n    if (widget_is_activate_key(widget, e)) {\n      ret = RET_STOP;\n      widget_set_state(widget, WIDGET_STATE_PRESSED);\n    } else if (widget_is_move_focus_next_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_next(widget);\n      } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n        ret = RET_STOP;\n        widget_focus_first(widget);\n      }\n    } else if (widget_is_move_focus_prev_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_prev(widget);\n      } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n        ret = RET_STOP;\n        widget_focus_first(widget);\n      }\n    } else if (widget_is_move_focus_up_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_up(widget);\n      }\n    } else if (widget_is_move_focus_down_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_down(widget);\n      }\n    } else if (widget_is_move_focus_left_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_left(widget);\n      }\n    } else if (widget_is_move_focus_right_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_right(widget);\n      }\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_impl(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_keydown_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keydown_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keydown_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_keydown(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  uint32_t key = e->key;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  widget_map_key(widget, e);\n  if (e->e.type == EVT_KEY_DOWN) {\n    ret = widget_on_keydown_impl(widget, e);\n    if (widget->feedback) {\n      ui_feedback_request(widget, (event_t*)e);\n    }\n\n    e->key = key;\n    if (ret != RET_STOP) {\n      ret = widget_on_keydown_general(widget, e);\n    }\n  } else if (e->e.type == EVT_KEY_LONG_PRESS) {\n    return_value_if_equal(widget_on_keydown_children(widget, e), RET_STOP);\n    ret = widget_on_keydown_after_children(widget, e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_before_children(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    key_event_t before = *e;\n    before.e.type = EVT_KEY_UP_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_keyup_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_keyup(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_after_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_keyup) {\n    ret = widget->vt->on_keyup(widget, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_impl(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_keyup_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keyup_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keyup_after_children(widget, e), RET_STOP);\n\n  if (widget_is_activate_key(widget, e)) {\n    pointer_event_t click;\n    if (widget_is_focusable(widget)) {\n      widget_set_state(widget, WIDGET_STATE_FOCUSED);\n    } else {\n      widget_set_state(widget, WIDGET_STATE_NORMAL);\n    }\n    widget_dispatch_async(widget, pointer_event_init(&click, EVT_CLICK, widget, 0, 0));\n\n    ret = RET_STOP;\n  } else if (widget_is_move_focus_next_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_prev_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_up_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_down_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_left_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_right_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_on_keyup(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  uint32_t key = e->key;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  widget_map_key(widget, e);\n  ret = widget_on_keyup_impl(widget, e);\n  if (widget->feedback) {\n    ui_feedback_request(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  e->key = key;\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_before_children(widget_t* widget, wheel_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    wheel_event_t before = *e;\n    before.e.type = EVT_WHEEL_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_wheel_children(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_wheel(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_after_children(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_wheel) {\n    ret = widget->vt->on_wheel(widget, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_impl(widget_t* widget, wheel_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_wheel_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_wheel_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_wheel_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_wheel(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_wheel_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}\n\nret_t widget_on_multi_gesture(widget_t* widget, multi_gesture_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\n    ret = widget_dispatch(target, (event_t*)e);\n  }\n\n  if (ret != RET_STOP) {\n    ret = widget_dispatch(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_dispatch_leave_event(widget_t* widget, pointer_event_t* e) {\n  widget_t* target = widget;\n\n  while (target != NULL) {\n    widget_t* curr = target;\n    pointer_event_t leave = *e;\n    leave.e.type = EVT_POINTER_LEAVE;\n\n    widget_dispatch(target, (event_t*)(&leave));\n    target = curr->target;\n    curr->target = NULL;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_dispatch_blur_event(widget_t* widget) {\n  widget_t* target = widget;\n  widget_t* temp;\n\n  while (target != NULL) {\n    widget_ref(target);\n    if (target->focused) {\n      target->focused = FALSE;\n      event_t e = event_init(EVT_BLUR, target);\n      widget_dispatch(target, &e);\n      widget_set_need_update_style(target);\n    }\n\n    if (target->parent && target->parent->key_target == target) {\n      target->parent->key_target = NULL;\n    }\n\n    temp = target->key_target;\n    widget_unref(target);\n    target = temp;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_dispatch_event_to_target_recursive(widget_t* widget, event_t* e) {\n  widget_t* target = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  target = widget->grab_widget ? widget->grab_widget : widget->target;\n  while (target != NULL) {\n    widget_dispatch(target, e);\n    target = target->target != NULL ? target->target : target->key_target;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_on_pointer_down_before_children(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    pointer_event_t before = *e;\n    before.e.type = EVT_POINTER_DOWN_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nret_t widget_on_pointer_down_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n\n  if (target != NULL && target->enable && target->sensitive) {\n    if (!(widget_is_keyboard(target))) {\n      if (widget_is_focusable(target) || !widget_is_strongly_focus(widget)) {\n        if (!target->focused) {\n          widget_set_focused_internal(target, TRUE);\n        } else {\n          widget->key_target = target;\n        }\n      }\n    }\n  } else if (widget->key_target && !widget_is_strongly_focus(widget)) {\n    widget_set_focused_internal(widget->key_target, FALSE);\n  }\n  return_value_if_equal(ret, RET_STOP);\n\n  if (widget->target != target) {\n    if (widget->target != NULL) {\n      widget_dispatch_leave_event(widget->target, e);\n    }\n    widget->target = target;\n  }\n\n  if (widget->target != NULL) {\n    ret = widget_on_pointer_down(widget->target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_down_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_pointer_down) {\n    return_value_if_equal(ret = widget->vt->on_pointer_down(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_down_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  widget->grab_widget = NULL;\n  widget->grab_widget_count = 0;\n  return_value_if_equal(widget_on_pointer_down_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_pointer_down_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_pointer_down_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_pointer_down(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_pointer_down_impl(widget, e);\n  if (widget->feedback) {\n    ui_feedback_request(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_move_before_children(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    pointer_event_t before = *e;\n    before.e.type = EVT_POINTER_MOVE_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nret_t widget_on_pointer_move_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n\n  if (target != widget->target) {\n    if (widget->target != NULL) {\n      widget_dispatch_leave_event(widget->target, e);\n    }\n\n    if (target != NULL) {\n      pointer_event_t enter = *e;\n      enter.e.type = EVT_POINTER_ENTER;\n      ret = widget_dispatch(target, (event_t*)(&enter));\n      widget_update_pointer_cursor(target);\n    } else {\n      widget_update_pointer_cursor(widget);\n    }\n\n    widget->target = target;\n  }\n  return_value_if_equal(ret, RET_STOP);\n\n  if (widget->target != NULL) {\n    ret = widget_on_pointer_move(widget->target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_move_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_pointer_move) {\n    return_value_if_equal(ret = widget->vt->on_pointer_move(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_move_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_pointer_move_before_children(widget, e), RET_STOP);\n  if (widget_on_pointer_move_children(widget, e) == RET_STOP) {\n    if (e->pressed) {\n      pointer_event_t abort;\n      pointer_event_init(&abort, EVT_POINTER_DOWN_ABORT, widget, e->x, e->y);\n      return_value_if_equal(widget_on_pointer_move_after_children(widget, &abort), RET_STOP);\n    }\n\n    return RET_STOP;\n  } else {\n    return widget_on_pointer_move_after_children(widget, e);\n  }\n}\n\nret_t widget_on_pointer_move(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_pointer_move_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_up_before_children(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    pointer_event_t before = *e;\n    before.e.type = EVT_POINTER_UP_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nret_t widget_on_pointer_up_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\n    ret = widget_on_pointer_up(target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_up_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_pointer_up) {\n    return_value_if_equal(ret = widget->vt->on_pointer_up(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_up_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_pointer_up_before_children(widget, e), RET_STOP);\n  if (widget_on_pointer_up_children(widget, e) == RET_STOP) {\n    if (e->pressed) {\n      pointer_event_t abort;\n      pointer_event_init(&abort, EVT_POINTER_DOWN_ABORT, widget, e->x, e->y);\n      return_value_if_equal(widget_on_pointer_up_after_children(widget, &abort), RET_STOP);\n    }\n\n    return RET_STOP;\n  } else {\n    return widget_on_pointer_up_after_children(widget, e);\n  }\n}\n\nret_t widget_on_pointer_up(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_pointer_up_impl(widget, e);\n  if (widget->feedback) {\n    ui_feedback_request(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_context_menu_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\n    ret = widget_on_context_menu(target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_context_menu_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_context_menu) {\n    return_value_if_equal(ret = widget->vt->on_context_menu(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_context_menu_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget_on_context_menu_children(widget, e) == RET_STOP) {\n    return RET_STOP;\n  } else {\n    return widget_on_context_menu_after_children(widget, e);\n  }\n}\n\nret_t widget_on_context_menu(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_context_menu_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}\n\nret_t widget_grab(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->grab_widget == NULL || widget->grab_widget == child, RET_BAD_PARAMS);\n\n  if (widget->grab_widget == NULL) {\n    widget->grab_widget = child;\n    widget->grab_widget_count = 1;\n  } else {\n    widget->grab_widget_count++;\n  }\n\n  if (widget->parent) {\n    widget_grab(widget->parent, widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_ungrab(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->grab_widget == child) {\n    if (widget->grab_widget->grab_widget_count < widget->grab_widget_count) {\n      widget->grab_widget_count--;\n      if (widget->grab_widget_count <= 0) {\n        widget->grab_widget = NULL;\n        widget->grab_widget_count = 0;\n      }\n\n      if (widget->parent) {\n        widget_ungrab(widget->parent, widget);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_foreach(widget_t* widget, tk_visit_t visit, void* ctx) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && visit != NULL, RET_BAD_PARAMS);\n\n  ret = visit(ctx, widget);\n  if (ret != RET_OK) {\n    return ret;\n  }\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  ret = widget_foreach(iter, visit, ctx);\n  if (ret == RET_STOP || ret == RET_DONE) {\n    return ret;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return RET_OK;\n}\n\nwidget_t* widget_get_window(widget_t* widget) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, NULL);\n\n  while (iter) {\n    if (widget_is_window(iter)) {\n      return iter;\n    }\n    iter = iter->parent;\n  }\n\n  return NULL;\n}\n\nstatic widget_t* widget_get_window_or_keyboard(widget_t* widget) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, NULL);\n\n  while (iter) {\n    if (widget_is_window(iter) || widget_is_keyboard(iter)) {\n      return iter;\n    }\n    iter = iter->parent;\n  }\n\n  return NULL;\n}\n\nwidget_t* widget_get_window_manager(widget_t* widget) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, NULL);\n\n  while (iter) {\n    if (widget_is_window_manager(iter)) {\n      return iter;\n    }\n    iter = iter->parent;\n  }\n\n  return window_manager();\n}\n\nuint32_t widget_add_timer(widget_t* widget, timer_func_t on_timer, uint32_t duration_ms) {\n  return_value_if_fail(widget != NULL && on_timer != NULL, TK_INVALID_ID);\n  return timer_add_with_type(on_timer, widget, duration_ms, TIMER_INFO_WIDGET_ADD);\n}\n\nret_t widget_remove_timer(widget_t* widget, uint32_t timer_id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return timer_remove(timer_id);\n}\n\nuint32_t widget_add_idle(widget_t* widget, idle_func_t on_idle) {\n  return_value_if_fail(widget != NULL && on_idle != NULL, TK_INVALID_ID);\n  return idle_add_with_type(on_idle, widget, IDLE_INFO_WIDGET_ADD);\n}\n\nret_t widget_remove_idle(widget_t* widget, uint32_t idle_id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return idle_remove(idle_id);\n}\n\nret_t widget_destroy_sync(widget_t* widget) {\n  event_t e = event_init(EVT_DESTROY, widget);\n  return_value_if_fail(widget != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n\n#ifndef WITHOUT_WIDGET_ANIMATORS\n  widget_destroy_animator(widget, NULL);\n#endif /*WITHOUT_WIDGET_ANIMATORS*/\n\n  widget->destroying = TRUE;\n  idle_remove_all_by_ctx_and_type(IDLE_INFO_WIDGET_ADD, widget);\n  timer_remove_all_by_ctx_and_type(TIMER_INFO_WIDGET_ADD, widget);\n\n  if (widget->emitter != NULL) {\n    widget_dispatch(widget, &e);\n    emitter_destroy(widget->emitter);\n    widget->emitter = NULL;\n  }\n\n  if (widget->children != NULL) {\n    widget_destroy_children(widget);\n    darray_destroy(widget->children);\n    widget->children = NULL;\n  }\n\n  if (widget->children_layout != NULL) {\n    children_layouter_destroy(widget->children_layout);\n    widget->children_layout = NULL;\n  }\n\n  if (widget->self_layout != NULL) {\n    self_layouter_destroy(widget->self_layout);\n    widget->self_layout = NULL;\n  }\n\n  widget->destroying = FALSE;\n\n  return widget_real_destroy(widget);\n}\n\nwidget_t* widget_create(widget_t* parent, const widget_vtable_t* vt, xy_t x, xy_t y, wh_t w,\n                        wh_t h) {\n  return_value_if_fail(vt != NULL, NULL);\n\n  return widget_init(widget_real_create(vt), parent, vt, x, y, w, h);\n}\n\nret_t widget_destroy(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->ref_count > 0 && widget->vt != NULL,\n                       RET_BAD_PARAMS);\n\n  if (widget->parent != NULL) {\n    widget_remove_child(widget->parent, widget);\n  }\n\n  return widget_unref_async(widget);\n}\n\nstatic ret_t widget_destroy_on_idle(const idle_info_t* info) {\n  widget_destroy(WIDGET(info->ctx));\n\n  return RET_REMOVE;\n}\n\nret_t widget_destroy_async(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->ref_count > 0 && widget->vt != NULL,\n                       RET_BAD_PARAMS);\n\n  return_value_if_fail(idle_add(widget_destroy_on_idle, widget) != TK_INVALID_ID, RET_FAIL);\n\n  return RET_OK;\n}\n\nstatic ret_t widget_set_parent_not_dirty(widget_t* widget) {\n  widget_t* iter = widget->parent;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    iter->dirty = FALSE;\n    if (iter->vt->is_window) {\n      break;\n    }\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_invalidate(widget_t* widget, const rect_t* r) {\n  rect_t rself;\n  return_value_if_fail(widget != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->dirty) {\n    return RET_OK;\n  }\n\n  if (r == NULL) {\n    rself = rect_init(0, 0, widget->w, widget->h);\n    r = &rself;\n  }\n\n  widget->dirty = TRUE;\n  widget_set_parent_not_dirty(widget);\n\n  if (widget->vt && widget->vt->invalidate) {\n    return widget->vt->invalidate(widget, r);\n  } else {\n    return widget_invalidate_default(widget, r);\n  }\n}\n\nret_t widget_invalidate_force(widget_t* widget, const rect_t* r) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->dirty = FALSE;\n  return widget_invalidate(widget, r);\n}\n\nwidget_t* widget_init(widget_t* widget, widget_t* parent, const widget_vtable_t* vt, xy_t x, xy_t y,\n                      wh_t w, wh_t h) {\n  return_value_if_fail(widget != NULL && vt != NULL, NULL);\n\n  widget->x = x;\n  widget->y = y;\n  widget->w = w;\n  widget->h = h;\n  widget->vt = vt;\n  widget->dirty = TRUE;\n  widget->ref_count = 1;\n  widget->opacity = 0xff;\n  widget->enable = TRUE;\n  widget->visible = TRUE;\n  widget->feedback = FALSE;\n  widget->auto_adjust_size = FALSE;\n  widget->sensitive = TRUE;\n  widget->emitter = NULL;\n  widget->children = NULL;\n  widget->initializing = TRUE;\n  widget->state = tk_strdup(WIDGET_STATE_NORMAL);\n  widget->target = NULL;\n  widget->key_target = NULL;\n  widget->grab_widget = NULL;\n  widget->grab_widget_count = 0;\n  widget->focused = FALSE;\n  widget->focusable = FALSE;\n  widget->with_focus_state = FALSE;\n  widget->dirty_rect_tolerance = 4;\n  widget->need_update_style = TRUE;\n\n  if (parent) {\n    widget_add_child(parent, widget);\n  }\n\n  wstr_init(&(widget->text), 0);\n  if (!widget->vt) {\n    widget->vt = widget_vtable_default();\n  }\n\n  if (widget->astyle == NULL &&\n      (widget_is_window_manager(widget) || widget_get_window(widget) != NULL)) {\n    widget->astyle = style_factory_create_style(style_factory(), widget_get_style_type(widget));\n    ENSURE(widget->astyle != NULL);\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  }\n\n  widget_invalidate_force(widget, NULL);\n\n  widget->initializing = FALSE;\n\n  return widget;\n}\n\nret_t widget_get_prop_default_value(widget_t* widget, const char* name, value_t* v) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    value_set_int32(v, 0xff);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    value_set_int(v, 4);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n    value_set_wstr(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSED)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    value_set_bool(v, FALSE);\n  } else {\n    if (widget->vt->get_prop_default_value) {\n      ret = widget->vt->get_prop_default_value(widget, name, v);\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_get_offset(widget_t* widget, xy_t* out_x, xy_t* out_y) {\n  return_value_if_fail(widget != NULL && out_x != NULL && out_y != NULL, RET_BAD_PARAMS);\n  *out_x = 0;\n  *out_y = 0;\n  if (widget->vt != NULL && widget->vt->get_offset != NULL) {\n    return widget->vt->get_offset(widget, out_x, out_y);\n  }\n  return RET_OK;\n}\n\nret_t widget_to_screen_ex(widget_t* widget, widget_t* parent, point_t* p) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL && p != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL && iter != parent) {\n    xy_t offset_x, offset_y;\n    if (widget_get_offset(iter, &offset_x, &offset_y) == RET_OK) {\n      p->x -= offset_x;\n      p->y -= offset_y;\n    }\n\n    p->x += iter->x;\n    p->y += iter->y;\n\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_to_screen(widget_t* widget, point_t* p) {\n  return widget_to_screen_ex(widget, NULL, p);\n}\n\nret_t widget_to_local(widget_t* widget, point_t* p) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL && p != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    xy_t offset_x = 0;\n    xy_t offset_y = 0;\n    if (widget_get_offset(iter, &offset_x, &offset_y) == RET_OK) {\n      p->x += offset_x;\n      p->y += offset_y;\n    }\n\n    p->x -= iter->x;\n    p->y -= iter->y;\n\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_to_global(widget_t* widget, point_t* p) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL && p != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    p->x += iter->x;\n    p->y += iter->y;\n\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nint32_t widget_count_children(widget_t* widget) {\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget->children != NULL ? widget->children->size : 0;\n}\n\nwidget_t* widget_get_child(widget_t* widget, int32_t index) {\n  return_value_if_fail(widget != NULL, NULL);\n  if (widget->children == NULL || index >= widget->children->size) {\n    return NULL;\n  }\n\n  return WIDGET(widget->children->elms[index]);\n}\n\nint32_t widget_index_of(widget_t* widget) {\n  widget_t* parent = NULL;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, -1);\n\n  parent = widget->parent;\n  WIDGET_FOR_EACH_CHILD_BEGIN(parent, iter, i)\n  if (iter == widget) {\n    return i;\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return -1;\n}\n\nret_t widget_prepare_text_style_ex(widget_t* widget, canvas_t* c, color_t default_trans,\n                                   const char* default_font, uint16_t default_font_size,\n                                   align_h_t default_align_h, align_v_t default_align_v) {\n  style_t* style = widget->astyle;\n  color_t tc = style_get_color(style, STYLE_ID_TEXT_COLOR, default_trans);\n  const char* font_name = style_get_str(style, STYLE_ID_FONT_NAME, default_font);\n  uint16_t font_size = style_get_int(style, STYLE_ID_FONT_SIZE, default_font_size);\n  align_h_t align_h = (align_h_t)style_get_int(style, STYLE_ID_TEXT_ALIGN_H, default_align_h);\n  align_v_t align_v = (align_v_t)style_get_int(style, STYLE_ID_TEXT_ALIGN_V, default_align_v);\n\n  canvas_set_text_color(c, tc);\n  canvas_set_font(c, font_name, font_size);\n  canvas_set_text_align(c, align_h, align_v);\n\n  return RET_OK;\n}\n\nret_t widget_prepare_text_style(widget_t* widget, canvas_t* c) {\n  color_t trans = color_init(0, 0, 0, 0);\n  return widget_prepare_text_style_ex(widget, c, trans, NULL, TK_DEFAULT_FONT_SIZE, ALIGN_H_CENTER,\n                                      ALIGN_V_MIDDLE);\n}\n\nstatic ret_t widget_copy_style(widget_t* clone, widget_t* widget) {\n  if (style_is_mutable(widget->astyle) && style_mutable_cast(widget->astyle) != NULL) {\n    if (!style_is_mutable(clone->astyle)) {\n      widget_ensure_style_mutable(clone);\n    }\n\n    if (style_mutable_cast(clone->astyle) != NULL) {\n      style_mutable_copy(clone->astyle, widget->astyle);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic const char* const s_widget_persistent_props[] = {WIDGET_PROP_NAME,\n                                                        WIDGET_PROP_STYLE,\n                                                        WIDGET_PROP_TR_TEXT,\n                                                        WIDGET_PROP_TEXT,\n                                                        WIDGET_PROP_ANIMATION,\n                                                        WIDGET_PROP_ENABLE,\n                                                        WIDGET_PROP_VISIBLE,\n                                                        WIDGET_PROP_FLOATING,\n                                                        WIDGET_PROP_CHILDREN_LAYOUT,\n                                                        WIDGET_PROP_SELF_LAYOUT,\n                                                        WIDGET_PROP_OPACITY,\n                                                        WIDGET_PROP_FOCUSED,\n                                                        WIDGET_PROP_FEEDBACK,\n                                                        WIDGET_PROP_AUTO_ADJUST_SIZE,\n                                                        WIDGET_PROP_FOCUSABLE,\n                                                        WIDGET_PROP_SENSITIVE,\n                                                        WIDGET_PROP_WITH_FOCUS_STATE,\n                                                        NULL};\n\nconst char* const* widget_get_persistent_props(void) {\n  return s_widget_persistent_props;\n}\n\nstatic ret_t widget_copy_base_props(widget_t* widget, widget_t* other) {\n  widget->state = tk_str_copy(widget->state, other->state);\n  widget->name = tk_str_copy(widget->name, other->name);\n  widget->style = tk_str_copy(widget->style, other->style);\n\n  if (other->text.str != NULL) {\n    widget_set_text(widget, other->text.str);\n  }\n\n  if (other->tr_text != NULL) {\n    widget_set_tr_text(widget, other->tr_text);\n  }\n\n  widget->enable = other->enable;\n  widget->visible = other->visible;\n  widget->floating = other->floating;\n  widget->opacity = other->opacity;\n  widget->feedback = other->feedback;\n  widget->auto_adjust_size = other->auto_adjust_size;\n  widget->focusable = other->focusable;\n  widget->sensitive = other->sensitive;\n  widget->auto_created = other->auto_created;\n  widget->with_focus_state = other->with_focus_state;\n  widget->dirty_rect_tolerance = other->dirty_rect_tolerance;\n\n  if (other->animation != NULL && *(other->animation)) {\n    widget_set_animation(widget, other->animation);\n  }\n\n  if (other->self_layout != NULL) {\n    widget->self_layout = self_layouter_clone(other->self_layout);\n  }\n\n  if (other->children_layout != NULL) {\n    widget->children_layout = children_layouter_clone(other->children_layout);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_copy(widget_t* widget, widget_t* other) {\n  return_value_if_fail(widget != NULL && other != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt == other->vt, RET_BAD_PARAMS);\n\n  widget_copy_style(widget, other);\n  widget_copy_base_props(widget, other);\n\n  if (other->custom_props) {\n    widget->custom_props = object_default_clone(OBJECT_DEFAULT(other->custom_props));\n  }\n\n  if (widget->vt->on_copy != NULL) {\n    widget->vt->on_copy(widget, other);\n  } else {\n    widget_on_copy_default(widget, other);\n  }\n\n  widget_set_need_update_style(widget);\n\n  return RET_OK;\n}\n\nwidget_t* widget_clone(widget_t* widget, widget_t* parent) {\n  widget_t* clone = NULL;\n  return_value_if_fail(widget != NULL && widget->vt != NULL && widget->vt->create != NULL, NULL);\n\n  clone = widget->vt->create(parent, widget->x, widget->y, widget->w, widget->h);\n  return_value_if_fail(clone != NULL, NULL);\n\n  widget_copy(clone, widget);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_clone(iter, clone);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return clone;\n}\n\n#define PROP_EQ(prop) (widget->prop == other->prop)\nbool_t widget_equal(widget_t* widget, widget_t* other) {\n  bool_t ret = FALSE;\n  const char* const* properties = NULL;\n  return_value_if_fail(widget != NULL && other != NULL, FALSE);\n\n  ret = PROP_EQ(opacity) && PROP_EQ(enable) && PROP_EQ(visible) && PROP_EQ(vt) && PROP_EQ(x) &&\n        PROP_EQ(y) && PROP_EQ(w) && PROP_EQ(h) && PROP_EQ(floating);\n  if (widget->name != NULL || other->name != NULL) {\n    ret = ret && (tk_str_eq(widget->name, other->name) || PROP_EQ(name));\n  }\n\n  if (widget->style != NULL || other->style != NULL) {\n    ret = ret && tk_str_eq(widget->style, other->style);\n  }\n\n  if (!ret) {\n    return ret;\n  }\n\n  ret = ret && wstr_equal(&(widget->text), &(other->text));\n\n  if (widget->tr_text != NULL || other->tr_text != NULL) {\n    ret = ret && (tk_str_eq(widget->tr_text, other->tr_text) || PROP_EQ(tr_text));\n  }\n\n  if (!ret) {\n    return ret;\n  }\n\n  properties = widget->vt->clone_properties;\n  if (properties != NULL) {\n    value_t v1;\n    value_t v2;\n    uint32_t i = 0;\n    for (i = 0; properties[i] != NULL; i++) {\n      const char* prop = properties[i];\n      if (widget_get_prop(widget, prop, &v1) != RET_OK) {\n        continue;\n      }\n\n      if (widget_get_prop(other, prop, &v2) != RET_OK) {\n        return FALSE;\n      }\n\n      if (!value_equal(&v1, &v2)) {\n        log_debug(\"prop %s not equal\\n\", prop);\n        return FALSE;\n      }\n    }\n  }\n\n  if (widget->children_layout != other->children_layout) {\n    const char* str1 = children_layouter_to_string(widget->children_layout);\nconst char* str2 = ",
    "raw_res": "",
    "prompt_res": "children_layouter_to_string(other->children_layout);",
    "gt": "children_layouter_to_string(other->children_layout);"
  },
  {
    "id": 2492,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/widget.c",
    "input": "﻿/**\n * File:   widget.c\n * Author: AWTK Develop Team\n * Brief:  basic class of all widget\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-13 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/fscript.h\"\n#include \"tkc/tokenizer.h\"\n#include \"tkc/color_parser.h\"\n#include \"tkc/object_default.h\"\n\n#include \"base/keys.h\"\n#include \"base/enums.h\"\n#include \"base/theme.h\"\n#include \"tkc/time_now.h\"\n#include \"base/idle.h\"\n#include \"base/widget.h\"\n#include \"base/layout.h\"\n#include \"native_window.h\"\n#include \"base/main_loop.h\"\n#include \"base/ui_feedback.h\"\n#include \"base/system_info.h\"\n#include \"base/window_manager.h\"\n#include \"base/widget_vtable.h\"\n#include \"base/style_mutable.h\"\n#include \"base/style_factory.h\"\n#include \"base/widget_animator_manager.h\"\n#include \"base/widget_animator_factory.h\"\n#include \"base/window_base.h\"\n#include \"blend/image_g2d.h\"\n\nret_t widget_focus_up(widget_t* widget);\nret_t widget_focus_down(widget_t* widget);\nret_t widget_focus_left(widget_t* widget);\nret_t widget_focus_right(widget_t* widget);\nstatic ret_t widget_unref_async(widget_t* widget);\nstatic ret_t widget_ensure_style_mutable(widget_t* widget);\nstatic ret_t widget_dispatch_blur_event(widget_t* widget);\n/*虚函数的包装*/\nstatic ret_t widget_on_paint_done(widget_t* widget, canvas_t* c);\nstatic ret_t widget_on_paint_begin(widget_t* widget, canvas_t* c);\nstatic ret_t widget_on_paint_end(widget_t* widget, canvas_t* c);\n\ntypedef widget_t* (*widget_find_wanted_focus_widget_t)(widget_t* widget, darray_t* all_focusable);\nstatic ret_t widget_move_focus(widget_t* widget, widget_find_wanted_focus_widget_t find);\n\n#define widget_set_xywh(widget, val, update_layout, invalidate)    \\\n  do {                                                             \\\n    if (widget->val != val) {                                      \\\n      if (invalidate) widget_invalidate_force(widget, NULL);       \\\n      widget->val = val;                                           \\\n      if (invalidate) widget_invalidate_force(widget, NULL);       \\\n    }                                                              \\\n    if (update_layout && widget->self_layout != NULL) {            \\\n      self_layouter_set_param_str(widget->self_layout, #val, \"n\"); \\\n    }                                                              \\\n  } while (0)\n\nstatic ret_t widget_set_x(widget_t* widget, xy_t x, bool_t update_layout) {\n  widget_set_xywh(widget, x, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_y(widget_t* widget, xy_t y, bool_t update_layout) {\n  widget_set_xywh(widget, y, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_w(widget_t* widget, wh_t w, bool_t update_layout) {\n  widget_set_xywh(widget, w, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_h(widget_t* widget, xy_t h, bool_t update_layout) {\n  widget_set_xywh(widget, h, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic bool_t widget_is_strongly_focus(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n  if (win != NULL) {\n    return WINDOW_BASE(win)->strongly_focus;\n  } else {\n    return FALSE;\n  }\n}\n\nret_t widget_set_need_update_style(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (!widget->need_update_style) {\n    widget_invalidate_force(widget, NULL);\n  }\n\n  widget->need_update_style = TRUE;\n\n  return RET_OK;\n}\n\nret_t widget_update_style_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_update_style(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_update_style_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_set_need_update_style_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_need_update_style(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_set_need_update_style_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_update_style(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->astyle != NULL, RET_BAD_PARAMS);\n\n  if (widget->need_update_style) {\n    widget->need_update_style = FALSE;\n    return style_notify_widget_state_changed(widget->astyle, widget);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_real_destroy(widget_t* widget) {\n  ENSURE(widget->ref_count == 1);\n\n  if (widget->vt->on_destroy) {\n    widget->vt->on_destroy(widget);\n  }\n\n  TKMEM_FREE(widget->name);\n  TKMEM_FREE(widget->state);\n  TKMEM_FREE(widget->style);\n  TKMEM_FREE(widget->tr_text);\n  TKMEM_FREE(widget->animation);\n  TKMEM_FREE(widget->pointer_cursor);\n  TK_OBJECT_UNREF(widget->custom_props);\n  wstr_reset(&(widget->text));\n  style_destroy(widget->astyle);\n\n  memset(widget, 0x00, sizeof(widget_t));\n  TKMEM_FREE(widget);\n\n  return RET_OK;\n}\n\nstatic widget_t* widget_real_create(const widget_vtable_t* vt) {\n  widget_t* widget = TKMEM_ALLOC(vt->size);\n  return_value_if_fail(widget != NULL, NULL);\n\n  memset(widget, 0x00, vt->size);\n  widget->vt = vt;\n\n  return widget;\n}\n\nstatic bool_t widget_is_scrollable(widget_t* widget) {\n  return widget != NULL && widget->vt != NULL && widget->vt->scrollable;\n}\n\nstatic bool_t widget_with_focus_state(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n  value_set_bool(&v, FALSE);\n  widget_get_prop(widget, WIDGET_PROP_WITH_FOCUS_STATE, &v);\n\n  return value_bool(&v);\n}\n\nbool_t widget_is_focusable(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  if (!widget->visible || !widget->sensitive || !widget->enable) {\n    return FALSE;\n  }\n\n  return widget->focusable || widget->vt->focusable;\n}\n\nret_t widget_move(widget_t* widget, xy_t x, xy_t y) {\n  event_t e = event_init(EVT_WILL_MOVE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->x != x || widget->y != y) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, x, TRUE, FALSE);\n    widget_set_xywh(widget, y, TRUE, FALSE);\n    widget_invalidate_force(widget, NULL);\n\n    e.type = EVT_MOVE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_to_center(widget_t* widget) {\n  int32_t x = 0;\n  int32_t y = 0;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, RET_BAD_PARAMS);\n\n  x = (widget->parent->w - widget->w) / 2;\n  y = (widget->parent->h - widget->h) / 2;\n\n  return widget_move(widget, x, y);\n}\n\nret_t widget_resize(widget_t* widget, wh_t w, wh_t h) {\n  event_t e = event_init(EVT_WILL_RESIZE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->w != w || widget->h != h) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, w, TRUE, FALSE);\n    widget_set_xywh(widget, h, TRUE, FALSE);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget);\n\n    e.type = EVT_RESIZE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_resize_ex(widget_t* widget, xy_t x, xy_t y, wh_t w, wh_t h,\n                            bool_t update_layout) {\n  event_t e = event_init(EVT_WILL_MOVE_RESIZE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->x != x || widget->y != y || widget->w != w || widget->h != h) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, x, update_layout, FALSE);\n    widget_set_xywh(widget, y, update_layout, FALSE);\n    widget_set_xywh(widget, w, update_layout, FALSE);\n    widget_set_xywh(widget, h, update_layout, FALSE);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget);\n\n    e.type = EVT_MOVE_RESIZE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_resize(widget_t* widget, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return widget_move_resize_ex(widget, x, y, w, h, TRUE);\n}\n\nfloat_t widget_get_value(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_VALUE, &v) == RET_OK ? value_float32(&v) : 0.0f;\n}\n\nret_t widget_set_value(widget_t* widget, float_t value) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_VALUE, value_set_float32(&v, value));\n}\n\nret_t widget_add_value(widget_t* widget, float_t delta) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_value(widget, widget_get_value(widget) + delta);\n}\n\nint32_t widget_get_value_int(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_VALUE, &v) == RET_OK ? value_int(&v) : 0;\n}\n\nret_t widget_set_value_int(widget_t* widget, int32_t value) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_VALUE, value_set_int(&v, value));\n}\n\nret_t widget_add_value_int(widget_t* widget, int32_t delta) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_value_int(widget, widget_get_value_int(widget) + delta);\n}\n\nstatic ret_t widget_animate_prop_float_to(widget_t* widget, const char* name, float_t value,\n                                          uint32_t duration) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL, RET_BAD_PARAMS);\n  if (duration == 0) {\n    ret = widget_set_prop_float(widget, name, value);\n  } else {\n    float_t prev_value = widget_get_prop_float(widget, name, 0.0f);\n    widget_destroy_animator(widget, name);\n\n    if (prev_value != value) {\n      char params[128] = {0};\n      tk_snprintf(params, sizeof(params) - 1, \"%s(from=%f,to=%f,duration=%d)\", name, prev_value,\n                  value, duration);\n      ret = widget_create_animator(widget, params);\n    }\n  }\n  return ret;\n}\n\nret_t widget_animate_value_to(widget_t* widget, float_t value, uint32_t duration) {\n  return widget_animate_prop_float_to(widget, WIDGET_PROP_VALUE, value, duration);\n}\n\nbool_t widget_is_window_opened(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n    return WINDOW_STAGE_OPENED == stage || WINDOW_STAGE_SUSPEND == stage;\n  } else {\n    return FALSE;\n  }\n}\n\nbool_t widget_is_window_created(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n    return WINDOW_STAGE_OPENED == stage || WINDOW_STAGE_SUSPEND == stage ||\n           WINDOW_STAGE_LOADED == stage || WINDOW_STAGE_CREATED == stage;\n  } else {\n    return FALSE;\n  }\n}\n\nret_t widget_get_window_theme(widget_t* widget, theme_t** win_theme, theme_t** default_theme) {\n  value_t v;\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    if (widget_get_prop(win, WIDGET_PROP_THEME_OBJ, &v) == RET_OK) {\n      *win_theme = (theme_t*)value_pointer(&v);\n    }\n\n    if (widget_get_prop(win, WIDGET_PROP_DEFAULT_THEME_OBJ, &v) == RET_OK) {\n      *default_theme = (theme_t*)value_pointer(&v);\n    }\n  }\n  return RET_OK;\n}\n\nbool_t widget_is_style_exist(widget_t* widget, const char* style_name, const char* state_name) {\n  const void* data = NULL;\n  const char* style = NULL;\n  const char* state = NULL;\n  theme_t* win_theme = NULL;\n  theme_t* default_theme = NULL;\n  const char* type = widget_get_type(widget);\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(widget != NULL && win != NULL, FALSE);\n\n  if (style_name == NULL || *style_name == 0) {\n    style = TK_DEFAULT_STYLE;\n  } else {\n    style = style_name;\n  }\n\n  if (state_name == NULL || *state_name == 0) {\n    state = WIDGET_STATE_NORMAL;\n  } else {\n    state = state_name;\n  }\n\n  return_value_if_fail(widget_get_window_theme(widget, &win_theme, &default_theme) == RET_OK,\n                       FALSE);\n\n  if (win_theme != NULL) {\n    data = theme_find_style(win_theme, type, style, state);\n  }\n\n  if (data == NULL && default_theme != NULL) {\n    data = theme_find_style(default_theme, type, style, state);\n  }\n\n  return data != NULL;\n}\n\nret_t widget_use_style(widget_t* widget, const char* value) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_need_update_style(widget);\n  widget->style = tk_str_copy(widget->style, value);\n\n  if (widget_is_window_opened(widget)) {\n    widget_update_style(widget);\n    return widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_text(widget_t* widget, const wchar_t* text) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_wstr(&v, text));\n}\n\nret_t widget_set_text_utf8(widget_t* widget, const char* text) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_str(&v, text));\n}\n\nret_t widget_get_text_utf8(widget_t* widget, char* text, uint32_t size) {\n  value_t v;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && text != NULL && size > 0, RET_BAD_PARAMS);\n\n  value_set_str(&v, NULL);\n  memset(text, 0x00, size);\n  if (widget_get_prop(widget, WIDGET_PROP_TEXT, &v) == RET_OK) {\n    if (v.type == VALUE_TYPE_STRING) {\n      tk_strncpy(text, value_str(&v), size - 1);\n      ret = RET_OK;\n    } else if (v.type == VALUE_TYPE_WSTRING) {\n      tk_utf8_from_utf16(value_wstr(&v), text, size);\n      ret = RET_OK;\n    }\n  }\n\n  return ret;\n}\n\nimage_manager_t* widget_get_image_manager(widget_t* widget) {\n  image_manager_t* ret = image_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = image_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_IMAGE_MANAGER, &v) == RET_OK) {\n      ret = (image_manager_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nlocale_info_t* widget_get_locale_info(widget_t* widget) {\n  locale_info_t* ret = locale_info();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = locale_info();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_LOCALE_INFO, &v) == RET_OK) {\n      ret = (locale_info_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nassets_manager_t* widget_get_assets_manager(widget_t* widget) {\n  assets_manager_t* am = assets_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, am);\n\n  if (widget->assets_manager != NULL) {\n    return widget->assets_manager;\n  }\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    am = assets_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_ASSETS_MANAGER, &v) == RET_OK) {\n      am = (assets_manager_t*)value_pointer(&v);\n    }\n  }\n  widget->assets_manager = am;\n\n  return am;\n}\n\nfont_manager_t* widget_get_font_manager(widget_t* widget) {\n  font_manager_t* ret = font_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = font_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_FONT_MANAGER, &v) == RET_OK) {\n      ret = (font_manager_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_apply_tr_text_before_paint(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  if (widget->tr_text != NULL) {\n    const char* text = locale_info_tr(widget_get_locale_info(widget), widget->tr_text);\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n  }\n\n  return RET_REMOVE;\n}\n\nret_t widget_set_tr_text(widget_t* widget, const char* text) {\n  const char* tr_text = NULL;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(widget != NULL, RET_OK);\n\n  if (text == NULL || *text == '\\0') {\n    if (widget->tr_text != NULL) {\n      TKMEM_FREE(widget->tr_text);\n      widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n    }\n\n    return RET_OK;\n  }\n\n  widget->tr_text = tk_str_copy(widget->tr_text, text);\n  if (win != NULL) {\n    tr_text = locale_info_tr(widget_get_locale_info(widget), text);\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, tr_text);\n  } else {\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n    widget_on(widget, EVT_BEFORE_PAINT, widget_apply_tr_text_before_paint, widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_re_translate_text(widget_t* widget) {\n  if (widget->vt->on_re_translate != NULL) {\n    widget->vt->on_re_translate(widget);\n  }\n  if (widget->tr_text != NULL) {\n    value_t v;\n    const char* tr_text = locale_info_tr(widget_get_locale_info(widget), widget->tr_text);\n    widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_str(&v, tr_text));\n    widget_invalidate(widget, NULL);\n  }\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_re_translate_text(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nconst wchar_t* widget_get_text(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_TEXT, &v) == RET_OK ? value_wstr(&v) : 0;\n}\n\nret_t widget_set_name(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (name != NULL) {\n    widget->name = tk_str_copy(widget->name, name);\n  } else {\n    TKMEM_FREE(widget->name);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_theme(widget_t* widget, const char* name) {\n  theme_change_event_t will_event;\n  event_t* will_evt = theme_change_event_init(&will_event, EVT_THEME_WILL_CHANGE, name);\n  widget_dispatch(window_manager(), will_evt);\n#ifdef WITH_FS_RES\n  const asset_info_t* info = NULL;\n  theme_change_event_t event;\n  event_t* evt = theme_change_event_init(&event, EVT_THEME_CHANGED, name);\n  widget_t* wm = widget_get_window_manager(widget);\n  font_manager_t* fm = widget_get_font_manager(widget);\n  image_manager_t* imm = widget_get_image_manager(widget);\n  assets_manager_t* am = widget_get_assets_manager(widget);\n  locale_info_t* locale_info = widget_get_locale_info(widget);\n  return_value_if_fail(am != NULL && name != NULL, RET_BAD_PARAMS);\n\n  font_manager_unload_all(fm);\n  image_manager_unload_all(imm);\n  locale_info_reload(locale_info);\n  assets_manager_set_theme(am, name);\n  widget_reset_canvas(widget);\n\n  info = assets_manager_ref(am, ASSET_TYPE_STYLE, \"default\");\n  if (info != NULL) {\n    theme_set(theme_load_from_data(info->name, info->data, info->size));\n    assets_manager_unref(assets_manager(), info);\n  }\n\n  widget_dispatch(wm, evt);\n  widget_invalidate_force(wm, NULL);\n\n  log_debug(\"theme changed: %s\\n\", name);\n#endif\n\n  return RET_OK;\n}\n\nret_t widget_set_pointer_cursor(widget_t* widget, const char* cursor) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (!tk_str_eq(widget->pointer_cursor, cursor)) {\n    widget->pointer_cursor = tk_str_copy(widget->pointer_cursor, cursor);\n    widget_update_pointer_cursor(widget);\n  }\n\n  return RET_OK;\n}\n\n#ifndef WITHOUT_WIDGET_ANIMATORS\nret_t widget_set_animation(widget_t* widget, const char* animation) {\n  return_value_if_fail(widget != NULL && animation != NULL, RET_BAD_PARAMS);\n\n  widget->animation = tk_str_copy(widget->animation, animation);\n\n  return widget_create_animator(widget, animation);\n}\n\nret_t widget_create_animator(widget_t* widget, const char* animation) {\n  tokenizer_t t;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && animation != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(tokenizer_init(&t, animation, strlen(animation), \";\") != NULL, RET_OOM);\n\n  while (tokenizer_has_more(&t)) {\n    const char* params = tokenizer_next(&t);\n    if (widget_animator_create(widget, params) == NULL) {\n      ret = RET_BAD_PARAMS;\n      break;\n    }\n  }\n  tokenizer_deinit(&t);\n  widget_invalidate(widget, NULL);\n\n  return ret;\n}\n\nret_t widget_start_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_start(widget_animator_manager(), widget, name);\n}\n\nret_t widget_set_animator_time_scale(widget_t* widget, const char* name, float_t time_scale) {\n  return widget_animator_manager_set_time_scale(widget_animator_manager(), widget, name,\n                                                time_scale);\n}\n\nret_t widget_pause_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_pause(widget_animator_manager(), widget, name);\n}\n\nwidget_animator_t* widget_find_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_find(widget_animator_manager(), widget, name);\n}\n\nret_t widget_stop_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_stop(widget_animator_manager(), widget, name);\n}\n\nret_t widget_destroy_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_remove_all(widget_animator_manager(), widget, name);\n}\n#else\nret_t widget_start_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nret_t widget_create_animator(widget_t* widget, const char* animation) {\n  return RET_OK;\n}\nret_t widget_set_animation(widget_t* widget, const char* animation) {\n  return RET_OK;\n}\nret_t widget_set_animator_time_scale(widget_t* widget, const char* name, float_t time_scale) {\n  return RET_OK;\n}\nret_t widget_pause_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nwidget_animator_t* widget_find_animator(widget_t* widget, const char* name) {\n  return NULL;\n}\nret_t widget_stop_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nret_t widget_destroy_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\n#endif /*WITHOUT_WIDGET_ANIMATORS*/\n\nret_t widget_set_enable(widget_t* widget, bool_t enable) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->enable != enable) {\n    widget->enable = enable;\n    widget_set_need_update_style_recursive(widget);\n    widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_feedback(widget_t* widget, bool_t feedback) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->feedback = feedback;\n\n  return RET_OK;\n}\n\nret_t widget_set_auto_adjust_size(widget_t* widget, bool_t auto_adjust_size) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->auto_adjust_size = auto_adjust_size;\n  widget_set_need_relayout(widget);\n\n  return RET_OK;\n}\n\nret_t widget_set_floating(widget_t* widget, bool_t floating) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->floating = floating;\n\n  return RET_OK;\n}\n\nret_t widget_set_focused_internal(widget_t* widget, bool_t focused) {\n  widget_t* win = widget_get_window(widget);\n  int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (WINDOW_STAGE_SUSPEND == stage) {\n    log_debug(\"You can not set focus of a widget when window is in background\");\n    return RET_FAIL;\n  }\n\n  if (widget->focused != focused) {\n    widget->focused = focused;\n    widget_set_need_update_style(widget);\n\n    if (focused) {\n      event_t e = event_init(EVT_FOCUS, widget);\n      widget_set_as_key_target(widget);\n\n      widget_dispatch(widget, &e);\n    } else {\n      event_t e = event_init(EVT_BLUR, widget);\n      widget_dispatch(widget, &e);\n      widget_dispatch_blur_event(widget);\n    }\n\n    widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_focused(widget_t* widget, bool_t focused) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_focused_internal(widget, focused);\n  if (focused) {\n    widget_ensure_visible_in_viewport(widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_focusable(widget_t* widget, bool_t focusable) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->focusable = focusable;\n\n  return RET_OK;\n}\n\nret_t widget_set_state(widget_t* widget, const char* state) {\n  return_value_if_fail(widget != NULL && state != NULL, RET_BAD_PARAMS);\n\n  if (!tk_str_eq(widget->state, state)) {\n    widget_invalidate_force(widget, NULL);\n    widget->state = tk_str_copy(widget->state, state);\n    widget_set_need_update_style(widget);\n    widget_invalidate_force(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_state_for_style(widget_t* widget, bool_t active, bool_t checked) {\n  const char* state = WIDGET_STATE_NORMAL;\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, state);\n\n  state = (const char*)(widget->state);\n\n  while (iter != NULL) {\n    if (!iter->enable) {\n      if (active) return WIDGET_STATE_DISABLE_OF_ACTIVE;\n      if (checked) return WIDGET_STATE_DISABLE_OF_CHECKED;\n      return WIDGET_STATE_DISABLE;\n    }\n    iter = iter->parent;\n  }\n\n  if (widget_is_focusable(widget) || widget_with_focus_state(widget)) {\n    if (widget->focused) {\n      if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n        state = WIDGET_STATE_FOCUSED;\n      }\n    } else {\n      if (tk_str_eq(state, WIDGET_STATE_FOCUSED)) {\n        state = WIDGET_STATE_NORMAL;\n      }\n    }\n  }\n\n  if (active) {\n    if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n      state = WIDGET_STATE_NORMAL_OF_ACTIVE;\n    } else if (tk_str_eq(state, WIDGET_STATE_PRESSED)) {\n      state = WIDGET_STATE_PRESSED_OF_ACTIVE;\n    } else if (tk_str_eq(state, WIDGET_STATE_OVER)) {\n      state = WIDGET_STATE_OVER_OF_ACTIVE;\n    } else if (widget_is_focusable(widget) && widget->focused) {\n      state = WIDGET_STATE_FOCUSED_OF_ACTIVE;\n    }\n  } else if (checked) {\n    if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n      state = WIDGET_STATE_NORMAL_OF_CHECKED;\n    } else if (tk_str_eq(state, WIDGET_STATE_PRESSED)) {\n      state = WIDGET_STATE_PRESSED_OF_CHECKED;\n    } else if (tk_str_eq(state, WIDGET_STATE_OVER)) {\n      state = WIDGET_STATE_OVER_OF_CHECKED;\n    } else if (widget_is_focusable(widget) && widget->focused) {\n      state = WIDGET_STATE_FOCUSED_OF_CHECKED;\n    }\n  }\n\n  return state;\n}\n\nret_t widget_set_opacity(widget_t* widget, uint8_t opacity) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->opacity = opacity;\n  widget_invalidate(widget, NULL);\n\n  return RET_OK;\n}\n\nret_t widget_set_dirty_rect_tolerance(widget_t* widget, uint16_t dirty_rect_tolerance) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->dirty_rect_tolerance = dirty_rect_tolerance;\n  widget_invalidate(widget, NULL);\n\n  return RET_OK;\n}\n\nret_t widget_destroy_children(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->children != NULL) {\n    WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n\n    widget_remove_child_prepare(widget, iter);\n    widget_unref(iter);\n\n    widget->children->elms[i] = NULL;\n\n    WIDGET_FOR_EACH_CHILD_END();\n    widget->children->size = 0;\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_style_type(widget_t* widget) {\n  theme_t* win_theme = NULL;\n  theme_t* default_theme = NULL;\n  const char* style_type = THEME_DEFAULT_STYLE_TYPE;\n\n  if (widget_get_window_theme(widget, &win_theme, &default_theme) == RET_OK) {\n    theme_t* t = win_theme != NULL ? win_theme : (default_theme != NULL ? default_theme : theme());\n    if (t != NULL) {\n      style_type = theme_get_style_type(t);\n    }\n  }\n\n  return style_type;\n}\n\nstatic ret_t widget_update_style_object(widget_t* widget) {\n  const char* style_type = widget_get_style_type(widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  if (widget->astyle == NULL) {\n    widget->astyle = style_factory_create_style(style_factory(), style_type);\n    ENSURE(widget->astyle != NULL);\n\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  } else if (widget->astyle != NULL &&\n             !tk_str_eq(style_get_style_type(widget->astyle), style_type)) {\n    style_t* style = style_factory_create_style(style_factory(), style_type);\n    ENSURE(style != NULL);\n    if (style_is_mutable(widget->astyle)) {\n      style_mutable_set_default_style(widget->astyle, style);\n    } else {\n      style_destroy(widget->astyle);\n      widget->astyle = style;\n    }\n\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  }\n  return RET_OK;\n}\n\nstatic ret_t widget_update_style_object_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_update_style_object(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_update_style_object_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_add_child(widget_t* widget, widget_t* child) {\n  event_t e = event_init(EVT_WIDGET_ADD_CHILD, widget);\n  return_value_if_fail(widget != NULL && child != NULL && child->parent == NULL, RET_BAD_PARAMS);\n\n  child->parent = widget;\n\n  if (widget->children == NULL) {\n    widget->children = darray_create(4, NULL, NULL);\n  }\n\n  if (widget->vt->on_add_child) {\n    if (widget->vt->on_add_child(widget, child) == RET_OK) {\n      return RET_OK;\n    }\n  }\n\n  if (child->vt->on_attach_parent) {\n    child->vt->on_attach_parent(child, widget);\n  }\n\n  ENSURE(darray_push(widget->children, child) == RET_OK);\n\n  if (!widget_is_window_manager(widget)) {\n    widget_set_need_relayout_children(widget);\n  }\n\n  if (!(child->initializing) && widget_get_window(child) != NULL) {\n    widget_set_need_update_style_recursive(child);\n    widget_update_style_object_recursive(child);\n  }\n\n  widget_dispatch(widget, &e);\n\n  return RET_OK;\n}\n\nret_t widget_remove_child_prepare(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n\n  if (!widget_is_window_manager(widget)) {\n    widget_set_need_relayout_children(widget);\n  }\n\n  widget_invalidate_force(child, NULL);\n  if (widget->target == child) {\n    widget->target = NULL;\n  }\n\n  if (widget->grab_widget == child) {\n    widget->grab_widget = NULL;\n    widget->grab_widget_count = 0;\n  }\n\n  if (widget->key_target == child) {\n    widget_dispatch_blur_event(widget->key_target);\n    widget->key_target = NULL;\n  }\n\n  if (widget->vt->on_remove_child) {\n    if (widget->vt->on_remove_child(widget, child) == RET_OK) {\n      return RET_OK;\n    }\n  }\n\n  if (child->vt->on_detach_parent) {\n    child->vt->on_detach_parent(child, widget);\n  }\n  child->parent = NULL;\n\n  return RET_OK;\n}\n\nret_t widget_remove_child(widget_t* widget, widget_t* child) {\n  ret_t ret = RET_OK;\n  event_t e = event_init(EVT_WIDGET_REMOVE_CHILD, widget);\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n\n  widget_remove_child_prepare(widget, child);\n  ret = darray_remove(widget->children, child);\n\n  if (ret == RET_OK) {\n    widget_dispatch(widget, &e);\n  }\n\n  return ret;\n}\n\nret_t widget_insert_child(widget_t* widget, uint32_t index, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget_add_child(widget, child) == RET_OK, RET_FAIL);\n\n  return widget_restack(child, index);\n}\n\nret_t widget_restack(widget_t* widget, uint32_t index) {\n  uint32_t i = 0;\n  uint32_t nr = 0;\n  int32_t old_index = 0;\n  widget_t** children = NULL;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, RET_BAD_PARAMS);\n\n  old_index = widget_index_of(widget);\n  nr = widget_count_children(widget->parent);\n  return_value_if_fail(old_index >= 0 && nr > 0, RET_BAD_PARAMS);\n\n  if (index >= nr) {\n    index = nr - 1;\n  }\n\n  if (index == old_index || nr == 1) {\n    return RET_OK;\n  }\n\n  children = (widget_t**)(widget->parent->children->elms);\n  if (index < old_index) {\n    for (i = old_index; i > index; i--) {\n      children[i] = children[i - 1];\n    }\n  } else {\n    for (i = old_index; i < index; i++) {\n      children[i] = children[i + 1];\n    }\n  }\n  children[index] = widget;\n\n  return RET_OK;\n}\n\nstatic widget_t* widget_lookup_child(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL && name != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (iter->name != NULL && tk_str_eq(iter->name, name)) {\n    return iter;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return NULL;\n}\n\nwidget_t* widget_child(widget_t* widget, const char* path) {\n  return widget_lookup_child(widget, path);\n}\n\nwidget_t* widget_get_focused_widget(widget_t* widget) {\n  widget_t* iter = NULL;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(win != NULL, NULL);\n\n  iter = win->key_target;\n  for (iter = win->key_target; iter != NULL; iter = iter->key_target) {\n    if (iter->focusable && iter->focused) {\n      return iter;\n    }\n\n    if (iter->key_target == NULL) {\n      return iter;\n    }\n  }\n\n  return NULL;\n}\n\nstatic widget_t* widget_lookup_all(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL && name != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (iter->name != NULL && tk_str_eq(iter->name, name)) {\n    return iter;\n  } else {\n    iter = widget_lookup_all(iter, name);\n    if (iter != NULL) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nwidget_t* widget_lookup(widget_t* widget, const char* name, bool_t recursive) {\n  if (recursive) {\n    return widget_lookup_all(widget, name);\n  } else {\n    return widget_lookup_child(widget, name);\n  }\n}\n\nstatic widget_t* widget_lookup_by_type_child(widget_t* widget, const char* type) {\n  return_value_if_fail(widget != NULL && type != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (tk_str_eq(iter->vt->type, type)) {\n    return iter;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return NULL;\n}\n\nstatic widget_t* widget_lookup_by_type_all(widget_t* widget, const char* type) {\n  return_value_if_fail(widget != NULL && type != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (tk_str_eq(iter->vt->type, type)) {\n    return iter;\n  } else {\n    iter = widget_lookup_by_type_all(iter, type);\n    if (iter != NULL) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nwidget_t* widget_lookup_by_type(widget_t* widget, const char* type, bool_t recursive) {\n  if (recursive) {\n    return widget_lookup_by_type_all(widget, type);\n  } else {\n    return widget_lookup_by_type_child(widget, type);\n  }\n}\n\nstatic ret_t widget_set_visible_self(widget_t* widget, bool_t visible) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->visible != visible) {\n    widget_invalidate_force(widget, NULL);\n    widget->visible = visible;\n    widget_set_need_update_style(widget);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget->parent);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_sensitive(widget_t* widget, bool_t sensitive) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->sensitive = sensitive;\n\n  return RET_OK;\n}\n\nret_t widget_set_visible_only(widget_t* widget, bool_t visible) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->visible = visible;\n\n  return RET_OK;\n}\n\nret_t widget_set_visible(widget_t* widget, bool_t visible, ...) {\n  return widget_set_visible_self(widget, visible);\n}\n\nwidget_t* widget_find_target(widget_t* widget, xy_t x, xy_t y) {\n  widget_t* ret = NULL;\n  return_value_if_fail(widget != NULL, NULL);\n\n  if (widget->vt && widget->vt->find_target) {\n    ret = widget->vt->find_target(widget, x, y);\n  } else {\n    ret = widget_find_target_default(widget, x, y);\n  }\n\n  return ret;\n}\n\nret_t widget_on_event_before_children(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt && widget->vt->on_event_before_children) {\n    ret = widget->vt->on_event_before_children(widget, e);\n  }\n\n  return ret;\n}\n\nstatic const char* widget_get_pointer_cursor(widget_t* widget) {\n  if (widget->pointer_cursor != NULL) {\n    return widget->pointer_cursor;\n  } else if (widget->vt->pointer_cursor != NULL) {\n    return widget->vt->pointer_cursor;\n  }\n\n  return WIDGET_CURSOR_DEFAULT;\n}\n\nret_t widget_update_pointer_cursor(widget_t* widget) {\n  widget_t* wm = widget_get_window_manager(widget);\n  return_value_if_fail(wm != NULL, RET_BAD_PARAMS);\n\n  return window_manager_set_cursor(wm, widget_get_pointer_cursor(widget));\n}\n\nret_t widget_dispatch(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  if (e->target == NULL) {\n    e->target = widget;\n  }\n\n  if (widget->vt && widget->vt->on_event) {\n    ret = widget->vt->on_event(widget, e);\n  } else {\n    ret = widget_on_event_default(widget, e);\n  }\n\n  if (ret != RET_STOP) {\n    if (widget->emitter != NULL) {\n      void* saved_target = e->target;\n\n      e->target = widget;\n      ret = emitter_dispatch(widget->emitter, e);\n      e->target = saved_target;\n    }\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t dispatch_in_idle(const idle_info_t* info) {\n  event_t* e = (event_t*)(info->ctx);\n  widget_t* widget = WIDGET(e->target);\n\n  widget_dispatch(widget, e);\n  widget_unref(widget);\n  event_destroy(e);\n\n  return RET_REMOVE;\n}\n\nret_t widget_dispatch_async(widget_t* widget, event_t* e) {\n  event_t* evt = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(e->target == widget, RET_BAD_PARAMS);\n\n  evt = event_clone(e);\n  return_value_if_fail(evt != NULL, RET_OOM);\n\n  widget_ref(widget);\n  idle_add(dispatch_in_idle, evt);\n\n  return RET_OK;\n}\n\nstatic ret_t widget_dispatch_callback(void* ctx, const void* data) {\n  widget_t* widget = WIDGET(data);\n\n  return widget_dispatch(widget, (event_t*)ctx);\n}\n\nret_t widget_dispatch_recursive(widget_t* widget, event_t* e) {\n  return widget_foreach(widget, widget_dispatch_callback, e);\n}\n\nuint32_t widget_on_with_tag(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx,\n                            uint32_t tag) {\n  return_value_if_fail(widget != NULL && on_event != NULL, RET_BAD_PARAMS);\n  if (widget->emitter == NULL) {\n    widget->emitter = emitter_create();\n  }\n\n  return emitter_on_with_tag(widget->emitter, type, on_event, ctx, tag);\n}\n\nuint32_t widget_on(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx) {\n  return widget_on_with_tag(widget, type, on_event, ctx, 0);\n}\n\nuint32_t widget_child_on(widget_t* widget, const char* name, uint32_t type, event_func_t on_event,\n                         void* ctx) {\n  return widget_on(widget_lookup(widget, name, TRUE), type, on_event, ctx);\n}\n\nret_t widget_off(widget_t* widget, uint32_t id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->emitter != NULL, RET_BAD_PARAMS);\n\n  return emitter_off(widget->emitter, id);\n}\n\nret_t widget_off_by_tag(widget_t* widget, uint32_t tag) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_tag(widget->emitter, tag);\n}\n\nret_t widget_off_by_ctx(widget_t* widget, void* ctx) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_ctx(widget->emitter, ctx);\n}\n\nret_t widget_off_by_func(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx) {\n  return_value_if_fail(widget != NULL && on_event != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_func(widget->emitter, type, on_event, ctx);\n}\n\nret_t widget_calc_icon_text_rect(const rect_t* ir, int32_t font_size, float_t text_size,\n                                 int32_t icon_at, uint32_t img_w, uint32_t img_h, int32_t spacer,\n                                 rect_t* r_text, rect_t* r_icon) {\n  return_value_if_fail(ir != NULL && (r_text != NULL || r_icon != NULL), RET_BAD_PARAMS);\n\n  if (r_icon == NULL) {\n    *r_text = *ir;\n\n    return RET_OK;\n  }\n\n  if (r_text == NULL) {\n    *r_icon = *ir;\n\n    return RET_OK;\n  }\n\n  return_value_if_fail(spacer < ir->h && spacer < ir->w, RET_BAD_PARAMS);\n  switch (icon_at) {\n    case ICON_AT_CENTRE: {\n      int32_t w = ir->w - spacer - text_size - img_w;\n      int32_t icon_h = ir->h - img_h;\n      *r_text = rect_init(ir->x + img_w + spacer + w / 2, ir->y, text_size, ir->h);\n      *r_icon = rect_init(ir->x + w / 2, ir->y + icon_h / 2, img_w, img_h);\n      break;\n    }\n    case ICON_AT_RIGHT: {\n      uint32_t w = img_w;\n      float_t ratio = system_info()->device_pixel_ratio;\n      if (ratio > 1) {\n        w = img_w / ratio;\n      }\n      w = tk_min(tk_max(w, ir->h), ir->w);\n      *r_icon = rect_init(ir->x + ir->w - w, ir->y, w, ir->h);\n      *r_text = rect_init(ir->x, ir->y, ir->w - ir->h - spacer, ir->h);\n      break;\n    }\n    case ICON_AT_TOP: {\n      int32_t icon_h = ir->h - font_size - spacer;\n      *r_icon = rect_init(ir->x, ir->y, ir->w, icon_h);\n      *r_text = rect_init(ir->x, icon_h + spacer, ir->w, font_size);\n      break;\n    }\n    case ICON_AT_BOTTOM: {\n      int32_t icon_h = ir->h - font_size - spacer;\n      *r_icon = rect_init(ir->x, ir->y + ir->h - icon_h, ir->w, icon_h);\n      *r_text = rect_init(ir->x, ir->y, ir->w, font_size);\n      break;\n    }\n    case ICON_AT_LEFT:\n    default: {\n      *r_icon = rect_init(ir->x, ir->y, ir->h, ir->h);\n      *r_text = rect_init(ir->x + ir->h + spacer, ir->y, ir->w - ir->h - spacer, ir->h);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_bidi(widget_t* widget) {\n  value_t v;\n  if (widget_get_prop(widget, WIDGET_PROP_BIDI, &v) == RET_OK) {\n    return value_str(&v);\n  }\n\n  return NULL;\n}\n\nret_t widget_draw_icon_text(widget_t* widget, canvas_t* c, const char* icon, wstr_t* text) {\n  rect_t ir;\n  wh_t w = 0;\n  wh_t h = 0;\n  bitmap_t img;\n  rect_t r_icon;\n  rect_t r_text;\n  int32_t margin = 0;\n  int32_t spacer = 0;\n  int32_t icon_at = 0;\n  uint16_t font_size = 0;\n  float_t text_size = 0.0f;\n  int32_t margin_left = 0;\n  int32_t margin_right = 0;\n  int32_t margin_top = 0;\n  int32_t margin_bottom = 0;\n  style_t* style = widget->astyle;\n  int32_t align_h = ALIGN_H_LEFT;\n  int32_t align_v = ALIGN_V_MIDDLE;\n  return_value_if_fail(widget->astyle != NULL, RET_BAD_PARAMS);\n\n  spacer = style_get_int(style, STYLE_ID_SPACER, 2);\n  margin = style_get_int(style, STYLE_ID_MARGIN, 0);\n  margin_top = style_get_int(style, STYLE_ID_MARGIN_TOP, margin);\n  margin_left = style_get_int(style, STYLE_ID_MARGIN_LEFT, margin);\n  margin_right = style_get_int(style, STYLE_ID_MARGIN_RIGHT, margin);\n  margin_bottom = style_get_int(style, STYLE_ID_MARGIN_BOTTOM, margin);\n  icon_at = style_get_int(style, STYLE_ID_ICON_AT, ICON_AT_AUTO);\n\n  w = widget->w - margin_left - margin_right;\n  h = widget->h - margin_top - margin_bottom;\n  ir = rect_init(margin_left, margin_top, w, h);\n\n  if (text == NULL) {\n    text = &(widget->text);\n  }\n\n  if (icon == NULL) {\n    icon = style_get_str(style, STYLE_ID_ICON, NULL);\n  }\n\n  widget_prepare_text_style(widget, c);\n\n  font_size = c->font_size;\n  text_size = text->str ? canvas_measure_text(c, text->str, text->size) : 0;\n  if (icon_at == ICON_AT_RIGHT || icon_at == ICON_AT_LEFT) {\n    align_v = style_get_int(style, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    align_h = style_get_int(style, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_LEFT);\n  } else {\n    align_v = style_get_int(style, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    align_h = style_get_int(style, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_CENTER);\n  }\n  canvas_set_text_align(c, (align_h_t)align_h, (align_v_t)align_v);\n\n  if (icon != NULL && widget_load_image(widget, icon, &img) == RET_OK) {\n    float_t dpr = system_info()->device_pixel_ratio;\n\n    if (text->size > 0) {\n      if ((h > (img.h / dpr + font_size) && icon_at == ICON_AT_AUTO)) {\n        icon_at = ICON_AT_TOP;\n      }\n\n      widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer, &r_text,\n                                 &r_icon);\n\n      canvas_draw_icon_in_rect(c, &img, &r_icon);\n      widget_draw_text_in_rect(widget, c, text->str, text->size, &r_text, FALSE);\n    } else {\n      if (icon_at == ICON_AT_AUTO) {\n        widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer, NULL,\n                                   &r_icon);\n      } else {\n        widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer,\n                                   &r_text, &r_icon);\n      }\n      canvas_draw_icon_in_rect(c, &img, &r_icon);\n    }\n  } else if (text != NULL && text->size > 0) {\n    widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, 0, 0, spacer, &r_text, NULL);\n    widget_draw_text_in_rect(widget, c, text->str, text->size, &r_text, FALSE);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_fill_rect(widget_t* widget, canvas_t* c, const rect_t* r, bool_t bg,\n                       image_draw_type_t draw_type) {\n  bitmap_t img;\n  ret_t ret = RET_OK;\n  gradient_t agradient;\n  style_t* style = widget->astyle;\n  uint32_t radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  const char* color_key = bg ? STYLE_ID_BG_COLOR : STYLE_ID_FG_COLOR;\n  const char* image_key = bg ? STYLE_ID_BG_IMAGE : STYLE_ID_FG_IMAGE;\n  rect_t bg_r = rect_init(widget->x, widget->y, widget->w, widget->h);\n  uint32_t radius_tl = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_LEFT, radius);\n  uint32_t radius_tr = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_RIGHT, radius);\n  uint32_t radius_bl = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_LEFT, radius);\n  uint32_t radius_br = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_RIGHT, radius);\n  uint32_t clear_bg = style_get_uint(style, STYLE_ID_CLEAR_BG, 0);\n  const char* draw_type_key = bg ? STYLE_ID_BG_IMAGE_DRAW_TYPE : STYLE_ID_FG_IMAGE_DRAW_TYPE;\n  gradient_t* gradient = style_get_gradient(style, color_key, &agradient);\n  const char* image_name = style_get_str(style, image_key, NULL);\n\n  if (gradient != NULL && r->w > 0 && r->h > 0) {\n    color_t color = gradient_get_first_color(gradient);\n    canvas_set_fill_color(c, color);\n    if (gradient->nr > 1 || color.rgba.a) {\n      if (radius_tl > 3 || radius_tr > 3 || radius_bl > 3 || radius_br > 3) {\n        /*TODO: support gradient*/\n        if (bg) {\n          ret = canvas_fill_rounded_rect_gradient_ex(c, r, NULL, gradient, radius_tl, radius_tr,\n                                                     radius_bl, radius_br);\n        } else {\n          ret = canvas_fill_rounded_rect_gradient_ex(c, r, &bg_r, gradient, radius_tl, radius_tr,\n                                                     radius_bl, radius_br);\n        }\n        if (ret == RET_FAIL) {\n          canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n        }\n      } else if (gradient->nr > 1) {\n        canvas_fill_rect_gradient(c, r->x, r->y, r->w, r->h, gradient);\n      } else {\n        if (clear_bg) {\n          canvas_clear_rect(c, r->x, r->y, r->w, r->h);\n        } else {\n          canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n        }\n      }\n    } else if (clear_bg) {\n      canvas_clear_rect(c, r->x, r->y, r->w, r->h);\n    }\n  }\n\n  if (image_name != NULL && *image_name && r->w > 0 && r->h > 0) {\n    char name[MAX_PATH + 1];\n    const char* region = strrchr(image_name, '#');\n    if (region != NULL) {\n      memset(name, 0x00, sizeof(name));\n      tk_strncpy(name, image_name, region - image_name);\n      image_name = name;\n    }\n\n    if (widget_load_image(widget, image_name, &img) == RET_OK) {\n      draw_type = (image_draw_type_t)style_get_int(style, draw_type_key, draw_type);\n\n      if (region == NULL) {\n        canvas_draw_image_ex(c, &img, draw_type, r);\n      } else {\n        rect_t src;\n        rect_t dst = *r;\n        if (tk_str_eq(region, \"#\")) {\n          src = rect_init(widget->x, widget->y, widget->w, widget->h);\n        } else if (tk_str_eq(region, \"#g\")) {\n          point_t p = {widget->x, widget->y};\n          widget_to_global(widget, &p);\n          src = rect_init(p.x, p.y, widget->w, widget->h);\n        } else {\n          image_region_parse(img.w, img.h, region, &src);\n        }\n\n        canvas_draw_image_ex2(c, &img, draw_type, &src, &dst);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_stroke_border_rect_for_border_type(canvas_t* c, const rect_t* r, color_t bd,\n                                                int32_t border, uint32_t border_width) {\n  wh_t w = r->w;\n  wh_t h = r->h;\n  xy_t x = r->x + 0.5;\n  xy_t y = r->y + 0.5;\n  xy_t y1 = y;\n  wh_t h1 = h;\n  bool_t draw_top = FALSE;\n  bool_t draw_bottom = FALSE;\n  canvas_set_fill_color(c, bd);\n  if (border & BORDER_TOP) {\n    draw_top = TRUE;\n    canvas_fill_rect(c, x, y, w, border_width);\n  }\n  if (border & BORDER_BOTTOM) {\n    draw_bottom = TRUE;\n    canvas_fill_rect(c, x, y + h - border_width, w, border_width);\n  }\n  /* 减少重复绘制的部分，可以修复有透明的时候重叠区域显示不正常为问题 */\n  if (draw_top) {\n    y1 += border_width;\n    h1 -= border_width;\n  }\n  if (draw_bottom) {\n    h1 -= border_width;\n  }\n  if (border & BORDER_LEFT) {\n    canvas_fill_rect(c, x, y1, border_width, h1);\n  }\n  if (border & BORDER_RIGHT) {\n    canvas_fill_rect(c, x + w - border_width, y1, border_width, h1);\n  }\n  return RET_OK;\n}\n\nret_t widget_stroke_border_rect(widget_t* widget, canvas_t* c, const rect_t* r) {\n  style_t* style = widget->astyle;\n  color_t trans = color_init(0, 0, 0, 0);\n  color_t bd = style_get_color(style, STYLE_ID_BORDER_COLOR, trans);\n  uint32_t radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  int32_t border = style_get_int(style, STYLE_ID_BORDER, BORDER_ALL);\n  uint32_t border_width = style_get_int(style, STYLE_ID_BORDER_WIDTH, 1);\n  uint32_t radius_tl = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_LEFT, radius);\n  uint32_t radius_tr = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_RIGHT, radius);\n  uint32_t radius_bl = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_LEFT, radius);\n  uint32_t radius_br = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_RIGHT, radius);\n\n  if (bd.rgba.a) {\n    canvas_set_stroke_color(c, bd);\n    if (radius_tl > 3 || radius_tr > 3 || radius_bl > 3 || radius_br > 3) {\n      if (canvas_stroke_rounded_rect_ex(c, r, NULL, &bd, radius_tl, radius_tr, radius_bl, radius_br,\n                                        border_width, border) != RET_OK) {\n        widget_stroke_border_rect_for_border_type(c, r, bd, border, border_width);\n      }\n    } else {\n      widget_stroke_border_rect_for_border_type(c, r, bd, border, border_width);\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_draw_background(widget_t* widget, canvas_t* c) {\n  rect_t r;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  r = rect_init(0, 0, widget->w, widget->h);\n\n  return widget_fill_rect(widget, c, &r, TRUE, IMAGE_DRAW_CENTER);\n}\n\nret_t widget_fill_bg_rect(widget_t* widget, canvas_t* c, const rect_t* r,\n                          image_draw_type_t draw_type) {\n  return widget_fill_rect(widget, c, r, TRUE, draw_type);\n}\n\nret_t widget_fill_fg_rect(widget_t* widget, canvas_t* c, const rect_t* r,\n                          image_draw_type_t draw_type) {\n  return widget_fill_rect(widget, c, r, FALSE, draw_type);\n}\n\nstatic ret_t widget_draw_border(widget_t* widget, canvas_t* c) {\n  rect_t r;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  r = rect_init(0, 0, widget->w, widget->h);\n  return widget_stroke_border_rect(widget, c, &r);\n}\n\nret_t widget_paint_helper(widget_t* widget, canvas_t* c, const char* icon, wstr_t* text) {\n  if (style_is_valid(widget->astyle)) {\n    widget_draw_icon_text(widget, c, icon, text);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_paint_impl(widget_t* widget, canvas_t* c) {\n  int32_t ox = widget->x;\n  int32_t oy = widget->y;\n  uint8_t save_alpha = c->global_alpha;\n\n  if (widget->opacity < TK_OPACITY_ALPHA) {\n    canvas_set_global_alpha(c, (widget->opacity * save_alpha) / 0xff);\n  }\n\n  if (widget->astyle != NULL) {\n    ox += style_get_int(widget->astyle, STYLE_ID_X_OFFSET, 0);\n    oy += style_get_int(widget->astyle, STYLE_ID_Y_OFFSET, 0);\n  }\n\n  canvas_translate(c, ox, oy);\n  widget_on_paint_begin(widget, c);\n  widget_on_paint_background(widget, c);\n  widget_on_paint_self(widget, c);\n  widget_on_paint_children(widget, c);\n  widget_on_paint_border(widget, c);\n  widget_on_paint_end(widget, c);\n\n  canvas_untranslate(c, ox, oy);\n  if (widget->opacity < TK_OPACITY_ALPHA) {\n    canvas_set_global_alpha(c, save_alpha);\n  }\n\n  widget_on_paint_done(widget, c);\n\n  return RET_OK;\n}\n\nret_t widget_paint(widget_t* widget, canvas_t* c) {\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  if (!widget->visible || widget->opacity <= 0x08 || widget->w <= 0 || widget->h <= 0) {\n    widget->dirty = FALSE;\n    return RET_OK;\n  }\n\n  if (widget->need_update_style) {\n    widget_update_style(widget);\n  }\n\n  canvas_save(c);\n  widget_paint_impl(widget, c);\n  canvas_restore(c);\n\n  widget->dirty = FALSE;\n\n  return RET_OK;\n}\n\nstatic const widget_cmd_t s_widget_cmds[] = {\n    {WIDGET_EXEC_START_ANIMATOR, widget_start_animator},\n    {WIDGET_EXEC_STOP_ANIMATOR, widget_stop_animator},\n    {WIDGET_EXEC_PAUSE_ANIMATOR, widget_pause_animator},\n    {WIDGET_EXEC_DESTROY_ANIMATOR, widget_destroy_animator}};\n\nstatic ret_t widget_do_exec(widget_t* widget, const char* cmd, const char* args) {\n  uint32_t i = 0;\n\n  for (i = 0; i < ARRAY_SIZE(s_widget_cmds); i++) {\n    const widget_cmd_t* iter = s_widget_cmds + i;\n    if (tk_str_eq(cmd, iter->name)) {\n      return iter->exec(widget, args);\n    }\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t widget_exec(widget_t* widget, const char* str) {\n  if (str != NULL) {\n    char cmd[TK_NAME_LEN + 1] = {0};\n    const char* args = strchr(str, ':');\n\n    if (args != NULL) {\n      return_value_if_fail((args - str) < TK_NAME_LEN, RET_BAD_PARAMS);\n      tk_strncpy(cmd, str, args - str);\n      args += 1;\n    } else {\n      return_value_if_fail(strlen(str) < TK_NAME_LEN, RET_BAD_PARAMS);\n      tk_strcpy(cmd, str);\n    }\n\n    return widget_do_exec(widget, cmd, args);\n  } else {\n    return RET_NOT_FOUND;\n  }\n}\n\nstatic widget_t* widget_get_top_widget_grab_key(widget_t* widget) {\n  return_value_if_fail(widget != NULL, NULL);\n  WIDGET_FOR_EACH_CHILD_BEGIN_R(widget, iter, i)\n  value_t v;\n  widget_t* widget_grab_key = widget_get_top_widget_grab_key(iter);\n  if (widget_grab_key == NULL && iter != NULL && iter->visible && iter->custom_props != NULL) {\n    ret_t ret = tk_object_get_prop(iter->custom_props, WIDGET_PROP_GRAB_KEYS, &v);\n    if (ret == RET_OK && value_bool(&v)) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nstatic ret_t widget_on_ungrab_keys(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  window_manager_t* wm = WINDOW_MANAGER(widget_get_window_manager(widget));\n\n  wm->widget_grab_key = widget_get_top_widget_grab_key(WIDGET(wm));\n\n  return RET_REMOVE;\n}\n\nstatic ret_t widget_exec_code(void* ctx, event_t* evt) {\n#ifndef WITHOUT_FSCRIPT\n  value_t v;\n  value_t result;\n  ret_t ret = RET_OK;\n  tk_object_t* obj = NULL;\n  widget_t* widget = WIDGET(evt->target);\n  const char* code = (const char*)ctx;\n  if (widget_get_prop(widget, STR_PROP_MODEL, &v) == RET_OK) {\n    obj = value_object(&v);\n  }\n  if (obj != NULL) {\n    TK_OBJECT_REF(obj);\n  } else {\n    obj = object_default_create();\n  }\n  return_value_if_fail(obj != NULL && code != NULL, RET_REMOVE);\n\n  tk_object_set_prop_pointer(obj, STR_PROP_SELF, widget);\n\n  switch (evt->type) {\n    case EVT_CLICK:\n    case EVT_POINTER_DOWN:\n    case EVT_POINTER_MOVE:\n    case EVT_POINTER_UP: {\n      pointer_event_t* e = pointer_event_cast(evt);\n      tk_object_set_prop_int(obj, \"x\", e->x);\n      tk_object_set_prop_int(obj, \"y\", e->y);\n      tk_object_set_prop_bool(obj, \"alt\", e->alt);\n      tk_object_set_prop_bool(obj, \"cmd\", e->cmd);\n      tk_object_set_prop_bool(obj, \"menu\", e->menu);\n      tk_object_set_prop_bool(obj, \"ctrl\", e->ctrl);\n      break;\n    }\n    case EVT_KEY_DOWN:\n    case EVT_KEY_LONG_PRESS:\n    case EVT_KEY_UP: {\n      key_event_t* e = key_event_cast(evt);\n      const key_type_value_t* kv = keys_type_find_by_value(e->key);\n      if (kv != NULL) {\n        tk_object_set_prop_str(obj, \"key\", kv->name);\n      } else {\n        tk_object_set_prop_str(obj, \"key\", \"unkown\");\n      }\n      tk_object_set_prop_bool(obj, \"alt\", e->alt);\n      tk_object_set_prop_bool(obj, \"cmd\", e->cmd);\n      tk_object_set_prop_bool(obj, \"menu\", e->menu);\n      tk_object_set_prop_bool(obj, \"ctrl\", e->ctrl);\n      break;\n    }\n    default:\n      break;\n  }\n\n  value_set_int(&result, 0);\n  fscript_eval(obj, code, &result);\n  if (tk_object_get_prop_bool(obj, \"RET_STOP\", FALSE)) {\n    ret = RET_STOP;\n  }\n  if (tk_object_get_prop_bool(obj, \"RET_REMOVE\", FALSE)) {\n    ret = RET_REMOVE;\n  }\n  value_reset(&result);\n  TK_OBJECT_UNREF(obj);\n\n  return ret;\n#else\n  return RET_OK;\n#endif\n}\n\nstatic ret_t widget_free_code(void* ctx, event_t* evt) {\n  widget_t* widget = WIDGET(evt->target);\n  widget_off_by_ctx(widget, ctx);\n  TKMEM_FREE(ctx);\n\n  return RET_REMOVE;\n}\n\n#define STR_ANIMATE_PREFIX \"animate:\"\n#define TK_ANIMATING_TIME 500 /* 单位：毫秒（ms） */\nret_t widget_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  ret_t ret = RET_OK;\n  prop_change_event_t e;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_EXEC)) {\n    ret = widget_exec(widget, value_str(v));\n    if (ret != RET_NOT_FOUND) {\n      return ret;\n    }\n  }\n\n  e.value = v;\n  e.name = name;\n  e.e = event_init(EVT_PROP_WILL_CHANGE, widget);\n  widget_dispatch(widget, (event_t*)&e);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    widget_set_x(widget, (xy_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    widget_set_y(widget, (xy_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    widget_set_w(widget, (wh_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    widget_set_h(widget, (wh_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    widget->opacity = (uint8_t)value_int(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    widget_set_visible(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    widget->sensitive = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    widget->floating = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    widget->focusable = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    widget->with_focus_state = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    widget->dirty_rect_tolerance = value_int(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    const char* name = value_str(v);\n    return widget_use_style(widget, name);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    widget_set_enable(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    widget->feedback = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    widget_set_auto_adjust_size(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    widget_set_name(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_TR_TEXT)) {\n    widget_set_tr_text(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    widget_set_animation(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    widget_set_self_layout(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_LAYOUT) || tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    widget_set_children_layout(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_POINTER_CURSOR)) {\n    widget_set_pointer_cursor(widget, value_str(v));\n  } else {\n    ret = RET_NOT_FOUND;\n  }\n\n  if (widget->vt->set_prop) {\n    if (tk_str_start_with(name, STR_ANIMATE_PREFIX)) {\n      return widget_animate_prop_float_to(widget, name + strlen(STR_ANIMATE_PREFIX),\n                                          value_float32(v), TK_ANIMATING_TIME);\n    } else {\n      ret_t ret1 = widget->vt->set_prop(widget, name, v);\n      if (ret == RET_NOT_FOUND) {\n        ret = ret1;\n      }\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_FOCUSED) || tk_str_eq(name, WIDGET_PROP_FOCUS)) {\n      widget_set_focused(widget, value_bool(v));\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n      wstr_from_value(&(widget->text), v);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_EXEC)) {\n      ret = RET_NOT_FOUND;\n    } else if (tk_str_start_with(name, \"style:\") || tk_str_start_with(name, \"style.\")) {\n      return widget_set_style(widget, name + 6, v);\n    } else {\n      if (widget->custom_props == NULL) {\n        widget->custom_props = object_default_create();\n      }\n\n      if (tk_str_eq(name, WIDGET_PROP_GRAB_KEYS)) {\n        window_manager_t* wm = WINDOW_MANAGER(widget_get_window_manager(widget));\n\n        if (value_bool(v)) {\n          widget_on(widget, EVT_DESTROY, widget_on_ungrab_keys, widget);\n          wm->widget_grab_key = widget;\n        }\n      }\n\n      if (strncmp(name, STR_ON_EVENT_PREFIX, sizeof(STR_ON_EVENT_PREFIX) - 1) == 0) {\n        int32_t etype = event_from_name(name + sizeof(STR_ON_EVENT_PREFIX) - 1);\n        if (etype != EVT_NONE) {\n          char* code = tk_strdup(value_str(v));\n          if (code != NULL) {\n            name += sizeof(STR_ON_EVENT_PREFIX) - 1;\n            if (strncmp(name, STR_GLOBAL_EVENT_PREFIX, sizeof(STR_GLOBAL_EVENT_PREFIX) - 1) == 0) {\n              widget_t* wm = window_manager();\n              widget_on(wm, etype, widget_exec_code, code);\n              widget_on(wm, EVT_DESTROY, widget_free_code, code);\n            } else {\n              widget_on(widget, etype, widget_exec_code, code);\n              widget_on(widget, EVT_DESTROY, widget_free_code, code);\n            }\n            ret = RET_OK;\n          }\n        } else {\n          log_debug(\"not found event %s\\n\", name);\n        }\n      } else {\n        ret = tk_object_set_prop(widget->custom_props, name, v);\n      }\n    }\n  }\n\n  if (ret != RET_NOT_FOUND) {\n    e.e.type = EVT_PROP_CHANGED;\n    widget_dispatch(widget, (event_t*)&e);\n    widget_invalidate(widget, NULL);\n  }\n\n  return ret;\n}\n\nret_t widget_get_prop(widget_t* widget, const char* name, value_t* v) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    value_set_int32(v, widget->x);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    value_set_int32(v, widget->y);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    value_set_int32(v, widget->w);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    value_set_int32(v, widget->h);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    value_set_int32(v, widget->opacity);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    value_set_bool(v, widget->visible);\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    value_set_bool(v, widget->sensitive);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    value_set_bool(v, widget->floating);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    value_set_bool(v, widget_is_focusable(widget));\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSED)) {\n    value_set_bool(v, widget->focused);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    value_set_bool(v, widget->with_focus_state);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    value_set_int(v, widget->dirty_rect_tolerance);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    value_set_str(v, widget->style);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    value_set_bool(v, widget->enable);\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    value_set_bool(v, widget->feedback);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    value_set_bool(v, widget->auto_adjust_size);\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    value_set_str(v, widget->name);\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    value_set_str(v, widget->animation);\n  } else if (tk_str_eq(name, WIDGET_PROP_POINTER_CURSOR)) {\n    value_set_str(v, widget->pointer_cursor);\n  } else if (tk_str_eq(name, WIDGET_PROP_LOADING)) {\n    value_set_bool(v, widget->loading);\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    if (widget->self_layout != NULL) {\n      value_set_str(v, self_layouter_to_string(widget->self_layout));\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  } else if (tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    if (widget->children_layout != NULL) {\n      value_set_str(v, children_layouter_to_string(widget->children_layout));\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  } else {\n    if (widget->vt->get_prop) {\n      ret = widget->vt->get_prop(widget, name, v);\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  }\n\n  /*default*/\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_LAYOUT_W)) {\n      value_set_int32(v, widget->w);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_LAYOUT_H)) {\n      value_set_int32(v, widget->h);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n      wchar_t* text = widget->text.str;\n      if (text != NULL) {\n        text[widget->text.size] = 0;\n      }\n      value_set_wstr(v, text);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_STATE_FOR_STYLE)) {\n      value_set_str(v, widget_get_state_for_style(widget, FALSE, FALSE));\n      ret = RET_OK;\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (widget->custom_props != NULL) {\n      ret = tk_object_get_prop(widget->custom_props, name, v);\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_TYPE)) {\n      value_set_str(v, widget->vt->type);\n      ret = RET_OK;\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_set_prop_str(widget_t* widget, const char* name, const char* str) {\n  value_t v;\n  value_set_str(&v, str);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nconst char* widget_get_prop_str(widget_t* widget, const char* name, const char* defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_str(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_pointer(widget_t* widget, const char* name, void* pointer) {\n  value_t v;\n  value_set_pointer(&v, pointer);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nvoid* widget_get_prop_pointer(widget_t* widget, const char* name) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_pointer(&v);\n  } else {\n    return NULL;\n  }\n}\n\nret_t widget_set_prop_float(widget_t* widget, const char* name, float_t num) {\n  value_t v;\n  value_set_float32(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nfloat_t widget_get_prop_float(widget_t* widget, const char* name, float_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_float32(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_int(widget_t* widget, const char* name, int32_t num) {\n  value_t v;\n  value_set_int(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nint32_t widget_get_prop_int(widget_t* widget, const char* name, int32_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_int(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_bool(widget_t* widget, const char* name, bool_t num) {\n  value_t v;\n  value_set_bool(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nbool_t widget_get_prop_bool(widget_t* widget, const char* name, bool_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_bool(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_on_paint_background(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_background) {\n    ret = widget->vt->on_paint_background(widget, c);\n  } else {\n    if (style_is_valid(widget->astyle)) {\n      widget_draw_background(widget, c);\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_self(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_self) {\n    ret = widget->vt->on_paint_self(widget, c);\n  } else {\n    paint_event_t e;\n    widget_dispatch(widget, paint_event_init(&e, EVT_PAINT, widget, c));\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_children(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_children) {\n    ret = widget->vt->on_paint_children(widget, c);\n  } else {\n    ret = widget_on_paint_children_default(widget, c);\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_border(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_border) {\n    ret = widget->vt->on_paint_border(widget, c);\n  } else {\n    if (style_is_valid(widget->astyle)) {\n      ret = widget_draw_border(widget, c);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_begin(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_begin) {\n    ret = widget->vt->on_paint_begin(widget, c);\n  }\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_BEFORE_PAINT, widget, c));\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_done(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_PAINT_DONE, widget, c));\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_end(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_end) {\n    ret = widget->vt->on_paint_end(widget, c);\n  }\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_AFTER_PAINT, widget, c));\n\n  return ret;\n}\n\nret_t widget_dispatch_to_target(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  e->target = widget;\n  widget_dispatch(widget, e);\n\n  if (widget->target) {\n    ret = widget_dispatch_to_target(widget->target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_map_key(widget_t* widget, key_event_t* e) {\n  value_t v;\n  const key_type_value_t* kv = NULL;\n\n  if (widget->custom_props != NULL) {\n    kv = keys_type_find_by_value(e->key);\n    if (kv != NULL) {\n      const char* to = NULL;\n      char from[TK_NAME_LEN + 1] = {0};\n      char fixed_name[TK_NAME_LEN + 1];\n\n      tk_snprintf(from, sizeof(from), \"map_key:%s\", kv->name);\n      if (tk_object_get_prop(widget->custom_props, from, &v) == RET_OK) {\n        to = value_str(&v);\n      } else if (strlen(kv->name) > 1) {\n        tk_strcpy(fixed_name, kv->name);\n        tk_str_tolower(fixed_name);\n        tk_snprintf(from, sizeof(from), \"map_key:%s\", fixed_name);\n        if (tk_object_get_prop(widget->custom_props, from, &v) == RET_OK) {\n          to = value_str(&v);\n        }\n      }\n\n      if (to != NULL) {\n        kv = keys_type_find(to);\n        if (kv != NULL) {\n          e->key = kv->value;\n          log_debug(\"map key %s to %s\\n\", from, to);\n        }\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_dispatch_to_key_target(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  e->target = widget;\n  widget_dispatch(widget, e);\n\n  if (widget->key_target) {\n    ret = widget_dispatch_to_target(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_before_children(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    key_event_t before = *e;\n    before.e.type = EVT_KEY_DOWN_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_keydown_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_keydown(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_after_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_keydown) {\n    ret = widget->vt->on_keydown(widget, e);\n  }\n\n  return ret;\n}\n\nbool_t widget_is_activate_key(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL && e != NULL, FALSE);\n\n  return (widget->vt->space_key_to_activate && e->key == TK_KEY_SPACE) ||\n         (widget->vt->return_key_to_activate && key_code_is_enter(e->key));\n}\n\nstatic bool_t shortcut_fast_match(const char* shortcut, key_event_t* e) {\n  uint32_t key = e->key;\n  const char* kname = strrchr(shortcut, '+');\n  bool_t cmd = strstr(shortcut, \"cmd\") != NULL;\n  bool_t ctrl = strstr(shortcut, \"ctrl\") != NULL;\n  bool_t shift = strstr(shortcut, \"shift\") != NULL;\n  const key_type_value_t* kv = keys_type_find_by_value(key);\n\n  if (kv != NULL) {\n    if (kname == NULL) {\n      kname = shortcut;\n    } else {\n      kname++;\n    }\n\n    if (tk_str_ieq(kname, kv->name) && cmd == e->cmd && ctrl == e->ctrl && shift == e->shift) {\n      return TRUE;\n    }\n  }\n\n  return FALSE;\n}\n\nstatic bool_t widget_match_key(widget_t* widget, const char* prop, key_event_t* e) {\n  const char* shortcut = NULL;\n  widget_t* win = widget_get_window(widget);\n\n  if (widget_is_window_manager(widget)) {\n    return FALSE;\n  }\n\n  return_value_if_fail(win != NULL, FALSE);\n  shortcut = widget_get_prop_str(win, prop, NULL);\n\n  if (shortcut != NULL) {\n    return shortcut_fast_match(shortcut, e);\n  }\n\n  return FALSE;\n}\n\nstatic bool_t widget_is_move_focus_prev_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_PREV_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_next_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_NEXT_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_up_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_UP_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_down_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_DOWN_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_left_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_LEFT_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_right_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_RIGHT_KEY, e);\n}\n\nbool_t widget_is_change_focus_key(widget_t* widget, key_event_t* e) {\n  return widget_is_move_focus_prev_key(widget, e) || widget_is_move_focus_next_key(widget, e) ||\n         widget_is_move_focus_up_key(widget, e) || widget_is_move_focus_down_key(widget, e) ||\n         widget_is_move_focus_left_key(widget, e) || widget_is_move_focus_right_key(widget, e);\n}\n\nstatic ret_t widget_on_keydown_general(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  if (!widget_is_window_manager(widget)) {\n    if (widget_is_activate_key(widget, e)) {\n      ret = RET_STOP;\n      widget_set_state(widget, WIDGET_STATE_PRESSED);\n    } else if (widget_is_move_focus_next_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_next(widget);\n      } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n        ret = RET_STOP;\n        widget_focus_first(widget);\n      }\n    } else if (widget_is_move_focus_prev_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_prev(widget);\n      } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n        ret = RET_STOP;\n        widget_focus_first(widget);\n      }\n    } else if (widget_is_move_focus_up_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_up(widget);\n      }\n    } else if (widget_is_move_focus_down_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_down(widget);\n      }\n    } else if (widget_is_move_focus_left_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_left(widget);\n      }\n    } else if (widget_is_move_focus_right_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_right(widget);\n      }\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_impl(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_keydown_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keydown_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keydown_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_keydown(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  uint32_t key = e->key;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  widget_map_key(widget, e);\n  if (e->e.type == EVT_KEY_DOWN) {\n    ret = widget_on_keydown_impl(widget, e);\n    if (widget->feedback) {\n      ui_feedback_request(widget, (event_t*)e);\n    }\n\n    e->key = key;\n    if (ret != RET_STOP) {\n      ret = widget_on_keydown_general(widget, e);\n    }\n  } else if (e->e.type == EVT_KEY_LONG_PRESS) {\n    return_value_if_equal(widget_on_keydown_children(widget, e), RET_STOP);\n    ret = widget_on_keydown_after_children(widget, e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_before_children(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    key_event_t before = *e;\n    before.e.type = EVT_KEY_UP_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_keyup_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_keyup(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_after_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_keyup) {\n    ret = widget->vt->on_keyup(widget, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_impl(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_keyup_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keyup_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keyup_after_children(widget, e), RET_STOP);\n\n  if (widget_is_activate_key(widget, e)) {\n    pointer_event_t click;\n    if (widget_is_focusable(widget)) {\n      widget_set_state(widget, WIDGET_STATE_FOCUSED);\n    } else {\n      widget_set_state(widget, WIDGET_STATE_NORMAL);\n    }\n    widget_dispatch_async(widget, pointer_event_init(&click, EVT_CLICK, widget, 0, 0));\n\n    ret = RET_STOP;\n  } else if (widget_is_move_focus_next_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_prev_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_up_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_down_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_left_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_right_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_on_keyup(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  uint32_t key = e->key;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  widget_map_key(widget, e);\n  ret = widget_on_keyup_impl(widget, e);\n  if (widget->feedback) {\n    ui_feedback_request(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  e->key = key;\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_before_children(widget_t* widget, wheel_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    wheel_event_t before = *e;\n    before.e.type = EVT_WHEEL_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_wheel_children(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_wheel(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_after_children(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_wheel) {\n    ret = widget->vt->on_wheel(widget, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_impl(widget_t* widget, wheel_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_wheel_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_wheel_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_wheel_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_wheel(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_wheel_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}\n\nret_t widget_on_multi_gesture(widget_t* widget, multi_gesture_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\n    ret = widget_dispatch(target, (event_t*)e);\n  }\n\n  if (ret != RET_STOP) {\n    ret = widget_dispatch(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_dispatch_leave_event(widget_t* widget, pointer_event_t* e) {\n  widget_t* target = widget;\n\n  while (target != NULL) {\n    widget_t* curr = target;\n    pointer_event_t leave = *e;\n    leave.e.type = EVT_POINTER_LEAVE;\n\n    widget_dispatch(target, (event_t*)(&leave));\n    target = curr->target;\n    curr->target = NULL;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_dispatch_blur_event(widget_t* widget) {\n  widget_t* target = widget;\n  widget_t* temp;\n\n  while (target != NULL) {\n    widget_ref(target);\n    if (target->focused) {\n      target->focused = FALSE;\n      event_t e = event_init(EVT_BLUR, target);\n      widget_dispatch(target, &e);\n      widget_set_need_update_style(target);\n    }\n\n    if (target->parent && target->parent->key_target == target) {\n      target->parent->key_target = NULL;\n    }\n\n    temp = target->key_target;\n    widget_unref(target);\n    target = temp;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_dispatch_event_to_target_recursive(widget_t* widget, event_t* e) {\n  widget_t* target = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  target = widget->grab_widget ? widget->grab_widget : widget->target;\n  while (target != NULL) {\n    widget_dispatch(target, e);\n    target = target->target != NULL ? target->target : target->key_target;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_on_pointer_down_before_children(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    pointer_event_t before = *e;\n    before.e.type = EVT_POINTER_DOWN_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nret_t widget_on_pointer_down_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n\n  if (target != NULL && target->enable && target->sensitive) {\n    if (!(widget_is_keyboard(target))) {\n      if (widget_is_focusable(target) || !widget_is_strongly_focus(widget)) {\n        if (!target->focused) {\n          widget_set_focused_internal(target, TRUE);\n        } else {\n          widget->key_target = target;\n        }\n      }\n    }\n  } else if (widget->key_target && !widget_is_strongly_focus(widget)) {\n    widget_set_focused_internal(widget->key_target, FALSE);\n  }\n  return_value_if_equal(ret, RET_STOP);\n\n  if (widget->target != target) {\n    if (widget->target != NULL) {\n      widget_dispatch_leave_event(widget->target, e);\n    }\n    widget->target = target;\n  }\n\n  if (widget->target != NULL) {\n    ret = widget_on_pointer_down(widget->target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_down_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_pointer_down) {\n    return_value_if_equal(ret = widget->vt->on_pointer_down(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_down_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  widget->grab_widget = NULL;\n  widget->grab_widget_count = 0;\n  return_value_if_equal(widget_on_pointer_down_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_pointer_down_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_pointer_down_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_pointer_down(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_pointer_down_impl(widget, e);\n  if (widget->feedback) {\n    ui_feedback_request(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_move_before_children(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    pointer_event_t before = *e;\n    before.e.type = EVT_POINTER_MOVE_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nret_t widget_on_pointer_move_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n\n  if (target != widget->target) {\n    if (widget->target != NULL) {\n      widget_dispatch_leave_event(widget->target, e);\n    }\n\n    if (target != NULL) {\n      pointer_event_t enter = *e;\n      enter.e.type = EVT_POINTER_ENTER;\n      ret = widget_dispatch(target, (event_t*)(&enter));\n      widget_update_pointer_cursor(target);\n    } else {\n      widget_update_pointer_cursor(widget);\n    }\n\n    widget->target = target;\n  }\n  return_value_if_equal(ret, RET_STOP);\n\n  if (widget->target != NULL) {\n    ret = widget_on_pointer_move(widget->target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_move_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_pointer_move) {\n    return_value_if_equal(ret = widget->vt->on_pointer_move(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_move_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_pointer_move_before_children(widget, e), RET_STOP);\n  if (widget_on_pointer_move_children(widget, e) == RET_STOP) {\n    if (e->pressed) {\n      pointer_event_t abort;\n      pointer_event_init(&abort, EVT_POINTER_DOWN_ABORT, widget, e->x, e->y);\n      return_value_if_equal(widget_on_pointer_move_after_children(widget, &abort), RET_STOP);\n    }\n\n    return RET_STOP;\n  } else {\n    return widget_on_pointer_move_after_children(widget, e);\n  }\n}\n\nret_t widget_on_pointer_move(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_pointer_move_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_up_before_children(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    pointer_event_t before = *e;\n    before.e.type = EVT_POINTER_UP_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nret_t widget_on_pointer_up_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\n    ret = widget_on_pointer_up(target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_up_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_pointer_up) {\n    return_value_if_equal(ret = widget->vt->on_pointer_up(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_up_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_pointer_up_before_children(widget, e), RET_STOP);\n  if (widget_on_pointer_up_children(widget, e) == RET_STOP) {\n    if (e->pressed) {\n      pointer_event_t abort;\n      pointer_event_init(&abort, EVT_POINTER_DOWN_ABORT, widget, e->x, e->y);\n      return_value_if_equal(widget_on_pointer_up_after_children(widget, &abort), RET_STOP);\n    }\n\n    return RET_STOP;\n  } else {\n    return widget_on_pointer_up_after_children(widget, e);\n  }\n}\n\nret_t widget_on_pointer_up(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_pointer_up_impl(widget, e);\n  if (widget->feedback) {\n    ui_feedback_request(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_context_menu_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\n    ret = widget_on_context_menu(target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_context_menu_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_context_menu) {\n    return_value_if_equal(ret = widget->vt->on_context_menu(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_context_menu_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget_on_context_menu_children(widget, e) == RET_STOP) {\n    return RET_STOP;\n  } else {\n    return widget_on_context_menu_after_children(widget, e);\n  }\n}\n\nret_t widget_on_context_menu(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_context_menu_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}\n\nret_t widget_grab(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->grab_widget == NULL || widget->grab_widget == child, RET_BAD_PARAMS);\n\n  if (widget->grab_widget == NULL) {\n    widget->grab_widget = child;\n    widget->grab_widget_count = 1;\n  } else {\n    widget->grab_widget_count++;\n  }\n\n  if (widget->parent) {\n    widget_grab(widget->parent, widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_ungrab(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->grab_widget == child) {\n    if (widget->grab_widget->grab_widget_count < widget->grab_widget_count) {\n      widget->grab_widget_count--;\n      if (widget->grab_widget_count <= 0) {\n        widget->grab_widget = NULL;\n        widget->grab_widget_count = 0;\n      }\n\n      if (widget->parent) {\n        widget_ungrab(widget->parent, widget);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_foreach(widget_t* widget, tk_visit_t visit, void* ctx) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && visit != NULL, RET_BAD_PARAMS);\n\n  ret = visit(ctx, widget);\n  if (ret != RET_OK) {\n    return ret;\n  }\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  ret = widget_foreach(iter, visit, ctx);\n  if (ret == RET_STOP || ret == RET_DONE) {\n    return ret;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return RET_OK;\n}\n\nwidget_t* widget_get_window(widget_t* widget) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, NULL);\n\n  while (iter) {\n    if (widget_is_window(iter)) {\n      return iter;\n    }\n    iter = iter->parent;\n  }\n\n  return NULL;\n}\n\nstatic widget_t* widget_get_window_or_keyboard(widget_t* widget) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, NULL);\n\n  while (iter) {\n    if (widget_is_window(iter) || widget_is_keyboard(iter)) {\n      return iter;\n    }\n    iter = iter->parent;\n  }\n\n  return NULL;\n}\n\nwidget_t* widget_get_window_manager(widget_t* widget) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, NULL);\n\n  while (iter) {\n    if (widget_is_window_manager(iter)) {\n      return iter;\n    }\n    iter = iter->parent;\n  }\n\n  return window_manager();\n}\n\nuint32_t widget_add_timer(widget_t* widget, timer_func_t on_timer, uint32_t duration_ms) {\n  return_value_if_fail(widget != NULL && on_timer != NULL, TK_INVALID_ID);\n  return timer_add_with_type(on_timer, widget, duration_ms, TIMER_INFO_WIDGET_ADD);\n}\n\nret_t widget_remove_timer(widget_t* widget, uint32_t timer_id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return timer_remove(timer_id);\n}\n\nuint32_t widget_add_idle(widget_t* widget, idle_func_t on_idle) {\n  return_value_if_fail(widget != NULL && on_idle != NULL, TK_INVALID_ID);\n  return idle_add_with_type(on_idle, widget, IDLE_INFO_WIDGET_ADD);\n}\n\nret_t widget_remove_idle(widget_t* widget, uint32_t idle_id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return idle_remove(idle_id);\n}\n\nret_t widget_destroy_sync(widget_t* widget) {\n  event_t e = event_init(EVT_DESTROY, widget);\n  return_value_if_fail(widget != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n\n#ifndef WITHOUT_WIDGET_ANIMATORS\n  widget_destroy_animator(widget, NULL);\n#endif /*WITHOUT_WIDGET_ANIMATORS*/\n\n  widget->destroying = TRUE;\n  idle_remove_all_by_ctx_and_type(IDLE_INFO_WIDGET_ADD, widget);\n  timer_remove_all_by_ctx_and_type(TIMER_INFO_WIDGET_ADD, widget);\n\n  if (widget->emitter != NULL) {\n    widget_dispatch(widget, &e);\n    emitter_destroy(widget->emitter);\n    widget->emitter = NULL;\n  }\n\n  if (widget->children != NULL) {\n    widget_destroy_children(widget);\n    darray_destroy(widget->children);\n    widget->children = NULL;\n  }\n\n  if (widget->children_layout != NULL) {\n    children_layouter_destroy(widget->children_layout);\n    widget->children_layout = NULL;\n  }\n\n  if (widget->self_layout != NULL) {\n    self_layouter_destroy(widget->self_layout);\n    widget->self_layout = NULL;\n  }\n\n  widget->destroying = FALSE;\n\n  return widget_real_destroy(widget);\n}\n\nwidget_t* widget_create(widget_t* parent, const widget_vtable_t* vt, xy_t x, xy_t y, wh_t w,\n                        wh_t h) {\n  return_value_if_fail(vt != NULL, NULL);\n\n  return widget_init(widget_real_create(vt), parent, vt, x, y, w, h);\n}\n\nret_t widget_destroy(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->ref_count > 0 && widget->vt != NULL,\n                       RET_BAD_PARAMS);\n\n  if (widget->parent != NULL) {\n    widget_remove_child(widget->parent, widget);\n  }\n\n  return widget_unref_async(widget);\n}\n\nstatic ret_t widget_destroy_on_idle(const idle_info_t* info) {\n  widget_destroy(WIDGET(info->ctx));\n\n  return RET_REMOVE;\n}\n\nret_t widget_destroy_async(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->ref_count > 0 && widget->vt != NULL,\n                       RET_BAD_PARAMS);\n\n  return_value_if_fail(idle_add(widget_destroy_on_idle, widget) != TK_INVALID_ID, RET_FAIL);\n\n  return RET_OK;\n}\n\nstatic ret_t widget_set_parent_not_dirty(widget_t* widget) {\n  widget_t* iter = widget->parent;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    iter->dirty = FALSE;\n    if (iter->vt->is_window) {\n      break;\n    }\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_invalidate(widget_t* widget, const rect_t* r) {\n  rect_t rself;\n  return_value_if_fail(widget != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->dirty) {\n    return RET_OK;\n  }\n\n  if (r == NULL) {\n    rself = rect_init(0, 0, widget->w, widget->h);\n    r = &rself;\n  }\n\n  widget->dirty = TRUE;\n  widget_set_parent_not_dirty(widget);\n\n  if (widget->vt && widget->vt->invalidate) {\n    return widget->vt->invalidate(widget, r);\n  } else {\n    return widget_invalidate_default(widget, r);\n  }\n}\n\nret_t widget_invalidate_force(widget_t* widget, const rect_t* r) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->dirty = FALSE;\n  return widget_invalidate(widget, r);\n}\n\nwidget_t* widget_init(widget_t* widget, widget_t* parent, const widget_vtable_t* vt, xy_t x, xy_t y,\n                      wh_t w, wh_t h) {\n  return_value_if_fail(widget != NULL && vt != NULL, NULL);\n\n  widget->x = x;\n  widget->y = y;\n  widget->w = w;\n  widget->h = h;\n  widget->vt = vt;\n  widget->dirty = TRUE;\n  widget->ref_count = 1;\n  widget->opacity = 0xff;\n  widget->enable = TRUE;\n  widget->visible = TRUE;\n  widget->feedback = FALSE;\n  widget->auto_adjust_size = FALSE;\n  widget->sensitive = TRUE;\n  widget->emitter = NULL;\n  widget->children = NULL;\n  widget->initializing = TRUE;\n  widget->state = tk_strdup(WIDGET_STATE_NORMAL);\n  widget->target = NULL;\n  widget->key_target = NULL;\n  widget->grab_widget = NULL;\n  widget->grab_widget_count = 0;\n  widget->focused = FALSE;\n  widget->focusable = FALSE;\n  widget->with_focus_state = FALSE;\n  widget->dirty_rect_tolerance = 4;\n  widget->need_update_style = TRUE;\n\n  if (parent) {\n    widget_add_child(parent, widget);\n  }\n\n  wstr_init(&(widget->text), 0);\n  if (!widget->vt) {\n    widget->vt = widget_vtable_default();\n  }\n\n  if (widget->astyle == NULL &&\n      (widget_is_window_manager(widget) || widget_get_window(widget) != NULL)) {\n    widget->astyle = style_factory_create_style(style_factory(), widget_get_style_type(widget));\n    ENSURE(widget->astyle != NULL);\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  }\n\n  widget_invalidate_force(widget, NULL);\n\n  widget->initializing = FALSE;\n\n  return widget;\n}\n\nret_t widget_get_prop_default_value(widget_t* widget, const char* name, value_t* v) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    value_set_int32(v, 0xff);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    value_set_int(v, 4);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n    value_set_wstr(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSED)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    value_set_bool(v, FALSE);\n  } else {\n    if (widget->vt->get_prop_default_value) {\n      ret = widget->vt->get_prop_default_value(widget, name, v);\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_get_offset(widget_t* widget, xy_t* out_x, xy_t* out_y) {\n  return_value_if_fail(widget != NULL && out_x != NULL && out_y != NULL, RET_BAD_PARAMS);\n  *out_x = 0;\n  *out_y = 0;\n  if (widget->vt != NULL && widget->vt->get_offset != NULL) {\n    return widget->vt->get_offset(widget, out_x, out_y);\n  }\n  return RET_OK;\n}\n\nret_t widget_to_screen_ex(widget_t* widget, widget_t* parent, point_t* p) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL && p != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL && iter != parent) {\n    xy_t offset_x, offset_y;\n    if (widget_get_offset(iter, &offset_x, &offset_y) == RET_OK) {\n      p->x -= offset_x;\n      p->y -= offset_y;\n    }\n\n    p->x += iter->x;\n    p->y += iter->y;\n\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_to_screen(widget_t* widget, point_t* p) {\n  return widget_to_screen_ex(widget, NULL, p);\n}\n\nret_t widget_to_local(widget_t* widget, point_t* p) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL && p != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    xy_t offset_x = 0;\n    xy_t offset_y = 0;\n    if (widget_get_offset(iter, &offset_x, &offset_y) == RET_OK) {\n      p->x += offset_x;\n      p->y += offset_y;\n    }\n\n    p->x -= iter->x;\n    p->y -= iter->y;\n\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_to_global(widget_t* widget, point_t* p) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL && p != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    p->x += iter->x;\n    p->y += iter->y;\n\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nint32_t widget_count_children(widget_t* widget) {\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget->children != NULL ? widget->children->size : 0;\n}\n\nwidget_t* widget_get_child(widget_t* widget, int32_t index) {\n  return_value_if_fail(widget != NULL, NULL);\n  if (widget->children == NULL || index >= widget->children->size) {\n    return NULL;\n  }\n\n  return WIDGET(widget->children->elms[index]);\n}\n\nint32_t widget_index_of(widget_t* widget) {\n  widget_t* parent = NULL;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, -1);\n\n  parent = widget->parent;\n  WIDGET_FOR_EACH_CHILD_BEGIN(parent, iter, i)\n  if (iter == widget) {\n    return i;\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return -1;\n}\n\nret_t widget_prepare_text_style_ex(widget_t* widget, canvas_t* c, color_t default_trans,\n                                   const char* default_font, uint16_t default_font_size,\n                                   align_h_t default_align_h, align_v_t default_align_v) {\n  style_t* style = widget->astyle;\n  color_t tc = style_get_color(style, STYLE_ID_TEXT_COLOR, default_trans);\n  const char* font_name = style_get_str(style, STYLE_ID_FONT_NAME, default_font);\n  uint16_t font_size = style_get_int(style, STYLE_ID_FONT_SIZE, default_font_size);\n  align_h_t align_h = (align_h_t)style_get_int(style, STYLE_ID_TEXT_ALIGN_H, default_align_h);\n  align_v_t align_v = (align_v_t)style_get_int(style, STYLE_ID_TEXT_ALIGN_V, default_align_v);\n\n  canvas_set_text_color(c, tc);\n  canvas_set_font(c, font_name, font_size);\n  canvas_set_text_align(c, align_h, align_v);\n\n  return RET_OK;\n}\n\nret_t widget_prepare_text_style(widget_t* widget, canvas_t* c) {\n  color_t trans = color_init(0, 0, 0, 0);\n  return widget_prepare_text_style_ex(widget, c, trans, NULL, TK_DEFAULT_FONT_SIZE, ALIGN_H_CENTER,\n                                      ALIGN_V_MIDDLE);\n}\n\nstatic ret_t widget_copy_style(widget_t* clone, widget_t* widget) {\n  if (style_is_mutable(widget->astyle) && style_mutable_cast(widget->astyle) != NULL) {\n    if (!style_is_mutable(clone->astyle)) {\n      widget_ensure_style_mutable(clone);\n    }\n\n    if (style_mutable_cast(clone->astyle) != NULL) {\n      style_mutable_copy(clone->astyle, widget->astyle);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic const char* const s_widget_persistent_props[] = {WIDGET_PROP_NAME,\n                                                        WIDGET_PROP_STYLE,\n                                                        WIDGET_PROP_TR_TEXT,\n                                                        WIDGET_PROP_TEXT,\n                                                        WIDGET_PROP_ANIMATION,\n                                                        WIDGET_PROP_ENABLE,\n                                                        WIDGET_PROP_VISIBLE,\n                                                        WIDGET_PROP_FLOATING,\n                                                        WIDGET_PROP_CHILDREN_LAYOUT,\n                                                        WIDGET_PROP_SELF_LAYOUT,\n                                                        WIDGET_PROP_OPACITY,\n                                                        WIDGET_PROP_FOCUSED,\n                                                        WIDGET_PROP_FEEDBACK,\n                                                        WIDGET_PROP_AUTO_ADJUST_SIZE,\n                                                        WIDGET_PROP_FOCUSABLE,\n                                                        WIDGET_PROP_SENSITIVE,\n                                                        WIDGET_PROP_WITH_FOCUS_STATE,\n                                                        NULL};\n\nconst char* const* widget_get_persistent_props(void) {\n  return s_widget_persistent_props;\n}\n\nstatic ret_t widget_copy_base_props(widget_t* widget, widget_t* other) {\n  widget->state = tk_str_copy(widget->state, other->state);\n  widget->name = tk_str_copy(widget->name, other->name);\n  widget->style = tk_str_copy(widget->style, other->style);\n\n  if (other->text.str != NULL) {\n    widget_set_text(widget, other->text.str);\n  }\n\n  if (other->tr_text != NULL) {\n    widget_set_tr_text(widget, other->tr_text);\n  }\n\n  widget->enable = other->enable;\n  widget->visible = other->visible;\n  widget->floating = other->floating;\n  widget->opacity = other->opacity;\n  widget->feedback = other->feedback;\n  widget->auto_adjust_size = other->auto_adjust_size;\n  widget->focusable = other->focusable;\n  widget->sensitive = other->sensitive;\n  widget->auto_created = other->auto_created;\n  widget->with_focus_state = other->with_focus_state;\n  widget->dirty_rect_tolerance = other->dirty_rect_tolerance;\n\n  if (other->animation != NULL && *(other->animation)) {\n    widget_set_animation(widget, other->animation);\n  }\n\n  if (other->self_layout != NULL) {\n    widget->self_layout = self_layouter_clone(other->self_layout);\n  }\n\n  if (other->children_layout != NULL) {\n    widget->children_layout = children_layouter_clone(other->children_layout);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_copy(widget_t* widget, widget_t* other) {\n  return_value_if_fail(widget != NULL && other != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt == other->vt, RET_BAD_PARAMS);\n\n  widget_copy_style(widget, other);\n  widget_copy_base_props(widget, other);\n\n  if (other->custom_props) {\n    widget->custom_props = object_default_clone(OBJECT_DEFAULT(other->custom_props));\n  }\n\n  if (widget->vt->on_copy != NULL) {\n    widget->vt->on_copy(widget, other);\n  } else {\n    widget_on_copy_default(widget, other);\n  }\n\n  widget_set_need_update_style(widget);\n\n  return RET_OK;\n}\n\nwidget_t* widget_clone(widget_t* widget, widget_t* parent) {\n  widget_t* clone = NULL;\n  return_value_if_fail(widget != NULL && widget->vt != NULL && widget->vt->create != NULL, NULL);\n\n  clone = widget->vt->create(parent, widget->x, widget->y, widget->w, widget->h);\n  return_value_if_fail(clone != NULL, NULL);\n\n  widget_copy(clone, widget);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_clone(iter, clone);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return clone;\n}\n\n#define PROP_EQ(prop) (widget->prop == other->prop)\nbool_t widget_equal(widget_t* widget, widget_t* other) {\n  bool_t ret = FALSE;\n  const char* const* properties = NULL;\n  return_value_if_fail(widget != NULL && other != NULL, FALSE);\n\n  ret = PROP_EQ(opacity) && PROP_EQ(enable) && PROP_EQ(visible) && PROP_EQ(vt) && PROP_EQ(x) &&\n        PROP_EQ(y) && PROP_EQ(w) && PROP_EQ(h) && PROP_EQ(floating);\n  if (widget->name != NULL || other->name != NULL) {\n    ret = ret && (tk_str_eq(widget->name, other->name) || PROP_EQ(name));\n  }\n\n  if (widget->style != NULL || other->style != NULL) {\n    ret = ret && tk_str_eq(widget->style, other->style);\n  }\n\n  if (!ret) {\n    return ret;\n  }\n\n  ret = ret && wstr_equal(&(widget->text), &(other->text));\n\n  if (widget->tr_text != NULL || other->tr_text != NULL) {\n    ret = ret && (tk_str_eq(widget->tr_text, other->tr_text) || PROP_EQ(tr_text));\n  }\n\n  if (!ret) {\n    return ret;\n  }\n\n  properties = widget->vt->clone_properties;\n  if (properties != NULL) {\n    value_t v1;\n    value_t v2;\n    uint32_t i = 0;\n    for (i = 0; properties[i] != NULL; i++) {\n      const char* prop = properties[i];\n      if (widget_get_prop(widget, prop, &v1) != RET_OK) {\n        continue;\n      }\n\n      if (widget_get_prop(other, prop, &v2) != RET_OK) {\n        return FALSE;\n      }\n\n      if (!value_equal(&v1, &v2)) {\n        log_debug(\"prop %s not equal\\n\", prop);\n        return FALSE;\n      }\n    }\n  }\n\n  if (widget->children_layout != other->children_layout) {\n    const char* str1 = children_layouter_to_string(widget->children_layout);\n    const char* str2 = children_layouter_to_string(other->children_layout);\n    if (!tk_str_eq(str1, str2)) {\n      return FALSE;\n    }\n  }\n\n  if (widget->self_layout != other->self_layout) {\nconst char* str1 = ",
    "raw_res": "",
    "prompt_res": "self_layouter_to_string(widget->self_layout);",
    "gt": "self_layouter_to_string(widget->self_layout);"
  },
  {
    "id": 2524,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/input_method.c",
    "input": "﻿/**\n * File:   input_method.h\n * Author: AWTK Develop Team\n * Brief:  input method interface.\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-06-19 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"base/keys.h\"\n#include \"tkc/utils.h\"\n#include \"base/input_method.h\"\n#include \"base/window_manager.h\"\n\nret_t input_method_dispatch(input_method_t* im, event_t* e) {\n  return_value_if_fail(im != NULL && e != NULL, RET_BAD_PARAMS);\n\n  return emitter_dispatch(&(im->emitter), e);\n}\n\nret_t input_method_dispatch_preedit(input_method_t* im) {\n  event_t e = event_init(EVT_IM_PREEDIT, im);\n\n  return input_method_dispatch_to_widget(im, &e);\n}\n\nret_t input_method_dispatch_preedit_confirm(input_method_t* im) {\n  event_t e = event_init(EVT_IM_PREEDIT_CONFIRM, im);\n\n  return input_method_dispatch_to_widget(im, &e);\n}\n\nret_t input_method_dispatch_preedit_abort(input_method_t* im) {\n  event_t e = event_init(EVT_IM_PREEDIT_ABORT, im);\n\n  return input_method_dispatch_to_widget(im, &e);\n}\n\nret_t input_method_dispatch_to_widget(input_method_t* im, event_t* e) {\n  return_value_if_fail(im != NULL && im->widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  e->target = im->widget;\n  return widget_dispatch(im->widget, e);\n}\n\nuint32_t input_method_on(input_method_t* im, event_type_t type, event_func_t on_event, void* ctx) {\n  return_value_if_fail(im != NULL && on_event != NULL, 0);\n\n  return emitter_on(&(im->emitter), type, on_event, ctx);\n}\n\nret_t input_method_off(input_method_t* im, uint32_t id) {\n  return_value_if_fail(im != NULL, RET_BAD_PARAMS);\n\n  return emitter_off(&(im->emitter), id);\n}\n\nret_t input_method_request(input_method_t* im, widget_t* widget) {\n  return_value_if_fail(im != NULL && im->request != NULL, RET_BAD_PARAMS);\n\n  if (im->busy) {\n    return RET_FAIL;\n  }\n\n  if (im->widget == widget) {\n    return RET_OK;\n  }\n\n  if (widget != NULL) {\n    widget_dispatch_simple_event(window_manager(), EVT_IM_START);\n  } else {\n    widget_dispatch_simple_event(window_manager(), EVT_IM_STOP);\n  }\n\n  return im->request(im, widget);\n}\n\nstatic input_method_t* s_input_method = NULL;\ninput_method_t* input_method(void) {\n  return s_input_method;\n}\n\nret_t input_method_set(input_method_t* im) {\n  s_input_method = im;\n\n  return RET_OK;\n}\n\nret_t input_method_update_action_button_info(input_method_t* im, const char* text, bool_t enable) {\n  im_action_button_info_event_t e;\n  return_value_if_fail(im != NULL, RET_BAD_PARAMS);\n\n  e.text = text;\n  e.enable = enable;\n  e.e = event_init(EVT_IM_ACTION_INFO, im);\n\n  im->action_button_enable = enable;\n  tk_strncpy(im->action_buton_text, text ? text : \"\", TK_NAME_LEN);\n\n  return input_method_dispatch(im, (event_t*)(&e));\n}\n\nret_t input_method_dispatch_action(input_method_t* im) {\n  event_t e = event_init(EVT_IM_ACTION, im);\n  return_value_if_fail(im != NULL, RET_BAD_PARAMS);\n\n  input_method_dispatch(im, &e);\n\n  if (im->engine != NULL && im->engine->keys.size > 0) {\n    char text[64];\n    tk_strncpy(text, im->engine->keys.str, sizeof(text) - 1);\n    input_method_commit_text(im, text);\n  }\n\n  return input_method_dispatch_to_widget(im, &e);\n}\n\nstatic ret_t input_method_dispatch_key_only(input_method_t* im, uint32_t key) {\n  key_event_t e;\n  key_event_init(&e, EVT_KEY_DOWN, NULL, key);\n\n  input_method_dispatch_to_widget(input_method(), (event_t*)&e);\n  e.e.type = EVT_KEY_UP;\n  input_method_dispatch_to_widget(input_method(), (event_t*)&e);\n\n  return RET_OK;\n}\n\nret_t input_method_dispatch_key(input_method_t* im, uint32_t key) {\n  return_value_if_fail(im != NULL, RET_BAD_PARAMS);\n\n  if (im->engine != NULL) {\n    if (input_engine_input(im->engine, (char)key) == RET_OK) {\n      return RET_OK;\n    }\n  }\n\n  return input_method_dispatch_key_only(im, key);\n}\n\nret_t input_method_dispatch_keys(input_method_t* im, const char* keys) {\n  return_value_if_fail(im != NULL && keys != NULL, RET_BAD_PARAMS);\n\n  if (im->engine != NULL) {\n    return input_engine_search(im->engine, keys);\n  }\n\n  return RET_OK;\n}\n\nret_t input_method_set_lang(input_method_t* im, const char* lang) {\n  return_value_if_fail(im != NULL, RET_BAD_PARAMS);\n  if (im->engine != NULL) {\n    if (input_engine_set_lang(im->engine, lang) == RET_OK) {\n      event_t e = event_init(EVT_IM_LANG_CHANGED, im);\n      input_method_dispatch(im, &e);\n\n      return RET_OK;\n    }\n  }\n\n  return RET_FAIL;\n}\n\nconst char* input_method_get_lang(input_method_t* im) {\n  return_value_if_fail(im != NULL, NULL);\n\n  if (im->engine != NULL) {\n    return input_engine_get_lang(im->engine);\n  }\n\n  return NULL;\n}\n\nret_t input_method_dispatch_candidates(input_method_t* im, const char* strs, uint32_t nr,\n                                       int32_t selected) {\n  im_candidates_event_t ce;\n\n  ce.e = event_init(EVT_IM_SHOW_CANDIDATES, im);\n  ce.candidates_nr = nr;\n  ce.candidates = strs;\n  ce.selected = selected;\n\n  return input_method_dispatch(im, (event_t*)(&ce));\n}\n\nret_t input_method_dispatch_pre_candidates(input_method_t* im, const char* strs, uint32_t nr,\n                                           int32_t selected) {\n  im_candidates_event_t ce;\n\n  ce.e = event_init(EVT_IM_SHOW_PRE_CANDIDATES, im);\n  ce.candidates_nr = nr;\n  ce.candidates = strs;\n  ce.selected = selected;\n\n  return input_method_dispatch(im, (event_t*)(&ce));\n}\n\nret_t input_method_commit_text_ex(input_method_t* im, bool_t replace, const char* text) {\n  im_commit_event_t e;\n  return_value_if_fail(im != NULL && text != NULL, RET_BAD_PARAMS);\n\n  if (im->engine) {\n    input_engine_reset_input(im->engine);\n    input_method_dispatch_candidates(im, \"\", 0, 0);\n  }\n\n  return input_method_dispatch_to_widget(input_method(), im_commit_event_init(&e, text, replace));\n}\n\nret_t input_method_commit_text(input_method_t* im, const char* text) {\n  return input_method_commit_text_ex(im, FALSE, text);\n}\n\nret_t input_method_destroy(input_method_t* im) {\n  return_value_if_fail(im != NULL, RET_BAD_PARAMS);\n  if (im->destroy) {\n    im->destroy(im);\n  }\n\n  return RET_OK;\n}\n\nevent_t* im_commit_event_init(im_commit_event_t* e, const char* text, bool_t replace) {\n  return_value_if_fail(e != NULL && text != NULL, NULL);\n\n  memset(e, 0x00, sizeof(*e));\n\n  e->text = text;\n  e->replace = replace;\ne->e = ",
    "raw_res": "event_init(EVT_IM_COMMIT, input_method());",
    "prompt_res": "event_init(EVT_IM_COMMIT, NULL);",
    "gt": "event_init(EVT_IM_COMMIT, NULL);"
  },
  {
    "id": 2525,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/font.c",
    "input": "﻿/**\n * File:   font.c\n * Author: AWTK Develop Team\n * Brief:  font interface\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-13 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"base/font.h\"\n\nret_t font_get_glyph(font_t* f, wchar_t chr, font_size_t font_size, glyph_t* g) {\n  return_value_if_fail(f != NULL && f->get_glyph != NULL && g != NULL, RET_BAD_PARAMS);\n\n  return f->get_glyph(f, chr, font_size, g);\n}\n\nret_t font_shrink_cache(font_t* f, uint32_t cache_size) {\n  return_value_if_fail(f != NULL, RET_BAD_PARAMS);\n\n  if (f->shrink_cache != NULL) {\n    f->shrink_cache(f, cache_size);\n  }\n\n  return RET_OK;\n}\n\nfont_vmetrics_t font_get_vmetrics(font_t* f, font_size_t font_size) {\n  font_vmetrics_t vmetrics = {font_size, 0, 0};\n  if (f != NULL && f->get_vmetrics != NULL) {\n    return f->get_vmetrics(f, font_size);\n  } else {\n    return vmetrics;\n  }\n}\n\nbool_t font_match(font_t* f, const char* name, font_size_t font_size) {\n  return_value_if_fail(f != NULL && f->match != NULL, FALSE);\n\n  return f->match(f, name, font_size);\n}\n\nret_t font_destroy(font_t* f) {\n  return_value_if_fail(f != NULL && f->destroy != NULL, RET_BAD_PARAMS);\n\n  return f->destroy(f);\n}\n\nglyph_t* glyph_create(void) {\n  return TKMEM_ZALLOC(glyph_t);\n}\n\nglyph_t* glyph_clone(glyph_t* old) {\n  glyph_t* g = NULL;\n  return_value_if_fail(old != NULL, NULL);\n\ng = ",
    "raw_res": "TKMEM_ZALLOC(glyph_t);",
    "prompt_res": "glyph_create();",
    "gt": "glyph_create();"
  },
  {
    "id": 2555,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/widgets/win/lv_win.c",
    "input": "/**\n * @file lv_win.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n#include \"lv_win.h\"\n#if LV_USE_WIN\n\n\n/*********************\n *      DEFINES\n *********************/\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic void lv_win_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\nconst lv_obj_class_t lv_win_class = {\n    .constructor_cb = lv_win_constructor,\n    .width_def = LV_PCT(100),\n    .height_def = LV_PCT(100),\n    .base_class = &lv_obj_class,\n    .instance_size = sizeof(lv_win_t)\n};\nstatic lv_coord_t create_header_height;\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\nlv_obj_t * lv_win_create(lv_obj_t * parent, lv_coord_t header_height)\n{\n    LV_LOG_INFO(\"begin\");\n    create_header_height = header_height;\n\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_win_class, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}\n\nlv_obj_t * lv_win_add_title(lv_obj_t * win, const char * txt)\n{\n    lv_obj_t * header = lv_win_get_header(win);\n    lv_obj_t * title = lv_label_create(header);\n    lv_label_set_long_mode(title, LV_LABEL_LONG_DOT);\n    lv_label_set_text(title, txt);\n    lv_obj_set_flex_grow(title, 1);\n    return title;\n}\n\nlv_obj_t * lv_win_add_btn(lv_obj_t * win, const void * icon, lv_coord_t btn_w)\n{\n    lv_obj_t * header = lv_win_get_header(win);\n    lv_obj_t * btn = lv_btn_create(header);\n    lv_obj_set_size(btn, btn_w, LV_PCT(100));\n\n    lv_obj_t * img = lv_img_create(btn);\n    lv_img_set_src(img, icon);\n    lv_obj_align(img, LV_ALIGN_CENTER, 0, 0);\n\n    return btn;\n}\n\nlv_obj_t * lv_win_get_header(lv_obj_t * win)\n{\n    return lv_obj_get_child(win, 0);\n}\n\nlv_obj_t * lv_win_get_content(lv_obj_t * win)\n{\n    return lv_obj_get_child(win, 1);\n}\n\n/**********************\n *   STATIC FUNCTIONS\n **********************/\n\nstatic void lv_win_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)\n{\n    LV_UNUSED(class_p);\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    lv_obj_set_size(obj, lv_obj_get_width(parent), lv_obj_get_height(parent));\n    lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_COLUMN);\n\nlv_obj_t * header = ",
    "raw_res": "lv_win_get_header(obj);",
    "prompt_res": "lv_obj_create(obj);",
    "gt": "lv_obj_create(obj);"
  },
  {
    "id": 2571,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/widgets/tileview/lv_tileview.c",
    "input": "/**\n * @file lv_tileview.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n#include \"lv_tileview.h\"\n#if LV_USE_TILEVIEW\n\n/*********************\n *      DEFINES\n *********************/\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic void lv_tileview_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void lv_tileview_tile_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void tileview_event_cb(lv_event_t * e);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\n\nconst lv_obj_class_t lv_tileview_class = {.constructor_cb = lv_tileview_constructor,\n                                          .base_class = &lv_obj_class,\n                                          .instance_size = sizeof(lv_tileview_t)\n                                         };\n\nconst lv_obj_class_t lv_tileview_tile_class = {.constructor_cb = lv_tileview_tile_constructor,\n                                               .base_class = &lv_obj_class,\n                                               .instance_size = sizeof(lv_tileview_tile_t)\n                                              };\n\nstatic lv_dir_t create_dir;\nstatic uint32_t create_col_id;\nstatic uint32_t create_row_id;\n\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\nlv_obj_t * lv_tileview_create(lv_obj_t * parent)\n{\n    LV_LOG_INFO(\"begin\");\nlv_obj_t * obj = ",
    "raw_res": "lv_obj_create(parent, NULL);",
    "prompt_res": "lv_obj_class_create_obj(&lv_tileview_class, parent);",
    "gt": "lv_obj_class_create_obj(&lv_tileview_class, parent);"
  },
  {
    "id": 2619,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/widgets/imgbtn/lv_imgbtn.c",
    "input": "/**\n * @file lv_imgbtn.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n\n#include \"lv_imgbtn.h\"\n\n#if LV_USE_IMGBTN != 0\n\n/*********************\n *      DEFINES\n *********************/\n#define MY_CLASS &lv_imgbtn_class\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic void lv_imgbtn_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void draw_main(lv_event_t * e);\nstatic void lv_imgbtn_event(const lv_obj_class_t * class_p, lv_event_t * e);\nstatic void refr_img(lv_obj_t * imgbtn);\nstatic lv_imgbtn_state_t suggest_state(lv_obj_t * imgbtn, lv_imgbtn_state_t state);\nlv_imgbtn_state_t get_state(const lv_obj_t * imgbtn);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\nconst lv_obj_class_t lv_imgbtn_class = {\n    .base_class = &lv_obj_class,\n    .instance_size = sizeof(lv_imgbtn_t),\n    .constructor_cb = lv_imgbtn_constructor,\n    .event_cb = lv_imgbtn_event,\n};\n\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\n/**\n * Create a image button object\n * @param par pointer to an object, it will be the parent of the new image button\n * @return pointer to the created image button\n */\nlv_obj_t * lv_imgbtn_create(lv_obj_t * parent)\n{\n    LV_LOG_INFO(\"begin\");\nlv_obj_t * obj = ",
    "raw_res": "lv_obj_create(parent, NULL);",
    "prompt_res": "lv_obj_class_create_obj(MY_CLASS, parent);",
    "gt": "lv_obj_class_create_obj(MY_CLASS, parent);"
  },
  {
    "id": 2621,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/widgets/imgbtn/lv_imgbtn.c",
    "input": "/**\n * @file lv_imgbtn.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n\n#include \"lv_imgbtn.h\"\n\n#if LV_USE_IMGBTN != 0\n\n/*********************\n *      DEFINES\n *********************/\n#define MY_CLASS &lv_imgbtn_class\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic void lv_imgbtn_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void draw_main(lv_event_t * e);\nstatic void lv_imgbtn_event(const lv_obj_class_t * class_p, lv_event_t * e);\nstatic void refr_img(lv_obj_t * imgbtn);\nstatic lv_imgbtn_state_t suggest_state(lv_obj_t * imgbtn, lv_imgbtn_state_t state);\nlv_imgbtn_state_t get_state(const lv_obj_t * imgbtn);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\nconst lv_obj_class_t lv_imgbtn_class = {\n    .base_class = &lv_obj_class,\n    .instance_size = sizeof(lv_imgbtn_t),\n    .constructor_cb = lv_imgbtn_constructor,\n    .event_cb = lv_imgbtn_event,\n};\n\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\n/**\n * Create a image button object\n * @param par pointer to an object, it will be the parent of the new image button\n * @return pointer to the created image button\n */\nlv_obj_t * lv_imgbtn_create(lv_obj_t * parent)\n{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}\n\n/*=====================\n * Setter functions\n *====================*/\n\n/**\n * Set images for a state of the image button\n * @param imgbtn pointer to an image button object\n * @param state for which state set the new image\n * @param src_left pointer to an image source for the left side of the button (a C array or path to\n * a file)\n * @param src_mid pointer to an image source for the middle of the button (ideally 1px wide) (a C\n * array or path to a file)\n * @param src_right pointer to an image source for the right side of the button (a C array or path\n * to a file)\n */\nvoid lv_imgbtn_set_src(lv_obj_t * obj, lv_imgbtn_state_t state, const void * src_left, const void * src_mid,\n                       const void * src_right)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_imgbtn_t * imgbtn = (lv_imgbtn_t *)obj;\n\n    imgbtn->img_src_left[state] = src_left;\n    imgbtn->img_src_mid[state] = src_mid;\n    imgbtn->img_src_right[state] = src_right;\n\n    refr_img(obj);\n}\n\nvoid lv_imgbtn_set_state(lv_obj_t * obj, lv_imgbtn_state_t state)\n{\n\tLV_ASSERT_OBJ(obj, MY_CLASS);\n\n\tlv_state_t obj_state = LV_STATE_DEFAULT;\n\tif(state == LV_IMGBTN_STATE_PRESSED || state == LV_IMGBTN_STATE_CHECKED_PRESSED) obj_state |= LV_STATE_PRESSED;\n\tif(state == LV_IMGBTN_STATE_DISABLED || state == LV_IMGBTN_STATE_CHECKED_DISABLED) obj_state |= LV_STATE_DISABLED;\n\tif(state == LV_IMGBTN_STATE_CHECKED_DISABLED || state == LV_IMGBTN_STATE_CHECKED_PRESSED || state == LV_IMGBTN_STATE_CHECKED_RELEASED) {\n\t\tobj_state |= LV_STATE_CHECKED;\n\t}\n\n\tlv_obj_clear_state(obj, LV_STATE_CHECKED | LV_STATE_PRESSED | LV_STATE_DISABLED);\n\tlv_obj_add_state(obj, obj_state);\n\n\trefr_img(obj);\n}\n\n/*=====================\n * Getter functions\n *====================*/\n\n\n/**\n * Get the left image in a given state\n * @param imgbtn pointer to an image button object\n * @param state the state where to get the image (from `lv_btn_state_t`) `\n * @return pointer to the left image source (a C array or path to a file)\n */\nconst void * lv_imgbtn_get_src_left(lv_obj_t * obj, lv_imgbtn_state_t state)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_imgbtn_t * imgbtn = (lv_imgbtn_t *)obj;\n\n    return imgbtn->img_src_left[state];\n}\n\n/**\n * Get the middle image in a given state\n * @param imgbtn pointer to an image button object\n * @param state the state where to get the image (from `lv_btn_state_t`) `\n * @return pointer to the middle image source (a C array or path to a file)\n */\nconst void * lv_imgbtn_get_src_middle(lv_obj_t * obj, lv_imgbtn_state_t state)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_imgbtn_t * imgbtn = (lv_imgbtn_t *)obj;\n\n    return imgbtn->img_src_mid[state];\n}\n\n/**\n * Get the right image in a given state\n * @param imgbtn pointer to an image button object\n * @param state the state where to get the image (from `lv_btn_state_t`) `\n * @return pointer to the left image source (a C array or path to a file)\n */\nconst void * lv_imgbtn_get_src_right(lv_obj_t * obj, lv_imgbtn_state_t state)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_imgbtn_t * imgbtn = (lv_imgbtn_t *)obj;\n\n    return imgbtn->img_src_right[state];\n}\n\n\n/**********************\n *   STATIC FUNCTIONS\n **********************/\n\nstatic void lv_imgbtn_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)\n{\n    LV_UNUSED(class_p);\n    lv_imgbtn_t * imgbtn = (lv_imgbtn_t *)obj;\n    /*Initialize the allocated 'ext'*/\n    lv_memset_00((void *)imgbtn->img_src_mid, sizeof(imgbtn->img_src_mid));\n    lv_memset_00(imgbtn->img_src_left, sizeof(imgbtn->img_src_left));\n    lv_memset_00(imgbtn->img_src_right, sizeof(imgbtn->img_src_right));\n\n    imgbtn->act_cf = LV_IMG_CF_UNKNOWN;\n}\n\n\nstatic void lv_imgbtn_event(const lv_obj_class_t * class_p, lv_event_t * e)\n{\n    LV_UNUSED(class_p);\n\n    lv_res_t res = lv_obj_event_base(&lv_imgbtn_class, e);\n    if(res != LV_RES_OK) return;\n\nlv_event_code_t code = ",
    "raw_res": "e->code;",
    "prompt_res": "lv_event_get_code(e);",
    "gt": "lv_event_get_code(e);"
  },
  {
    "id": 2658,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/widgets/tabview/lv_tabview.c",
    "input": "/**\n * @file lv_tabview.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n#include \"lv_tabview.h\"\n#if LV_USE_TABVIEW\n\n#include \"../../../misc/lv_assert.h\"\n\n/*********************\n *      DEFINES\n *********************/\n#define MY_CLASS    &lv_tabview_class\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic void lv_tabview_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void lv_tabview_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void lv_tabview_event(const lv_obj_class_t * class_p, lv_event_t * e);\nstatic void btns_value_changed_event_cb(lv_event_t * e);\nstatic void cont_scroll_end_event_cb(lv_event_t * e);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\nconst lv_obj_class_t lv_tabview_class = {\n    .constructor_cb = lv_tabview_constructor,\n    .destructor_cb = lv_tabview_destructor,\n    .event_cb = lv_tabview_event,\n    .width_def = LV_PCT(100),\n    .height_def = LV_PCT(100),\n    .base_class = &lv_obj_class,\n    .instance_size = sizeof(lv_tabview_t)\n};\n\nstatic lv_dir_t tabpos_create;\nstatic lv_coord_t tabsize_create;\n\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\nlv_obj_t * lv_tabview_create(lv_obj_t * parent, lv_dir_t tab_pos, lv_coord_t tab_size)\n{\n    LV_LOG_INFO(\"begin\");\n    tabpos_create = tab_pos;\n    tabsize_create = tab_size;\n\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_tabview_class, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}\n\nlv_obj_t * lv_tabview_add_tab(lv_obj_t * obj, const char * name)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_tabview_t * tabview = (lv_tabview_t *)obj;\n    lv_obj_t * cont = lv_tabview_get_content(obj);\n\n    lv_obj_t * page = lv_obj_create(cont);\n    lv_obj_set_size(page, LV_PCT(100), LV_PCT(100));\n    lv_obj_clear_flag(page, LV_OBJ_FLAG_CLICK_FOCUSABLE);\n    uint32_t tab_id = lv_obj_get_child_cnt(cont);\n\nlv_obj_t * btns = ",
    "raw_res": "lv_tabview_get_btns(obj);",
    "prompt_res": "lv_tabview_get_tab_btns(obj);",
    "gt": "lv_tabview_get_tab_btns(obj);"
  },
  {
    "id": 2668,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/widgets/tabview/lv_tabview.c",
    "input": "/**\n * @file lv_tabview.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n#include \"lv_tabview.h\"\n#if LV_USE_TABVIEW\n\n#include \"../../../misc/lv_assert.h\"\n\n/*********************\n *      DEFINES\n *********************/\n#define MY_CLASS    &lv_tabview_class\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic void lv_tabview_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void lv_tabview_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void lv_tabview_event(const lv_obj_class_t * class_p, lv_event_t * e);\nstatic void btns_value_changed_event_cb(lv_event_t * e);\nstatic void cont_scroll_end_event_cb(lv_event_t * e);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\nconst lv_obj_class_t lv_tabview_class = {\n    .constructor_cb = lv_tabview_constructor,\n    .destructor_cb = lv_tabview_destructor,\n    .event_cb = lv_tabview_event,\n    .width_def = LV_PCT(100),\n    .height_def = LV_PCT(100),\n    .base_class = &lv_obj_class,\n    .instance_size = sizeof(lv_tabview_t)\n};\n\nstatic lv_dir_t tabpos_create;\nstatic lv_coord_t tabsize_create;\n\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\nlv_obj_t * lv_tabview_create(lv_obj_t * parent, lv_dir_t tab_pos, lv_coord_t tab_size)\n{\n    LV_LOG_INFO(\"begin\");\n    tabpos_create = tab_pos;\n    tabsize_create = tab_size;\n\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_tabview_class, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}\n\nlv_obj_t * lv_tabview_add_tab(lv_obj_t * obj, const char * name)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_tabview_t * tabview = (lv_tabview_t *)obj;\n    lv_obj_t * cont = lv_tabview_get_content(obj);\n\n    lv_obj_t * page = lv_obj_create(cont);\n    lv_obj_set_size(page, LV_PCT(100), LV_PCT(100));\n    lv_obj_clear_flag(page, LV_OBJ_FLAG_CLICK_FOCUSABLE);\n    uint32_t tab_id = lv_obj_get_child_cnt(cont);\n\n    lv_obj_t * btns = lv_tabview_get_tab_btns(obj);\n\n    char ** old_map = tabview->map;\n    char ** new_map;\n\n    /*top or bottom dir*/\n    if(tabview->tab_pos & LV_DIR_VER) {\n        new_map = lv_mem_alloc((tab_id + 1) * sizeof(const char *));\n        lv_memcpy_small(new_map, old_map, sizeof(const char *) * (tab_id - 1));\n        new_map[tab_id - 1] = lv_mem_alloc(strlen(name) + 1);\n        strcpy((char *)new_map[tab_id - 1], name);\n        new_map[tab_id] = \"\";\n    }\n    /*left or right dir*/\n    else {\n        new_map = lv_mem_alloc((tab_id * 2) * sizeof(const char *));\n        lv_memcpy_small(new_map, old_map, sizeof(const char *) * (tab_id - 1) * 2);\n        if(tabview->tab_cnt == 0) {\n            new_map[0] = lv_mem_alloc(strlen(name) + 1);\n            strcpy((char *)new_map[0], name);\n            new_map[1] = \"\";\n        }\n        else {\n            new_map[tab_id * 2 - 3] = \"\\n\";\n            new_map[tab_id * 2 - 2] = lv_mem_alloc(strlen(name) + 1);\n            new_map[tab_id * 2 - 1] = \"\";\n            strcpy((char *)new_map[(tab_id * 2) - 2], name);\n        }\n    }\n    tabview->map = new_map;\n    lv_btnmatrix_set_map(btns, (const char **)new_map);\n    lv_mem_free(old_map);\n\n    lv_btnmatrix_set_btn_ctrl_all(btns, LV_BTNMATRIX_CTRL_CHECKABLE | LV_BTNMATRIX_CTRL_CLICK_TRIG |\n                                  LV_BTNMATRIX_CTRL_NO_REPEAT);\n\n    tabview->tab_cnt++;\n    if(tabview->tab_cnt == 1) {\n        lv_tabview_set_act(obj, 0, LV_ANIM_OFF);\n    }\n\n    lv_btnmatrix_set_btn_ctrl(btns, tabview->tab_cur, LV_BTNMATRIX_CTRL_CHECKED);\n\n    return page;\n}\n\nvoid lv_tabview_set_act(lv_obj_t * obj, uint32_t id, lv_anim_enable_t anim_en)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_tabview_t * tabview = (lv_tabview_t *)obj;\n\n    if(id >= tabview->tab_cnt) {\n        id = tabview->tab_cnt - 1;\n    }\n\n    /*To be sure lv_obj_get_content_width will return valid value*/\n    lv_obj_update_layout(obj);\n\n    lv_obj_t * cont = lv_tabview_get_content(obj);\n    if(cont == NULL) return;\n    lv_coord_t gap = lv_obj_get_style_pad_column(cont, LV_PART_MAIN);\n    lv_coord_t w = lv_obj_get_content_width(cont);\n    if(lv_obj_get_style_base_dir(obj, LV_PART_MAIN) != LV_BASE_DIR_RTL) {\n        lv_obj_scroll_to_x(cont, id * (gap + w), anim_en);\n    }\n    else {\n        int32_t id_rtl = -(int32_t)id;\n        lv_obj_scroll_to_x(cont, (gap + w) * id_rtl, anim_en);\n    }\n\n    lv_obj_t * btns = lv_tabview_get_tab_btns(obj);\n    lv_btnmatrix_set_btn_ctrl(btns, id, LV_BTNMATRIX_CTRL_CHECKED);\n    tabview->tab_cur = id;\n}\n\nuint16_t lv_tabview_get_tab_act(lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_tabview_t * tabview = (lv_tabview_t *)obj;\n    return tabview->tab_cur;\n}\n\nlv_obj_t * lv_tabview_get_content(lv_obj_t * tv)\n{\n    return lv_obj_get_child(tv, 1);\n}\n\nlv_obj_t * lv_tabview_get_tab_btns(lv_obj_t * tv)\n{\n    return lv_obj_get_child(tv, 0);\n}\n\n/**********************\n *   STATIC FUNCTIONS\n **********************/\n\nstatic void lv_tabview_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)\n{\n    LV_UNUSED(class_p);\n    lv_tabview_t * tabview = (lv_tabview_t *)obj;\n\n    tabview->tab_pos = tabpos_create;\n\n    switch(tabview->tab_pos) {\n        case LV_DIR_TOP:\n            lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_COLUMN);\n            break;\n        case LV_DIR_BOTTOM:\n            lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_COLUMN_REVERSE);\n            break;\n        case LV_DIR_LEFT:\n            lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_ROW);\n            break;\n        case LV_DIR_RIGHT:\n            lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_ROW_REVERSE);\n            break;\n    }\n\n    lv_obj_set_size(obj, LV_PCT(100), LV_PCT(100));\n\n    lv_obj_t * btnm;\n    lv_obj_t * cont;\n\n    btnm = lv_btnmatrix_create(obj);\n    cont = lv_obj_create(obj);\n\n    lv_btnmatrix_set_one_checked(btnm, true);\n    tabview->map = lv_mem_alloc(sizeof(const char *));\n    tabview->map[0] = \"\";\n    lv_btnmatrix_set_map(btnm, (const char **)tabview->map);\n    lv_obj_add_event_cb(btnm, btns_value_changed_event_cb, LV_EVENT_VALUE_CHANGED, NULL);\n    lv_obj_add_flag(btnm, LV_OBJ_FLAG_EVENT_BUBBLE);\n\n    lv_obj_add_event_cb(cont, cont_scroll_end_event_cb, LV_EVENT_ALL, NULL);\n    lv_obj_set_scrollbar_mode(cont, LV_SCROLLBAR_MODE_OFF);\n\n    switch(tabview->tab_pos) {\n        case LV_DIR_TOP:\n        case LV_DIR_BOTTOM:\n            lv_obj_set_size(btnm, LV_PCT(100), tabsize_create);\n            lv_obj_set_width(cont, LV_PCT(100));\n            lv_obj_set_flex_grow(cont, 1);\n            break;\n        case LV_DIR_LEFT:\n        case LV_DIR_RIGHT:\n            lv_obj_set_size(btnm, tabsize_create, LV_PCT(100));\n            lv_obj_set_height(cont, LV_PCT(100));\n            lv_obj_set_flex_grow(cont, 1);\n            break;\n    }\n\n    lv_group_t * g = lv_group_get_default();\n    if(g) lv_group_add_obj(g, btnm);\n\n    lv_obj_set_flex_flow(cont, LV_FLEX_FLOW_ROW);\n    lv_obj_set_scroll_snap_x(cont, LV_SCROLL_SNAP_CENTER);\n    lv_obj_add_flag(cont, LV_OBJ_FLAG_SCROLL_ONE);\n    lv_obj_clear_flag(cont, LV_OBJ_FLAG_SCROLL_ON_FOCUS);\n}\n\nstatic void lv_tabview_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)\n{\n    LV_UNUSED(class_p);\n    lv_tabview_t * tabview = (lv_tabview_t *)obj;\n\n    uint32_t i;\n    if(tabview->tab_pos & LV_DIR_VER) {\n        for(i = 0; i < tabview->tab_cnt; i++) {\n            lv_mem_free(tabview->map[i]);\n            tabview->map[i] = NULL;\n        }\n    }\n    if(tabview->tab_pos & LV_DIR_HOR) {\n        for(i = 0; i < tabview->tab_cnt; i++) {\n            lv_mem_free(tabview->map[i * 2]);\n            tabview->map[i * 2] = NULL;\n        }\n    }\n\n\n    lv_mem_free(tabview->map);\n    tabview->map = NULL;\n}\n\nstatic void lv_tabview_event(const lv_obj_class_t * class_p, lv_event_t * e)\n{\n    LV_UNUSED(class_p);\n    lv_res_t res = lv_obj_event_base(&lv_tabview_class, e);\n    if(res != LV_RES_OK) return;\n\nlv_event_code_t code = ",
    "raw_res": "e->code;",
    "prompt_res": "lv_event_get_code(e);",
    "gt": "lv_event_get_code(e);"
  },
  {
    "id": 2690,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/widgets/meter/lv_meter.c",
    "input": "/**\n * @file lv_meter.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n#include \"lv_meter.h\"\n#if LV_USE_METER != 0\n\n#include \"../../../misc/lv_assert.h\"\n\n/*********************\n *      DEFINES\n *********************/\n#define MY_CLASS &lv_meter_class\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic void lv_meter_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void lv_meter_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void lv_meter_event(const lv_obj_class_t * class_p, lv_event_t * e);\nstatic void draw_arcs(lv_obj_t * obj, const lv_area_t * clip_area, const lv_area_t * scale_area);\nstatic void draw_ticks_and_labels(lv_obj_t * obj, const lv_area_t * clip_area, const lv_area_t * scale_area);\nstatic void draw_needles(lv_obj_t * obj, const lv_area_t * clip_area, const lv_area_t * scale_area);\nstatic void inv_arc(lv_obj_t * obj, lv_meter_indicator_t * indic, int32_t old_value, int32_t new_value);\nstatic void inv_line(lv_obj_t * obj, lv_meter_indicator_t * indic, int32_t value);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\nconst lv_obj_class_t lv_meter_class = {\n    .constructor_cb = lv_meter_constructor,\n    .destructor_cb = lv_meter_destructor,\n    .event_cb = lv_meter_event,\n    .instance_size = sizeof(lv_meter_t),\n    .base_class = &lv_obj_class\n};\n\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\nlv_obj_t * lv_meter_create(lv_obj_t * parent)\n{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}\n\n/*=====================\n * Add scale\n *====================*/\n\nlv_meter_scale_t * lv_meter_add_scale(lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_meter_t * meter = (lv_meter_t *)obj;\n\n    lv_meter_scale_t * scale = _lv_ll_ins_head(&meter->scale_ll);\n    LV_ASSERT_MALLOC(scale);\n    lv_memset_00(scale, sizeof(lv_meter_scale_t));\n\n    scale->angle_range = 270;\n    scale->rotation = 90 + (360 - scale->angle_range) / 2;\n    scale->min = 0;\n    scale->max = 100;\n    scale->tick_cnt = 6;\n    scale->tick_length = 8;\n    scale->tick_width = 2;\n    scale->label_gap = 2;\n\n    return scale;\n}\n\nvoid lv_meter_set_scale_ticks(lv_obj_t * obj, lv_meter_scale_t * scale, uint16_t cnt, uint16_t width, uint16_t len,\n                              lv_color_t color)\n{\n    scale->tick_cnt = cnt;\n    scale->tick_width = width;\n    scale->tick_length = len;\n    scale->tick_color = color;\n    lv_obj_invalidate(obj);\n}\n\nvoid lv_meter_set_scale_major_ticks(lv_obj_t * obj, lv_meter_scale_t * scale, uint16_t nth, uint16_t width,\n                                    uint16_t len, lv_color_t color, int16_t label_gap)\n{\n    scale->tick_major_nth = nth;\n    scale->tick_major_width = width;\n    scale->tick_major_length = len;\n    scale->tick_major_color = color;\n    scale->label_gap = label_gap;\n    lv_obj_invalidate(obj);\n}\n\nvoid lv_meter_set_scale_range(lv_obj_t * obj, lv_meter_scale_t * scale, int32_t min, int32_t max, uint32_t angle_range,\n                              uint32_t rotation)\n{\n    scale->min = min;\n    scale->max = max;\n    scale->angle_range = angle_range;\n    scale->rotation = rotation;\n    lv_obj_invalidate(obj);\n}\n\n/*=====================\n * Add indicator\n *====================*/\n\nlv_meter_indicator_t * lv_meter_add_needle_line(lv_obj_t * obj, lv_meter_scale_t * scale, uint16_t width,\n                                                lv_color_t color, int16_t r_mod)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_meter_t * meter = (lv_meter_t *)obj;\n    lv_meter_indicator_t * indic = _lv_ll_ins_head(&meter->indicator_ll);\n    LV_ASSERT_MALLOC(indic);\n    lv_memset_00(indic, sizeof(lv_meter_indicator_t));\n    indic->scale = scale;\n    indic->opa = LV_OPA_COVER;\n\n    indic->type = LV_METER_INDICATOR_TYPE_NEEDLE_LINE;\n    indic->type_data.needle_line.width = width;\n    indic->type_data.needle_line.color = color;\n    indic->type_data.needle_line.r_mod = r_mod;\n    lv_obj_invalidate(obj);\n\n    return indic;\n}\n\nlv_meter_indicator_t * lv_meter_add_needle_img(lv_obj_t * obj, lv_meter_scale_t * scale, const void * src,\n                                               lv_coord_t pivot_x, lv_coord_t pivot_y)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_meter_t * meter = (lv_meter_t *)obj;\n    lv_meter_indicator_t * indic = _lv_ll_ins_head(&meter->indicator_ll);\n    LV_ASSERT_MALLOC(indic);\n    lv_memset_00(indic, sizeof(lv_meter_indicator_t));\n    indic->scale = scale;\n    indic->opa = LV_OPA_COVER;\n\n    indic->type = LV_METER_INDICATOR_TYPE_NEEDLE_IMG;\n    indic->type_data.needle_img.src = src;\n    indic->type_data.needle_img.pivot.x = pivot_x;\n    indic->type_data.needle_img.pivot.y = pivot_y;\n    lv_obj_invalidate(obj);\n\n    return indic;\n}\n\nlv_meter_indicator_t * lv_meter_add_arc(lv_obj_t * obj, lv_meter_scale_t * scale, uint16_t width, lv_color_t color,\n                                        int16_t r_mod)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_meter_t * meter = (lv_meter_t *)obj;\n    lv_meter_indicator_t * indic = _lv_ll_ins_head(&meter->indicator_ll);\n    LV_ASSERT_MALLOC(indic);\n    lv_memset_00(indic, sizeof(lv_meter_indicator_t));\n    indic->scale = scale;\n    indic->opa = LV_OPA_COVER;\n\n    indic->type = LV_METER_INDICATOR_TYPE_ARC;\n    indic->type_data.arc.width = width;\n    indic->type_data.arc.color = color;\n    indic->type_data.arc.r_mod = r_mod;\n\n    lv_obj_invalidate(obj);\n    return indic;\n}\n\nlv_meter_indicator_t * lv_meter_add_scale_lines(lv_obj_t * obj, lv_meter_scale_t * scale, lv_color_t color_start,\n                                                lv_color_t color_end, bool local, int16_t width_mod)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_meter_t * meter = (lv_meter_t *)obj;\n    lv_meter_indicator_t * indic = _lv_ll_ins_head(&meter->indicator_ll);\n    LV_ASSERT_MALLOC(indic);\n    lv_memset_00(indic, sizeof(lv_meter_indicator_t));\n    indic->scale = scale;\n    indic->opa = LV_OPA_COVER;\n\n    indic->type = LV_METER_INDICATOR_TYPE_SCALE_LINES;\n    indic->type_data.scale_lines.color_start = color_start;\n    indic->type_data.scale_lines.color_end = color_end;\n    indic->type_data.scale_lines.local_grad = local;\n    indic->type_data.scale_lines.width_mod = width_mod;\n\n    lv_obj_invalidate(obj);\n    return indic;\n}\n\n/*=====================\n * Set indicator value\n *====================*/\n\nvoid lv_meter_set_indicator_value(lv_obj_t * obj, lv_meter_indicator_t * indic, int32_t value)\n{\n    int32_t old_start = indic->start_value;\n    int32_t old_end = indic->end_value;\n    indic->start_value = value;\n    indic->end_value = value;\n\n    if(indic->type == LV_METER_INDICATOR_TYPE_ARC) {\n        inv_arc(obj, indic, old_start, value);\n        inv_arc(obj, indic, old_end, value);\n    }\n    else if(indic->type == LV_METER_INDICATOR_TYPE_NEEDLE_IMG || indic->type == LV_METER_INDICATOR_TYPE_NEEDLE_LINE) {\n        inv_line(obj, indic, old_start);\n        inv_line(obj, indic, old_end);\n        inv_line(obj, indic, value);\n    }\n    else {\n        lv_obj_invalidate(obj);\n    }\n}\n\nvoid lv_meter_set_indicator_start_value(lv_obj_t * obj, lv_meter_indicator_t * indic, int32_t value)\n{\n    int32_t old_value = indic->start_value;\n    indic->start_value = value;\n\n    if(indic->type == LV_METER_INDICATOR_TYPE_ARC) {\n        inv_arc(obj, indic, old_value, value);\n    }\n    else if(indic->type == LV_METER_INDICATOR_TYPE_NEEDLE_IMG || indic->type == LV_METER_INDICATOR_TYPE_NEEDLE_LINE) {\n        inv_line(obj, indic, old_value);\n        inv_line(obj, indic, value);\n    }\n    else {\n        lv_obj_invalidate(obj);\n    }\n}\n\nvoid lv_meter_set_indicator_end_value(lv_obj_t * obj, lv_meter_indicator_t * indic, int32_t value)\n{\n    int32_t old_value = indic->end_value;\n    indic->end_value = value;\n\n    if(indic->type == LV_METER_INDICATOR_TYPE_ARC) {\n        inv_arc(obj, indic, old_value, value);\n    }\n    else if(indic->type == LV_METER_INDICATOR_TYPE_NEEDLE_IMG || indic->type == LV_METER_INDICATOR_TYPE_NEEDLE_LINE) {\n        inv_line(obj, indic, old_value);\n        inv_line(obj, indic, value);\n    }\n    else {\n        lv_obj_invalidate(obj);\n    }\n}\n\n/**********************\n *   STATIC FUNCTIONS\n **********************/\n\nstatic void lv_meter_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)\n{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_meter_t * meter = (lv_meter_t *)obj;\n\n    _lv_ll_init(&meter->scale_ll, sizeof(lv_meter_scale_t));\n    _lv_ll_init(&meter->indicator_ll, sizeof(lv_meter_indicator_t));\n\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}\n\nstatic void lv_meter_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)\n{\n    LV_UNUSED(class_p);\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_meter_t * meter = (lv_meter_t *)obj;\n    _lv_ll_clear(&meter->indicator_ll);\n    _lv_ll_clear(&meter->scale_ll);\n\n}\n\nstatic void lv_meter_event(const lv_obj_class_t * class_p, lv_event_t * e)\n{\n    LV_UNUSED(class_p);\n\n    lv_res_t res = lv_obj_event_base(MY_CLASS, e);\n    if(res != LV_RES_OK) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n    if(code == LV_EVENT_DRAW_MAIN) {\n        const lv_area_t * clip_area = lv_event_get_param(e);\n        lv_area_t scale_area;\n        lv_obj_get_content_coords(obj, &scale_area);\n\n        draw_arcs(obj, clip_area, &scale_area);\n        draw_ticks_and_labels(obj, clip_area, &scale_area);\n        draw_needles(obj, clip_area, &scale_area);\n\n        lv_coord_t r_edge = lv_area_get_width(&scale_area) / 2;\n        lv_point_t scale_center;\n        scale_center.x = scale_area.x1 + r_edge;\n        scale_center.y = scale_area.y1 + r_edge;\n\n        lv_draw_rect_dsc_t mid_dsc;\n        lv_draw_rect_dsc_init(&mid_dsc);\n        lv_obj_init_draw_rect_dsc(obj, LV_PART_INDICATOR, &mid_dsc);\n        lv_coord_t w = lv_obj_get_style_width(obj, LV_PART_INDICATOR) / 2;\n        lv_coord_t h = lv_obj_get_style_height(obj, LV_PART_INDICATOR) / 2;\n        lv_area_t nm_cord;\n        nm_cord.x1 = scale_center.x - w;\n        nm_cord.y1 = scale_center.y - h;\n        nm_cord.x2 = scale_center.x + w;\n        nm_cord.y2 = scale_center.y + h;\n        lv_draw_rect(&nm_cord, clip_area, &mid_dsc);\n    }\n}\n\nstatic void draw_arcs(lv_obj_t * obj, const lv_area_t * clip_area, const lv_area_t * scale_area)\n{\n    lv_meter_t * meter = (lv_meter_t *)obj;\n\n    lv_draw_arc_dsc_t arc_dsc;\n    lv_draw_arc_dsc_init(&arc_dsc);\n    arc_dsc.rounded = lv_obj_get_style_arc_rounded(obj, LV_PART_ITEMS);\n\n    lv_coord_t r_out = lv_area_get_width(scale_area) / 2 ;\n    lv_point_t scale_center;\n    scale_center.x = scale_area->x1 + r_out;\n    scale_center.y = scale_area->y1 + r_out;\n\n    lv_opa_t opa_main = lv_obj_get_style_opa(obj, LV_PART_MAIN);\n    lv_meter_indicator_t * indic;\n\n    lv_obj_draw_part_dsc_t part_draw_dsc;\n    lv_obj_draw_dsc_init(&part_draw_dsc, clip_area);\n    part_draw_dsc.arc_dsc = &arc_dsc;\n    part_draw_dsc.part = LV_PART_INDICATOR;\n    part_draw_dsc.class_p = MY_CLASS;\n    part_draw_dsc.type = LV_METER_DRAW_PART_ARC;\n\n    _LV_LL_READ_BACK(&meter->indicator_ll, indic) {\n        if(indic->type != LV_METER_INDICATOR_TYPE_ARC) continue;\n\n        arc_dsc.color = indic->type_data.arc.color;\n        arc_dsc.width = indic->type_data.arc.width;\n        arc_dsc.opa = indic->opa > LV_OPA_MAX ? opa_main : (opa_main * indic->opa) >> 8;\n\n        lv_meter_scale_t * scale = indic->scale;\n\n        int32_t start_angle = lv_map(indic->start_value, scale->min, scale->max, scale->rotation,\n                                     scale->rotation + scale->angle_range);\n        int32_t end_angle = lv_map(indic->end_value, scale->min, scale->max, scale->rotation,\n                                   scale->rotation + scale->angle_range);\n\n        part_draw_dsc.radius = r_out + indic->type_data.arc.r_mod;\n        part_draw_dsc.sub_part_ptr = indic;\n        part_draw_dsc.p1 = &scale_center;\n\n        lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n        lv_draw_arc(scale_center.x, scale_center.y, part_draw_dsc.radius, start_angle, end_angle, clip_area, &arc_dsc);\n        lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n    }\n}\n\nstatic void draw_ticks_and_labels(lv_obj_t * obj, const lv_area_t * clip_area, const lv_area_t * scale_area)\n{\n    lv_meter_t * meter    = (lv_meter_t *)obj;\n\n    lv_point_t p_center;\n    lv_coord_t r_edge = LV_MIN(lv_area_get_width(scale_area) / 2, lv_area_get_height(scale_area) / 2);\n    p_center.x = scale_area->x1 + r_edge;\n    p_center.y = scale_area->y1 + r_edge;\n\n    uint8_t i;\n\n    lv_draw_line_dsc_t line_dsc;\n    lv_draw_line_dsc_init(&line_dsc);\n    lv_obj_init_draw_line_dsc(obj, LV_PART_TICKS, &line_dsc);\n    line_dsc.raw_end = 1;\n\n    lv_draw_label_dsc_t label_dsc;\n    lv_draw_label_dsc_init(&label_dsc);\n    lv_obj_init_draw_label_dsc(obj, LV_PART_TICKS, &label_dsc);\n\n    lv_meter_scale_t * scale;\n\n    lv_draw_mask_radius_param_t inner_minor_mask;\n    lv_draw_mask_radius_param_t inner_major_mask;\n    lv_draw_mask_radius_param_t outer_mask;\n\n    lv_obj_draw_part_dsc_t part_draw_dsc;\n    lv_obj_draw_dsc_init(&part_draw_dsc, clip_area);\n    part_draw_dsc.class_p = MY_CLASS;\n    part_draw_dsc.part = LV_PART_TICKS;\n    part_draw_dsc.type = LV_METER_DRAW_PART_TICK;\n    part_draw_dsc.line_dsc = &line_dsc;\n\n    _LV_LL_READ_BACK(&meter->scale_ll, scale) {\n        part_draw_dsc.sub_part_ptr = scale;\n\n        lv_coord_t r_out = r_edge + scale->r_mod;\n        lv_coord_t r_in_minor = r_out - scale->tick_length;\n        lv_coord_t r_in_major = r_out - scale->tick_major_length;\n\n        lv_area_t area_inner_minor;\n        area_inner_minor.x1 = p_center.x - r_in_minor;\n        area_inner_minor.y1 = p_center.y - r_in_minor;\n        area_inner_minor.x2 = p_center.x + r_in_minor;\n        area_inner_minor.y2 = p_center.y + r_in_minor;\n        lv_draw_mask_radius_init(&inner_minor_mask, &area_inner_minor, LV_RADIUS_CIRCLE, true);\n\n        lv_area_t area_inner_major;\n        area_inner_major.x1 = p_center.x - r_in_major;\n        area_inner_major.y1 = p_center.y - r_in_major;\n        area_inner_major.x2 = p_center.x + r_in_major - 1;\n        area_inner_major.y2 = p_center.y + r_in_major - 1;\n        lv_draw_mask_radius_init(&inner_major_mask, &area_inner_major, LV_RADIUS_CIRCLE, true);\n\n        lv_area_t area_outer;\n        area_outer.x1 = p_center.x - r_out;\n        area_outer.y1 = p_center.y - r_out;\n        area_outer.x2 = p_center.x + r_out - 1;\n        area_outer.y2 = p_center.y + r_out - 1;\n        lv_draw_mask_radius_init(&outer_mask, &area_outer, LV_RADIUS_CIRCLE, false);\n        int16_t outer_mask_id = lv_draw_mask_add(&outer_mask, NULL);\n\n        int16_t inner_act_mask_id = LV_MASK_ID_INV; /*Will be added later*/\n\n        uint32_t minor_cnt = scale->tick_major_nth ? scale->tick_major_nth - 1 : 0xFFFF;\n        for(i = 0; i < scale->tick_cnt; i++) {\n            minor_cnt++;\n            bool major = false;\n            if(minor_cnt == scale->tick_major_nth) {\n                minor_cnt = 0;\n                major = true;\n            }\n\n            int32_t value_of_line = lv_map(i, 0, scale->tick_cnt - 1, scale->min, scale->max);\n            part_draw_dsc.value = value_of_line;\n\n            lv_color_t line_color = major ? scale->tick_major_color : scale->tick_color;\n            lv_color_t line_color_ori = line_color;\n\n            lv_coord_t line_width_ori = major ? scale->tick_major_width : scale->tick_width;\n            lv_coord_t line_width = line_width_ori;\n\n            lv_meter_indicator_t * indic;\n            _LV_LL_READ_BACK(&meter->indicator_ll, indic) {\n                if(indic->type != LV_METER_INDICATOR_TYPE_SCALE_LINES) continue;\n                if(value_of_line >= indic->start_value && value_of_line <= indic->end_value) {\n                    line_width += indic->type_data.scale_lines.width_mod;\n\n                    if(indic->type_data.scale_lines.color_start.full == indic->type_data.scale_lines.color_end.full) {\n                        line_color = indic->type_data.scale_lines.color_start;\n                    }\n                    else {\n                        lv_opa_t ratio;\n                        if(indic->type_data.scale_lines.local_grad) {\n                            ratio = lv_map(value_of_line, indic->start_value, indic->end_value, LV_OPA_TRANSP, LV_OPA_COVER);\n                        }\n                        else {\nratio = ",
    "raw_res": "0;",
    "prompt_res": "lv_map(value_of_line, scale->min, scale->max, LV_OPA_TRANSP, LV_OPA_COVER);",
    "gt": "lv_map(value_of_line, scale->min, scale->max, LV_OPA_TRANSP, LV_OPA_COVER);"
  },
  {
    "id": 2744,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/widgets/msgbox/lv_msgbox.c",
    "input": "/**\n * @file lv_msgbox.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n#include \"lv_msgbox.h\"\n#if LV_USE_MSGBOX\n\n#include \"../../../misc/lv_assert.h\"\n\n/*********************\n *      DEFINES\n *********************/\n#define LV_MSGBOX_FLAG_AUTO_PARENT  LV_OBJ_FLAG_WIDGET_1        /*Mark that the parent was automatically created*/\n#define MY_CLASS    &lv_msgbox_class\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic void msgbox_close_click_event_cb(lv_event_t * e);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\nconst lv_obj_class_t lv_msgbox_class = {\n        .base_class = &lv_obj_class,\n        .width_def = LV_DPI_DEF * 2,\n        .height_def = LV_SIZE_CONTENT,\n        .instance_size = sizeof(lv_msgbox_t)\n};\n\nconst lv_obj_class_t lv_msgbox_content_class = {\n        .base_class = &lv_obj_class,\n        .width_def = LV_PCT(100),\n        .height_def = LV_SIZE_CONTENT,\n        .instance_size = sizeof(lv_obj_t)\n};\n\nconst lv_obj_class_t lv_msgbox_backdrop_class = {\n        .base_class = &lv_obj_class,\n        .width_def = LV_PCT(100),\n        .height_def = LV_PCT(100),\n        .instance_size = sizeof(lv_obj_t)\n};\n\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\nlv_obj_t * lv_msgbox_create(lv_obj_t * parent, const char * title, const char * txt, const char * btn_txts[],\n                            bool add_close_btn)\n{\n    LV_LOG_INFO(\"begin\");\n    bool auto_parent = false;\n    if(parent == NULL) {\n        auto_parent = true;\n        parent = lv_obj_class_create_obj(&lv_msgbox_backdrop_class, lv_layer_top());\n        LV_ASSERT_MALLOC(parent);\n        lv_obj_class_init_obj(parent);\n        lv_obj_clear_flag(parent, LV_OBJ_FLAG_IGNORE_LAYOUT);\n        lv_obj_set_size(parent, LV_PCT(100), LV_PCT(100));\n    }\n\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_msgbox_class, parent);\n    LV_ASSERT_MALLOC(obj);\n    lv_obj_class_init_obj(obj);\n    if(obj == NULL) return NULL;\n    lv_msgbox_t * mbox = (lv_msgbox_t *)obj;\n\n    if(auto_parent) lv_obj_add_flag(obj, LV_MSGBOX_FLAG_AUTO_PARENT);\n\n    lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_ROW_WRAP);\n\n    bool has_title = title && strlen(title) > 0;\n\n    /*When a close button is required, we need the empty label as spacer to push the button to the right*/\n    if (add_close_btn || has_title) {\n        mbox->title = lv_label_create(obj);\n        lv_label_set_text(mbox->title, has_title ? title : \"\");\n        lv_label_set_long_mode(mbox->title, LV_LABEL_LONG_SCROLL_CIRCULAR);\n        if(add_close_btn) lv_obj_set_flex_grow(mbox->title, 1);\n        else lv_obj_set_width(mbox->title, LV_PCT(100));\n    }\n\n    if(add_close_btn) {\n        mbox->close_btn = lv_btn_create(obj);\n        lv_obj_set_ext_click_area(mbox->close_btn, LV_DPX(10));\n        lv_obj_add_event_cb(mbox->close_btn, msgbox_close_click_event_cb, LV_EVENT_CLICKED, NULL);\n        lv_obj_t * label = lv_label_create(mbox->close_btn);\n        lv_label_set_text(label, LV_SYMBOL_CLOSE);\n        const lv_font_t * font = lv_obj_get_style_text_font(mbox->close_btn, LV_PART_MAIN);\n        lv_coord_t close_btn_size = lv_font_get_line_height(font) + LV_DPX(10);\n        lv_obj_set_size(mbox->close_btn, close_btn_size, close_btn_size);\n        lv_obj_align(label, LV_ALIGN_CENTER, 0, 0);\n    }\n\n    mbox->content = lv_obj_class_create_obj(&lv_msgbox_content_class, obj);\n\n    bool has_txt = txt && strlen(txt) > 0;\n    if (has_txt) {\n        mbox->text = lv_label_create(mbox->content);\n        lv_label_set_text(mbox->text, txt);\n        lv_label_set_long_mode(mbox->text, LV_LABEL_LONG_WRAP);\n        lv_obj_set_width(mbox->text, lv_pct(100));\n    }\n\n    if(btn_txts) {\nmbox->btns = ",
    "raw_res": "lv_btnm_create(obj);",
    "prompt_res": "lv_btnmatrix_create(obj);",
    "gt": "lv_btnmatrix_create(obj);"
  },
  {
    "id": 2758,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar_header_dropdown.c",
    "input": "/**\n * @file lv_calendar_obj_dropdown.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n#include \"lv_calendar_header_dropdown.h\"\n#if LV_USE_CALENDAR_HEADER_DROPDOWN\n\n#include \"lv_calendar.h\"\n#include \"../../../widgets/lv_dropdown.h\"\n#include \"../../layouts/flex/lv_flex.h\"\n\n/*********************\n *      DEFINES\n *********************/\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic void my_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void year_event_cb(lv_event_t * e);\nstatic void month_event_cb(lv_event_t * e);\nstatic void value_changed_event_cb(lv_event_t * e);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\nconst lv_obj_class_t lv_calendar_header_dropdown_class = {\n    .base_class = &lv_obj_class,\n    .width_def = LV_PCT(100),\n    .height_def = LV_SIZE_CONTENT,\n    .constructor_cb = my_constructor\n};\n\nstatic const char * month_list = \"01\\n02\\n03\\n04\\n05\\n06\\n07\\n08\\n09\\n10\\n11\\n12\";\nstatic const char * year_list = {\n    \"2023\\n2022\\n2021\\n\"\n    \"2020\\n2019\\n2018\\n2017\\n2016\\n2015\\n2014\\n2013\\n2012\\n2011\\n2010\\n2009\\n2008\\n2007\\n2006\\n2005\\n2004\\n2003\\n2002\\n2001\\n\"\n    \"2000\\n1999\\n1998\\n1997\\n1996\\n1995\\n1994\\n1993\\n1992\\n1991\\n1990\\n1989\\n1988\\n1987\\n1986\\n1985\\n1984\\n1983\\n1982\\n1981\\n\"\n    \"1980\\n1979\\n1978\\n1977\\n1976\\n1975\\n1974\\n1973\\n1972\\n1971\\n1970\\n1969\\n1968\\n1967\\n1966\\n1965\\n1964\\n1963\\n1962\\n1961\\n\"\n    \"1960\\n1959\\n1958\\n1957\\n1956\\n1955\\n1954\\n1953\\n1952\\n1951\\n1950\\n1949\\n1948\\n1947\\n1946\\n1945\\n1944\\n1943\\n1942\\n1941\\n\"\n    \"1940\\n1939\\n1938\\n1937\\n1936\\n1935\\n1934\\n1933\\n1932\\n1931\\n1930\\n1929\\n1928\\n1927\\n1926\\n1925\\n1924\\n1923\\n1922\\n1921\\n\"\n    \"1920\\n1919\\n1918\\n1917\\n1916\\n1915\\n1914\\n1913\\n1912\\n1911\\n1910\\n1909\\n1908\\n1907\\n1906\\n1905\\n1904\\n1903\\n1902\\n1901\"\n};\n\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\nlv_obj_t * lv_calendar_header_dropdown_create(lv_obj_t * parent)\n{\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_calendar_header_dropdown_class, parent);\n    lv_obj_class_init_obj(obj);\n\n    return obj;\n}\n\n/**********************\n *  STATIC FUNCTIONS\n **********************/\n\nstatic void my_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)\n{\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    LV_UNUSED(class_p);\n\n    lv_obj_t * calendar = lv_obj_get_parent(obj);\n    lv_obj_move_to_index(obj, 0);\n    lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_ROW);\n\n    lv_obj_t * year_dd = lv_dropdown_create(obj);\n    lv_dropdown_set_options(year_dd, year_list);\n    lv_obj_add_event_cb(year_dd, year_event_cb, LV_EVENT_VALUE_CHANGED, calendar);\n    lv_obj_set_flex_grow(year_dd, 1);\n\n    lv_obj_t * month_dd = lv_dropdown_create(obj);\n    lv_dropdown_set_options(month_dd, month_list);\n    lv_obj_add_event_cb(month_dd, month_event_cb, LV_EVENT_VALUE_CHANGED, calendar);\n    lv_obj_set_flex_grow(month_dd, 1);\n\n    lv_obj_add_event_cb(obj, value_changed_event_cb, LV_EVENT_VALUE_CHANGED, NULL);\n    /*Refresh the drop downs*/\n    lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n}\n\nstatic void month_event_cb(lv_event_t * e)\n{\n    lv_obj_t * dropdown = lv_event_get_target(e);\n    lv_obj_t * calendar = lv_event_get_user_data(e);\n\n    uint16_t sel = lv_dropdown_get_selected(dropdown);\n\n    const lv_calendar_date_t * d;\n    d = lv_calendar_get_showed_date(calendar);\n    lv_calendar_date_t newd = *d;\n    newd.month = sel + 1;\n\n    lv_calendar_set_showed_date(calendar, newd.year, newd.month);\n}\n\nstatic void year_event_cb(lv_event_t * e)\n{\n    lv_obj_t * dropdown = lv_event_get_target(e);\n    lv_obj_t * calendar = lv_event_get_user_data(e);\n\n    uint16_t sel = lv_dropdown_get_selected(dropdown);\n\n    const lv_calendar_date_t * d;\n    d = lv_calendar_get_showed_date(calendar);\n    lv_calendar_date_t newd = *d;\n    newd.year = 2023 - sel;\n\n    lv_calendar_set_showed_date(calendar, newd.year, newd.month);\n}\n\nstatic void value_changed_event_cb(lv_event_t * e)\n{\n    lv_obj_t * header = lv_event_get_target(e);\n    lv_obj_t * calendar = lv_obj_get_parent(header);\n    const lv_calendar_date_t * cur_date = lv_calendar_get_showed_date(calendar);\n\nlv_obj_t * year_dd = ",
    "raw_res": "lv_dropdown_get_ddobj(header, 0);",
    "prompt_res": "lv_obj_get_child(header, 0);",
    "gt": "lv_obj_get_child(header, 0);"
  },
  {
    "id": 2765,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar_header_arrow.c",
    "input": "/**\n * @file lv_calendar_header_arrow.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n#include \"lv_calendar_header_arrow.h\"\n#if LV_USE_CALENDAR_HEADER_ARROW\n\n#include \"lv_calendar.h\"\n#include \"../../../widgets/lv_btn.h\"\n#include \"../../../widgets/lv_label.h\"\n#include \"../../layouts/flex/lv_flex.h\"\n\n/*********************\n *      DEFINES\n *********************/\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic void my_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void month_event_cb(lv_event_t * e);\nstatic void value_changed_event_cb(lv_event_t * e);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\nconst lv_obj_class_t lv_calendar_header_arrow_class = {\n    .base_class = &lv_obj_class,\n    .constructor_cb = my_constructor,\n    .width_def = LV_PCT(100),\n    .height_def = LV_DPI_DEF / 3\n};\n\nstatic const char * month_names_def[12] = LV_CALENDAR_DEFAULT_MONTH_NAMES;\n\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\nlv_obj_t * lv_calendar_header_arrow_create(lv_obj_t * parent)\n{\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_calendar_header_arrow_class, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}\n\n/**********************\n *  STATIC FUNCTIONS\n **********************/\n\nstatic void my_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)\n{\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    LV_UNUSED(class_p);\n\n    lv_obj_move_to_index(obj, 0);\n\n    lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_ROW);\n    lv_obj_set_flex_align(obj, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_START);\n\n    lv_obj_t * mo_prev = lv_btn_create(obj);\n    lv_obj_set_style_bg_img_src(mo_prev, LV_SYMBOL_LEFT, 0);\n    lv_obj_set_height(mo_prev, lv_pct(100));\n    lv_obj_update_layout(mo_prev);\n    lv_coord_t btn_size = lv_obj_get_height(mo_prev);\n    lv_obj_set_width(mo_prev, btn_size);\n\n    lv_obj_add_event_cb(mo_prev, month_event_cb, LV_EVENT_CLICKED, NULL);\n    lv_obj_clear_flag(mo_prev, LV_OBJ_FLAG_CLICK_FOCUSABLE);\n\n    lv_obj_t * label = lv_label_create(obj);\n    lv_label_set_long_mode(label, LV_LABEL_LONG_SCROLL_CIRCULAR);\n    lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_CENTER, 0);\n    lv_obj_set_flex_grow(label, 1);\n\n    lv_obj_t * mo_next = lv_btn_create(obj);\n    lv_obj_set_style_bg_img_src(mo_next, LV_SYMBOL_RIGHT, 0);\n    lv_obj_set_size(mo_next, btn_size, btn_size);\n\n    lv_obj_add_event_cb(mo_next, month_event_cb, LV_EVENT_CLICKED, NULL);\n    lv_obj_clear_flag(mo_next, LV_OBJ_FLAG_CLICK_FOCUSABLE);\n\n    lv_obj_add_event_cb(obj, value_changed_event_cb, LV_EVENT_VALUE_CHANGED, NULL);\n    /*Refresh the drop downs*/\n    lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n}\n\nstatic void month_event_cb(lv_event_t * e)\n{\n    lv_obj_t * btn = lv_event_get_target(e);\n\nlv_obj_t * header = ",
    "raw_res": "lv_event_get_user_data(e);",
    "prompt_res": "lv_obj_get_parent(btn);",
    "gt": "lv_obj_get_parent(btn);"
  },
  {
    "id": 2779,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/widgets/led/lv_led.c",
    "input": "/**\n * @file lv_led.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n#include \"lv_led.h\"\n#if LV_USE_LED\n\n#include \"../../../misc/lv_assert.h\"\n\n/*********************\n *      DEFINES\n *********************/\n#define MY_CLASS &lv_led_class\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic void lv_led_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void lv_led_event(const lv_obj_class_t * class_p, lv_event_t * e);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\nconst lv_obj_class_t lv_led_class  = {\n    .base_class = &lv_obj_class,\n    .constructor_cb = lv_led_constructor,\n    .width_def = LV_DPI_DEF / 5,\n    .height_def = LV_DPI_DEF / 5,\n    .event_cb = lv_led_event,\n    .instance_size = sizeof(lv_led_t),\n};\n\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\n/**\n * Create a led objects\n * @param par pointer to an object, it will be the parent of the new led\n * @return pointer to the created led\n */\nlv_obj_t * lv_led_create(lv_obj_t * parent)\n{\n    LV_LOG_INFO(\"begin\");\nlv_obj_t * obj = ",
    "raw_res": "lv_obj_create(parent, NULL);",
    "prompt_res": "lv_obj_class_create_obj(MY_CLASS, parent);",
    "gt": "lv_obj_class_create_obj(MY_CLASS, parent);"
  },
  {
    "id": 2795,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/widgets/led/lv_led.c",
    "input": "/**\n * @file lv_led.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n#include \"lv_led.h\"\n#if LV_USE_LED\n\n#include \"../../../misc/lv_assert.h\"\n\n/*********************\n *      DEFINES\n *********************/\n#define MY_CLASS &lv_led_class\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic void lv_led_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void lv_led_event(const lv_obj_class_t * class_p, lv_event_t * e);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\nconst lv_obj_class_t lv_led_class  = {\n    .base_class = &lv_obj_class,\n    .constructor_cb = lv_led_constructor,\n    .width_def = LV_DPI_DEF / 5,\n    .height_def = LV_DPI_DEF / 5,\n    .event_cb = lv_led_event,\n    .instance_size = sizeof(lv_led_t),\n};\n\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\n/**\n * Create a led objects\n * @param par pointer to an object, it will be the parent of the new led\n * @return pointer to the created led\n */\nlv_obj_t * lv_led_create(lv_obj_t * parent)\n{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}\n\n/*=====================\n * Setter functions\n *====================*/\n\n/**\n * Set the color of the LED\n * @param led       pointer to a LED object\n * @param color     the color of the the LED\n */\nvoid lv_led_set_color(lv_obj_t * obj, lv_color_t color)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_led_t * led = (lv_led_t *)obj;\n    led->color = color;\n    lv_obj_invalidate(obj);\n}\n\n/**\n * Set the brightness of a LED object\n * @param led pointer to a LED object\n * @param bright LV_LED_BRIGHT_MIN (max. dark) ... LV_LED_BRIGHT_MAX (max. light)\n */\nvoid lv_led_set_brightness(lv_obj_t * obj, uint8_t bright)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_led_t * led = (lv_led_t *)obj;\n    if(led->bright == bright) return;\n\n    led->bright = LV_CLAMP(LV_LED_BRIGHT_MIN, bright, LV_LED_BRIGHT_MAX);\n\n    /*Invalidate the object there fore it will be redrawn*/\n    lv_obj_invalidate(obj);\n}\n\n/**\n * Light on a LED\n * @param led pointer to a LED object\n */\nvoid lv_led_on(lv_obj_t * led)\n{\n    lv_led_set_brightness(led, LV_LED_BRIGHT_MAX);\n}\n\n/**\n * Light off a LED\n * @param led pointer to a LED object\n */\nvoid lv_led_off(lv_obj_t * led)\n{\n    lv_led_set_brightness(led, LV_LED_BRIGHT_MIN);\n}\n\n/**\n * Toggle the state of a LED\n * @param led pointer to a LED object\n */\nvoid lv_led_toggle(lv_obj_t * obj)\n{\n    uint8_t bright = lv_led_get_brightness(obj);\n    if(bright > (LV_LED_BRIGHT_MIN + LV_LED_BRIGHT_MAX) >> 1)\n        lv_led_off(obj);\n    else\n        lv_led_on(obj);\n}\n\n/*=====================\n * Getter functions\n *====================*/\n\n/**\n * Get the brightness of a LEd object\n * @param led pointer to LED object\n * @return bright 0 (max. dark) ... 255 (max. light)\n */\nuint8_t lv_led_get_brightness(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_led_t * led = (lv_led_t *)obj;\n    return led->bright;\n}\n\n/**********************\n *   STATIC FUNCTIONS\n **********************/\n\nstatic void lv_led_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)\n{\n    LV_UNUSED(class_p);\n    lv_led_t * led = (lv_led_t *)obj;\n    led->color = lv_theme_get_color_primary(obj);\n    led->bright = LV_LED_BRIGHT_MAX;\n}\n\nstatic void lv_led_event(const lv_obj_class_t * class_p, lv_event_t * e)\n{\n    LV_UNUSED(class_p);\n\n    lv_res_t res;\n\n    /* Call the ancestor's event handler */\n    lv_event_code_t code = lv_event_get_code(e);\n    if(code != LV_EVENT_DRAW_MAIN && code != LV_EVENT_DRAW_MAIN_END) {\n        res = lv_obj_event_base(MY_CLASS, e);\n        if(res != LV_RES_OK) return;\n    }\n\n    lv_obj_t * obj = lv_event_get_target(e);\n    if(code == LV_EVENT_DRAW_MAIN) {\n        /*Make darker colors in a temporary style according to the brightness*/\n        lv_led_t * led = (lv_led_t *)obj;\n\n        lv_draw_rect_dsc_t rect_dsc;\n        lv_draw_rect_dsc_init(&rect_dsc);\n        lv_obj_init_draw_rect_dsc(obj, LV_PART_MAIN, &rect_dsc);\n\n        /*Use the original colors brightness to modify color->led*/\n        rect_dsc.bg_color = lv_color_mix(led->color, lv_color_black(), lv_color_brightness(rect_dsc.bg_color));\n        rect_dsc.bg_grad_color = lv_color_mix(led->color, lv_color_black(), lv_color_brightness(rect_dsc.bg_grad_color));\n        rect_dsc.shadow_color = lv_color_mix(led->color, lv_color_black(), lv_color_brightness(rect_dsc.shadow_color));\n        rect_dsc.border_color = lv_color_mix(led->color, lv_color_black(), lv_color_brightness(rect_dsc.border_color));\n        rect_dsc.outline_color = lv_color_mix(led->color, lv_color_black(), lv_color_brightness(rect_dsc.outline_color));\n\n        /*Mix. the color with black proportionally with brightness*/\n        rect_dsc.bg_color   = lv_color_mix(rect_dsc.bg_color, lv_color_black(), led->bright);\n        rect_dsc.bg_grad_color   = lv_color_mix(rect_dsc.bg_grad_color, lv_color_black(), led->bright);\n        rect_dsc.border_color = lv_color_mix(rect_dsc.border_color, lv_color_black(), led->bright);\n        rect_dsc.shadow_color = lv_color_mix(rect_dsc.shadow_color, lv_color_black(), led->bright);\n        rect_dsc.outline_color = lv_color_mix(rect_dsc.outline_color, lv_color_black(), led->bright);\n\n        /*Set the current shadow width according to brightness proportionally between LV_LED_BRIGHT_OFF\n         * and LV_LED_BRIGHT_ON*/\n        rect_dsc.shadow_width = ((led->bright - LV_LED_BRIGHT_MIN) * rect_dsc.shadow_width) /\n                                (LV_LED_BRIGHT_MAX - LV_LED_BRIGHT_MIN);\n        rect_dsc.shadow_spread = ((led->bright - LV_LED_BRIGHT_MIN) * rect_dsc.shadow_spread) /\n                                 (LV_LED_BRIGHT_MAX - LV_LED_BRIGHT_MIN);\n\nconst lv_area_t * clip_area = ",
    "raw_res": "lv_event_get_clip_area(e);",
    "prompt_res": "lv_event_get_param(e);",
    "gt": "lv_event_get_param(e);"
  },
  {
    "id": 2864,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/libs/rlottie/lv_rlottie.c",
    "input": "/**\n * @file lv_rlottie.c\n *\n */\n\n /*********************\n  *      INCLUDES\n  *********************/\n\n#include \"lv_rlottie.h\"\n#if LV_USE_RLOTTIE\n\n/*********************\n*      DEFINES\n*********************/\n#define MY_CLASS &lv_rlottie_class\n\n/**********************\n*      TYPEDEFS\n**********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic void lv_rlottie_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void lv_rlottie_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void next_frame_task_cb(lv_timer_t* t);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\nconst lv_obj_class_t lv_rlottie_class = {\n    .constructor_cb = lv_rlottie_constructor,\n    .destructor_cb = lv_rlottie_destructor,\n    .instance_size = sizeof(lv_rlottie_t),\n    .base_class = &lv_img_class\n};\n\nstatic lv_coord_t create_width;\nstatic lv_coord_t create_height;\nstatic const char* rlottie_desc_create;\nstatic const char* path_create;\n\n/**********************\n *      MACROS\n **********************/\n\n /**********************\n  *   GLOBAL FUNCTIONS\n  **********************/\n\nlv_obj_t* lv_rlottie_create_from_file(lv_obj_t* parent, lv_coord_t width, lv_coord_t height, const char* path)\n{\n\n    create_width = width;\n    create_height = height;\n    path_create = path;\n    rlottie_desc_create = NULL;\n\n    LV_LOG_INFO(\"begin\");\nlv_obj_t * obj = ",
    "raw_res": "lv_img_create(parent);",
    "prompt_res": "lv_obj_class_create_obj(MY_CLASS, parent);",
    "gt": "lv_obj_class_create_obj(MY_CLASS, parent);"
  },
  {
    "id": 2904,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/libs/png/lv_png.c",
    "input": "/**\n * @file lv_png.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n#include \"../../../lvgl.h\"\n#if LV_USE_PNG\n\n#include \"lv_png.h\"\n#include \"lodepng.h\"\n#include <stdlib.h>\n\n#if LV_USE_SUNXIFB_G2D_BLEND\n#include \"../../../../../lv_drivers/display/sunximem.h\"\n#endif /* LV_USE_SUNXIFB_G2D_BLEND */\n\n/*********************\n *      DEFINES\n *********************/\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic lv_res_t decoder_info(struct _lv_img_decoder_t * decoder, const void * src, lv_img_header_t * header);\nstatic lv_res_t decoder_open(lv_img_decoder_t * dec, lv_img_decoder_dsc_t * dsc);\nstatic void decoder_close(lv_img_decoder_t * dec, lv_img_decoder_dsc_t * dsc);\nstatic void convert_color_depth(uint8_t * img, uint32_t px_cnt);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\n\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\n/**\n * Register the PNG decoder functions in LittlevGL\n */\nvoid lv_png_init(void)\n{\n    lv_img_decoder_t * dec = lv_img_decoder_create();\n    lv_img_decoder_set_info_cb(dec, decoder_info);\n    lv_img_decoder_set_open_cb(dec, decoder_open);\n    lv_img_decoder_set_close_cb(dec, decoder_close);\n}\n\n/**********************\n *   STATIC FUNCTIONS\n **********************/\n\n/**\n * Get info about a PNG image\n * @param src can be file name or pointer to a C array\n * @param header store the info here\n * @return LV_RES_OK: no error; LV_RES_INV: can't get the info\n */\nstatic lv_res_t decoder_info(struct _lv_img_decoder_t * decoder, const void * src, lv_img_header_t * header)\n{\n    (void) decoder; /*Unused*/\n     lv_img_src_t src_type = lv_img_src_get_type(src);          /*Get the source type*/\n\n     /*If it's a PNG file...*/\n     if(src_type == LV_IMG_SRC_FILE) {\n         const char * fn = src;\n         if(!strcmp(&fn[strlen(fn) - 3], \"png\")) {              /*Check the extension*/\n\n             /* Read the width and height from the file. They have a constant location:\n              * [16..23]: width\n              * [24..27]: height\n              */\n             uint32_t size[2];\n             lv_fs_file_t f;\nlv_fs_res_t res = ",
    "raw_res": "lv_fs_open(&f, src, LV_FS_MODE_RD);",
    "prompt_res": "lv_fs_open(&f, fn, LV_FS_MODE_RD);",
    "gt": "lv_fs_open(&f, fn, LV_FS_MODE_RD);"
  },
  {
    "id": 2917,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/others/snapshot/lv_snapshot.c",
    "input": "/**\n * @file lv_snapshot.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n#include \"lv_snapshot.h\"\n#if LV_USE_SNAPSHOT\n\n#include <stdbool.h>\n#include \"../../../core/lv_disp.h\"\n#include \"../../../core/lv_refr.h\"\n/*********************\n *      DEFINES\n *********************/\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\n\n/**********************\n *  STATIC VARIABLES\n **********************/\n\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\n/** Get the buffer needed for object snapshot image.\n *\n * @param obj    The object to generate snapshot.\n * @param cf     color format for generated image.\n *\n * @return the buffer size needed in bytes\n */\nuint32_t lv_snapshot_buf_size_needed(lv_obj_t * obj, lv_img_cf_t cf)\n{\n    switch(cf) {\n        case LV_IMG_CF_TRUE_COLOR_ALPHA:\n        case LV_IMG_CF_ALPHA_1BIT:\n        case LV_IMG_CF_ALPHA_2BIT:\n        case LV_IMG_CF_ALPHA_4BIT:\n        case LV_IMG_CF_ALPHA_8BIT:\n            break;\n        default:\n            return 0;\n    }\n\n    lv_obj_update_layout(obj);\n\n    /*Width and height determine snapshot image size.*/\n    lv_coord_t w = lv_obj_get_width(obj);\n    lv_coord_t h = lv_obj_get_height(obj);\n    lv_coord_t ext_size = _lv_obj_get_ext_draw_size(obj);\n    w += ext_size * 2;\n    h += ext_size * 2;\n\n    uint8_t px_size = lv_img_cf_get_px_size(cf);\n    return w * h * ((px_size + 7) >> 3);\n}\n\n/** Take snapshot for object with its children, save image info to provided buffer.\n *\n * @param obj    The object to generate snapshot.\n * @param cf     color format for generated image.\n * @param dsc    image descriptor to store the image result.\n * @param buf    the buffer to store image data.\n * @param buff_size provided buffer size in bytes.\n *\n * @return LV_RES_OK on success, LV_RES_INV on error.\n */\nlv_res_t lv_snapshot_take_to_buf(lv_obj_t * obj, lv_img_cf_t cf, lv_img_dsc_t * dsc, void * buf, uint32_t buff_size)\n{\n    LV_ASSERT(dsc);\n    LV_ASSERT(buf);\n\n    switch(cf) {\n        case LV_IMG_CF_TRUE_COLOR_ALPHA:\n        case LV_IMG_CF_ALPHA_1BIT:\n        case LV_IMG_CF_ALPHA_2BIT:\n        case LV_IMG_CF_ALPHA_4BIT:\n        case LV_IMG_CF_ALPHA_8BIT:\n            break;\n        default:\n            return LV_RES_INV;\n    }\n\n    if(lv_snapshot_buf_size_needed(obj, cf) > buff_size)\n        return LV_RES_INV;\n\n    /*Width and height determine snapshot image size.*/\n    lv_coord_t w = lv_obj_get_width(obj);\n    lv_coord_t h = lv_obj_get_height(obj);\n    lv_coord_t ext_size = _lv_obj_get_ext_draw_size(obj);\n    w += ext_size * 2;\n    h += ext_size * 2;\n\n    /*Backup obj original info.*/\n    lv_obj_t * parent_old = lv_obj_get_parent(obj);\n    lv_area_t coords_bkp;\n    lv_area_copy(&coords_bkp, &obj->coords);\n\n    lv_memset(buf, 0x00, buff_size);\n    lv_memset_00(dsc, sizeof(lv_img_dsc_t));\n\n    /*We are safe to use stack for below variables since disp will be\n     * unregistered when function returns. */\n    lv_disp_t * disp;\n    lv_disp_drv_t driver;\n    lv_disp_draw_buf_t draw_buf;\n\n    lv_disp_draw_buf_init(&draw_buf, buf, NULL, w * h);\n\n    lv_disp_drv_init(&driver);\n    driver.draw_buf = &draw_buf;\n    driver.hor_res = w;\n    driver.ver_res = h;\n    lv_disp_drv_use_generic_set_px_cb(&driver, cf);\n\ndisp = ",
    "raw_res": "lv_disp_create(NULL);",
    "prompt_res": "lv_disp_drv_register(&driver);",
    "gt": "lv_disp_drv_register(&driver);"
  },
  {
    "id": 2932,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/tests/src/test_cases/test_arc.c",
    "input": "#if LV_BUILD_TEST\n#include \"../lvgl.h\"\n\n#include \"unity/unity.h\"\n#include \"lv_test_indev.h\"\n\n/* This function runs before each test */\nvoid setUp(void);\n\nvoid test_arc_creation_successfull(void);\nvoid test_arc_should_truncate_to_max_range_when_new_value_exceeds_it(void);\nvoid test_arc_should_truncate_to_min_range_when_new_value_is_inferior(void);\nvoid test_arc_should_update_value_after_updating_range(void);\nvoid test_arc_should_update_angles_when_changing_to_symmetrical_mode(void);\nvoid test_arc_should_update_angles_when_changing_to_symmetrical_mode_value_more_than_middle_range(void);\nvoid test_arc_angles_when_reversed(void);\n\nstatic lv_obj_t *active_screen = NULL;\nstatic lv_obj_t *arc = NULL;\nstatic uint32_t event_cnt;\n\nstatic void dummy_event_cb(lv_event_t * e);\n\nvoid setUp(void)\n{\nactive_screen = ",
    "raw_res": "lv_obj_create(NULL, NULL);",
    "prompt_res": "lv_scr_act();",
    "gt": "lv_scr_act();"
  },
  {
    "id": 2941,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/tests/src/test_cases/test_checkbox.c",
    "input": "#if LV_BUILD_TEST\n#include \"../lvgl.h\"\n\n#include \"unity/unity.h\"\n\n#include \"lv_test_indev.h\"\n\nvoid test_checkbox_creation_successfull(void);\nvoid test_checkbox_should_call_event_handler_on_click_when_enabled(void);\nvoid test_checkbox_should_have_default_text_when_created(void);\nvoid test_checkbox_should_return_dinamically_allocated_text(void);\nvoid test_checkbox_should_allocate_memory_for_static_text(void);\n\nstatic lv_obj_t *active_screen = NULL;\nstatic lv_obj_t *checkbox = NULL;\n\nstatic volatile bool event_called = false;\n\nstatic void event_handler(lv_event_t *e)\n{\n    lv_event_code_t code = lv_event_get_code(e);\n\n    if (LV_EVENT_VALUE_CHANGED == code) {\n        event_called = true;\n    }\n}\n\nvoid test_checkbox_creation_successfull(void)\n{\nactive_screen = ",
    "raw_res": "lv_obj_create(NULL, NULL);",
    "prompt_res": "lv_scr_act();",
    "gt": "lv_scr_act();"
  },
  {
    "id": 2942,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/tests/src/test_cases/test_checkbox.c",
    "input": "#if LV_BUILD_TEST\n#include \"../lvgl.h\"\n\n#include \"unity/unity.h\"\n\n#include \"lv_test_indev.h\"\n\nvoid test_checkbox_creation_successfull(void);\nvoid test_checkbox_should_call_event_handler_on_click_when_enabled(void);\nvoid test_checkbox_should_have_default_text_when_created(void);\nvoid test_checkbox_should_return_dinamically_allocated_text(void);\nvoid test_checkbox_should_allocate_memory_for_static_text(void);\n\nstatic lv_obj_t *active_screen = NULL;\nstatic lv_obj_t *checkbox = NULL;\n\nstatic volatile bool event_called = false;\n\nstatic void event_handler(lv_event_t *e)\n{\n    lv_event_code_t code = lv_event_get_code(e);\n\n    if (LV_EVENT_VALUE_CHANGED == code) {\n        event_called = true;\n    }\n}\n\nvoid test_checkbox_creation_successfull(void)\n{\n    active_screen = lv_scr_act();\ncheckbox = ",
    "raw_res": "lv_checkbox_create(active_screen, NULL);",
    "prompt_res": "lv_checkbox_create(active_screen);",
    "gt": "lv_checkbox_create(active_screen);"
  }
]