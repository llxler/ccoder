[
  {
    "id": 15,
    "pkg": "YPS-Instrument3",
    "fpath": "prj/CPDM04/Projects/3rd/awtk-widget-qr/src/qr/qrspec.c",
    "input": "﻿/*\n * qrencode - QR Code encoder\n *\n * QR Code specification in convenient format.\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * The following data / specifications are taken from\n * \"Two dimensional symbol -- QR-code -- Basic Specification\" (JIS X0510:2004)\n *  or\n * \"Automatic identification and data capture techniques --\n *  QR Code 2005 bar code symbology specification\" (ISO/IEC 18004:2006)\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n# include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"qrspec.h\"\n#include \"qrinput.h\"\n\n/******************************************************************************\n * Version and capacity\n *****************************************************************************/\n\ntypedef struct {\n\tint width; //< Edge length of the symbol\n\tint words;  //< Data capacity (bytes)\n\tint remainder; //< Remainder bit (bits)\n\tint ec[4];  //< Number of ECC code (bytes)\n} QRspec_Capacity;\n\n/**\n * Table of the capacity of symbols\n * See Table 1 (pp.13) and Table 12-16 (pp.30-36), JIS X0510:2004.\n */\nstatic const QRspec_Capacity qrspecCapacity[QRSPEC_VERSION_MAX + 1] = {\n\t{  0,    0, 0, {   0,    0,    0,    0}},\n\t{ 21,   26, 0, {   7,   10,   13,   17}}, // 1\n\t{ 25,   44, 7, {  10,   16,   22,   28}},\n\t{ 29,   70, 7, {  15,   26,   36,   44}},\n\t{ 33,  100, 7, {  20,   36,   52,   64}},\n\t{ 37,  134, 7, {  26,   48,   72,   88}}, // 5\n\t{ 41,  172, 7, {  36,   64,   96,  112}},\n\t{ 45,  196, 0, {  40,   72,  108,  130}},\n\t{ 49,  242, 0, {  48,   88,  132,  156}},\n\t{ 53,  292, 0, {  60,  110,  160,  192}},\n\t{ 57,  346, 0, {  72,  130,  192,  224}}, //10\n\t{ 61,  404, 0, {  80,  150,  224,  264}},\n\t{ 65,  466, 0, {  96,  176,  260,  308}},\n\t{ 69,  532, 0, { 104,  198,  288,  352}},\n\t{ 73,  581, 3, { 120,  216,  320,  384}},\n\t{ 77,  655, 3, { 132,  240,  360,  432}}, //15\n\t{ 81,  733, 3, { 144,  280,  408,  480}},\n\t{ 85,  815, 3, { 168,  308,  448,  532}},\n\t{ 89,  901, 3, { 180,  338,  504,  588}},\n\t{ 93,  991, 3, { 196,  364,  546,  650}},\n\t{ 97, 1085, 3, { 224,  416,  600,  700}}, //20\n\t{101, 1156, 4, { 224,  442,  644,  750}},\n\t{105, 1258, 4, { 252,  476,  690,  816}},\n\t{109, 1364, 4, { 270,  504,  750,  900}},\n\t{113, 1474, 4, { 300,  560,  810,  960}},\n\t{117, 1588, 4, { 312,  588,  870, 1050}}, //25\n\t{121, 1706, 4, { 336,  644,  952, 1110}},\n\t{125, 1828, 4, { 360,  700, 1020, 1200}},\n\t{129, 1921, 3, { 390,  728, 1050, 1260}},\n\t{133, 2051, 3, { 420,  784, 1140, 1350}},\n\t{137, 2185, 3, { 450,  812, 1200, 1440}}, //30\n\t{141, 2323, 3, { 480,  868, 1290, 1530}},\n\t{145, 2465, 3, { 510,  924, 1350, 1620}},\n\t{149, 2611, 3, { 540,  980, 1440, 1710}},\n\t{153, 2761, 3, { 570, 1036, 1530, 1800}},\n\t{157, 2876, 0, { 570, 1064, 1590, 1890}}, //35\n\t{161, 3034, 0, { 600, 1120, 1680, 1980}},\n\t{165, 3196, 0, { 630, 1204, 1770, 2100}},\n\t{169, 3362, 0, { 660, 1260, 1860, 2220}},\n\t{173, 3532, 0, { 720, 1316, 1950, 2310}},\n\t{177, 3706, 0, { 750, 1372, 2040, 2430}} //40\n};\n\nint QRspec_getDataLength(int version, QRecLevel level)\n{\n\treturn qrspecCapacity[version].words - qrspecCapacity[version].ec[level];\n}\n\nint QRspec_getECCLength(int version, QRecLevel level)\n{\n\treturn qrspecCapacity[version].ec[level];\n}\n\nint QRspec_getMinimumVersion(int size, QRecLevel level)\n{\n\tint i;\n\tint words;\n\n\tfor(i = 1; i <= QRSPEC_VERSION_MAX; i++) {\n\t\twords  = qrspecCapacity[i].words - qrspecCapacity[i].ec[level];\n\t\tif(words >= size) return i;\n\t}\n\n\treturn QRSPEC_VERSION_MAX;\n}\n\nint QRspec_getWidth(int version)\n{\n\treturn qrspecCapacity[version].width;\n}\n\nint QRspec_getRemainder(int version)\n{\n\treturn qrspecCapacity[version].remainder;\n}\n\n/******************************************************************************\n * Length indicator\n *****************************************************************************/\n\nstatic const int lengthTableBits[4][3] = {\n\t{10, 12, 14},\n\t{ 9, 11, 13},\n\t{ 8, 16, 16},\n\t{ 8, 10, 12}\n};\n\nint QRspec_lengthIndicator(QRencodeMode mode, int version)\n{\n\tint l;\n\n\tif(!QRinput_isSplittableMode(mode)) return 0;\n\tif(version <= 9) {\n\t\tl = 0;\n\t} else if(version <= 26) {\n\t\tl = 1;\n\t} else {\n\t\tl = 2;\n\t}\n\n\treturn lengthTableBits[mode][l];\n}\n\nint QRspec_maximumWords(QRencodeMode mode, int version)\n{\n\tint l;\n\tint bits;\n\tint words;\n\n\tif(!QRinput_isSplittableMode(mode)) return 0;\n\tif(version <= 9) {\n\t\tl = 0;\n\t} else if(version <= 26) {\n\t\tl = 1;\n\t} else {\n\t\tl = 2;\n\t}\n\n\tbits = lengthTableBits[mode][l];\n\twords = (1 << bits) - 1;\n\tif(mode == QR_MODE_KANJI) {\n\t\twords *= 2; // the number of bytes is required\n\t}\n\n\treturn words;\n}\n\n/******************************************************************************\n * Error correction code\n *****************************************************************************/\n\n/**\n * Table of the error correction code (Reed-Solomon block)\n * See Table 12-16 (pp.30-36), JIS X0510:2004.\n */\nstatic const int eccTable[QRSPEC_VERSION_MAX+1][4][2] = {\n\t{{ 0,  0}, { 0,  0}, { 0,  0}, { 0,  0}},\n\t{{ 1,  0}, { 1,  0}, { 1,  0}, { 1,  0}}, // 1\n\t{{ 1,  0}, { 1,  0}, { 1,  0}, { 1,  0}},\n\t{{ 1,  0}, { 1,  0}, { 2,  0}, { 2,  0}},\n\t{{ 1,  0}, { 2,  0}, { 2,  0}, { 4,  0}},\n\t{{ 1,  0}, { 2,  0}, { 2,  2}, { 2,  2}}, // 5\n\t{{ 2,  0}, { 4,  0}, { 4,  0}, { 4,  0}},\n\t{{ 2,  0}, { 4,  0}, { 2,  4}, { 4,  1}},\n\t{{ 2,  0}, { 2,  2}, { 4,  2}, { 4,  2}},\n\t{{ 2,  0}, { 3,  2}, { 4,  4}, { 4,  4}},\n\t{{ 2,  2}, { 4,  1}, { 6,  2}, { 6,  2}}, //10\n\t{{ 4,  0}, { 1,  4}, { 4,  4}, { 3,  8}},\n\t{{ 2,  2}, { 6,  2}, { 4,  6}, { 7,  4}},\n\t{{ 4,  0}, { 8,  1}, { 8,  4}, {12,  4}},\n\t{{ 3,  1}, { 4,  5}, {11,  5}, {11,  5}},\n\t{{ 5,  1}, { 5,  5}, { 5,  7}, {11,  7}}, //15\n\t{{ 5,  1}, { 7,  3}, {15,  2}, { 3, 13}},\n\t{{ 1,  5}, {10,  1}, { 1, 15}, { 2, 17}},\n\t{{ 5,  1}, { 9,  4}, {17,  1}, { 2, 19}},\n\t{{ 3,  4}, { 3, 11}, {17,  4}, { 9, 16}},\n\t{{ 3,  5}, { 3, 13}, {15,  5}, {15, 10}}, //20\n\t{{ 4,  4}, {17,  0}, {17,  6}, {19,  6}},\n\t{{ 2,  7}, {17,  0}, { 7, 16}, {34,  0}},\n\t{{ 4,  5}, { 4, 14}, {11, 14}, {16, 14}},\n\t{{ 6,  4}, { 6, 14}, {11, 16}, {30,  2}},\n\t{{ 8,  4}, { 8, 13}, { 7, 22}, {22, 13}}, //25\n\t{{10,  2}, {19,  4}, {28,  6}, {33,  4}},\n\t{{ 8,  4}, {22,  3}, { 8, 26}, {12, 28}},\n\t{{ 3, 10}, { 3, 23}, { 4, 31}, {11, 31}},\n\t{{ 7,  7}, {21,  7}, { 1, 37}, {19, 26}},\n\t{{ 5, 10}, {19, 10}, {15, 25}, {23, 25}}, //30\n\t{{13,  3}, { 2, 29}, {42,  1}, {23, 28}},\n\t{{17,  0}, {10, 23}, {10, 35}, {19, 35}},\n\t{{17,  1}, {14, 21}, {29, 19}, {11, 46}},\n\t{{13,  6}, {14, 23}, {44,  7}, {59,  1}},\n\t{{12,  7}, {12, 26}, {39, 14}, {22, 41}}, //35\n\t{{ 6, 14}, { 6, 34}, {46, 10}, { 2, 64}},\n\t{{17,  4}, {29, 14}, {49, 10}, {24, 46}},\n\t{{ 4, 18}, {13, 32}, {48, 14}, {42, 32}},\n\t{{20,  4}, {40,  7}, {43, 22}, {10, 67}},\n\t{{19,  6}, {18, 31}, {34, 34}, {20, 61}},//40\n};\n\nvoid QRspec_getEccSpec(int version, QRecLevel level, int spec[5])\n{\n\tint b1, b2;\n\tint data, ecc;\n\n\tb1 = eccTable[version][level][0];\n\tb2 = eccTable[version][level][1];\n\tdata = QRspec_getDataLength(version, level);\necc  = ",
    "raw_res": "8 * (data + b1 + b2);",
    "prompt_res": "QRspec_getECCLength(version, level);",
    "gt": "QRspec_getECCLength(version, level);"
  },
  {
    "id": 17,
    "pkg": "YPS-Instrument3",
    "fpath": "prj/CPDM04/Projects/3rd/awtk-widget-qr/src/qr/split.c",
    "input": "﻿/*\n * qrencode - QR Code encoder\n *\n * Input data splitter.\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * The following data / specifications are taken from\n * \"Two dimensional symbol -- QR-code -- Basic Specification\" (JIS X0510:2004)\n *  or\n * \"Automatic identification and data capture techniques --\n *  QR Code 2005 bar code symbology specification\" (ISO/IEC 18004:2006)\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n# include \"config.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include \"qrencode.h\"\n#include \"qrinput.h\"\n#include \"qrspec.h\"\n#include \"split.h\"\n\n#define isdigit(__c__) ((unsigned char)((signed char)(__c__) - '0') < 10)\n#define isalnum(__c__) (QRinput_lookAnTable(__c__) >= 0)\n\n#if !HAVE_STRDUP\n#undef strdup\nchar *strdup(const char *s)\n{\n\tsize_t len = strlen(s) + 1;\nvoid *newstring = ",
    "raw_res": "0;",
    "prompt_res": "malloc(len);",
    "gt": "malloc(len);"
  },
  {
    "id": 40,
    "pkg": "YPS-Instrument3",
    "fpath": "prj/CPDM04/Projects/3rd/awtk-widget-qr/src/qr/qrencode.c",
    "input": "﻿/*\n * qrencode - QR Code encoder\n *\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n# include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"qrencode.h\"\n#include \"qrspec.h\"\n#include \"mqrspec.h\"\n#include \"bitstream.h\"\n#include \"qrinput.h\"\n#include \"rsecc.h\"\n#include \"split.h\"\n#include \"mask.h\"\n#include \"mmask.h\"\n\n/******************************************************************************\n * Raw code\n *****************************************************************************/\n\ntypedef struct {\n\tint dataLength;\n\tint eccLength;\n\tunsigned char *data;\n\tunsigned char *ecc;\n} RSblock;\n\ntypedef struct {\n\tint version;\n\tint dataLength;\n\tint eccLength;\n\tunsigned char *datacode;\n\tunsigned char *ecccode;\n\tint b1;\n\tint blocks;\n\tRSblock *rsblock;\n\tint count;\n} QRRawCode;\n\nstatic void RSblock_initBlock(RSblock *block, int dl, unsigned char *data, int el, unsigned char *ecc)\n{\n\tblock->dataLength = dl;\n\tblock->data = data;\n\tblock->eccLength = el;\n\tblock->ecc = ecc;\n\n\tRSECC_encode((size_t)dl, (size_t)el, data, ecc);\n}\n\nstatic int RSblock_init(RSblock *blocks, int spec[5], unsigned char *data, unsigned char *ecc)\n{\n\tint i;\n\tRSblock *block;\n\tunsigned char *dp, *ep;\n\tint el, dl;\n\n\tdl = QRspec_rsDataCodes1(spec);\n\tel = QRspec_rsEccCodes1(spec);\n\n\tblock = blocks;\n\tdp = data;\n\tep = ecc;\n\tfor(i = 0; i < QRspec_rsBlockNum1(spec); i++) {\n\t\tRSblock_initBlock(block, dl, dp, el, ep);\n\t\tdp += dl;\n\t\tep += el;\n\t\tblock++;\n\t}\n\n\tif(QRspec_rsBlockNum2(spec) == 0) return 0;\n\n\tdl = QRspec_rsDataCodes2(spec);\n\tel = QRspec_rsEccCodes2(spec);\n\tfor(i = 0; i < QRspec_rsBlockNum2(spec); i++) {\n\t\tRSblock_initBlock(block, dl, dp, el, ep);\n\t\tdp += dl;\n\t\tep += el;\n\t\tblock++;\n\t}\n\n\treturn 0;\n}\n\nSTATIC_IN_RELEASE void QRraw_free(QRRawCode *raw);\nSTATIC_IN_RELEASE QRRawCode *QRraw_new(QRinput *input)\n{\n\tQRRawCode *raw;\n\tint spec[5], ret;\n\n\traw = (QRRawCode *)malloc(sizeof(QRRawCode));\n\tif(raw == NULL) return NULL;\n\n\traw->datacode = QRinput_getByteStream(input);\n\tif(raw->datacode == NULL) {\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\n\tQRspec_getEccSpec(input->version, input->level, spec);\n\n\traw->version = input->version;\n\traw->b1 = QRspec_rsBlockNum1(spec);\n\traw->dataLength = QRspec_rsDataLength(spec);\n\traw->eccLength = QRspec_rsEccLength(spec);\n\traw->ecccode = (unsigned char *)malloc((size_t)raw->eccLength);\n\tif(raw->ecccode == NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\n\traw->blocks = QRspec_rsBlockNum(spec);\n\traw->rsblock = (RSblock *)calloc((size_t)(raw->blocks), sizeof(RSblock));\n\tif(raw->rsblock == NULL) {\n\t\tQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\tret = RSblock_init(raw->rsblock, spec, raw->datacode, raw->ecccode);\n\tif(ret < 0) {\n\t\tQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\n\traw->count = 0;\n\n\treturn raw;\n}\n\n/**\n * Return a code (byte).\n * This function can be called iteratively.\n * @param raw raw code.\n * @return code\n */\nSTATIC_IN_RELEASE unsigned char QRraw_getCode(QRRawCode *raw)\n{\n\tint col, row;\n\tunsigned char ret;\n\n\tif(raw->count < raw->dataLength) {\n\t\trow = raw->count % raw->blocks;\n\t\tcol = raw->count / raw->blocks;\n\t\tif(col >= raw->rsblock[0].dataLength) {\n\t\t\trow += raw->b1;\n\t\t}\n\t\tret = raw->rsblock[row].data[col];\n\t} else if(raw->count < raw->dataLength + raw->eccLength) {\n\t\trow = (raw->count - raw->dataLength) % raw->blocks;\n\t\tcol = (raw->count - raw->dataLength) / raw->blocks;\n\t\tret = raw->rsblock[row].ecc[col];\n\t} else {\n\t\treturn 0;\n\t}\n\traw->count++;\n\treturn ret;\n}\n\nSTATIC_IN_RELEASE void QRraw_free(QRRawCode *raw)\n{\n\tif(raw != NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw->ecccode);\n\t\tfree(raw->rsblock);\n\t\tfree(raw);\n\t}\n}\n\n/******************************************************************************\n * Raw code for Micro QR Code\n *****************************************************************************/\n\ntypedef struct {\n\tint version;\n\tint dataLength;\n\tint eccLength;\n\tunsigned char *datacode;\n\tunsigned char *ecccode;\n\tRSblock *rsblock;\n\tint oddbits;\n\tint count;\n} MQRRawCode;\n\nSTATIC_IN_RELEASE void MQRraw_free(MQRRawCode *raw);\nSTATIC_IN_RELEASE MQRRawCode *MQRraw_new(QRinput *input)\n{\n\tMQRRawCode *raw;\n\n\traw = (MQRRawCode *)malloc(sizeof(MQRRawCode));\n\tif(raw == NULL) return NULL;\n\n\traw->version = input->version;\n\traw->dataLength = MQRspec_getDataLength(input->version, input->level);\n\traw->eccLength = MQRspec_getECCLength(input->version, input->level);\n\traw->oddbits = raw->dataLength * 8 - MQRspec_getDataLengthBit(input->version, input->level);\n\traw->datacode = QRinput_getByteStream(input);\n\tif(raw->datacode == NULL) {\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\traw->ecccode = (unsigned char *)malloc((size_t)raw->eccLength);\n\tif(raw->ecccode == NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\n\traw->rsblock = (RSblock *)calloc(1, sizeof(RSblock));\n\tif(raw->rsblock == NULL) {\n\t\tMQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\n\tRSblock_initBlock(raw->rsblock, raw->dataLength, raw->datacode, raw->eccLength, raw->ecccode);\n\n\traw->count = 0;\n\n\treturn raw;\n}\n\n/**\n * Return a code (byte).\n * This function can be called iteratively.\n * @param raw raw code.\n * @return code\n */\nSTATIC_IN_RELEASE unsigned char MQRraw_getCode(MQRRawCode *raw)\n{\n\tunsigned char ret;\n\n\tif(raw->count < raw->dataLength) {\n\t\tret = raw->datacode[raw->count];\n\t} else if(raw->count < raw->dataLength + raw->eccLength) {\n\t\tret = raw->ecccode[raw->count - raw->dataLength];\n\t} else {\n\t\treturn 0;\n\t}\n\traw->count++;\n\treturn ret;\n}\n\nSTATIC_IN_RELEASE void MQRraw_free(MQRRawCode *raw)\n{\n\tif(raw != NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw->ecccode);\n\t\tfree(raw->rsblock);\n\t\tfree(raw);\n\t}\n}\n\n\n/******************************************************************************\n * Frame filling\n *****************************************************************************/\n\ntypedef struct {\n\tint width;\n\tunsigned char *frame;\n\tint x, y;\n\tint dir;\n\tint bit;\n\tint mqr;\n} FrameFiller;\n\nstatic void FrameFiller_set(FrameFiller *filler, int width, unsigned char *frame, int mqr)\n{\n\tfiller->width = width;\n\tfiller->frame = frame;\n\tfiller->x = width - 1;\n\tfiller->y = width - 1;\n\tfiller->dir = -1;\n\tfiller->bit = -1;\n\tfiller->mqr = mqr;\n}\n\nstatic unsigned char *FrameFiller_next(FrameFiller *filler)\n{\n\tunsigned char *p;\n\tint x, y, w;\n\n\tif(filler->bit == -1) {\n\t\tfiller->bit = 0;\n\t\treturn filler->frame + filler->y * filler->width + filler->x;\n\t}\n\n\tx = filler->x;\n\ty = filler->y;\n\tp = filler->frame;\n\tw = filler->width;\n\n\tif(filler->bit == 0) {\n\t\tx--;\n\t\tfiller->bit++;\n\t} else {\n\t\tx++;\n\t\ty += filler->dir;\n\t\tfiller->bit--;\n\t}\n\n\tif(filler->dir < 0) {\n\t\tif(y < 0) {\n\t\t\ty = 0;\n\t\t\tx -= 2;\n\t\t\tfiller->dir = 1;\n\t\t\tif(!filler->mqr && x == 6) {\n\t\t\t\tx--;\n\t\t\t\ty = 9;\n\t\t\t}\n\t\t}\n\t} else if(y == w) {\n\t\ty = w - 1;\n\t\tx -= 2;\n\t\tfiller->dir = -1;\n\t\tif(!filler->mqr && x == 6) {\n\t\t\tx--;\n\t\t\ty -= 8;\n\t\t}\n\t}\n\tif(x < 0 || y < 0) return NULL;\n\n\tfiller->x = x;\n\tfiller->y = y;\n\n\tif(p[y * w + x] & 0x80) {\n\t\t// This tail recursion could be optimized.\n\t\treturn FrameFiller_next(filler);\n\t}\n\treturn &p[y * w + x];\n}\n\n#ifdef WITH_TESTS\nunsigned char *FrameFiller_test(int version)\n{\n\tint width;\n\tunsigned char *frame, *p;\n\tint i, length;\n\tFrameFiller filler;\n\n\twidth = QRspec_getWidth(version);\n\tframe = QRspec_newFrame(version);\n\tif(frame == NULL) return NULL;\n\tFrameFiller_set(&filler, width, frame, 0);\n\tlength = QRspec_getDataLength(version, QR_ECLEVEL_L) * 8\n\t       + QRspec_getECCLength(version, QR_ECLEVEL_L) * 8\n\t\t   + QRspec_getRemainder(version);\n\tfor(i = 0; i < length; i++) {\n\t\tp = FrameFiller_next(&filler);\n\t\tif(p == NULL) {\n\t\t\tfree(frame);\n\t\t\treturn NULL;\n\t\t}\n\t\t*p = (unsigned char)(i & 0x7f) | 0x80;\n\t}\n\treturn frame;\n}\n\nunsigned char *FrameFiller_testMQR(int version)\n{\n\tint width;\n\tunsigned char *frame, *p;\n\tint i, length;\n\tFrameFiller filler;\n\n\twidth = MQRspec_getWidth(version);\n\tframe = MQRspec_newFrame(version);\n\tif(frame == NULL) return NULL;\n\tFrameFiller_set(&filler, width, frame, 1);\n\tlength = MQRspec_getDataLengthBit(version, QR_ECLEVEL_L)\n\t       + MQRspec_getECCLength(version, QR_ECLEVEL_L) * 8;\n\tfor(i = 0; i < length; i++) {\n\t\tp = FrameFiller_next(&filler);\n\t\tif(p == NULL) {\n\t\t\tfprintf(stderr, \"Frame filler run over the frame!\\n\");\n\t\t\treturn frame;\n\t\t}\n\t\t*p = (unsigned char)(i & 0x7f) | 0x80;\n\t}\n\treturn frame;\n}\n#endif\n\n\n/******************************************************************************\n * QR-code encoding\n *****************************************************************************/\n\nSTATIC_IN_RELEASE QRcode *QRcode_new(int version, int width, unsigned char *data)\n{\n\tQRcode *qrcode;\n\n\tqrcode = (QRcode *)malloc(sizeof(QRcode));\n\tif(qrcode == NULL) return NULL;\n\n\tqrcode->version = version;\n\tqrcode->width = width;\n\tqrcode->data = data;\n\n\treturn qrcode;\n}\n\nvoid QRcode_free(QRcode *qrcode)\n{\n\tif(qrcode != NULL) {\n\t\tfree(qrcode->data);\n\t\tfree(qrcode);\n\t}\n}\n\nSTATIC_IN_RELEASE QRcode *QRcode_encodeMask(QRinput *input, int mask)\n{\n\tint width, version;\n\tQRRawCode *raw;\n\tunsigned char *frame, *masked, *p, code, bit;\n\tint i, j;\n\tQRcode *qrcode = NULL;\n\tFrameFiller filler;\n\n\tif(input->mqr) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(input->version < 0 || input->version > QRSPEC_VERSION_MAX) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(input->level > QR_ECLEVEL_H) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\traw = QRraw_new(input);\n\tif(raw == NULL) return NULL;\n\n\tversion = raw->version;\n\twidth = QRspec_getWidth(version);\n\tframe = QRspec_newFrame(version);\n\tif(frame == NULL) {\n\t\tQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\tFrameFiller_set(&filler, width, frame, 0);\n\n\t/* interleaved data and ecc codes */\n\tfor(i = 0; i < raw->dataLength; i++) {\n\t\tcode = QRraw_getCode(raw);\n\t\tbit = 0x80;\n\t\tfor(j = 0; j < 8; j++) {\n\t\t\tp = FrameFiller_next(&filler);\n\t\t\tif(p == NULL)  goto EXIT;\n\t\t\t*p = ((bit & code) != 0);\n\t\t\tbit = bit >> 1;\n\t\t}\n\t}\n\tfor(i = 0; i < raw->eccLength; i++) {\n\t\tcode = QRraw_getCode(raw);\n\t\tbit = 0x80;\n\t\tfor(j = 0; j < 8; j++) {\n\t\t\tp = FrameFiller_next(&filler);\n\t\t\tif(p == NULL)  goto EXIT;\n\t\t\t*p = 0x02 | ((bit & code) != 0);\n\t\t\tbit = bit >> 1;\n\t\t}\n\t}\n\tQRraw_free(raw);\n\traw = NULL;\n\t/* remainder bits */\n\tj = QRspec_getRemainder(version);\n\tfor(i = 0; i < j; i++) {\n\t\tp = FrameFiller_next(&filler);\n\t\tif(p == NULL)  goto EXIT;\n\t\t*p = 0x02;\n\t}\n\n\t/* masking */\n\tif(mask == -2) { // just for debug purpose\n\t\tmasked = (unsigned char *)malloc((size_t)(width * width));\n\t\tmemcpy(masked, frame, (size_t)(width * width));\n\t} else if(mask < 0) {\n\t\tmasked = Mask_mask(width, frame, input->level);\n\t} else {\n\t\tmasked = Mask_makeMask(width, frame, mask, input->level);\n\t}\n\tif(masked == NULL) {\n\t\tgoto EXIT;\n\t}\n\tqrcode = QRcode_new(version, width, masked);\n\tif(qrcode == NULL) {\n\t\tfree(masked);\n\t}\n\nEXIT:\n\tQRraw_free(raw);\n\tfree(frame);\n\treturn qrcode;\n}\n\nSTATIC_IN_RELEASE QRcode *QRcode_encodeMaskMQR(QRinput *input, int mask)\n{\n\tint width, version;\n\tMQRRawCode *raw;\n\tunsigned char *frame, *masked, *p, code, bit;\n\tint i, j, length;\n\tQRcode *qrcode = NULL;\n\tFrameFiller filler;\n\n\tif(!input->mqr) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(input->version <= 0 || input->version > MQRSPEC_VERSION_MAX) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(input->level > QR_ECLEVEL_Q) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\traw = MQRraw_new(input);\n\tif(raw == NULL) return NULL;\n\n\tversion = raw->version;\n\twidth = MQRspec_getWidth(version);\n\tframe = MQRspec_newFrame(version);\n\tif(frame == NULL) {\n\t\tMQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\tFrameFiller_set(&filler, width, frame, 1);\n\n\t/* interleaved data and ecc codes */\n\tfor(i = 0; i < raw->dataLength; i++) {\n\t\tcode = MQRraw_getCode(raw);\n\t\tbit = 0x80;\n\t\tif(raw->oddbits && i == raw->dataLength - 1) {\n\t\t\tlength = raw->oddbits;\n\t\t} else {\n\t\t\tlength = 8;\n\t\t}\n\t\tfor(j = 0; j < length; j++) {\n\t\t\tp = FrameFiller_next(&filler);\n\t\t\tif(p == NULL) goto EXIT;\n\t\t\t*p = ((bit & code) != 0);\n\t\t\tbit = bit >> 1;\n\t\t}\n\t}\n\tfor(i = 0; i < raw->eccLength; i++) {\n\t\tcode = MQRraw_getCode(raw);\n\t\tbit = 0x80;\n\t\tlength = 8;\n\t\tfor(j = 0; j < length; j++) {\n\t\t\tp = FrameFiller_next(&filler);\n\t\t\tif(p == NULL) goto EXIT;\n\t\t\t*p = 0x02 | ((bit & code) != 0);\n\t\t\tbit = bit >> 1;\n\t\t}\n\t}\n\tMQRraw_free(raw);\n\traw = NULL;\n\n\t/* masking */\n\tif(mask == -2) { // just for debug purpose\n\t\tmasked = (unsigned char *)malloc((size_t)(width * width));\n\t\tmemcpy(masked, frame, (size_t)(width * width));\n\t} else if(mask < 0) {\n\t\tmasked = MMask_mask(version, frame, input->level);\n\t} else {\nmasked = ",
    "raw_res": "0;",
    "prompt_res": "MMask_makeMask(version, frame, mask, input->level);",
    "gt": "MMask_makeMask(version, frame, mask, input->level);"
  },
  {
    "id": 41,
    "pkg": "YPS-Instrument3",
    "fpath": "prj/CPDM04/Projects/3rd/awtk-widget-qr/src/qr/qrencode.c",
    "input": "﻿/*\n * qrencode - QR Code encoder\n *\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n# include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"qrencode.h\"\n#include \"qrspec.h\"\n#include \"mqrspec.h\"\n#include \"bitstream.h\"\n#include \"qrinput.h\"\n#include \"rsecc.h\"\n#include \"split.h\"\n#include \"mask.h\"\n#include \"mmask.h\"\n\n/******************************************************************************\n * Raw code\n *****************************************************************************/\n\ntypedef struct {\n\tint dataLength;\n\tint eccLength;\n\tunsigned char *data;\n\tunsigned char *ecc;\n} RSblock;\n\ntypedef struct {\n\tint version;\n\tint dataLength;\n\tint eccLength;\n\tunsigned char *datacode;\n\tunsigned char *ecccode;\n\tint b1;\n\tint blocks;\n\tRSblock *rsblock;\n\tint count;\n} QRRawCode;\n\nstatic void RSblock_initBlock(RSblock *block, int dl, unsigned char *data, int el, unsigned char *ecc)\n{\n\tblock->dataLength = dl;\n\tblock->data = data;\n\tblock->eccLength = el;\n\tblock->ecc = ecc;\n\n\tRSECC_encode((size_t)dl, (size_t)el, data, ecc);\n}\n\nstatic int RSblock_init(RSblock *blocks, int spec[5], unsigned char *data, unsigned char *ecc)\n{\n\tint i;\n\tRSblock *block;\n\tunsigned char *dp, *ep;\n\tint el, dl;\n\n\tdl = QRspec_rsDataCodes1(spec);\n\tel = QRspec_rsEccCodes1(spec);\n\n\tblock = blocks;\n\tdp = data;\n\tep = ecc;\n\tfor(i = 0; i < QRspec_rsBlockNum1(spec); i++) {\n\t\tRSblock_initBlock(block, dl, dp, el, ep);\n\t\tdp += dl;\n\t\tep += el;\n\t\tblock++;\n\t}\n\n\tif(QRspec_rsBlockNum2(spec) == 0) return 0;\n\n\tdl = QRspec_rsDataCodes2(spec);\n\tel = QRspec_rsEccCodes2(spec);\n\tfor(i = 0; i < QRspec_rsBlockNum2(spec); i++) {\n\t\tRSblock_initBlock(block, dl, dp, el, ep);\n\t\tdp += dl;\n\t\tep += el;\n\t\tblock++;\n\t}\n\n\treturn 0;\n}\n\nSTATIC_IN_RELEASE void QRraw_free(QRRawCode *raw);\nSTATIC_IN_RELEASE QRRawCode *QRraw_new(QRinput *input)\n{\n\tQRRawCode *raw;\n\tint spec[5], ret;\n\n\traw = (QRRawCode *)malloc(sizeof(QRRawCode));\n\tif(raw == NULL) return NULL;\n\n\traw->datacode = QRinput_getByteStream(input);\n\tif(raw->datacode == NULL) {\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\n\tQRspec_getEccSpec(input->version, input->level, spec);\n\n\traw->version = input->version;\n\traw->b1 = QRspec_rsBlockNum1(spec);\n\traw->dataLength = QRspec_rsDataLength(spec);\n\traw->eccLength = QRspec_rsEccLength(spec);\n\traw->ecccode = (unsigned char *)malloc((size_t)raw->eccLength);\n\tif(raw->ecccode == NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\n\traw->blocks = QRspec_rsBlockNum(spec);\n\traw->rsblock = (RSblock *)calloc((size_t)(raw->blocks), sizeof(RSblock));\n\tif(raw->rsblock == NULL) {\n\t\tQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\tret = RSblock_init(raw->rsblock, spec, raw->datacode, raw->ecccode);\n\tif(ret < 0) {\n\t\tQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\n\traw->count = 0;\n\n\treturn raw;\n}\n\n/**\n * Return a code (byte).\n * This function can be called iteratively.\n * @param raw raw code.\n * @return code\n */\nSTATIC_IN_RELEASE unsigned char QRraw_getCode(QRRawCode *raw)\n{\n\tint col, row;\n\tunsigned char ret;\n\n\tif(raw->count < raw->dataLength) {\n\t\trow = raw->count % raw->blocks;\n\t\tcol = raw->count / raw->blocks;\n\t\tif(col >= raw->rsblock[0].dataLength) {\n\t\t\trow += raw->b1;\n\t\t}\n\t\tret = raw->rsblock[row].data[col];\n\t} else if(raw->count < raw->dataLength + raw->eccLength) {\n\t\trow = (raw->count - raw->dataLength) % raw->blocks;\n\t\tcol = (raw->count - raw->dataLength) / raw->blocks;\n\t\tret = raw->rsblock[row].ecc[col];\n\t} else {\n\t\treturn 0;\n\t}\n\traw->count++;\n\treturn ret;\n}\n\nSTATIC_IN_RELEASE void QRraw_free(QRRawCode *raw)\n{\n\tif(raw != NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw->ecccode);\n\t\tfree(raw->rsblock);\n\t\tfree(raw);\n\t}\n}\n\n/******************************************************************************\n * Raw code for Micro QR Code\n *****************************************************************************/\n\ntypedef struct {\n\tint version;\n\tint dataLength;\n\tint eccLength;\n\tunsigned char *datacode;\n\tunsigned char *ecccode;\n\tRSblock *rsblock;\n\tint oddbits;\n\tint count;\n} MQRRawCode;\n\nSTATIC_IN_RELEASE void MQRraw_free(MQRRawCode *raw);\nSTATIC_IN_RELEASE MQRRawCode *MQRraw_new(QRinput *input)\n{\n\tMQRRawCode *raw;\n\n\traw = (MQRRawCode *)malloc(sizeof(MQRRawCode));\n\tif(raw == NULL) return NULL;\n\n\traw->version = input->version;\n\traw->dataLength = MQRspec_getDataLength(input->version, input->level);\n\traw->eccLength = MQRspec_getECCLength(input->version, input->level);\n\traw->oddbits = raw->dataLength * 8 - MQRspec_getDataLengthBit(input->version, input->level);\n\traw->datacode = QRinput_getByteStream(input);\n\tif(raw->datacode == NULL) {\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\traw->ecccode = (unsigned char *)malloc((size_t)raw->eccLength);\n\tif(raw->ecccode == NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\n\traw->rsblock = (RSblock *)calloc(1, sizeof(RSblock));\n\tif(raw->rsblock == NULL) {\n\t\tMQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\n\tRSblock_initBlock(raw->rsblock, raw->dataLength, raw->datacode, raw->eccLength, raw->ecccode);\n\n\traw->count = 0;\n\n\treturn raw;\n}\n\n/**\n * Return a code (byte).\n * This function can be called iteratively.\n * @param raw raw code.\n * @return code\n */\nSTATIC_IN_RELEASE unsigned char MQRraw_getCode(MQRRawCode *raw)\n{\n\tunsigned char ret;\n\n\tif(raw->count < raw->dataLength) {\n\t\tret = raw->datacode[raw->count];\n\t} else if(raw->count < raw->dataLength + raw->eccLength) {\n\t\tret = raw->ecccode[raw->count - raw->dataLength];\n\t} else {\n\t\treturn 0;\n\t}\n\traw->count++;\n\treturn ret;\n}\n\nSTATIC_IN_RELEASE void MQRraw_free(MQRRawCode *raw)\n{\n\tif(raw != NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw->ecccode);\n\t\tfree(raw->rsblock);\n\t\tfree(raw);\n\t}\n}\n\n\n/******************************************************************************\n * Frame filling\n *****************************************************************************/\n\ntypedef struct {\n\tint width;\n\tunsigned char *frame;\n\tint x, y;\n\tint dir;\n\tint bit;\n\tint mqr;\n} FrameFiller;\n\nstatic void FrameFiller_set(FrameFiller *filler, int width, unsigned char *frame, int mqr)\n{\n\tfiller->width = width;\n\tfiller->frame = frame;\n\tfiller->x = width - 1;\n\tfiller->y = width - 1;\n\tfiller->dir = -1;\n\tfiller->bit = -1;\n\tfiller->mqr = mqr;\n}\n\nstatic unsigned char *FrameFiller_next(FrameFiller *filler)\n{\n\tunsigned char *p;\n\tint x, y, w;\n\n\tif(filler->bit == -1) {\n\t\tfiller->bit = 0;\n\t\treturn filler->frame + filler->y * filler->width + filler->x;\n\t}\n\n\tx = filler->x;\n\ty = filler->y;\n\tp = filler->frame;\n\tw = filler->width;\n\n\tif(filler->bit == 0) {\n\t\tx--;\n\t\tfiller->bit++;\n\t} else {\n\t\tx++;\n\t\ty += filler->dir;\n\t\tfiller->bit--;\n\t}\n\n\tif(filler->dir < 0) {\n\t\tif(y < 0) {\n\t\t\ty = 0;\n\t\t\tx -= 2;\n\t\t\tfiller->dir = 1;\n\t\t\tif(!filler->mqr && x == 6) {\n\t\t\t\tx--;\n\t\t\t\ty = 9;\n\t\t\t}\n\t\t}\n\t} else if(y == w) {\n\t\ty = w - 1;\n\t\tx -= 2;\n\t\tfiller->dir = -1;\n\t\tif(!filler->mqr && x == 6) {\n\t\t\tx--;\n\t\t\ty -= 8;\n\t\t}\n\t}\n\tif(x < 0 || y < 0) return NULL;\n\n\tfiller->x = x;\n\tfiller->y = y;\n\n\tif(p[y * w + x] & 0x80) {\n\t\t// This tail recursion could be optimized.\n\t\treturn FrameFiller_next(filler);\n\t}\n\treturn &p[y * w + x];\n}\n\n#ifdef WITH_TESTS\nunsigned char *FrameFiller_test(int version)\n{\n\tint width;\n\tunsigned char *frame, *p;\n\tint i, length;\n\tFrameFiller filler;\n\n\twidth = QRspec_getWidth(version);\n\tframe = QRspec_newFrame(version);\n\tif(frame == NULL) return NULL;\n\tFrameFiller_set(&filler, width, frame, 0);\n\tlength = QRspec_getDataLength(version, QR_ECLEVEL_L) * 8\n\t       + QRspec_getECCLength(version, QR_ECLEVEL_L) * 8\n\t\t   + QRspec_getRemainder(version);\n\tfor(i = 0; i < length; i++) {\n\t\tp = FrameFiller_next(&filler);\n\t\tif(p == NULL) {\n\t\t\tfree(frame);\n\t\t\treturn NULL;\n\t\t}\n\t\t*p = (unsigned char)(i & 0x7f) | 0x80;\n\t}\n\treturn frame;\n}\n\nunsigned char *FrameFiller_testMQR(int version)\n{\n\tint width;\n\tunsigned char *frame, *p;\n\tint i, length;\n\tFrameFiller filler;\n\n\twidth = MQRspec_getWidth(version);\n\tframe = MQRspec_newFrame(version);\n\tif(frame == NULL) return NULL;\n\tFrameFiller_set(&filler, width, frame, 1);\n\tlength = MQRspec_getDataLengthBit(version, QR_ECLEVEL_L)\n\t       + MQRspec_getECCLength(version, QR_ECLEVEL_L) * 8;\n\tfor(i = 0; i < length; i++) {\n\t\tp = FrameFiller_next(&filler);\n\t\tif(p == NULL) {\n\t\t\tfprintf(stderr, \"Frame filler run over the frame!\\n\");\n\t\t\treturn frame;\n\t\t}\n\t\t*p = (unsigned char)(i & 0x7f) | 0x80;\n\t}\n\treturn frame;\n}\n#endif\n\n\n/******************************************************************************\n * QR-code encoding\n *****************************************************************************/\n\nSTATIC_IN_RELEASE QRcode *QRcode_new(int version, int width, unsigned char *data)\n{\n\tQRcode *qrcode;\n\n\tqrcode = (QRcode *)malloc(sizeof(QRcode));\n\tif(qrcode == NULL) return NULL;\n\n\tqrcode->version = version;\n\tqrcode->width = width;\n\tqrcode->data = data;\n\n\treturn qrcode;\n}\n\nvoid QRcode_free(QRcode *qrcode)\n{\n\tif(qrcode != NULL) {\n\t\tfree(qrcode->data);\n\t\tfree(qrcode);\n\t}\n}\n\nSTATIC_IN_RELEASE QRcode *QRcode_encodeMask(QRinput *input, int mask)\n{\n\tint width, version;\n\tQRRawCode *raw;\n\tunsigned char *frame, *masked, *p, code, bit;\n\tint i, j;\n\tQRcode *qrcode = NULL;\n\tFrameFiller filler;\n\n\tif(input->mqr) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(input->version < 0 || input->version > QRSPEC_VERSION_MAX) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(input->level > QR_ECLEVEL_H) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\traw = QRraw_new(input);\n\tif(raw == NULL) return NULL;\n\n\tversion = raw->version;\n\twidth = QRspec_getWidth(version);\n\tframe = QRspec_newFrame(version);\n\tif(frame == NULL) {\n\t\tQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\tFrameFiller_set(&filler, width, frame, 0);\n\n\t/* interleaved data and ecc codes */\n\tfor(i = 0; i < raw->dataLength; i++) {\n\t\tcode = QRraw_getCode(raw);\n\t\tbit = 0x80;\n\t\tfor(j = 0; j < 8; j++) {\n\t\t\tp = FrameFiller_next(&filler);\n\t\t\tif(p == NULL)  goto EXIT;\n\t\t\t*p = ((bit & code) != 0);\n\t\t\tbit = bit >> 1;\n\t\t}\n\t}\n\tfor(i = 0; i < raw->eccLength; i++) {\n\t\tcode = QRraw_getCode(raw);\n\t\tbit = 0x80;\n\t\tfor(j = 0; j < 8; j++) {\n\t\t\tp = FrameFiller_next(&filler);\n\t\t\tif(p == NULL)  goto EXIT;\n\t\t\t*p = 0x02 | ((bit & code) != 0);\n\t\t\tbit = bit >> 1;\n\t\t}\n\t}\n\tQRraw_free(raw);\n\traw = NULL;\n\t/* remainder bits */\n\tj = QRspec_getRemainder(version);\n\tfor(i = 0; i < j; i++) {\n\t\tp = FrameFiller_next(&filler);\n\t\tif(p == NULL)  goto EXIT;\n\t\t*p = 0x02;\n\t}\n\n\t/* masking */\n\tif(mask == -2) { // just for debug purpose\n\t\tmasked = (unsigned char *)malloc((size_t)(width * width));\n\t\tmemcpy(masked, frame, (size_t)(width * width));\n\t} else if(mask < 0) {\n\t\tmasked = Mask_mask(width, frame, input->level);\n\t} else {\n\t\tmasked = Mask_makeMask(width, frame, mask, input->level);\n\t}\n\tif(masked == NULL) {\n\t\tgoto EXIT;\n\t}\n\tqrcode = QRcode_new(version, width, masked);\n\tif(qrcode == NULL) {\n\t\tfree(masked);\n\t}\n\nEXIT:\n\tQRraw_free(raw);\n\tfree(frame);\n\treturn qrcode;\n}\n\nSTATIC_IN_RELEASE QRcode *QRcode_encodeMaskMQR(QRinput *input, int mask)\n{\n\tint width, version;\n\tMQRRawCode *raw;\n\tunsigned char *frame, *masked, *p, code, bit;\n\tint i, j, length;\n\tQRcode *qrcode = NULL;\n\tFrameFiller filler;\n\n\tif(!input->mqr) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(input->version <= 0 || input->version > MQRSPEC_VERSION_MAX) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(input->level > QR_ECLEVEL_Q) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\traw = MQRraw_new(input);\n\tif(raw == NULL) return NULL;\n\n\tversion = raw->version;\n\twidth = MQRspec_getWidth(version);\n\tframe = MQRspec_newFrame(version);\n\tif(frame == NULL) {\n\t\tMQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\tFrameFiller_set(&filler, width, frame, 1);\n\n\t/* interleaved data and ecc codes */\n\tfor(i = 0; i < raw->dataLength; i++) {\n\t\tcode = MQRraw_getCode(raw);\n\t\tbit = 0x80;\n\t\tif(raw->oddbits && i == raw->dataLength - 1) {\n\t\t\tlength = raw->oddbits;\n\t\t} else {\n\t\t\tlength = 8;\n\t\t}\n\t\tfor(j = 0; j < length; j++) {\n\t\t\tp = FrameFiller_next(&filler);\n\t\t\tif(p == NULL) goto EXIT;\n\t\t\t*p = ((bit & code) != 0);\n\t\t\tbit = bit >> 1;\n\t\t}\n\t}\n\tfor(i = 0; i < raw->eccLength; i++) {\n\t\tcode = MQRraw_getCode(raw);\n\t\tbit = 0x80;\n\t\tlength = 8;\n\t\tfor(j = 0; j < length; j++) {\n\t\t\tp = FrameFiller_next(&filler);\n\t\t\tif(p == NULL) goto EXIT;\n\t\t\t*p = 0x02 | ((bit & code) != 0);\n\t\t\tbit = bit >> 1;\n\t\t}\n\t}\n\tMQRraw_free(raw);\n\traw = NULL;\n\n\t/* masking */\n\tif(mask == -2) { // just for debug purpose\n\t\tmasked = (unsigned char *)malloc((size_t)(width * width));\n\t\tmemcpy(masked, frame, (size_t)(width * width));\n\t} else if(mask < 0) {\n\t\tmasked = MMask_mask(version, frame, input->level);\n\t} else {\n\t\tmasked = MMask_makeMask(version, frame, mask, input->level);\n\t}\n\tif(masked == NULL) {\n\t\tgoto EXIT;\n\t}\n\n\tqrcode = QRcode_new(version, width, masked);\n\tif(qrcode == NULL) {\n\t\tfree(masked);\n\t}\n\nEXIT:\n\tMQRraw_free(raw);\n\tfree(frame);\n\treturn qrcode;\n}\n\nQRcode *QRcode_encodeInput(QRinput *input)\n{\n\tif(input->mqr) {\n\t\treturn QRcode_encodeMaskMQR(input, -1);\n\t} else {\n\t\treturn QRcode_encodeMask(input, -1);\n\t}\n}\n\nstatic QRcode *QRcode_encodeStringReal(const char *string, int version, QRecLevel level, int mqr, QRencodeMode hint, int casesensitive)\n{\n\tQRinput *input;\n\tQRcode *code;\n\tint ret;\n\n\tif(string == NULL) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(hint != QR_MODE_8 && hint != QR_MODE_KANJI) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif(mqr) {\ninput = ",
    "raw_res": "0;",
    "prompt_res": "QRinput_newMQR(version, level);",
    "gt": "QRinput_newMQR(version, level);"
  },
  {
    "id": 44,
    "pkg": "YPS-Instrument3",
    "fpath": "prj/CPDM04/Projects/3rd/awtk-widget-qr/src/qr/qrencode.c",
    "input": "﻿/*\n * qrencode - QR Code encoder\n *\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n# include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"qrencode.h\"\n#include \"qrspec.h\"\n#include \"mqrspec.h\"\n#include \"bitstream.h\"\n#include \"qrinput.h\"\n#include \"rsecc.h\"\n#include \"split.h\"\n#include \"mask.h\"\n#include \"mmask.h\"\n\n/******************************************************************************\n * Raw code\n *****************************************************************************/\n\ntypedef struct {\n\tint dataLength;\n\tint eccLength;\n\tunsigned char *data;\n\tunsigned char *ecc;\n} RSblock;\n\ntypedef struct {\n\tint version;\n\tint dataLength;\n\tint eccLength;\n\tunsigned char *datacode;\n\tunsigned char *ecccode;\n\tint b1;\n\tint blocks;\n\tRSblock *rsblock;\n\tint count;\n} QRRawCode;\n\nstatic void RSblock_initBlock(RSblock *block, int dl, unsigned char *data, int el, unsigned char *ecc)\n{\n\tblock->dataLength = dl;\n\tblock->data = data;\n\tblock->eccLength = el;\n\tblock->ecc = ecc;\n\n\tRSECC_encode((size_t)dl, (size_t)el, data, ecc);\n}\n\nstatic int RSblock_init(RSblock *blocks, int spec[5], unsigned char *data, unsigned char *ecc)\n{\n\tint i;\n\tRSblock *block;\n\tunsigned char *dp, *ep;\n\tint el, dl;\n\n\tdl = QRspec_rsDataCodes1(spec);\n\tel = QRspec_rsEccCodes1(spec);\n\n\tblock = blocks;\n\tdp = data;\n\tep = ecc;\n\tfor(i = 0; i < QRspec_rsBlockNum1(spec); i++) {\n\t\tRSblock_initBlock(block, dl, dp, el, ep);\n\t\tdp += dl;\n\t\tep += el;\n\t\tblock++;\n\t}\n\n\tif(QRspec_rsBlockNum2(spec) == 0) return 0;\n\n\tdl = QRspec_rsDataCodes2(spec);\n\tel = QRspec_rsEccCodes2(spec);\n\tfor(i = 0; i < QRspec_rsBlockNum2(spec); i++) {\n\t\tRSblock_initBlock(block, dl, dp, el, ep);\n\t\tdp += dl;\n\t\tep += el;\n\t\tblock++;\n\t}\n\n\treturn 0;\n}\n\nSTATIC_IN_RELEASE void QRraw_free(QRRawCode *raw);\nSTATIC_IN_RELEASE QRRawCode *QRraw_new(QRinput *input)\n{\n\tQRRawCode *raw;\n\tint spec[5], ret;\n\n\traw = (QRRawCode *)malloc(sizeof(QRRawCode));\n\tif(raw == NULL) return NULL;\n\n\traw->datacode = QRinput_getByteStream(input);\n\tif(raw->datacode == NULL) {\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\n\tQRspec_getEccSpec(input->version, input->level, spec);\n\n\traw->version = input->version;\n\traw->b1 = QRspec_rsBlockNum1(spec);\n\traw->dataLength = QRspec_rsDataLength(spec);\n\traw->eccLength = QRspec_rsEccLength(spec);\n\traw->ecccode = (unsigned char *)malloc((size_t)raw->eccLength);\n\tif(raw->ecccode == NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\n\traw->blocks = QRspec_rsBlockNum(spec);\n\traw->rsblock = (RSblock *)calloc((size_t)(raw->blocks), sizeof(RSblock));\n\tif(raw->rsblock == NULL) {\n\t\tQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\tret = RSblock_init(raw->rsblock, spec, raw->datacode, raw->ecccode);\n\tif(ret < 0) {\n\t\tQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\n\traw->count = 0;\n\n\treturn raw;\n}\n\n/**\n * Return a code (byte).\n * This function can be called iteratively.\n * @param raw raw code.\n * @return code\n */\nSTATIC_IN_RELEASE unsigned char QRraw_getCode(QRRawCode *raw)\n{\n\tint col, row;\n\tunsigned char ret;\n\n\tif(raw->count < raw->dataLength) {\n\t\trow = raw->count % raw->blocks;\n\t\tcol = raw->count / raw->blocks;\n\t\tif(col >= raw->rsblock[0].dataLength) {\n\t\t\trow += raw->b1;\n\t\t}\n\t\tret = raw->rsblock[row].data[col];\n\t} else if(raw->count < raw->dataLength + raw->eccLength) {\n\t\trow = (raw->count - raw->dataLength) % raw->blocks;\n\t\tcol = (raw->count - raw->dataLength) / raw->blocks;\n\t\tret = raw->rsblock[row].ecc[col];\n\t} else {\n\t\treturn 0;\n\t}\n\traw->count++;\n\treturn ret;\n}\n\nSTATIC_IN_RELEASE void QRraw_free(QRRawCode *raw)\n{\n\tif(raw != NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw->ecccode);\n\t\tfree(raw->rsblock);\n\t\tfree(raw);\n\t}\n}\n\n/******************************************************************************\n * Raw code for Micro QR Code\n *****************************************************************************/\n\ntypedef struct {\n\tint version;\n\tint dataLength;\n\tint eccLength;\n\tunsigned char *datacode;\n\tunsigned char *ecccode;\n\tRSblock *rsblock;\n\tint oddbits;\n\tint count;\n} MQRRawCode;\n\nSTATIC_IN_RELEASE void MQRraw_free(MQRRawCode *raw);\nSTATIC_IN_RELEASE MQRRawCode *MQRraw_new(QRinput *input)\n{\n\tMQRRawCode *raw;\n\n\traw = (MQRRawCode *)malloc(sizeof(MQRRawCode));\n\tif(raw == NULL) return NULL;\n\n\traw->version = input->version;\n\traw->dataLength = MQRspec_getDataLength(input->version, input->level);\n\traw->eccLength = MQRspec_getECCLength(input->version, input->level);\n\traw->oddbits = raw->dataLength * 8 - MQRspec_getDataLengthBit(input->version, input->level);\n\traw->datacode = QRinput_getByteStream(input);\n\tif(raw->datacode == NULL) {\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\traw->ecccode = (unsigned char *)malloc((size_t)raw->eccLength);\n\tif(raw->ecccode == NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\n\traw->rsblock = (RSblock *)calloc(1, sizeof(RSblock));\n\tif(raw->rsblock == NULL) {\n\t\tMQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\n\tRSblock_initBlock(raw->rsblock, raw->dataLength, raw->datacode, raw->eccLength, raw->ecccode);\n\n\traw->count = 0;\n\n\treturn raw;\n}\n\n/**\n * Return a code (byte).\n * This function can be called iteratively.\n * @param raw raw code.\n * @return code\n */\nSTATIC_IN_RELEASE unsigned char MQRraw_getCode(MQRRawCode *raw)\n{\n\tunsigned char ret;\n\n\tif(raw->count < raw->dataLength) {\n\t\tret = raw->datacode[raw->count];\n\t} else if(raw->count < raw->dataLength + raw->eccLength) {\n\t\tret = raw->ecccode[raw->count - raw->dataLength];\n\t} else {\n\t\treturn 0;\n\t}\n\traw->count++;\n\treturn ret;\n}\n\nSTATIC_IN_RELEASE void MQRraw_free(MQRRawCode *raw)\n{\n\tif(raw != NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw->ecccode);\n\t\tfree(raw->rsblock);\n\t\tfree(raw);\n\t}\n}\n\n\n/******************************************************************************\n * Frame filling\n *****************************************************************************/\n\ntypedef struct {\n\tint width;\n\tunsigned char *frame;\n\tint x, y;\n\tint dir;\n\tint bit;\n\tint mqr;\n} FrameFiller;\n\nstatic void FrameFiller_set(FrameFiller *filler, int width, unsigned char *frame, int mqr)\n{\n\tfiller->width = width;\n\tfiller->frame = frame;\n\tfiller->x = width - 1;\n\tfiller->y = width - 1;\n\tfiller->dir = -1;\n\tfiller->bit = -1;\n\tfiller->mqr = mqr;\n}\n\nstatic unsigned char *FrameFiller_next(FrameFiller *filler)\n{\n\tunsigned char *p;\n\tint x, y, w;\n\n\tif(filler->bit == -1) {\n\t\tfiller->bit = 0;\n\t\treturn filler->frame + filler->y * filler->width + filler->x;\n\t}\n\n\tx = filler->x;\n\ty = filler->y;\n\tp = filler->frame;\n\tw = filler->width;\n\n\tif(filler->bit == 0) {\n\t\tx--;\n\t\tfiller->bit++;\n\t} else {\n\t\tx++;\n\t\ty += filler->dir;\n\t\tfiller->bit--;\n\t}\n\n\tif(filler->dir < 0) {\n\t\tif(y < 0) {\n\t\t\ty = 0;\n\t\t\tx -= 2;\n\t\t\tfiller->dir = 1;\n\t\t\tif(!filler->mqr && x == 6) {\n\t\t\t\tx--;\n\t\t\t\ty = 9;\n\t\t\t}\n\t\t}\n\t} else if(y == w) {\n\t\ty = w - 1;\n\t\tx -= 2;\n\t\tfiller->dir = -1;\n\t\tif(!filler->mqr && x == 6) {\n\t\t\tx--;\n\t\t\ty -= 8;\n\t\t}\n\t}\n\tif(x < 0 || y < 0) return NULL;\n\n\tfiller->x = x;\n\tfiller->y = y;\n\n\tif(p[y * w + x] & 0x80) {\n\t\t// This tail recursion could be optimized.\n\t\treturn FrameFiller_next(filler);\n\t}\n\treturn &p[y * w + x];\n}\n\n#ifdef WITH_TESTS\nunsigned char *FrameFiller_test(int version)\n{\n\tint width;\n\tunsigned char *frame, *p;\n\tint i, length;\n\tFrameFiller filler;\n\n\twidth = QRspec_getWidth(version);\n\tframe = QRspec_newFrame(version);\n\tif(frame == NULL) return NULL;\n\tFrameFiller_set(&filler, width, frame, 0);\n\tlength = QRspec_getDataLength(version, QR_ECLEVEL_L) * 8\n\t       + QRspec_getECCLength(version, QR_ECLEVEL_L) * 8\n\t\t   + QRspec_getRemainder(version);\n\tfor(i = 0; i < length; i++) {\n\t\tp = FrameFiller_next(&filler);\n\t\tif(p == NULL) {\n\t\t\tfree(frame);\n\t\t\treturn NULL;\n\t\t}\n\t\t*p = (unsigned char)(i & 0x7f) | 0x80;\n\t}\n\treturn frame;\n}\n\nunsigned char *FrameFiller_testMQR(int version)\n{\n\tint width;\n\tunsigned char *frame, *p;\n\tint i, length;\n\tFrameFiller filler;\n\n\twidth = MQRspec_getWidth(version);\n\tframe = MQRspec_newFrame(version);\n\tif(frame == NULL) return NULL;\n\tFrameFiller_set(&filler, width, frame, 1);\n\tlength = MQRspec_getDataLengthBit(version, QR_ECLEVEL_L)\n\t       + MQRspec_getECCLength(version, QR_ECLEVEL_L) * 8;\n\tfor(i = 0; i < length; i++) {\n\t\tp = FrameFiller_next(&filler);\n\t\tif(p == NULL) {\n\t\t\tfprintf(stderr, \"Frame filler run over the frame!\\n\");\n\t\t\treturn frame;\n\t\t}\n\t\t*p = (unsigned char)(i & 0x7f) | 0x80;\n\t}\n\treturn frame;\n}\n#endif\n\n\n/******************************************************************************\n * QR-code encoding\n *****************************************************************************/\n\nSTATIC_IN_RELEASE QRcode *QRcode_new(int version, int width, unsigned char *data)\n{\n\tQRcode *qrcode;\n\n\tqrcode = (QRcode *)malloc(sizeof(QRcode));\n\tif(qrcode == NULL) return NULL;\n\n\tqrcode->version = version;\n\tqrcode->width = width;\n\tqrcode->data = data;\n\n\treturn qrcode;\n}\n\nvoid QRcode_free(QRcode *qrcode)\n{\n\tif(qrcode != NULL) {\n\t\tfree(qrcode->data);\n\t\tfree(qrcode);\n\t}\n}\n\nSTATIC_IN_RELEASE QRcode *QRcode_encodeMask(QRinput *input, int mask)\n{\n\tint width, version;\n\tQRRawCode *raw;\n\tunsigned char *frame, *masked, *p, code, bit;\n\tint i, j;\n\tQRcode *qrcode = NULL;\n\tFrameFiller filler;\n\n\tif(input->mqr) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(input->version < 0 || input->version > QRSPEC_VERSION_MAX) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(input->level > QR_ECLEVEL_H) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\traw = QRraw_new(input);\n\tif(raw == NULL) return NULL;\n\n\tversion = raw->version;\n\twidth = QRspec_getWidth(version);\n\tframe = QRspec_newFrame(version);\n\tif(frame == NULL) {\n\t\tQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\tFrameFiller_set(&filler, width, frame, 0);\n\n\t/* interleaved data and ecc codes */\n\tfor(i = 0; i < raw->dataLength; i++) {\n\t\tcode = QRraw_getCode(raw);\n\t\tbit = 0x80;\n\t\tfor(j = 0; j < 8; j++) {\n\t\t\tp = FrameFiller_next(&filler);\n\t\t\tif(p == NULL)  goto EXIT;\n\t\t\t*p = ((bit & code) != 0);\n\t\t\tbit = bit >> 1;\n\t\t}\n\t}\n\tfor(i = 0; i < raw->eccLength; i++) {\n\t\tcode = QRraw_getCode(raw);\n\t\tbit = 0x80;\n\t\tfor(j = 0; j < 8; j++) {\n\t\t\tp = FrameFiller_next(&filler);\n\t\t\tif(p == NULL)  goto EXIT;\n\t\t\t*p = 0x02 | ((bit & code) != 0);\n\t\t\tbit = bit >> 1;\n\t\t}\n\t}\n\tQRraw_free(raw);\n\traw = NULL;\n\t/* remainder bits */\n\tj = QRspec_getRemainder(version);\n\tfor(i = 0; i < j; i++) {\n\t\tp = FrameFiller_next(&filler);\n\t\tif(p == NULL)  goto EXIT;\n\t\t*p = 0x02;\n\t}\n\n\t/* masking */\n\tif(mask == -2) { // just for debug purpose\n\t\tmasked = (unsigned char *)malloc((size_t)(width * width));\n\t\tmemcpy(masked, frame, (size_t)(width * width));\n\t} else if(mask < 0) {\n\t\tmasked = Mask_mask(width, frame, input->level);\n\t} else {\n\t\tmasked = Mask_makeMask(width, frame, mask, input->level);\n\t}\n\tif(masked == NULL) {\n\t\tgoto EXIT;\n\t}\n\tqrcode = QRcode_new(version, width, masked);\n\tif(qrcode == NULL) {\n\t\tfree(masked);\n\t}\n\nEXIT:\n\tQRraw_free(raw);\n\tfree(frame);\n\treturn qrcode;\n}\n\nSTATIC_IN_RELEASE QRcode *QRcode_encodeMaskMQR(QRinput *input, int mask)\n{\n\tint width, version;\n\tMQRRawCode *raw;\n\tunsigned char *frame, *masked, *p, code, bit;\n\tint i, j, length;\n\tQRcode *qrcode = NULL;\n\tFrameFiller filler;\n\n\tif(!input->mqr) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(input->version <= 0 || input->version > MQRSPEC_VERSION_MAX) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(input->level > QR_ECLEVEL_Q) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\traw = MQRraw_new(input);\n\tif(raw == NULL) return NULL;\n\n\tversion = raw->version;\n\twidth = MQRspec_getWidth(version);\n\tframe = MQRspec_newFrame(version);\n\tif(frame == NULL) {\n\t\tMQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\tFrameFiller_set(&filler, width, frame, 1);\n\n\t/* interleaved data and ecc codes */\n\tfor(i = 0; i < raw->dataLength; i++) {\n\t\tcode = MQRraw_getCode(raw);\n\t\tbit = 0x80;\n\t\tif(raw->oddbits && i == raw->dataLength - 1) {\n\t\t\tlength = raw->oddbits;\n\t\t} else {\n\t\t\tlength = 8;\n\t\t}\n\t\tfor(j = 0; j < length; j++) {\n\t\t\tp = FrameFiller_next(&filler);\n\t\t\tif(p == NULL) goto EXIT;\n\t\t\t*p = ((bit & code) != 0);\n\t\t\tbit = bit >> 1;\n\t\t}\n\t}\n\tfor(i = 0; i < raw->eccLength; i++) {\n\t\tcode = MQRraw_getCode(raw);\n\t\tbit = 0x80;\n\t\tlength = 8;\n\t\tfor(j = 0; j < length; j++) {\n\t\t\tp = FrameFiller_next(&filler);\n\t\t\tif(p == NULL) goto EXIT;\n\t\t\t*p = 0x02 | ((bit & code) != 0);\n\t\t\tbit = bit >> 1;\n\t\t}\n\t}\n\tMQRraw_free(raw);\n\traw = NULL;\n\n\t/* masking */\n\tif(mask == -2) { // just for debug purpose\n\t\tmasked = (unsigned char *)malloc((size_t)(width * width));\n\t\tmemcpy(masked, frame, (size_t)(width * width));\n\t} else if(mask < 0) {\n\t\tmasked = MMask_mask(version, frame, input->level);\n\t} else {\n\t\tmasked = MMask_makeMask(version, frame, mask, input->level);\n\t}\n\tif(masked == NULL) {\n\t\tgoto EXIT;\n\t}\n\n\tqrcode = QRcode_new(version, width, masked);\n\tif(qrcode == NULL) {\n\t\tfree(masked);\n\t}\n\nEXIT:\n\tMQRraw_free(raw);\n\tfree(frame);\n\treturn qrcode;\n}\n\nQRcode *QRcode_encodeInput(QRinput *input)\n{\n\tif(input->mqr) {\n\t\treturn QRcode_encodeMaskMQR(input, -1);\n\t} else {\n\t\treturn QRcode_encodeMask(input, -1);\n\t}\n}\n\nstatic QRcode *QRcode_encodeStringReal(const char *string, int version, QRecLevel level, int mqr, QRencodeMode hint, int casesensitive)\n{\n\tQRinput *input;\n\tQRcode *code;\n\tint ret;\n\n\tif(string == NULL) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(hint != QR_MODE_8 && hint != QR_MODE_KANJI) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif(mqr) {\n\t\tinput = QRinput_newMQR(version, level);\n\t} else {\n\t\tinput = QRinput_new2(version, level);\n\t}\n\tif(input == NULL) return NULL;\n\n\tret = Split_splitStringToQRinput(string, input, hint, casesensitive);\n\tif(ret < 0) {\n\t\tQRinput_free(input);\n\t\treturn NULL;\n\t}\ncode = ",
    "raw_res": "0;",
    "prompt_res": "QRcode_encodeInput(input);",
    "gt": "QRcode_encodeInput(input);"
  },
  {
    "id": 53,
    "pkg": "YPS-Instrument3",
    "fpath": "prj/CPDM04/Projects/3rd/awtk-widget-qr/src/qr/qrinput.c",
    "input": "﻿/*\n * qrencode - QR Code encoder\n *\n * Input data chunk class\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n# include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"qrencode.h\"\n#include \"qrspec.h\"\n#include \"mqrspec.h\"\n#include \"bitstream.h\"\n#include \"qrinput.h\"\n\n/******************************************************************************\n * Utilities\n *****************************************************************************/\nint QRinput_isSplittableMode(QRencodeMode mode)\n{\n\treturn (mode >= QR_MODE_NUM && mode <= QR_MODE_KANJI);\n}\n\n/******************************************************************************\n * Entry of input data\n *****************************************************************************/\n\nstatic QRinput_List *QRinput_List_newEntry(QRencodeMode mode, int size, const unsigned char *data)\n{\n\tQRinput_List *entry;\n\n\tif(QRinput_check(mode, size, data)) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tentry = (QRinput_List *)malloc(sizeof(QRinput_List));\n\tif(entry == NULL) return NULL;\n\n\tentry->mode = mode;\n\tentry->size = size;\n\tentry->data = NULL;\n\tif(size > 0) {\n\t\tentry->data = (unsigned char *)malloc((size_t)size);\n\t\tif(entry->data == NULL) {\n\t\t\tfree(entry);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemcpy(entry->data, data, (size_t)size);\n\t}\n\tentry->bstream = NULL;\n\tentry->next = NULL;\n\n\treturn entry;\n}\n\nstatic void QRinput_List_freeEntry(QRinput_List *entry)\n{\n\tif(entry != NULL) {\n\t\tfree(entry->data);\n\t\tBitStream_free(entry->bstream);\n\t\tfree(entry);\n\t}\n}\n\nstatic QRinput_List *QRinput_List_dup(QRinput_List *entry)\n{\n\tQRinput_List *n;\n\n\tn = (QRinput_List *)malloc(sizeof(QRinput_List));\n\tif(n == NULL) return NULL;\n\n\tn->mode = entry->mode;\n\tn->size = entry->size;\n\tn->data = (unsigned char *)malloc((size_t)n->size);\n\tif(n->data == NULL) {\n\t\tfree(n);\n\t\treturn NULL;\n\t}\n\tmemcpy(n->data, entry->data, (size_t)entry->size);\n\tn->bstream = NULL;\n\tn->next = NULL;\n\n\treturn n;\n}\n\n/******************************************************************************\n * Input Data\n *****************************************************************************/\n\nQRinput *QRinput_new(void)\n{\n\treturn QRinput_new2(0, QR_ECLEVEL_L);\n}\n\nQRinput *QRinput_new2(int version, QRecLevel level)\n{\n\tQRinput *input;\n\n\tif(version < 0 || version > QRSPEC_VERSION_MAX || level > QR_ECLEVEL_H) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tinput = (QRinput *)malloc(sizeof(QRinput));\n\tif(input == NULL) return NULL;\n\n\tinput->head = NULL;\n\tinput->tail = NULL;\n\tinput->version = version;\n\tinput->level = level;\n\tinput->mqr = 0;\n\tinput->fnc1 = 0;\n\n\treturn input;\n}\n\nQRinput *QRinput_newMQR(int version, QRecLevel level)\n{\n\tQRinput *input;\n\n\tif(version <= 0 || version > MQRSPEC_VERSION_MAX) goto INVALID;\n\tif((MQRspec_getECCLength(version, level) == 0)) goto INVALID;\n\n\tinput = QRinput_new2(version, level);\n\tif(input == NULL) return NULL;\n\n\tinput->mqr = 1;\n\n\treturn input;\n\nINVALID:\n\terrno = EINVAL;\n\treturn NULL;\n}\n\nint QRinput_getVersion(QRinput *input)\n{\n\treturn input->version;\n}\n\nint QRinput_setVersion(QRinput *input, int version)\n{\n\tif(input->mqr || version < 0 || version > QRSPEC_VERSION_MAX) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tinput->version = version;\n\n\treturn 0;\n}\n\nQRecLevel QRinput_getErrorCorrectionLevel(QRinput *input)\n{\n\treturn input->level;\n}\n\nint QRinput_setErrorCorrectionLevel(QRinput *input, QRecLevel level)\n{\n\tif(input->mqr || level > QR_ECLEVEL_H) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tinput->level = level;\n\n\treturn 0;\n}\n\nint QRinput_setVersionAndErrorCorrectionLevel(QRinput *input, int version, QRecLevel level)\n{\n\tif(input->mqr) {\n\t\tif(version <= 0 || version > MQRSPEC_VERSION_MAX) goto INVALID;\n\t\tif((MQRspec_getECCLength(version, level) == 0)) goto INVALID;\n\t} else {\n\t\tif(version < 0 || version > QRSPEC_VERSION_MAX) goto INVALID;\n\t\tif(level > QR_ECLEVEL_H) goto INVALID;\n\t}\n\n\tinput->version = version;\n\tinput->level = level;\n\n\treturn 0;\n\nINVALID:\n\terrno = EINVAL;\n\treturn -1;\n}\n\nstatic void QRinput_appendEntry(QRinput *input, QRinput_List *entry)\n{\n\tif(input->tail == NULL) {\n\t\tinput->head = entry;\n\t\tinput->tail = entry;\n\t} else {\n\t\tinput->tail->next = entry;\n\t\tinput->tail = entry;\n\t}\n\tentry->next = NULL;\n}\n\nint QRinput_append(QRinput *input, QRencodeMode mode, int size, const unsigned char *data)\n{\n\tQRinput_List *entry;\n\n\tentry = QRinput_List_newEntry(mode, size, data);\n\tif(entry == NULL) {\n\t\treturn -1;\n\t}\n\n\tQRinput_appendEntry(input, entry);\n\n\treturn 0;\n}\n\n/**\n * Insert a structured-append header to the head of the input data.\n * @param input input data.\n * @param size number of structured symbols.\n * @param number index number of the symbol. (1 <= number <= size)\n * @param parity parity among input data. (NOTE: each symbol of a set of structured symbols has the same parity data)\n * @retval 0 success.\n * @retval -1 error occurred and errno is set to indeicate the error. See Execptions for the details.\n * @throw EINVAL invalid parameter.\n * @throw ENOMEM unable to allocate memory.\n */\nSTATIC_IN_RELEASE int QRinput_insertStructuredAppendHeader(QRinput *input, int size, int number, unsigned char parity)\n{\n\tQRinput_List *entry;\n\tunsigned char buf[3];\n\n\tif(size > MAX_STRUCTURED_SYMBOLS) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tif(number <= 0 || number > size) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tbuf[0] = (unsigned char)size;\n\tbuf[1] = (unsigned char)number;\n\tbuf[2] = parity;\n\tentry = QRinput_List_newEntry(QR_MODE_STRUCTURE, 3, buf);\n\tif(entry == NULL) {\n\t\treturn -1;\n\t}\n\n\tentry->next = input->head;\n\tinput->head = entry;\n\n\treturn 0;\n}\n\nint QRinput_appendECIheader(QRinput *input, unsigned int ecinum)\n{\n\tunsigned char data[4];\n\n\tif(ecinum > 999999) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* We manually create byte array of ecinum because\n\t (unsigned char *)&ecinum may cause bus error on some architectures, */\n\tdata[0] = ecinum & 0xff;\n\tdata[1] = (ecinum >>  8) & 0xff;\n\tdata[2] = (ecinum >> 16) & 0xff;\n\tdata[3] = (ecinum >> 24) & 0xff;\n\treturn QRinput_append(input, QR_MODE_ECI, 4, data);\n}\n\nvoid QRinput_free(QRinput *input)\n{\n\tQRinput_List *list, *next;\n\n\tif(input != NULL) {\n\t\tlist = input->head;\n\t\twhile(list != NULL) {\n\t\t\tnext = list->next;\n\t\t\tQRinput_List_freeEntry(list);\n\t\t\tlist = next;\n\t\t}\n\t\tfree(input);\n\t}\n}\n\nstatic unsigned char QRinput_calcParity(QRinput *input)\n{\n\tunsigned char parity = 0;\n\tQRinput_List *list;\n\tint i;\n\n\tlist = input->head;\n\twhile(list != NULL) {\n\t\tif(list->mode != QR_MODE_STRUCTURE) {\n\t\t\tfor(i = list->size-1; i >= 0; i--) {\n\t\t\t\tparity ^= list->data[i];\n\t\t\t}\n\t\t}\n\t\tlist = list->next;\n\t}\n\n\treturn parity;\n}\n\nQRinput *QRinput_dup(QRinput *input)\n{\n\tQRinput *n;\n\tQRinput_List *list, *e;\n\n\tif(input->mqr) {\n\t\tn = QRinput_newMQR(input->version, input->level);\n\t} else {\nn = ",
    "raw_res": "n = QRinput_new2(input->version, input->level);",
    "prompt_res": "QRinput_new2(input->version, input->level);",
    "gt": "QRinput_new2(input->version, input->level);"
  },
  {
    "id": 142,
    "pkg": "YPS-Instrument3",
    "fpath": "prj/CPDM04/src/pages/menu_base_view/menu_tab_view.c",
    "input": "#include \"menu_tab_view.h\"\n#include \"yps_view_base.h\"\n#include \"yps_dataset.h\"\n#include \"bllLog.h\"\n#include \"yps_app_status.h\"\n\nstatic int _carrent_tab_item_idx = 1;\n\n//view焦点顺序配置 {当前焦点item所在的名称，当前焦点返回的上级view名称，空字符串表示焦点返回到主窗口处理， 按确定之后焦点指向的下级view的名称}\nstatic yps_view_item_focus_map_t _focus_map_list[ ] = {\n    {\"menu_ico_1\", \"menu_info_view\"},\n    {\"menu_ico_2\", \"\"},\n    {\"menu_ico_3\", \"menu_setting_view\"},\n};\n\n//当前view焦点顺序配置\nyps_view_focus_t _menu_tab_view_focus = {\n    .pre_view_name = \"\",    //menu_tab_view 没有上级页面，点击返回之后直接回到主页面\n    .focus_map_list = _focus_map_list,\n    .focus_map_num = sizeof(_focus_map_list) / sizeof(yps_view_item_focus_map_t),\n    .focus_id = 1,  //页面创建之后焦点默认在第一个item上\n    .default_focus_id = 1, //页面创建之后焦点默认在第一个item上\n};\n\n//view数据模型定义，用于view内子控件和数据绑定\nstatic yps_view_data_model_t _menu_tab_view_data_model[ ] = {\n};\n\n\n\n//view数据回调函数定义，用于自定义数据更新\nYPS_VIEW_DATA_MODEL_CB(menu_tab_view){\n    return value;\n}\n\n\n\n//view事件回调函数定义，感兴趣的事件可以在这里处理\nYPS_VIEW_EVENT_CB(menu_tab_view) {\n    yps_view_t* tab_view = yps_view_cast(view);\n    if (event_type == YPS_VIEW_EVENT_SHOW) {\n        char ico_name[32] = {0};\n        for (int i = 1; i < 4; i++) {\n            sprintf(ico_name, \"menu_ico_%d\", i);\n            widget_t* ico = widget_lookup(tab_view->view, ico_name, true);\n            if (ico &&  _carrent_tab_item_idx == i) {\n                image_value_set_value(ico, 1);\n            }\n            else {\n                image_value_set_value(ico, 0);\n            }\n        }\n    }\n    else if (event_type == YPS_VIEW_EVENT_CLICK) {\n        if (click_type == YPS_CLICK_OK && yps_status_get_connect_status() == CONNECT_STATUS_CONNECTED && _carrent_tab_item_idx == 2) {\n            _carrent_tab_item_idx = 2;\n            jump_to_mirror_page(-1);\n            return false;\n        }\n    }\n    else if (event_type == YPS_VIEW_EVENT_FOCUS_ITEM) {\n        widget_t* item_widget = (widget_t*)param;\n        image_value_set_value(item_widget, 1);\n        if (strcmp(item_widget->name, \"menu_ico_1\") == 0) {\n            _carrent_tab_item_idx = 1;\n            yps_view_manager_show_view_by_name(\"menu_info_view\");\n        }\n        else if (strcmp(item_widget->name, \"menu_ico_2\") == 0) {\n            _carrent_tab_item_idx = 2;\n            LOGAPPD(\"菜单页 互联状态 ==============> %d\", yps_status_get_connect_status());\n            if (yps_status_get_connect_status() == CONNECT_STATUS_CONNECTED) {\n                yps_view_manager_show_view_by_name(\"menu_connected_view\");\n            }\n            else {\n                yps_view_manager_show_view_by_name(\"qr_view\");\n            }\n        }\n        else if (strcmp(item_widget->name, \"menu_ico_3\") == 0) {\n            _carrent_tab_item_idx = 3;\n            tab_view->view_focus.default_focus_id = 3;\n            yps_view_manager_show_view_by_name(\"menu_setting_view\");\n        }\n    }\n    else if (event_type == YPS_VIEW_EVENT_KILL_FOCUS_ITEM) {\n        if (tab_view->view->focused) {\n            image_value_set_value((widget_t*)param, 0);\n        }\n    }\n    return true;\n}\n\nstatic yps_view_t* _menu_tab_view = NULL;\nvoid menu_tab_view_open(widget_t* parent) {\n    _menu_tab_view_focus.focus_id = _carrent_tab_item_idx;\n    // int data_model_size = sizeof(_menu_tab_view_data_model) / sizeof(yps_view_data_model_t);\n    // _menu_tab_view = yps_view_create(parent, \"menu_base_view/menu_tab_view\", \"menu_tab_view\", YPS_VIEW_TYPE_BASE, NULL, _menu_tab_view_data_model, data_model_size, _menu_tab_view_focus, YPS_VIEW_EVENT_CB_NAME(menu_tab_view));\n\n    yps_view_conf_t view_conf = {\n        .xml_name = \"menu_base_view/menu_tab_view\",\n        .view_type = YPS_VIEW_TYPE_BASE,\n        .lang_list = NULL,\n        .data_model = _menu_tab_view_data_model,\n        .data_model_num = sizeof(_menu_tab_view_data_model) / sizeof(yps_view_data_model_t),\n        .focus = _menu_tab_view_focus,\n        .view_cb = YPS_VIEW_EVENT_CB_NAME(menu_tab_view),\n    };\n\n_menu_tab_view = ",
    "raw_res": "yps_view_create(parent, view_conf);",
    "prompt_res": "yps_view_create_ex(parent, \"menu_tab_view\", &view_conf);",
    "gt": "yps_view_create_ex(parent, \"menu_tab_view\", &view_conf);"
  },
  {
    "id": 148,
    "pkg": "YPS-Instrument3",
    "fpath": "prj/CPDM04/src/pages/pop_view/pop_view_phone_call.c",
    "input": "#include \"pop_view_phone_call.h\"\n#include \"yps_view_base.h\"\n#include \"yps_view_manager.h\"\n#include \"yps_page_base.h\"\n#include \"pop_view_volume.h\"\n#include \"bllLog.h\"\n#include \"yps_app_status.h\"\n#include \"yps_dataset.h\"\n#include \"yps_mcu.h\"\n\nstatic yps_view_t* _view_call = NULL;\nstatic bool _has_volume_view = false;\n\nstatic yps_view_item_focus_map_t _focus_map_list[ ] = {\n};\n\n//当前view焦点顺序配置\nstatic yps_view_focus_t _pop_view_phone_call_focus = {\n    .pre_view_name = \"\",\n    .focus_map_list = _focus_map_list,\n    .focus_map_num = sizeof(_focus_map_list) / sizeof(yps_view_item_focus_map_t),\n    .focus_id = -1,  //页面创建之后焦点默认在第一个item上\n    .default_focus_id = 0, \n};\n\n\nstatic yps_lang_t _pop_view_call_lang[ ] = {\n};\n\nstatic const char* _tips_cn[] = {\n    \"拨号中...\",\n    \"来电...\",\n    \"通话中...\",\n};\n\nstatic const char* _tips_en[] = {\n    \"Calling...\",\n    \"Call In...\",\n    \"On Call...\",\n};\n\n\n\nstatic yps_lang_list_t _pop_view_call_lang_list = {\n    .list = _pop_view_call_lang,\n    .count = sizeof(_pop_view_call_lang) / sizeof(yps_lang_t)\n};\n\nstatic void pop_view_phone_call_close() {\n    yps_view_t* view_call = (yps_view_t*)yps_view_manager_get_view_by_name(\"pop_view_phone_call\");\n    if (view_call != NULL) {\n        yps_view_hide(view_call);\n    }\n}\n\nstatic void get_call_tip(int call_type, char* tip) {\n    const char** tips = NULL;\n    if (GET_INT(DI_MCU_LANGUAGE) == YPS_LANG_ENGLISH) {\n        tips = _tips_en;\n    }\n    else {\n        tips = _tips_cn;\n    }\n    \n    switch (call_type) {\n        case YPS_BT_HFP_STATE_CALL_OUT:\n            strcpy(tip, tips[0]);\n            break;\n        case YPS_BT_HFP_STATE_CALL_IN:\n            strcpy(tip, tips[1]);\n            break;\n        case YPS_BT_HFP_STATE_TALKING: {\n            yps_phone_call_info_t * call_log = yps_status_get_phone_call_info();\n            strcpy(tip, call_log->time);\n            break;\n        }\n        default:\n            pop_view_phone_call_close();\n            break;\n    }\n}\n\nYPS_VIEW_DATA_MODEL_CB(pop_view_phone_call) {\n    if (strcmp(target_widget_name, \"phone_number\") == 0) {\n        yps_phone_call_info_t * call_log = yps_status_get_phone_call_info();\n        LOGAPPD(\"phone_name = %s %s\", call_log->name, call_log->number);\n        if (strlen(call_log->name) > 0) {\n            strcpy(value.value.string_value, call_log->name);\n        }\n        else {\n            strcpy(value.value.string_value, call_log->number);\n        }\n    }\n    else if (strcmp(target_widget_name, \"tip\") == 0) {\nyps_bt_hfp_state_t phone_state = ",
    "raw_res": "yps_status_get_phone_state();",
    "prompt_res": "yps_status_get_phone_call_state();",
    "gt": "yps_status_get_phone_call_state();"
  },
  {
    "id": 161,
    "pkg": "YPS-Instrument3",
    "fpath": "prj/CPDM04/src/pages/pop_view/pop_view_music.c",
    "input": "#include \"pop_view_music.h\"\n#include \"yps_view_base.h\"\n#include \"pop_view_volume.h\"\n#include \"yps_view_manager.h\"\n#include \"yps_app_status.h\"\n#include \"bllLog.h\"\n#include \"yps_bt.h\"\n#include \"yps_dataset.h\"\n#include \"yps_page_base.h\"\n\nyps_view_t* _view_music = NULL;\nbool _has_volume_view = false;\n\nstatic yps_view_item_focus_map_t _focus_map_list[ ] = {\n};\n\n//当前view焦点顺序配置\nstatic yps_view_focus_t _pop_view_music_focus = {\n    .pre_view_name = \"\",\n    .focus_map_list = _focus_map_list,\n    .focus_map_num = sizeof(_focus_map_list) / sizeof(yps_view_item_focus_map_t),\n    .focus_id = -1,  //页面创建之后焦点默认在第一个item上\n    .default_focus_id = 0,\n};\n\n\nstatic yps_lang_t _pop_view_music_lang[ ] = {\n};\n\nstatic yps_lang_list_t _pop_view_music_lang_list = {\n    .list = _pop_view_music_lang,\n    .count = sizeof(_pop_view_music_lang) / sizeof(yps_lang_t)\n};\n\nYPS_VIEW_DATA_MODEL_CB(pop_view_music) {\n    yps_bt_music_info_t* music_info = yps_status_get_music_info();\n    if (strcmp(target_widget_name, \"music_name\") == 0) {\n        strcpy(value.value.string_value, (char*)music_info->track_title);\n    }\n    else if (strcmp(target_widget_name, \"tip\") == 0) {\n        strcpy(value.value.string_value, (char*)music_info->track_artist);\n    }\n    // LOGAPPD(\"value.value.string_value = %s\", value.value.string_value);\n    return value;\n}\n\n//view数据模型定义，用于view内子控件和数据绑定\nstatic yps_view_data_model_t _pop_view_music_data_model[ ] = {\n    {\n        .widget_name = \"music_name\",\n        .value = {\n            .data_type = YPS_VIEW_DATA_TYPE_SCROLL_STRING,\n            .value.string_value = \"\",\n        },\n        .data_model_cb = YPS_VIEW_DATA_MODEL_CB_NAME(pop_view_music),\n    },\n    {\n        .widget_name = \"tip\",\n        .value = {\n            .data_type = YPS_VIEW_DATA_TYPE_SCROLL_STRING,\n            .value.string_value = \"\",\n        },\n        .data_model_cb = YPS_VIEW_DATA_MODEL_CB_NAME(pop_view_music),\n    }\n};\n\n\nstatic bool pop_view_music_on_click(yps_view_t* view_obj, yps_click_type_t click_type) {\n    if (click_type == YPS_CLICK_UP || click_type == YPS_CLICK_DOWN) {\n        if (_has_volume_view) {\n            pop_view_volume_open(view_obj->parent);\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    else if (click_type == YPS_CLICK_LONG_UP) {\n        LOGAPPD(\"播放上一曲~~~~~~~~~~\");\n        yps_bll_bt_exec_command(YPS_BT_INDEX_PHONE, YPS_COMMAND_BT_MUSIC_PREV, 0, 0);\n        return false;\n    }\n    else if (click_type == YPS_CLICK_LONG_DOWN) {\n        LOGAPPD(\"播放下一曲~~~~~~~~~~\");\n        yps_bll_bt_exec_command(YPS_BT_INDEX_PHONE, YPS_COMMAND_BT_MUSIC_NEXT, 0, 0);\n        return false;\n    }\n    else if (click_type == YPS_CLICK_LONG_OK) {\n        LOGAPPD(\"播放状态~~~~~~~~~~ %d    \\n\", yps_status_get_music_info()->play_state);\n        if (yps_status_get_music_info()->play_state == 1) {\n            yps_bll_bt_exec_command(YPS_BT_INDEX_PHONE, YPS_COMMAND_BT_MUSIC_PLAYPAUSE, 0, 0);\n            LOGAPPD(\"暂停播放音乐\");\n        }\n        else {\n            yps_bll_bt_exec_command(YPS_BT_INDEX_PHONE, YPS_COMMAND_BT_MUSIC_PLAY, 0, 0);\n            LOGAPPD(\"继续播放音乐\");\n        }\n        return false;\n    }\n    return true;\n}\n\nstatic void pop_view_music_close() {\n    // yps_view_manager_remove_by_view_name(\"pop_view_music\");\n    _view_music = yps_view_manager_get_view_by_name(\"pop_view_music\");\n    if (_view_music == NULL) {\n        return;\n    }\n\n    // widget_pause_animator(_view_music->view,\"ic_music_anim\");\n    yps_view_hide(_view_music);\n}\n\nstatic int _timer_updater = 0;\nstatic int _clear_count = 0;\nstatic ret_t view_music_updater(const timer_info_t* timer) {\n    if (_view_music != NULL && get_page_code() >= YPS_PAGE_MIRROR) {\n        if (widget_get_visible(_view_music->view)) {\n            widget_invalidate(_view_music->view, NULL);\n        }\n        else {\n            if (_clear_count++ < 5) {\n                yps_view_clear_canvas(_view_music);\n                widget_invalidate(_view_music->view, NULL);\n            }\n            else {\n                _clear_count = 0;\n                return RET_REMOVE;\n            }\n        }\n    }\n    else {\n        _clear_count = 0;\n        return RET_REMOVE;\n    }\n    return RET_REPEAT;\n}\n\n\n//view事件回调函数定义，感兴趣的事件可以在这里处理\nYPS_VIEW_EVENT_CB(pop_view_phone_call) {\n    yps_view_t* view_obj = (yps_view_t*)view;\n    if (event_type == YPS_VIEW_EVENT_SHOW) {\n        _timer_updater = widget_add_timer(view_obj->view, view_music_updater, 100);\n    }\n    else if (event_type == YPS_VIEW_EVENT_HIDE) {\n        // yps_view_clear_canvas(view_obj);\n        // widget_remove_timer(view_obj->view, _timer_updater);\n    }\n    else if (event_type == YPS_VIEW_EVENT_CLICK) {\n        return pop_view_music_on_click(view_obj, click_type);\n    }\n\n    return true;\n}\n\n\nvoid pop_view_music_handle(widget_t* parent) {\nyps_bt_hfp_state_t phone_state = ",
    "raw_res": "0;",
    "prompt_res": "yps_status_get_phone_call_state();",
    "gt": "yps_status_get_phone_call_state();"
  },
  {
    "id": 254,
    "pkg": "YPS-Instrument3",
    "fpath": "src/framework/yps_ui_updater.c",
    "input": "#include \"yps_ui_updater.h\"\n#include <stddef.h>\n#include <awtk.h>\n#include <sys/time.h>\n#include <tkc/thread.h>\n#include <tkc/platform.h>\n#include <tkc/types_def.h>\n#include \"yps_dataset.h\"\n#include \"yps_mcu.h\"\n#include \"yps_bt.h\"\n#include \"yps_ec.h\"\n#include \"bllLog.h\"\n#include \"yps_time_view.h\"\n#include \"yps_app_status.h\"\n\n#ifndef YPS_DATA_FUEL_MODE\n#define YPS_DATA_FUEL_MODE  0\n#endif\n\nextern const widget_vtable_t g_image_value_vtable;\nextern const widget_vtable_t g_label_vtable;\nextern const widget_vtable_t g_image_vtable;\n\n//油量状态\ntypedef enum _fuel_status_t {\n    FUEL_STATUS_NONE = -1,      //无效值\n    FUEL_STATUS_NORMAL = 0,     //正常，显示图标0\n    FUEL_STATUS_LOW,            //低油量 显示图标1，1Hz闪烁\n}fuel_status_t;\n\n//机油压力状态\ntypedef enum _oil_pressure_status_t {\n    OIL_PRESSURE_NONE = -1,      //无效值\n    OIL_PRESSURE_STATUS_NORMAL = 0,     //正常， 图标不显示\n    OIL_PRESSURE_STATUS_LOW,            //低油压 1Hz闪烁\n}oil_pressure_status_t;\n\n//水温状态\ntypedef enum _water_temp_status_t {\n    WATER_TEMP_NONE = -1,               //无效值\n    WATER_TEMP_STATUS_NORMAL = 0,     //正常， 图标1\n    WATER_TEMP_STATUS_HIGH,            //高水温 图标2\n}water_temp_status_t;\n\nstatic widget_t* _ic_light_turn_left;  //左转向灯图标\nstatic widget_t* _ic_light_turn_right; //右转向灯图标\nstatic widget_t* _ic_light_far;        //远光灯图标\nstatic widget_t* _ic_light_near;       //近光灯图标\nstatic widget_t* _ic_bt;               //蓝牙图标\nstatic widget_t* _ic_wifi;             //wifi图标 互联状态\nstatic widget_t* _ic_music;            //蓝牙音乐图标\nstatic widget_t* _ic_phone_battery;    //手机电量图标\nstatic widget_t* _ic_gms;              //GMS图标\nstatic widget_t* _ic_auto;             //自动启停图标\nstatic widget_t* _ic_fuel;             //油量图标\nstatic widget_t* _ic_engine_oil;       //机油压力图标\nstatic widget_t* _ic_abs;              //ABS图标\nstatic widget_t* _ic_tire_pressure;    //胎压图标\nstatic widget_t* _ic_engine;           //发动机故障图标\nstatic widget_t* _ic_water_temper;     //水温图标\nstatic widget_t* _prg_fuel_level;        //油量格数\nstatic widget_t* _prg_water_temper_level; //水温格数\nstatic widget_t* _ic_temper;               //气温图标\nstatic widget_t* _txt_temper;              //气温\nstatic widget_t* _ic_temper_unit;          //气温单位\nstatic widget_t* _txt_speed;               //车速速度\nstatic widget_t* _ictxt_speed_unit;        //车速单位,需要同时支持图标和文本控件类型\nstatic widget_t* _txt_battery_soc1;        //电池1电量\nstatic widget_t* _txt_battery_soc2;        //电池2电量\nstatic widget_t* _txt_total_battery_soc;   //总电量文本\nstatic widget_t* _prg_total_battery_soc;  //总电量进度条\nstatic widget_t* _ic_gear;                 //档位图标\nstatic widget_t* _view_altitude;           //海拔显示控件\nstatic widget_t* _txt_altitude;            //海拔数值显示控件\nstatic widget_t* _prog_rpm;                //转速表控件\nstatic widget_t* _ic_dirve_mode;           //驾驶模式图标\nstatic widget_t* _ic_side_stand;           //侧支撑图标\nstatic widget_t* _ic_tcs;                  //牵引力控制系统图标\nstatic widget_t* _ic_ready;\nstatic widget_t* _ic_gps;\n\n\nint _ic_ble_value = -1;\nint _ic_bt_value = -1;\n\n\n//图标闪烁 -1: 无效值 0:正常 1:闪烁\nstatic int32_t _ic_fuel_blink_status = -1;\nstatic int32_t _ic_engine_oil_blink_status = -1;\n\n//更新油量格数\nstatic int _fuel_level_vaule = -1;\nstatic uint64_t _fuel_level_update_time = 0;\n//通过油量百分比获取油量格数\nstatic int get_fuel_level_by_percent() {\n    int level = -1;\n    int value = GET_INT(DI_MCU_CAPA_OIL_PERCENT);\n    if (value >= 74) {\n        level = 6;\n    }\n    else if (value >= 60) {\n        level = 5;\n    }\n    else if (value >= 46) {\n        level = 4;\n    }\n    else if (value >= 36) {\n        level = 3;\n    }\n    else if (value >= 24) {\n        level = 2;\n    }\n    else if (value >= 17) {\n        level = 1;\n    }\n    else {\n        level = 0;\n    }\n    return level;\n}\n\nstatic void update_ic_fuel(bool flag) {\n    uint64_t t = get_time_ms64();\n    if (t - _fuel_level_update_time < 600 && !flag) return;\n    _fuel_level_update_time = t;\n\n    int level = 0;\n    int flag_capa = GET_INT(DI_MCU_CAPA_OIL_FLAG);\n    int flage_level = GET_INT(DI_MCU_OIL_LEVEL_FLAG);\n    if (flag_capa == 0 && flage_level == 0) {// 油量数据无效， 隐藏油壶图标， 油量格数设置为0\n        if (_prg_fuel_level != NULL) {\n            image_value_set_value(_prg_fuel_level, 0);\n        }\n\n#if YPS_DATA_FUEL_MODE == 1\n        if (_ic_fuel != NULL) {\n            if (_ic_fuel_blink_status != 1) {\n                widget_set_visible(_ic_fuel, TRUE);\n                _ic_fuel_blink_status = 1;\n            }\n            image_value_set_value(_ic_fuel, 0);\n        }\n        _fuel_level_vaule = 0;\n#else   //油壶图标默认模式\n        if (_ic_fuel != NULL) {\n            widget_set_visible(_ic_fuel, FALSE);\n            _ic_fuel_blink_status = -1;\n        }\n        _fuel_level_vaule = -1;\n#endif\n        return;\n    }\n    else if (flag_capa) {\n        level = get_fuel_level_by_percent();\n    }\n    else{\n        level = GET_INT(DI_MCU_OIL_LEVEL);\n    }\n\n    if (_fuel_level_vaule == -1) flag = true;\n    if (flag || _fuel_level_vaule != level) {\n        if (_prg_fuel_level != NULL) {\n            _fuel_level_vaule = _fuel_level_vaule < 0 ? 0 : _fuel_level_vaule;\n            if (tk_abs(level - _fuel_level_vaule) > 1) {\n                char str_anim[128] = { 0 };\n                tk_snprintf(str_anim, 128, \"value(from=%d,to=%d,duration=600,repeat_times=1,auto_play=true,auto_destroy=true,easing=linear);\", _fuel_level_vaule, level);\n                widget_set_animation(_prg_fuel_level, str_anim);\n            }\n            image_value_set_value(_prg_fuel_level, level);\n        }\n        _fuel_level_vaule = level;\n        if (_ic_fuel != NULL) {\n            if (level == 0) {\n                image_value_set_value(_ic_fuel, 0);\n                _ic_fuel_blink_status = 1;\n            }\n            else {\n                image_value_set_value(_ic_fuel, 1);\n                _ic_fuel_blink_status = 0;\n                widget_set_visible(_ic_fuel, TRUE);\n            }\n        }\n    }\n}\n\n//更新机油压力图标\nstatic oil_pressure_status_t _oil_pressure_status = OIL_PRESSURE_NONE;\nstatic void update_ic_engine_oil(bool flag) {\n    if (_ic_engine_oil != NULL) {\n        oil_pressure_status_t oil_pressure_status = GET_INT(DI_MCU_LIGHT_OIL_PRESSURE) == 0 ? OIL_PRESSURE_STATUS_NORMAL : OIL_PRESSURE_STATUS_LOW;\n        if (GET_INT(DI_MCU_LIGHT_OIL_PRESSURE_FLAG) == 0) {\n            _ic_engine_oil_blink_status = 0;\n            widget_set_visible(_ic_engine_oil, false);\n            return;\n        }\n        \n        if (flag || _oil_pressure_status != oil_pressure_status) {\n            _oil_pressure_status = oil_pressure_status;\n            if (_oil_pressure_status == OIL_PRESSURE_STATUS_NORMAL) {\n                widget_set_visible(_ic_engine_oil, false);\n                _ic_engine_oil_blink_status = 0;\n            }\n            else {\n                // widget_set_visible(_ic_engine_oil, true);\n                _ic_engine_oil_blink_status = 1;\n            }\n        }\n    }\n    else {\n        _ic_engine_oil_blink_status = -1;\n    }\n}\n\n//更新水温图标\nstatic water_temp_status_t _water_temp_status = WATER_TEMP_NONE;\nstatic uint64_t _water_ic_temp_update_time = 0;\nstatic void update_ic_water_temp(bool flag) {\n    if (_ic_water_temper != NULL) {\n        water_temp_status_t water_temp_status = GET_INT(DI_MCU_TEMP_WATER_LEVEL) > 5 ? WATER_TEMP_STATUS_HIGH : WATER_TEMP_STATUS_NORMAL;\n        // LOGAPPD(\"DI_MCU_TEMP_WATER_LEVEL value ================== %d \", GET_INT(DI_MCU_TEMP_WATER_LEVEL));\n        uint64_t t = get_time_ms64();\n        if (flag || _water_temp_status != water_temp_status || t - _water_ic_temp_update_time > 500) {\n            _water_ic_temp_update_time = t;\n            _water_temp_status = water_temp_status;\n            if (_water_temp_status == WATER_TEMP_STATUS_NORMAL) {\n                image_value_set_value(_ic_water_temper, 0);\n            }\n            else {\n                image_value_set_value(_ic_water_temper, 1);\n            }\n        }\n    }\n}\n\n//更新水温格数\nstatic int _prg_water_temp_level_vaule = -1;\nstatic uint64_t _water_temp_prg_update_time = 0;\nstatic void update_ic_water_temp_num(bool flag) {\n    if (_prg_water_temper_level == NULL) return;\n    if (_prg_water_temp_level_vaule == -1) {\n        _prg_water_temp_level_vaule = 0;\n        flag = true;\n    }\n\n    int level = GET_INT(DI_MCU_TEMP_WATER_LEVEL);\n    uint64_t t = get_time_ms64();\n    if (flag || _prg_water_temp_level_vaule != level || t - _water_temp_prg_update_time > 1000) {\n        _water_temp_prg_update_time = t;\n        if (abs(level - _prg_water_temp_level_vaule) > 1) {\n            char str_anim[128] = { 0 };\n            tk_snprintf(str_anim, 128, \"value(from=%d,to=%d,duration=400,repeat_times=1,auto_play=true,auto_destroy=true,easing=linear);\", _prg_water_temp_level_vaule, level);\n            widget_set_animation(_prg_water_temper_level, str_anim);\n        }\n        image_value_set_value(_prg_water_temper_level, level);\n        _prg_water_temp_level_vaule = level;\n    }\n}\n\n//更新气温数据\nstatic int _temper_unit = 0; //0:摄氏度 1:华氏度\nstatic int _air_temper_value = 0;\nstatic void update_txt_air_temper(bool flag) {\n    if (_txt_temper == NULL) return;\n    int value;\n    _ic_ble_value = GET_INT(DI_BT_BLUETOOTH_BLE);\n    if (_ic_ble_value == 1) { //如果ble已经连接就优先从ble取数据\n        value = GET_INT(DI_BT_BLE_TEMPERATURE);\n        widget_set_visible(_ic_temper, true);\n        widget_set_visible(_txt_temper, true);\n        widget_set_visible(_ic_temper_unit, true);\n    }\n    else {\n        if (GET_INT(DI_MCU_TEMP_AIR_FLAG)) {\n            value = GET_INT(DI_MCU_TEMP_AIR);\n            widget_set_visible(_ic_temper, true);\n            widget_set_visible(_txt_temper, true);\n            widget_set_visible(_ic_temper_unit, true);\n        }\n        else {\n            widget_set_visible(_ic_temper, false);\n            widget_set_visible(_txt_temper, false);\n            widget_set_visible(_ic_temper_unit, false);\n            return;\n        }\n    }\n\n    if (_air_temper_value != value || flag) {\n        _air_temper_value = value;\n\n        if (_temper_unit == 1) {\n            value = (int)celsius_to_fahrenheit(value);\n        }\n\n        char buf[16] = { 0 };\n        tk_snprintf(buf, 16, \"%d\", value);\n        widget_set_text_utf8(_txt_temper, buf);\n    }\n}\n\n//更新温度单位\nstatic void update_temper_unit(bool flag) {\n    if (_ic_temper_unit == NULL) return;\n\n    int temper_unit = GET_INT(DI_MCU_UNIT_TEMPER);\n    if (temper_unit != _temper_unit || flag) {\n        _temper_unit = temper_unit;\n        if (_temper_unit == 0) {\n            image_value_set_value(_ic_temper_unit, 0);\n        }\n        else {\n            image_value_set_value(_ic_temper_unit, 1);\n        }\n        update_txt_air_temper(true);\n    }\n}\n\n//更新挡位图标\nstatic void update_ic_gear() {\n    if (_ic_gear == NULL) return;\n    if (!widget_is_instance_of(_ic_gear, &g_image_value_vtable)) {\n        LOGAPPD(\"更新挡位图标失败，挡位图标只能使用image_value控件类型\");\n        return;\n    }\n\n    if (GET_INT(DI_MCU_GEAR_FLAG)) {\n        int gear = GET_INT(DI_MCU_GEAR);\n        if(gear == 15) gear = 9;\n        image_value_set_value(_ic_gear, gear);\n    }\n    else {\n        image_value_set_value(_ic_gear, 9);\n    }\n}\n\n//更新信号图标\nstatic void update_ic_gms() {\n    if (_ic_gms == NULL) return;\n    if (_ic_bt_value == 1) {\n        widget_set_visible(_ic_gms, true);\n    }\n    else {\n        widget_set_visible(_ic_gms, false);\n        return;\n    }\n    image_value_set_value(_ic_gms, GET_INT(DI_BT_PHONE_SIGNAL));\n}\n\nstatic void update_ic_phone_battery() {\n    if (_ic_phone_battery == NULL) return;\n    if (_ic_bt_value == 1) {\n        widget_set_visible(_ic_phone_battery, true);\n    }\n    else {\n        widget_set_visible(_ic_phone_battery, false);\n        return;\n    }\n    image_value_set_value(_ic_phone_battery, GET_INT(DI_BT_PHONE_BATTERY));\n}\n\n// static float _altitude_value = 0.f;\nstatic uint64_t _last_altitude_update_time = 0;\nstatic void update_txt_altitude(bool flag) {\n    if (_view_altitude == NULL || _txt_altitude == NULL) return;\n    uint64_t t = get_time_ms64();\n\n    float value = GET_FLOAT(DI_BT_BLE_ALTITUDE);\n    _ic_ble_value = GET_INT(DI_BT_BLUETOOTH_BLE);\n\n    if (_ic_ble_value == 1) {\n        widget_set_visible(_view_altitude, true);\n    }\n    else {\n        widget_set_visible(_view_altitude, false);\n    }\n\n    //控制海拔数据更新频率\n    if (t - _last_altitude_update_time < 1000 || _ic_ble_value != 1) return;\n    _last_altitude_update_time = t;\n    char buf[16] = { 0 };\n    tk_snprintf(buf, 16, \"%d\", (int)value);\n    widget_set_text_utf8(_txt_altitude, buf);\n}\n\n//更新车速\nstatic int _speed_unit = 0; //0:km/h 1:mph\nstatic int _speed_value = 0;\nstatic void update_txt_speed(bool flag) {\n    if (_txt_speed == NULL) return;\n    int value = GET_INT(DI_MCU_SPEED);\n    if (_speed_value != value || flag) {\n        _speed_value = value;\n        if (_speed_unit == 1) {\n            value = km_to_mile(value);\n        }\n\n        if(widget_is_instance_of(_txt_speed, &g_image_value_vtable)){\n            image_value_set_value(_txt_speed, value);\n        }\n        else {\n            char buf[16] = { 0 };\n            tk_snprintf(buf, 16, \"%d\", value);\n            widget_set_text_utf8(_txt_speed, buf);\n        }\n    }\n}\n\n//更新车速单位\nstatic void update_speed_unit(bool flag) {\n    if (_ictxt_speed_unit == NULL) return;\n    int speed_unit = GET_INT(DI_MCU_UNIT_LENGTH);\n    if (_speed_unit < 0 || _speed_unit > 1) {\n        LOGAPPD(\"车速单位错误，使用默认单位km/h\");\n        _speed_unit = 0;\n    }\n    if (flag || speed_unit != _speed_unit) {\n        _speed_unit = speed_unit;\n        if (widget_is_instance_of(_ictxt_speed_unit, &g_label_vtable)) {\n            static const char* str_unit[ ] = { \"km/h\", \"mph\" };\n            widget_set_text_utf8(_ictxt_speed_unit, str_unit[_speed_unit]);\n        }\n        else if (widget_is_instance_of(_ictxt_speed_unit, &g_image_value_vtable)) {\n            image_value_set_value(_ictxt_speed_unit, _speed_unit);\n        }\n        else {\n            LOGAPPD(\"更新车速单位失败，车速单位使用的控件类型不支持...\");\n        }\n        update_txt_speed(true);\n    }\n}\n\n//更新驾驶模式显示\nstatic void update_ic_dirve_mode() {\n    if (_ic_dirve_mode == NULL) return;\n    if (GET_INT(DI_MCU_DRIVING_FLAG)) {\n        widget_set_visible(_ic_dirve_mode, true);\n        image_value_set_value(_ic_dirve_mode, GET_INT(DI_MCU_DRIVING_MODE));\n    }\n    else {\n        widget_set_visible(_ic_dirve_mode, false);\n    }\n}\n\n//更新TCS图标\nstatic int _tcs_value = -1;\nstatic void update_ic_tcs() {\n    if (_ic_tcs == NULL) return;\n\n    if (GET_INT(DI_MCU_TCS_FLAG) == 0) {\n        widget_set_visible(_ic_tcs, false);\n        return;\n    }\n\n    int value = GET_INT(DI_MCU_TCS_STATUS);\n    _tcs_value = value;\n    \n    switch (value) {\n        case 0://TCS诊断\n            widget_set_visible(_ic_tcs, false);\n            break;\n        case 1://TCS未作动\n            // yps_widget_ico_ex_set_image_id(_ic_tcs, 0);\n            // widget_set_visible(_ic_tcs, true);\n            widget_set_visible(_ic_tcs, false);\n            break;\n        // case 2://TCS作动\n        //     yps_widget_ico_ex_set_image_id(_ic_tcs, 1);\n        //     break;\n        case 3://TCS异常\n            image_value_set_value(_ic_tcs, 2);\n            widget_set_visible(_ic_tcs, true);\n            break;\n        case 4://TCS OFF\n            image_value_set_value(_ic_tcs, 0);\n            widget_set_visible(_ic_tcs, true);\n            break;\n        default:\n            image_value_set_value(_ic_tcs, 1);\n            widget_set_visible(_ic_tcs, true);\n            break;\n    }\n    // yps_widget_ico_ex_set_image_id(_ic_tcs, GET_INT(DI_MCU_TCS_STATUS));\n}\n\nstatic void update_ic_ready() {\n    if (_ic_ready == NULL) return;\n    if (GET_INT(DI_MCU_LIGHT_READY_FLAG)) {\n        widget_set_visible(_ic_ready, GET_INT(DI_MCU_LIGHT_READY));\n    }\n    else {\n        widget_set_visible(_ic_ready, false);\n    }\n}\n\nstatic void update_ic_gps() {\n    if (_ic_gps == NULL) return;\n    if (GET_INT(DI_MCU_SIGNAL_GPS_FLAG)) {\n        widget_set_visible(_ic_gps, GET_INT(DI_MCU_SIGNAL_GPS));\n    }\n    else {\n        widget_set_visible(_ic_gps, false);\n    }\n}\n\n//更新侧支撑图标\nstatic void update_ic_side_stand() {\n    if (_ic_side_stand == NULL) return;\n    if (GET_INT(DI_MCU_LIGHT_SIDE_STAND_FLAG)) {\n        if (GET_INT(DI_MCU_LIGHT_SIDE_STAND)) {\n            widget_set_visible(_ic_side_stand, true);\n        }\n        else {\n            widget_set_visible(_ic_side_stand, false);\n        }\n    }\n    else {\n        widget_set_visible(_ic_side_stand, false);\n    }\n}\n\n//更新电车电池电量数据\nstatic int _battery_soc1 = -1;\nstatic int _battery_soc2 = -1;\nstatic int _total_battery_soc = -1;\nstatic void update_battery_soc(bool flag) {\n    if (_txt_battery_soc1 != NULL) {\n        if (GET_INT(DI_MCU_BATTERY_SOC1_FLAG)) {\n            int tmp_soc1 = GET_INT(DI_MCU_BATTERY_SOC1);\n            if (flag || _battery_soc1 != tmp_soc1) {\n                _battery_soc1 = tmp_soc1;\n                char buf[16] = { 0 };\n                tk_snprintf(buf, 16, \"%d%%\", _battery_soc1);\n                widget_set_text_utf8(_txt_battery_soc1, buf);\n            }\n        }\n        else {\n            widget_set_text_utf8(_txt_battery_soc1, \"--\");\n        }\n    }\n\n    if (_txt_battery_soc2 != NULL) {\n        if (GET_INT(DI_MCU_BATTERY_SOC2_FLAG)) {\n            int tmp_soc2 = GET_INT(DI_MCU_BATTERY_SOC2);\n            if (flag || _battery_soc2 != tmp_soc2) {\n                _battery_soc2 = tmp_soc2;\n                char buf[16] = { 0 };\n                tk_snprintf(buf, 16, \"%d%%\", _battery_soc2);\n                widget_set_text_utf8(_txt_battery_soc2, buf);\n            }\n        }\n        else {\n            widget_set_text_utf8(_txt_battery_soc2, \"--\");\n        }\n    }\n\n    if (GET_INT(DI_MCU_BATTERY_TOTAL_FLAG)) {\n        _total_battery_soc = GET_INT(DI_MCU_BATTERY_TOTAL);\n        if (_txt_total_battery_soc != NULL) {\n            char buf[16] = { 0 };\n            tk_snprintf(buf, 16, \"%d%%\", _total_battery_soc);\n            widget_set_text_utf8(_txt_total_battery_soc, buf);\n        }\n\n        if(_prg_total_battery_soc != NULL){\n            progress_bar_set_value(_prg_total_battery_soc, _total_battery_soc);\n        }\n    }\n    else {\n        _total_battery_soc = -1;\n        if (_txt_total_battery_soc != NULL) {\n            char buf[16] = { 0 };\n            tk_snprintf(buf, 16, \"--\", _total_battery_soc);\n            widget_set_text_utf8(_txt_total_battery_soc, buf);\n        }\n\n        if(_prg_total_battery_soc != NULL){\n            progress_bar_set_value(_prg_total_battery_soc, 0);\n        }\n    }\n}\n\nstatic ret_t reset_ic_status_checkself_after(void* ctx) {\n    update_ic_water_temp(true);\n    update_ic_fuel(true);\n    update_ic_engine_oil(true);\n    update_ic_water_temp_num(true);\n    update_ic_gms();\n    update_ic_phone_battery();\n    update_temper_unit(true);\n    update_txt_air_temper(true);\n    update_ic_gear();\n    update_ic_dirve_mode();\n    update_ic_tcs();\n    update_ic_ready();\n    update_ic_gps();\n    update_ic_side_stand();\n    update_speed_unit(true);\n    update_txt_speed(true);\n    update_txt_altitude(true);\n\n    return RET_OK;\n}\n\nstatic ret_t reset_ic_status_checkself_befor(void* ctx) {\n    bool bveisible = true;\n    if (get_check_animation_status() == 1) {\n        bveisible = false;\n    }\n    if (_ic_light_turn_left != NULL) widget_set_visible(_ic_light_turn_left, bveisible);\n    if (_ic_light_turn_right != NULL) widget_set_visible(_ic_light_turn_right, bveisible);\n    if (_ic_light_far != NULL) widget_set_visible(_ic_light_far, bveisible);\n    if (_ic_light_near != NULL)  widget_set_visible(_ic_light_near, bveisible);\n    if (_ic_bt != NULL) widget_set_visible(_ic_bt, bveisible);\n    if (_ic_auto != NULL) widget_set_visible(_ic_auto, bveisible);\n#if YPS_DATA_FUEL_MODE == 1\n    if (_ic_fuel != NULL) widget_set_visible(_ic_fuel, TRUE);\n#else\n    if (_ic_fuel != NULL) widget_set_visible(_ic_fuel, !bveisible);\n#endif\n    if (_ic_engine_oil != NULL) widget_set_visible(_ic_engine_oil, bveisible);\n    if (_ic_abs != NULL) widget_set_visible(_ic_abs, bveisible);\n    if (_ic_tire_pressure != NULL) widget_set_visible(_ic_tire_pressure, bveisible);\n    if (_ic_engine != NULL) widget_set_visible(_ic_engine, bveisible);\n    if (_ic_wifi != NULL) widget_set_visible(_ic_wifi, bveisible);\n    if (_ic_music != NULL) widget_set_visible(_ic_music, bveisible);\n    if (_ic_phone_battery != NULL) widget_set_visible(_ic_phone_battery, bveisible);\n    if (_ic_gms != NULL) widget_set_visible(_ic_gms, bveisible);\n    if (_ic_dirve_mode != NULL) widget_set_visible(_ic_dirve_mode, false);\n    if (_ic_side_stand != NULL) widget_set_visible(_ic_side_stand, true);\n    if (_ic_tcs != NULL) widget_set_visible(_ic_tcs, bveisible);\n    if (_view_altitude != NULL) widget_set_visible(_view_altitude, false);\n\n    update_temper_unit(true);\n    update_txt_air_temper(true);\n\n    widget_t* top_view = widget_lookup(WIDGET(ctx), \"view_top\", TRUE);\n    if (top_view != NULL) {\n        widget_set_visible(top_view, TRUE);\n    }\n\n    return RET_OK;\n}\n\nstatic void yps_ui_elements_init(widget_t* page) {\n    yps_time_view_init(page);\n    _ic_light_turn_left = widget_lookup(page, \"ic_light_turn_left\", true);\n    _ic_light_turn_right = widget_lookup(page, \"ic_light_turn_right\", true);\n    _ic_light_far = widget_lookup(page, \"ic_light_far\", true);\n    _ic_light_near = widget_lookup(page, \"ic_light_near\", true);\n    _ic_bt = widget_lookup(page, \"ic_bt\", true);\n    _ic_auto = widget_lookup(page, \"ic_auto\", true);\n    _ic_fuel = widget_lookup(page, \"ic_fuel\", true);\n    _ic_engine_oil = widget_lookup(page, \"ic_engine_oil\", true);\n    _ic_abs = widget_lookup(page, \"ic_abs\", true);\n    _ic_tire_pressure = widget_lookup(page, \"ic_tire_pressure\", true);\n    _ic_engine = widget_lookup(page, \"ic_engine\", true);\n    _ic_wifi = widget_lookup(page, \"ic_wifi\", true);\n    _ic_music = widget_lookup(page, \"ic_music\", true);\n    _ic_phone_battery = widget_lookup(page, \"ic_phone_battery\", true);\n    _ic_gms = widget_lookup(page, \"ic_gsm\", true);\n\n    _ic_water_temper = widget_lookup(page, \"ic_water_temper\", true);\n    _prg_fuel_level = widget_lookup(page, \"prg_oil_capacity\", true);\n    _prg_water_temper_level = widget_lookup(page, \"prg_water_temper\", true);\n    _ic_temper = widget_lookup(page, \"ic_temper\", true);\n    _txt_temper = widget_lookup(page, \"txt_temper\", true);\n    _ic_temper_unit = widget_lookup(page, \"ic_temper_unit\", true);\n    _ic_gear = widget_lookup(page, \"ic_gear\", true);\n    _ic_dirve_mode = widget_lookup(page, \"ic_dirve_mode\", true);\n    _ic_side_stand = widget_lookup(page, \"ic_side_stand\", true);\n    _ic_tcs = widget_lookup(page, \"ic_tcs\", true);\n    _ic_ready = widget_lookup(page, \"ic_ready\", true);\n    _ic_gps = widget_lookup(page, \"ic_gps\", true);\n    _txt_speed = widget_lookup(page, \"speed_value\", true);\n    _ictxt_speed_unit = widget_lookup(page, \"speed_unit\", true);\n_txt_battery_soc1 = ",
    "raw_res": "widget_lookup(page, \"battery_soc1\", true);",
    "prompt_res": "widget_lookup(page, \"txt_battery_soc1\", true);",
    "gt": "widget_lookup(page, \"txt_battery_soc1\", true);"
  },
  {
    "id": 294,
    "pkg": "YPS-Instrument3",
    "fpath": "src/framework/yps_view_base.c",
    "input": "#include <stdio.h>\n#include \"awtk_widget_common.h\"\n#include \"bllLog.h\"\n#include \"yps_view_base.h\"\n#include \"yps_view_manager.h\"\n#include \"yps_widget/qr.h\"\n#include \"yps_page_base.h\"\n#include \"yps_app_status.h\"\n#include \"yps_dataset.h\"\n#include \"yps_mcu.h\"\n#include \"yps_theme_managr.h\"\n\n\nstatic ret_t clear_view_canvas(const idle_info_t* info) {\n    if(info == NULL) return RET_OK;\n    native_window_t* native_window =\n        (native_window_t *)widget_get_prop_pointer(window_manager(), WIDGET_PROP_NATIVE_WINDOW);\n    canvas_t* c = native_window_get_canvas(native_window);\n    yps_view_t* yps_view = (yps_view_t*)info->ctx;\n    if (yps_view != NULL) {\n        canvas_clear_rect(c, yps_view->view->x, yps_view->view->y, yps_view->view->w, yps_view->view->h);\n        widget_invalidate(yps_view->view, NULL);\n        // rect_t rect = {yps_view->view->x, yps_view->view->y, yps_view->view->w, yps_view->view->h}; \n        // widget_invalidate(yps_view->parent, &rect);\n    }\n    return RET_OK;\n}\n\nstatic void yps_view_destory_animator(yps_view_t* obj) {\n    if (widget_find_animator(obj->view, \"show\") != NULL) {\n        widget_stop_animator(obj->view, \"show\");\n        widget_destroy_animator(obj->view, \"show\");\n    }\n\n    if (widget_find_animator(obj->view, \"hide\") != NULL) {\n        widget_stop_animator(obj->view, \"hide\");\n        widget_destroy_animator(obj->view, \"hide\");\n    }\n}\n\nstatic ret_t yps_view_on_focused_event(void* ctx, event_t* e) {\n    yps_view_t* view_obj = (yps_view_t*)ctx;\n    widget_t* target_widget = WIDGET(e->target);\n    // LOGAPPD(\"view: %s => %s, 接收到获取焦点消息\", view_obj->view_name, target_widget->name);\n\n    yps_view_show(view_obj);\n\n    if (view_obj->view_cb != NULL) {\n        view_obj->view_cb((void*)view_obj, YPS_VIEW_EVENT_FOCUS, 0, target_widget);\n    }\n    return RET_OK;\n}\n\nstatic ret_t yps_view_on_kill_focus_event(void* ctx, event_t* e) {\n    if (ctx == NULL || e == NULL) {\n        return RET_OK;\n    }\n    yps_view_t* view_obj = (yps_view_t*)ctx;\n    widget_t* target_widget = WIDGET(e->target);\n    // LOGAPPD(\"view: %s => %s, 接收到失去焦点消息\", view_obj->view_name, target_widget->name);\n    if (view_obj->view_cb != NULL) {\n        view_obj->view_focus.focus_id = -1;\n        view_obj->view_cb((void*)view_obj, YPS_VIEW_EVENT_KILL_FOCUS, YPS_CLICK_NONE, NULL);\n    }\n\n    return RET_OK;\n}\n\n// static ret_t yps_view_on_close_event(void* ctx, event_t* e) {\n//     yps_view_t* view_obj = (yps_view_t*)ctx;\n//     widget_t* target_widget = WIDGET(e->target);\n//     if (view_obj->view_cb != NULL) {\n//         view_obj->view_cb((void*)view_obj, YPS_VIEW_EVENT_DESTROY, YPS_CLICK_NONE, NULL);\n//     }\n//     return RET_OK;\n// }\n\n\nstatic ret_t yps_view_on_focused_item_event(void* ctx, event_t* e) {\n    yps_view_t* view_obj = (yps_view_t*)ctx;\n    widget_t* item = WIDGET(e->target);\n    if (widget_get_visible(item) == FALSE) {\n        widget_set_visible(item, TRUE);\n    }\n    //  LOGAPPD(\"view: %s, item： %s接收到获取焦点消息\", view_obj->view_name, item->name);\n    if (view_obj->view_cb != NULL) {\n        view_obj->view_cb((void*)view_obj, YPS_VIEW_EVENT_FOCUS_ITEM, YPS_CLICK_NONE, (void*)item);\n    }\n\n    return RET_OK;\n}\n\nstatic ret_t yps_view_on_kill_focus_item_event(void* ctx, event_t* e) {\n    yps_view_t* view_obj = (yps_view_t*)ctx;\n    widget_t* item = WIDGET(e->target);\n    // LOGAPPD(\"view: %s, item： %s接收到失去焦点消息\", view_obj->view_name, item->name);\n\n    if (view_obj->view_cb != NULL) {\n        view_obj->view_cb((void*)view_obj, YPS_VIEW_EVENT_KILL_FOCUS_ITEM, YPS_CLICK_NONE, (void*)item);\n    }\n    return RET_OK;\n}\n\nstatic void yps_view_data_to_widget(widget_t* widget, yps_data_model_value_t data) {\n    switch (data.data_type) {\n        case YPS_VIEW_DATA_TYPE_DIGIT:\n            image_value_set_value(widget, data.value.int_value);\n            break;\n        case YPS_VIEW_DATA_TYPE_IMAGE_ID:\n            yps_widget_ico_ex_set_image_id(widget, data.value.int_value);\n            break;\n        case YPS_VIEW_DATA_TYPE_PROGRESS:\n            widget_set_value(widget, data.value.int_value);\n            break;\n        case YPS_VIEW_DATA_TYPE_BOOL:\n            widget_set_visible(widget, data.value.bool_value);\n            break;\n        case YPS_VIEW_DATA_TYPE_STRING:\n            widget_set_text_utf8(widget, data.value.string_value);\n            // replace_no_exist_font_with_default_font(widget, data.value.string_value, 256);\n            break;\n        case YPS_VIEW_DATA_TYPE_FILTER_STRING:\n            replace_no_exist_font_with_default_font(widget, data.value.string_value, 256);\n            break;\n        case YPS_VIEW_DATA_TYPE_SCROLL_STRING:\n            hscroll_label_stop(widget);\n            // widget_set_text_utf8(widget, data.value.string_value);\n            replace_no_exist_font_with_default_font(widget, data.value.string_value, 256);\n            hscroll_label_start(widget);\n            break;\n        case YPS_VIEW_DATA_TYPE_IMAGE_NAME:\n            image_set_image(widget, data.value.string_value);\n            break;\n        case YPS_VIEW_DATA_TYPE_QRCODE:\n            widget_set_style_color(widget, \"bg_color\", 0xffffffff);\n            widget_set_style_color(widget, \"fg_color\", 0xff000000);\n            qr_set_value(widget, data.value.string_value);\n            break;\n        default:\n            LOGAPPD(\"%s:%d 不支持的数据绑定类型\\n\", __FILE__, __LINE__);\n            break;\n    }\n}\n\nstatic void yps_view_item_bind_event(yps_view_t* view) {\n    widget_on(view->view, EVT_FOCUS, yps_view_on_focused_event, view);\n    widget_on(view->view, EVT_BLUR, yps_view_on_kill_focus_event, view);\n    // widget_on(view->view, EVT_WINDOW_CLOSE, yps_view_on_close_event, view);\n    for (int i = 0; i < view->view_focus.focus_map_num; i++) {\n        char* item_name = view->view_focus.focus_map_list[i].item_name;\n        widget_t* item = find_widget(view->view, item_name);\n        if (item == NULL) {\n            LOGAPPD(\"绑定焦点事件失败 view: %s 未找到控件【%s】\\n\", view->view_name, item_name);\n            continue;\n        }\n        widget_set_focusable(item, true);\n        widget_on(item, EVT_FOCUS, yps_view_on_focused_item_event, view);\n        widget_on(item, EVT_BLUR, yps_view_on_kill_focus_item_event, view);\n    }\n\n    //根据焦点配置情况设置焦点\n    if (view->view_focus.focus_id < 0) {\n\n    }\n    else if (view->view_focus.focus_id == 0) {\n        widget_set_focused(view->view, true);\n    }\n    else {\n        char* item_name = view->view_focus.focus_map_list[view->view_focus.focus_id - 1].item_name;\n        widget_t* item = find_widget(view->view, item_name);\n        if (item == NULL) {\n            LOGAPPD(\"初始化焦点设置失败 view: %s 未找到控件【%s】\\n\", view->view_name, item_name);\n            return;\n        }\n        LOGAPPD(\"view: %s焦点设置到item: %s \\n\", view->view_name, item_name);\n        widget_set_focused(item, true);\n    }\n}\n\nstatic void yps_view_item_unbind_event(yps_view_t* view) {\n    widget_off_by_func(view->view, EVT_FOCUS, yps_view_on_focused_event, view);\n    widget_off_by_func(view->view, EVT_BLUR, yps_view_on_kill_focus_event, view);\n\n    for (int i = 0; i < view->view_focus.focus_map_num; i++) {\n        char* item_name = view->view_focus.focus_map_list[i].item_name;\n        widget_t* item = find_widget(view->view, item_name);\n        if (item == NULL) {\n            continue;\n        }\n        widget_off_by_func(item, EVT_FOCUS, yps_view_on_focused_item_event, view);\n        widget_off_by_func(item, EVT_BLUR, yps_view_on_kill_focus_item_event, view);\n    }\n}\n\n//yps_view 窗口关闭动画播放完成通知\nstatic ret_t yps_view_close_anim_done_event(void* ctx, event_t* e) {\n    widget_t* view = WIDGET(ctx);\n    widget_set_visible(view, false);\n    if (view->parent) {\n        widget_invalidate(view->parent, NULL);\n    }\n    // LOGAPPD(\"view: %s 关闭动画播放完成\\n\", view->name);\n    return RET_OK;\n}\n\nstatic ret_t yps_view_show_anim_done_event(void* ctx, event_t* e) {\n    widget_t* view = WIDGET(ctx);\n    widget_set_visible(view, true);\n    if (view->parent) {\n        widget_invalidate(view->parent, NULL);\n    }\n    // LOGAPPD(\"view: %s 显示动画播放完成\\n\", view->name);\n    return RET_OK;\n}\n\nvoid yps_view_update(yps_view_t* view) {\n    if (view == NULL) return;\n    if (view->view_cb != NULL) {\n        view->view_cb((void*)view, YPS_VIEW_EVENT_UPDATE, YPS_CLICK_NONE, NULL);\n    }\n\n    for (int idm = 0; idm < view->data_model_num; idm++) {\n        yps_view_data_model_t vdm = view->data_model[idm];\n        // LOGAPPD(\"%s:%d view: %s 查找控件【%s】\\n\", __FILE__, __LINE__, view->view_name, vdm.widget_name);\n\n        widget_t* widget = find_widget(view->view, vdm.widget_name);\n        if (widget == NULL) {\n            LOGAPPD(\" view: %s 未找到控件【%s】\\n\", view->view_name, vdm.widget_name);\n            continue;\n        }\n\n        //更新数据到view,如果有数据回调函数 就优先使用数据回调\n        if (vdm.data_model_cb != NULL) {\n            view->data_model[idm].value = vdm.data_model_cb(view->view_name, vdm.widget_name, view->data_model[idm].value);\n            yps_view_data_to_widget(widget, view->data_model[idm].value);\n        }\n        else {\n            continue;\n        }\n    }\n}\n\n//更新多语言显示\nvoid yps_view_update_lang_text(yps_view_t* view) {\n    yps_update_lang_text(view->view, view->lang_list);\n}\n\nvoid yps_view_show(yps_view_t* view) {\n    if (widget_get_visible(view->view) == false) {\n        if (view->view_cb != NULL) {\n            view->view_cb((void*)view, YPS_VIEW_EVENT_SHOW, YPS_CLICK_NONE, NULL);\n        }\n        \n        yps_view_update_lang_text(view); //更新多语言文本\n        yps_view_update(view);\n        widget_set_visible(view->view, true);\n        widget_animator_t* show_anim = widget_find_animator(view->view, \"show\");\n        if (show_anim!= NULL) {\n            widget_animator_on(show_anim, EVT_ANIM_END, yps_view_show_anim_done_event, view->view);\n            widget_start_animator(view->view, \"show\");\n        }\n    }\n}\n\nvoid yps_view_hide(yps_view_t* view) {\n    if (widget_get_visible(view->view) == true) {\n        widget_animator_t* hide_anim = widget_find_animator(view->view, \"hide\");\n        if (hide_anim != NULL) {\n            widget_animator_on(hide_anim, EVT_ANIM_END, yps_view_close_anim_done_event, view->view);\n            widget_start_animator(view->view, \"hide\");\n        }\n        else {\n            widget_set_visible(view->view, false);\n            if (view->view_cb != NULL) {\n                view->view_cb((void*)view, YPS_VIEW_EVENT_HIDE, YPS_CLICK_NONE, NULL);\n            }\n            // if (view->parent) {\n            //     widget_invalidate(view->parent, NULL);\n            // }\n            widget_invalidate(view->view, NULL);\n        }\n    }\n}\n\nvoid yps_view_set_focus(yps_view_t* view) {\n    int focus_id = view->view_focus.default_focus_id;\n    if (focus_id < 0) {\n        LOGAPPD(\"view: %s, 设置不能获取焦点，不做任何处理\\n\", view->view_name);\n    }\n    else if (focus_id == 0) {\n        view->view_focus.focus_id = 0;\n        widget_set_focused(view->view, true);\n    }\n    else if (focus_id > 0) {\n        view->view_focus.focus_id = focus_id;\n        widget_t* widget = find_widget(view->view, view->view_focus.focus_map_list[focus_id - 1].item_name);\n        if (widget == NULL) {\n            LOGAPPD(\"view: %s, 未找到控件【%s】\\n\", view->view_name, view->view_focus.focus_map_list[focus_id - 1].item_name);\n            return;\n        }\n        widget_set_focused(widget, true);\n    }\n}\n\nvoid yps_view_focus_next(yps_view_t* view) {\n    int next_focus_id = 0;\n    if (view->view_focus.focus_map_num <= 1) {\n        LOGAPPD(\"view: %s，可获取子项焦点的数量小于等于1，下移焦点操作不做任何响应\", view->view_name);\n        return;\n    }\n\n    if (view->view_focus.focus_id <= 0) { //如果当前view item没有焦点， 就不做焦点上移操作\n        LOGAPPD(\"view: %s, 当前没有item获取焦点，不做焦点上移操作\", view->view_name);\n        return;\n    }\n    else { //focus_id > 0\n        view->view_focus.focus_id++;\n        if (view->view_focus.focus_id > view->view_focus.focus_map_num) {\n            view->view_focus.focus_id = 1;\n        }\n        widget_t* item_widget = find_widget(view->view, view->view_focus.focus_map_list[view->view_focus.focus_id - 1].item_name);\n        if (item_widget == NULL) {\n            LOGAPPD(\"view: %s， 未找到焦点控件，上移焦点操作不做任何响应\", view->view_name);\n            return;\n        }\n        widget_set_focused(item_widget, true);\n    }\n}\n\nvoid yps_view_focus_pre(yps_view_t* view) {\n    int pre_focus_id = 0;\n\n    if (view->view_focus.focus_map_num <= 1) {\n        LOGAPPD(\"view: %s，可获取子项焦点的数量小于等于1，上移焦点操作不做任何响应\", view->view_name);\n        return;\n    }\n\n    if (view->view_focus.focus_id <= 0) {\n        LOGAPPD(\"view: %s， 未获取焦点，上移焦点操作不做任何响应\", view->view_name);\n    }\n    else {\n        view->view_focus.focus_id--;\n        if (view->view_focus.focus_id < 1) {\n            view->view_focus.focus_id = view->view_focus.focus_map_num;\n        }\n        widget_t* item_widget = find_widget(view->view, view->view_focus.focus_map_list[view->view_focus.focus_id - 1].item_name);\n        if (item_widget == NULL) {\n            LOGAPPD(\"view: %s， 未找到焦点控件，上移焦点操作不做任何响应\", view->view_name);\n            return;\n        }\n        widget_set_focused(item_widget, true);\n    }\n}\n\nvoid yps_view_focus_map_update(yps_view_t* view, yps_view_focus_t focus, yps_view_focus_t* focus_bak) {\n    if (focus_bak != NULL) {\n        memcpy(focus_bak, &(view->view_focus), sizeof(yps_view_focus_t));\n    }\n    memcpy(&(view->view_focus), &focus, sizeof(yps_view_focus_t));\n}\n\n//view 默认事件处理\nstatic void yps_view_on_click_up_event(yps_view_t* view) {\n    //按键上事件未被截断就继续执行焦点切换操作\n    yps_view_focus_pre(view);\n}\n\nstatic void yps_view_on_click_down_event(yps_view_t* view) {\n    yps_view_focus_next(view);\n}\n\n//base_view 响应返回按键需要单独处理\nstatic void yps_view_base_click_back_event(yps_view_t* view) {\n    //如果设置了上级页面就将焦点转移到上级页面\n    //如果没有设置上级页面就返回到主表盘\n    if (strcmp(view->view_focus.pre_view_name, \"\") == 0) {\n        //没有配置上级焦点view就直接返回到主表盘\n        page_guimsg_handler(YPS_VIEW_EVENT_HOME_PAGE, 0, 0);\n    }\n    else {\n        yps_view_manager_set_focus_by_name(view->view_focus.pre_view_name);\n    }\n}\n\nstatic void yps_view_on_click_back_event(yps_view_t* view) {\n    //如果按键view焦点在item上就默认将item焦点转移到view上\n    //如果view焦点在view上就默认将焦点转移到上一级view\n    //  -- 如果上级view不存在就返回到主表盘\n    //  -- 如果上级view存在就将焦点转移到上级view上\n\n    if (view->view_type == YPS_VIEW_TYPE_BASE) {\n        yps_view_base_click_back_event(view);\n        return;\n    }\n    else if (view->view_type == YPS_VIEW_TYPE_MENU || view->view_type == YPS_VIEW_TYPE_TOP_MENU) {\n        if (view->view_focus.default_focus_id != 0) {\n            view->view_focus.default_focus_id = 1;  //重置默认焦点位置\n        }\n\n        if (strcmp(view->view_focus.pre_view_name, \"\") == 0) {\n            //没有配置上级焦点view就直接返回到主表盘\n            page_guimsg_handler(YPS_VIEW_EVENT_HOME_PAGE, 0, 0);\n            return;\n        }\n        else {\n            if (yps_view_manager_set_focus_by_name(view->view_focus.pre_view_name)) {\n                if (view->view_type != YPS_VIEW_TYPE_TOP_MENU) {//顶级菜单才需要隐藏\n                    yps_view_hide(view);\n                }\n                return;\n            }\n        }\n    }\n    return;\n}\n\nstatic bool yps_view_on_click_ok_event(yps_view_t* view) {\n    // LOGAPPD(\"view: %s, 焦点ID： %d\", view->view_name, view->view_focus.focus_id);\n    if (view->view_focus.focus_id < 0) {\n        LOGAPPD(\"view: %s, 窗口未获取焦点，不响应按键消息\", view->view_name);\n        return false;\n    }\n    else if (view->view_focus.focus_id == 0) {//焦点在当前view上, 处理点击事件之后焦点设置到view的第一个item上\n        if (view->view_focus.focus_map_num > 0) {\n            view->view_focus.focus_id = 1;\n            yps_view_item_focus_map_t focus_map = view->view_focus.focus_map_list[0];\n            widget_t* item_widget = widget_lookup(view->view, focus_map.item_name, true);\n            if (item_widget == NULL) {\n                LOGAPPD(\"view: %s, 焦点配置参数有误，请检查代码\", view->view_name);\n                return false;\n            }\n            widget_set_focused(item_widget, true);\n            // yps_view_on_focus_event(view); //生成获取焦点消息\n            return false;\n        }\n        else {\n            LOGAPPD(\"view: %s, 没有子项可获取焦点，不做处理\", view->view_name);\n            return false;\n        }\n    }\n    else {//焦点在当前view的item上\n\n        int focus_id = view->view_focus.focus_id - 1;\n        if (focus_id >= view->view_focus.focus_map_num) {\n            LOGAPPD(\"view: %s, 焦点配置参数有误，请检查代码\", view->view_name);\n            return false;\n        }\n\n        yps_view_item_focus_map_t focus_map = view->view_focus.focus_map_list[focus_id];\n        if (strncmp(focus_map.next_view_name, \"\", 64) == 0) {\n            LOGAPPD(\"view: %s, 是末级页面，焦点不继续向下传递\", view->view_name);\n            return false;\n        }\n        else {//焦点在ITEM传递（跳转）到下级页面\n            // yps_view_manager_show_view_by_name(focus_map.next_view_name);\n            view->view_focus.default_focus_id = view->view_focus.focus_id;\n            yps_view_manager_set_focus_by_name(focus_map.next_view_name);\n            // LOGAPPD(\"view: %s, 显示下级页面失败 %s\", view->view_name, focus_map.next_view_name);\n            return false;\n        }\n    }\n    return true;\n}\n\nyps_view_t* yps_view_create(widget_t* parent, char* xml, char* view_name, yps_view_type_t view_type, yps_lang_list_t* lang_list, yps_view_data_model_t* data_model, int data_model_num, yps_view_focus_t focus, on_event_view_cb_t view_cb) {\n    widget_t* view = ui_loader_load_widget_with_parent(xml, parent);\n    if (view == NULL) {\n        LOGAPPD(\"加载xml: %s失败, 无法创建view 【%s】\\n\", xml, view_name);\n        return NULL;\n    }\n\n    if (focus.focus_id > focus.focus_map_num || focus.default_focus_id > focus.focus_map_num) {\n        LOGAPPD(\"focus_id 或 default_focus_id 超出最大可设置的范围 %d\\n\", focus.focus_map_num);\n        return NULL;\n    }\n\n    widget_set_visible(view, FALSE);\nyps_view_t* view_obj = ",
    "raw_res": "(yps_view_t*)malloc(sizeof(yps_view_t));",
    "prompt_res": "malloc(sizeof(yps_view_t));",
    "gt": "malloc(sizeof(yps_view_t));"
  },
  {
    "id": 302,
    "pkg": "YPS-Instrument3",
    "fpath": "src/framework/yps_view_manager.c",
    "input": "#include <stdio.h>\n#include <string.h>\n#include <tkc/mutex.h>\n#include \"yps_view_manager.h\"\n#include \"bllLog.h\"\n#include \"yps_app_status.h\"\n#include \"yps_page_base.h\"\n\n//视图容器定义\ntypedef struct yps_view_node_t {\n    yps_view_t* view;\n    struct yps_view_node_t* next;\n} yps_view_node_t;\n\ntypedef struct yps_view_list_t {\n    yps_view_node_t* head;\n    yps_view_node_t* tail;\n    int len;\n} yps_view_list_t;\n\n\nstatic yps_view_list_t* _yps_view_list = NULL;\n\n//基础视图容器操作\n// static yps_view_list_t* _yps_base_view_list = NULL;\n//全局弹窗视图容器，存在优先级处理，\n// static yps_view_list_t* _yps_pop_view_list = NULL;\n//保存主窗口下的所有的子窗口节点，一般情况下所有的窗口节点应该只能有一个时可见的，其他的应该隐藏\n// static yps_view_list_t* _yps_normal_view_list = NULL;\n//缓存列表，切换主窗口前备份当前所有的弹窗，切换主窗口完成之后恢复所有弹窗\n\nbool check_view_list()  {\n    if (_yps_view_list == NULL) {\n        LOGAPPF(\"%s:%d 出现逻辑错误，%s 不应该为空, yps_view_manager 未初始化\", __FILE__, __LINE__, \"#view_list\");\\\n        return false;\n    }\n    return true;\n}\n\n\nyps_view_list_t* yps_view_list_create() {\n    yps_view_list_t* list = (yps_view_list_t*)malloc(sizeof(yps_view_list_t));\n    list->head = NULL;\n    list->tail = NULL;\n    list->len = 0;\n    return list;\n}\n\nvoid yps_view_list_destory(yps_view_list_t* list) {\n    if(list == NULL) return;\n    yps_view_node_t* current = list->head;\n    while (current != NULL) {\n        // LOGAPPD(\"删除view 【%s】\", current->view->view_name);\n        yps_view_node_t* next = current->next;\n        yps_view_destroy(current->view);\n\n        free(current);\n        current = next;\n    }\n    list->head = NULL;\n    list->tail = NULL;\n    list->len = 0;\n    free(list);\n    list = NULL;\n}\n\nvoid yps_view_list_append(yps_view_list_t* list, yps_view_t* view) {\n    if (list == NULL) {\n        LOGAPPE(\"%s:%d view list 为空\", __FILE__, __LINE__);\n        return;\n    }\n\n    yps_view_node_t* node = (yps_view_node_t*)malloc(sizeof(yps_view_node_t));\n    node->view = view;\n    node->next = NULL;\n\n    if (list->head == NULL) {\n        list->head = node;\n        list->len = 1;\n    }\n    else {\n        list->tail->next = node;\n        list->len++;\n    }\n    list->tail = node;\n}\n\nvoid yps_view_list_insert(yps_view_list_t* list, yps_view_t* view) {\n    // 创建一个新节点\n    yps_view_node_t* new_node = (yps_view_node_t*)malloc(sizeof(yps_view_node_t));\n    new_node->view = view;\n    new_node->next = NULL;\n\n    // 空链表，直接插入\n    if (list->len == 0) {\n        list->head = new_node;\n        list->tail = new_node;\n        list->len = 1;\n        return;\n    }\n\n    // 遍历链表，找到插入位置\n    yps_view_node_t* node = list->head;\n    yps_view_node_t* prev = NULL;\n\n    while (node && view->view_type < node->view->view_type) {\n        prev = node;\n        node = node->next;\n    }\n\n    // 插入新节点\n    if (!prev) {\n        // 插入头部\n        new_node->next = list->head;\n        list->head = new_node;\n    }\n    else if (!node) {\n        // 插入尾部\n        prev->next = new_node;\n        list->tail = new_node;\n    }\n    else {\n        // 插入中间\n        prev->next = new_node;\n        new_node->next = node;\n    }\n\n    list->len++;\n}\n\nbool yps_view_list_delete_by_name(yps_view_list_t* list, char* view_name) {\n    if (list == NULL) {\n        LOGAPPE(\"%s:%d view list 为空 \\n\", __FILE__, __LINE__);\n        return false;\n    }\n\n    yps_view_node_t* node = list->head;\n    yps_view_node_t* prev = NULL;\n\n    while (node != NULL) {\n        yps_view_t* view = node->view;\n        if (strcmp(view->view_name, view_name) == 0) {\n            list->len--;\n            break;\n        }\n        prev = node;\n        node = node->next;\n    }\n\n    if (node == NULL) {\n        LOGAPPE(\"%s:%d 未找到view：[%s], 删除失败 \\n\", __FILE__, __LINE__, view_name);\n        return false;\n    }\n\n    yps_view_destroy(node->view);\n    \n    if (prev == NULL) {\n        list->head = node->next;\n    }\n    else {\n        prev->next = node->next;\n    }\n    if (node == list->tail) {\n        list->tail = prev;\n    }\n    free(node);\n    return true;\n}\n\nyps_view_t* yps_view_list_find_by_name(yps_view_list_t* list, char* view_name) {\n    if (list == NULL) {\n        LOGAPPD(\"view list 为空\\n\");\n        return NULL;\n    }\n\n    yps_view_node_t* node = list->head;\n    while (node != NULL) {\n        yps_view_t* view = node->view;\n        if (strcmp(view->view_name, view_name) == 0) {\n            return view;\n        }\n        node = node->next;\n    }\n\n    return NULL;\n}\n\n\nvoid yps_manager_list_printf(yps_view_list_t* list) {\n    if (list == NULL) {\n        LOGAPPD(\"view list 为空\");\n        return;\n    }\n    LOGAPPD(\"===============yps_view_manager_printf=============\\n\");\n\n    yps_view_node_t* node = list->head;\n    while (node != NULL) {\n        yps_view_t* view = node->view;\n        LOGAPPD(\"view name: %s\\n\", view->view_name);\n        node = node->next;\n    }\n}\n\nvoid yps_view_manager_init() {\n    if (_yps_view_list == NULL) {\n        _yps_view_list = yps_view_list_create();\n    }\n\n    if (_yps_view_list == NULL) {\n        LOGAPPD(\"创建视图管理器失败...\\n\");\n        return;\n    }\n    LOGAPPD(\"视图管理模块初始化完成\\n\");\n}\n\nvoid yps_view_manager_deinit() {\n    yps_view_list_destory(_yps_view_list);\n    LOGAPPD(\"销毁视图管理器...\\n\");\n}\n\nvoid yps_view_manager_reset() {\n    LOGAPPD(\"重置主窗口中的view列表...\\n\");\n    //弹窗列表销毁前需要做备份，这里后续需要实现\n    yps_view_list_destory(_yps_view_list);\n    _yps_view_list = yps_view_list_create();\n}\n\n\n//获取菜单前景窗口\n// static yps_view_t* yps_view_manager_get_foreground_view() {\n//     if(!check_view_list()) return NULL;\n//     yps_view_node_t* node = _yps_view_list->head;\n//     while (node != NULL) {\n//         yps_view_t* view = node->view;\n//         if ((view->view_type == YPS_VIEW_TYPE_MENU || view->view_type == YPS_VIEW_TYPE_TOP_MENU)&& widget_get_visible(view->view)) {\n//             return view;\n//         }\n//         node = node->next;\n//     }\n//     return NULL;\n// }\n\n\n//切换前景窗口 （菜单窗口跳转）, b_focus 是否设置焦点\nstatic bool yps_view_manager_switch_foreground_view(char* view_name, bool b_focus) {\n    bool b_find = false;\n    yps_view_node_t* node = _yps_view_list->head;\n    while (node != NULL) {\n        yps_view_t* view = node->view;\n        if (view->view_type == YPS_VIEW_TYPE_MENU|| view->view_type == YPS_VIEW_TYPE_TOP_MENU) {\n            if (strncmp(view->view_name, view_name, 64) == 0) {\n                if (widget_get_visible(view->view) == false) {  //如果当前窗口不可见状态就生成任何消息\n                    yps_view_show(view);\n                    //这里没有设置焦点，也没有发送焦点消息，是因为窗口显示之后不一定要求获取焦点，这个需要具体的窗口自己处理\n                    LOGAPPD(\"切换 %s 到前景窗口显示\\n\", view_name);\n                }\n                b_find = true;\n            }\n            else {\n                //如果原来窗口时显示状态，切换到隐藏状态后需要发送窗口隐藏事件\n                if (widget_get_visible(view->view)) {\n                    yps_view_hide(view);\n                    LOGAPPD(\"切换 %s 到后台窗口隐藏\\n\", view_name);\n                }\n            }\n        }\n        node = node->next;\n    }\n    return b_find;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////\n// 弹窗事件过滤逻辑  ========> 开始\n\n//判断是否存在弹窗\nstatic bool yps_pop_view_check() {\n    yps_view_node_t* node = _yps_view_list->head;\n    while (node != NULL) {\n        yps_view_t* view = node->view;\n        if (view->view_type >= YPS_VIEW_TYPE_POPUP) {\n            //存在弹窗，拦截消息进行处理\n            return true;\n        }\n        node = node->next;\n    }\n    return false;\n}\nstatic yps_view_t* yps_get_pop_view(yps_view_type_t pop_type) {\n    if (pop_type < YPS_VIEW_TYPE_POPUP) {\n        LOGAPPD(\"获取弹窗失败，输入的弹窗类型错误 【%d】\\n\", pop_type);\n        return NULL;\n    }\n    yps_view_node_t* node = _yps_view_list->head;\n    while (node != NULL) {\n        yps_view_t* view = node->view;\n        if (view->view_type == pop_type) {\n            return view;\n        }\n        node = node->next;\n    }\n    return NULL;\n}\n\n\n//主页按键事件处理逻辑\nstatic bool yps_pop_view_on_click_home_page(yps_click_type_t click_type) {    \n    //判断是否有音量弹窗，如果有就直接响应\n    yps_view_t* pop_view = NULL;\n    pop_view = yps_get_pop_view(YPS_VIEW_TYPE_POPUP_VOLUME);\n    if (pop_view != NULL && widget_get_visible(pop_view->view)) {\n        bool ret = yps_view_fire_click_event(pop_view, click_type);\n        LOGAPPD(\"音量弹窗响应按键事件结果  ===> %d \", ret);\n        return ret;\n    }\n\n    //没有音量弹窗就判断是否存在电话弹窗，有电话弹窗就需要创建音量弹窗响应通话音量\n    pop_view = yps_get_pop_view(YPS_VIEW_TYPE_POPUP_PHONE);\n    if (pop_view != NULL && widget_get_visible(pop_view->view)) {\n        \n        bool ret = yps_view_fire_click_event(pop_view, click_type);\n        LOGAPPD(\"电话弹窗响应按键事件结果  ===> %d \", ret);\n        return ret;\n    }\n\n    //没有电话弹窗或者没有处理，就判断是否有音乐弹窗，有音乐弹窗就响应音乐音量/播放、暂停、上一曲、下一曲\n    pop_view = yps_get_pop_view(YPS_VIEW_TYPE_POPUP_MUSIC);\n    if (pop_view != NULL && widget_get_visible(pop_view->view)) {\n        bool ret = yps_view_fire_click_event(pop_view, click_type);\n        LOGAPPD(\"音乐弹窗响应按键事件结果  ===> %d \", ret);\n        return ret;\n    }\n    //没有任何弹窗或者没有处理，就将按键事件传递到主窗口处理\n    return true;\n}\n\n//菜单页弹窗按键事件处理逻辑\nstatic bool yps_pop_view_on_click_menu_page(yps_click_type_t click_type) {\n    yps_view_t* pop_view = NULL;\n    //判断是否有YES NO弹窗，如果有就直接响应\n    pop_view = yps_get_pop_view(YPS_VIEW_TYPE_POPUP_YES_NO);\n    if (pop_view != NULL && widget_get_visible(pop_view->view)) {\n        bool ret = yps_view_fire_click_event(pop_view, click_type);\n        LOGAPPD(\"确认弹窗响应按键事件结果  ===> %d \", ret);\n        return ret;\n    }\n    //判断是否有音量弹窗，如果有就直接响应\n    pop_view = yps_get_pop_view(YPS_VIEW_TYPE_POPUP_VOLUME);\n    if (pop_view != NULL && widget_get_visible(pop_view->view)) {\n        bool ret = yps_view_fire_click_event(pop_view, click_type);\n        LOGAPPD(\"音量弹窗响应按键事件结果  ===> %d \", ret);\n        return ret;\n    }\n\n    //没有音量弹窗就判断是否存在电话弹窗，有电话弹窗就需要创建音量弹窗响应通话音量\n    pop_view = yps_get_pop_view(YPS_VIEW_TYPE_POPUP_PHONE);\n    if (pop_view != NULL && widget_get_visible(pop_view->view)) {\n        \n        bool ret = yps_view_fire_click_event(pop_view, click_type);\n        LOGAPPD(\"电话弹窗响应按键事件结果  ===> %d \", ret);\n        return ret;\n    }\n    return true;\n}\n\n//互联页弹窗按键事件处理逻辑\nstatic bool yps_pop_view_on_click_connect_page(yps_click_type_t click_type) {\n        //判断是否有音量弹窗，如果有就直接响应\n    yps_view_t* pop_view = NULL;\n    pop_view = yps_get_pop_view(YPS_VIEW_TYPE_POPUP_VOLUME);\n    if (pop_view != NULL && widget_get_visible(pop_view->view)) {\n        bool ret = yps_view_fire_click_event(pop_view, click_type);\n        LOGAPPD(\"音量弹窗响应按键事件结果  ===> %d \", ret);\n        return ret;\n    }\n\n    //没有音量弹窗就判断是否存在电话弹窗，有电话弹窗就需要创建音量弹窗响应通话音量\n    pop_view = yps_get_pop_view(YPS_VIEW_TYPE_POPUP_PHONE);\n    if (pop_view != NULL && widget_get_visible(pop_view->view)) {\n        \n        bool ret = yps_view_fire_click_event(pop_view, click_type);\n        LOGAPPD(\"电话弹窗响应按键事件结果  ===> %d \", ret);\n        return ret;\n    }\n\n        //没有电话弹窗或者没有处理，就判断是否有音乐弹窗，有音乐弹窗就响应音乐音量/播放、暂停、上一曲、下一曲\n    pop_view = yps_get_pop_view(YPS_VIEW_TYPE_POPUP_MUSIC);\n    if (pop_view != NULL && widget_get_visible(pop_view->view)) {\n        bool ret = yps_view_fire_click_event(pop_view, click_type);\n        LOGAPPD(\"音乐弹窗响应按键事件结果  ===> %d \", ret);\n        return ret;\n    }\n    return true;\n}\n\n//弹窗按键事件处理逻辑\nstatic bool yps_pop_view_on_click(yps_click_type_t click_type) {\n    //判断是否存在弹窗，如果没有直接向下传递\n    if (!yps_pop_view_check()) {\n        return true;\n    }\n\n    //判断当前页面类型\n    int page_type = yps_status_get_main_page_type();\n    if (page_type == YPS_PAGE_HOME) {\n        return yps_pop_view_on_click_home_page(click_type);\n    }\n    else if(page_type == YPS_PAGE_MENU) {\n        return yps_pop_view_on_click_menu_page(click_type);\n    }\n    else if (page_type == YPS_PAGE_MIRROR ||\n        page_type == YPS_PAGE_SUPER_MIRROR) {\n        return yps_pop_view_on_click_connect_page(click_type);\n    }\n    return true;\n}\n\n// 弹窗事件过滤逻辑  ========>  结束\n//////////////////////////////////////////////////////////////////////////////////////\n\n//HUD 事件分发逻辑\n//没有HUD弹窗就将 hud消息分发到主窗口创建HUD弹窗\n//如果HUD弹窗就将HUD消息分发到HUD弹窗中处理\nstatic bool yps_hud_event_dispatch(void* data) {\n    yps_view_t* view = yps_view_manager_find_by_view_type(YPS_VIEW_TYPE_POPUP_HUD);\n    if(view == NULL) {\n        return true;\n    }\n    yps_view_fire_event(view, YPS_VIEW_EVENT_HUD_STATUS_CHANGED, YPS_CLICK_NONE, data);\n    return false;\n}\n\n\nvoid yps_view_manager_insert(yps_view_t* view) {\n    if (_yps_view_list == NULL) {\n        LOGAPPF(\"yps_view_manager 未初始化\\n\");\n        return;\n    }\n    // LOGAPPD(\"创建view -> %s\\n\", view->view_name);\n    if (view->view_type >= YPS_VIEW_TYPE_POPUP) {//弹窗类型view\n        yps_view_list_insert(_yps_view_list, view);\n    }\n    else if (view->view_type == YPS_VIEW_TYPE_MENU|| view->view_type == YPS_VIEW_TYPE_TOP_MENU) {//菜单类型view\n        yps_view_list_append(_yps_view_list, view);\n        if (view->view_focus.focus_id > -1) {\n            //创建的窗口默认带了焦点,需要显示,并且隐藏之前的菜单view\n            yps_view_manager_switch_foreground_view(view->view_name, true);\n        }\n        else {//默认创建的菜单view没有焦点\n            widget_set_visible(view->view, false);\n        }\n    }\n    else {//基础类型的view\n        yps_view_list_append(_yps_view_list, view);\n        if (view->view_focus.focus_id > -1) {\n            yps_view_show(view);\n        }\n    }\n\n    // yps_manager_list_printf(_yps_view_list);\n}\n\nvoid yps_view_manager_remove_by_view_name(char* view_name) {\n    if (_yps_view_list == NULL) {\n        LOGAPPF(\"yps_view_manager 未初始化\\n\");\n        return;\n    }\n    yps_view_list_delete_by_name(_yps_view_list, view_name);\n}\n\nyps_view_t* yps_view_manager_get_view_by_name(char* view_name) {\n    yps_view_t* view = NULL;\n    view = yps_view_list_find_by_name(_yps_view_list, view_name);\n    return view;\n}\n\n//通过view类型查找view\nyps_view_t* yps_view_manager_find_by_view_type(yps_view_type_t view_type) {\n    if (_yps_view_list == NULL) {\n        LOGAPPD(\"view list 为空\\n\");\n        return NULL;\n    }\n\n    yps_view_node_t* node = _yps_view_list->head;\n    while (node != NULL) {\n        yps_view_t* view = node->view;\n        if(view->view_type == view_type){\n            return view;\n        }\n        node = node->next;\n    }\n    return NULL;\n}\n\nvoid yps_view_manager_show_view_by_name(char* view_name) {\n    if(!check_view_list()) return;\n    yps_view_t* view = yps_view_list_find_by_name(_yps_view_list, view_name);\n    if(view == NULL) {\n        LOGAPPD(\"显示窗口 %s 失败，窗口不存在\\n\", view_name);\n        return;\n    }\n    if (view->view_type == YPS_VIEW_TYPE_MENU || view->view_type == YPS_VIEW_TYPE_TOP_MENU) {\n        yps_view_manager_switch_foreground_view(view_name, true);\n    }\n    else {\n        yps_view_show(view);\n    }\n}\n\nvoid yps_view_manager_hide_view_by_name(char* view_name) {\n    if(!check_view_list()) return;\n    yps_view_t* view = yps_view_list_find_by_name(_yps_view_list, view_name);\n    if (view != NULL) {\n        yps_view_hide(view);\n    }\n    else {\n        LOGAPPD(\"隐藏窗口 %s 失败，窗口不存在\\n\", view_name);\n    }\n}\n\n\nbool yps_view_manager_set_focus_by_name(char* view_name) {\n    yps_view_node_t* node = _yps_view_list->head;\n    while (node != NULL) {\n        yps_view_t* view = node->view;\n        if (strncmp(view->view_name, view_name, 64) == 0) {\n            if (view->view_type == YPS_VIEW_TYPE_MENU || view->view_type == YPS_VIEW_TYPE_TOP_MENU) {\n                yps_view_manager_switch_foreground_view(view_name, true);\n            }\n            yps_view_set_focus(view);\n            return true;\n        }\n        node = node->next;\n    }\n    LOGAPPD(\"设置 %s 窗口获取焦点失败，窗口不存在\\n\", view_name);\n    return false;\n}\n\nbool yps_view_manager_fire_click_event(yps_click_type_t event) {\n    if(!check_view_list()) return false;\n    if (_yps_view_list->len > 0 && _yps_view_list->head != NULL) {\n        yps_view_node_t* node = _yps_view_list->head;\n        while (node != NULL) {\n            yps_view_t* view = node->view;\n            if (widget_get_visible(view->view) == true && view->view->focused) {\n                // LOGAPPD(\"窗口 %s 接收到点击事件 => %d\\n\", view->view_name, event);\n// yps_ret_t ret = ",
    "raw_res": "yps_view_fire_click_event(view, event);",
    "prompt_res": "yps_view_fire_event(view, YPS_VIEW_EVENT_CLICK, event, NULL);",
    "gt": "yps_view_fire_event(view, YPS_VIEW_EVENT_CLICK, event, NULL);"
  },
  {
    "id": 609,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/fscript_ext/fscript_bits.c",
    "input": "﻿/**\n * File:   fscript_bits.c\n * Author: AWTK Develop Team\n * Brief:  bits functions for fscript\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2021-01-03 Li XianJing <lixianjing@zlg.cn> created\n *\n */\n\n#include \"tkc/fscript.h\"\n\ntypedef enum _func_type_t {\n  FUNC_LSHIFT = 1,\n  FUNC_RSHIFT = 2,\n  FUNC_BIT_CLEAR = 3,\n} func_type_t;\n\nstatic ret_t func_lshift(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t n = 0;\n  value_t* value = NULL;\n  ret_t ret = RET_OK;\n\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value = args->args;\n  n = value_uint32(args->args + 1);\n\n  switch (value->type) {\n    case VALUE_TYPE_INT8: {\n      value_set_int8(result, value_int8(value) << n);\n      break;\n    }\n    case VALUE_TYPE_UINT8: {\n      value_set_uint8(result, value_uint8(value) << n);\n      break;\n    }\n    case VALUE_TYPE_INT16: {\n      value_set_int16(result, value_int16(value) << n);\n      break;\n    }\n    case VALUE_TYPE_UINT16: {\n      value_set_uint16(result, value_uint16(value) << n);\n      break;\n    }\n    case VALUE_TYPE_INT32: {\n      value_set_int32(result, value_int32(value) << n);\n      break;\n    }\n    case VALUE_TYPE_UINT32: {\n      value_set_uint32(result, value_uint32(value) << n);\n      break;\n    }\n    case VALUE_TYPE_INT64: {\n      value_set_int64(result, value_int64(value) << n);\n      break;\n    }\n    case VALUE_TYPE_UINT64: {\n      value_set_uint64(result, value_uint64(value) << n);\n      break;\n    }\n    default: {\n      ret = RET_BAD_PARAMS;\n      break;\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t func_rshift(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t n = 0;\n  value_t* value = NULL;\n  ret_t ret = RET_OK;\n\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value = args->args;\n  n = value_uint32(args->args + 1);\n\n  switch (value->type) {\n    case VALUE_TYPE_INT8: {\n      value_set_int8(result, value_int8(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_UINT8: {\n      value_set_uint8(result, value_uint8(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_INT16: {\n      value_set_int16(result, value_int16(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_UINT16: {\n      value_set_uint16(result, value_uint16(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_INT32: {\n      value_set_int32(result, value_int32(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_UINT32: {\n      value_set_uint32(result, value_uint32(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_INT64: {\n      value_set_int64(result, value_int64(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_UINT64: {\n      value_set_uint64(result, value_uint64(value) >> n);\n      break;\n    }\n    default: {\n      ret = RET_BAD_PARAMS;\n      break;\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t func_bit_set(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t n = 0;\n  value_t* value = NULL;\n  ret_t ret = RET_OK;\n\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value = args->args;\n  n = value_uint32(args->args + 1);\n\n  switch (value->type) {\n    case VALUE_TYPE_INT8: {\n      int8_t vv = value_int8(value);\n      TK_SET_BIT(vv, n);\n      value_set_int8(result, vv);\n      break;\n    }\n    case VALUE_TYPE_UINT8: {\n      uint8_t vv = value_uint8(value);\n      TK_SET_BIT(vv, n);\n      value_set_uint8(result, vv);\n      break;\n    }\n    case VALUE_TYPE_INT16: {\n      int16_t vv = value_int16(value);\n      TK_SET_BIT(vv, n);\n      value_set_int16(result, vv);\n      break;\n    }\n    case VALUE_TYPE_UINT16: {\nuint16_t vv = ",
    "raw_res": "0;",
    "prompt_res": "value_uint16(value);",
    "gt": "value_uint16(value);"
  },
  {
    "id": 653,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/fscript_ext/fscript_array.c",
    "input": "﻿/**\n * File:   fscript_array.c\n * Author: AWTK Develop Team\n * Brief:  array functions for fscript\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2021-01-03 Li XianJing <lixianjing@zlg.cn> created\n *\n */\n\n#include \"tkc/fscript.h\"\n#include \"tkc/object_array.h\"\nstatic ret_t func_array_create(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  tk_object_t* obj = object_array_create();\n  value_set_object(result, obj);\n  result->free_handle = TRUE;\n\n  for (i = 0; i < args->size; i++) {\n    ret_t ret = object_array_push(obj, args->args + i);\n    if (ret != RET_OK) {\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic value_type_t value_type_from_str(const char* type) {\n  if (type != NULL) {\n    if (*type == 'i') {\n      return VALUE_TYPE_INT32;\n    } else if (*type == 'd') {\n      return VALUE_TYPE_DOUBLE;\n    }\n  }\n\n  return VALUE_TYPE_STRING;\n}\n\nstatic ret_t func_array_create_with_str(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  tk_object_t* obj = NULL;\n  const char* str = NULL;\n  const char* sep = NULL;\n  const char* type = NULL;\n  FSCRIPT_FUNC_CHECK(args->size >= 2, RET_BAD_PARAMS);\n\n  str = value_str(args->args);\nsep = ",
    "raw_res": "0;",
    "prompt_res": "value_str(args->args + 1);",
    "gt": "value_str(args->args + 1);"
  },
  {
    "id": 659,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/fscript_ext/fscript_array.c",
    "input": "﻿/**\n * File:   fscript_array.c\n * Author: AWTK Develop Team\n * Brief:  array functions for fscript\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2021-01-03 Li XianJing <lixianjing@zlg.cn> created\n *\n */\n\n#include \"tkc/fscript.h\"\n#include \"tkc/object_array.h\"\nstatic ret_t func_array_create(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  tk_object_t* obj = object_array_create();\n  value_set_object(result, obj);\n  result->free_handle = TRUE;\n\n  for (i = 0; i < args->size; i++) {\n    ret_t ret = object_array_push(obj, args->args + i);\n    if (ret != RET_OK) {\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic value_type_t value_type_from_str(const char* type) {\n  if (type != NULL) {\n    if (*type == 'i') {\n      return VALUE_TYPE_INT32;\n    } else if (*type == 'd') {\n      return VALUE_TYPE_DOUBLE;\n    }\n  }\n\n  return VALUE_TYPE_STRING;\n}\n\nstatic ret_t func_array_create_with_str(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  tk_object_t* obj = NULL;\n  const char* str = NULL;\n  const char* sep = NULL;\n  const char* type = NULL;\n  FSCRIPT_FUNC_CHECK(args->size >= 2, RET_BAD_PARAMS);\n\n  str = value_str(args->args);\n  sep = value_str(args->args + 1);\n  type = args->size > 2 ? value_str(args->args + 2) : NULL;\n\n  obj = object_array_create_with_str(str, sep, value_type_from_str(type));\n  value_set_object(result, obj);\n  return_value_if_fail(obj != NULL, RET_BAD_PARAMS);\n  result->free_handle = TRUE;\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_dup(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t start = 0;\n  uint32_t end = 0;\n  tk_object_t* obj = NULL;\n  tk_object_t* dup = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  if (arr->size == 0) {\n    dup = object_array_clone(obj);\n  } else {\n    if (args->size == 1) {\n      start = 0;\n      end = arr->size;\n    } else if (args->size == 2) {\n      start = value_uint32(args->args + 1);\n      end = arr->size;\n    } else {\n      start = value_uint32(args->args + 1);\n      end = value_uint32(args->args + 2);\n    }\ndup = ",
    "raw_res": "object_array_clone_range(obj, start, end);",
    "prompt_res": "object_array_dup(obj, start, end);",
    "gt": "object_array_dup(obj, start, end);"
  },
  {
    "id": 664,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/fscript_ext/fscript_array.c",
    "input": "﻿/**\n * File:   fscript_array.c\n * Author: AWTK Develop Team\n * Brief:  array functions for fscript\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2021-01-03 Li XianJing <lixianjing@zlg.cn> created\n *\n */\n\n#include \"tkc/fscript.h\"\n#include \"tkc/object_array.h\"\nstatic ret_t func_array_create(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  tk_object_t* obj = object_array_create();\n  value_set_object(result, obj);\n  result->free_handle = TRUE;\n\n  for (i = 0; i < args->size; i++) {\n    ret_t ret = object_array_push(obj, args->args + i);\n    if (ret != RET_OK) {\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic value_type_t value_type_from_str(const char* type) {\n  if (type != NULL) {\n    if (*type == 'i') {\n      return VALUE_TYPE_INT32;\n    } else if (*type == 'd') {\n      return VALUE_TYPE_DOUBLE;\n    }\n  }\n\n  return VALUE_TYPE_STRING;\n}\n\nstatic ret_t func_array_create_with_str(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  tk_object_t* obj = NULL;\n  const char* str = NULL;\n  const char* sep = NULL;\n  const char* type = NULL;\n  FSCRIPT_FUNC_CHECK(args->size >= 2, RET_BAD_PARAMS);\n\n  str = value_str(args->args);\n  sep = value_str(args->args + 1);\n  type = args->size > 2 ? value_str(args->args + 2) : NULL;\n\n  obj = object_array_create_with_str(str, sep, value_type_from_str(type));\n  value_set_object(result, obj);\n  return_value_if_fail(obj != NULL, RET_BAD_PARAMS);\n  result->free_handle = TRUE;\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_dup(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t start = 0;\n  uint32_t end = 0;\n  tk_object_t* obj = NULL;\n  tk_object_t* dup = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  if (arr->size == 0) {\n    dup = object_array_clone(obj);\n  } else {\n    if (args->size == 1) {\n      start = 0;\n      end = arr->size;\n    } else if (args->size == 2) {\n      start = value_uint32(args->args + 1);\n      end = arr->size;\n    } else {\n      start = value_uint32(args->args + 1);\n      end = value_uint32(args->args + 2);\n    }\n    dup = object_array_dup(obj, start, end);\n  }\n  value_set_object(result, dup);\n  return_value_if_fail(dup != NULL, RET_BAD_PARAMS);\n  result->free_handle = TRUE;\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_create_repeated(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  uint32_t n = 0;\n  tk_object_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n\n  obj = object_array_create();\n  value_set_object(result, obj);\n  return_value_if_fail(obj != NULL, RET_BAD_PARAMS);\n\n  result->free_handle = TRUE;\n  n = value_uint32(args->args + 1);\n  for (i = 0; i < n; i++) {\n    ret_t ret = object_array_push(obj, args->args);\n    if (ret != RET_OK) {\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_push(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size > 1, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  for (i = 1; i < args->size; i++) {\n    ret_t ret = object_array_push(obj, args->args + i);\n    if (ret != RET_OK) {\n      break;\n    }\n  }\n\n  value_set_uint32(result, i - 1);\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_pop(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n  if (arr->size > 0) {\n    return object_array_pop(obj, result);\n  } else {\n    result->type = VALUE_TYPE_INVALID;\n    return RET_OK;\n  }\n}\n\nstatic ret_t func_array_shift(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  if (arr->size > 0) {\n    return object_array_shift(obj, result);\n  } else {\n    result->type = VALUE_TYPE_INVALID;\n    return RET_OK;\n  }\n}\n\nstatic ret_t func_array_set(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  int32_t index = 0;\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 3, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  index = value_int(args->args + 1);\n  if (index < 0) {\n    index += arr->size;\n  }\n  return_value_if_fail(index >= 0 && index < arr->size, RET_BAD_PARAMS);\n\n  value_set_bool(result, object_array_set(obj, index, args->args + 2) == RET_OK);\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_get(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  int32_t index = 0;\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  index = value_int(args->args + 1);\n  if (index < 0) {\n    index += arr->size;\n  }\n  return_value_if_fail(index >= 0 && index < arr->size, RET_BAD_PARAMS);\n\n  return object_array_get(obj, index, result);\n}\n\nstatic ret_t func_array_insert(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  int32_t index = 0;\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 3, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  index = value_int(args->args + 1);\n  if (index < 0) {\n    index += arr->size;\n  }\n  return_value_if_fail(index >= 0, RET_BAD_PARAMS);\n\n  value_set_bool(result, object_array_insert(obj, index, args->args + 2) == RET_OK);\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_remove(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  int32_t index = 0;\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  index = value_int(args->args + 1);\n  if (index < 0) {\n    index += arr->size;\n  }\n  return_value_if_fail(index >= 0 && index < arr->size, RET_BAD_PARAMS);\n\n  value_set_bool(result, object_array_remove(obj, index) == RET_OK);\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_get_and_remove(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  int32_t index = 0;\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  index = value_int(args->args + 1);\n  if (index < 0) {\n    index += arr->size;\n  }\n  return_value_if_fail(index >= 0 && index < arr->size, RET_BAD_PARAMS);\n\n  return object_array_get_and_remove(obj, index, result);\n}\n\nstatic ret_t func_array_index_of(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  value_set_int(result, object_array_index_of(obj, args->args + 1));\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_last_index_of(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  value_set_int(result, object_array_last_index_of(obj, args->args + 1));\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_clear(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  value_set_bool(result, object_array_clear_props(obj) == RET_OK);\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_reverse(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  value_set_bool(result, object_array_reverse(obj) == RET_OK);\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_sort_ex(fscript_t* fscript, fscript_args_t* args, value_t* result,\n                                bool_t clone) {\n  ret_t ret = RET_OK;\n  tk_object_t* obj = NULL;\n  bool_t ascending = TRUE;\n  bool_t ignore_case = FALSE;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  if (clone) {\n    obj = object_array_clone(obj);\n  }\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  if (args->size > 1) {\n    ascending = value_bool(args->args + 1);\n  }\n  if (args->size > 2) {\n    ignore_case = value_bool(args->args + 2);\n  }\n\n  if (arr->size > 1) {\n    value_t v;\n    object_array_get(obj, 0, &v);\n\n    if (v.type == VALUE_TYPE_STRING) {\nret = ",
    "raw_res": "0;",
    "prompt_res": "object_array_sort_as_str(obj, ascending, ignore_case);",
    "gt": "object_array_sort_as_str(obj, ascending, ignore_case);"
  },
  {
    "id": 665,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/fscript_ext/fscript_array.c",
    "input": "﻿/**\n * File:   fscript_array.c\n * Author: AWTK Develop Team\n * Brief:  array functions for fscript\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2021-01-03 Li XianJing <lixianjing@zlg.cn> created\n *\n */\n\n#include \"tkc/fscript.h\"\n#include \"tkc/object_array.h\"\nstatic ret_t func_array_create(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  tk_object_t* obj = object_array_create();\n  value_set_object(result, obj);\n  result->free_handle = TRUE;\n\n  for (i = 0; i < args->size; i++) {\n    ret_t ret = object_array_push(obj, args->args + i);\n    if (ret != RET_OK) {\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic value_type_t value_type_from_str(const char* type) {\n  if (type != NULL) {\n    if (*type == 'i') {\n      return VALUE_TYPE_INT32;\n    } else if (*type == 'd') {\n      return VALUE_TYPE_DOUBLE;\n    }\n  }\n\n  return VALUE_TYPE_STRING;\n}\n\nstatic ret_t func_array_create_with_str(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  tk_object_t* obj = NULL;\n  const char* str = NULL;\n  const char* sep = NULL;\n  const char* type = NULL;\n  FSCRIPT_FUNC_CHECK(args->size >= 2, RET_BAD_PARAMS);\n\n  str = value_str(args->args);\n  sep = value_str(args->args + 1);\n  type = args->size > 2 ? value_str(args->args + 2) : NULL;\n\n  obj = object_array_create_with_str(str, sep, value_type_from_str(type));\n  value_set_object(result, obj);\n  return_value_if_fail(obj != NULL, RET_BAD_PARAMS);\n  result->free_handle = TRUE;\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_dup(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t start = 0;\n  uint32_t end = 0;\n  tk_object_t* obj = NULL;\n  tk_object_t* dup = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  if (arr->size == 0) {\n    dup = object_array_clone(obj);\n  } else {\n    if (args->size == 1) {\n      start = 0;\n      end = arr->size;\n    } else if (args->size == 2) {\n      start = value_uint32(args->args + 1);\n      end = arr->size;\n    } else {\n      start = value_uint32(args->args + 1);\n      end = value_uint32(args->args + 2);\n    }\n    dup = object_array_dup(obj, start, end);\n  }\n  value_set_object(result, dup);\n  return_value_if_fail(dup != NULL, RET_BAD_PARAMS);\n  result->free_handle = TRUE;\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_create_repeated(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  uint32_t n = 0;\n  tk_object_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n\n  obj = object_array_create();\n  value_set_object(result, obj);\n  return_value_if_fail(obj != NULL, RET_BAD_PARAMS);\n\n  result->free_handle = TRUE;\n  n = value_uint32(args->args + 1);\n  for (i = 0; i < n; i++) {\n    ret_t ret = object_array_push(obj, args->args);\n    if (ret != RET_OK) {\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_push(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size > 1, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  for (i = 1; i < args->size; i++) {\n    ret_t ret = object_array_push(obj, args->args + i);\n    if (ret != RET_OK) {\n      break;\n    }\n  }\n\n  value_set_uint32(result, i - 1);\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_pop(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n  if (arr->size > 0) {\n    return object_array_pop(obj, result);\n  } else {\n    result->type = VALUE_TYPE_INVALID;\n    return RET_OK;\n  }\n}\n\nstatic ret_t func_array_shift(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  if (arr->size > 0) {\n    return object_array_shift(obj, result);\n  } else {\n    result->type = VALUE_TYPE_INVALID;\n    return RET_OK;\n  }\n}\n\nstatic ret_t func_array_set(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  int32_t index = 0;\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 3, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  index = value_int(args->args + 1);\n  if (index < 0) {\n    index += arr->size;\n  }\n  return_value_if_fail(index >= 0 && index < arr->size, RET_BAD_PARAMS);\n\n  value_set_bool(result, object_array_set(obj, index, args->args + 2) == RET_OK);\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_get(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  int32_t index = 0;\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  index = value_int(args->args + 1);\n  if (index < 0) {\n    index += arr->size;\n  }\n  return_value_if_fail(index >= 0 && index < arr->size, RET_BAD_PARAMS);\n\n  return object_array_get(obj, index, result);\n}\n\nstatic ret_t func_array_insert(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  int32_t index = 0;\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 3, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  index = value_int(args->args + 1);\n  if (index < 0) {\n    index += arr->size;\n  }\n  return_value_if_fail(index >= 0, RET_BAD_PARAMS);\n\n  value_set_bool(result, object_array_insert(obj, index, args->args + 2) == RET_OK);\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_remove(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  int32_t index = 0;\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  index = value_int(args->args + 1);\n  if (index < 0) {\n    index += arr->size;\n  }\n  return_value_if_fail(index >= 0 && index < arr->size, RET_BAD_PARAMS);\n\n  value_set_bool(result, object_array_remove(obj, index) == RET_OK);\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_get_and_remove(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  int32_t index = 0;\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  index = value_int(args->args + 1);\n  if (index < 0) {\n    index += arr->size;\n  }\n  return_value_if_fail(index >= 0 && index < arr->size, RET_BAD_PARAMS);\n\n  return object_array_get_and_remove(obj, index, result);\n}\n\nstatic ret_t func_array_index_of(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  value_set_int(result, object_array_index_of(obj, args->args + 1));\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_last_index_of(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  value_set_int(result, object_array_last_index_of(obj, args->args + 1));\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_clear(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  value_set_bool(result, object_array_clear_props(obj) == RET_OK);\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_reverse(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  tk_object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  value_set_bool(result, object_array_reverse(obj) == RET_OK);\n\n  return RET_OK;\n}\n\nstatic ret_t func_array_sort_ex(fscript_t* fscript, fscript_args_t* args, value_t* result,\n                                bool_t clone) {\n  ret_t ret = RET_OK;\n  tk_object_t* obj = NULL;\n  bool_t ascending = TRUE;\n  bool_t ignore_case = FALSE;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  if (clone) {\n    obj = object_array_clone(obj);\n  }\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  if (args->size > 1) {\n    ascending = value_bool(args->args + 1);\n  }\n  if (args->size > 2) {\n    ignore_case = value_bool(args->args + 2);\n  }\n\n  if (arr->size > 1) {\n    value_t v;\n    object_array_get(obj, 0, &v);\n\n    if (v.type == VALUE_TYPE_STRING) {\n      ret = object_array_sort_as_str(obj, ascending, ignore_case);\n    } else if (v.type == VALUE_TYPE_INT32) {\nret = ",
    "raw_res": "object_array_sort_as_int32(obj, ascending);",
    "prompt_res": "object_array_sort_as_int(obj, ascending);",
    "gt": "object_array_sort_as_int(obj, ascending);"
  },
  {
    "id": 671,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/fscript_ext/fscript_iostream_serial.c",
    "input": "﻿/**\n * File:   fscript_iostream_serial.c\n * Author: AWTK Develop Team\n * Brief:  iostream_serial functions for fscript\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2021-01-06 Li XianJing <lixianjing@zlg.cn> created\n *\n */\n\n#include \"tkc/buffer.h\"\n#include \"tkc/fscript.h\"\n#include \"tkc/socket_helper.h\"\n#include \"streams/serial/iostream_serial.h\"\n\nstatic ret_t func_iostream_serial_create(fscript_t* fscript, fscript_args_t* args,\n                                         value_t* result) {\n  int baudrate = 115200;\n  tk_object_t* obj = NULL;\n  const char* devname = NULL;\n  bytesize_t bytesize = eightbits;\n  parity_t parity = parity_none;\n  stopbits_t stopbits = stopbits_one;\n  flowcontrol_t flowcontrol = flowcontrol_none;\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n\n  devname = value_str(args->args);\n  if (args->size > 1) {\n    baudrate = value_int(args->args + 1);\n  }\n  if (args->size > 2) {\nbytesize = ",
    "raw_res": "0;",
    "prompt_res": "value_int(args->args + 2);",
    "gt": "value_int(args->args + 2);"
  },
  {
    "id": 681,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/fscript_ext/fscript_istream.c",
    "input": "﻿/**\n * File:   fscript_istream.c\n * Author: AWTK Develop Team\n * Brief:  istream functions for fscript\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2021-01-06 Li XianJing <lixianjing@zlg.cn> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/buffer.h\"\n#include \"tkc/fscript.h\"\n#include \"tkc/istream.h\"\n\nstatic ret_t func_istream_seek(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t offset = 0;\n  tk_istream_t* istream = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  istream = TK_ISTREAM(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(istream != NULL && istream != NULL, RET_BAD_PARAMS);\n  offset = value_uint32(args->args + 1);\n\n  value_set_bool(result, tk_istream_seek(istream, offset) == RET_OK);\n\n  return RET_OK;\n}\n\nstatic ret_t func_istream_tell(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  tk_istream_t* istream = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  istream = TK_ISTREAM(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(istream != NULL && istream != NULL, RET_BAD_PARAMS);\n\n  value_set_uint32(result, tk_istream_tell(istream));\n\n  return RET_OK;\n}\n\nstatic ret_t func_istream_is_eos(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  tk_istream_t* istream = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  istream = TK_ISTREAM(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(istream != NULL && istream != NULL, RET_BAD_PARAMS);\n\n  value_set_bool(result, tk_istream_eos(istream));\n\n  return RET_OK;\n}\n\nstatic ret_t func_istream_read_uint8(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint8_t v = 0;\n  int32_t ret = 0;\n  uint32_t timeout = 0;\n  tk_istream_t* istream = NULL;\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n  istream = TK_ISTREAM(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(istream != NULL && istream != NULL, RET_BAD_PARAMS);\n  timeout = args->size > 1 ? value_uint32(args->args + 1) : 0;\n\n  ret = tk_istream_read_len(istream, &v, sizeof(v), timeout);\n  if (ret == sizeof(v)) {\n    value_set_uint8(result, v);\n  }\n\n  return ret == sizeof(v) ? RET_OK : RET_FAIL;\n}\n\nstatic ret_t func_istream_read_uint16(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint16_t v = 0;\n  int32_t ret = 0;\n  uint32_t timeout = 0;\n  tk_istream_t* istream = NULL;\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n  istream = TK_ISTREAM(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(istream != NULL && istream != NULL, RET_BAD_PARAMS);\n  timeout = args->size > 1 ? value_uint32(args->args + 1) : 0;\n\n  ret = tk_istream_read_len(istream, &v, sizeof(v), timeout);\n  if (ret == sizeof(v)) {\n    value_set_uint16(result, v);\n  }\n\n  return ret == sizeof(v) ? RET_OK : RET_FAIL;\n}\n\nstatic ret_t func_istream_read_uint32(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t v = 0;\n  int32_t ret = 0;\n  uint32_t timeout = 0;\n  tk_istream_t* istream = NULL;\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n  istream = TK_ISTREAM(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(istream != NULL && istream != NULL, RET_BAD_PARAMS);\n  timeout = args->size > 1 ? value_uint32(args->args + 1) : 0;\n\n  ret = tk_istream_read_len(istream, &v, sizeof(v), timeout);\n  if (ret == sizeof(v)) {\n    value_set_uint32(result, v);\n  }\n\n  return ret == sizeof(v) ? RET_OK : RET_FAIL;\n}\n\nstatic ret_t func_istream_read_uint64(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint64_t v = 0;\n  int32_t ret = 0;\n  uint32_t timeout = 0;\n  tk_istream_t* istream = NULL;\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n  istream = TK_ISTREAM(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(istream != NULL && istream != NULL, RET_BAD_PARAMS);\n  timeout = args->size > 1 ? value_uint32(args->args + 1) : 0;\n\n  ret = tk_istream_read_len(istream, &v, sizeof(v), timeout);\n  if (ret == sizeof(v)) {\n    value_set_uint64(result, v);\n  }\n\n  return ret == sizeof(v) ? RET_OK : RET_FAIL;\n}\n\nstatic ret_t func_istream_read_int8(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  ret_t ret = func_istream_read_uint8(fscript, args, result);\n  if (result->type != VALUE_TYPE_INVALID) {\n    result->type = VALUE_TYPE_INT8;\n  }\n  return ret;\n}\n\nstatic ret_t func_istream_read_int16(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  ret_t ret = func_istream_read_uint16(fscript, args, result);\n  if (result->type != VALUE_TYPE_INVALID) {\n    result->type = VALUE_TYPE_INT16;\n  }\n  return ret;\n}\n\nstatic ret_t func_istream_read_int32(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  ret_t ret = func_istream_read_uint32(fscript, args, result);\n  if (result->type != VALUE_TYPE_INVALID) {\n    result->type = VALUE_TYPE_INT32;\n  }\n  return ret;\n}\n\nstatic ret_t func_istream_read_int64(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  ret_t ret = func_istream_read_uint64(fscript, args, result);\n  if (result->type != VALUE_TYPE_INVALID) {\n    result->type = VALUE_TYPE_INT64;\n  }\n  return ret;\n}\n\nstatic ret_t func_istream_read_float(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  float v = 0;\n  int32_t ret = 0;\n  uint32_t timeout = 0;\n  tk_istream_t* istream = NULL;\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n  istream = TK_ISTREAM(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(istream != NULL && istream != NULL, RET_BAD_PARAMS);\n  timeout = args->size > 1 ? value_uint32(args->args + 1) : 0;\n\n  ret = tk_istream_read_len(istream, &v, sizeof(v), timeout);\n  if (ret == sizeof(v)) {\n    value_set_float(result, v);\n  }\n\n  return ret == sizeof(v) ? RET_OK : RET_FAIL;\n}\n\nstatic ret_t func_istream_read_double(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  double v = 0;\n  int32_t ret = 0;\n  uint32_t timeout = 0;\n  tk_istream_t* istream = NULL;\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n  istream = TK_ISTREAM(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(istream != NULL && istream != NULL, RET_BAD_PARAMS);\n  timeout = args->size > 1 ? value_uint32(args->args + 1) : 0;\n\n  ret = tk_istream_read_len(istream, &v, sizeof(v), timeout);\n  if (ret == sizeof(v)) {\n    value_set_double(result, v);\n  }\n\n  return ret == sizeof(v) ? RET_OK : RET_FAIL;\n}\n\nstatic ret_t func_istream_read_string(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  char* v = 0;\n  int32_t ret = 0;\n  uint32_t size = 0;\n  uint32_t timeout = 0;\n  tk_istream_t* istream = NULL;\n\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n  istream = TK_ISTREAM(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(istream != NULL && istream != NULL, RET_BAD_PARAMS);\n  size = args->size > 1 ? value_uint32(args->args + 1) : 0;\n  timeout = args->size > 2 ? value_uint32(args->args + 2) : 0;\n  FSCRIPT_FUNC_CHECK(size > 0, RET_BAD_PARAMS);\n  v = TKMEM_ALLOC(size + 1);\n  FSCRIPT_FUNC_CHECK(v != NULL, RET_BAD_PARAMS);\n\nret = ",
    "raw_res": "0;",
    "prompt_res": "tk_istream_read_len(istream, v, size, timeout);",
    "gt": "tk_istream_read_len(istream, v, size, timeout);"
  },
  {
    "id": 714,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/native_window/native_window_sdl.c",
    "input": "﻿/**\n * File:   native_window_sdl.h\n * Author: AWTK Develop Team\n * Brief:  native window sdl\n *\n * Copyright (c) 2019 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-07-21 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include <SDL.h>\n#include \"base/system_info.h\"\n#include \"base/window_manager.h\"\n\n#ifdef WITH_GPU_GL\n#ifndef WITHOUT_GLAD\n#include \"glad/glad.h\"\n#define loadGL gladLoadGL\n#else\n#define loadGL()\n#ifdef IOS\n#include <OpenGLES/gltypes.h>\n#include <OpenGLES/ES2/gl.h>\n#include <OpenGLES/ES2/glext.h>\n#define GL_ALPHA_TEST 0x0BC0\n#else\n#include <SDL_opengl.h>\n#include <SDL_opengl_glext.h>\n#endif /*IOS*/\n#endif /*WITHOUT_GLAD*/\n\n#endif /*WITH_GPU_GL*/\n\n#include \"lcd/lcd_sdl2.h\"\n#include \"lcd/lcd_nanovg.h\"\n#include \"lcd/lcd_sdl2_mono.h\"\n#include \"base/native_window.h\"\n\ntypedef struct _native_window_sdl_t {\n  native_window_t native_window;\n  bool_t is_init;\n  SDL_GLContext context;\n  SDL_Renderer* render;\n  SDL_Window* window;\n  canvas_t canvas;\n  SDL_Cursor* cursor;\n  SDL_Surface* cursor_surface;\n} native_window_sdl_t;\n\nstatic native_window_t* s_shared_win = NULL;\n\n#define NATIVE_WINDOW_SDL(win) ((native_window_sdl_t*)(win))\n\nstatic ret_t native_window_sdl_move(native_window_t* win, xy_t x, xy_t y) {\n  int oldx = 0;\n  int oldy = 0;\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n\n  win->rect.x = x;\n  win->rect.y = y;\n  SDL_GetWindowPosition(sdl->window, &oldx, &oldy);\n  if (oldx != x || oldy != y) {\n    SDL_SetWindowPosition(sdl->window, x, y);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_resize(native_window_t* win, wh_t w, wh_t h) {\n  lcd_t* lcd = NULL;\n  ret_t ret = RET_OK;\n  native_window_info_t info;\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n  return_value_if_fail(sdl != NULL, RET_BAD_PARAMS);\n  lcd = sdl->canvas.lcd;\n  native_window_get_info(win, &info);\n\n  win->rect.w = w;\n  win->rect.h = h;\n\n#if !defined(ANDROID) && !defined(IOS)\n  if (w != info.w || h != info.h) {\n#ifdef WIN32\n    w = w * win->ratio;\n    h = h * win->ratio;\n#endif /*WIN32*/\n\n    SDL_SetWindowSize(sdl->window, w, h);\n  }\n#endif /*ANDROID*/\n  if (lcd != NULL && (lcd->w != w || lcd->h != h)) {\n    ret = lcd_resize(lcd, w, h, 0);\n  }\n\n  return ret;\n}\n\nstatic ret_t native_window_sdl_set_orientation(native_window_t* win,\n                                               lcd_orientation_t old_orientation,\n                                               lcd_orientation_t new_orientation) {\n  wh_t w, h;\n  native_window_info_t info;\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n  return_value_if_fail(sdl != NULL, RET_BAD_PARAMS);\n  native_window_get_info(win, &info);\n  w = info.w;\n  h = info.h;\n  if (new_orientation == LCD_ORIENTATION_90 || new_orientation == LCD_ORIENTATION_270) {\n    w = info.h;\n    h = info.w;\n  }\n\n  win->rect.w = w;\n  win->rect.h = h;\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_minimize(native_window_t* win) {\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n\n  SDL_MinimizeWindow(sdl->window);\n\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_maximize(native_window_t* win) {\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n\n  SDL_MaximizeWindow(sdl->window);\n\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_restore(native_window_t* win) {\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n\n  SDL_RestoreWindow(sdl->window);\n\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_center(native_window_t* win) {\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n\n  SDL_SetWindowPosition(sdl->window, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED);\n\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_show_border(native_window_t* win, bool_t show) {\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n\n  SDL_SetWindowBordered(sdl->window, show);\n\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_set_fullscreen(native_window_t* win, bool_t fullscreen) {\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n\n  if (fullscreen) {\n    SDL_SetWindowFullscreen(sdl->window, SDL_WINDOW_FULLSCREEN_DESKTOP);\n  } else {\n    SDL_SetWindowFullscreen(sdl->window, 0);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_close(native_window_t* win) {\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n  lcd_t* lcd = sdl->canvas.lcd;\n\n  canvas_reset(&(sdl->canvas));\n  lcd_destroy(lcd);\n\n  if (sdl->render != NULL) {\n    SDL_DestroyRenderer(sdl->render);\n  }\n\n  if (sdl->context != NULL) {\n    SDL_GL_DeleteContext(sdl->context);\n  }\n\n  if (sdl->window != NULL) {\n    SDL_DestroyWindow(sdl->window);\n  }\n\n  sdl->render = NULL;\n  sdl->window = NULL;\n  sdl->context = NULL;\n\n  SDL_Quit();\n\n  return RET_OK;\n}\n\nstatic canvas_t* native_window_sdl_get_canvas(native_window_t* win) {\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n\n  return &(sdl->canvas);\n}\n\nstatic ret_t native_window_sdl_gl_make_current(native_window_t* win) {\n#ifdef WITH_GPU_GL\n  int fw = 0;\n  int fh = 0;\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n  SDL_Window* window = sdl->window;\n\n  SDL_GL_MakeCurrent(window, sdl->context);\n  SDL_GL_GetDrawableSize(window, &fw, &fh);\n\n  glViewport(0, 0, fw, fh);\n  if (!sdl->is_init) {\n    sdl->is_init = TRUE;\n    glClearColor(1.0f, 1.0f, 1.0f, 1.0f);\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);\n  } else {\n    glClear(GL_STENCIL_BUFFER_BIT);\n  }\n#endif /*WITH_GPU_GL*/\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_swap_buffer(native_window_t* win) {\n#ifdef WITH_GPU_GL\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n  SDL_GL_SwapWindow(sdl->window);\n#else\n#endif /*WITH_GPU_GL*/\n\n  return RET_OK;\n}\n\nextern ret_t tk_quit();\n\nstatic ret_t native_window_sdl_preprocess_event(native_window_t* win, event_t* e) {\n#if defined(ANDROID)\n  if (e->type == EVT_POINTER_DOWN || e->type == EVT_POINTER_MOVE || e->type == EVT_CLICK ||\n      e->type == EVT_POINTER_UP || e->type == EVT_CONTEXT_MENU) {\n    pointer_event_t* evt = pointer_event_cast(e);\n    evt->x /= win->ratio;\n    evt->y /= win->ratio;\n  } else if (e->type == EVT_KEY_DOWN) {\n    key_event_t* evt = key_event_cast(e);\n    if (evt->key == TK_KEY_AC_BACK) {\n      window_manager_back(window_manager());\n      if (widget_count_children(window_manager()) == 0) {\n        tk_quit();\n      }\n    }\n  }\n#endif /*ANDROID*/\n\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_get_info(native_window_t* win, native_window_info_t* info) {\n  int ww = 0;\n  int wh = 0;\n  int fw = 0;\n  int fh = 0;\n  int x = 0;\n  int y = 0;\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n  SDL_Window* window = sdl->window;\n\n  SDL_GetWindowPosition(window, &x, &y);\n  SDL_GetWindowSize(window, &ww, &wh);\n  SDL_GL_GetDrawableSize(window, &fw, &fh);\n\n  memset(info, 0x00, sizeof(*info));\n  info->x = x;\n  info->y = y;\n\n#if defined(ANDROID)\n  float dpi = 1;\n  SDL_GetDisplayDPI(0, &dpi, NULL, NULL);\n  float_t ratio = dpi / 160;\n\n  info->w = ww / ratio;\n  info->h = wh / ratio;\n  info->ratio = ratio;\n#elif defined(IOS)\n  info->w = ww;\n  info->h = wh;\n  info->ratio = (float_t)fw / (float_t)ww;\n#else\n  info->w = ww;\n  info->h = wh;\n  info->ratio = (float_t)fw / (float_t)ww;\n#endif /**/\n\n  win->rect.x = info->x;\n  win->rect.y = info->y;\n  win->rect.w = info->w;\n  win->rect.h = info->h;\n  win->ratio = info->ratio;\n\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_cursor_from_bitmap(native_window_t* win, bitmap_t* img) {\n  Uint32 depth = 32;\n  uint8_t* data = NULL;\n  uint32_t w = img->w;\n  uint32_t h = img->h;\n  uint32_t rmask = 0;\n  uint32_t gmask = 0;\n  uint32_t bmask = 0;\n  uint32_t amask = 0;\n  uint32_t pitch = 4 * w;\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n\n  if (img->format == BITMAP_FMT_BGRA8888) {\n    bmask = 0x000000ff;\n    gmask = 0x0000ff00;\n    rmask = 0x00ff0000;\n    amask = 0xff000000;\n  } else if (img->format == BITMAP_FMT_RGBA8888) {\n    rmask = 0x000000ff;\n    gmask = 0x0000ff00;\n    bmask = 0x00ff0000;\n    amask = 0xff000000;\n  } else {\n    /*\n     *assert(!\"not supported format!\");\n     */\n    return RET_FAIL;\n  }\n\n  if (sdl->cursor_surface != NULL) {\n    SDL_FreeSurface(sdl->cursor_surface);\n    sdl->cursor_surface = NULL;\n  }\n\n  data = bitmap_lock_buffer_for_read(img);\n  return_value_if_fail(data != NULL, RET_BAD_PARAMS);\n  sdl->cursor_surface =\n      SDL_CreateRGBSurfaceFrom(data, w, h, depth, pitch, rmask, gmask, bmask, amask);\n  bitmap_unlock_buffer(img);\n  return_value_if_fail(sdl->cursor_surface != NULL, RET_OOM);\n\n  sdl->cursor = SDL_CreateColorCursor(sdl->cursor_surface, 0, 0);\n  SDL_SetCursor(sdl->cursor);\n\n  return RET_OK;\n}\n\nstatic int map_to_sdl_cursor(const char* name) {\n  if (tk_str_eq(WIDGET_CURSOR_DEFAULT, name)) {\n    return SDL_SYSTEM_CURSOR_ARROW;\n  } else if (tk_str_eq(WIDGET_CURSOR_EDIT, name)) {\n    return SDL_SYSTEM_CURSOR_IBEAM;\n  } else if (tk_str_eq(WIDGET_CURSOR_HAND, name)) {\n    return SDL_SYSTEM_CURSOR_HAND;\n  } else if (tk_str_eq(WIDGET_CURSOR_WAIT, name)) {\n    return SDL_SYSTEM_CURSOR_WAIT;\n  } else if (tk_str_eq(WIDGET_CURSOR_CROSS, name)) {\n    return SDL_SYSTEM_CURSOR_CROSSHAIR;\n  } else if (tk_str_eq(WIDGET_CURSOR_NO, name)) {\n    return SDL_SYSTEM_CURSOR_NO;\n  } else if (tk_str_eq(WIDGET_CURSOR_SIZENWSE, name)) {\n    return SDL_SYSTEM_CURSOR_SIZENWSE;\n  } else if (tk_str_eq(WIDGET_CURSOR_SIZENESW, name)) {\n    return SDL_SYSTEM_CURSOR_SIZENESW;\n  } else if (tk_str_eq(WIDGET_CURSOR_SIZEWE, name)) {\n    return SDL_SYSTEM_CURSOR_SIZEWE;\n  } else if (tk_str_eq(WIDGET_CURSOR_SIZENS, name)) {\n    return SDL_SYSTEM_CURSOR_SIZENS;\n  } else if (tk_str_eq(WIDGET_CURSOR_SIZEALL, name)) {\n    return SDL_SYSTEM_CURSOR_SIZEALL;\n  }\n\n  return -1;\n}\n\nstatic ret_t native_window_sdl_set_cursor(native_window_t* win, const char* name, bitmap_t* img) {\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n\n  if (sdl->cursor != NULL) {\n    SDL_FreeCursor(sdl->cursor);\n    sdl->cursor = NULL;\n  }\n\n  if (system_info()->app_type == APP_DESKTOP) {\n    int system_cursor = map_to_sdl_cursor(name);\n    if (system_cursor >= 0) {\n      sdl->cursor = SDL_CreateSystemCursor((SDL_SystemCursor)system_cursor);\n      SDL_SetCursor(sdl->cursor);\n\n      return RET_OK;\n    }\n  } else if (img != NULL) {\n    return native_window_sdl_cursor_from_bitmap(win, img);\n  }\n\n  return RET_FAIL;\n}\n\nstatic const native_window_vtable_t s_native_window_vtable = {\n    .type = \"native_window_sdl\",\n    .move = native_window_sdl_move,\n    .resize = native_window_sdl_resize,\n    .set_orientation = native_window_sdl_set_orientation,\n    .minimize = native_window_sdl_minimize,\n    .maximize = native_window_sdl_maximize,\n    .restore = native_window_sdl_restore,\n    .center = native_window_sdl_center,\n    .show_border = native_window_sdl_show_border,\n    .set_fullscreen = native_window_sdl_set_fullscreen,\n    .get_info = native_window_sdl_get_info,\n    .preprocess_event = native_window_sdl_preprocess_event,\n    .swap_buffer = native_window_sdl_swap_buffer,\n    .gl_make_current = native_window_sdl_gl_make_current,\n    .set_cursor = native_window_sdl_set_cursor,\n    .get_canvas = native_window_sdl_get_canvas};\n\nstatic ret_t native_window_sdl_set_prop(tk_object_t* obj, const char* name, const value_t* v) {\n  native_window_t* win = NATIVE_WINDOW(obj);\n\n  if (tk_str_eq(NATIVE_WINDOW_PROP_SIZE, name)) {\n    rect_t* r = (rect_t*)value_pointer(v);\n    native_window_sdl_resize(win, r->w, r->h);\n\n    return RET_OK;\n  } else if (tk_str_eq(NATIVE_WINDOW_PROP_POSITION, name)) {\n    rect_t* r = (rect_t*)value_pointer(v);\n    native_window_sdl_move(win, r->x, r->y);\n\n    return RET_OK;\n  } else if (tk_str_eq(NATIVE_WINDOW_PROP_TITLE, name)) {\n    SDL_Window* sdlwin = (SDL_Window*)(win->handle);\n    const char* app_name = value_str(v);\n    SDL_SetWindowTitle(sdlwin, app_name);\n    system_info_set_app_name(system_info(), app_name);\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t native_window_sdl_get_prop(tk_object_t* obj, const char* name, value_t* v) {\n  native_window_t* win = NATIVE_WINDOW(obj);\n\n  if (tk_str_eq(NATIVE_WINDOW_PROP_SIZE, name) || tk_str_eq(NATIVE_WINDOW_PROP_POSITION, name)) {\n    int x = 0;\n    int y = 0;\n    int w = 0;\n    int h = 0;\n    SDL_Window* sdlwin = (SDL_Window*)(win->handle);\n\n    SDL_GetWindowSize(sdlwin, &w, &h);\n    SDL_GetWindowPosition(sdlwin, &x, &y);\n    win->rect = rect_init(x, y, w, h);\n    value_set_pointer(v, &(win->rect));\n\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t native_window_sdl_on_destroy(tk_object_t* obj) {\n  log_debug(\"Close native window.\\n\");\n  native_window_sdl_close(NATIVE_WINDOW(obj));\n\n  return RET_OK;\n}\n\nstatic ret_t native_window_sdl_exec(tk_object_t* obj, const char* cmd, const char* args) {\n#ifdef WITH_GPU\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(obj);\n  if (tk_str_eq(cmd, \"reset_canvas\")) {\n    canvas_t* c = &(sdl->canvas);\n    vgcanvas_t* vg = canvas_get_vgcanvas(c);\n\n    vgcanvas_reset(vg);\n\n    return RET_OK;\n  }\n#endif /*WITH_GPU*/\n\n  return RET_NOT_FOUND;\n}\n\nstatic const object_vtable_t s_native_window_sdl_vtable = {\n    .type = \"native_window_sdl\",\n    .desc = \"native_window_sdl\",\n    .size = sizeof(native_window_sdl_t),\n    .get_prop = native_window_sdl_get_prop,\n    .set_prop = native_window_sdl_set_prop,\n    .exec = native_window_sdl_exec,\n    .on_destroy = native_window_sdl_on_destroy};\n\nstatic native_window_t* native_window_create_internal(const char* title, uint32_t flags, int32_t x,\n                                                      int32_t y, uint32_t w, uint32_t h) {\n  lcd_t* lcd = NULL;\n  native_window_info_t info;\n  tk_object_t* obj = tk_object_create(&s_native_window_sdl_vtable);\n  native_window_t* win = NATIVE_WINDOW(obj);\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n  canvas_t* c = &(sdl->canvas);\n\n#ifndef NATIVE_WINDOW_NOT_RESIZABLE\n  if (system_info()->app_type == APP_DESKTOP) {\n    flags |= SDL_WINDOW_RESIZABLE;\n  }\n#endif /*NATIVE_WINDOW_NOT_RESIZABLE*/\n\n#ifndef WITH_NANOVG_SOFT\n  flags |= SDL_WINDOW_OPENGL | SDL_WINDOW_ALLOW_HIGHDPI;\n#endif /*WITH_NANOVG_SOFT*/\n\n#ifdef NATIVE_WINDOW_BORDERLESS\n  flags |= SDL_WINDOW_BORDERLESS;\n#endif /*NATIVE_WINDOW_BORDERLESS*/\n\n  sdl->window = SDL_CreateWindow(title, x, y, w, h, flags);\n\n#ifdef WITH_NANOVG_SOFT\n  sdl->render =\n      SDL_CreateRenderer(sdl->window, -1, SDL_RENDERER_PRESENTVSYNC | SDL_RENDERER_ACCELERATED);\n  if (sdl->render == NULL) {\n    sdl->render = SDL_CreateRenderer(sdl->window, -1, SDL_RENDERER_SOFTWARE);\n  }\n#endif /*WITH_NANOVG_SOFT*/\n\n  win->handle = sdl->window;\n  win->vt = &s_native_window_vtable;\n\n#ifdef WITH_GPU_GL\n  sdl->context = SDL_GL_CreateContext(sdl->window);\n  SDL_GL_SetSwapInterval(1);\n\n  loadGL();\n  glDisable(GL_STENCIL_TEST);\n  glDisable(GL_ALPHA_TEST);\n  glDisable(GL_DEPTH_TEST);\n  glDisable(GL_SCISSOR_TEST);\n#endif /*WITH_GPU_GL*/\n\n  if (native_window_get_info(win, &info) == RET_OK) {\n    w = info.w;\n    h = info.h;\n  }\n  win->rect = rect_init(x, y, w, h);\n\n#ifdef WITH_LCD_MONO\n  lcd = lcd_sdl2_mono_init(sdl->render);\n#else\n#ifdef WITH_NANOVG_SOFT\n  lcd = lcd_sdl2_init(sdl->render);\n#elif WITH_NANOVG_GPU\n  lcd = lcd_nanovg_init(win);\n#endif /*WITH_NANOVG_SOFT*/\n#endif /*WITH_LCD_MONO*/\n\n  canvas_init(c, lcd, font_manager());\n\n  return win;\n}\n\nnative_window_t* native_window_create(widget_t* widget) {\n  int32_t x = widget->x;\n  int32_t y = widget->y;\n  int32_t w = widget->w;\n  int32_t h = widget->h;\n  native_window_t* nw = NULL;\n\n  if (s_shared_win != NULL) {\n    tk_object_ref(TK_OBJECT(s_shared_win));\n\n    nw = s_shared_win;\n  } else {\n    str_t str;\n\n    str_init(&str, 0);\n    str_from_wstr(&str, widget->text.str);\n    nw = native_window_create_internal(str.str, 0, x, y, w, h);\n    str_reset(&str);\n  }\n\n  widget_set_prop_pointer(widget, WIDGET_PROP_NATIVE_WINDOW, nw);\n\n  return nw;\n}\n\n#ifdef WITH_GPU_GL\nstatic ret_t sdl_init_gl(void) {\n  SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 8);\n  SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 8);\n  SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 8);\n  SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8);\n  SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);\n  SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\n  SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, \"nearest\");\n\n#ifdef WITH_GPU_GL2\n  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);\n  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);\n#elif defined(WITH_GPU_GL3)\n  SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG);\n  SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);\n  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);\n  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);\n#endif\n\n  log_debug(\"Init opengl done.\\n\");\n  return RET_OK;\n}\n#endif /*WITH_GPU_GL*/\n\nret_t native_window_sdl_init(bool_t shared, uint32_t w, uint32_t h) {\n  const char* title = system_info()->app_name;\n\n  SDL_SetHint(SDL_HINT_VIDEO_ALLOW_SCREENSAVER, \"1\");\n  if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_EVENTS | SDL_INIT_AUDIO) != 0) {\n    log_debug(\"Failed to initialize SDL: %s\", SDL_GetError());\n    exit(0);\n    return RET_FAIL;\n  }\n\n#ifdef WITH_GPU_GL\n  sdl_init_gl();\n#endif /*WITH_GPU_GL*/\n\n  SDL_StopTextInput();\n  if (shared) {\n    int32_t x = SDL_WINDOWPOS_UNDEFINED;\n    int32_t y = SDL_WINDOWPOS_UNDEFINED;\ns_shared_win = ",
    "raw_res": "native_window_create_internal(title, SDL_WINDOW_FULLSCREEN_DESKTOP, x, y, w, h);",
    "prompt_res": "native_window_create_internal(title, 0, x, y, w, h);",
    "gt": "native_window_create_internal(title, 0, x, y, w, h);"
  },
  {
    "id": 741,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/waitable_action_queue.c",
    "input": "﻿/**\n * File:   waitable_action_queue.c\n * Author: AWTK Develop Team\n * Brief:  waitable_action_queue\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2020-02-07 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/waitable_action_queue.h\"\n\nwaitable_action_queue_t* waitable_action_queue_create(uint16_t capacity) {\n  waitable_action_queue_t* q = TKMEM_ZALLOC(waitable_action_queue_t);\n  return_value_if_fail(q != NULL, NULL);\n  q->queue = action_queue_create(capacity);\n  goto_error_if_fail(q->queue != NULL);\n\n  q->mutex = tk_mutex_create();\n  goto_error_if_fail(q->mutex != NULL);\n\n  q->sema_recv = tk_semaphore_create(0, NULL);\n  goto_error_if_fail(q->sema_recv != NULL);\n\n  q->sema_send = tk_semaphore_create(capacity, NULL);\n  goto_error_if_fail(q->sema_send != NULL);\n\n  return q;\nerror:\n  if (q != NULL) {\n    if (q->queue != NULL) {\n      action_queue_destroy(q->queue);\n    }\n\n    if (q->mutex != NULL) {\n      tk_mutex_destroy(q->mutex);\n    }\n\n    if (q->sema_recv != NULL) {\n      tk_semaphore_destroy(q->sema_recv);\n    }\n\n    if (q->sema_send != NULL) {\n      tk_semaphore_destroy(q->sema_send);\n    }\n\n    TKMEM_FREE(q);\n  }\n\n  return NULL;\n}\n\nret_t waitable_action_queue_recv(waitable_action_queue_t* q, qaction_t** action,\n                                 uint32_t timeout_ms) {\n  ret_t ret = RET_FAIL;\n  return_value_if_fail(q != NULL && action != NULL, RET_BAD_PARAMS);\n\n  if (tk_semaphore_wait(q->sema_recv, timeout_ms) == RET_OK) {\n    if (tk_mutex_lock(q->mutex) == RET_OK) {\nret = ",
    "raw_res": "0;",
    "prompt_res": "action_queue_recv(q->queue, action);",
    "gt": "action_queue_recv(q->queue, action);"
  },
  {
    "id": 751,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/object.c",
    "input": "﻿/**\n * File:   object.c\n * Author: AWTK Develop Team\n * Brief:  reference count object\n *\n * Copyright (c) 2019 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-01-09 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/event.h\"\n#include \"tkc/object.h\"\n#include \"tkc/fscript.h\"\n#include \"tkc/named_value.h\"\n\nret_t tk_object_set_name(tk_object_t* obj, const char* name) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(obj != NULL && obj->vt != NULL, RET_BAD_PARAMS);\n\n  obj->name = tk_str_copy(obj->name, name);\n\n  return ret;\n}\n\nstatic ret_t object_destroy(tk_object_t* obj) {\n  ret_t ret = RET_OK;\n  event_t e = event_init(EVT_DESTROY, obj);\n  return_value_if_fail(obj != NULL && obj->vt != NULL, RET_BAD_PARAMS);\n\n  emitter_dispatch((emitter_t*)obj, (event_t*)(&e));\n\n  if (obj->vt->on_destroy != NULL) {\n    ret = obj->vt->on_destroy(obj);\n  }\n\n  emitter_deinit((emitter_t*)obj);\n  TKMEM_FREE(obj->name);\n\n  memset(obj, 0x00, obj->vt->size);\n  TKMEM_FREE(obj);\n\n  return ret;\n}\n\ntk_object_t* tk_object_create_ex(const object_vtable_t* vt, uint32_t extra_data_size) {\n  uint32_t size = 0;\n  tk_object_t* obj = NULL;\n  return_value_if_fail(vt != NULL && vt->size >= sizeof(tk_object_t), NULL);\n\n  size = vt->size + extra_data_size;\n  obj = (tk_object_t*)TKMEM_ALLOC(size);\n  return_value_if_fail(obj != NULL, NULL);\n\n  memset(obj, 0x00, size);\n\n  obj->vt = vt;\n  obj->ref_count = 1;\n  emitter_init((emitter_t*)obj);\n\n  return obj;\n}\n\ntk_object_t* tk_object_create(const object_vtable_t* vt) {\n  tk_object_t* obj = NULL;\n  return_value_if_fail(vt != NULL && vt->size >= sizeof(tk_object_t), NULL);\n\n  obj = (tk_object_t*)TKMEM_ALLOC(vt->size);\n  return_value_if_fail(obj != NULL, NULL);\n\n  memset(obj, 0x00, vt->size);\n\n  obj->vt = vt;\n  obj->ref_count = 1;\n  emitter_init((emitter_t*)obj);\n\n  return obj;\n}\n\nret_t tk_object_unref(tk_object_t* obj) {\n  return_value_if_fail(obj != NULL && obj->vt != NULL && obj->ref_count > 0, RET_BAD_PARAMS);\n  return_value_if_fail(!(obj->visiting), RET_BUSY);\n\n  if (obj->ref_count == 1) {\n    object_destroy(obj);\n  } else {\n    obj->ref_count--;\n  }\n\n  return RET_OK;\n}\n\ntk_object_t* tk_object_ref(tk_object_t* obj) {\n  return_value_if_fail(obj != NULL && obj->vt != NULL && obj->ref_count >= 0, NULL);\n\n  obj->ref_count++;\n\n  return obj;\n}\n\ntk_object_t* tk_object_clone(tk_object_t* obj) {\n  return_value_if_fail(obj != NULL && obj->vt != NULL && obj->vt->clone != NULL, NULL);\n\n  return obj->vt->clone(obj);\n}\n\nstatic ret_t object_get_prop_by_name(tk_object_t* obj, const char* name, value_t* v) {\n  ret_t ret = RET_NOT_FOUND;\n  return_value_if_fail(obj != NULL && obj->vt != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  value_set_str(v, NULL);\n  if (obj->vt->get_prop != NULL) {\n    ret = obj->vt->get_prop(obj, name, v);\n  }\n\n  return ret;\n}\n\nstatic ret_t object_get_prop_by_path_with_len(tk_object_t* obj, const char* path, uint32_t len,\n                                              value_t* v) {\n  char* p = NULL;\n  char temp[MAX_PATH + 1];\n  const char* name = temp;\n  ret_t ret = RET_NOT_FOUND;\n  return_value_if_fail(len <= MAX_PATH, RET_BAD_PARAMS);\n\n  memcpy(temp, path, len);\n  temp[len] = '\\0';\n\n  do {\n    p = strchr(name, '.');\n    if (p != NULL) {\n      *p = '\\0';\n    }\n\n    if (object_get_prop_by_name(obj, name, v) != RET_OK) {\n      break;\n    }\n\n    if (p == NULL) {\n      ret = RET_OK;\n      break;\n    }\n\n    if (v->type == VALUE_TYPE_OBJECT) {\n      obj = value_object(v);\n    } else {\n      ret = RET_BAD_PARAMS;\n      break;\n    }\n\n    name = p + 1;\n  } while (p != NULL);\n\n  return ret;\n}\n\nret_t tk_object_get_prop_by_path(tk_object_t* obj, const char* path, value_t* v) {\n  uint32_t len = 0;\n  return_value_if_fail(obj != NULL && obj->vt != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(path != NULL && v != NULL, RET_BAD_PARAMS);\n\n  len = strlen(path);\n  return object_get_prop_by_path_with_len(obj, path, len, v);\n}\n\nret_t tk_object_get_prop(tk_object_t* obj, const char* name, value_t* v) {\n  return object_get_prop_by_name(obj, name, v);\n}\n\nconst char* tk_object_get_prop_str(tk_object_t* obj, const char* name) {\n  value_t v;\n  if (tk_object_get_prop(obj, name, &v) == RET_OK) {\n    return value_str(&v);\n  } else {\n    return NULL;\n  }\n}\n\nvoid* tk_object_get_prop_pointer(tk_object_t* obj, const char* name) {\n  value_t v;\n  if (tk_object_get_prop(obj, name, &v) == RET_OK) {\n    return value_pointer(&v);\n  } else {\n    return NULL;\n  }\n}\n\ntk_object_t* tk_object_get_prop_object(tk_object_t* obj, const char* name) {\n  value_t v;\n  if (tk_object_get_prop(obj, name, &v) == RET_OK) {\n    return value_object(&v);\n  } else {\n    return NULL;\n  }\n}\n\nint32_t tk_object_get_prop_int(tk_object_t* obj, const char* name, int32_t defval) {\n  value_t v;\n  if (tk_object_get_prop(obj, name, &v) == RET_OK) {\n    return value_int(&v);\n  } else {\n    return defval;\n  }\n}\n\nbool_t tk_object_get_prop_bool(tk_object_t* obj, const char* name, bool_t defval) {\n  value_t v;\n  if (tk_object_get_prop(obj, name, &v) == RET_OK) {\n    return value_bool(&v);\n  } else {\n    return defval;\n  }\n}\n\nfloat_t tk_object_get_prop_float(tk_object_t* obj, const char* name, float_t defval) {\n  value_t v;\n  if (tk_object_get_prop(obj, name, &v) == RET_OK) {\n    return value_float(&v);\n  } else {\n    return defval;\n  }\n}\n\ndouble tk_object_get_prop_double(tk_object_t* obj, const char* name, double defval) {\n  value_t v;\n  if (tk_object_get_prop(obj, name, &v) == RET_OK) {\n    return value_double(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t tk_object_notify_changed(tk_object_t* obj) {\n  event_t e = event_init(EVT_PROPS_CHANGED, obj);\n\n  return emitter_dispatch((emitter_t*)obj, &e);\n}\n\nret_t tk_object_set_prop(tk_object_t* obj, const char* name, const value_t* v) {\n  ret_t ret = RET_NOT_FOUND;\n  return_value_if_fail(name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(obj != NULL && obj->vt != NULL && obj->ref_count >= 0, RET_BAD_PARAMS);\n  return_value_if_fail(!(obj->visiting), RET_BUSY);\n\n  if (obj->vt->set_prop != NULL) {\n    prop_change_event_t e;\n\n    e.name = name;\n    e.value = v;\n\n    e.e = event_init(EVT_PROP_WILL_CHANGE, obj);\n    emitter_dispatch((emitter_t*)obj, (event_t*)(&e));\n\n    ret = obj->vt->set_prop(obj, name, v);\n    if (ret == RET_OK) {\n      e.e = event_init(EVT_PROP_CHANGED, obj);\n      emitter_dispatch((emitter_t*)obj, (event_t*)(&e));\n    }\n  }\n\n  return ret;\n}\n\nret_t tk_object_set_prop_str(tk_object_t* obj, const char* name, const char* value) {\n  value_t v;\n  value_set_str(&v, value);\n\n  return tk_object_set_prop(obj, name, &v);\n}\n\nret_t tk_object_set_prop_pointer(tk_object_t* obj, const char* name, void* value) {\n  value_t v;\n  value_set_pointer(&v, value);\n\n  return tk_object_set_prop(obj, name, &v);\n}\n\nret_t tk_object_set_prop_object(tk_object_t* obj, const char* name, tk_object_t* value) {\n  value_t v;\n  value_set_object(&v, value);\n\n  return tk_object_set_prop(obj, name, &v);\n}\n\nret_t tk_object_set_prop_int(tk_object_t* obj, const char* name, int32_t value) {\n  value_t v;\n  value_set_int(&v, value);\n\n  return tk_object_set_prop(obj, name, &v);\n}\n\nret_t tk_object_set_prop_bool(tk_object_t* obj, const char* name, bool_t value) {\n  value_t v;\n  value_set_bool(&v, value);\n\n  return tk_object_set_prop(obj, name, &v);\n}\n\nret_t tk_object_set_prop_float(tk_object_t* obj, const char* name, float_t value) {\n  value_t v;\n  value_set_float(&v, value);\n\n  return tk_object_set_prop(obj, name, &v);\n}\n\nret_t tk_object_set_prop_double(tk_object_t* obj, const char* name, double value) {\n  value_t v;\n  value_set_double(&v, value);\n\n  return tk_object_set_prop(obj, name, &v);\n}\n\nret_t tk_object_remove_prop(tk_object_t* obj, const char* name) {\n  ret_t ret = RET_NOT_FOUND;\n  return_value_if_fail(name != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(obj != NULL && obj->vt != NULL && obj->ref_count >= 0, RET_BAD_PARAMS);\n  return_value_if_fail(!(obj->visiting), RET_BUSY);\n\n  if (obj->vt->remove_prop != NULL) {\n    ret = obj->vt->remove_prop(obj, name);\n  }\n\n  return ret;\n}\n\nret_t tk_object_foreach_prop(tk_object_t* obj, tk_visit_t on_prop, void* ctx) {\n  ret_t ret = RET_NOT_IMPL;\n  return_value_if_fail(on_prop != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(obj != NULL && obj->vt != NULL && obj->ref_count >= 0, RET_BAD_PARAMS);\n  return_value_if_fail(!(obj->visiting), RET_BUSY);\n\n  if (obj->vt->foreach_prop != NULL) {\n    obj->visiting = TRUE;\n    ret = obj->vt->foreach_prop(obj, on_prop, ctx);\n    obj->visiting = FALSE;\n  }\n\n  return ret;\n}\n\nint tk_object_compare(tk_object_t* obj, tk_object_t* other) {\n  int32_t ret = -1;\n  return_value_if_fail(obj != NULL && obj->vt != NULL && obj->ref_count >= 0, -1);\n  return_value_if_fail(other != NULL && other->vt != NULL && other->ref_count >= 0, -1);\n\n  if (obj->vt->compare != NULL) {\n    ret = obj->vt->compare(obj, other);\n  }\n\n  return ret;\n}\n\nbool_t tk_object_can_exec(tk_object_t* obj, const char* name, const char* args) {\n  bool_t ret = FALSE;\n  cmd_exec_event_t e;\n  return_value_if_fail(name != NULL, FALSE);\n  return_value_if_fail(obj != NULL && obj->vt != NULL && obj->ref_count >= 0, FALSE);\n\n  if (emitter_dispatch(EMITTER(obj), cmd_exec_event_init(&e, EVT_CMD_CAN_EXEC, name, args)) !=\n      RET_OK) {\n    return e.can_exec;\n  }\n\n  if (obj->vt->can_exec != NULL) {\n    ret = obj->vt->can_exec(obj, name, args);\n  }\n\n  return ret;\n}\n\nret_t tk_object_exec(tk_object_t* obj, const char* name, const char* args) {\n  cmd_exec_event_t e;\n  event_t* evt = NULL;\n  ret_t ret = RET_NOT_IMPL;\n  return_value_if_fail(name != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(obj != NULL && obj->vt != NULL && obj->ref_count >= 0, RET_BAD_PARAMS);\n\n  if (emitter_dispatch(EMITTER(obj), cmd_exec_event_init(&e, EVT_CMD_WILL_EXEC, name, args)) !=\n      RET_OK) {\n    return RET_FAIL;\n  }\n\n  if (obj->vt->exec != NULL) {\n    ret = obj->vt->exec(obj, name, args);\n  }\n\n  evt = cmd_exec_event_init(&e, EVT_CMD_EXECED, name, args);\n  e.result = ret;\n  emitter_dispatch(EMITTER(obj), evt);\n\n  return e.result;\n}\n\nbool_t tk_object_has_prop(tk_object_t* obj, const char* name) {\n  value_t v;\n  ret_t ret = RET_OK;\n\n  ret = tk_object_get_prop(obj, name, &v);\n  if (ret == RET_OK) {\n    value_reset(&v);\n  }\n\n  return ret == RET_OK;\n}\n\nret_t tk_object_copy_prop(tk_object_t* obj, tk_object_t* src, const char* name) {\n  value_t v;\n  ret_t ret = RET_FAIL;\n  return_value_if_fail(name != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(obj != NULL && obj->vt != NULL && obj->ref_count >= 0, RET_BAD_PARAMS);\n  return_value_if_fail(src != NULL && src->vt != NULL && src->ref_count >= 0, RET_BAD_PARAMS);\n\n  if (tk_object_get_prop(src, name, &v) == RET_OK) {\n    ret = tk_object_set_prop(obj, name, &v);\n    value_reset(&v);\n  }\n\n  return ret;\n}\n\ntypedef struct _copy_ctx_t {\n  bool_t overwrite;\n  tk_object_t* dst;\n} copy_ctx_t;\n\nstatic ret_t on_copy_on_prop(void* ctx, const void* data) {\n  named_value_t* nv = (named_value_t*)data;\n  copy_ctx_t* info = (copy_ctx_t*)ctx;\n\n  if (info->overwrite) {\n    tk_object_set_prop(info->dst, nv->name, &(nv->value));\n  } else {\n    value_t v;\n    if (tk_object_get_prop(info->dst, nv->name, &v) != RET_OK) {\n      tk_object_set_prop(info->dst, nv->name, &(nv->value));\n    }\n  }\n  return RET_OK;\n}\n\nret_t tk_object_copy_props(tk_object_t* obj, tk_object_t* src, bool_t overwrite) {\n  copy_ctx_t ctx = {overwrite, obj};\n  return_value_if_fail(obj != NULL && src != NULL, RET_BAD_PARAMS);\n\n  return tk_object_foreach_prop(src, on_copy_on_prop, &ctx);\n}\n\n#ifndef WITHOUT_FSCRIPT\nret_t tk_object_eval(tk_object_t* obj, const char* expr, value_t* v) {\n  return fscript_eval(obj, expr, v);\n}\n#else\nret_t tk_object_eval(tk_object_t* obj, const char* expr, value_t* v) {\n  return_value_if_fail(expr != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(obj != NULL && obj->vt != NULL && obj->ref_count >= 0, RET_BAD_PARAMS);\n\n  if (tk_is_valid_name(expr)) {\n    return tk_object_get_prop(obj, expr, v);\n  } else {\n    return RET_FAIL;\n  }\n}\n#endif /*WITHOUT_FSCRIPT*/\n\nconst char* tk_object_get_type(tk_object_t* obj) {\n  return_value_if_fail(obj != NULL && obj->vt != NULL, NULL);\n\n  return obj->vt->type;\n}\n\nconst char* tk_object_get_desc(tk_object_t* obj) {\n  return_value_if_fail(obj != NULL && obj->vt != NULL, NULL);\n\n  return obj->vt->desc;\n}\n\nbool_t tk_object_is_collection(tk_object_t* obj) {\n  return_value_if_fail(obj != NULL && obj->vt != NULL, FALSE);\n\n  return obj->vt->is_collection;\n}\n\nuint32_t tk_object_get_size(tk_object_t* obj) {\n  return_value_if_fail(obj != NULL && obj->vt != NULL, 0);\n\n  return obj->vt->size;\n}\n\nbool_t tk_object_has_prop_by_path(tk_object_t* obj, const char* path) {\n  value_t v;\n  ret_t ret = RET_OK;\n\nret = ",
    "raw_res": "object_get_prop_by_path_with_len(obj, path, strlen(path), &v);",
    "prompt_res": "tk_object_get_prop_by_path(obj, path, &v);",
    "gt": "tk_object_get_prop_by_path(obj, path, &v);"
  },
  {
    "id": 800,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/fscript.c",
    "input": "﻿/**\n * File:   fscript.c\n * Author: AWTK Develop Team\n * Brief:  a simple script language\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2020-11-09 Li XianJing <lixianjing@zlg.cn> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/darray.h\"\n#include \"tkc/fscript.h\"\n#include \"tkc/object_default.h\"\n#include \"tkc/general_factory.h\"\n#include \"tkc/object_locker.h\"\n\n#ifndef WITHOUT_FSCRIPT\n#define value_id_index(v) (v)->value.id.index\n#define value_id_suboffset(v) (v)->value.id.suboffset\n\nstatic const fscript_hooks_t* s_hooks;\n\nret_t fscript_set_hooks(const fscript_hooks_t* hooks) {\n  s_hooks = hooks;\n  return RET_OK;\n}\n\nstatic ret_t func_function_def(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_if(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_while(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_until(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_repeat_times(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_repeat(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_for(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_for_in(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_noop(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_pending(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_return(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  if (args->size > 0) {\n    value_deep_copy(result, args->args);\n  }\n  fscript->returned = TRUE;\n  return RET_OK;\n}\nstatic ret_t func_get(fscript_t* fscript, fscript_args_t* args, value_t* result);\nstatic ret_t func_set(fscript_t* fscript, fscript_args_t* args, value_t* result);\nstatic ret_t func_unset(fscript_t* fscript, fscript_args_t* args, value_t* result);\nstatic ret_t func_set_local(fscript_t* fscript, fscript_args_t* args, value_t* result);\nstatic ret_t fscript_func_call_init_func(fscript_func_call_t* call, tk_object_t* obj,\n                                         tk_object_t* funcs_def, const char* name, uint32_t size);\n\nret_t fscript_ensure_locals(fscript_t* fscript) {\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n\n  if (fscript->locals == NULL) {\n    fscript->locals = darray_create(5, (tk_destroy_t)named_value_destroy,\n                                    (tk_compare_t)named_value_compare_by_name);\n  }\n\n  return fscript->locals != NULL ? RET_OK : RET_FAIL;\n}\n\nstatic ret_t fscript_locals_remove(fscript_t* fscript, uint32_t index) {\n  named_value_t* nv = (named_value_t*)(fscript->locals->elms[index]);\n  return value_reset(&(nv->value));\n}\n\nstatic tk_object_t* fscript_locals_get_object(fscript_t* fscript, const char* name) {\n  named_value_t* nv = (named_value_t*)darray_find(fscript->locals, (void*)name);\n\n  return nv != NULL ? value_object(&(nv->value)) : NULL;\n}\n\nstatic ret_t fscript_locals_get(fscript_t* fscript, const value_t* name, value_t* v) {\n  int32_t index = value_id_index(name);\n  int32_t suboffset = value_id_suboffset(name);\n  named_value_t* nv = (named_value_t*)(fscript->locals->elms[index]);\n  if (!suboffset) {\n    return value_copy(v, &(nv->value));\n  } else {\n    tk_object_t* obj = value_object(&(nv->value));\n    const char* subname = value_id(name) + suboffset;\n    return_value_if_fail(obj != NULL, RET_BAD_PARAMS);\n\n    return tk_object_get_prop(obj, subname, v);\n  }\n}\n\nstatic ret_t fscript_locals_set_with_index(fscript_t* fscript, uint32_t index, const value_t* v) {\n  named_value_t* nv = (named_value_t*)(fscript->locals->elms[index]);\n  if (nv->value.free_handle) {\n    value_reset(&(nv->value));\n  }\n  return value_deep_copy(&(nv->value), v);\n}\n\nstatic ret_t fscript_locals_set(fscript_t* fscript, const value_t* name, value_t* v) {\n  int32_t index = value_id_index(name);\n  int32_t suboffset = value_id_suboffset(name);\n  named_value_t* nv = (named_value_t*)(fscript->locals->elms[index]);\n  if (!suboffset) {\n    return fscript_locals_set_with_index(fscript, index, v);\n  } else {\n    tk_object_t* obj = value_object(&(nv->value));\n    const char* subname = value_id(name) + suboffset;\n    return_value_if_fail(obj != NULL, RET_BAD_PARAMS);\n\n    return tk_object_set_prop(obj, subname, v);\n  }\n}\n\nstatic ret_t fscript_locals_create(fscript_t* fscript, const char* name, const value_t* v) {\n  int32_t index = 0;\n  named_value_t* nv = NULL;\n  return_value_if_fail(fscript_ensure_locals(fscript) == RET_OK, RET_BAD_PARAMS);\n  index = darray_find_index(fscript->locals, (void*)name);\n\n  if (index >= 0) {\n    fscript_set_error(fscript, RET_FAIL, \"<>\", \"duplicated var name.\");\n    return fscript_locals_set_with_index(fscript, index, v);\n  }\n\n  nv = named_value_create_ex(name, v);\n  return_value_if_fail(nv != NULL, RET_BAD_PARAMS);\n\n  if (darray_push_unique(fscript->locals, nv) != RET_OK) {\n    named_value_destroy(nv);\n    return RET_FAIL;\n  }\n  return RET_OK;\n}\n\nstatic ret_t fscript_locals_destroy(fscript_t* fscript) {\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n  if (fscript->locals != NULL) {\n    darray_destroy(fscript->locals);\n    fscript->locals = NULL;\n  }\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_func(fscript_t* fscript, const char* name, fscript_func_call_t* iter,\n                               value_t* result) {\n  if (s_hooks != NULL && s_hooks->exec_func != NULL) {\n    return s_hooks->exec_func(fscript, name, iter, result);\n  } else {\n    return fscript_exec_func_default(fscript, iter, result);\n  }\n}\n\nret_t fscript_set_error(fscript_t* fscript, ret_t code, const char* func, const char* message) {\n  fscript->error_code = code;\n  fscript->error_func = fscript->curr;\n  fscript->error_row = fscript->curr->row;\n  fscript->error_col = fscript->curr->col;\n  fscript->error_message = tk_str_copy(fscript->error_message, message);\n  if (code != RET_OK) {\n    log_debug(\"(%d:%d): %s code=%d %s\\n\", fscript->curr->row, fscript->curr->col, func, code,\n              message);\n  }\n\n  if (fscript->on_error != NULL) {\n    fscript->on_error(fscript->on_error_ctx, fscript);\n  }\n\n  return RET_OK;\n}\n\nret_t fscript_set_on_error(fscript_t* fscript, fscript_on_error_t on_error, void* ctx) {\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n  fscript->on_error = on_error;\n  fscript->on_error_ctx = ctx;\n\n  return RET_OK;\n}\n\nret_t fscript_set_print_func(fscript_t* fscript, fscript_func_t print) {\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n\n  fscript->print = print;\n\n  return RET_OK;\n}\n\nstatic bool_t value_is_digit(value_t* v) {\n  uint32_t type = 0;\n  bool_t ret = TRUE;\n  return_value_if_fail(v != NULL, FALSE);\n\n  type = v->type;\n  if (type == VALUE_TYPE_INVALID || type == VALUE_TYPE_POINTER || type == VALUE_TYPE_STRING ||\n      type == VALUE_TYPE_WSTRING || type == VALUE_TYPE_OBJECT || type == VALUE_TYPE_SIZED_STRING ||\n      type == VALUE_TYPE_BINARY || type == VALUE_TYPE_UBJSON) {\n    ret = FALSE;\n  }\n\n  return ret;\n}\n\nstatic ret_t func_args_extend(fscript_args_t* args) {\n  if (args->size < args->capacity) {\n    return RET_OK;\n  }\n\n  if (args->capacity < FSCRIPT_MAX_ARGS) {\n    value_t* new_args = NULL;\n    uint16_t capacity = args->capacity + 2;\n    capacity = tk_min(capacity, FSCRIPT_MAX_ARGS);\n    new_args = TKMEM_REALLOC(args->args, capacity * sizeof(value_t));\n    return_value_if_fail(new_args != NULL, RET_OOM);\n    args->args = new_args;\n    args->capacity = capacity;\n    return RET_OK;\n  }\n\n  return RET_FAIL;\n}\n\nstatic ret_t func_args_push(fscript_args_t* args, value_t* v) {\n  return_value_if_fail(v != NULL && func_args_extend(args) == RET_OK, RET_BAD_PARAMS);\n  args->args[args->size++] = *v;\n  v->free_handle = FALSE;\n  value_reset(v);\n\n  return RET_OK;\n}\n\nstatic ret_t func_args_init(fscript_args_t* args, uint16_t init_args_capacity) {\n  memset(args, 0x00, sizeof(fscript_args_t));\n  if (init_args_capacity > 0) {\n    args->args = TKMEM_ZALLOCN(value_t, init_args_capacity);\n    return_value_if_fail(args->args != NULL, RET_OOM);\n    args->capacity = init_args_capacity;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_func_call_destroy(fscript_func_call_t* call);\n\nstatic ret_t func_args_reset(fscript_args_t* args) {\n  uint32_t i = 0;\n  for (i = 0; i < args->size; i++) {\n    value_t* v = args->args + i;\n    if (v->type == VALUE_TYPE_FSCRIPT_FUNC) {\n      fscript_func_call_destroy(value_func(v));\n    }\n    value_reset(args->args + i);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_args_deinit(fscript_args_t* args) {\n  func_args_reset(args);\n  TKMEM_FREE(args->args);\n  memset(args, 0x00, sizeof(fscript_args_t));\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_func_call_destroy(fscript_func_call_t* call) {\n  fscript_func_call_t* iter = call;\n  fscript_func_call_t* next = NULL;\n\n  while (iter != NULL) {\n    if (iter->func == func_pending) {\n      TKMEM_FREE(iter->ctx);\n    }\n    next = iter->next;\n    func_args_deinit(&(iter->args));\n    TKMEM_FREE(iter);\n    iter = next;\n  }\n\n  return RET_OK;\n}\n\nstatic fscript_function_def_t* fscript_function_def_create(const char* name,\n                                                           fscript_func_call_t* body) {\n  fscript_function_def_t* func = TKMEM_ZALLOC(fscript_function_def_t);\n  return_value_if_fail(func != NULL, NULL);\n  func->body = body;\n  func->name = tk_strdup(name);\n\n  darray_init(&(func->params), 3, default_destroy, NULL);\n  return func;\n}\n\nstatic ret_t fscript_function_def_destroy(fscript_function_def_t* func) {\n  return_value_if_fail(func != NULL, RET_BAD_PARAMS);\n  darray_deinit(&(func->params));\n  fscript_func_call_destroy(func->body);\n  TKMEM_FREE(func->name);\n  memset(func, 0x00, sizeof(fscript_function_def_t));\n  TKMEM_FREE(func);\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_function_def_add_param(fscript_function_def_t* func, const char* name) {\n  return_value_if_fail(func != NULL, RET_BAD_PARAMS);\n  return darray_push(&(func->params), tk_strdup(name));\n}\n\ntypedef enum _token_type_t {\n  TOKEN_ID = 1,\n  TOKEN_VAR,\n  TOKEN_FUNC,\n  TOKEN_RETURN,\n  TOKEN_FUNC_DEF,\n  TOKEN_STR,\n  TOKEN_NUMBER,\n  TOKEN_LPAREN,\n  TOKEN_RPAREN,\n  TOKEN_LBRACKET,\n  TOKEN_RBRACKET,\n  TOKEN_COMMA,\n  TOKEN_SEMICOLON,\n  /*for expr*/\n  TOKEN_QUESTION,\n  TOKEN_COLON,\n  TOKEN_EOF\n} token_type_t;\n\ntypedef struct _token_t {\n  const char* token;\n  token_type_t type;\n  uint32_t size;\n  bool_t valid;\n} token_t;\n\ntypedef struct _fscript_parser_t {\n  tk_object_t* obj;\n  token_t token;\n  char* code_id;\n  const char* str;\n  const char* cursor;\n\n  char c;\n  str_t temp;\n  uint16_t row;\n  uint16_t col;\n  tk_object_t* funcs_def;\n  fscript_func_call_t* first;\n  fscript_parser_error_t* error;\n  bool_t keep_func_name;\n  darray_t* symbols;\n} fscript_parser_t;\n\nstatic ret_t fexpr_parse(fscript_parser_t* parser, value_t* result);\nstatic ret_t fscript_parse_statements(fscript_parser_t* parser, fscript_func_call_t* acall);\nstatic fscript_func_call_t* fscript_func_call_create(fscript_parser_t* parser, const char* name,\n                                                     uint32_t size);\nstatic ret_t fscript_get_var(fscript_t* fscript, const char* name, value_t* value) {\n  value_set_str(value, NULL);\n  return_value_if_fail(name != NULL, RET_BAD_PARAMS);\n  if (*name == '$') {\n    name += 1;\n  }\n\n  if (strncmp(name, FSCRIPT_STR_GLOBAL_PREFIX, FSCRIPT_GLOBAL_PREFIX_LEN) == 0) {\n    return tk_object_get_prop(fscript_get_global_object(), name + FSCRIPT_GLOBAL_PREFIX_LEN, value);\n  }\n\n  return tk_object_get_prop(fscript->obj, name, value);\n}\n\nret_t fscript_set_var_default(fscript_t* fscript, const char* name, const value_t* value) {\n  if (strncmp(name, FSCRIPT_STR_GLOBAL_PREFIX, FSCRIPT_GLOBAL_PREFIX_LEN) == 0) {\n    return tk_object_set_prop(fscript_get_global_object(), name + FSCRIPT_GLOBAL_PREFIX_LEN, value);\n  }\n\n  return tk_object_set_prop(fscript->obj, name, value);\n}\n\nret_t fscript_set_var(fscript_t* fscript, const char* name, const value_t* value) {\n  if (s_hooks != NULL && s_hooks->set_var != NULL) {\n    return s_hooks->set_var(fscript, name, value);\n  } else {\n    return fscript_set_var_default(fscript, name, value);\n  }\n}\n\nstatic ret_t fscript_eval_arg(fscript_t* fscript, fscript_func_call_t* iter, uint32_t i,\n                              value_t* d) {\n  value_t v;\n  value_t* s = iter->args.args + i;\n  value_set_str(&v, NULL);\n  value_set_str(d, NULL);\n  if (s->type == VALUE_TYPE_FSCRIPT_ID) {\n    if ((iter->func == func_set_local || iter->func == func_set || iter->func == func_unset ||\n         iter->func == func_get) &&\n        i == 0) {\n      value_copy(d, s); /*func_set accept id/str as first param*/\n    } else {\n      const char* name = value_id(s);\n      if (value_id_index(s) >= 0) {\n        return fscript_locals_get(fscript, s, d);\n      }\n\n      if (fscript->loop_count > 0) {\n        if (tk_str_eq(name, \"break\")) {\n          fscript->breaked = TRUE;\n          return RET_OK;\n        } else if (tk_str_eq(name, \"continue\")) {\n          fscript->continued = TRUE;\n          return RET_OK;\n        }\n      } else if (tk_str_eq(name, \"return\")) {\n        fscript->returned = TRUE;\n        value_set_int(d, 0);\n        return RET_OK;\n      } else if (*name == '.') {\n        value_copy(d, s);\n        return RET_OK;\n      }\n\n      if (fscript_get_var(fscript, name, d) != RET_OK) {\n        if (name == NULL || *name != '$') {\n          char msg[128];\n          tk_snprintf(msg, sizeof(msg) - 1, \"not found var %s\", name);\n          fscript_set_error(fscript, RET_NOT_FOUND, \"get_var\", msg);\n          value_set_str(d, value_id(s));\n        } else if (*name == '$') {\n          value_reset(d);\n        }\n      }\n    }\n  } else if (s->type == VALUE_TYPE_FSCRIPT_FUNC) {\n    fscript_exec_func(fscript, NULL, value_func(s), d);\n  } else {\n    value_copy(d, s);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_if(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  uint32_t i = 0;\n  uint32_t n = 0;\n  value_t condition;\n  return_value_if_fail(iter->args.size >= 2, RET_FAIL);\n\n  n = iter->args.size / 2;\n  for (i = 0; i < n; i++) {\n    value_set_bool(&condition, FALSE);\n    return_value_if_fail(fscript_eval_arg(fscript, iter, 2 * i, &condition) == RET_OK, RET_FAIL);\n    if (value_bool(&condition)) {\n      return fscript_eval_arg(fscript, iter, 2 * i + 1, result);\n    }\n  }\n\n  if ((2 * i) < iter->args.size) {\n    return fscript_eval_arg(fscript, iter, 2 * i, result);\n  } else {\n    value_set_int(result, 0);\n    return RET_OK;\n  }\n}\n\nstatic ret_t fscript_exec_loop_body(fscript_t* fscript, fscript_func_call_t* iter, uint32_t start,\n                                    value_t* result, bool_t* done) {\n  uint32_t i = 1;\n  for (i = start; i < iter->args.size; i++) {\n    value_reset(result);\n    fscript_eval_arg(fscript, iter, i, result);\n    if (fscript->breaked) {\n      *done = TRUE;\n      fscript->breaked = FALSE;\n      break;\n    } else if (fscript->returned) {\n      *done = TRUE;\n    } else if (fscript->continued) {\n      fscript->continued = FALSE;\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_while_or_until(fscript_t* fscript, fscript_func_call_t* iter,\n                                         value_t* result, bool_t is_while) {\n  value_t condition;\n  bool_t done = FALSE;\n  FSCRIPT_FUNC_CHECK(iter->args.size > 1, RET_FAIL);\n\n  fscript->loop_count++;\n  value_set_int(&condition, 0);\n  while (!done && fscript_eval_arg(fscript, iter, 0, &condition) == RET_OK) {\n    if (is_while ? !value_bool(&condition) : value_bool(&condition)) {\n      break;\n    }\n    fscript_exec_loop_body(fscript, iter, 1, result, &done);\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\n\n/*repeat(a, 0, 100, 1) {*/\nstatic ret_t fscript_exec_repeat(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  value_t v;\n  int32_t start = 0;\n  int32_t end = 0;\n  int32_t delta = 0;\n  bool_t done = FALSE;\n  value_t* var = iter->args.args;\n  int32_t index = value_id_index(var);\n  const char* name = value_id(iter->args.args);\n  FSCRIPT_FUNC_CHECK(iter->args.size > 4, RET_FAIL);\n\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 1, &v) == RET_OK, RET_BAD_PARAMS);\n  start = value_int(&v);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 2, &v) == RET_OK, RET_BAD_PARAMS);\n  end = value_int(&v);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 3, &v) == RET_OK, RET_BAD_PARAMS);\n  delta = value_int(&v);\n\n  fscript->loop_count++;\n  while ((start != end) && !done) {\n    value_set_int(&v, start);\n    if (index >= 0) {\n      break_if_fail(fscript_locals_set(fscript, var, &v) == RET_OK);\n    } else {\n      break_if_fail(fscript_set_var(fscript, name, &v) == RET_OK);\n    }\n    fscript_exec_loop_body(fscript, iter, 4, result, &done);\n    start += delta;\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_for(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  value_t v;\n  bool_t done = FALSE;\n  FSCRIPT_FUNC_CHECK(iter->args.size > 3, RET_FAIL);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 0, &v) == RET_OK, RET_BAD_PARAMS);\n\n  fscript->loop_count++;\n  while (!done) {\n    break_if_fail(fscript_eval_arg(fscript, iter, 1, &v) == RET_OK);\n    if (!value_bool(&v)) {\n      break;\n    }\n    fscript_exec_loop_body(fscript, iter, 3, result, &done);\n    break_if_fail(fscript_eval_arg(fscript, iter, 2, &v) == RET_OK);\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_for_in(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  value_t v;\n  char prop[32];\n  uint32_t i = 0;\n  uint32_t n = 0;\n  bool_t done = FALSE;\n  object_t* obj = NULL;\n  value_t* var = iter->args.args;\n  int32_t index = value_id_index(var);\n  const char* name = value_id(var);\n\n  FSCRIPT_FUNC_CHECK(iter->args.size > 2, RET_FAIL);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 1, &v) == RET_OK, RET_BAD_PARAMS);\n  obj = value_object(&v);\n  FSCRIPT_FUNC_CHECK(obj != NULL, RET_FAIL);\n\n  fscript->loop_count++;\n  n = tk_object_get_prop_int(obj, TK_OBJECT_PROP_SIZE, 0);\n  for (i = 0; ((i < n) && !done); i++) {\n    tk_snprintf(prop, sizeof(prop) - 1, \"[%u]\", i);\n    break_if_fail(tk_object_get_prop(obj, prop, &v) == RET_OK);\n\n    if (index >= 0) {\n      fscript_locals_set(fscript, var, &v);\n    } else {\n      fscript_set_var(fscript, name, &v);\n    }\n    fscript_exec_loop_body(fscript, iter, 2, result, &done);\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_repeat_times(fscript_t* fscript, fscript_func_call_t* iter,\n                                       value_t* result) {\n  value_t v;\n  uint32_t i = 0;\n  uint32_t n = 0;\n  bool_t done = FALSE;\n  FSCRIPT_FUNC_CHECK(iter->args.size > 1, RET_FAIL);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 0, &v) == RET_OK, RET_BAD_PARAMS);\n\n  n = value_int(&v);\n  fscript->loop_count++;\n  for (i = 0; i < n && !done; i++) {\n    fscript_exec_loop_body(fscript, iter, 1, result, &done);\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\nstatic ret_t fscript_exec_while(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  return fscript_exec_while_or_until(fscript, iter, result, TRUE);\n}\n\nstatic ret_t fscript_exec_until(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  return fscript_exec_while_or_until(fscript, iter, result, FALSE);\n}\n\nstatic ret_t fscript_exec_core_func(fscript_t* fscript, fscript_func_call_t* iter,\n                                    value_t* result) {\n  if (iter->func == func_if) {\n    return fscript_exec_if(fscript, iter, result);\n  } else if (iter->func == func_while) {\n    return fscript_exec_while(fscript, iter, result);\n  } else if (iter->func == func_until) {\n    return fscript_exec_until(fscript, iter, result);\n  } else if (iter->func == func_repeat) {\n    return fscript_exec_repeat(fscript, iter, result);\n  } else if (iter->func == func_for) {\n    return fscript_exec_for(fscript, iter, result);\n  } else if (iter->func == func_for_in) {\n    return fscript_exec_for_in(fscript, iter, result);\n  } else if (iter->func == func_repeat_times) {\n    return fscript_exec_repeat_times(fscript, iter, result);\n  } else if (iter->func == func_function_def) {\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t fscript_exec_ext_func(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  value_t v;\n  uint32_t i = 0;\n  ret_t ret = RET_OK;\n  fscript_args_t args;\n  value_t args_values[5];\n\n  value_set_int(&v, 0);\n  if (iter->args.size <= ARRAY_SIZE(args_values)) {\n    memset(&args, 0x00, sizeof(args));\n    memset(&args_values, 0x00, sizeof(args_values));\n    args.capacity = ARRAY_SIZE(args_values);\n    args.args = args_values;\n  } else {\n    func_args_init(&args, iter->args.size);\n  }\n  args.size = iter->args.size;\n\n  return_value_if_fail((args.args != NULL || args.size == 0), RET_OOM);\n  for (i = 0; i < iter->args.size; i++) {\n    ret = fscript_eval_arg(fscript, iter, i, args.args + i);\n    if (fscript->breaked || fscript->continued || fscript->returned) {\n      value_deep_copy(result, args.args + i);\n      if (iter->args.size <= ARRAY_SIZE(args_values)) {\n        func_args_reset(&args);\n      } else {\n        func_args_deinit(&args);\n      }\n      return RET_OK;\n    }\n  }\n\n  value_set_int(result, 0);\n  fscript->curr = iter;\n  ret = iter->func(fscript, &args, result);\n\n  if (iter->args.size <= ARRAY_SIZE(args_values)) {\n    func_args_reset(&args);\n  } else {\n    func_args_deinit(&args);\n  }\n\n  return ret;\n}\n\nret_t fscript_exec_func_default(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  fscript->curr = iter;\n  result->type = VALUE_TYPE_INVALID;\n\n  if (iter->func == func_pending && iter->ctx != NULL) {\n    tk_object_t* obj = NULL;\n    void* ctx = iter->ctx;\n    char* name = (char*)(iter->ctx);\n    char* p = strchr(name, '.');\n    iter->ctx = NULL;\n\n    if (p != NULL) {\n      *p = '\\0';\n      obj = fscript_locals_get_object(fscript, name);\n      name = p + 1;\n    }\n    obj = obj != NULL ? obj : fscript->obj;\n    fscript_func_call_init_func(iter, obj, fscript->funcs_def, name, tk_strlen(name));\n\n    if (iter->func == func_noop) {\n      log_warn(\"not found func %s\\n\", name);\n    }\n    TKMEM_FREE(ctx);\n  }\n\n  if (fscript_exec_core_func(fscript, iter, result) == RET_NOT_FOUND) {\n    return_value_if_fail(fscript_exec_ext_func(fscript, iter, result) == RET_OK, RET_FAIL);\n  }\n\n  return RET_OK;\n}\n\nret_t fscript_exec(fscript_t* fscript, value_t* result) {\n  fscript_func_call_t* iter = NULL;\n  return_value_if_fail(fscript != NULL, RET_FAIL);\n\n  if (s_hooks != NULL && s_hooks->before_exec != NULL) {\n    s_hooks->before_exec(fscript);\n  }\n\n  value_set_str(result, NULL);\n  iter = fscript->first;\n  while (iter != NULL) {\n    break_if_fail(iter->func != NULL);\n    value_reset(result);\n    break_if_fail(fscript_exec_func(fscript, NULL, iter, result) == RET_OK);\n    if (fscript->returned) {\n      fscript->returned = FALSE;\n      break;\n    }\n    iter = iter->next;\n  }\n\n  if (s_hooks != NULL && s_hooks->after_exec != NULL) {\n    s_hooks->after_exec(fscript);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t on_free_func_def(void* ctx, const void* data) {\n  named_value_t* iter = (named_value_t*)(data);\n  fscript_function_def_destroy(value_func_def(&(iter->value)));\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_reset(fscript_t* fscript) {\n  return_value_if_fail(fscript != NULL, RET_FAIL);\n\n  if (s_hooks != NULL && s_hooks->on_deinit != NULL) {\n    s_hooks->on_deinit(fscript);\n  }\n\n  str_reset(&(fscript->str));\n  fscript_locals_destroy(fscript);\n  if (fscript->funcs_def != NULL) {\n    tk_object_foreach_prop(fscript->funcs_def, on_free_func_def, NULL);\n  }\n  TK_OBJECT_UNREF(fscript->funcs_def);\n  TKMEM_FREE(fscript->error_message);\n  fscript_func_call_destroy(fscript->first);\n  TKMEM_FREE(fscript->code_id);\n  memset(fscript, 0x00, sizeof(fscript_t));\n\n  return RET_OK;\n}\n\nret_t fscript_deinit(fscript_t* fscript) {\n  return fscript_reset(fscript);\n}\n\nret_t fscript_destroy(fscript_t* fscript) {\n  return_value_if_fail(fscript != NULL, RET_FAIL);\n  fscript_deinit(fscript);\n\n  TKMEM_FREE(fscript);\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_init(fscript_parser_t* parser, tk_object_t* obj, const char* str,\n                                 fscript_parser_error_t* error) {\n  memset(parser, 0x00, sizeof(fscript_parser_t));\n\n  parser->obj = obj;\n  parser->str = str;\n  parser->cursor = str;\n  parser->error = error;\n  parser->symbols = darray_create(5, NULL, (tk_compare_t)tk_str_cmp);\n\n  str_init(&(parser->temp), 64);\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_deinit(fscript_parser_t* parser) {\n  str_reset(&(parser->temp));\n  TKMEM_FREE(parser->code_id);\n  darray_destroy(parser->symbols);\n  fscript_func_call_destroy(parser->first);\n  if (parser->funcs_def != NULL) {\n    tk_object_foreach_prop(parser->funcs_def, on_free_func_def, NULL);\n  }\n  TK_OBJECT_UNREF(parser->funcs_def);\n\n  return RET_OK;\n}\n\nstatic char fscript_parser_get_char(fscript_parser_t* parser) {\n  char c = '\\0';\n  return_value_if_fail(parser != NULL, c);\n  if (parser->c) {\n    c = parser->c;\n    parser->c = '\\0';\n    return c;\n  }\n\n  c = parser->cursor[0];\n  if (c) {\n    if (c == '\\n') {\n      parser->row++;\n      parser->col = 0;\n    } else {\n      parser->col++;\n    }\n\n    parser->cursor++;\n  }\n\n  return c;\n}\n\nstatic ret_t fscript_parser_unget_char(fscript_parser_t* parser, char c) {\n  return_value_if_fail(parser->cursor > parser->str, RET_BAD_PARAMS);\n  parser->c = c;\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_set_error(fscript_parser_t* parser, const char* str) {\n  return_value_if_fail(parser != NULL && str != NULL, RET_BAD_PARAMS);\n\n  if (parser->error != NULL) {\n    parser->error->row = parser->row;\n    parser->error->col = parser->col;\n    parser->error->offset = parser->cursor - parser->str;\n    parser->error->message = tk_str_copy(parser->error->message, str);\n    parser->error->token = tk_str_copy(parser->error->token, parser->token.token);\n  }\n\n  log_warn(\"code: \\\"%s\\\"\\n\", parser->str);\n  log_warn(\"token: \\\"%s\\\"\\n\", parser->token.token);\n  log_warn(\"at line(%u) col (%u): %s\\n\", parser->row, parser->col, str);\n\n  return RET_FAIL;\n}\n\nstatic ret_t fscript_parser_skip_seperators(fscript_parser_t* parser) {\n  char c = '\\0';\n  do {\n    c = fscript_parser_get_char(parser);\n  } while (tk_isspace(c));\n  fscript_parser_unget_char(parser, c);\n\n  return RET_OK;\n}\n\n#define STR_CODE_ID_START \"code_id(\\\"\"\n#define STR_CODE_ID_END \"\\\")\"\n\nstatic ret_t fscript_parser_skip_line_comment(fscript_parser_t* parser) {\n  char c = '\\0';\n  str_t* str = &(parser->temp);\n  str_clear(str);\n  do {\n    c = fscript_parser_get_char(parser);\n    str_append_char(str, c);\n  } while (c != '\\0' && c != '\\r' && c != '\\n');\n\n  if (str->size > sizeof(STR_CODE_ID_START)) {\n    const char* end = NULL;\n    const char* start = strstr(str->str, STR_CODE_ID_START);\n    if (start != NULL) {\n      start += strlen(STR_CODE_ID_START);\n      end = strstr(start, STR_CODE_ID_END);\n      if (end != NULL) {\n        TKMEM_FREE(parser->code_id);\n        parser->code_id = tk_strndup(start, end - start);\n        log_debug(\"code_id:%s\\n\", parser->code_id);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_skip_block_comment(fscript_parser_t* parser) {\n  char c = '\\0';\n  do {\n    c = fscript_parser_get_char(parser);\n    if (c == '*' && parser->cursor[0] == '/') {\n      c = fscript_parser_get_char(parser);\n      break;\n    }\n  } while (c != '\\0');\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_skip_seperators_and_comments(fscript_parser_t* parser) {\n  char c = '\\0';\n\n  while (TRUE) {\n    fscript_parser_skip_seperators(parser);\n    c = fscript_parser_get_char(parser);\n    if (c == '/') {\n      if (parser->cursor[0] == '/') {\n        c = fscript_parser_get_char(parser);\n        fscript_parser_skip_line_comment(parser);\n      } else if (parser->cursor[0] == '*') {\n        c = fscript_parser_get_char(parser);\n        fscript_parser_skip_block_comment(parser);\n      } else {\n        break;\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (c) {\n    parser->cursor--;\n    if (parser->col > 0) {\n      parser->col--;\n    }\n  }\n\n  return RET_OK;\n}\n\n#define TOKEN_INIT(t, ttype, str) \\\n  t->type = ttype;                \\\n  t->token = str->str;            \\\n  t->size = str->size;\n\nstatic ret_t fscript_parser_parse_str(fscript_parser_t* parser, char quota) {\n  char c = '\\0';\n  bool_t escape = FALSE;\n  str_t* str = &(parser->temp);\n  token_t* t = &(parser->token);\n\n  str_set(str, \"\");\n  do {\n    c = fscript_parser_get_char(parser);\n    if (escape) {\n      if (c == 'r') {\n        str_append_char(str, '\\r');\n      } else if (c == 'n') {\n        str_append_char(str, '\\n');\n      } else if (c == 't') {\n        str_append_char(str, '\\t');\n      } else {\n        str_append_char(str, c);\n      }\n      escape = FALSE;\n      continue;\n    }\n\n    if (c == quota || c == '\\0') {\n      break;\n    } else if (c == '\\\\') {\n      escape = TRUE;\n      continue;\n    }\n    str_append_char(str, c);\n  } while (TRUE);\n\n  TOKEN_INIT(t, TOKEN_STR, str);\n  if (c != '\\0' && c != quota) {\n    fscript_parser_unget_char(parser, c);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_get_non_ascii_char(fscript_parser_t* parser, str_t* str, uint8_t c,\n                                               uint32_t n) {\n  str_append_char(str, c);\n  while (n > 1) {\n    c = fscript_parser_get_char(parser);\n    str_append_char(str, c);\n    n--;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_parse_id_or_number(fscript_parser_t* parser, token_type_t def_type) {\n  char c = '\\0';\n  str_t* str = &(parser->temp);\n  token_t* t = &(parser->token);\n  c = fscript_parser_get_char(parser);\n\n  str_set(str, \"\");\n  if (c) {\n    int32_t n = tk_utf8_get_bytes_of_leading((uint8_t)c);\n    fscript_parser_get_non_ascii_char(parser, str, c, n);\n  }\n\n  do {\n    c = fscript_parser_get_char(parser);\n    if (tk_isxdigit(c) || tk_isdigit(c) || tk_isalpha(c) || c == '.' || c == '_' || c == '[' ||\n        c == ']' || c == '#') {\n      str_append_char(str, c);\n    } else {\n      int32_t n = tk_utf8_get_bytes_of_leading((uint8_t)c);\n      if (n > 1) {\n        fscript_parser_get_non_ascii_char(parser, str, c, n);\n      } else {\n        break;\n      }\n    }\n  } while (TRUE);\n\n  if (tk_isspace(c)) {\n    fscript_parser_skip_seperators_and_comments(parser);\n    c = fscript_parser_get_char(parser);\n  }\n\n  str_trim(str, \" \\t\\r\\n\");\n  TOKEN_INIT(t, (c == '(' ? TOKEN_FUNC : def_type), str);\n  if (c != '\\0') {\n    fscript_parser_unget_char(parser, c);\n  }\n\n  if (t->type == TOKEN_ID) {\n    if (tk_str_eq(t->token, \"function\")) {\n      t->type = TOKEN_FUNC_DEF;\n    } else if (tk_str_eq(t->token, \"var\")) {\n      t->type = TOKEN_VAR;\n    } else if (tk_str_eq(t->token, \"return\")) {\n      t->type = TOKEN_RETURN;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_get_unary(fscript_parser_t* parser, char c, str_t* str) {\n  do {\n    fscript_parser_skip_seperators_and_comments(parser);\n    c = fscript_parser_get_char(parser);\n    if (c == str->str[0]) {\n      str_append_char(str, c);\n    } else {\n      fscript_parser_unget_char(parser, c);\n      break;\n    }\n  } while (TRUE);\n\n  return RET_OK;\n}\n\nstatic token_t* fscript_parser_get_token_ex(fscript_parser_t* parser, bool_t operator) {\n  char c = 0;\n  str_t* str = &(parser->temp);\n  token_t* t = &(parser->token);\n\n  if (t->valid) {\n    t->valid = FALSE;\n    return t;\n  }\n\n  fscript_parser_skip_seperators_and_comments(parser);\n  c = fscript_parser_get_char(parser);\n\n  str_set_with_len(str, &c, 1);\n  t->token = str->str;\n  t->size = 1;\n  switch (c) {\n    case '\\0': {\n      t->type = TOKEN_EOF;\n      return NULL;\n    }\n    case '(': {\n      t->type = TOKEN_LPAREN;\n      return t;\n    }\n    case ')': {\n      t->type = TOKEN_RPAREN;\n      return t;\n    }\n    case '{': {\n      t->type = TOKEN_LBRACKET;\n      return t;\n    }\n    case '}': {\n      t->type = TOKEN_RBRACKET;\n      return t;\n    }\n    case ',': {\n      t->type = TOKEN_COMMA;\n      return t;\n    }\n    case ';': {\n      t->type = TOKEN_SEMICOLON;\n      return t;\n    }\n    case '?': {\n      t->type = TOKEN_QUESTION;\n      return t;\n    }\n    case ':': {\n      t->type = TOKEN_COLON;\n      return t;\n    }\n    case '*':\n    case '/':\n    case '%':\n    case '^':\n    case '#': {\n      t->type = TOKEN_FUNC;\n      return t;\n    }\n    case '>':\n    case '<':\n    case '=': {\n      c = fscript_parser_get_char(parser);\n      if (str->str[0] == c || c == '=') {\n        str_append_char(str, c);\n      } else {\n        fscript_parser_unget_char(parser, c);\n      }\n      t->type = TOKEN_FUNC;\n      t->size = str->size;\n      return t;\n    }\n    case '~':\n    case '!': {\n      c = fscript_parser_get_char(parser);\n      if (c == '=') {\n        str_append_char(str, c);\n      } else {\n        fscript_parser_unget_char(parser, c);\n        fscript_parser_get_unary(parser, c, str);\n      }\n      TOKEN_INIT(t, TOKEN_FUNC, str);\n      return t;\n    }\n    case '|':\n    case '&': {\n      c = fscript_parser_get_char(parser);\n      if (c == str->str[0]) {\n        str_append_char(str, c);\n      } else {\n        fscript_parser_unget_char(parser, c);\n      }\n\n      t->type = TOKEN_FUNC;\n      t->size = str->size;\n      return t;\n    }\n    case '\\\"':\n    case '\\'': {\n      fscript_parser_parse_str(parser, c);\n      return t;\n    }\n    default: {\n      if (c == '+' || c == '-') {\n        fscript_parser_skip_seperators_and_comments(parser);\n        if (operator|| !tk_isdigit(parser->cursor[0])) {\n          fscript_parser_get_unary(parser, c, str);\n          TOKEN_INIT(t, TOKEN_FUNC, str);\n        } else {\n          fscript_parser_unget_char(parser, c);\n          fscript_parser_parse_id_or_number(parser, TOKEN_NUMBER);\n        }\n      } else if (tk_isdigit(c)) {\n        fscript_parser_unget_char(parser, c);\n        fscript_parser_parse_id_or_number(parser, TOKEN_NUMBER);\n      } else {\n        fscript_parser_unget_char(parser, c);\n        fscript_parser_parse_id_or_number(parser, TOKEN_ID);\n      }\n      return t;\n    }\n  }\n}\n\nstatic token_t* fscript_parser_get_token(fscript_parser_t* parser) {\n  return fscript_parser_get_token_ex(parser, FALSE);\n}\n\nstatic ret_t fscript_parser_expect_token(fscript_parser_t* parser, token_type_t type,\n                                         const char* msg) {\n  token_t* t = fscript_parser_get_token(parser);\n  if (t == NULL || t->type != type) {\n    return fscript_parser_set_error(parser, msg);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_unget_token(fscript_parser_t* parser) {\n  if (parser->token.type != TOKEN_EOF) {\n    parser->token.valid = TRUE;\n  }\n  return RET_OK;\n}\n\nstatic ret_t token_to_value(fscript_parser_t* parser, token_t* t, value_t* v) {\n  if (t->type == TOKEN_NUMBER) {\n    char number[64];\n    tk_strncpy_s(number, sizeof(number) - 1, t->token, t->size);\n    if (strchr(number, '.') != NULL) {\n      value_set_double(v, tk_atof(number));\n    } else {\n      uint64_t vv = 0;\n      const char* str = number;\n      bool_t has_minus = FALSE;\n      if (*str == '-') {\n        has_minus = TRUE;\n        str++;\n      }\n\n      vv = tk_atoul(str);\n      if (vv < INT_MAX) {\n        if (has_minus) {\n          value_set_int32(v, -vv);\n        } else {\n          value_set_int32(v, vv);\n        }\n      } else if (vv < UINT32_MAX) {\n        if (has_minus) {\n          value_set_int64(v, -vv);\n        } else {\n          value_set_uint32(v, vv);\n        }\n      } else {\n        if (has_minus) {\n          value_set_int64(v, -vv);\n        } else {\n          value_set_uint64(v, vv);\n        }\n      }\n    }\n  } else if (t->type == TOKEN_STR) {\n    value_dup_str_with_len(v, t->token, t->size);\n  } else if (t->type == TOKEN_ID) {\n    if (t->token[0] == 't' && strncmp(t->token, \"true\", 4) == 0) {\n      value_set_bool(v, TRUE);\n    } else if (t->token[0] == 'f' && strncmp(t->token, \"false\", 5) == 0) {\n      value_set_bool(v, FALSE);\n    } else {\n      const char* name = NULL;\n      const char* p = NULL;\n      value_set_id(v, t->token, t->size);\n      name = value_id(v);\n      p = strchr(name, '.');\n      if (p != NULL) {\n        char first_name[TK_NAME_LEN + 1];\n        tk_strncpy_s(first_name, TK_NAME_LEN, name, p - name);\n        value_id_suboffset(v) = p - name + 1;\n        value_id_index(v) = darray_find_index(parser->symbols, (void*)first_name);\n      } else {\n        value_id_suboffset(v) = 0;\n        value_id_index(v) = darray_find_index(parser->symbols, (void*)name);\n      }\n    }\n  } else {\n    return RET_FAIL;\n  }\n\n  return RET_OK;\n}\n\nret_t fscript_eval(tk_object_t* obj, const char* script, value_t* result) {\n  value_t v;\n  ret_t ret = RET_OK;\n  fscript_t* fscript = fscript_create(obj, script);\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n\n  if (fscript_exec(fscript, &v) == RET_OK && result != NULL) {\n    value_deep_copy(result, &v);\n  }\n  value_reset(&v);\n  fscript_destroy(fscript);\n\n  return ret;\n}\n\n/*expr parser*/\nstatic ret_t fexpr_parse_block(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  value_t v;\n  fscript_func_call_t* statements = fscript_func_call_create(parser, \"expr\", 4);\n  return_value_if_fail(statements != NULL, RET_OOM);\n\n  if (fscript_parse_statements(parser, statements) == RET_OK) {\n    func_args_push(&(acall->args), value_set_func(&v, statements));\n  } else {\n    fscript_func_call_destroy(statements);\n  }\n\n  fscript_parser_expect_token(parser, TOKEN_RBRACKET, \"expect \\\"}\\\"\");\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_function(fscript_parser_t* parser, value_t* result);\n\nstatic ret_t fexpr_parse_if(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  uint32_t i = 0;\n  token_t* t = NULL;\n  fexpr_parse_block(parser, acall);\n  t = fscript_parser_get_token(parser);\n\n  if (t != NULL && t->type == TOKEN_ID && tk_str_eq(t->token, \"else\")) {\n    t = fscript_parser_get_token(parser);\n    if (t != NULL && t->type == TOKEN_FUNC && tk_str_eq(t->token, \"if\")) {\n      value_t result;\n      fscript_func_call_t* elseif = NULL;\n      fscript_parser_unget_token(parser);\n      return_value_if_fail(fexpr_parse_function(parser, &result) == RET_OK, RET_FAIL);\n      elseif = value_func(&result);\n      for (i = 0; i < elseif->args.size; i++) {\n        func_args_push(&(acall->args), elseif->args.args + i);\n      }\n      elseif->args.size = 0;\n      fscript_func_call_destroy(elseif);\n      return RET_OK;\n    } else {\n      fscript_parser_unget_token(parser);\n      fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\");\n      return fexpr_parse_block(parser, acall);\n    }\n  } else {\n    fscript_parser_unget_token(parser);\n    return RET_OK;\n  }\n}\n\nstatic ret_t fexpr_parse_function(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  fscript_args_t* args = NULL;\n  token_t* t = fscript_parser_get_token(parser);\n  fscript_func_call_t* acall = NULL;\n  if (t->token[0] == '-' && t->size == 1) {\n    acall = fscript_func_call_create(parser, \"minus\", 5);\n  } else {\n    acall = fscript_func_call_create(parser, t->token, t->size);\n  }\n  value_set_func(result, acall);\n  return_value_if_fail(acall != NULL, RET_BAD_PARAMS);\n\n  args = &(acall->args);\n  return_value_if_fail(fscript_parser_expect_token(parser, TOKEN_LPAREN, \"expect \\\"(\\\"\") == RET_OK,\n                       RET_FAIL);\n\n  do {\n    t = fscript_parser_get_token(parser);\n    if (t == NULL) {\n      return fscript_parser_set_error(parser, \"expect \\\")\\\"\");\n    }\n\n    if (t->type == TOKEN_RPAREN) {\n      break;\n    } else {\n      fscript_parser_unget_token(parser);\n    }\n    value_set_int(&v, 0);\n    return_value_if_fail(fexpr_parse(parser, &v) == RET_OK, RET_FAIL);\n    func_args_push(args, &v);\n    t = fscript_parser_get_token(parser);\n\n    if (t == NULL) {\n      return fscript_parser_set_error(parser, \"expect \\\")\\\"\");\n    } else if (t->type == TOKEN_RPAREN) {\n      break;\n    }\n    fscript_parser_unget_token(parser);\n    if (acall->func == func_for) {\n      fscript_parser_expect_token(parser, TOKEN_SEMICOLON, \"expect \\\";\\\"\");\n    } else {\n      fscript_parser_expect_token(parser, TOKEN_COMMA, \"expect \\\",\\\"\");\n    }\n  } while (TRUE);\n\n  if (acall->func == func_if && acall->args.size == 1) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_if(parser, acall);\n    }\n  } else if ((acall->func == func_while || acall->func == func_until ||\n              acall->func == func_repeat_times) &&\n             acall->args.size == 1) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_block(parser, acall);\n    }\n  } else if (acall->func == func_for && acall->args.size == 3) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_block(parser, acall);\n    }\n  } else if (acall->func == func_for_in && acall->args.size == 2) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_block(parser, acall);\n    }\n  } else if (acall->func == func_repeat && acall->args.size == 4) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_block(parser, acall);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_term(fscript_parser_t* parser, value_t* result) {\n  ret_t ret = RET_OK;\n  token_t* t = fscript_parser_get_token(parser);\n  value_set_int(result, 0);\n  return_value_if_fail(t != NULL, RET_BAD_PARAMS);\n\n  if (t->type == TOKEN_NUMBER || t->type == TOKEN_ID || t->type == TOKEN_STR) {\n    if (t->type == TOKEN_ID && t->token[0] == '.') {\n      fscript_parser_set_error(parser, \"var can't begin with '.'\");\n    }\n    ret = token_to_value(parser, t, result);\n  } else if (t->type == TOKEN_FUNC) {\n    fscript_parser_unget_token(parser);\n    ret = fexpr_parse_function(parser, result);\n  } else if (t->type == TOKEN_RETURN) {\n    fscript_func_call_t* acall = fscript_func_call_create(parser, \"return\", 6);\n    return_value_if_fail(acall != NULL, RET_OOM);\n    value_set_func(result, acall);\n    t = fscript_parser_get_token(parser);\n    if (t != NULL && t->type != TOKEN_SEMICOLON && t->type != TOKEN_RBRACKET) {\n      value_t v;\n      value_set_int(&v, 0);\n      fscript_parser_unget_token(parser);\n      if (fexpr_parse(parser, &v) == RET_OK) {\n        func_args_push(&(acall->args), &v);\n      }\n    } else {\n      fscript_parser_unget_token(parser);\n    }\n  } else if (t->type == TOKEN_LPAREN) {\n    ret = fexpr_parse(parser, result);\n    return_value_if_fail(ret == RET_OK, ret);\n    ret = fscript_parser_expect_token(parser, TOKEN_RPAREN, \"expect )\");\n  } else {\n    fscript_parser_unget_token(parser);\n  }\n\n  return ret;\n}\n\nstatic ret_t fexpr_parse_unary(fscript_parser_t* parser, value_t* result) {\n  char c = '\\0';\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n  token_t* t = fscript_parser_get_token_ex(parser, FALSE);\n  if (t == NULL || t->type == TOKEN_EOF) {\n    return RET_OK;\n  }\n\n  c = t->token[0];\n  if (t->type == TOKEN_FUNC && (c == '!' || c == '~' || c == '-')) {\n    value_t v;\n    uint32_t i = 0;\n    bool_t valid = FALSE;\n    for (i = 0; i < t->size; i++) {\n      if (t->token[i] != c) {\n        return fscript_parser_set_error(parser, \"unexpected token\");\n      } else {\n        valid = !valid;\n      }\n    }\n\n    if (valid) {\n      acall = fscript_func_call_create(parser, &c, 1);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      value_set_func(result, acall);\n      return_value_if_fail(fexpr_parse_term(parser, &v) == RET_OK, RET_FAIL);\n      func_args_push(args, &v);\n    } else {\n      return_value_if_fail(fexpr_parse_term(parser, result) == RET_OK, RET_FAIL);\n    }\n  } else {\n    fscript_parser_unget_token(parser);\n    return_value_if_fail(fexpr_parse_term(parser, result) == RET_OK, RET_FAIL);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fsexpr_parse_product(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n  return_value_if_fail(fexpr_parse_unary(parser, result) == RET_OK, RET_FAIL);\n\n  while (TRUE) {\n    t = fscript_parser_get_token_ex(parser, TRUE);\n    if (t == NULL || t->type != TOKEN_FUNC) {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n\n    if (t->token[0] == '*' || t->token[0] == '/' || t->token[0] == '%') {\n      acall = fscript_func_call_create(parser, t->token, t->size);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      func_args_push(args, result);\n      value_set_func(result, acall);\n      v.type = VALUE_TYPE_INVALID;\n      fexpr_parse_unary(parser, &v);\n      if (v.type == VALUE_TYPE_INVALID) {\n        fscript_parser_set_error(parser, \"expect an expression\");\n      } else {\n        func_args_push(args, &v);\n      }\n    } else {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_sum(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n  return_value_if_fail(fsexpr_parse_product(parser, result) == RET_OK, RET_FAIL);\n\n  while (TRUE) {\n    t = fscript_parser_get_token_ex(parser, TRUE);\n    if (t == NULL || t->type != TOKEN_FUNC) {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n\n    if (t->token[0] == '+' || t->token[0] == '-') {\n      parser->token.valid = FALSE;\n      acall = fscript_func_call_create(parser, t->token, t->size);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      func_args_push(args, result);\n      value_set_func(result, acall);\n      v.type = VALUE_TYPE_INVALID;\n      fsexpr_parse_product(parser, &v);\n      if (v.type == VALUE_TYPE_INVALID) {\n        fscript_parser_set_error(parser, \"expect an expression\");\n      } else {\n        func_args_push(args, &v);\n      }\n    } else {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_compare(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n\n  value_set_int(result, 0);\n  return_value_if_fail(fexpr_parse_sum(parser, result) == RET_OK, RET_FAIL);\n\n  t = fscript_parser_get_token_ex(parser, TRUE);\n  if (t == NULL || t->type != TOKEN_FUNC || tk_str_eq(t->token, \"=\")) {\n    fscript_parser_unget_token(parser);\n    return RET_OK;\n  }\n\n  if (t->token[0] == '>' || t->token[0] == '<' || t->token[0] == '=' ||\n      (t->token[0] == '!' && t->token[1] == '=')) {\n    acall = fscript_func_call_create(parser, t->token, t->size);\n    return_value_if_fail(acall != NULL, RET_OOM);\n    args = &(acall->args);\n    func_args_push(args, result);\n    value_set_func(result, acall);\n    v.type = VALUE_TYPE_INVALID;\n    fexpr_parse_sum(parser, &v);\n    if (v.type == VALUE_TYPE_INVALID) {\n      fscript_parser_set_error(parser, \"expect an expression\");\n    } else {\n      func_args_push(args, &v);\n    }\n  } else {\n    fscript_parser_unget_token(parser);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_logic(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n\n  value_set_int(result, 0);\n  return_value_if_fail(fexpr_parse_compare(parser, result) == RET_OK, RET_FAIL);\n\n  while (TRUE) {\n    t = fscript_parser_get_token_ex(parser, TRUE);\n    if (t == NULL || t->type != TOKEN_FUNC || tk_str_eq(t->token, \"=\")) {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n\n    if (t->token[0] == '|' || t->token[0] == '&' || t->token[0] == '^') {\n      acall = fscript_func_call_create(parser, t->token, t->size);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      func_args_push(args, result);\n      value_set_func(result, acall);\n      v.type = VALUE_TYPE_INVALID;\n      fexpr_parse_compare(parser, &v);\n      if (v.type == VALUE_TYPE_INVALID) {\n        fscript_parser_set_error(parser, \"expect an expression\");\n      } else {\n        func_args_push(args, &v);\n      }\n    } else {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_question(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  ret_t ret = RET_OK;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n\n  value_set_str(&v, NULL);\n  if (fexpr_parse_logic(parser, result) == RET_OK) {\n    t = fscript_parser_get_token(parser);\n    if (t && t->type == TOKEN_QUESTION) {\n      acall = fscript_func_call_create(parser, \"if\", 2);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      func_args_push(args, result);\n      value_set_func(result, acall);\n\n      value_reset(&v);\n      return_value_if_fail(fexpr_parse_logic(parser, &v) == RET_OK, RET_FAIL);\n      func_args_push(args, &v);\n\n      return_value_if_fail(fscript_parser_expect_token(parser, TOKEN_COLON, \"expect :\") == RET_OK,\n                           RET_FAIL);\n      return_value_if_fail(fexpr_parse_logic(parser, &v) == RET_OK, RET_FAIL);\n      func_args_push(args, &v);\n    } else {\n      fscript_parser_unget_token(parser);\n    }\n  } else {\n    ret = RET_FAIL;\n  }\n\n  return ret;\n}\n\nstatic ret_t fexpr_parse(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  bool_t is_local = FALSE;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n  value_set_int(result, 0);\n\n  t = fscript_parser_get_token_ex(parser, TRUE);\n  if (t == NULL || t->type == TOKEN_RBRACKET || t->type == TOKEN_SEMICOLON) {\n    value_reset(result);\n    fscript_parser_unget_token(parser);\n    return RET_OK;\n  }\n\n  if (t->type == TOKEN_VAR) {\n    is_local = TRUE;\n  } else {\n    fscript_parser_unget_token(parser);\n  }\n  return_value_if_fail(fexpr_parse_question(parser, result) == RET_OK, RET_FAIL);\n\n  t = fscript_parser_get_token_ex(parser, TRUE);\n  if (t != NULL && tk_str_eq(t->token, \"=\")) {\n    const char* name = is_local ? \"set_local\" : \"=\";\n    acall = fscript_func_call_create(parser, name, strlen(name));\n    return_value_if_fail(acall != NULL, RET_OOM);\n    args = &(acall->args);\n    func_args_push(args, result);\n    value_set_func(result, acall);\n    v.type = VALUE_TYPE_INVALID;\n    fexpr_parse_question(parser, &v);\n    if (v.type == VALUE_TYPE_INVALID) {\n      fscript_parser_set_error(parser, \"expect an expression\");\n    } else {\n      func_args_push(args, &v);\n    }\n\n    if (is_local) {\n      darray_push_unique(parser->symbols, (void*)value_id(args->args));\n    }\n  } else {\n    fscript_parser_unget_token(parser);\n  }\n\n  return RET_OK;\n}\n\nstatic fscript_t* fscript_init_with_parser(fscript_t* fscript, fscript_parser_t* parser) {\n  fscript = fscript != NULL ? fscript : TKMEM_ZALLOC(fscript_t);\n  return_value_if_fail(fscript != NULL, NULL);\n  fscript->str = parser->temp;\n  fscript->obj = parser->obj;\n  fscript->first = parser->first;\n  fscript->funcs_def = parser->funcs_def;\n  fscript->code_id = parser->code_id;\n  fscript->lines = parser->row + 1;\n\n  if (s_hooks != NULL && s_hooks->on_init != NULL) {\n    s_hooks->on_init(fscript, parser->str);\n  }\n\n  parser->obj = NULL;\n  parser->first = NULL;\n  parser->temp.str = NULL;\n  parser->funcs_def = NULL;\n  parser->code_id = NULL;\n\n  return fscript;\n}\n\nstatic ret_t func_function(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  ret_t ret = RET_OK;\n  darray_t* saved_locals = fscript->locals;\n  fscript_function_def_t* func_def = (fscript_function_def_t*)(fscript->curr->ctx);\n  fscript_func_call_t* func = func_def->body;\n\n  func->func = func_noop;\n  fscript->locals = NULL;\n  if (func_def->params.size > 0 && args->size > 0) {\n    uint32_t i = 0;\n    uint32_t n = tk_min(func_def->params.size, args->size);\n    for (i = 0; i < n; i++) {\n      const value_t* value = args->args + i;\n      const char* name = (const char*)(func_def->params.elms[i]);\n      fscript_locals_create(fscript, name, value);\n    }\n  }\n\n  ret = fscript_exec_func(fscript, func_def->name, func, result);\n\n  fscript_locals_destroy(fscript);\n  fscript->locals = saved_locals;\n  fscript->returned = FALSE;\n\n  return ret;\n}\n\nstatic ret_t fscript_parse_function_def(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  value_t v;\n  char func_name[TK_NAME_LEN + 1];\n  fscript_function_def_t* func_def = NULL;\n  fscript_func_call_t* statements = NULL;\n  token_t* t = fscript_parser_get_token(parser);\n  darray_t* saved_symbols = parser->symbols;\n\n  if (t->type != TOKEN_FUNC) {\n    return fscript_parser_set_error(parser, \"expect function name\\n\");\n  }\n  tk_strncpy(func_name, t->token, TK_NAME_LEN);\n  fscript_parser_expect_token(parser, TOKEN_LPAREN, \"expect \\\"(\\\"\");\n  if (parser->funcs_def == NULL) {\n    parser->funcs_def = object_default_create();\n  }\n\n  if (tk_object_get_prop(parser->funcs_def, func_name, &v) == RET_OK) {\n    return fscript_parser_set_error(parser, \"duplicate function\\n\");\n  }\n  statements = fscript_func_call_create(parser, \"func\", 4);\n  return_value_if_fail(statements != NULL, RET_OOM);\n\n  func_def = fscript_function_def_create(func_name, statements);\n  return_value_if_fail(func_def != NULL, RET_OOM);\n  value_set_func_def(&v, func_def);\n  tk_object_set_prop(parser->funcs_def, func_name, &v);\n\n  parser->symbols = darray_create(5, NULL, (tk_compare_t)tk_str_cmp);\n  while (TRUE) {\n    t = fscript_parser_get_token(parser);\n    if (t == NULL || t->type == TOKEN_EOF || t->type == TOKEN_RPAREN) {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n    if (t->type == TOKEN_ID) {\n      fscript_function_def_add_param(func_def, t->token);\n      darray_push_unique(parser->symbols,\n                         (void*)darray_get(&(func_def->params), func_def->params.size - 1));\n    } else if (t->type == TOKEN_COMMA) {\n    } else {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n  }\n  fscript_parser_expect_token(parser, TOKEN_RPAREN, \"expect \\\")\\\"\");\n  fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\");\n  fscript_parse_statements(parser, statements);\n  fscript_parser_expect_token(parser, TOKEN_RBRACKET, \"expect \\\"}\\\"\");\n  darray_destroy(parser->symbols);\n  parser->symbols = saved_symbols;\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parse_statements(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  value_t v;\n  ret_t ret = RET_OK;\n  fscript_args_t* args = NULL;\n  return_value_if_fail(parser != NULL && acall != NULL, RET_BAD_PARAMS);\n\n  args = &(acall->args);\n\n  do {\n    token_t* t = NULL;\n    value_set_int(&v, 0);\n    ret = fexpr_parse(parser, &v);\n    if (ret == RET_OK) {\n      if (v.type != VALUE_TYPE_INVALID) {\n        func_args_push(args, &v);\n      }\n      t = fscript_parser_get_token(parser);\n      if (t == NULL) {\n        break;\n      }\n\n      if (t->type == TOKEN_FUNC || t->type == TOKEN_ID || t->type == TOKEN_NUMBER ||\n          t->type == TOKEN_STR || t->type == TOKEN_VAR || t->type == TOKEN_RETURN) {\n        fscript_parser_unget_token(parser);\n      } else if (t->type == TOKEN_RBRACKET || t->type == TOKEN_FUNC_DEF) {\n        fscript_parser_unget_token(parser);\n        break;\n      } else if (t->type != TOKEN_COMMA && t->type != TOKEN_SEMICOLON) {\n        return fscript_parser_set_error(parser, \"unexpected token\\n\");\n      }\n    } else {\n      if (v.type == VALUE_TYPE_FSCRIPT_FUNC) {\n        fscript_func_call_destroy(value_func(&v));\n      } else {\n        value_reset(&v);\n      }\n\n      break;\n    }\n  } while (parser->token.type != TOKEN_EOF);\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parse_all(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  ret_t ret = RET_OK;\n  while (ret == RET_OK) {\n    token_t* t = fscript_parser_get_token(parser);\n    if (t && t->type == TOKEN_FUNC_DEF) {\n      ret = fscript_parse_function_def(parser, acall);\n    } else if (t == NULL || t->type == TOKEN_EOF) {\n      break;\n    } else if (t->type == TOKEN_RBRACKET) {\n      fscript_parser_set_error(parser, \"unexpected token\");\n      break;\n    } else {\n      fscript_parser_unget_token(parser);\n      ret = fscript_parse_statements(parser, acall);\n    }\n  }\n\n  return ret;\n}\n\nfscript_parser_error_t* fscript_parser_error_init(fscript_parser_error_t* error) {\n  return_value_if_fail(error != NULL, NULL);\n  memset(error, 0x00, sizeof(fscript_parser_error_t));\n\n  return error;\n}\n\nret_t fscript_parser_error_deinit(fscript_parser_error_t* error) {\n  return_value_if_fail(error != NULL, RET_BAD_PARAMS);\n  TKMEM_FREE(error->token);\n  TKMEM_FREE(error->message);\n\n  return RET_OK;\n}\n\nret_t fscript_syntax_check(tk_object_t* obj, const char* script, fscript_parser_error_t* error) {\n  ret_t ret = RET_OK;\n  fscript_parser_t parser;\n  return_value_if_fail(obj != NULL && script != NULL && error != NULL, RET_BAD_PARAMS);\n  fscript_parser_error_init(error);\n  fscript_parser_init(&parser, obj, script, error);\n\n  parser.first = fscript_func_call_create(&parser, \"expr\", 4);\n  ret = fscript_parse_all(&parser, parser.first);\n  fscript_parser_deinit(&parser);\n\n  return ret;\n}\n\nstatic fscript_t* fscript_load(fscript_t* fscript, tk_object_t* obj, const char* script,\n                               const char* first_call_name, bool_t keep_func_name) {\n  ret_t ret = RET_OK;\n  fscript_parser_t parser;\n  fscript_parser_error_t error;\n  return_value_if_fail(script != NULL, NULL);\n\n  fscript_parser_error_init(&error);\n  fscript_parser_init(&parser, obj, script, &error);\n  parser.keep_func_name = keep_func_name;\n  parser.first = fscript_func_call_create(&parser, first_call_name, strlen(first_call_name));\n  ret = fscript_parse_all(&parser, parser.first);\n  if (ret == RET_OK) {\n    fscript = fscript_init_with_parser(fscript, &parser);\n    fscript_parser_deinit(&parser);\n  } else {\n    log_warn(\"parser error:%s\\n\", script);\n    fscript_parser_deinit(&parser);\n  }\n  fscript_parser_error_deinit(&error);\n\n  return fscript;\n}\n\nret_t fscript_reload(fscript_t* fscript, const char* script) {\n  tk_object_t* obj = NULL;\n  return_value_if_fail(fscript != NULL && fscript->obj != NULL && script != NULL, RET_BAD_PARAMS);\n  obj = fscript->obj;\n  fscript_reset(fscript);\n\n  return fscript_load(fscript, obj, script, \"expr\", FALSE) != NULL ? RET_OK : RET_FAIL;\n}\n\nfscript_t* fscript_init(fscript_t* fscript, tk_object_t* obj, const char* script,\n                        const char* first_call_name, bool_t keep_func_name) {\n  return fscript_load(fscript, obj, script, first_call_name, keep_func_name);\n}\n\nfscript_t* fscript_create_ex(tk_object_t* obj, const char* script, bool_t keep_func_name) {\n  return fscript_load(NULL, obj, script, \"expr\", keep_func_name);\n}\n\nfscript_t* fscript_create(tk_object_t* obj, const char* script) {\n  return fscript_create_ex(obj, script, FALSE);\n}\n\n/*functions*/\nstatic ret_t func_get_last_error(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  if (fscript->error_code != RET_OK) {\n    tk_object_t* obj = object_default_create();\n    return_value_if_fail(obj != NULL, RET_OOM);\n    tk_object_set_prop_int(obj, \"col\", fscript->error_col);\n    tk_object_set_prop_int(obj, \"line\", fscript->error_row);\n    tk_object_set_prop_int(obj, \"code\", fscript->error_code);\n    tk_object_set_prop_str(obj, \"message\", fscript->error_message);\n    value_set_object(result, obj);\n    result->free_handle = TRUE;\n  } else {\n    value_set_int(result, 0);\n    value_reset(result);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_has_error(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  value_set_bool(result, fscript->error_code != RET_OK);\n  return RET_OK;\n}\n\nstatic ret_t func_clear_error(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  fscript_set_error(fscript, RET_OK, NULL, NULL);\n  return RET_OK;\n}\n\nstatic ret_t func_sum(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  double v = 0;\n  uint32_t i = 0;\n  bool_t has_str = FALSE;\n  bool_t has_float = FALSE;\n  FSCRIPT_FUNC_CHECK(args->size > 0, RET_BAD_PARAMS);\n\n  for (i = 0; i < args->size; i++) {\n    int type = args->args[i].type;\n    if (type == VALUE_TYPE_STRING) {\n      has_str = TRUE;\n    }\n    if (type == VALUE_TYPE_FLOAT || type == VALUE_TYPE_DOUBLE || type == VALUE_TYPE_FLOAT32) {\n      has_float = TRUE;\n    }\n  }\n\n  if (has_str) {\n    str_t str;\n    char buff[64];\n    str_init(&str, 100);\n    for (i = 0; i < args->size; i++) {\n      str_append(&str, value_str_ex(args->args + i, buff, sizeof(buff) - 1));\n    }\n    value_dup_str(result, str.str);\n    str_reset(&str);\n  } else {\n    for (i = 0; i < args->size; i++) {\n      v += value_double(args->args + i);\n    }\n    if (has_float) {\n      value_set_double(result, v);\n    } else {\n      value_set_int(result, (int)v);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_int(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int(result, value_int(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_i8(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int8(result, value_int8(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_i16(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int16(result, value_int16(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_i32(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int(result, value_int(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_i64(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int64(result, value_int64(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_u8(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_uint8(result, value_uint8(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_u16(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_uint16(result, value_uint16(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_u32(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_uint32(result, value_uint32(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_u64(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_uint64(result, value_uint64(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_f32(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_float32(result, value_float32(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_double(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_double(result, value_double(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_binary(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  void* p = NULL;\n  uint32_t size = 0;\n  /*基本类型默认拷贝*/\n  bool_t clone = TRUE;\n  value_t* v = args->args;\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n\n  switch (v->type) {\n    case VALUE_TYPE_BOOL: {\n      size = sizeof(int8_t);\n      p = &(v->value.b);\n      break;\n    }\n    case VALUE_TYPE_INT8: {\n      size = sizeof(int8_t);\n      p = &(v->value.i8);\n      break;\n    }\n    case VALUE_TYPE_UINT8: {\n      size = sizeof(uint8_t);\n      p = &(v->value.u8);\n      break;\n    }\n    case VALUE_TYPE_INT16: {\n      size = sizeof(int16_t);\n      p = &(v->value.i16);\n      break;\n    }\n    case VALUE_TYPE_UINT16: {\n      size = sizeof(uint16_t);\n      p = &(v->value.u16);\n      break;\n    }\n    case VALUE_TYPE_INT32: {\n      size = sizeof(int32_t);\n      p = &(v->value.i32);\n      break;\n    }\n    case VALUE_TYPE_UINT32: {\n      size = sizeof(uint32_t);\n      p = &(v->value.u32);\n      break;\n    }\n    case VALUE_TYPE_INT64: {\n      size = sizeof(int64_t);\n      p = &(v->value.i64);\n      break;\n    }\n    case VALUE_TYPE_UINT64: {\n      size = sizeof(uint64_t);\n      p = &(v->value.u64);\n      break;\n    }\n    case VALUE_TYPE_FLOAT: {\n      size = sizeof(float_t);\n      p = &(v->value.f32);\n      break;\n    }\n    case VALUE_TYPE_FLOAT32: {\n      size = sizeof(float);\n      p = &(v->value.f32);\n      break;\n    }\n    case VALUE_TYPE_DOUBLE: {\n      size = sizeof(double);\n      p = &(v->value.f64);\n      break;\n    }\n    case VALUE_TYPE_STRING: {\n      p = (void*)value_str(v);\n      size = tk_strlen(value_str(v));\n      clone = FALSE;\n      break;\n    }\n    case VALUE_TYPE_WSTRING: {\n      p = (void*)value_wstr(v);\n      size = wcslen(value_wstr(v)) * sizeof(wchar_t);\n      clone = FALSE;\n      break;\n    }\n    case VALUE_TYPE_POINTER: {\n      p = value_pointer(v);\n      size = args->size > 1 ? value_uint32(args->args + 1) : 0;\n      clone = FALSE;\n      break;\n    }\n    case VALUE_TYPE_BINARY: {\n      p = v->value.binary_data.data;\n      size = v->value.binary_data.size;\n      clone = FALSE;\n      break;\n    }\n    case VALUE_TYPE_SIZED_STRING: {\n      p = v->value.sized_str.str;\n      size = v->value.sized_str.size;\n      clone = FALSE;\n      break;\n    }\n    default: {\n      log_debug(\"not supported type\\n\");\n      break;\n    }\n  }\n\n  if (p == NULL || size == 0) {\n    value_set_binary_data(result, p, size);\n    return RET_OK;\n  }\n\n  /*参数1指定长度*/\n  if (args->size > 1) {\n    uint32_t esize = value_uint32(args->args + 1);\n    if (esize <= size) {\n      size = esize;\n    } else {\n      log_debug(\"size is too large, use default\\n\");\n    }\n  }\n\n  /*参数2要求复制*/\n  if (args->size > 2 && value_bool(args->args + 2)) {\n    clone = TRUE;\n  }\n\n  if (clone) {\n    p = tk_memdup(p, size);\n    value_set_binary_data(result, p, size);\n    result->free_handle = TRUE;\n  } else {\n    value_set_binary_data(result, p, size);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_str(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  str_t* str = &(fscript->str);\n  value_t* v = args->args;\n  bool_t force_pointer_as_str = args->size == 2 && value_bool(args->args + 1);\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n\n  if (force_pointer_as_str) {\n    if (v->type == VALUE_TYPE_POINTER) {\n      value_set_str(result, (const char*)value_pointer(v));\n      return RET_OK;\n    } else if (v->type == VALUE_TYPE_BINARY) {\n      value_set_str(result, (const char*)(v->value.binary_data.data));\n      return RET_OK;\n    }\n  }\n  str_from_value(str, args->args);\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}\n\nstatic ret_t func_one_of(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  char sep = ';';\n  int32_t index = 0;\n  const char* strs = NULL;\n  const char* start = NULL;\n\n  value_set_str(result, \"\");\n  FSCRIPT_FUNC_CHECK(args->size >= 2, RET_BAD_PARAMS);\n  FSCRIPT_FUNC_CHECK(args->args[0].type == VALUE_TYPE_STRING, RET_BAD_PARAMS);\nstrs = ",
    "raw_res": "value_str(&(args->args[0]));",
    "prompt_res": "value_str(args->args);",
    "gt": "value_str(args->args);"
  },
  {
    "id": 810,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/fscript.c",
    "input": "﻿/**\n * File:   fscript.c\n * Author: AWTK Develop Team\n * Brief:  a simple script language\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2020-11-09 Li XianJing <lixianjing@zlg.cn> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/darray.h\"\n#include \"tkc/fscript.h\"\n#include \"tkc/object_default.h\"\n#include \"tkc/general_factory.h\"\n#include \"tkc/object_locker.h\"\n\n#ifndef WITHOUT_FSCRIPT\n#define value_id_index(v) (v)->value.id.index\n#define value_id_suboffset(v) (v)->value.id.suboffset\n\nstatic const fscript_hooks_t* s_hooks;\n\nret_t fscript_set_hooks(const fscript_hooks_t* hooks) {\n  s_hooks = hooks;\n  return RET_OK;\n}\n\nstatic ret_t func_function_def(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_if(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_while(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_until(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_repeat_times(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_repeat(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_for(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_for_in(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_noop(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_pending(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_return(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  if (args->size > 0) {\n    value_deep_copy(result, args->args);\n  }\n  fscript->returned = TRUE;\n  return RET_OK;\n}\nstatic ret_t func_get(fscript_t* fscript, fscript_args_t* args, value_t* result);\nstatic ret_t func_set(fscript_t* fscript, fscript_args_t* args, value_t* result);\nstatic ret_t func_unset(fscript_t* fscript, fscript_args_t* args, value_t* result);\nstatic ret_t func_set_local(fscript_t* fscript, fscript_args_t* args, value_t* result);\nstatic ret_t fscript_func_call_init_func(fscript_func_call_t* call, tk_object_t* obj,\n                                         tk_object_t* funcs_def, const char* name, uint32_t size);\n\nret_t fscript_ensure_locals(fscript_t* fscript) {\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n\n  if (fscript->locals == NULL) {\n    fscript->locals = darray_create(5, (tk_destroy_t)named_value_destroy,\n                                    (tk_compare_t)named_value_compare_by_name);\n  }\n\n  return fscript->locals != NULL ? RET_OK : RET_FAIL;\n}\n\nstatic ret_t fscript_locals_remove(fscript_t* fscript, uint32_t index) {\n  named_value_t* nv = (named_value_t*)(fscript->locals->elms[index]);\n  return value_reset(&(nv->value));\n}\n\nstatic tk_object_t* fscript_locals_get_object(fscript_t* fscript, const char* name) {\n  named_value_t* nv = (named_value_t*)darray_find(fscript->locals, (void*)name);\n\n  return nv != NULL ? value_object(&(nv->value)) : NULL;\n}\n\nstatic ret_t fscript_locals_get(fscript_t* fscript, const value_t* name, value_t* v) {\n  int32_t index = value_id_index(name);\n  int32_t suboffset = value_id_suboffset(name);\n  named_value_t* nv = (named_value_t*)(fscript->locals->elms[index]);\n  if (!suboffset) {\n    return value_copy(v, &(nv->value));\n  } else {\n    tk_object_t* obj = value_object(&(nv->value));\n    const char* subname = value_id(name) + suboffset;\n    return_value_if_fail(obj != NULL, RET_BAD_PARAMS);\n\n    return tk_object_get_prop(obj, subname, v);\n  }\n}\n\nstatic ret_t fscript_locals_set_with_index(fscript_t* fscript, uint32_t index, const value_t* v) {\n  named_value_t* nv = (named_value_t*)(fscript->locals->elms[index]);\n  if (nv->value.free_handle) {\n    value_reset(&(nv->value));\n  }\n  return value_deep_copy(&(nv->value), v);\n}\n\nstatic ret_t fscript_locals_set(fscript_t* fscript, const value_t* name, value_t* v) {\n  int32_t index = value_id_index(name);\n  int32_t suboffset = value_id_suboffset(name);\n  named_value_t* nv = (named_value_t*)(fscript->locals->elms[index]);\n  if (!suboffset) {\n    return fscript_locals_set_with_index(fscript, index, v);\n  } else {\n    tk_object_t* obj = value_object(&(nv->value));\n    const char* subname = value_id(name) + suboffset;\n    return_value_if_fail(obj != NULL, RET_BAD_PARAMS);\n\n    return tk_object_set_prop(obj, subname, v);\n  }\n}\n\nstatic ret_t fscript_locals_create(fscript_t* fscript, const char* name, const value_t* v) {\n  int32_t index = 0;\n  named_value_t* nv = NULL;\n  return_value_if_fail(fscript_ensure_locals(fscript) == RET_OK, RET_BAD_PARAMS);\n  index = darray_find_index(fscript->locals, (void*)name);\n\n  if (index >= 0) {\n    fscript_set_error(fscript, RET_FAIL, \"<>\", \"duplicated var name.\");\n    return fscript_locals_set_with_index(fscript, index, v);\n  }\n\n  nv = named_value_create_ex(name, v);\n  return_value_if_fail(nv != NULL, RET_BAD_PARAMS);\n\n  if (darray_push_unique(fscript->locals, nv) != RET_OK) {\n    named_value_destroy(nv);\n    return RET_FAIL;\n  }\n  return RET_OK;\n}\n\nstatic ret_t fscript_locals_destroy(fscript_t* fscript) {\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n  if (fscript->locals != NULL) {\n    darray_destroy(fscript->locals);\n    fscript->locals = NULL;\n  }\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_func(fscript_t* fscript, const char* name, fscript_func_call_t* iter,\n                               value_t* result) {\n  if (s_hooks != NULL && s_hooks->exec_func != NULL) {\n    return s_hooks->exec_func(fscript, name, iter, result);\n  } else {\n    return fscript_exec_func_default(fscript, iter, result);\n  }\n}\n\nret_t fscript_set_error(fscript_t* fscript, ret_t code, const char* func, const char* message) {\n  fscript->error_code = code;\n  fscript->error_func = fscript->curr;\n  fscript->error_row = fscript->curr->row;\n  fscript->error_col = fscript->curr->col;\n  fscript->error_message = tk_str_copy(fscript->error_message, message);\n  if (code != RET_OK) {\n    log_debug(\"(%d:%d): %s code=%d %s\\n\", fscript->curr->row, fscript->curr->col, func, code,\n              message);\n  }\n\n  if (fscript->on_error != NULL) {\n    fscript->on_error(fscript->on_error_ctx, fscript);\n  }\n\n  return RET_OK;\n}\n\nret_t fscript_set_on_error(fscript_t* fscript, fscript_on_error_t on_error, void* ctx) {\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n  fscript->on_error = on_error;\n  fscript->on_error_ctx = ctx;\n\n  return RET_OK;\n}\n\nret_t fscript_set_print_func(fscript_t* fscript, fscript_func_t print) {\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n\n  fscript->print = print;\n\n  return RET_OK;\n}\n\nstatic bool_t value_is_digit(value_t* v) {\n  uint32_t type = 0;\n  bool_t ret = TRUE;\n  return_value_if_fail(v != NULL, FALSE);\n\n  type = v->type;\n  if (type == VALUE_TYPE_INVALID || type == VALUE_TYPE_POINTER || type == VALUE_TYPE_STRING ||\n      type == VALUE_TYPE_WSTRING || type == VALUE_TYPE_OBJECT || type == VALUE_TYPE_SIZED_STRING ||\n      type == VALUE_TYPE_BINARY || type == VALUE_TYPE_UBJSON) {\n    ret = FALSE;\n  }\n\n  return ret;\n}\n\nstatic ret_t func_args_extend(fscript_args_t* args) {\n  if (args->size < args->capacity) {\n    return RET_OK;\n  }\n\n  if (args->capacity < FSCRIPT_MAX_ARGS) {\n    value_t* new_args = NULL;\n    uint16_t capacity = args->capacity + 2;\n    capacity = tk_min(capacity, FSCRIPT_MAX_ARGS);\n    new_args = TKMEM_REALLOC(args->args, capacity * sizeof(value_t));\n    return_value_if_fail(new_args != NULL, RET_OOM);\n    args->args = new_args;\n    args->capacity = capacity;\n    return RET_OK;\n  }\n\n  return RET_FAIL;\n}\n\nstatic ret_t func_args_push(fscript_args_t* args, value_t* v) {\n  return_value_if_fail(v != NULL && func_args_extend(args) == RET_OK, RET_BAD_PARAMS);\n  args->args[args->size++] = *v;\n  v->free_handle = FALSE;\n  value_reset(v);\n\n  return RET_OK;\n}\n\nstatic ret_t func_args_init(fscript_args_t* args, uint16_t init_args_capacity) {\n  memset(args, 0x00, sizeof(fscript_args_t));\n  if (init_args_capacity > 0) {\n    args->args = TKMEM_ZALLOCN(value_t, init_args_capacity);\n    return_value_if_fail(args->args != NULL, RET_OOM);\n    args->capacity = init_args_capacity;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_func_call_destroy(fscript_func_call_t* call);\n\nstatic ret_t func_args_reset(fscript_args_t* args) {\n  uint32_t i = 0;\n  for (i = 0; i < args->size; i++) {\n    value_t* v = args->args + i;\n    if (v->type == VALUE_TYPE_FSCRIPT_FUNC) {\n      fscript_func_call_destroy(value_func(v));\n    }\n    value_reset(args->args + i);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_args_deinit(fscript_args_t* args) {\n  func_args_reset(args);\n  TKMEM_FREE(args->args);\n  memset(args, 0x00, sizeof(fscript_args_t));\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_func_call_destroy(fscript_func_call_t* call) {\n  fscript_func_call_t* iter = call;\n  fscript_func_call_t* next = NULL;\n\n  while (iter != NULL) {\n    if (iter->func == func_pending) {\n      TKMEM_FREE(iter->ctx);\n    }\n    next = iter->next;\n    func_args_deinit(&(iter->args));\n    TKMEM_FREE(iter);\n    iter = next;\n  }\n\n  return RET_OK;\n}\n\nstatic fscript_function_def_t* fscript_function_def_create(const char* name,\n                                                           fscript_func_call_t* body) {\n  fscript_function_def_t* func = TKMEM_ZALLOC(fscript_function_def_t);\n  return_value_if_fail(func != NULL, NULL);\n  func->body = body;\n  func->name = tk_strdup(name);\n\n  darray_init(&(func->params), 3, default_destroy, NULL);\n  return func;\n}\n\nstatic ret_t fscript_function_def_destroy(fscript_function_def_t* func) {\n  return_value_if_fail(func != NULL, RET_BAD_PARAMS);\n  darray_deinit(&(func->params));\n  fscript_func_call_destroy(func->body);\n  TKMEM_FREE(func->name);\n  memset(func, 0x00, sizeof(fscript_function_def_t));\n  TKMEM_FREE(func);\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_function_def_add_param(fscript_function_def_t* func, const char* name) {\n  return_value_if_fail(func != NULL, RET_BAD_PARAMS);\n  return darray_push(&(func->params), tk_strdup(name));\n}\n\ntypedef enum _token_type_t {\n  TOKEN_ID = 1,\n  TOKEN_VAR,\n  TOKEN_FUNC,\n  TOKEN_RETURN,\n  TOKEN_FUNC_DEF,\n  TOKEN_STR,\n  TOKEN_NUMBER,\n  TOKEN_LPAREN,\n  TOKEN_RPAREN,\n  TOKEN_LBRACKET,\n  TOKEN_RBRACKET,\n  TOKEN_COMMA,\n  TOKEN_SEMICOLON,\n  /*for expr*/\n  TOKEN_QUESTION,\n  TOKEN_COLON,\n  TOKEN_EOF\n} token_type_t;\n\ntypedef struct _token_t {\n  const char* token;\n  token_type_t type;\n  uint32_t size;\n  bool_t valid;\n} token_t;\n\ntypedef struct _fscript_parser_t {\n  tk_object_t* obj;\n  token_t token;\n  char* code_id;\n  const char* str;\n  const char* cursor;\n\n  char c;\n  str_t temp;\n  uint16_t row;\n  uint16_t col;\n  tk_object_t* funcs_def;\n  fscript_func_call_t* first;\n  fscript_parser_error_t* error;\n  bool_t keep_func_name;\n  darray_t* symbols;\n} fscript_parser_t;\n\nstatic ret_t fexpr_parse(fscript_parser_t* parser, value_t* result);\nstatic ret_t fscript_parse_statements(fscript_parser_t* parser, fscript_func_call_t* acall);\nstatic fscript_func_call_t* fscript_func_call_create(fscript_parser_t* parser, const char* name,\n                                                     uint32_t size);\nstatic ret_t fscript_get_var(fscript_t* fscript, const char* name, value_t* value) {\n  value_set_str(value, NULL);\n  return_value_if_fail(name != NULL, RET_BAD_PARAMS);\n  if (*name == '$') {\n    name += 1;\n  }\n\n  if (strncmp(name, FSCRIPT_STR_GLOBAL_PREFIX, FSCRIPT_GLOBAL_PREFIX_LEN) == 0) {\n    return tk_object_get_prop(fscript_get_global_object(), name + FSCRIPT_GLOBAL_PREFIX_LEN, value);\n  }\n\n  return tk_object_get_prop(fscript->obj, name, value);\n}\n\nret_t fscript_set_var_default(fscript_t* fscript, const char* name, const value_t* value) {\n  if (strncmp(name, FSCRIPT_STR_GLOBAL_PREFIX, FSCRIPT_GLOBAL_PREFIX_LEN) == 0) {\n    return tk_object_set_prop(fscript_get_global_object(), name + FSCRIPT_GLOBAL_PREFIX_LEN, value);\n  }\n\n  return tk_object_set_prop(fscript->obj, name, value);\n}\n\nret_t fscript_set_var(fscript_t* fscript, const char* name, const value_t* value) {\n  if (s_hooks != NULL && s_hooks->set_var != NULL) {\n    return s_hooks->set_var(fscript, name, value);\n  } else {\n    return fscript_set_var_default(fscript, name, value);\n  }\n}\n\nstatic ret_t fscript_eval_arg(fscript_t* fscript, fscript_func_call_t* iter, uint32_t i,\n                              value_t* d) {\n  value_t v;\n  value_t* s = iter->args.args + i;\n  value_set_str(&v, NULL);\n  value_set_str(d, NULL);\n  if (s->type == VALUE_TYPE_FSCRIPT_ID) {\n    if ((iter->func == func_set_local || iter->func == func_set || iter->func == func_unset ||\n         iter->func == func_get) &&\n        i == 0) {\n      value_copy(d, s); /*func_set accept id/str as first param*/\n    } else {\n      const char* name = value_id(s);\n      if (value_id_index(s) >= 0) {\n        return fscript_locals_get(fscript, s, d);\n      }\n\n      if (fscript->loop_count > 0) {\n        if (tk_str_eq(name, \"break\")) {\n          fscript->breaked = TRUE;\n          return RET_OK;\n        } else if (tk_str_eq(name, \"continue\")) {\n          fscript->continued = TRUE;\n          return RET_OK;\n        }\n      } else if (tk_str_eq(name, \"return\")) {\n        fscript->returned = TRUE;\n        value_set_int(d, 0);\n        return RET_OK;\n      } else if (*name == '.') {\n        value_copy(d, s);\n        return RET_OK;\n      }\n\n      if (fscript_get_var(fscript, name, d) != RET_OK) {\n        if (name == NULL || *name != '$') {\n          char msg[128];\n          tk_snprintf(msg, sizeof(msg) - 1, \"not found var %s\", name);\n          fscript_set_error(fscript, RET_NOT_FOUND, \"get_var\", msg);\n          value_set_str(d, value_id(s));\n        } else if (*name == '$') {\n          value_reset(d);\n        }\n      }\n    }\n  } else if (s->type == VALUE_TYPE_FSCRIPT_FUNC) {\n    fscript_exec_func(fscript, NULL, value_func(s), d);\n  } else {\n    value_copy(d, s);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_if(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  uint32_t i = 0;\n  uint32_t n = 0;\n  value_t condition;\n  return_value_if_fail(iter->args.size >= 2, RET_FAIL);\n\n  n = iter->args.size / 2;\n  for (i = 0; i < n; i++) {\n    value_set_bool(&condition, FALSE);\n    return_value_if_fail(fscript_eval_arg(fscript, iter, 2 * i, &condition) == RET_OK, RET_FAIL);\n    if (value_bool(&condition)) {\n      return fscript_eval_arg(fscript, iter, 2 * i + 1, result);\n    }\n  }\n\n  if ((2 * i) < iter->args.size) {\n    return fscript_eval_arg(fscript, iter, 2 * i, result);\n  } else {\n    value_set_int(result, 0);\n    return RET_OK;\n  }\n}\n\nstatic ret_t fscript_exec_loop_body(fscript_t* fscript, fscript_func_call_t* iter, uint32_t start,\n                                    value_t* result, bool_t* done) {\n  uint32_t i = 1;\n  for (i = start; i < iter->args.size; i++) {\n    value_reset(result);\n    fscript_eval_arg(fscript, iter, i, result);\n    if (fscript->breaked) {\n      *done = TRUE;\n      fscript->breaked = FALSE;\n      break;\n    } else if (fscript->returned) {\n      *done = TRUE;\n    } else if (fscript->continued) {\n      fscript->continued = FALSE;\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_while_or_until(fscript_t* fscript, fscript_func_call_t* iter,\n                                         value_t* result, bool_t is_while) {\n  value_t condition;\n  bool_t done = FALSE;\n  FSCRIPT_FUNC_CHECK(iter->args.size > 1, RET_FAIL);\n\n  fscript->loop_count++;\n  value_set_int(&condition, 0);\n  while (!done && fscript_eval_arg(fscript, iter, 0, &condition) == RET_OK) {\n    if (is_while ? !value_bool(&condition) : value_bool(&condition)) {\n      break;\n    }\n    fscript_exec_loop_body(fscript, iter, 1, result, &done);\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\n\n/*repeat(a, 0, 100, 1) {*/\nstatic ret_t fscript_exec_repeat(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  value_t v;\n  int32_t start = 0;\n  int32_t end = 0;\n  int32_t delta = 0;\n  bool_t done = FALSE;\n  value_t* var = iter->args.args;\n  int32_t index = value_id_index(var);\n  const char* name = value_id(iter->args.args);\n  FSCRIPT_FUNC_CHECK(iter->args.size > 4, RET_FAIL);\n\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 1, &v) == RET_OK, RET_BAD_PARAMS);\n  start = value_int(&v);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 2, &v) == RET_OK, RET_BAD_PARAMS);\n  end = value_int(&v);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 3, &v) == RET_OK, RET_BAD_PARAMS);\n  delta = value_int(&v);\n\n  fscript->loop_count++;\n  while ((start != end) && !done) {\n    value_set_int(&v, start);\n    if (index >= 0) {\n      break_if_fail(fscript_locals_set(fscript, var, &v) == RET_OK);\n    } else {\n      break_if_fail(fscript_set_var(fscript, name, &v) == RET_OK);\n    }\n    fscript_exec_loop_body(fscript, iter, 4, result, &done);\n    start += delta;\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_for(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  value_t v;\n  bool_t done = FALSE;\n  FSCRIPT_FUNC_CHECK(iter->args.size > 3, RET_FAIL);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 0, &v) == RET_OK, RET_BAD_PARAMS);\n\n  fscript->loop_count++;\n  while (!done) {\n    break_if_fail(fscript_eval_arg(fscript, iter, 1, &v) == RET_OK);\n    if (!value_bool(&v)) {\n      break;\n    }\n    fscript_exec_loop_body(fscript, iter, 3, result, &done);\n    break_if_fail(fscript_eval_arg(fscript, iter, 2, &v) == RET_OK);\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_for_in(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  value_t v;\n  char prop[32];\n  uint32_t i = 0;\n  uint32_t n = 0;\n  bool_t done = FALSE;\n  object_t* obj = NULL;\n  value_t* var = iter->args.args;\n  int32_t index = value_id_index(var);\n  const char* name = value_id(var);\n\n  FSCRIPT_FUNC_CHECK(iter->args.size > 2, RET_FAIL);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 1, &v) == RET_OK, RET_BAD_PARAMS);\n  obj = value_object(&v);\n  FSCRIPT_FUNC_CHECK(obj != NULL, RET_FAIL);\n\n  fscript->loop_count++;\n  n = tk_object_get_prop_int(obj, TK_OBJECT_PROP_SIZE, 0);\n  for (i = 0; ((i < n) && !done); i++) {\n    tk_snprintf(prop, sizeof(prop) - 1, \"[%u]\", i);\n    break_if_fail(tk_object_get_prop(obj, prop, &v) == RET_OK);\n\n    if (index >= 0) {\n      fscript_locals_set(fscript, var, &v);\n    } else {\n      fscript_set_var(fscript, name, &v);\n    }\n    fscript_exec_loop_body(fscript, iter, 2, result, &done);\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_repeat_times(fscript_t* fscript, fscript_func_call_t* iter,\n                                       value_t* result) {\n  value_t v;\n  uint32_t i = 0;\n  uint32_t n = 0;\n  bool_t done = FALSE;\n  FSCRIPT_FUNC_CHECK(iter->args.size > 1, RET_FAIL);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 0, &v) == RET_OK, RET_BAD_PARAMS);\n\n  n = value_int(&v);\n  fscript->loop_count++;\n  for (i = 0; i < n && !done; i++) {\n    fscript_exec_loop_body(fscript, iter, 1, result, &done);\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\nstatic ret_t fscript_exec_while(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  return fscript_exec_while_or_until(fscript, iter, result, TRUE);\n}\n\nstatic ret_t fscript_exec_until(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  return fscript_exec_while_or_until(fscript, iter, result, FALSE);\n}\n\nstatic ret_t fscript_exec_core_func(fscript_t* fscript, fscript_func_call_t* iter,\n                                    value_t* result) {\n  if (iter->func == func_if) {\n    return fscript_exec_if(fscript, iter, result);\n  } else if (iter->func == func_while) {\n    return fscript_exec_while(fscript, iter, result);\n  } else if (iter->func == func_until) {\n    return fscript_exec_until(fscript, iter, result);\n  } else if (iter->func == func_repeat) {\n    return fscript_exec_repeat(fscript, iter, result);\n  } else if (iter->func == func_for) {\n    return fscript_exec_for(fscript, iter, result);\n  } else if (iter->func == func_for_in) {\n    return fscript_exec_for_in(fscript, iter, result);\n  } else if (iter->func == func_repeat_times) {\n    return fscript_exec_repeat_times(fscript, iter, result);\n  } else if (iter->func == func_function_def) {\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t fscript_exec_ext_func(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  value_t v;\n  uint32_t i = 0;\n  ret_t ret = RET_OK;\n  fscript_args_t args;\n  value_t args_values[5];\n\n  value_set_int(&v, 0);\n  if (iter->args.size <= ARRAY_SIZE(args_values)) {\n    memset(&args, 0x00, sizeof(args));\n    memset(&args_values, 0x00, sizeof(args_values));\n    args.capacity = ARRAY_SIZE(args_values);\n    args.args = args_values;\n  } else {\n    func_args_init(&args, iter->args.size);\n  }\n  args.size = iter->args.size;\n\n  return_value_if_fail((args.args != NULL || args.size == 0), RET_OOM);\n  for (i = 0; i < iter->args.size; i++) {\n    ret = fscript_eval_arg(fscript, iter, i, args.args + i);\n    if (fscript->breaked || fscript->continued || fscript->returned) {\n      value_deep_copy(result, args.args + i);\n      if (iter->args.size <= ARRAY_SIZE(args_values)) {\n        func_args_reset(&args);\n      } else {\n        func_args_deinit(&args);\n      }\n      return RET_OK;\n    }\n  }\n\n  value_set_int(result, 0);\n  fscript->curr = iter;\n  ret = iter->func(fscript, &args, result);\n\n  if (iter->args.size <= ARRAY_SIZE(args_values)) {\n    func_args_reset(&args);\n  } else {\n    func_args_deinit(&args);\n  }\n\n  return ret;\n}\n\nret_t fscript_exec_func_default(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  fscript->curr = iter;\n  result->type = VALUE_TYPE_INVALID;\n\n  if (iter->func == func_pending && iter->ctx != NULL) {\n    tk_object_t* obj = NULL;\n    void* ctx = iter->ctx;\n    char* name = (char*)(iter->ctx);\n    char* p = strchr(name, '.');\n    iter->ctx = NULL;\n\n    if (p != NULL) {\n      *p = '\\0';\n      obj = fscript_locals_get_object(fscript, name);\n      name = p + 1;\n    }\n    obj = obj != NULL ? obj : fscript->obj;\n    fscript_func_call_init_func(iter, obj, fscript->funcs_def, name, tk_strlen(name));\n\n    if (iter->func == func_noop) {\n      log_warn(\"not found func %s\\n\", name);\n    }\n    TKMEM_FREE(ctx);\n  }\n\n  if (fscript_exec_core_func(fscript, iter, result) == RET_NOT_FOUND) {\n    return_value_if_fail(fscript_exec_ext_func(fscript, iter, result) == RET_OK, RET_FAIL);\n  }\n\n  return RET_OK;\n}\n\nret_t fscript_exec(fscript_t* fscript, value_t* result) {\n  fscript_func_call_t* iter = NULL;\n  return_value_if_fail(fscript != NULL, RET_FAIL);\n\n  if (s_hooks != NULL && s_hooks->before_exec != NULL) {\n    s_hooks->before_exec(fscript);\n  }\n\n  value_set_str(result, NULL);\n  iter = fscript->first;\n  while (iter != NULL) {\n    break_if_fail(iter->func != NULL);\n    value_reset(result);\n    break_if_fail(fscript_exec_func(fscript, NULL, iter, result) == RET_OK);\n    if (fscript->returned) {\n      fscript->returned = FALSE;\n      break;\n    }\n    iter = iter->next;\n  }\n\n  if (s_hooks != NULL && s_hooks->after_exec != NULL) {\n    s_hooks->after_exec(fscript);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t on_free_func_def(void* ctx, const void* data) {\n  named_value_t* iter = (named_value_t*)(data);\n  fscript_function_def_destroy(value_func_def(&(iter->value)));\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_reset(fscript_t* fscript) {\n  return_value_if_fail(fscript != NULL, RET_FAIL);\n\n  if (s_hooks != NULL && s_hooks->on_deinit != NULL) {\n    s_hooks->on_deinit(fscript);\n  }\n\n  str_reset(&(fscript->str));\n  fscript_locals_destroy(fscript);\n  if (fscript->funcs_def != NULL) {\n    tk_object_foreach_prop(fscript->funcs_def, on_free_func_def, NULL);\n  }\n  TK_OBJECT_UNREF(fscript->funcs_def);\n  TKMEM_FREE(fscript->error_message);\n  fscript_func_call_destroy(fscript->first);\n  TKMEM_FREE(fscript->code_id);\n  memset(fscript, 0x00, sizeof(fscript_t));\n\n  return RET_OK;\n}\n\nret_t fscript_deinit(fscript_t* fscript) {\n  return fscript_reset(fscript);\n}\n\nret_t fscript_destroy(fscript_t* fscript) {\n  return_value_if_fail(fscript != NULL, RET_FAIL);\n  fscript_deinit(fscript);\n\n  TKMEM_FREE(fscript);\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_init(fscript_parser_t* parser, tk_object_t* obj, const char* str,\n                                 fscript_parser_error_t* error) {\n  memset(parser, 0x00, sizeof(fscript_parser_t));\n\n  parser->obj = obj;\n  parser->str = str;\n  parser->cursor = str;\n  parser->error = error;\n  parser->symbols = darray_create(5, NULL, (tk_compare_t)tk_str_cmp);\n\n  str_init(&(parser->temp), 64);\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_deinit(fscript_parser_t* parser) {\n  str_reset(&(parser->temp));\n  TKMEM_FREE(parser->code_id);\n  darray_destroy(parser->symbols);\n  fscript_func_call_destroy(parser->first);\n  if (parser->funcs_def != NULL) {\n    tk_object_foreach_prop(parser->funcs_def, on_free_func_def, NULL);\n  }\n  TK_OBJECT_UNREF(parser->funcs_def);\n\n  return RET_OK;\n}\n\nstatic char fscript_parser_get_char(fscript_parser_t* parser) {\n  char c = '\\0';\n  return_value_if_fail(parser != NULL, c);\n  if (parser->c) {\n    c = parser->c;\n    parser->c = '\\0';\n    return c;\n  }\n\n  c = parser->cursor[0];\n  if (c) {\n    if (c == '\\n') {\n      parser->row++;\n      parser->col = 0;\n    } else {\n      parser->col++;\n    }\n\n    parser->cursor++;\n  }\n\n  return c;\n}\n\nstatic ret_t fscript_parser_unget_char(fscript_parser_t* parser, char c) {\n  return_value_if_fail(parser->cursor > parser->str, RET_BAD_PARAMS);\n  parser->c = c;\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_set_error(fscript_parser_t* parser, const char* str) {\n  return_value_if_fail(parser != NULL && str != NULL, RET_BAD_PARAMS);\n\n  if (parser->error != NULL) {\n    parser->error->row = parser->row;\n    parser->error->col = parser->col;\n    parser->error->offset = parser->cursor - parser->str;\n    parser->error->message = tk_str_copy(parser->error->message, str);\n    parser->error->token = tk_str_copy(parser->error->token, parser->token.token);\n  }\n\n  log_warn(\"code: \\\"%s\\\"\\n\", parser->str);\n  log_warn(\"token: \\\"%s\\\"\\n\", parser->token.token);\n  log_warn(\"at line(%u) col (%u): %s\\n\", parser->row, parser->col, str);\n\n  return RET_FAIL;\n}\n\nstatic ret_t fscript_parser_skip_seperators(fscript_parser_t* parser) {\n  char c = '\\0';\n  do {\n    c = fscript_parser_get_char(parser);\n  } while (tk_isspace(c));\n  fscript_parser_unget_char(parser, c);\n\n  return RET_OK;\n}\n\n#define STR_CODE_ID_START \"code_id(\\\"\"\n#define STR_CODE_ID_END \"\\\")\"\n\nstatic ret_t fscript_parser_skip_line_comment(fscript_parser_t* parser) {\n  char c = '\\0';\n  str_t* str = &(parser->temp);\n  str_clear(str);\n  do {\n    c = fscript_parser_get_char(parser);\n    str_append_char(str, c);\n  } while (c != '\\0' && c != '\\r' && c != '\\n');\n\n  if (str->size > sizeof(STR_CODE_ID_START)) {\n    const char* end = NULL;\n    const char* start = strstr(str->str, STR_CODE_ID_START);\n    if (start != NULL) {\n      start += strlen(STR_CODE_ID_START);\n      end = strstr(start, STR_CODE_ID_END);\n      if (end != NULL) {\n        TKMEM_FREE(parser->code_id);\n        parser->code_id = tk_strndup(start, end - start);\n        log_debug(\"code_id:%s\\n\", parser->code_id);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_skip_block_comment(fscript_parser_t* parser) {\n  char c = '\\0';\n  do {\n    c = fscript_parser_get_char(parser);\n    if (c == '*' && parser->cursor[0] == '/') {\n      c = fscript_parser_get_char(parser);\n      break;\n    }\n  } while (c != '\\0');\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_skip_seperators_and_comments(fscript_parser_t* parser) {\n  char c = '\\0';\n\n  while (TRUE) {\n    fscript_parser_skip_seperators(parser);\n    c = fscript_parser_get_char(parser);\n    if (c == '/') {\n      if (parser->cursor[0] == '/') {\n        c = fscript_parser_get_char(parser);\n        fscript_parser_skip_line_comment(parser);\n      } else if (parser->cursor[0] == '*') {\n        c = fscript_parser_get_char(parser);\n        fscript_parser_skip_block_comment(parser);\n      } else {\n        break;\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (c) {\n    parser->cursor--;\n    if (parser->col > 0) {\n      parser->col--;\n    }\n  }\n\n  return RET_OK;\n}\n\n#define TOKEN_INIT(t, ttype, str) \\\n  t->type = ttype;                \\\n  t->token = str->str;            \\\n  t->size = str->size;\n\nstatic ret_t fscript_parser_parse_str(fscript_parser_t* parser, char quota) {\n  char c = '\\0';\n  bool_t escape = FALSE;\n  str_t* str = &(parser->temp);\n  token_t* t = &(parser->token);\n\n  str_set(str, \"\");\n  do {\n    c = fscript_parser_get_char(parser);\n    if (escape) {\n      if (c == 'r') {\n        str_append_char(str, '\\r');\n      } else if (c == 'n') {\n        str_append_char(str, '\\n');\n      } else if (c == 't') {\n        str_append_char(str, '\\t');\n      } else {\n        str_append_char(str, c);\n      }\n      escape = FALSE;\n      continue;\n    }\n\n    if (c == quota || c == '\\0') {\n      break;\n    } else if (c == '\\\\') {\n      escape = TRUE;\n      continue;\n    }\n    str_append_char(str, c);\n  } while (TRUE);\n\n  TOKEN_INIT(t, TOKEN_STR, str);\n  if (c != '\\0' && c != quota) {\n    fscript_parser_unget_char(parser, c);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_get_non_ascii_char(fscript_parser_t* parser, str_t* str, uint8_t c,\n                                               uint32_t n) {\n  str_append_char(str, c);\n  while (n > 1) {\n    c = fscript_parser_get_char(parser);\n    str_append_char(str, c);\n    n--;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_parse_id_or_number(fscript_parser_t* parser, token_type_t def_type) {\n  char c = '\\0';\n  str_t* str = &(parser->temp);\n  token_t* t = &(parser->token);\n  c = fscript_parser_get_char(parser);\n\n  str_set(str, \"\");\n  if (c) {\n    int32_t n = tk_utf8_get_bytes_of_leading((uint8_t)c);\n    fscript_parser_get_non_ascii_char(parser, str, c, n);\n  }\n\n  do {\n    c = fscript_parser_get_char(parser);\n    if (tk_isxdigit(c) || tk_isdigit(c) || tk_isalpha(c) || c == '.' || c == '_' || c == '[' ||\n        c == ']' || c == '#') {\n      str_append_char(str, c);\n    } else {\n      int32_t n = tk_utf8_get_bytes_of_leading((uint8_t)c);\n      if (n > 1) {\n        fscript_parser_get_non_ascii_char(parser, str, c, n);\n      } else {\n        break;\n      }\n    }\n  } while (TRUE);\n\n  if (tk_isspace(c)) {\n    fscript_parser_skip_seperators_and_comments(parser);\n    c = fscript_parser_get_char(parser);\n  }\n\n  str_trim(str, \" \\t\\r\\n\");\n  TOKEN_INIT(t, (c == '(' ? TOKEN_FUNC : def_type), str);\n  if (c != '\\0') {\n    fscript_parser_unget_char(parser, c);\n  }\n\n  if (t->type == TOKEN_ID) {\n    if (tk_str_eq(t->token, \"function\")) {\n      t->type = TOKEN_FUNC_DEF;\n    } else if (tk_str_eq(t->token, \"var\")) {\n      t->type = TOKEN_VAR;\n    } else if (tk_str_eq(t->token, \"return\")) {\n      t->type = TOKEN_RETURN;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_get_unary(fscript_parser_t* parser, char c, str_t* str) {\n  do {\n    fscript_parser_skip_seperators_and_comments(parser);\n    c = fscript_parser_get_char(parser);\n    if (c == str->str[0]) {\n      str_append_char(str, c);\n    } else {\n      fscript_parser_unget_char(parser, c);\n      break;\n    }\n  } while (TRUE);\n\n  return RET_OK;\n}\n\nstatic token_t* fscript_parser_get_token_ex(fscript_parser_t* parser, bool_t operator) {\n  char c = 0;\n  str_t* str = &(parser->temp);\n  token_t* t = &(parser->token);\n\n  if (t->valid) {\n    t->valid = FALSE;\n    return t;\n  }\n\n  fscript_parser_skip_seperators_and_comments(parser);\n  c = fscript_parser_get_char(parser);\n\n  str_set_with_len(str, &c, 1);\n  t->token = str->str;\n  t->size = 1;\n  switch (c) {\n    case '\\0': {\n      t->type = TOKEN_EOF;\n      return NULL;\n    }\n    case '(': {\n      t->type = TOKEN_LPAREN;\n      return t;\n    }\n    case ')': {\n      t->type = TOKEN_RPAREN;\n      return t;\n    }\n    case '{': {\n      t->type = TOKEN_LBRACKET;\n      return t;\n    }\n    case '}': {\n      t->type = TOKEN_RBRACKET;\n      return t;\n    }\n    case ',': {\n      t->type = TOKEN_COMMA;\n      return t;\n    }\n    case ';': {\n      t->type = TOKEN_SEMICOLON;\n      return t;\n    }\n    case '?': {\n      t->type = TOKEN_QUESTION;\n      return t;\n    }\n    case ':': {\n      t->type = TOKEN_COLON;\n      return t;\n    }\n    case '*':\n    case '/':\n    case '%':\n    case '^':\n    case '#': {\n      t->type = TOKEN_FUNC;\n      return t;\n    }\n    case '>':\n    case '<':\n    case '=': {\n      c = fscript_parser_get_char(parser);\n      if (str->str[0] == c || c == '=') {\n        str_append_char(str, c);\n      } else {\n        fscript_parser_unget_char(parser, c);\n      }\n      t->type = TOKEN_FUNC;\n      t->size = str->size;\n      return t;\n    }\n    case '~':\n    case '!': {\n      c = fscript_parser_get_char(parser);\n      if (c == '=') {\n        str_append_char(str, c);\n      } else {\n        fscript_parser_unget_char(parser, c);\n        fscript_parser_get_unary(parser, c, str);\n      }\n      TOKEN_INIT(t, TOKEN_FUNC, str);\n      return t;\n    }\n    case '|':\n    case '&': {\n      c = fscript_parser_get_char(parser);\n      if (c == str->str[0]) {\n        str_append_char(str, c);\n      } else {\n        fscript_parser_unget_char(parser, c);\n      }\n\n      t->type = TOKEN_FUNC;\n      t->size = str->size;\n      return t;\n    }\n    case '\\\"':\n    case '\\'': {\n      fscript_parser_parse_str(parser, c);\n      return t;\n    }\n    default: {\n      if (c == '+' || c == '-') {\n        fscript_parser_skip_seperators_and_comments(parser);\n        if (operator|| !tk_isdigit(parser->cursor[0])) {\n          fscript_parser_get_unary(parser, c, str);\n          TOKEN_INIT(t, TOKEN_FUNC, str);\n        } else {\n          fscript_parser_unget_char(parser, c);\n          fscript_parser_parse_id_or_number(parser, TOKEN_NUMBER);\n        }\n      } else if (tk_isdigit(c)) {\n        fscript_parser_unget_char(parser, c);\n        fscript_parser_parse_id_or_number(parser, TOKEN_NUMBER);\n      } else {\n        fscript_parser_unget_char(parser, c);\n        fscript_parser_parse_id_or_number(parser, TOKEN_ID);\n      }\n      return t;\n    }\n  }\n}\n\nstatic token_t* fscript_parser_get_token(fscript_parser_t* parser) {\n  return fscript_parser_get_token_ex(parser, FALSE);\n}\n\nstatic ret_t fscript_parser_expect_token(fscript_parser_t* parser, token_type_t type,\n                                         const char* msg) {\n  token_t* t = fscript_parser_get_token(parser);\n  if (t == NULL || t->type != type) {\n    return fscript_parser_set_error(parser, msg);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_unget_token(fscript_parser_t* parser) {\n  if (parser->token.type != TOKEN_EOF) {\n    parser->token.valid = TRUE;\n  }\n  return RET_OK;\n}\n\nstatic ret_t token_to_value(fscript_parser_t* parser, token_t* t, value_t* v) {\n  if (t->type == TOKEN_NUMBER) {\n    char number[64];\n    tk_strncpy_s(number, sizeof(number) - 1, t->token, t->size);\n    if (strchr(number, '.') != NULL) {\n      value_set_double(v, tk_atof(number));\n    } else {\n      uint64_t vv = 0;\n      const char* str = number;\n      bool_t has_minus = FALSE;\n      if (*str == '-') {\n        has_minus = TRUE;\n        str++;\n      }\n\n      vv = tk_atoul(str);\n      if (vv < INT_MAX) {\n        if (has_minus) {\n          value_set_int32(v, -vv);\n        } else {\n          value_set_int32(v, vv);\n        }\n      } else if (vv < UINT32_MAX) {\n        if (has_minus) {\n          value_set_int64(v, -vv);\n        } else {\n          value_set_uint32(v, vv);\n        }\n      } else {\n        if (has_minus) {\n          value_set_int64(v, -vv);\n        } else {\n          value_set_uint64(v, vv);\n        }\n      }\n    }\n  } else if (t->type == TOKEN_STR) {\n    value_dup_str_with_len(v, t->token, t->size);\n  } else if (t->type == TOKEN_ID) {\n    if (t->token[0] == 't' && strncmp(t->token, \"true\", 4) == 0) {\n      value_set_bool(v, TRUE);\n    } else if (t->token[0] == 'f' && strncmp(t->token, \"false\", 5) == 0) {\n      value_set_bool(v, FALSE);\n    } else {\n      const char* name = NULL;\n      const char* p = NULL;\n      value_set_id(v, t->token, t->size);\n      name = value_id(v);\n      p = strchr(name, '.');\n      if (p != NULL) {\n        char first_name[TK_NAME_LEN + 1];\n        tk_strncpy_s(first_name, TK_NAME_LEN, name, p - name);\n        value_id_suboffset(v) = p - name + 1;\n        value_id_index(v) = darray_find_index(parser->symbols, (void*)first_name);\n      } else {\n        value_id_suboffset(v) = 0;\n        value_id_index(v) = darray_find_index(parser->symbols, (void*)name);\n      }\n    }\n  } else {\n    return RET_FAIL;\n  }\n\n  return RET_OK;\n}\n\nret_t fscript_eval(tk_object_t* obj, const char* script, value_t* result) {\n  value_t v;\n  ret_t ret = RET_OK;\n  fscript_t* fscript = fscript_create(obj, script);\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n\n  if (fscript_exec(fscript, &v) == RET_OK && result != NULL) {\n    value_deep_copy(result, &v);\n  }\n  value_reset(&v);\n  fscript_destroy(fscript);\n\n  return ret;\n}\n\n/*expr parser*/\nstatic ret_t fexpr_parse_block(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  value_t v;\n  fscript_func_call_t* statements = fscript_func_call_create(parser, \"expr\", 4);\n  return_value_if_fail(statements != NULL, RET_OOM);\n\n  if (fscript_parse_statements(parser, statements) == RET_OK) {\n    func_args_push(&(acall->args), value_set_func(&v, statements));\n  } else {\n    fscript_func_call_destroy(statements);\n  }\n\n  fscript_parser_expect_token(parser, TOKEN_RBRACKET, \"expect \\\"}\\\"\");\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_function(fscript_parser_t* parser, value_t* result);\n\nstatic ret_t fexpr_parse_if(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  uint32_t i = 0;\n  token_t* t = NULL;\n  fexpr_parse_block(parser, acall);\n  t = fscript_parser_get_token(parser);\n\n  if (t != NULL && t->type == TOKEN_ID && tk_str_eq(t->token, \"else\")) {\n    t = fscript_parser_get_token(parser);\n    if (t != NULL && t->type == TOKEN_FUNC && tk_str_eq(t->token, \"if\")) {\n      value_t result;\n      fscript_func_call_t* elseif = NULL;\n      fscript_parser_unget_token(parser);\n      return_value_if_fail(fexpr_parse_function(parser, &result) == RET_OK, RET_FAIL);\n      elseif = value_func(&result);\n      for (i = 0; i < elseif->args.size; i++) {\n        func_args_push(&(acall->args), elseif->args.args + i);\n      }\n      elseif->args.size = 0;\n      fscript_func_call_destroy(elseif);\n      return RET_OK;\n    } else {\n      fscript_parser_unget_token(parser);\n      fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\");\n      return fexpr_parse_block(parser, acall);\n    }\n  } else {\n    fscript_parser_unget_token(parser);\n    return RET_OK;\n  }\n}\n\nstatic ret_t fexpr_parse_function(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  fscript_args_t* args = NULL;\n  token_t* t = fscript_parser_get_token(parser);\n  fscript_func_call_t* acall = NULL;\n  if (t->token[0] == '-' && t->size == 1) {\n    acall = fscript_func_call_create(parser, \"minus\", 5);\n  } else {\n    acall = fscript_func_call_create(parser, t->token, t->size);\n  }\n  value_set_func(result, acall);\n  return_value_if_fail(acall != NULL, RET_BAD_PARAMS);\n\n  args = &(acall->args);\n  return_value_if_fail(fscript_parser_expect_token(parser, TOKEN_LPAREN, \"expect \\\"(\\\"\") == RET_OK,\n                       RET_FAIL);\n\n  do {\n    t = fscript_parser_get_token(parser);\n    if (t == NULL) {\n      return fscript_parser_set_error(parser, \"expect \\\")\\\"\");\n    }\n\n    if (t->type == TOKEN_RPAREN) {\n      break;\n    } else {\n      fscript_parser_unget_token(parser);\n    }\n    value_set_int(&v, 0);\n    return_value_if_fail(fexpr_parse(parser, &v) == RET_OK, RET_FAIL);\n    func_args_push(args, &v);\n    t = fscript_parser_get_token(parser);\n\n    if (t == NULL) {\n      return fscript_parser_set_error(parser, \"expect \\\")\\\"\");\n    } else if (t->type == TOKEN_RPAREN) {\n      break;\n    }\n    fscript_parser_unget_token(parser);\n    if (acall->func == func_for) {\n      fscript_parser_expect_token(parser, TOKEN_SEMICOLON, \"expect \\\";\\\"\");\n    } else {\n      fscript_parser_expect_token(parser, TOKEN_COMMA, \"expect \\\",\\\"\");\n    }\n  } while (TRUE);\n\n  if (acall->func == func_if && acall->args.size == 1) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_if(parser, acall);\n    }\n  } else if ((acall->func == func_while || acall->func == func_until ||\n              acall->func == func_repeat_times) &&\n             acall->args.size == 1) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_block(parser, acall);\n    }\n  } else if (acall->func == func_for && acall->args.size == 3) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_block(parser, acall);\n    }\n  } else if (acall->func == func_for_in && acall->args.size == 2) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_block(parser, acall);\n    }\n  } else if (acall->func == func_repeat && acall->args.size == 4) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_block(parser, acall);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_term(fscript_parser_t* parser, value_t* result) {\n  ret_t ret = RET_OK;\n  token_t* t = fscript_parser_get_token(parser);\n  value_set_int(result, 0);\n  return_value_if_fail(t != NULL, RET_BAD_PARAMS);\n\n  if (t->type == TOKEN_NUMBER || t->type == TOKEN_ID || t->type == TOKEN_STR) {\n    if (t->type == TOKEN_ID && t->token[0] == '.') {\n      fscript_parser_set_error(parser, \"var can't begin with '.'\");\n    }\n    ret = token_to_value(parser, t, result);\n  } else if (t->type == TOKEN_FUNC) {\n    fscript_parser_unget_token(parser);\n    ret = fexpr_parse_function(parser, result);\n  } else if (t->type == TOKEN_RETURN) {\n    fscript_func_call_t* acall = fscript_func_call_create(parser, \"return\", 6);\n    return_value_if_fail(acall != NULL, RET_OOM);\n    value_set_func(result, acall);\n    t = fscript_parser_get_token(parser);\n    if (t != NULL && t->type != TOKEN_SEMICOLON && t->type != TOKEN_RBRACKET) {\n      value_t v;\n      value_set_int(&v, 0);\n      fscript_parser_unget_token(parser);\n      if (fexpr_parse(parser, &v) == RET_OK) {\n        func_args_push(&(acall->args), &v);\n      }\n    } else {\n      fscript_parser_unget_token(parser);\n    }\n  } else if (t->type == TOKEN_LPAREN) {\n    ret = fexpr_parse(parser, result);\n    return_value_if_fail(ret == RET_OK, ret);\n    ret = fscript_parser_expect_token(parser, TOKEN_RPAREN, \"expect )\");\n  } else {\n    fscript_parser_unget_token(parser);\n  }\n\n  return ret;\n}\n\nstatic ret_t fexpr_parse_unary(fscript_parser_t* parser, value_t* result) {\n  char c = '\\0';\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n  token_t* t = fscript_parser_get_token_ex(parser, FALSE);\n  if (t == NULL || t->type == TOKEN_EOF) {\n    return RET_OK;\n  }\n\n  c = t->token[0];\n  if (t->type == TOKEN_FUNC && (c == '!' || c == '~' || c == '-')) {\n    value_t v;\n    uint32_t i = 0;\n    bool_t valid = FALSE;\n    for (i = 0; i < t->size; i++) {\n      if (t->token[i] != c) {\n        return fscript_parser_set_error(parser, \"unexpected token\");\n      } else {\n        valid = !valid;\n      }\n    }\n\n    if (valid) {\n      acall = fscript_func_call_create(parser, &c, 1);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      value_set_func(result, acall);\n      return_value_if_fail(fexpr_parse_term(parser, &v) == RET_OK, RET_FAIL);\n      func_args_push(args, &v);\n    } else {\n      return_value_if_fail(fexpr_parse_term(parser, result) == RET_OK, RET_FAIL);\n    }\n  } else {\n    fscript_parser_unget_token(parser);\n    return_value_if_fail(fexpr_parse_term(parser, result) == RET_OK, RET_FAIL);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fsexpr_parse_product(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n  return_value_if_fail(fexpr_parse_unary(parser, result) == RET_OK, RET_FAIL);\n\n  while (TRUE) {\n    t = fscript_parser_get_token_ex(parser, TRUE);\n    if (t == NULL || t->type != TOKEN_FUNC) {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n\n    if (t->token[0] == '*' || t->token[0] == '/' || t->token[0] == '%') {\n      acall = fscript_func_call_create(parser, t->token, t->size);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      func_args_push(args, result);\n      value_set_func(result, acall);\n      v.type = VALUE_TYPE_INVALID;\n      fexpr_parse_unary(parser, &v);\n      if (v.type == VALUE_TYPE_INVALID) {\n        fscript_parser_set_error(parser, \"expect an expression\");\n      } else {\n        func_args_push(args, &v);\n      }\n    } else {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_sum(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n  return_value_if_fail(fsexpr_parse_product(parser, result) == RET_OK, RET_FAIL);\n\n  while (TRUE) {\n    t = fscript_parser_get_token_ex(parser, TRUE);\n    if (t == NULL || t->type != TOKEN_FUNC) {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n\n    if (t->token[0] == '+' || t->token[0] == '-') {\n      parser->token.valid = FALSE;\n      acall = fscript_func_call_create(parser, t->token, t->size);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      func_args_push(args, result);\n      value_set_func(result, acall);\n      v.type = VALUE_TYPE_INVALID;\n      fsexpr_parse_product(parser, &v);\n      if (v.type == VALUE_TYPE_INVALID) {\n        fscript_parser_set_error(parser, \"expect an expression\");\n      } else {\n        func_args_push(args, &v);\n      }\n    } else {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_compare(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n\n  value_set_int(result, 0);\n  return_value_if_fail(fexpr_parse_sum(parser, result) == RET_OK, RET_FAIL);\n\n  t = fscript_parser_get_token_ex(parser, TRUE);\n  if (t == NULL || t->type != TOKEN_FUNC || tk_str_eq(t->token, \"=\")) {\n    fscript_parser_unget_token(parser);\n    return RET_OK;\n  }\n\n  if (t->token[0] == '>' || t->token[0] == '<' || t->token[0] == '=' ||\n      (t->token[0] == '!' && t->token[1] == '=')) {\n    acall = fscript_func_call_create(parser, t->token, t->size);\n    return_value_if_fail(acall != NULL, RET_OOM);\n    args = &(acall->args);\n    func_args_push(args, result);\n    value_set_func(result, acall);\n    v.type = VALUE_TYPE_INVALID;\n    fexpr_parse_sum(parser, &v);\n    if (v.type == VALUE_TYPE_INVALID) {\n      fscript_parser_set_error(parser, \"expect an expression\");\n    } else {\n      func_args_push(args, &v);\n    }\n  } else {\n    fscript_parser_unget_token(parser);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_logic(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n\n  value_set_int(result, 0);\n  return_value_if_fail(fexpr_parse_compare(parser, result) == RET_OK, RET_FAIL);\n\n  while (TRUE) {\n    t = fscript_parser_get_token_ex(parser, TRUE);\n    if (t == NULL || t->type != TOKEN_FUNC || tk_str_eq(t->token, \"=\")) {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n\n    if (t->token[0] == '|' || t->token[0] == '&' || t->token[0] == '^') {\n      acall = fscript_func_call_create(parser, t->token, t->size);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      func_args_push(args, result);\n      value_set_func(result, acall);\n      v.type = VALUE_TYPE_INVALID;\n      fexpr_parse_compare(parser, &v);\n      if (v.type == VALUE_TYPE_INVALID) {\n        fscript_parser_set_error(parser, \"expect an expression\");\n      } else {\n        func_args_push(args, &v);\n      }\n    } else {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_question(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  ret_t ret = RET_OK;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n\n  value_set_str(&v, NULL);\n  if (fexpr_parse_logic(parser, result) == RET_OK) {\n    t = fscript_parser_get_token(parser);\n    if (t && t->type == TOKEN_QUESTION) {\n      acall = fscript_func_call_create(parser, \"if\", 2);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      func_args_push(args, result);\n      value_set_func(result, acall);\n\n      value_reset(&v);\n      return_value_if_fail(fexpr_parse_logic(parser, &v) == RET_OK, RET_FAIL);\n      func_args_push(args, &v);\n\n      return_value_if_fail(fscript_parser_expect_token(parser, TOKEN_COLON, \"expect :\") == RET_OK,\n                           RET_FAIL);\n      return_value_if_fail(fexpr_parse_logic(parser, &v) == RET_OK, RET_FAIL);\n      func_args_push(args, &v);\n    } else {\n      fscript_parser_unget_token(parser);\n    }\n  } else {\n    ret = RET_FAIL;\n  }\n\n  return ret;\n}\n\nstatic ret_t fexpr_parse(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  bool_t is_local = FALSE;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n  value_set_int(result, 0);\n\n  t = fscript_parser_get_token_ex(parser, TRUE);\n  if (t == NULL || t->type == TOKEN_RBRACKET || t->type == TOKEN_SEMICOLON) {\n    value_reset(result);\n    fscript_parser_unget_token(parser);\n    return RET_OK;\n  }\n\n  if (t->type == TOKEN_VAR) {\n    is_local = TRUE;\n  } else {\n    fscript_parser_unget_token(parser);\n  }\n  return_value_if_fail(fexpr_parse_question(parser, result) == RET_OK, RET_FAIL);\n\n  t = fscript_parser_get_token_ex(parser, TRUE);\n  if (t != NULL && tk_str_eq(t->token, \"=\")) {\n    const char* name = is_local ? \"set_local\" : \"=\";\n    acall = fscript_func_call_create(parser, name, strlen(name));\n    return_value_if_fail(acall != NULL, RET_OOM);\n    args = &(acall->args);\n    func_args_push(args, result);\n    value_set_func(result, acall);\n    v.type = VALUE_TYPE_INVALID;\n    fexpr_parse_question(parser, &v);\n    if (v.type == VALUE_TYPE_INVALID) {\n      fscript_parser_set_error(parser, \"expect an expression\");\n    } else {\n      func_args_push(args, &v);\n    }\n\n    if (is_local) {\n      darray_push_unique(parser->symbols, (void*)value_id(args->args));\n    }\n  } else {\n    fscript_parser_unget_token(parser);\n  }\n\n  return RET_OK;\n}\n\nstatic fscript_t* fscript_init_with_parser(fscript_t* fscript, fscript_parser_t* parser) {\n  fscript = fscript != NULL ? fscript : TKMEM_ZALLOC(fscript_t);\n  return_value_if_fail(fscript != NULL, NULL);\n  fscript->str = parser->temp;\n  fscript->obj = parser->obj;\n  fscript->first = parser->first;\n  fscript->funcs_def = parser->funcs_def;\n  fscript->code_id = parser->code_id;\n  fscript->lines = parser->row + 1;\n\n  if (s_hooks != NULL && s_hooks->on_init != NULL) {\n    s_hooks->on_init(fscript, parser->str);\n  }\n\n  parser->obj = NULL;\n  parser->first = NULL;\n  parser->temp.str = NULL;\n  parser->funcs_def = NULL;\n  parser->code_id = NULL;\n\n  return fscript;\n}\n\nstatic ret_t func_function(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  ret_t ret = RET_OK;\n  darray_t* saved_locals = fscript->locals;\n  fscript_function_def_t* func_def = (fscript_function_def_t*)(fscript->curr->ctx);\n  fscript_func_call_t* func = func_def->body;\n\n  func->func = func_noop;\n  fscript->locals = NULL;\n  if (func_def->params.size > 0 && args->size > 0) {\n    uint32_t i = 0;\n    uint32_t n = tk_min(func_def->params.size, args->size);\n    for (i = 0; i < n; i++) {\n      const value_t* value = args->args + i;\n      const char* name = (const char*)(func_def->params.elms[i]);\n      fscript_locals_create(fscript, name, value);\n    }\n  }\n\n  ret = fscript_exec_func(fscript, func_def->name, func, result);\n\n  fscript_locals_destroy(fscript);\n  fscript->locals = saved_locals;\n  fscript->returned = FALSE;\n\n  return ret;\n}\n\nstatic ret_t fscript_parse_function_def(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  value_t v;\n  char func_name[TK_NAME_LEN + 1];\n  fscript_function_def_t* func_def = NULL;\n  fscript_func_call_t* statements = NULL;\n  token_t* t = fscript_parser_get_token(parser);\n  darray_t* saved_symbols = parser->symbols;\n\n  if (t->type != TOKEN_FUNC) {\n    return fscript_parser_set_error(parser, \"expect function name\\n\");\n  }\n  tk_strncpy(func_name, t->token, TK_NAME_LEN);\n  fscript_parser_expect_token(parser, TOKEN_LPAREN, \"expect \\\"(\\\"\");\n  if (parser->funcs_def == NULL) {\n    parser->funcs_def = object_default_create();\n  }\n\n  if (tk_object_get_prop(parser->funcs_def, func_name, &v) == RET_OK) {\n    return fscript_parser_set_error(parser, \"duplicate function\\n\");\n  }\n  statements = fscript_func_call_create(parser, \"func\", 4);\n  return_value_if_fail(statements != NULL, RET_OOM);\n\n  func_def = fscript_function_def_create(func_name, statements);\n  return_value_if_fail(func_def != NULL, RET_OOM);\n  value_set_func_def(&v, func_def);\n  tk_object_set_prop(parser->funcs_def, func_name, &v);\n\n  parser->symbols = darray_create(5, NULL, (tk_compare_t)tk_str_cmp);\n  while (TRUE) {\n    t = fscript_parser_get_token(parser);\n    if (t == NULL || t->type == TOKEN_EOF || t->type == TOKEN_RPAREN) {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n    if (t->type == TOKEN_ID) {\n      fscript_function_def_add_param(func_def, t->token);\n      darray_push_unique(parser->symbols,\n                         (void*)darray_get(&(func_def->params), func_def->params.size - 1));\n    } else if (t->type == TOKEN_COMMA) {\n    } else {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n  }\n  fscript_parser_expect_token(parser, TOKEN_RPAREN, \"expect \\\")\\\"\");\n  fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\");\n  fscript_parse_statements(parser, statements);\n  fscript_parser_expect_token(parser, TOKEN_RBRACKET, \"expect \\\"}\\\"\");\n  darray_destroy(parser->symbols);\n  parser->symbols = saved_symbols;\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parse_statements(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  value_t v;\n  ret_t ret = RET_OK;\n  fscript_args_t* args = NULL;\n  return_value_if_fail(parser != NULL && acall != NULL, RET_BAD_PARAMS);\n\n  args = &(acall->args);\n\n  do {\n    token_t* t = NULL;\n    value_set_int(&v, 0);\n    ret = fexpr_parse(parser, &v);\n    if (ret == RET_OK) {\n      if (v.type != VALUE_TYPE_INVALID) {\n        func_args_push(args, &v);\n      }\n      t = fscript_parser_get_token(parser);\n      if (t == NULL) {\n        break;\n      }\n\n      if (t->type == TOKEN_FUNC || t->type == TOKEN_ID || t->type == TOKEN_NUMBER ||\n          t->type == TOKEN_STR || t->type == TOKEN_VAR || t->type == TOKEN_RETURN) {\n        fscript_parser_unget_token(parser);\n      } else if (t->type == TOKEN_RBRACKET || t->type == TOKEN_FUNC_DEF) {\n        fscript_parser_unget_token(parser);\n        break;\n      } else if (t->type != TOKEN_COMMA && t->type != TOKEN_SEMICOLON) {\n        return fscript_parser_set_error(parser, \"unexpected token\\n\");\n      }\n    } else {\n      if (v.type == VALUE_TYPE_FSCRIPT_FUNC) {\n        fscript_func_call_destroy(value_func(&v));\n      } else {\n        value_reset(&v);\n      }\n\n      break;\n    }\n  } while (parser->token.type != TOKEN_EOF);\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parse_all(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  ret_t ret = RET_OK;\n  while (ret == RET_OK) {\n    token_t* t = fscript_parser_get_token(parser);\n    if (t && t->type == TOKEN_FUNC_DEF) {\n      ret = fscript_parse_function_def(parser, acall);\n    } else if (t == NULL || t->type == TOKEN_EOF) {\n      break;\n    } else if (t->type == TOKEN_RBRACKET) {\n      fscript_parser_set_error(parser, \"unexpected token\");\n      break;\n    } else {\n      fscript_parser_unget_token(parser);\n      ret = fscript_parse_statements(parser, acall);\n    }\n  }\n\n  return ret;\n}\n\nfscript_parser_error_t* fscript_parser_error_init(fscript_parser_error_t* error) {\n  return_value_if_fail(error != NULL, NULL);\n  memset(error, 0x00, sizeof(fscript_parser_error_t));\n\n  return error;\n}\n\nret_t fscript_parser_error_deinit(fscript_parser_error_t* error) {\n  return_value_if_fail(error != NULL, RET_BAD_PARAMS);\n  TKMEM_FREE(error->token);\n  TKMEM_FREE(error->message);\n\n  return RET_OK;\n}\n\nret_t fscript_syntax_check(tk_object_t* obj, const char* script, fscript_parser_error_t* error) {\n  ret_t ret = RET_OK;\n  fscript_parser_t parser;\n  return_value_if_fail(obj != NULL && script != NULL && error != NULL, RET_BAD_PARAMS);\n  fscript_parser_error_init(error);\n  fscript_parser_init(&parser, obj, script, error);\n\n  parser.first = fscript_func_call_create(&parser, \"expr\", 4);\n  ret = fscript_parse_all(&parser, parser.first);\n  fscript_parser_deinit(&parser);\n\n  return ret;\n}\n\nstatic fscript_t* fscript_load(fscript_t* fscript, tk_object_t* obj, const char* script,\n                               const char* first_call_name, bool_t keep_func_name) {\n  ret_t ret = RET_OK;\n  fscript_parser_t parser;\n  fscript_parser_error_t error;\n  return_value_if_fail(script != NULL, NULL);\n\n  fscript_parser_error_init(&error);\n  fscript_parser_init(&parser, obj, script, &error);\n  parser.keep_func_name = keep_func_name;\n  parser.first = fscript_func_call_create(&parser, first_call_name, strlen(first_call_name));\n  ret = fscript_parse_all(&parser, parser.first);\n  if (ret == RET_OK) {\n    fscript = fscript_init_with_parser(fscript, &parser);\n    fscript_parser_deinit(&parser);\n  } else {\n    log_warn(\"parser error:%s\\n\", script);\n    fscript_parser_deinit(&parser);\n  }\n  fscript_parser_error_deinit(&error);\n\n  return fscript;\n}\n\nret_t fscript_reload(fscript_t* fscript, const char* script) {\n  tk_object_t* obj = NULL;\n  return_value_if_fail(fscript != NULL && fscript->obj != NULL && script != NULL, RET_BAD_PARAMS);\n  obj = fscript->obj;\n  fscript_reset(fscript);\n\n  return fscript_load(fscript, obj, script, \"expr\", FALSE) != NULL ? RET_OK : RET_FAIL;\n}\n\nfscript_t* fscript_init(fscript_t* fscript, tk_object_t* obj, const char* script,\n                        const char* first_call_name, bool_t keep_func_name) {\n  return fscript_load(fscript, obj, script, first_call_name, keep_func_name);\n}\n\nfscript_t* fscript_create_ex(tk_object_t* obj, const char* script, bool_t keep_func_name) {\n  return fscript_load(NULL, obj, script, \"expr\", keep_func_name);\n}\n\nfscript_t* fscript_create(tk_object_t* obj, const char* script) {\n  return fscript_create_ex(obj, script, FALSE);\n}\n\n/*functions*/\nstatic ret_t func_get_last_error(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  if (fscript->error_code != RET_OK) {\n    tk_object_t* obj = object_default_create();\n    return_value_if_fail(obj != NULL, RET_OOM);\n    tk_object_set_prop_int(obj, \"col\", fscript->error_col);\n    tk_object_set_prop_int(obj, \"line\", fscript->error_row);\n    tk_object_set_prop_int(obj, \"code\", fscript->error_code);\n    tk_object_set_prop_str(obj, \"message\", fscript->error_message);\n    value_set_object(result, obj);\n    result->free_handle = TRUE;\n  } else {\n    value_set_int(result, 0);\n    value_reset(result);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_has_error(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  value_set_bool(result, fscript->error_code != RET_OK);\n  return RET_OK;\n}\n\nstatic ret_t func_clear_error(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  fscript_set_error(fscript, RET_OK, NULL, NULL);\n  return RET_OK;\n}\n\nstatic ret_t func_sum(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  double v = 0;\n  uint32_t i = 0;\n  bool_t has_str = FALSE;\n  bool_t has_float = FALSE;\n  FSCRIPT_FUNC_CHECK(args->size > 0, RET_BAD_PARAMS);\n\n  for (i = 0; i < args->size; i++) {\n    int type = args->args[i].type;\n    if (type == VALUE_TYPE_STRING) {\n      has_str = TRUE;\n    }\n    if (type == VALUE_TYPE_FLOAT || type == VALUE_TYPE_DOUBLE || type == VALUE_TYPE_FLOAT32) {\n      has_float = TRUE;\n    }\n  }\n\n  if (has_str) {\n    str_t str;\n    char buff[64];\n    str_init(&str, 100);\n    for (i = 0; i < args->size; i++) {\n      str_append(&str, value_str_ex(args->args + i, buff, sizeof(buff) - 1));\n    }\n    value_dup_str(result, str.str);\n    str_reset(&str);\n  } else {\n    for (i = 0; i < args->size; i++) {\n      v += value_double(args->args + i);\n    }\n    if (has_float) {\n      value_set_double(result, v);\n    } else {\n      value_set_int(result, (int)v);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_int(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int(result, value_int(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_i8(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int8(result, value_int8(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_i16(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int16(result, value_int16(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_i32(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int(result, value_int(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_i64(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int64(result, value_int64(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_u8(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_uint8(result, value_uint8(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_u16(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_uint16(result, value_uint16(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_u32(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_uint32(result, value_uint32(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_u64(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_uint64(result, value_uint64(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_f32(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_float32(result, value_float32(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_double(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_double(result, value_double(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_binary(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  void* p = NULL;\n  uint32_t size = 0;\n  /*基本类型默认拷贝*/\n  bool_t clone = TRUE;\n  value_t* v = args->args;\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n\n  switch (v->type) {\n    case VALUE_TYPE_BOOL: {\n      size = sizeof(int8_t);\n      p = &(v->value.b);\n      break;\n    }\n    case VALUE_TYPE_INT8: {\n      size = sizeof(int8_t);\n      p = &(v->value.i8);\n      break;\n    }\n    case VALUE_TYPE_UINT8: {\n      size = sizeof(uint8_t);\n      p = &(v->value.u8);\n      break;\n    }\n    case VALUE_TYPE_INT16: {\n      size = sizeof(int16_t);\n      p = &(v->value.i16);\n      break;\n    }\n    case VALUE_TYPE_UINT16: {\n      size = sizeof(uint16_t);\n      p = &(v->value.u16);\n      break;\n    }\n    case VALUE_TYPE_INT32: {\n      size = sizeof(int32_t);\n      p = &(v->value.i32);\n      break;\n    }\n    case VALUE_TYPE_UINT32: {\n      size = sizeof(uint32_t);\n      p = &(v->value.u32);\n      break;\n    }\n    case VALUE_TYPE_INT64: {\n      size = sizeof(int64_t);\n      p = &(v->value.i64);\n      break;\n    }\n    case VALUE_TYPE_UINT64: {\n      size = sizeof(uint64_t);\n      p = &(v->value.u64);\n      break;\n    }\n    case VALUE_TYPE_FLOAT: {\n      size = sizeof(float_t);\n      p = &(v->value.f32);\n      break;\n    }\n    case VALUE_TYPE_FLOAT32: {\n      size = sizeof(float);\n      p = &(v->value.f32);\n      break;\n    }\n    case VALUE_TYPE_DOUBLE: {\n      size = sizeof(double);\n      p = &(v->value.f64);\n      break;\n    }\n    case VALUE_TYPE_STRING: {\n      p = (void*)value_str(v);\n      size = tk_strlen(value_str(v));\n      clone = FALSE;\n      break;\n    }\n    case VALUE_TYPE_WSTRING: {\n      p = (void*)value_wstr(v);\n      size = wcslen(value_wstr(v)) * sizeof(wchar_t);\n      clone = FALSE;\n      break;\n    }\n    case VALUE_TYPE_POINTER: {\n      p = value_pointer(v);\n      size = args->size > 1 ? value_uint32(args->args + 1) : 0;\n      clone = FALSE;\n      break;\n    }\n    case VALUE_TYPE_BINARY: {\n      p = v->value.binary_data.data;\n      size = v->value.binary_data.size;\n      clone = FALSE;\n      break;\n    }\n    case VALUE_TYPE_SIZED_STRING: {\n      p = v->value.sized_str.str;\n      size = v->value.sized_str.size;\n      clone = FALSE;\n      break;\n    }\n    default: {\n      log_debug(\"not supported type\\n\");\n      break;\n    }\n  }\n\n  if (p == NULL || size == 0) {\n    value_set_binary_data(result, p, size);\n    return RET_OK;\n  }\n\n  /*参数1指定长度*/\n  if (args->size > 1) {\n    uint32_t esize = value_uint32(args->args + 1);\n    if (esize <= size) {\n      size = esize;\n    } else {\n      log_debug(\"size is too large, use default\\n\");\n    }\n  }\n\n  /*参数2要求复制*/\n  if (args->size > 2 && value_bool(args->args + 2)) {\n    clone = TRUE;\n  }\n\n  if (clone) {\n    p = tk_memdup(p, size);\n    value_set_binary_data(result, p, size);\n    result->free_handle = TRUE;\n  } else {\n    value_set_binary_data(result, p, size);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_str(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  str_t* str = &(fscript->str);\n  value_t* v = args->args;\n  bool_t force_pointer_as_str = args->size == 2 && value_bool(args->args + 1);\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n\n  if (force_pointer_as_str) {\n    if (v->type == VALUE_TYPE_POINTER) {\n      value_set_str(result, (const char*)value_pointer(v));\n      return RET_OK;\n    } else if (v->type == VALUE_TYPE_BINARY) {\n      value_set_str(result, (const char*)(v->value.binary_data.data));\n      return RET_OK;\n    }\n  }\n  str_from_value(str, args->args);\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}\n\nstatic ret_t func_one_of(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  char sep = ';';\n  int32_t index = 0;\n  const char* strs = NULL;\n  const char* start = NULL;\n\n  value_set_str(result, \"\");\n  FSCRIPT_FUNC_CHECK(args->size >= 2, RET_BAD_PARAMS);\n  FSCRIPT_FUNC_CHECK(args->args[0].type == VALUE_TYPE_STRING, RET_BAD_PARAMS);\n  strs = value_str(args->args);\n  FSCRIPT_FUNC_CHECK(strs != NULL, RET_BAD_PARAMS);\n\n  if (args->size > 2 && args->args[2].type == VALUE_TYPE_STRING) {\n    const char* p = value_str(args->args + 2);\n    if (p != NULL) {\n      sep = *p;\n    }\n  }\n\n  start = strs;\n  index = value_int(args->args + 1);\n\n  while (index > 0) {\n    while (*start && *start != sep) {\n      start++;\n    }\n    if (*start == '\\0') {\n      break;\n    }\n    index--;\n    start++;\n  }\n\n  if (start != NULL) {\n    const char* end = strchr(start, sep);\n    if (end != NULL) {\n      value_dup_str_with_len(result, start, end - start);\n    } else {\n      value_dup_str(result, start);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_join(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  char buff[64];\n  str_t* str = &(fscript->str);\n  value_set_bool(result, FALSE);\n  FSCRIPT_FUNC_CHECK(args->size > 1, RET_BAD_PARAMS);\n\n  str_set(str, \"\");\n  value_set_bool(result, TRUE);\n  for (i = 1; i < args->size; i++) {\n    if (i > 1) {\n      str_append(str, value_str_ex(args->args, buff, sizeof(buff)));\n    }\n    str_append(str, value_str_ex(args->args + i, buff, sizeof(buff)));\n  }\n\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}\n\nstatic ret_t func_set_local(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  const char* name = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  name = value_id(args->args);\n  FSCRIPT_FUNC_CHECK(name != NULL, RET_BAD_PARAMS);\n  value_set_bool(result, fscript_locals_create(fscript, name, args->args + 1) == RET_OK);\n\n  return RET_OK;\n}\n\nstatic ret_t func_get(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  ret_t ret = RET_OK;\n  value_t* v = args->args;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  return_value_if_fail(v->type == VALUE_TYPE_ID, RET_BAD_PARAMS);\n\n  if (value_id_index(v) >= 0) {\n    ret = fscript_locals_get(fscript, v, result);\n  } else {\n    const char* name = value_id(v);\n    ret = fscript_get_var(fscript, name, result);\n  }\n\n  if (ret != RET_OK) {\n    result->type = VALUE_TYPE_INVALID;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_set(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  int32_t index = 0;\n  value_t* v = args->args;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  return_value_if_fail(v->type == VALUE_TYPE_ID, RET_BAD_PARAMS);\n\n  index = value_id_index(v);\n  if (index >= 0) {\n    value_set_bool(result, fscript_locals_set(fscript, v, args->args + 1) == RET_OK);\n  } else {\n    const char* name = value_id(v);\n    value_set_bool(result, fscript_set_var(fscript, name, args->args + 1) == RET_OK);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_unset(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  int32_t index = 0;\n  value_t* v = args->args;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  return_value_if_fail(v->type == VALUE_TYPE_ID, RET_BAD_PARAMS);\n\n  index = value_id_index(v);\n  if (index >= 0) {\n    fscript_locals_remove(fscript, index);\n  } else {\n    const char* name = value_id(v);\n    tk_object_remove_prop(fscript->obj, name);\n  }\n  value_set_bool(result, TRUE);\n\n  return RET_OK;\n}\n\nstatic ret_t func_expr(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  if (args->size >= 1) {\n    value_deep_copy(result, args->args + args->size - 1);\n  } else {\n    result->type = VALUE_TYPE_INVALID;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_print(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  char buff[64];\n\n  value_set_bool(result, TRUE);\n  for (i = 0; i < args->size; i++) {\n    log_info(\"%s \", value_str_ex(args->args + i, buff, sizeof(buff) - 1));\n  }\n  log_info(\"\\n\");\n\n  if (fscript->print != NULL) {\n    return fscript->print(fscript, args, result);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_iformat(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  str_t* str = &(fscript->str);\n  const char* format = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  format = value_str(args->args);\n  FSCRIPT_FUNC_CHECK(format != NULL, RET_BAD_PARAMS);\n\n  tk_snprintf(str->str, str->capacity - 1, format, value_int(args->args + 1));\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}\n\nstatic ret_t func_fformat(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  str_t* str = &(fscript->str);\n  const char* format = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  format = value_str(args->args);\n  FSCRIPT_FUNC_CHECK(format != NULL, RET_BAD_PARAMS);\n\n  tk_snprintf(str->str, str->capacity - 1, format, value_double(args->args + 1));\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}\n\nstatic ret_t func_and(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value_set_bool(result, value_bool(args->args) && value_bool(args->args + 1));\n\n  return RET_OK;\n}\n\nstatic ret_t func_or(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value_set_bool(result, value_bool(args->args) || value_bool(args->args + 1));\n\n  return RET_OK;\n}\n\nstatic ret_t func_not(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_bool(result, !value_bool(args->args));\n\n  return RET_OK;\n}\n\nstatic ret_t func_minus(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  if (args->args[0].type == VALUE_TYPE_INT32) {\n    value_set_int(result, -value_int(args->args));\n  } else {\n    value_set_double(result, -value_double(args->args));\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_div(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value_set_double(result, value_double(args->args) / value_double(args->args + 1));\n\n  return RET_OK;\n}\n\nstatic ret_t func_mod(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value_set_int(result, value_int(args->args) % value_int(args->args + 1));\n\n  return RET_OK;\n}\n\nstatic ret_t func_mul(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value_set_double(result, value_double(args->args) * value_double(args->args + 1));\n\n  return RET_OK;\n}\n\nstatic ret_t func_sub(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n  if (args->size == 1) {\n    func_minus(fscript, args, result);\n  } else {\n    if (args->args->type == VALUE_TYPE_INT32 && args->args[1].type == VALUE_TYPE_INT32) {\n      value_set_int(result, value_int(args->args) - value_int(args->args + 1));\n    } else {\n      value_set_double(result, value_double(args->args) - value_double(args->args + 1));\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_random(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  long v = random();\n  if (args->size == 2) {\n    int32_t min = value_int(args->args);\n    int32_t max = value_int(args->args + 1);\n    if (min < max) {\n      v = min + v % (max - min);\n    }\n  }\n\n  value_set_int(result, v);\n\n  return RET_OK;\n}\n\nstatic ret_t func_le(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  if (args->args[0].type == VALUE_TYPE_STRING && args->args[1].type == VALUE_TYPE_STRING) {\n    value_set_bool(result, tk_str_cmp(value_str(args->args), value_str(args->args + 1)) <= 0);\n  } else {\n    value_set_bool(result, value_double(args->args) <= value_double(args->args + 1));\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_less(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  if (args->args[0].type == VALUE_TYPE_STRING && args->args[1].type == VALUE_TYPE_STRING) {\n    value_set_bool(result, tk_str_cmp(value_str(args->args), value_str(args->args + 1)) < 0);\n  } else {\n    value_set_bool(result, value_double(args->args) < value_double(args->args + 1));\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_ge(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  if (args->args[0].type == VALUE_TYPE_STRING && args->args[1].type == VALUE_TYPE_STRING) {\n    value_set_bool(result, tk_str_cmp(value_str(args->args), value_str(args->args + 1)) >= 0);\n  } else {\n    value_set_bool(result, value_double(args->args) >= value_double(args->args + 1));\n  }\n  return RET_OK;\n}\n\nstatic ret_t func_great(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  if (args->args[0].type == VALUE_TYPE_STRING && args->args[1].type == VALUE_TYPE_STRING) {\n    value_set_bool(result, tk_str_cmp(value_str(args->args), value_str(args->args + 1)) > 0);\n  } else {\n    value_set_bool(result, value_double(args->args) > value_double(args->args + 1));\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_eq(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  value_t* v1 = NULL;\n  value_t* v2 = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  v1 = args->args;\n  v2 = args->args + 1;\n\n  if (v1->type == VALUE_TYPE_STRING && v2->type == VALUE_TYPE_STRING) {\n    value_set_bool(result, tk_str_eq(value_str(v1), value_str(v2)));\n  } else if (v1->type == VALUE_TYPE_POINTER && v2->type == VALUE_TYPE_POINTER) {\n    value_set_bool(result, value_pointer(v1) == value_pointer(v2));\n  } else if (v1->type == VALUE_TYPE_OBJECT && v2->type == VALUE_TYPE_OBJECT) {\n    value_set_bool(result, value_object(v1) == value_object(v2));\n  } else if (v1->type == VALUE_TYPE_BINARY && v2->type == VALUE_TYPE_BINARY) {\n    binary_data_t* bin1 = value_binary_data(v1);\n    binary_data_t* bin2 = value_binary_data(v2);\n    if (bin1->size == bin2->size) {\n      value_set_bool(result, tk_str_cmp((const char*)bin1->data, (const char*)bin2->data) == 0);\n    } else {\n      value_set_bool(result, FALSE);\n    }\n  } else if (v1->type == VALUE_TYPE_INT64 || v2->type == VALUE_TYPE_INT64) {\n    value_set_bool(result, value_int64(v1) == value_int64(v2));\n  } else if (v1->type == VALUE_TYPE_UINT64 || v2->type == VALUE_TYPE_UINT64) {\n    value_set_bool(result, value_uint64(v1) == value_uint64(v2));\n  } else if (v1->type != v2->type && !(value_is_digit(v1) && value_is_digit(v2))) {\n    value_set_bool(result, FALSE);\n  } else {\n    value_set_bool(result, tk_fequal(value_double(v1), value_double(v2)));\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_not_eq(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  func_eq(fscript, args, result);\n  value_set_bool(result, !value_bool(result));\n\n  return RET_OK;\n}\n\nstatic ret_t func_assert(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n  if (!value_bool(args->args)) {\n    fscript_set_error(fscript, RET_FAIL, __FUNCTION__,\n                      args->size > 1 ? value_str(args->args + 1) : \"unkown\");\n    if (args->size > 1 && value_bool(args->args + 1)) {\n      assert(0);\n    } else {\n      log_debug(\"assert failed at: (%d %d)\\n\", (int)(fscript->curr->row),\n                (int)(fscript->curr->col));\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_min(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  double v1 = 0;\n  double v2 = 0;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n\n  v1 = value_double(args->args);\n  v2 = value_double(args->args + 1);\n  value_set_double(result, tk_min(v1, v2));\n\n  return RET_OK;\n}\n\nstatic ret_t func_max(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  double v1 = 0;\n  double v2 = 0;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n\n  v1 = value_double(args->args);\n  v2 = value_double(args->args + 1);\n  value_set_double(result, tk_max(v1, v2));\n\n  return RET_OK;\n}\n\nstatic ret_t func_clamp(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  double v1 = 0;\n  double v2 = 0;\n  double v3 = 0;\n  FSCRIPT_FUNC_CHECK(args->size == 3, RET_BAD_PARAMS);\n\n  v1 = value_double(args->args);\n  v2 = value_double(args->args + 1);\n  v3 = value_double(args->args + 2);\n  value_set_double(result, tk_clamp(v1, v2, v3));\n\n  return RET_OK;\n}\n\nstatic ret_t func_round(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_double(result, tk_roundi(value_double(args->args)));\n  return RET_OK;\n}\n\nstatic ret_t func_floor(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_double(result, floor(value_double(args->args)));\n  return RET_OK;\n}\n\nstatic ret_t func_ceil(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_double(result, ceil(value_double(args->args)));\n  return RET_OK;\n}\n\nstatic ret_t func_abs(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_double(result, tk_abs(value_double(args->args)));\n  return RET_OK;\n}\n\nstatic ret_t func_len(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  char buff[64];\n  const char* str = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n\n  if (args->args->type == VALUE_TYPE_OBJECT) {\ntk_object_t* obj = ",
    "raw_res": "0;",
    "prompt_res": "value_object(args->args);",
    "gt": "value_object(args->args);"
  },
  {
    "id": 813,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/fscript.c",
    "input": "﻿/**\n * File:   fscript.c\n * Author: AWTK Develop Team\n * Brief:  a simple script language\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2020-11-09 Li XianJing <lixianjing@zlg.cn> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/darray.h\"\n#include \"tkc/fscript.h\"\n#include \"tkc/object_default.h\"\n#include \"tkc/general_factory.h\"\n#include \"tkc/object_locker.h\"\n\n#ifndef WITHOUT_FSCRIPT\n#define value_id_index(v) (v)->value.id.index\n#define value_id_suboffset(v) (v)->value.id.suboffset\n\nstatic const fscript_hooks_t* s_hooks;\n\nret_t fscript_set_hooks(const fscript_hooks_t* hooks) {\n  s_hooks = hooks;\n  return RET_OK;\n}\n\nstatic ret_t func_function_def(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_if(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_while(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_until(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_repeat_times(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_repeat(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_for(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_for_in(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_noop(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_pending(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_return(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  if (args->size > 0) {\n    value_deep_copy(result, args->args);\n  }\n  fscript->returned = TRUE;\n  return RET_OK;\n}\nstatic ret_t func_get(fscript_t* fscript, fscript_args_t* args, value_t* result);\nstatic ret_t func_set(fscript_t* fscript, fscript_args_t* args, value_t* result);\nstatic ret_t func_unset(fscript_t* fscript, fscript_args_t* args, value_t* result);\nstatic ret_t func_set_local(fscript_t* fscript, fscript_args_t* args, value_t* result);\nstatic ret_t fscript_func_call_init_func(fscript_func_call_t* call, tk_object_t* obj,\n                                         tk_object_t* funcs_def, const char* name, uint32_t size);\n\nret_t fscript_ensure_locals(fscript_t* fscript) {\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n\n  if (fscript->locals == NULL) {\n    fscript->locals = darray_create(5, (tk_destroy_t)named_value_destroy,\n                                    (tk_compare_t)named_value_compare_by_name);\n  }\n\n  return fscript->locals != NULL ? RET_OK : RET_FAIL;\n}\n\nstatic ret_t fscript_locals_remove(fscript_t* fscript, uint32_t index) {\n  named_value_t* nv = (named_value_t*)(fscript->locals->elms[index]);\n  return value_reset(&(nv->value));\n}\n\nstatic tk_object_t* fscript_locals_get_object(fscript_t* fscript, const char* name) {\n  named_value_t* nv = (named_value_t*)darray_find(fscript->locals, (void*)name);\n\n  return nv != NULL ? value_object(&(nv->value)) : NULL;\n}\n\nstatic ret_t fscript_locals_get(fscript_t* fscript, const value_t* name, value_t* v) {\n  int32_t index = value_id_index(name);\n  int32_t suboffset = value_id_suboffset(name);\n  named_value_t* nv = (named_value_t*)(fscript->locals->elms[index]);\n  if (!suboffset) {\n    return value_copy(v, &(nv->value));\n  } else {\n    tk_object_t* obj = value_object(&(nv->value));\n    const char* subname = value_id(name) + suboffset;\n    return_value_if_fail(obj != NULL, RET_BAD_PARAMS);\n\n    return tk_object_get_prop(obj, subname, v);\n  }\n}\n\nstatic ret_t fscript_locals_set_with_index(fscript_t* fscript, uint32_t index, const value_t* v) {\n  named_value_t* nv = (named_value_t*)(fscript->locals->elms[index]);\n  if (nv->value.free_handle) {\n    value_reset(&(nv->value));\n  }\n  return value_deep_copy(&(nv->value), v);\n}\n\nstatic ret_t fscript_locals_set(fscript_t* fscript, const value_t* name, value_t* v) {\n  int32_t index = value_id_index(name);\n  int32_t suboffset = value_id_suboffset(name);\n  named_value_t* nv = (named_value_t*)(fscript->locals->elms[index]);\n  if (!suboffset) {\n    return fscript_locals_set_with_index(fscript, index, v);\n  } else {\n    tk_object_t* obj = value_object(&(nv->value));\n    const char* subname = value_id(name) + suboffset;\n    return_value_if_fail(obj != NULL, RET_BAD_PARAMS);\n\n    return tk_object_set_prop(obj, subname, v);\n  }\n}\n\nstatic ret_t fscript_locals_create(fscript_t* fscript, const char* name, const value_t* v) {\n  int32_t index = 0;\n  named_value_t* nv = NULL;\n  return_value_if_fail(fscript_ensure_locals(fscript) == RET_OK, RET_BAD_PARAMS);\n  index = darray_find_index(fscript->locals, (void*)name);\n\n  if (index >= 0) {\n    fscript_set_error(fscript, RET_FAIL, \"<>\", \"duplicated var name.\");\n    return fscript_locals_set_with_index(fscript, index, v);\n  }\n\n  nv = named_value_create_ex(name, v);\n  return_value_if_fail(nv != NULL, RET_BAD_PARAMS);\n\n  if (darray_push_unique(fscript->locals, nv) != RET_OK) {\n    named_value_destroy(nv);\n    return RET_FAIL;\n  }\n  return RET_OK;\n}\n\nstatic ret_t fscript_locals_destroy(fscript_t* fscript) {\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n  if (fscript->locals != NULL) {\n    darray_destroy(fscript->locals);\n    fscript->locals = NULL;\n  }\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_func(fscript_t* fscript, const char* name, fscript_func_call_t* iter,\n                               value_t* result) {\n  if (s_hooks != NULL && s_hooks->exec_func != NULL) {\n    return s_hooks->exec_func(fscript, name, iter, result);\n  } else {\n    return fscript_exec_func_default(fscript, iter, result);\n  }\n}\n\nret_t fscript_set_error(fscript_t* fscript, ret_t code, const char* func, const char* message) {\n  fscript->error_code = code;\n  fscript->error_func = fscript->curr;\n  fscript->error_row = fscript->curr->row;\n  fscript->error_col = fscript->curr->col;\n  fscript->error_message = tk_str_copy(fscript->error_message, message);\n  if (code != RET_OK) {\n    log_debug(\"(%d:%d): %s code=%d %s\\n\", fscript->curr->row, fscript->curr->col, func, code,\n              message);\n  }\n\n  if (fscript->on_error != NULL) {\n    fscript->on_error(fscript->on_error_ctx, fscript);\n  }\n\n  return RET_OK;\n}\n\nret_t fscript_set_on_error(fscript_t* fscript, fscript_on_error_t on_error, void* ctx) {\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n  fscript->on_error = on_error;\n  fscript->on_error_ctx = ctx;\n\n  return RET_OK;\n}\n\nret_t fscript_set_print_func(fscript_t* fscript, fscript_func_t print) {\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n\n  fscript->print = print;\n\n  return RET_OK;\n}\n\nstatic bool_t value_is_digit(value_t* v) {\n  uint32_t type = 0;\n  bool_t ret = TRUE;\n  return_value_if_fail(v != NULL, FALSE);\n\n  type = v->type;\n  if (type == VALUE_TYPE_INVALID || type == VALUE_TYPE_POINTER || type == VALUE_TYPE_STRING ||\n      type == VALUE_TYPE_WSTRING || type == VALUE_TYPE_OBJECT || type == VALUE_TYPE_SIZED_STRING ||\n      type == VALUE_TYPE_BINARY || type == VALUE_TYPE_UBJSON) {\n    ret = FALSE;\n  }\n\n  return ret;\n}\n\nstatic ret_t func_args_extend(fscript_args_t* args) {\n  if (args->size < args->capacity) {\n    return RET_OK;\n  }\n\n  if (args->capacity < FSCRIPT_MAX_ARGS) {\n    value_t* new_args = NULL;\n    uint16_t capacity = args->capacity + 2;\n    capacity = tk_min(capacity, FSCRIPT_MAX_ARGS);\n    new_args = TKMEM_REALLOC(args->args, capacity * sizeof(value_t));\n    return_value_if_fail(new_args != NULL, RET_OOM);\n    args->args = new_args;\n    args->capacity = capacity;\n    return RET_OK;\n  }\n\n  return RET_FAIL;\n}\n\nstatic ret_t func_args_push(fscript_args_t* args, value_t* v) {\n  return_value_if_fail(v != NULL && func_args_extend(args) == RET_OK, RET_BAD_PARAMS);\n  args->args[args->size++] = *v;\n  v->free_handle = FALSE;\n  value_reset(v);\n\n  return RET_OK;\n}\n\nstatic ret_t func_args_init(fscript_args_t* args, uint16_t init_args_capacity) {\n  memset(args, 0x00, sizeof(fscript_args_t));\n  if (init_args_capacity > 0) {\n    args->args = TKMEM_ZALLOCN(value_t, init_args_capacity);\n    return_value_if_fail(args->args != NULL, RET_OOM);\n    args->capacity = init_args_capacity;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_func_call_destroy(fscript_func_call_t* call);\n\nstatic ret_t func_args_reset(fscript_args_t* args) {\n  uint32_t i = 0;\n  for (i = 0; i < args->size; i++) {\n    value_t* v = args->args + i;\n    if (v->type == VALUE_TYPE_FSCRIPT_FUNC) {\n      fscript_func_call_destroy(value_func(v));\n    }\n    value_reset(args->args + i);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_args_deinit(fscript_args_t* args) {\n  func_args_reset(args);\n  TKMEM_FREE(args->args);\n  memset(args, 0x00, sizeof(fscript_args_t));\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_func_call_destroy(fscript_func_call_t* call) {\n  fscript_func_call_t* iter = call;\n  fscript_func_call_t* next = NULL;\n\n  while (iter != NULL) {\n    if (iter->func == func_pending) {\n      TKMEM_FREE(iter->ctx);\n    }\n    next = iter->next;\n    func_args_deinit(&(iter->args));\n    TKMEM_FREE(iter);\n    iter = next;\n  }\n\n  return RET_OK;\n}\n\nstatic fscript_function_def_t* fscript_function_def_create(const char* name,\n                                                           fscript_func_call_t* body) {\n  fscript_function_def_t* func = TKMEM_ZALLOC(fscript_function_def_t);\n  return_value_if_fail(func != NULL, NULL);\n  func->body = body;\n  func->name = tk_strdup(name);\n\n  darray_init(&(func->params), 3, default_destroy, NULL);\n  return func;\n}\n\nstatic ret_t fscript_function_def_destroy(fscript_function_def_t* func) {\n  return_value_if_fail(func != NULL, RET_BAD_PARAMS);\n  darray_deinit(&(func->params));\n  fscript_func_call_destroy(func->body);\n  TKMEM_FREE(func->name);\n  memset(func, 0x00, sizeof(fscript_function_def_t));\n  TKMEM_FREE(func);\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_function_def_add_param(fscript_function_def_t* func, const char* name) {\n  return_value_if_fail(func != NULL, RET_BAD_PARAMS);\n  return darray_push(&(func->params), tk_strdup(name));\n}\n\ntypedef enum _token_type_t {\n  TOKEN_ID = 1,\n  TOKEN_VAR,\n  TOKEN_FUNC,\n  TOKEN_RETURN,\n  TOKEN_FUNC_DEF,\n  TOKEN_STR,\n  TOKEN_NUMBER,\n  TOKEN_LPAREN,\n  TOKEN_RPAREN,\n  TOKEN_LBRACKET,\n  TOKEN_RBRACKET,\n  TOKEN_COMMA,\n  TOKEN_SEMICOLON,\n  /*for expr*/\n  TOKEN_QUESTION,\n  TOKEN_COLON,\n  TOKEN_EOF\n} token_type_t;\n\ntypedef struct _token_t {\n  const char* token;\n  token_type_t type;\n  uint32_t size;\n  bool_t valid;\n} token_t;\n\ntypedef struct _fscript_parser_t {\n  tk_object_t* obj;\n  token_t token;\n  char* code_id;\n  const char* str;\n  const char* cursor;\n\n  char c;\n  str_t temp;\n  uint16_t row;\n  uint16_t col;\n  tk_object_t* funcs_def;\n  fscript_func_call_t* first;\n  fscript_parser_error_t* error;\n  bool_t keep_func_name;\n  darray_t* symbols;\n} fscript_parser_t;\n\nstatic ret_t fexpr_parse(fscript_parser_t* parser, value_t* result);\nstatic ret_t fscript_parse_statements(fscript_parser_t* parser, fscript_func_call_t* acall);\nstatic fscript_func_call_t* fscript_func_call_create(fscript_parser_t* parser, const char* name,\n                                                     uint32_t size);\nstatic ret_t fscript_get_var(fscript_t* fscript, const char* name, value_t* value) {\n  value_set_str(value, NULL);\n  return_value_if_fail(name != NULL, RET_BAD_PARAMS);\n  if (*name == '$') {\n    name += 1;\n  }\n\n  if (strncmp(name, FSCRIPT_STR_GLOBAL_PREFIX, FSCRIPT_GLOBAL_PREFIX_LEN) == 0) {\n    return tk_object_get_prop(fscript_get_global_object(), name + FSCRIPT_GLOBAL_PREFIX_LEN, value);\n  }\n\n  return tk_object_get_prop(fscript->obj, name, value);\n}\n\nret_t fscript_set_var_default(fscript_t* fscript, const char* name, const value_t* value) {\n  if (strncmp(name, FSCRIPT_STR_GLOBAL_PREFIX, FSCRIPT_GLOBAL_PREFIX_LEN) == 0) {\n    return tk_object_set_prop(fscript_get_global_object(), name + FSCRIPT_GLOBAL_PREFIX_LEN, value);\n  }\n\n  return tk_object_set_prop(fscript->obj, name, value);\n}\n\nret_t fscript_set_var(fscript_t* fscript, const char* name, const value_t* value) {\n  if (s_hooks != NULL && s_hooks->set_var != NULL) {\n    return s_hooks->set_var(fscript, name, value);\n  } else {\n    return fscript_set_var_default(fscript, name, value);\n  }\n}\n\nstatic ret_t fscript_eval_arg(fscript_t* fscript, fscript_func_call_t* iter, uint32_t i,\n                              value_t* d) {\n  value_t v;\n  value_t* s = iter->args.args + i;\n  value_set_str(&v, NULL);\n  value_set_str(d, NULL);\n  if (s->type == VALUE_TYPE_FSCRIPT_ID) {\n    if ((iter->func == func_set_local || iter->func == func_set || iter->func == func_unset ||\n         iter->func == func_get) &&\n        i == 0) {\n      value_copy(d, s); /*func_set accept id/str as first param*/\n    } else {\n      const char* name = value_id(s);\n      if (value_id_index(s) >= 0) {\n        return fscript_locals_get(fscript, s, d);\n      }\n\n      if (fscript->loop_count > 0) {\n        if (tk_str_eq(name, \"break\")) {\n          fscript->breaked = TRUE;\n          return RET_OK;\n        } else if (tk_str_eq(name, \"continue\")) {\n          fscript->continued = TRUE;\n          return RET_OK;\n        }\n      } else if (tk_str_eq(name, \"return\")) {\n        fscript->returned = TRUE;\n        value_set_int(d, 0);\n        return RET_OK;\n      } else if (*name == '.') {\n        value_copy(d, s);\n        return RET_OK;\n      }\n\n      if (fscript_get_var(fscript, name, d) != RET_OK) {\n        if (name == NULL || *name != '$') {\n          char msg[128];\n          tk_snprintf(msg, sizeof(msg) - 1, \"not found var %s\", name);\n          fscript_set_error(fscript, RET_NOT_FOUND, \"get_var\", msg);\n          value_set_str(d, value_id(s));\n        } else if (*name == '$') {\n          value_reset(d);\n        }\n      }\n    }\n  } else if (s->type == VALUE_TYPE_FSCRIPT_FUNC) {\n    fscript_exec_func(fscript, NULL, value_func(s), d);\n  } else {\n    value_copy(d, s);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_if(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  uint32_t i = 0;\n  uint32_t n = 0;\n  value_t condition;\n  return_value_if_fail(iter->args.size >= 2, RET_FAIL);\n\n  n = iter->args.size / 2;\n  for (i = 0; i < n; i++) {\n    value_set_bool(&condition, FALSE);\n    return_value_if_fail(fscript_eval_arg(fscript, iter, 2 * i, &condition) == RET_OK, RET_FAIL);\n    if (value_bool(&condition)) {\n      return fscript_eval_arg(fscript, iter, 2 * i + 1, result);\n    }\n  }\n\n  if ((2 * i) < iter->args.size) {\n    return fscript_eval_arg(fscript, iter, 2 * i, result);\n  } else {\n    value_set_int(result, 0);\n    return RET_OK;\n  }\n}\n\nstatic ret_t fscript_exec_loop_body(fscript_t* fscript, fscript_func_call_t* iter, uint32_t start,\n                                    value_t* result, bool_t* done) {\n  uint32_t i = 1;\n  for (i = start; i < iter->args.size; i++) {\n    value_reset(result);\n    fscript_eval_arg(fscript, iter, i, result);\n    if (fscript->breaked) {\n      *done = TRUE;\n      fscript->breaked = FALSE;\n      break;\n    } else if (fscript->returned) {\n      *done = TRUE;\n    } else if (fscript->continued) {\n      fscript->continued = FALSE;\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_while_or_until(fscript_t* fscript, fscript_func_call_t* iter,\n                                         value_t* result, bool_t is_while) {\n  value_t condition;\n  bool_t done = FALSE;\n  FSCRIPT_FUNC_CHECK(iter->args.size > 1, RET_FAIL);\n\n  fscript->loop_count++;\n  value_set_int(&condition, 0);\n  while (!done && fscript_eval_arg(fscript, iter, 0, &condition) == RET_OK) {\n    if (is_while ? !value_bool(&condition) : value_bool(&condition)) {\n      break;\n    }\n    fscript_exec_loop_body(fscript, iter, 1, result, &done);\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\n\n/*repeat(a, 0, 100, 1) {*/\nstatic ret_t fscript_exec_repeat(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  value_t v;\n  int32_t start = 0;\n  int32_t end = 0;\n  int32_t delta = 0;\n  bool_t done = FALSE;\n  value_t* var = iter->args.args;\n  int32_t index = value_id_index(var);\n  const char* name = value_id(iter->args.args);\n  FSCRIPT_FUNC_CHECK(iter->args.size > 4, RET_FAIL);\n\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 1, &v) == RET_OK, RET_BAD_PARAMS);\n  start = value_int(&v);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 2, &v) == RET_OK, RET_BAD_PARAMS);\n  end = value_int(&v);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 3, &v) == RET_OK, RET_BAD_PARAMS);\n  delta = value_int(&v);\n\n  fscript->loop_count++;\n  while ((start != end) && !done) {\n    value_set_int(&v, start);\n    if (index >= 0) {\n      break_if_fail(fscript_locals_set(fscript, var, &v) == RET_OK);\n    } else {\n      break_if_fail(fscript_set_var(fscript, name, &v) == RET_OK);\n    }\n    fscript_exec_loop_body(fscript, iter, 4, result, &done);\n    start += delta;\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_for(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  value_t v;\n  bool_t done = FALSE;\n  FSCRIPT_FUNC_CHECK(iter->args.size > 3, RET_FAIL);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 0, &v) == RET_OK, RET_BAD_PARAMS);\n\n  fscript->loop_count++;\n  while (!done) {\n    break_if_fail(fscript_eval_arg(fscript, iter, 1, &v) == RET_OK);\n    if (!value_bool(&v)) {\n      break;\n    }\n    fscript_exec_loop_body(fscript, iter, 3, result, &done);\n    break_if_fail(fscript_eval_arg(fscript, iter, 2, &v) == RET_OK);\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_for_in(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  value_t v;\n  char prop[32];\n  uint32_t i = 0;\n  uint32_t n = 0;\n  bool_t done = FALSE;\n  object_t* obj = NULL;\n  value_t* var = iter->args.args;\n  int32_t index = value_id_index(var);\n  const char* name = value_id(var);\n\n  FSCRIPT_FUNC_CHECK(iter->args.size > 2, RET_FAIL);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 1, &v) == RET_OK, RET_BAD_PARAMS);\n  obj = value_object(&v);\n  FSCRIPT_FUNC_CHECK(obj != NULL, RET_FAIL);\n\n  fscript->loop_count++;\n  n = tk_object_get_prop_int(obj, TK_OBJECT_PROP_SIZE, 0);\n  for (i = 0; ((i < n) && !done); i++) {\n    tk_snprintf(prop, sizeof(prop) - 1, \"[%u]\", i);\n    break_if_fail(tk_object_get_prop(obj, prop, &v) == RET_OK);\n\n    if (index >= 0) {\n      fscript_locals_set(fscript, var, &v);\n    } else {\n      fscript_set_var(fscript, name, &v);\n    }\n    fscript_exec_loop_body(fscript, iter, 2, result, &done);\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_repeat_times(fscript_t* fscript, fscript_func_call_t* iter,\n                                       value_t* result) {\n  value_t v;\n  uint32_t i = 0;\n  uint32_t n = 0;\n  bool_t done = FALSE;\n  FSCRIPT_FUNC_CHECK(iter->args.size > 1, RET_FAIL);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 0, &v) == RET_OK, RET_BAD_PARAMS);\n\n  n = value_int(&v);\n  fscript->loop_count++;\n  for (i = 0; i < n && !done; i++) {\n    fscript_exec_loop_body(fscript, iter, 1, result, &done);\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\nstatic ret_t fscript_exec_while(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  return fscript_exec_while_or_until(fscript, iter, result, TRUE);\n}\n\nstatic ret_t fscript_exec_until(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  return fscript_exec_while_or_until(fscript, iter, result, FALSE);\n}\n\nstatic ret_t fscript_exec_core_func(fscript_t* fscript, fscript_func_call_t* iter,\n                                    value_t* result) {\n  if (iter->func == func_if) {\n    return fscript_exec_if(fscript, iter, result);\n  } else if (iter->func == func_while) {\n    return fscript_exec_while(fscript, iter, result);\n  } else if (iter->func == func_until) {\n    return fscript_exec_until(fscript, iter, result);\n  } else if (iter->func == func_repeat) {\n    return fscript_exec_repeat(fscript, iter, result);\n  } else if (iter->func == func_for) {\n    return fscript_exec_for(fscript, iter, result);\n  } else if (iter->func == func_for_in) {\n    return fscript_exec_for_in(fscript, iter, result);\n  } else if (iter->func == func_repeat_times) {\n    return fscript_exec_repeat_times(fscript, iter, result);\n  } else if (iter->func == func_function_def) {\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t fscript_exec_ext_func(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  value_t v;\n  uint32_t i = 0;\n  ret_t ret = RET_OK;\n  fscript_args_t args;\n  value_t args_values[5];\n\n  value_set_int(&v, 0);\n  if (iter->args.size <= ARRAY_SIZE(args_values)) {\n    memset(&args, 0x00, sizeof(args));\n    memset(&args_values, 0x00, sizeof(args_values));\n    args.capacity = ARRAY_SIZE(args_values);\n    args.args = args_values;\n  } else {\n    func_args_init(&args, iter->args.size);\n  }\n  args.size = iter->args.size;\n\n  return_value_if_fail((args.args != NULL || args.size == 0), RET_OOM);\n  for (i = 0; i < iter->args.size; i++) {\n    ret = fscript_eval_arg(fscript, iter, i, args.args + i);\n    if (fscript->breaked || fscript->continued || fscript->returned) {\n      value_deep_copy(result, args.args + i);\n      if (iter->args.size <= ARRAY_SIZE(args_values)) {\n        func_args_reset(&args);\n      } else {\n        func_args_deinit(&args);\n      }\n      return RET_OK;\n    }\n  }\n\n  value_set_int(result, 0);\n  fscript->curr = iter;\n  ret = iter->func(fscript, &args, result);\n\n  if (iter->args.size <= ARRAY_SIZE(args_values)) {\n    func_args_reset(&args);\n  } else {\n    func_args_deinit(&args);\n  }\n\n  return ret;\n}\n\nret_t fscript_exec_func_default(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  fscript->curr = iter;\n  result->type = VALUE_TYPE_INVALID;\n\n  if (iter->func == func_pending && iter->ctx != NULL) {\n    tk_object_t* obj = NULL;\n    void* ctx = iter->ctx;\n    char* name = (char*)(iter->ctx);\n    char* p = strchr(name, '.');\n    iter->ctx = NULL;\n\n    if (p != NULL) {\n      *p = '\\0';\n      obj = fscript_locals_get_object(fscript, name);\n      name = p + 1;\n    }\n    obj = obj != NULL ? obj : fscript->obj;\n    fscript_func_call_init_func(iter, obj, fscript->funcs_def, name, tk_strlen(name));\n\n    if (iter->func == func_noop) {\n      log_warn(\"not found func %s\\n\", name);\n    }\n    TKMEM_FREE(ctx);\n  }\n\n  if (fscript_exec_core_func(fscript, iter, result) == RET_NOT_FOUND) {\n    return_value_if_fail(fscript_exec_ext_func(fscript, iter, result) == RET_OK, RET_FAIL);\n  }\n\n  return RET_OK;\n}\n\nret_t fscript_exec(fscript_t* fscript, value_t* result) {\n  fscript_func_call_t* iter = NULL;\n  return_value_if_fail(fscript != NULL, RET_FAIL);\n\n  if (s_hooks != NULL && s_hooks->before_exec != NULL) {\n    s_hooks->before_exec(fscript);\n  }\n\n  value_set_str(result, NULL);\n  iter = fscript->first;\n  while (iter != NULL) {\n    break_if_fail(iter->func != NULL);\n    value_reset(result);\n    break_if_fail(fscript_exec_func(fscript, NULL, iter, result) == RET_OK);\n    if (fscript->returned) {\n      fscript->returned = FALSE;\n      break;\n    }\n    iter = iter->next;\n  }\n\n  if (s_hooks != NULL && s_hooks->after_exec != NULL) {\n    s_hooks->after_exec(fscript);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t on_free_func_def(void* ctx, const void* data) {\n  named_value_t* iter = (named_value_t*)(data);\n  fscript_function_def_destroy(value_func_def(&(iter->value)));\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_reset(fscript_t* fscript) {\n  return_value_if_fail(fscript != NULL, RET_FAIL);\n\n  if (s_hooks != NULL && s_hooks->on_deinit != NULL) {\n    s_hooks->on_deinit(fscript);\n  }\n\n  str_reset(&(fscript->str));\n  fscript_locals_destroy(fscript);\n  if (fscript->funcs_def != NULL) {\n    tk_object_foreach_prop(fscript->funcs_def, on_free_func_def, NULL);\n  }\n  TK_OBJECT_UNREF(fscript->funcs_def);\n  TKMEM_FREE(fscript->error_message);\n  fscript_func_call_destroy(fscript->first);\n  TKMEM_FREE(fscript->code_id);\n  memset(fscript, 0x00, sizeof(fscript_t));\n\n  return RET_OK;\n}\n\nret_t fscript_deinit(fscript_t* fscript) {\n  return fscript_reset(fscript);\n}\n\nret_t fscript_destroy(fscript_t* fscript) {\n  return_value_if_fail(fscript != NULL, RET_FAIL);\n  fscript_deinit(fscript);\n\n  TKMEM_FREE(fscript);\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_init(fscript_parser_t* parser, tk_object_t* obj, const char* str,\n                                 fscript_parser_error_t* error) {\n  memset(parser, 0x00, sizeof(fscript_parser_t));\n\n  parser->obj = obj;\n  parser->str = str;\n  parser->cursor = str;\n  parser->error = error;\n  parser->symbols = darray_create(5, NULL, (tk_compare_t)tk_str_cmp);\n\n  str_init(&(parser->temp), 64);\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_deinit(fscript_parser_t* parser) {\n  str_reset(&(parser->temp));\n  TKMEM_FREE(parser->code_id);\n  darray_destroy(parser->symbols);\n  fscript_func_call_destroy(parser->first);\n  if (parser->funcs_def != NULL) {\n    tk_object_foreach_prop(parser->funcs_def, on_free_func_def, NULL);\n  }\n  TK_OBJECT_UNREF(parser->funcs_def);\n\n  return RET_OK;\n}\n\nstatic char fscript_parser_get_char(fscript_parser_t* parser) {\n  char c = '\\0';\n  return_value_if_fail(parser != NULL, c);\n  if (parser->c) {\n    c = parser->c;\n    parser->c = '\\0';\n    return c;\n  }\n\n  c = parser->cursor[0];\n  if (c) {\n    if (c == '\\n') {\n      parser->row++;\n      parser->col = 0;\n    } else {\n      parser->col++;\n    }\n\n    parser->cursor++;\n  }\n\n  return c;\n}\n\nstatic ret_t fscript_parser_unget_char(fscript_parser_t* parser, char c) {\n  return_value_if_fail(parser->cursor > parser->str, RET_BAD_PARAMS);\n  parser->c = c;\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_set_error(fscript_parser_t* parser, const char* str) {\n  return_value_if_fail(parser != NULL && str != NULL, RET_BAD_PARAMS);\n\n  if (parser->error != NULL) {\n    parser->error->row = parser->row;\n    parser->error->col = parser->col;\n    parser->error->offset = parser->cursor - parser->str;\n    parser->error->message = tk_str_copy(parser->error->message, str);\n    parser->error->token = tk_str_copy(parser->error->token, parser->token.token);\n  }\n\n  log_warn(\"code: \\\"%s\\\"\\n\", parser->str);\n  log_warn(\"token: \\\"%s\\\"\\n\", parser->token.token);\n  log_warn(\"at line(%u) col (%u): %s\\n\", parser->row, parser->col, str);\n\n  return RET_FAIL;\n}\n\nstatic ret_t fscript_parser_skip_seperators(fscript_parser_t* parser) {\n  char c = '\\0';\n  do {\n    c = fscript_parser_get_char(parser);\n  } while (tk_isspace(c));\n  fscript_parser_unget_char(parser, c);\n\n  return RET_OK;\n}\n\n#define STR_CODE_ID_START \"code_id(\\\"\"\n#define STR_CODE_ID_END \"\\\")\"\n\nstatic ret_t fscript_parser_skip_line_comment(fscript_parser_t* parser) {\n  char c = '\\0';\n  str_t* str = &(parser->temp);\n  str_clear(str);\n  do {\n    c = fscript_parser_get_char(parser);\n    str_append_char(str, c);\n  } while (c != '\\0' && c != '\\r' && c != '\\n');\n\n  if (str->size > sizeof(STR_CODE_ID_START)) {\n    const char* end = NULL;\n    const char* start = strstr(str->str, STR_CODE_ID_START);\n    if (start != NULL) {\n      start += strlen(STR_CODE_ID_START);\n      end = strstr(start, STR_CODE_ID_END);\n      if (end != NULL) {\n        TKMEM_FREE(parser->code_id);\n        parser->code_id = tk_strndup(start, end - start);\n        log_debug(\"code_id:%s\\n\", parser->code_id);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_skip_block_comment(fscript_parser_t* parser) {\n  char c = '\\0';\n  do {\n    c = fscript_parser_get_char(parser);\n    if (c == '*' && parser->cursor[0] == '/') {\n      c = fscript_parser_get_char(parser);\n      break;\n    }\n  } while (c != '\\0');\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_skip_seperators_and_comments(fscript_parser_t* parser) {\n  char c = '\\0';\n\n  while (TRUE) {\n    fscript_parser_skip_seperators(parser);\n    c = fscript_parser_get_char(parser);\n    if (c == '/') {\n      if (parser->cursor[0] == '/') {\n        c = fscript_parser_get_char(parser);\n        fscript_parser_skip_line_comment(parser);\n      } else if (parser->cursor[0] == '*') {\n        c = fscript_parser_get_char(parser);\n        fscript_parser_skip_block_comment(parser);\n      } else {\n        break;\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (c) {\n    parser->cursor--;\n    if (parser->col > 0) {\n      parser->col--;\n    }\n  }\n\n  return RET_OK;\n}\n\n#define TOKEN_INIT(t, ttype, str) \\\n  t->type = ttype;                \\\n  t->token = str->str;            \\\n  t->size = str->size;\n\nstatic ret_t fscript_parser_parse_str(fscript_parser_t* parser, char quota) {\n  char c = '\\0';\n  bool_t escape = FALSE;\n  str_t* str = &(parser->temp);\n  token_t* t = &(parser->token);\n\n  str_set(str, \"\");\n  do {\n    c = fscript_parser_get_char(parser);\n    if (escape) {\n      if (c == 'r') {\n        str_append_char(str, '\\r');\n      } else if (c == 'n') {\n        str_append_char(str, '\\n');\n      } else if (c == 't') {\n        str_append_char(str, '\\t');\n      } else {\n        str_append_char(str, c);\n      }\n      escape = FALSE;\n      continue;\n    }\n\n    if (c == quota || c == '\\0') {\n      break;\n    } else if (c == '\\\\') {\n      escape = TRUE;\n      continue;\n    }\n    str_append_char(str, c);\n  } while (TRUE);\n\n  TOKEN_INIT(t, TOKEN_STR, str);\n  if (c != '\\0' && c != quota) {\n    fscript_parser_unget_char(parser, c);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_get_non_ascii_char(fscript_parser_t* parser, str_t* str, uint8_t c,\n                                               uint32_t n) {\n  str_append_char(str, c);\n  while (n > 1) {\n    c = fscript_parser_get_char(parser);\n    str_append_char(str, c);\n    n--;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_parse_id_or_number(fscript_parser_t* parser, token_type_t def_type) {\n  char c = '\\0';\n  str_t* str = &(parser->temp);\n  token_t* t = &(parser->token);\n  c = fscript_parser_get_char(parser);\n\n  str_set(str, \"\");\n  if (c) {\n    int32_t n = tk_utf8_get_bytes_of_leading((uint8_t)c);\n    fscript_parser_get_non_ascii_char(parser, str, c, n);\n  }\n\n  do {\n    c = fscript_parser_get_char(parser);\n    if (tk_isxdigit(c) || tk_isdigit(c) || tk_isalpha(c) || c == '.' || c == '_' || c == '[' ||\n        c == ']' || c == '#') {\n      str_append_char(str, c);\n    } else {\n      int32_t n = tk_utf8_get_bytes_of_leading((uint8_t)c);\n      if (n > 1) {\n        fscript_parser_get_non_ascii_char(parser, str, c, n);\n      } else {\n        break;\n      }\n    }\n  } while (TRUE);\n\n  if (tk_isspace(c)) {\n    fscript_parser_skip_seperators_and_comments(parser);\n    c = fscript_parser_get_char(parser);\n  }\n\n  str_trim(str, \" \\t\\r\\n\");\n  TOKEN_INIT(t, (c == '(' ? TOKEN_FUNC : def_type), str);\n  if (c != '\\0') {\n    fscript_parser_unget_char(parser, c);\n  }\n\n  if (t->type == TOKEN_ID) {\n    if (tk_str_eq(t->token, \"function\")) {\n      t->type = TOKEN_FUNC_DEF;\n    } else if (tk_str_eq(t->token, \"var\")) {\n      t->type = TOKEN_VAR;\n    } else if (tk_str_eq(t->token, \"return\")) {\n      t->type = TOKEN_RETURN;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_get_unary(fscript_parser_t* parser, char c, str_t* str) {\n  do {\n    fscript_parser_skip_seperators_and_comments(parser);\n    c = fscript_parser_get_char(parser);\n    if (c == str->str[0]) {\n      str_append_char(str, c);\n    } else {\n      fscript_parser_unget_char(parser, c);\n      break;\n    }\n  } while (TRUE);\n\n  return RET_OK;\n}\n\nstatic token_t* fscript_parser_get_token_ex(fscript_parser_t* parser, bool_t operator) {\n  char c = 0;\n  str_t* str = &(parser->temp);\n  token_t* t = &(parser->token);\n\n  if (t->valid) {\n    t->valid = FALSE;\n    return t;\n  }\n\n  fscript_parser_skip_seperators_and_comments(parser);\n  c = fscript_parser_get_char(parser);\n\n  str_set_with_len(str, &c, 1);\n  t->token = str->str;\n  t->size = 1;\n  switch (c) {\n    case '\\0': {\n      t->type = TOKEN_EOF;\n      return NULL;\n    }\n    case '(': {\n      t->type = TOKEN_LPAREN;\n      return t;\n    }\n    case ')': {\n      t->type = TOKEN_RPAREN;\n      return t;\n    }\n    case '{': {\n      t->type = TOKEN_LBRACKET;\n      return t;\n    }\n    case '}': {\n      t->type = TOKEN_RBRACKET;\n      return t;\n    }\n    case ',': {\n      t->type = TOKEN_COMMA;\n      return t;\n    }\n    case ';': {\n      t->type = TOKEN_SEMICOLON;\n      return t;\n    }\n    case '?': {\n      t->type = TOKEN_QUESTION;\n      return t;\n    }\n    case ':': {\n      t->type = TOKEN_COLON;\n      return t;\n    }\n    case '*':\n    case '/':\n    case '%':\n    case '^':\n    case '#': {\n      t->type = TOKEN_FUNC;\n      return t;\n    }\n    case '>':\n    case '<':\n    case '=': {\n      c = fscript_parser_get_char(parser);\n      if (str->str[0] == c || c == '=') {\n        str_append_char(str, c);\n      } else {\n        fscript_parser_unget_char(parser, c);\n      }\n      t->type = TOKEN_FUNC;\n      t->size = str->size;\n      return t;\n    }\n    case '~':\n    case '!': {\n      c = fscript_parser_get_char(parser);\n      if (c == '=') {\n        str_append_char(str, c);\n      } else {\n        fscript_parser_unget_char(parser, c);\n        fscript_parser_get_unary(parser, c, str);\n      }\n      TOKEN_INIT(t, TOKEN_FUNC, str);\n      return t;\n    }\n    case '|':\n    case '&': {\n      c = fscript_parser_get_char(parser);\n      if (c == str->str[0]) {\n        str_append_char(str, c);\n      } else {\n        fscript_parser_unget_char(parser, c);\n      }\n\n      t->type = TOKEN_FUNC;\n      t->size = str->size;\n      return t;\n    }\n    case '\\\"':\n    case '\\'': {\n      fscript_parser_parse_str(parser, c);\n      return t;\n    }\n    default: {\n      if (c == '+' || c == '-') {\n        fscript_parser_skip_seperators_and_comments(parser);\n        if (operator|| !tk_isdigit(parser->cursor[0])) {\n          fscript_parser_get_unary(parser, c, str);\n          TOKEN_INIT(t, TOKEN_FUNC, str);\n        } else {\n          fscript_parser_unget_char(parser, c);\n          fscript_parser_parse_id_or_number(parser, TOKEN_NUMBER);\n        }\n      } else if (tk_isdigit(c)) {\n        fscript_parser_unget_char(parser, c);\n        fscript_parser_parse_id_or_number(parser, TOKEN_NUMBER);\n      } else {\n        fscript_parser_unget_char(parser, c);\n        fscript_parser_parse_id_or_number(parser, TOKEN_ID);\n      }\n      return t;\n    }\n  }\n}\n\nstatic token_t* fscript_parser_get_token(fscript_parser_t* parser) {\n  return fscript_parser_get_token_ex(parser, FALSE);\n}\n\nstatic ret_t fscript_parser_expect_token(fscript_parser_t* parser, token_type_t type,\n                                         const char* msg) {\n  token_t* t = fscript_parser_get_token(parser);\n  if (t == NULL || t->type != type) {\n    return fscript_parser_set_error(parser, msg);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_unget_token(fscript_parser_t* parser) {\n  if (parser->token.type != TOKEN_EOF) {\n    parser->token.valid = TRUE;\n  }\n  return RET_OK;\n}\n\nstatic ret_t token_to_value(fscript_parser_t* parser, token_t* t, value_t* v) {\n  if (t->type == TOKEN_NUMBER) {\n    char number[64];\n    tk_strncpy_s(number, sizeof(number) - 1, t->token, t->size);\n    if (strchr(number, '.') != NULL) {\n      value_set_double(v, tk_atof(number));\n    } else {\n      uint64_t vv = 0;\n      const char* str = number;\n      bool_t has_minus = FALSE;\n      if (*str == '-') {\n        has_minus = TRUE;\n        str++;\n      }\n\n      vv = tk_atoul(str);\n      if (vv < INT_MAX) {\n        if (has_minus) {\n          value_set_int32(v, -vv);\n        } else {\n          value_set_int32(v, vv);\n        }\n      } else if (vv < UINT32_MAX) {\n        if (has_minus) {\n          value_set_int64(v, -vv);\n        } else {\n          value_set_uint32(v, vv);\n        }\n      } else {\n        if (has_minus) {\n          value_set_int64(v, -vv);\n        } else {\n          value_set_uint64(v, vv);\n        }\n      }\n    }\n  } else if (t->type == TOKEN_STR) {\n    value_dup_str_with_len(v, t->token, t->size);\n  } else if (t->type == TOKEN_ID) {\n    if (t->token[0] == 't' && strncmp(t->token, \"true\", 4) == 0) {\n      value_set_bool(v, TRUE);\n    } else if (t->token[0] == 'f' && strncmp(t->token, \"false\", 5) == 0) {\n      value_set_bool(v, FALSE);\n    } else {\n      const char* name = NULL;\n      const char* p = NULL;\n      value_set_id(v, t->token, t->size);\n      name = value_id(v);\n      p = strchr(name, '.');\n      if (p != NULL) {\n        char first_name[TK_NAME_LEN + 1];\n        tk_strncpy_s(first_name, TK_NAME_LEN, name, p - name);\n        value_id_suboffset(v) = p - name + 1;\n        value_id_index(v) = darray_find_index(parser->symbols, (void*)first_name);\n      } else {\n        value_id_suboffset(v) = 0;\n        value_id_index(v) = darray_find_index(parser->symbols, (void*)name);\n      }\n    }\n  } else {\n    return RET_FAIL;\n  }\n\n  return RET_OK;\n}\n\nret_t fscript_eval(tk_object_t* obj, const char* script, value_t* result) {\n  value_t v;\n  ret_t ret = RET_OK;\n  fscript_t* fscript = fscript_create(obj, script);\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n\n  if (fscript_exec(fscript, &v) == RET_OK && result != NULL) {\n    value_deep_copy(result, &v);\n  }\n  value_reset(&v);\n  fscript_destroy(fscript);\n\n  return ret;\n}\n\n/*expr parser*/\nstatic ret_t fexpr_parse_block(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  value_t v;\n  fscript_func_call_t* statements = fscript_func_call_create(parser, \"expr\", 4);\n  return_value_if_fail(statements != NULL, RET_OOM);\n\n  if (fscript_parse_statements(parser, statements) == RET_OK) {\n    func_args_push(&(acall->args), value_set_func(&v, statements));\n  } else {\n    fscript_func_call_destroy(statements);\n  }\n\n  fscript_parser_expect_token(parser, TOKEN_RBRACKET, \"expect \\\"}\\\"\");\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_function(fscript_parser_t* parser, value_t* result);\n\nstatic ret_t fexpr_parse_if(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  uint32_t i = 0;\n  token_t* t = NULL;\n  fexpr_parse_block(parser, acall);\n  t = fscript_parser_get_token(parser);\n\n  if (t != NULL && t->type == TOKEN_ID && tk_str_eq(t->token, \"else\")) {\n    t = fscript_parser_get_token(parser);\n    if (t != NULL && t->type == TOKEN_FUNC && tk_str_eq(t->token, \"if\")) {\n      value_t result;\n      fscript_func_call_t* elseif = NULL;\n      fscript_parser_unget_token(parser);\n      return_value_if_fail(fexpr_parse_function(parser, &result) == RET_OK, RET_FAIL);\n      elseif = value_func(&result);\n      for (i = 0; i < elseif->args.size; i++) {\n        func_args_push(&(acall->args), elseif->args.args + i);\n      }\n      elseif->args.size = 0;\n      fscript_func_call_destroy(elseif);\n      return RET_OK;\n    } else {\n      fscript_parser_unget_token(parser);\n      fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\");\n      return fexpr_parse_block(parser, acall);\n    }\n  } else {\n    fscript_parser_unget_token(parser);\n    return RET_OK;\n  }\n}\n\nstatic ret_t fexpr_parse_function(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  fscript_args_t* args = NULL;\n  token_t* t = fscript_parser_get_token(parser);\n  fscript_func_call_t* acall = NULL;\n  if (t->token[0] == '-' && t->size == 1) {\n    acall = fscript_func_call_create(parser, \"minus\", 5);\n  } else {\n    acall = fscript_func_call_create(parser, t->token, t->size);\n  }\n  value_set_func(result, acall);\n  return_value_if_fail(acall != NULL, RET_BAD_PARAMS);\n\n  args = &(acall->args);\n  return_value_if_fail(fscript_parser_expect_token(parser, TOKEN_LPAREN, \"expect \\\"(\\\"\") == RET_OK,\n                       RET_FAIL);\n\n  do {\n    t = fscript_parser_get_token(parser);\n    if (t == NULL) {\n      return fscript_parser_set_error(parser, \"expect \\\")\\\"\");\n    }\n\n    if (t->type == TOKEN_RPAREN) {\n      break;\n    } else {\n      fscript_parser_unget_token(parser);\n    }\n    value_set_int(&v, 0);\n    return_value_if_fail(fexpr_parse(parser, &v) == RET_OK, RET_FAIL);\n    func_args_push(args, &v);\n    t = fscript_parser_get_token(parser);\n\n    if (t == NULL) {\n      return fscript_parser_set_error(parser, \"expect \\\")\\\"\");\n    } else if (t->type == TOKEN_RPAREN) {\n      break;\n    }\n    fscript_parser_unget_token(parser);\n    if (acall->func == func_for) {\n      fscript_parser_expect_token(parser, TOKEN_SEMICOLON, \"expect \\\";\\\"\");\n    } else {\n      fscript_parser_expect_token(parser, TOKEN_COMMA, \"expect \\\",\\\"\");\n    }\n  } while (TRUE);\n\n  if (acall->func == func_if && acall->args.size == 1) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_if(parser, acall);\n    }\n  } else if ((acall->func == func_while || acall->func == func_until ||\n              acall->func == func_repeat_times) &&\n             acall->args.size == 1) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_block(parser, acall);\n    }\n  } else if (acall->func == func_for && acall->args.size == 3) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_block(parser, acall);\n    }\n  } else if (acall->func == func_for_in && acall->args.size == 2) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_block(parser, acall);\n    }\n  } else if (acall->func == func_repeat && acall->args.size == 4) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_block(parser, acall);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_term(fscript_parser_t* parser, value_t* result) {\n  ret_t ret = RET_OK;\n  token_t* t = fscript_parser_get_token(parser);\n  value_set_int(result, 0);\n  return_value_if_fail(t != NULL, RET_BAD_PARAMS);\n\n  if (t->type == TOKEN_NUMBER || t->type == TOKEN_ID || t->type == TOKEN_STR) {\n    if (t->type == TOKEN_ID && t->token[0] == '.') {\n      fscript_parser_set_error(parser, \"var can't begin with '.'\");\n    }\n    ret = token_to_value(parser, t, result);\n  } else if (t->type == TOKEN_FUNC) {\n    fscript_parser_unget_token(parser);\n    ret = fexpr_parse_function(parser, result);\n  } else if (t->type == TOKEN_RETURN) {\n    fscript_func_call_t* acall = fscript_func_call_create(parser, \"return\", 6);\n    return_value_if_fail(acall != NULL, RET_OOM);\n    value_set_func(result, acall);\n    t = fscript_parser_get_token(parser);\n    if (t != NULL && t->type != TOKEN_SEMICOLON && t->type != TOKEN_RBRACKET) {\n      value_t v;\n      value_set_int(&v, 0);\n      fscript_parser_unget_token(parser);\n      if (fexpr_parse(parser, &v) == RET_OK) {\n        func_args_push(&(acall->args), &v);\n      }\n    } else {\n      fscript_parser_unget_token(parser);\n    }\n  } else if (t->type == TOKEN_LPAREN) {\n    ret = fexpr_parse(parser, result);\n    return_value_if_fail(ret == RET_OK, ret);\n    ret = fscript_parser_expect_token(parser, TOKEN_RPAREN, \"expect )\");\n  } else {\n    fscript_parser_unget_token(parser);\n  }\n\n  return ret;\n}\n\nstatic ret_t fexpr_parse_unary(fscript_parser_t* parser, value_t* result) {\n  char c = '\\0';\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n  token_t* t = fscript_parser_get_token_ex(parser, FALSE);\n  if (t == NULL || t->type == TOKEN_EOF) {\n    return RET_OK;\n  }\n\n  c = t->token[0];\n  if (t->type == TOKEN_FUNC && (c == '!' || c == '~' || c == '-')) {\n    value_t v;\n    uint32_t i = 0;\n    bool_t valid = FALSE;\n    for (i = 0; i < t->size; i++) {\n      if (t->token[i] != c) {\n        return fscript_parser_set_error(parser, \"unexpected token\");\n      } else {\n        valid = !valid;\n      }\n    }\n\n    if (valid) {\n      acall = fscript_func_call_create(parser, &c, 1);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      value_set_func(result, acall);\n      return_value_if_fail(fexpr_parse_term(parser, &v) == RET_OK, RET_FAIL);\n      func_args_push(args, &v);\n    } else {\n      return_value_if_fail(fexpr_parse_term(parser, result) == RET_OK, RET_FAIL);\n    }\n  } else {\n    fscript_parser_unget_token(parser);\n    return_value_if_fail(fexpr_parse_term(parser, result) == RET_OK, RET_FAIL);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fsexpr_parse_product(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n  return_value_if_fail(fexpr_parse_unary(parser, result) == RET_OK, RET_FAIL);\n\n  while (TRUE) {\n    t = fscript_parser_get_token_ex(parser, TRUE);\n    if (t == NULL || t->type != TOKEN_FUNC) {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n\n    if (t->token[0] == '*' || t->token[0] == '/' || t->token[0] == '%') {\n      acall = fscript_func_call_create(parser, t->token, t->size);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      func_args_push(args, result);\n      value_set_func(result, acall);\n      v.type = VALUE_TYPE_INVALID;\n      fexpr_parse_unary(parser, &v);\n      if (v.type == VALUE_TYPE_INVALID) {\n        fscript_parser_set_error(parser, \"expect an expression\");\n      } else {\n        func_args_push(args, &v);\n      }\n    } else {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_sum(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n  return_value_if_fail(fsexpr_parse_product(parser, result) == RET_OK, RET_FAIL);\n\n  while (TRUE) {\n    t = fscript_parser_get_token_ex(parser, TRUE);\n    if (t == NULL || t->type != TOKEN_FUNC) {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n\n    if (t->token[0] == '+' || t->token[0] == '-') {\n      parser->token.valid = FALSE;\n      acall = fscript_func_call_create(parser, t->token, t->size);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      func_args_push(args, result);\n      value_set_func(result, acall);\n      v.type = VALUE_TYPE_INVALID;\n      fsexpr_parse_product(parser, &v);\n      if (v.type == VALUE_TYPE_INVALID) {\n        fscript_parser_set_error(parser, \"expect an expression\");\n      } else {\n        func_args_push(args, &v);\n      }\n    } else {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_compare(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n\n  value_set_int(result, 0);\n  return_value_if_fail(fexpr_parse_sum(parser, result) == RET_OK, RET_FAIL);\n\n  t = fscript_parser_get_token_ex(parser, TRUE);\n  if (t == NULL || t->type != TOKEN_FUNC || tk_str_eq(t->token, \"=\")) {\n    fscript_parser_unget_token(parser);\n    return RET_OK;\n  }\n\n  if (t->token[0] == '>' || t->token[0] == '<' || t->token[0] == '=' ||\n      (t->token[0] == '!' && t->token[1] == '=')) {\n    acall = fscript_func_call_create(parser, t->token, t->size);\n    return_value_if_fail(acall != NULL, RET_OOM);\n    args = &(acall->args);\n    func_args_push(args, result);\n    value_set_func(result, acall);\n    v.type = VALUE_TYPE_INVALID;\n    fexpr_parse_sum(parser, &v);\n    if (v.type == VALUE_TYPE_INVALID) {\n      fscript_parser_set_error(parser, \"expect an expression\");\n    } else {\n      func_args_push(args, &v);\n    }\n  } else {\n    fscript_parser_unget_token(parser);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_logic(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n\n  value_set_int(result, 0);\n  return_value_if_fail(fexpr_parse_compare(parser, result) == RET_OK, RET_FAIL);\n\n  while (TRUE) {\n    t = fscript_parser_get_token_ex(parser, TRUE);\n    if (t == NULL || t->type != TOKEN_FUNC || tk_str_eq(t->token, \"=\")) {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n\n    if (t->token[0] == '|' || t->token[0] == '&' || t->token[0] == '^') {\n      acall = fscript_func_call_create(parser, t->token, t->size);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      func_args_push(args, result);\n      value_set_func(result, acall);\n      v.type = VALUE_TYPE_INVALID;\n      fexpr_parse_compare(parser, &v);\n      if (v.type == VALUE_TYPE_INVALID) {\n        fscript_parser_set_error(parser, \"expect an expression\");\n      } else {\n        func_args_push(args, &v);\n      }\n    } else {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_question(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  ret_t ret = RET_OK;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n\n  value_set_str(&v, NULL);\n  if (fexpr_parse_logic(parser, result) == RET_OK) {\n    t = fscript_parser_get_token(parser);\n    if (t && t->type == TOKEN_QUESTION) {\n      acall = fscript_func_call_create(parser, \"if\", 2);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      func_args_push(args, result);\n      value_set_func(result, acall);\n\n      value_reset(&v);\n      return_value_if_fail(fexpr_parse_logic(parser, &v) == RET_OK, RET_FAIL);\n      func_args_push(args, &v);\n\n      return_value_if_fail(fscript_parser_expect_token(parser, TOKEN_COLON, \"expect :\") == RET_OK,\n                           RET_FAIL);\n      return_value_if_fail(fexpr_parse_logic(parser, &v) == RET_OK, RET_FAIL);\n      func_args_push(args, &v);\n    } else {\n      fscript_parser_unget_token(parser);\n    }\n  } else {\n    ret = RET_FAIL;\n  }\n\n  return ret;\n}\n\nstatic ret_t fexpr_parse(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  bool_t is_local = FALSE;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n  value_set_int(result, 0);\n\n  t = fscript_parser_get_token_ex(parser, TRUE);\n  if (t == NULL || t->type == TOKEN_RBRACKET || t->type == TOKEN_SEMICOLON) {\n    value_reset(result);\n    fscript_parser_unget_token(parser);\n    return RET_OK;\n  }\n\n  if (t->type == TOKEN_VAR) {\n    is_local = TRUE;\n  } else {\n    fscript_parser_unget_token(parser);\n  }\n  return_value_if_fail(fexpr_parse_question(parser, result) == RET_OK, RET_FAIL);\n\n  t = fscript_parser_get_token_ex(parser, TRUE);\n  if (t != NULL && tk_str_eq(t->token, \"=\")) {\n    const char* name = is_local ? \"set_local\" : \"=\";\n    acall = fscript_func_call_create(parser, name, strlen(name));\n    return_value_if_fail(acall != NULL, RET_OOM);\n    args = &(acall->args);\n    func_args_push(args, result);\n    value_set_func(result, acall);\n    v.type = VALUE_TYPE_INVALID;\n    fexpr_parse_question(parser, &v);\n    if (v.type == VALUE_TYPE_INVALID) {\n      fscript_parser_set_error(parser, \"expect an expression\");\n    } else {\n      func_args_push(args, &v);\n    }\n\n    if (is_local) {\n      darray_push_unique(parser->symbols, (void*)value_id(args->args));\n    }\n  } else {\n    fscript_parser_unget_token(parser);\n  }\n\n  return RET_OK;\n}\n\nstatic fscript_t* fscript_init_with_parser(fscript_t* fscript, fscript_parser_t* parser) {\n  fscript = fscript != NULL ? fscript : TKMEM_ZALLOC(fscript_t);\n  return_value_if_fail(fscript != NULL, NULL);\n  fscript->str = parser->temp;\n  fscript->obj = parser->obj;\n  fscript->first = parser->first;\n  fscript->funcs_def = parser->funcs_def;\n  fscript->code_id = parser->code_id;\n  fscript->lines = parser->row + 1;\n\n  if (s_hooks != NULL && s_hooks->on_init != NULL) {\n    s_hooks->on_init(fscript, parser->str);\n  }\n\n  parser->obj = NULL;\n  parser->first = NULL;\n  parser->temp.str = NULL;\n  parser->funcs_def = NULL;\n  parser->code_id = NULL;\n\n  return fscript;\n}\n\nstatic ret_t func_function(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  ret_t ret = RET_OK;\n  darray_t* saved_locals = fscript->locals;\n  fscript_function_def_t* func_def = (fscript_function_def_t*)(fscript->curr->ctx);\n  fscript_func_call_t* func = func_def->body;\n\n  func->func = func_noop;\n  fscript->locals = NULL;\n  if (func_def->params.size > 0 && args->size > 0) {\n    uint32_t i = 0;\n    uint32_t n = tk_min(func_def->params.size, args->size);\n    for (i = 0; i < n; i++) {\n      const value_t* value = args->args + i;\n      const char* name = (const char*)(func_def->params.elms[i]);\n      fscript_locals_create(fscript, name, value);\n    }\n  }\n\n  ret = fscript_exec_func(fscript, func_def->name, func, result);\n\n  fscript_locals_destroy(fscript);\n  fscript->locals = saved_locals;\n  fscript->returned = FALSE;\n\n  return ret;\n}\n\nstatic ret_t fscript_parse_function_def(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  value_t v;\n  char func_name[TK_NAME_LEN + 1];\n  fscript_function_def_t* func_def = NULL;\n  fscript_func_call_t* statements = NULL;\n  token_t* t = fscript_parser_get_token(parser);\n  darray_t* saved_symbols = parser->symbols;\n\n  if (t->type != TOKEN_FUNC) {\n    return fscript_parser_set_error(parser, \"expect function name\\n\");\n  }\n  tk_strncpy(func_name, t->token, TK_NAME_LEN);\n  fscript_parser_expect_token(parser, TOKEN_LPAREN, \"expect \\\"(\\\"\");\n  if (parser->funcs_def == NULL) {\n    parser->funcs_def = object_default_create();\n  }\n\n  if (tk_object_get_prop(parser->funcs_def, func_name, &v) == RET_OK) {\n    return fscript_parser_set_error(parser, \"duplicate function\\n\");\n  }\n  statements = fscript_func_call_create(parser, \"func\", 4);\n  return_value_if_fail(statements != NULL, RET_OOM);\n\n  func_def = fscript_function_def_create(func_name, statements);\n  return_value_if_fail(func_def != NULL, RET_OOM);\n  value_set_func_def(&v, func_def);\n  tk_object_set_prop(parser->funcs_def, func_name, &v);\n\n  parser->symbols = darray_create(5, NULL, (tk_compare_t)tk_str_cmp);\n  while (TRUE) {\n    t = fscript_parser_get_token(parser);\n    if (t == NULL || t->type == TOKEN_EOF || t->type == TOKEN_RPAREN) {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n    if (t->type == TOKEN_ID) {\n      fscript_function_def_add_param(func_def, t->token);\n      darray_push_unique(parser->symbols,\n                         (void*)darray_get(&(func_def->params), func_def->params.size - 1));\n    } else if (t->type == TOKEN_COMMA) {\n    } else {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n  }\n  fscript_parser_expect_token(parser, TOKEN_RPAREN, \"expect \\\")\\\"\");\n  fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\");\n  fscript_parse_statements(parser, statements);\n  fscript_parser_expect_token(parser, TOKEN_RBRACKET, \"expect \\\"}\\\"\");\n  darray_destroy(parser->symbols);\n  parser->symbols = saved_symbols;\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parse_statements(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  value_t v;\n  ret_t ret = RET_OK;\n  fscript_args_t* args = NULL;\n  return_value_if_fail(parser != NULL && acall != NULL, RET_BAD_PARAMS);\n\n  args = &(acall->args);\n\n  do {\n    token_t* t = NULL;\n    value_set_int(&v, 0);\n    ret = fexpr_parse(parser, &v);\n    if (ret == RET_OK) {\n      if (v.type != VALUE_TYPE_INVALID) {\n        func_args_push(args, &v);\n      }\n      t = fscript_parser_get_token(parser);\n      if (t == NULL) {\n        break;\n      }\n\n      if (t->type == TOKEN_FUNC || t->type == TOKEN_ID || t->type == TOKEN_NUMBER ||\n          t->type == TOKEN_STR || t->type == TOKEN_VAR || t->type == TOKEN_RETURN) {\n        fscript_parser_unget_token(parser);\n      } else if (t->type == TOKEN_RBRACKET || t->type == TOKEN_FUNC_DEF) {\n        fscript_parser_unget_token(parser);\n        break;\n      } else if (t->type != TOKEN_COMMA && t->type != TOKEN_SEMICOLON) {\n        return fscript_parser_set_error(parser, \"unexpected token\\n\");\n      }\n    } else {\n      if (v.type == VALUE_TYPE_FSCRIPT_FUNC) {\n        fscript_func_call_destroy(value_func(&v));\n      } else {\n        value_reset(&v);\n      }\n\n      break;\n    }\n  } while (parser->token.type != TOKEN_EOF);\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parse_all(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  ret_t ret = RET_OK;\n  while (ret == RET_OK) {\n    token_t* t = fscript_parser_get_token(parser);\n    if (t && t->type == TOKEN_FUNC_DEF) {\n      ret = fscript_parse_function_def(parser, acall);\n    } else if (t == NULL || t->type == TOKEN_EOF) {\n      break;\n    } else if (t->type == TOKEN_RBRACKET) {\n      fscript_parser_set_error(parser, \"unexpected token\");\n      break;\n    } else {\n      fscript_parser_unget_token(parser);\n      ret = fscript_parse_statements(parser, acall);\n    }\n  }\n\n  return ret;\n}\n\nfscript_parser_error_t* fscript_parser_error_init(fscript_parser_error_t* error) {\n  return_value_if_fail(error != NULL, NULL);\n  memset(error, 0x00, sizeof(fscript_parser_error_t));\n\n  return error;\n}\n\nret_t fscript_parser_error_deinit(fscript_parser_error_t* error) {\n  return_value_if_fail(error != NULL, RET_BAD_PARAMS);\n  TKMEM_FREE(error->token);\n  TKMEM_FREE(error->message);\n\n  return RET_OK;\n}\n\nret_t fscript_syntax_check(tk_object_t* obj, const char* script, fscript_parser_error_t* error) {\n  ret_t ret = RET_OK;\n  fscript_parser_t parser;\n  return_value_if_fail(obj != NULL && script != NULL && error != NULL, RET_BAD_PARAMS);\n  fscript_parser_error_init(error);\n  fscript_parser_init(&parser, obj, script, error);\n\n  parser.first = fscript_func_call_create(&parser, \"expr\", 4);\n  ret = fscript_parse_all(&parser, parser.first);\n  fscript_parser_deinit(&parser);\n\n  return ret;\n}\n\nstatic fscript_t* fscript_load(fscript_t* fscript, tk_object_t* obj, const char* script,\n                               const char* first_call_name, bool_t keep_func_name) {\n  ret_t ret = RET_OK;\n  fscript_parser_t parser;\n  fscript_parser_error_t error;\n  return_value_if_fail(script != NULL, NULL);\n\n  fscript_parser_error_init(&error);\n  fscript_parser_init(&parser, obj, script, &error);\n  parser.keep_func_name = keep_func_name;\n  parser.first = fscript_func_call_create(&parser, first_call_name, strlen(first_call_name));\n  ret = fscript_parse_all(&parser, parser.first);\n  if (ret == RET_OK) {\n    fscript = fscript_init_with_parser(fscript, &parser);\n    fscript_parser_deinit(&parser);\n  } else {\n    log_warn(\"parser error:%s\\n\", script);\n    fscript_parser_deinit(&parser);\n  }\n  fscript_parser_error_deinit(&error);\n\n  return fscript;\n}\n\nret_t fscript_reload(fscript_t* fscript, const char* script) {\n  tk_object_t* obj = NULL;\n  return_value_if_fail(fscript != NULL && fscript->obj != NULL && script != NULL, RET_BAD_PARAMS);\n  obj = fscript->obj;\n  fscript_reset(fscript);\n\n  return fscript_load(fscript, obj, script, \"expr\", FALSE) != NULL ? RET_OK : RET_FAIL;\n}\n\nfscript_t* fscript_init(fscript_t* fscript, tk_object_t* obj, const char* script,\n                        const char* first_call_name, bool_t keep_func_name) {\n  return fscript_load(fscript, obj, script, first_call_name, keep_func_name);\n}\n\nfscript_t* fscript_create_ex(tk_object_t* obj, const char* script, bool_t keep_func_name) {\n  return fscript_load(NULL, obj, script, \"expr\", keep_func_name);\n}\n\nfscript_t* fscript_create(tk_object_t* obj, const char* script) {\n  return fscript_create_ex(obj, script, FALSE);\n}\n\n/*functions*/\nstatic ret_t func_get_last_error(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  if (fscript->error_code != RET_OK) {\n    tk_object_t* obj = object_default_create();\n    return_value_if_fail(obj != NULL, RET_OOM);\n    tk_object_set_prop_int(obj, \"col\", fscript->error_col);\n    tk_object_set_prop_int(obj, \"line\", fscript->error_row);\n    tk_object_set_prop_int(obj, \"code\", fscript->error_code);\n    tk_object_set_prop_str(obj, \"message\", fscript->error_message);\n    value_set_object(result, obj);\n    result->free_handle = TRUE;\n  } else {\n    value_set_int(result, 0);\n    value_reset(result);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_has_error(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  value_set_bool(result, fscript->error_code != RET_OK);\n  return RET_OK;\n}\n\nstatic ret_t func_clear_error(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  fscript_set_error(fscript, RET_OK, NULL, NULL);\n  return RET_OK;\n}\n\nstatic ret_t func_sum(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  double v = 0;\n  uint32_t i = 0;\n  bool_t has_str = FALSE;\n  bool_t has_float = FALSE;\n  FSCRIPT_FUNC_CHECK(args->size > 0, RET_BAD_PARAMS);\n\n  for (i = 0; i < args->size; i++) {\n    int type = args->args[i].type;\n    if (type == VALUE_TYPE_STRING) {\n      has_str = TRUE;\n    }\n    if (type == VALUE_TYPE_FLOAT || type == VALUE_TYPE_DOUBLE || type == VALUE_TYPE_FLOAT32) {\n      has_float = TRUE;\n    }\n  }\n\n  if (has_str) {\n    str_t str;\n    char buff[64];\n    str_init(&str, 100);\n    for (i = 0; i < args->size; i++) {\n      str_append(&str, value_str_ex(args->args + i, buff, sizeof(buff) - 1));\n    }\n    value_dup_str(result, str.str);\n    str_reset(&str);\n  } else {\n    for (i = 0; i < args->size; i++) {\n      v += value_double(args->args + i);\n    }\n    if (has_float) {\n      value_set_double(result, v);\n    } else {\n      value_set_int(result, (int)v);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_int(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int(result, value_int(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_i8(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int8(result, value_int8(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_i16(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int16(result, value_int16(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_i32(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int(result, value_int(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_i64(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int64(result, value_int64(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_u8(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_uint8(result, value_uint8(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_u16(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_uint16(result, value_uint16(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_u32(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_uint32(result, value_uint32(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_u64(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_uint64(result, value_uint64(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_f32(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_float32(result, value_float32(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_double(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_double(result, value_double(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_binary(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  void* p = NULL;\n  uint32_t size = 0;\n  /*基本类型默认拷贝*/\n  bool_t clone = TRUE;\n  value_t* v = args->args;\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n\n  switch (v->type) {\n    case VALUE_TYPE_BOOL: {\n      size = sizeof(int8_t);\n      p = &(v->value.b);\n      break;\n    }\n    case VALUE_TYPE_INT8: {\n      size = sizeof(int8_t);\n      p = &(v->value.i8);\n      break;\n    }\n    case VALUE_TYPE_UINT8: {\n      size = sizeof(uint8_t);\n      p = &(v->value.u8);\n      break;\n    }\n    case VALUE_TYPE_INT16: {\n      size = sizeof(int16_t);\n      p = &(v->value.i16);\n      break;\n    }\n    case VALUE_TYPE_UINT16: {\n      size = sizeof(uint16_t);\n      p = &(v->value.u16);\n      break;\n    }\n    case VALUE_TYPE_INT32: {\n      size = sizeof(int32_t);\n      p = &(v->value.i32);\n      break;\n    }\n    case VALUE_TYPE_UINT32: {\n      size = sizeof(uint32_t);\n      p = &(v->value.u32);\n      break;\n    }\n    case VALUE_TYPE_INT64: {\n      size = sizeof(int64_t);\n      p = &(v->value.i64);\n      break;\n    }\n    case VALUE_TYPE_UINT64: {\n      size = sizeof(uint64_t);\n      p = &(v->value.u64);\n      break;\n    }\n    case VALUE_TYPE_FLOAT: {\n      size = sizeof(float_t);\n      p = &(v->value.f32);\n      break;\n    }\n    case VALUE_TYPE_FLOAT32: {\n      size = sizeof(float);\n      p = &(v->value.f32);\n      break;\n    }\n    case VALUE_TYPE_DOUBLE: {\n      size = sizeof(double);\n      p = &(v->value.f64);\n      break;\n    }\n    case VALUE_TYPE_STRING: {\n      p = (void*)value_str(v);\n      size = tk_strlen(value_str(v));\n      clone = FALSE;\n      break;\n    }\n    case VALUE_TYPE_WSTRING: {\n      p = (void*)value_wstr(v);\n      size = wcslen(value_wstr(v)) * sizeof(wchar_t);\n      clone = FALSE;\n      break;\n    }\n    case VALUE_TYPE_POINTER: {\n      p = value_pointer(v);\n      size = args->size > 1 ? value_uint32(args->args + 1) : 0;\n      clone = FALSE;\n      break;\n    }\n    case VALUE_TYPE_BINARY: {\n      p = v->value.binary_data.data;\n      size = v->value.binary_data.size;\n      clone = FALSE;\n      break;\n    }\n    case VALUE_TYPE_SIZED_STRING: {\n      p = v->value.sized_str.str;\n      size = v->value.sized_str.size;\n      clone = FALSE;\n      break;\n    }\n    default: {\n      log_debug(\"not supported type\\n\");\n      break;\n    }\n  }\n\n  if (p == NULL || size == 0) {\n    value_set_binary_data(result, p, size);\n    return RET_OK;\n  }\n\n  /*参数1指定长度*/\n  if (args->size > 1) {\n    uint32_t esize = value_uint32(args->args + 1);\n    if (esize <= size) {\n      size = esize;\n    } else {\n      log_debug(\"size is too large, use default\\n\");\n    }\n  }\n\n  /*参数2要求复制*/\n  if (args->size > 2 && value_bool(args->args + 2)) {\n    clone = TRUE;\n  }\n\n  if (clone) {\n    p = tk_memdup(p, size);\n    value_set_binary_data(result, p, size);\n    result->free_handle = TRUE;\n  } else {\n    value_set_binary_data(result, p, size);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_str(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  str_t* str = &(fscript->str);\n  value_t* v = args->args;\n  bool_t force_pointer_as_str = args->size == 2 && value_bool(args->args + 1);\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n\n  if (force_pointer_as_str) {\n    if (v->type == VALUE_TYPE_POINTER) {\n      value_set_str(result, (const char*)value_pointer(v));\n      return RET_OK;\n    } else if (v->type == VALUE_TYPE_BINARY) {\n      value_set_str(result, (const char*)(v->value.binary_data.data));\n      return RET_OK;\n    }\n  }\n  str_from_value(str, args->args);\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}\n\nstatic ret_t func_one_of(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  char sep = ';';\n  int32_t index = 0;\n  const char* strs = NULL;\n  const char* start = NULL;\n\n  value_set_str(result, \"\");\n  FSCRIPT_FUNC_CHECK(args->size >= 2, RET_BAD_PARAMS);\n  FSCRIPT_FUNC_CHECK(args->args[0].type == VALUE_TYPE_STRING, RET_BAD_PARAMS);\n  strs = value_str(args->args);\n  FSCRIPT_FUNC_CHECK(strs != NULL, RET_BAD_PARAMS);\n\n  if (args->size > 2 && args->args[2].type == VALUE_TYPE_STRING) {\n    const char* p = value_str(args->args + 2);\n    if (p != NULL) {\n      sep = *p;\n    }\n  }\n\n  start = strs;\n  index = value_int(args->args + 1);\n\n  while (index > 0) {\n    while (*start && *start != sep) {\n      start++;\n    }\n    if (*start == '\\0') {\n      break;\n    }\n    index--;\n    start++;\n  }\n\n  if (start != NULL) {\n    const char* end = strchr(start, sep);\n    if (end != NULL) {\n      value_dup_str_with_len(result, start, end - start);\n    } else {\n      value_dup_str(result, start);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_join(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  char buff[64];\n  str_t* str = &(fscript->str);\n  value_set_bool(result, FALSE);\n  FSCRIPT_FUNC_CHECK(args->size > 1, RET_BAD_PARAMS);\n\n  str_set(str, \"\");\n  value_set_bool(result, TRUE);\n  for (i = 1; i < args->size; i++) {\n    if (i > 1) {\n      str_append(str, value_str_ex(args->args, buff, sizeof(buff)));\n    }\n    str_append(str, value_str_ex(args->args + i, buff, sizeof(buff)));\n  }\n\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}\n\nstatic ret_t func_set_local(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  const char* name = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  name = value_id(args->args);\n  FSCRIPT_FUNC_CHECK(name != NULL, RET_BAD_PARAMS);\n  value_set_bool(result, fscript_locals_create(fscript, name, args->args + 1) == RET_OK);\n\n  return RET_OK;\n}\n\nstatic ret_t func_get(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  ret_t ret = RET_OK;\n  value_t* v = args->args;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  return_value_if_fail(v->type == VALUE_TYPE_ID, RET_BAD_PARAMS);\n\n  if (value_id_index(v) >= 0) {\n    ret = fscript_locals_get(fscript, v, result);\n  } else {\n    const char* name = value_id(v);\n    ret = fscript_get_var(fscript, name, result);\n  }\n\n  if (ret != RET_OK) {\n    result->type = VALUE_TYPE_INVALID;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_set(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  int32_t index = 0;\n  value_t* v = args->args;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  return_value_if_fail(v->type == VALUE_TYPE_ID, RET_BAD_PARAMS);\n\n  index = value_id_index(v);\n  if (index >= 0) {\n    value_set_bool(result, fscript_locals_set(fscript, v, args->args + 1) == RET_OK);\n  } else {\n    const char* name = value_id(v);\n    value_set_bool(result, fscript_set_var(fscript, name, args->args + 1) == RET_OK);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_unset(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  int32_t index = 0;\n  value_t* v = args->args;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  return_value_if_fail(v->type == VALUE_TYPE_ID, RET_BAD_PARAMS);\n\n  index = value_id_index(v);\n  if (index >= 0) {\n    fscript_locals_remove(fscript, index);\n  } else {\n    const char* name = value_id(v);\n    tk_object_remove_prop(fscript->obj, name);\n  }\n  value_set_bool(result, TRUE);\n\n  return RET_OK;\n}\n\nstatic ret_t func_expr(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  if (args->size >= 1) {\n    value_deep_copy(result, args->args + args->size - 1);\n  } else {\n    result->type = VALUE_TYPE_INVALID;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_print(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  char buff[64];\n\n  value_set_bool(result, TRUE);\n  for (i = 0; i < args->size; i++) {\n    log_info(\"%s \", value_str_ex(args->args + i, buff, sizeof(buff) - 1));\n  }\n  log_info(\"\\n\");\n\n  if (fscript->print != NULL) {\n    return fscript->print(fscript, args, result);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_iformat(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  str_t* str = &(fscript->str);\n  const char* format = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  format = value_str(args->args);\n  FSCRIPT_FUNC_CHECK(format != NULL, RET_BAD_PARAMS);\n\n  tk_snprintf(str->str, str->capacity - 1, format, value_int(args->args + 1));\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}\n\nstatic ret_t func_fformat(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  str_t* str = &(fscript->str);\n  const char* format = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  format = value_str(args->args);\n  FSCRIPT_FUNC_CHECK(format != NULL, RET_BAD_PARAMS);\n\n  tk_snprintf(str->str, str->capacity - 1, format, value_double(args->args + 1));\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}\n\nstatic ret_t func_and(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value_set_bool(result, value_bool(args->args) && value_bool(args->args + 1));\n\n  return RET_OK;\n}\n\nstatic ret_t func_or(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value_set_bool(result, value_bool(args->args) || value_bool(args->args + 1));\n\n  return RET_OK;\n}\n\nstatic ret_t func_not(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_bool(result, !value_bool(args->args));\n\n  return RET_OK;\n}\n\nstatic ret_t func_minus(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  if (args->args[0].type == VALUE_TYPE_INT32) {\n    value_set_int(result, -value_int(args->args));\n  } else {\n    value_set_double(result, -value_double(args->args));\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_div(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value_set_double(result, value_double(args->args) / value_double(args->args + 1));\n\n  return RET_OK;\n}\n\nstatic ret_t func_mod(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value_set_int(result, value_int(args->args) % value_int(args->args + 1));\n\n  return RET_OK;\n}\n\nstatic ret_t func_mul(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value_set_double(result, value_double(args->args) * value_double(args->args + 1));\n\n  return RET_OK;\n}\n\nstatic ret_t func_sub(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n  if (args->size == 1) {\n    func_minus(fscript, args, result);\n  } else {\n    if (args->args->type == VALUE_TYPE_INT32 && args->args[1].type == VALUE_TYPE_INT32) {\n      value_set_int(result, value_int(args->args) - value_int(args->args + 1));\n    } else {\n      value_set_double(result, value_double(args->args) - value_double(args->args + 1));\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_random(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  long v = random();\n  if (args->size == 2) {\n    int32_t min = value_int(args->args);\n    int32_t max = value_int(args->args + 1);\n    if (min < max) {\n      v = min + v % (max - min);\n    }\n  }\n\n  value_set_int(result, v);\n\n  return RET_OK;\n}\n\nstatic ret_t func_le(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  if (args->args[0].type == VALUE_TYPE_STRING && args->args[1].type == VALUE_TYPE_STRING) {\n    value_set_bool(result, tk_str_cmp(value_str(args->args), value_str(args->args + 1)) <= 0);\n  } else {\n    value_set_bool(result, value_double(args->args) <= value_double(args->args + 1));\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_less(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  if (args->args[0].type == VALUE_TYPE_STRING && args->args[1].type == VALUE_TYPE_STRING) {\n    value_set_bool(result, tk_str_cmp(value_str(args->args), value_str(args->args + 1)) < 0);\n  } else {\n    value_set_bool(result, value_double(args->args) < value_double(args->args + 1));\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_ge(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  if (args->args[0].type == VALUE_TYPE_STRING && args->args[1].type == VALUE_TYPE_STRING) {\n    value_set_bool(result, tk_str_cmp(value_str(args->args), value_str(args->args + 1)) >= 0);\n  } else {\n    value_set_bool(result, value_double(args->args) >= value_double(args->args + 1));\n  }\n  return RET_OK;\n}\n\nstatic ret_t func_great(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  if (args->args[0].type == VALUE_TYPE_STRING && args->args[1].type == VALUE_TYPE_STRING) {\n    value_set_bool(result, tk_str_cmp(value_str(args->args), value_str(args->args + 1)) > 0);\n  } else {\n    value_set_bool(result, value_double(args->args) > value_double(args->args + 1));\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_eq(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  value_t* v1 = NULL;\n  value_t* v2 = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  v1 = args->args;\n  v2 = args->args + 1;\n\n  if (v1->type == VALUE_TYPE_STRING && v2->type == VALUE_TYPE_STRING) {\n    value_set_bool(result, tk_str_eq(value_str(v1), value_str(v2)));\n  } else if (v1->type == VALUE_TYPE_POINTER && v2->type == VALUE_TYPE_POINTER) {\n    value_set_bool(result, value_pointer(v1) == value_pointer(v2));\n  } else if (v1->type == VALUE_TYPE_OBJECT && v2->type == VALUE_TYPE_OBJECT) {\n    value_set_bool(result, value_object(v1) == value_object(v2));\n  } else if (v1->type == VALUE_TYPE_BINARY && v2->type == VALUE_TYPE_BINARY) {\n    binary_data_t* bin1 = value_binary_data(v1);\n    binary_data_t* bin2 = value_binary_data(v2);\n    if (bin1->size == bin2->size) {\n      value_set_bool(result, tk_str_cmp((const char*)bin1->data, (const char*)bin2->data) == 0);\n    } else {\n      value_set_bool(result, FALSE);\n    }\n  } else if (v1->type == VALUE_TYPE_INT64 || v2->type == VALUE_TYPE_INT64) {\n    value_set_bool(result, value_int64(v1) == value_int64(v2));\n  } else if (v1->type == VALUE_TYPE_UINT64 || v2->type == VALUE_TYPE_UINT64) {\n    value_set_bool(result, value_uint64(v1) == value_uint64(v2));\n  } else if (v1->type != v2->type && !(value_is_digit(v1) && value_is_digit(v2))) {\n    value_set_bool(result, FALSE);\n  } else {\n    value_set_bool(result, tk_fequal(value_double(v1), value_double(v2)));\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_not_eq(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  func_eq(fscript, args, result);\n  value_set_bool(result, !value_bool(result));\n\n  return RET_OK;\n}\n\nstatic ret_t func_assert(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n  if (!value_bool(args->args)) {\n    fscript_set_error(fscript, RET_FAIL, __FUNCTION__,\n                      args->size > 1 ? value_str(args->args + 1) : \"unkown\");\n    if (args->size > 1 && value_bool(args->args + 1)) {\n      assert(0);\n    } else {\n      log_debug(\"assert failed at: (%d %d)\\n\", (int)(fscript->curr->row),\n                (int)(fscript->curr->col));\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_min(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  double v1 = 0;\n  double v2 = 0;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n\n  v1 = value_double(args->args);\n  v2 = value_double(args->args + 1);\n  value_set_double(result, tk_min(v1, v2));\n\n  return RET_OK;\n}\n\nstatic ret_t func_max(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  double v1 = 0;\n  double v2 = 0;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n\n  v1 = value_double(args->args);\n  v2 = value_double(args->args + 1);\n  value_set_double(result, tk_max(v1, v2));\n\n  return RET_OK;\n}\n\nstatic ret_t func_clamp(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  double v1 = 0;\n  double v2 = 0;\n  double v3 = 0;\n  FSCRIPT_FUNC_CHECK(args->size == 3, RET_BAD_PARAMS);\n\n  v1 = value_double(args->args);\n  v2 = value_double(args->args + 1);\n  v3 = value_double(args->args + 2);\n  value_set_double(result, tk_clamp(v1, v2, v3));\n\n  return RET_OK;\n}\n\nstatic ret_t func_round(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_double(result, tk_roundi(value_double(args->args)));\n  return RET_OK;\n}\n\nstatic ret_t func_floor(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_double(result, floor(value_double(args->args)));\n  return RET_OK;\n}\n\nstatic ret_t func_ceil(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_double(result, ceil(value_double(args->args)));\n  return RET_OK;\n}\n\nstatic ret_t func_abs(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_double(result, tk_abs(value_double(args->args)));\n  return RET_OK;\n}\n\nstatic ret_t func_len(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  char buff[64];\n  const char* str = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n\n  if (args->args->type == VALUE_TYPE_OBJECT) {\n    tk_object_t* obj = value_object(args->args);\n    value_set_uint32(result, tk_object_get_prop_int32(obj, \"size\", 0));\n  } else if (args->args->type == VALUE_TYPE_BINARY) {\n    binary_data_t* data = value_binary_data(args->args);\n    value_set_uint32(result, data != NULL ? data->size : 0);\n  } else if (args->args->type == VALUE_TYPE_STRING) {\n    value_set_uint32(result, tk_strlen(value_str(args->args)));\n  } else {\n    str = value_str_ex(args->args, buff, sizeof(buff) - 1);\n    value_set_uint32(result, tk_strlen(str));\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_toupper(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  str_t* str = &(fscript->str);\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  str_set(str, value_str(args->args));\n  str_to_upper(str);\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}\n\nstatic ret_t func_eval(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  return fscript_eval(fscript->obj, value_str(args->args), result);\n}\n\nstatic ret_t func_tolower(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  str_t* str = &(fscript->str);\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  str_set(str, value_str(args->args));\n  str_to_lower(str);\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}\n\nstatic ret_t func_trim(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  str_t* str = &(fscript->str);\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  str_set(str, value_str(args->args));\n  str_trim(str, \" \\t\\r\\n\");\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}\n\nstatic ret_t func_substr(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  str_t* str = &(fscript->str);\n  const char* org = NULL;\n  uint32_t total_len = 0;\n  uint32_t from = 0;\n  uint32_t len = 0;\n  FSCRIPT_FUNC_CHECK(args->size == 3, RET_BAD_PARAMS);\n  org = value_str(args->args);\n  from = value_uint32(args->args + 1);\nlen = ",
    "raw_res": "0;",
    "prompt_res": "value_uint32(args->args + 2);",
    "gt": "value_uint32(args->args + 2);"
  },
  {
    "id": 815,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/fscript.c",
    "input": "﻿/**\n * File:   fscript.c\n * Author: AWTK Develop Team\n * Brief:  a simple script language\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2020-11-09 Li XianJing <lixianjing@zlg.cn> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/darray.h\"\n#include \"tkc/fscript.h\"\n#include \"tkc/object_default.h\"\n#include \"tkc/general_factory.h\"\n#include \"tkc/object_locker.h\"\n\n#ifndef WITHOUT_FSCRIPT\n#define value_id_index(v) (v)->value.id.index\n#define value_id_suboffset(v) (v)->value.id.suboffset\n\nstatic const fscript_hooks_t* s_hooks;\n\nret_t fscript_set_hooks(const fscript_hooks_t* hooks) {\n  s_hooks = hooks;\n  return RET_OK;\n}\n\nstatic ret_t func_function_def(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_if(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_while(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_until(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_repeat_times(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_repeat(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_for(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_for_in(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_noop(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_pending(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  return RET_OK;\n}\nstatic ret_t func_return(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  if (args->size > 0) {\n    value_deep_copy(result, args->args);\n  }\n  fscript->returned = TRUE;\n  return RET_OK;\n}\nstatic ret_t func_get(fscript_t* fscript, fscript_args_t* args, value_t* result);\nstatic ret_t func_set(fscript_t* fscript, fscript_args_t* args, value_t* result);\nstatic ret_t func_unset(fscript_t* fscript, fscript_args_t* args, value_t* result);\nstatic ret_t func_set_local(fscript_t* fscript, fscript_args_t* args, value_t* result);\nstatic ret_t fscript_func_call_init_func(fscript_func_call_t* call, tk_object_t* obj,\n                                         tk_object_t* funcs_def, const char* name, uint32_t size);\n\nret_t fscript_ensure_locals(fscript_t* fscript) {\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n\n  if (fscript->locals == NULL) {\n    fscript->locals = darray_create(5, (tk_destroy_t)named_value_destroy,\n                                    (tk_compare_t)named_value_compare_by_name);\n  }\n\n  return fscript->locals != NULL ? RET_OK : RET_FAIL;\n}\n\nstatic ret_t fscript_locals_remove(fscript_t* fscript, uint32_t index) {\n  named_value_t* nv = (named_value_t*)(fscript->locals->elms[index]);\n  return value_reset(&(nv->value));\n}\n\nstatic tk_object_t* fscript_locals_get_object(fscript_t* fscript, const char* name) {\n  named_value_t* nv = (named_value_t*)darray_find(fscript->locals, (void*)name);\n\n  return nv != NULL ? value_object(&(nv->value)) : NULL;\n}\n\nstatic ret_t fscript_locals_get(fscript_t* fscript, const value_t* name, value_t* v) {\n  int32_t index = value_id_index(name);\n  int32_t suboffset = value_id_suboffset(name);\n  named_value_t* nv = (named_value_t*)(fscript->locals->elms[index]);\n  if (!suboffset) {\n    return value_copy(v, &(nv->value));\n  } else {\n    tk_object_t* obj = value_object(&(nv->value));\n    const char* subname = value_id(name) + suboffset;\n    return_value_if_fail(obj != NULL, RET_BAD_PARAMS);\n\n    return tk_object_get_prop(obj, subname, v);\n  }\n}\n\nstatic ret_t fscript_locals_set_with_index(fscript_t* fscript, uint32_t index, const value_t* v) {\n  named_value_t* nv = (named_value_t*)(fscript->locals->elms[index]);\n  if (nv->value.free_handle) {\n    value_reset(&(nv->value));\n  }\n  return value_deep_copy(&(nv->value), v);\n}\n\nstatic ret_t fscript_locals_set(fscript_t* fscript, const value_t* name, value_t* v) {\n  int32_t index = value_id_index(name);\n  int32_t suboffset = value_id_suboffset(name);\n  named_value_t* nv = (named_value_t*)(fscript->locals->elms[index]);\n  if (!suboffset) {\n    return fscript_locals_set_with_index(fscript, index, v);\n  } else {\n    tk_object_t* obj = value_object(&(nv->value));\n    const char* subname = value_id(name) + suboffset;\n    return_value_if_fail(obj != NULL, RET_BAD_PARAMS);\n\n    return tk_object_set_prop(obj, subname, v);\n  }\n}\n\nstatic ret_t fscript_locals_create(fscript_t* fscript, const char* name, const value_t* v) {\n  int32_t index = 0;\n  named_value_t* nv = NULL;\n  return_value_if_fail(fscript_ensure_locals(fscript) == RET_OK, RET_BAD_PARAMS);\n  index = darray_find_index(fscript->locals, (void*)name);\n\n  if (index >= 0) {\n    fscript_set_error(fscript, RET_FAIL, \"<>\", \"duplicated var name.\");\n    return fscript_locals_set_with_index(fscript, index, v);\n  }\n\n  nv = named_value_create_ex(name, v);\n  return_value_if_fail(nv != NULL, RET_BAD_PARAMS);\n\n  if (darray_push_unique(fscript->locals, nv) != RET_OK) {\n    named_value_destroy(nv);\n    return RET_FAIL;\n  }\n  return RET_OK;\n}\n\nstatic ret_t fscript_locals_destroy(fscript_t* fscript) {\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n  if (fscript->locals != NULL) {\n    darray_destroy(fscript->locals);\n    fscript->locals = NULL;\n  }\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_func(fscript_t* fscript, const char* name, fscript_func_call_t* iter,\n                               value_t* result) {\n  if (s_hooks != NULL && s_hooks->exec_func != NULL) {\n    return s_hooks->exec_func(fscript, name, iter, result);\n  } else {\n    return fscript_exec_func_default(fscript, iter, result);\n  }\n}\n\nret_t fscript_set_error(fscript_t* fscript, ret_t code, const char* func, const char* message) {\n  fscript->error_code = code;\n  fscript->error_func = fscript->curr;\n  fscript->error_row = fscript->curr->row;\n  fscript->error_col = fscript->curr->col;\n  fscript->error_message = tk_str_copy(fscript->error_message, message);\n  if (code != RET_OK) {\n    log_debug(\"(%d:%d): %s code=%d %s\\n\", fscript->curr->row, fscript->curr->col, func, code,\n              message);\n  }\n\n  if (fscript->on_error != NULL) {\n    fscript->on_error(fscript->on_error_ctx, fscript);\n  }\n\n  return RET_OK;\n}\n\nret_t fscript_set_on_error(fscript_t* fscript, fscript_on_error_t on_error, void* ctx) {\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n  fscript->on_error = on_error;\n  fscript->on_error_ctx = ctx;\n\n  return RET_OK;\n}\n\nret_t fscript_set_print_func(fscript_t* fscript, fscript_func_t print) {\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n\n  fscript->print = print;\n\n  return RET_OK;\n}\n\nstatic bool_t value_is_digit(value_t* v) {\n  uint32_t type = 0;\n  bool_t ret = TRUE;\n  return_value_if_fail(v != NULL, FALSE);\n\n  type = v->type;\n  if (type == VALUE_TYPE_INVALID || type == VALUE_TYPE_POINTER || type == VALUE_TYPE_STRING ||\n      type == VALUE_TYPE_WSTRING || type == VALUE_TYPE_OBJECT || type == VALUE_TYPE_SIZED_STRING ||\n      type == VALUE_TYPE_BINARY || type == VALUE_TYPE_UBJSON) {\n    ret = FALSE;\n  }\n\n  return ret;\n}\n\nstatic ret_t func_args_extend(fscript_args_t* args) {\n  if (args->size < args->capacity) {\n    return RET_OK;\n  }\n\n  if (args->capacity < FSCRIPT_MAX_ARGS) {\n    value_t* new_args = NULL;\n    uint16_t capacity = args->capacity + 2;\n    capacity = tk_min(capacity, FSCRIPT_MAX_ARGS);\n    new_args = TKMEM_REALLOC(args->args, capacity * sizeof(value_t));\n    return_value_if_fail(new_args != NULL, RET_OOM);\n    args->args = new_args;\n    args->capacity = capacity;\n    return RET_OK;\n  }\n\n  return RET_FAIL;\n}\n\nstatic ret_t func_args_push(fscript_args_t* args, value_t* v) {\n  return_value_if_fail(v != NULL && func_args_extend(args) == RET_OK, RET_BAD_PARAMS);\n  args->args[args->size++] = *v;\n  v->free_handle = FALSE;\n  value_reset(v);\n\n  return RET_OK;\n}\n\nstatic ret_t func_args_init(fscript_args_t* args, uint16_t init_args_capacity) {\n  memset(args, 0x00, sizeof(fscript_args_t));\n  if (init_args_capacity > 0) {\n    args->args = TKMEM_ZALLOCN(value_t, init_args_capacity);\n    return_value_if_fail(args->args != NULL, RET_OOM);\n    args->capacity = init_args_capacity;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_func_call_destroy(fscript_func_call_t* call);\n\nstatic ret_t func_args_reset(fscript_args_t* args) {\n  uint32_t i = 0;\n  for (i = 0; i < args->size; i++) {\n    value_t* v = args->args + i;\n    if (v->type == VALUE_TYPE_FSCRIPT_FUNC) {\n      fscript_func_call_destroy(value_func(v));\n    }\n    value_reset(args->args + i);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_args_deinit(fscript_args_t* args) {\n  func_args_reset(args);\n  TKMEM_FREE(args->args);\n  memset(args, 0x00, sizeof(fscript_args_t));\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_func_call_destroy(fscript_func_call_t* call) {\n  fscript_func_call_t* iter = call;\n  fscript_func_call_t* next = NULL;\n\n  while (iter != NULL) {\n    if (iter->func == func_pending) {\n      TKMEM_FREE(iter->ctx);\n    }\n    next = iter->next;\n    func_args_deinit(&(iter->args));\n    TKMEM_FREE(iter);\n    iter = next;\n  }\n\n  return RET_OK;\n}\n\nstatic fscript_function_def_t* fscript_function_def_create(const char* name,\n                                                           fscript_func_call_t* body) {\n  fscript_function_def_t* func = TKMEM_ZALLOC(fscript_function_def_t);\n  return_value_if_fail(func != NULL, NULL);\n  func->body = body;\n  func->name = tk_strdup(name);\n\n  darray_init(&(func->params), 3, default_destroy, NULL);\n  return func;\n}\n\nstatic ret_t fscript_function_def_destroy(fscript_function_def_t* func) {\n  return_value_if_fail(func != NULL, RET_BAD_PARAMS);\n  darray_deinit(&(func->params));\n  fscript_func_call_destroy(func->body);\n  TKMEM_FREE(func->name);\n  memset(func, 0x00, sizeof(fscript_function_def_t));\n  TKMEM_FREE(func);\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_function_def_add_param(fscript_function_def_t* func, const char* name) {\n  return_value_if_fail(func != NULL, RET_BAD_PARAMS);\n  return darray_push(&(func->params), tk_strdup(name));\n}\n\ntypedef enum _token_type_t {\n  TOKEN_ID = 1,\n  TOKEN_VAR,\n  TOKEN_FUNC,\n  TOKEN_RETURN,\n  TOKEN_FUNC_DEF,\n  TOKEN_STR,\n  TOKEN_NUMBER,\n  TOKEN_LPAREN,\n  TOKEN_RPAREN,\n  TOKEN_LBRACKET,\n  TOKEN_RBRACKET,\n  TOKEN_COMMA,\n  TOKEN_SEMICOLON,\n  /*for expr*/\n  TOKEN_QUESTION,\n  TOKEN_COLON,\n  TOKEN_EOF\n} token_type_t;\n\ntypedef struct _token_t {\n  const char* token;\n  token_type_t type;\n  uint32_t size;\n  bool_t valid;\n} token_t;\n\ntypedef struct _fscript_parser_t {\n  tk_object_t* obj;\n  token_t token;\n  char* code_id;\n  const char* str;\n  const char* cursor;\n\n  char c;\n  str_t temp;\n  uint16_t row;\n  uint16_t col;\n  tk_object_t* funcs_def;\n  fscript_func_call_t* first;\n  fscript_parser_error_t* error;\n  bool_t keep_func_name;\n  darray_t* symbols;\n} fscript_parser_t;\n\nstatic ret_t fexpr_parse(fscript_parser_t* parser, value_t* result);\nstatic ret_t fscript_parse_statements(fscript_parser_t* parser, fscript_func_call_t* acall);\nstatic fscript_func_call_t* fscript_func_call_create(fscript_parser_t* parser, const char* name,\n                                                     uint32_t size);\nstatic ret_t fscript_get_var(fscript_t* fscript, const char* name, value_t* value) {\n  value_set_str(value, NULL);\n  return_value_if_fail(name != NULL, RET_BAD_PARAMS);\n  if (*name == '$') {\n    name += 1;\n  }\n\n  if (strncmp(name, FSCRIPT_STR_GLOBAL_PREFIX, FSCRIPT_GLOBAL_PREFIX_LEN) == 0) {\n    return tk_object_get_prop(fscript_get_global_object(), name + FSCRIPT_GLOBAL_PREFIX_LEN, value);\n  }\n\n  return tk_object_get_prop(fscript->obj, name, value);\n}\n\nret_t fscript_set_var_default(fscript_t* fscript, const char* name, const value_t* value) {\n  if (strncmp(name, FSCRIPT_STR_GLOBAL_PREFIX, FSCRIPT_GLOBAL_PREFIX_LEN) == 0) {\n    return tk_object_set_prop(fscript_get_global_object(), name + FSCRIPT_GLOBAL_PREFIX_LEN, value);\n  }\n\n  return tk_object_set_prop(fscript->obj, name, value);\n}\n\nret_t fscript_set_var(fscript_t* fscript, const char* name, const value_t* value) {\n  if (s_hooks != NULL && s_hooks->set_var != NULL) {\n    return s_hooks->set_var(fscript, name, value);\n  } else {\n    return fscript_set_var_default(fscript, name, value);\n  }\n}\n\nstatic ret_t fscript_eval_arg(fscript_t* fscript, fscript_func_call_t* iter, uint32_t i,\n                              value_t* d) {\n  value_t v;\n  value_t* s = iter->args.args + i;\n  value_set_str(&v, NULL);\n  value_set_str(d, NULL);\n  if (s->type == VALUE_TYPE_FSCRIPT_ID) {\n    if ((iter->func == func_set_local || iter->func == func_set || iter->func == func_unset ||\n         iter->func == func_get) &&\n        i == 0) {\n      value_copy(d, s); /*func_set accept id/str as first param*/\n    } else {\n      const char* name = value_id(s);\n      if (value_id_index(s) >= 0) {\n        return fscript_locals_get(fscript, s, d);\n      }\n\n      if (fscript->loop_count > 0) {\n        if (tk_str_eq(name, \"break\")) {\n          fscript->breaked = TRUE;\n          return RET_OK;\n        } else if (tk_str_eq(name, \"continue\")) {\n          fscript->continued = TRUE;\n          return RET_OK;\n        }\n      } else if (tk_str_eq(name, \"return\")) {\n        fscript->returned = TRUE;\n        value_set_int(d, 0);\n        return RET_OK;\n      } else if (*name == '.') {\n        value_copy(d, s);\n        return RET_OK;\n      }\n\n      if (fscript_get_var(fscript, name, d) != RET_OK) {\n        if (name == NULL || *name != '$') {\n          char msg[128];\n          tk_snprintf(msg, sizeof(msg) - 1, \"not found var %s\", name);\n          fscript_set_error(fscript, RET_NOT_FOUND, \"get_var\", msg);\n          value_set_str(d, value_id(s));\n        } else if (*name == '$') {\n          value_reset(d);\n        }\n      }\n    }\n  } else if (s->type == VALUE_TYPE_FSCRIPT_FUNC) {\n    fscript_exec_func(fscript, NULL, value_func(s), d);\n  } else {\n    value_copy(d, s);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_if(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  uint32_t i = 0;\n  uint32_t n = 0;\n  value_t condition;\n  return_value_if_fail(iter->args.size >= 2, RET_FAIL);\n\n  n = iter->args.size / 2;\n  for (i = 0; i < n; i++) {\n    value_set_bool(&condition, FALSE);\n    return_value_if_fail(fscript_eval_arg(fscript, iter, 2 * i, &condition) == RET_OK, RET_FAIL);\n    if (value_bool(&condition)) {\n      return fscript_eval_arg(fscript, iter, 2 * i + 1, result);\n    }\n  }\n\n  if ((2 * i) < iter->args.size) {\n    return fscript_eval_arg(fscript, iter, 2 * i, result);\n  } else {\n    value_set_int(result, 0);\n    return RET_OK;\n  }\n}\n\nstatic ret_t fscript_exec_loop_body(fscript_t* fscript, fscript_func_call_t* iter, uint32_t start,\n                                    value_t* result, bool_t* done) {\n  uint32_t i = 1;\n  for (i = start; i < iter->args.size; i++) {\n    value_reset(result);\n    fscript_eval_arg(fscript, iter, i, result);\n    if (fscript->breaked) {\n      *done = TRUE;\n      fscript->breaked = FALSE;\n      break;\n    } else if (fscript->returned) {\n      *done = TRUE;\n    } else if (fscript->continued) {\n      fscript->continued = FALSE;\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_while_or_until(fscript_t* fscript, fscript_func_call_t* iter,\n                                         value_t* result, bool_t is_while) {\n  value_t condition;\n  bool_t done = FALSE;\n  FSCRIPT_FUNC_CHECK(iter->args.size > 1, RET_FAIL);\n\n  fscript->loop_count++;\n  value_set_int(&condition, 0);\n  while (!done && fscript_eval_arg(fscript, iter, 0, &condition) == RET_OK) {\n    if (is_while ? !value_bool(&condition) : value_bool(&condition)) {\n      break;\n    }\n    fscript_exec_loop_body(fscript, iter, 1, result, &done);\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\n\n/*repeat(a, 0, 100, 1) {*/\nstatic ret_t fscript_exec_repeat(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  value_t v;\n  int32_t start = 0;\n  int32_t end = 0;\n  int32_t delta = 0;\n  bool_t done = FALSE;\n  value_t* var = iter->args.args;\n  int32_t index = value_id_index(var);\n  const char* name = value_id(iter->args.args);\n  FSCRIPT_FUNC_CHECK(iter->args.size > 4, RET_FAIL);\n\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 1, &v) == RET_OK, RET_BAD_PARAMS);\n  start = value_int(&v);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 2, &v) == RET_OK, RET_BAD_PARAMS);\n  end = value_int(&v);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 3, &v) == RET_OK, RET_BAD_PARAMS);\n  delta = value_int(&v);\n\n  fscript->loop_count++;\n  while ((start != end) && !done) {\n    value_set_int(&v, start);\n    if (index >= 0) {\n      break_if_fail(fscript_locals_set(fscript, var, &v) == RET_OK);\n    } else {\n      break_if_fail(fscript_set_var(fscript, name, &v) == RET_OK);\n    }\n    fscript_exec_loop_body(fscript, iter, 4, result, &done);\n    start += delta;\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_for(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  value_t v;\n  bool_t done = FALSE;\n  FSCRIPT_FUNC_CHECK(iter->args.size > 3, RET_FAIL);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 0, &v) == RET_OK, RET_BAD_PARAMS);\n\n  fscript->loop_count++;\n  while (!done) {\n    break_if_fail(fscript_eval_arg(fscript, iter, 1, &v) == RET_OK);\n    if (!value_bool(&v)) {\n      break;\n    }\n    fscript_exec_loop_body(fscript, iter, 3, result, &done);\n    break_if_fail(fscript_eval_arg(fscript, iter, 2, &v) == RET_OK);\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_for_in(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  value_t v;\n  char prop[32];\n  uint32_t i = 0;\n  uint32_t n = 0;\n  bool_t done = FALSE;\n  object_t* obj = NULL;\n  value_t* var = iter->args.args;\n  int32_t index = value_id_index(var);\n  const char* name = value_id(var);\n\n  FSCRIPT_FUNC_CHECK(iter->args.size > 2, RET_FAIL);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 1, &v) == RET_OK, RET_BAD_PARAMS);\n  obj = value_object(&v);\n  FSCRIPT_FUNC_CHECK(obj != NULL, RET_FAIL);\n\n  fscript->loop_count++;\n  n = tk_object_get_prop_int(obj, TK_OBJECT_PROP_SIZE, 0);\n  for (i = 0; ((i < n) && !done); i++) {\n    tk_snprintf(prop, sizeof(prop) - 1, \"[%u]\", i);\n    break_if_fail(tk_object_get_prop(obj, prop, &v) == RET_OK);\n\n    if (index >= 0) {\n      fscript_locals_set(fscript, var, &v);\n    } else {\n      fscript_set_var(fscript, name, &v);\n    }\n    fscript_exec_loop_body(fscript, iter, 2, result, &done);\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_exec_repeat_times(fscript_t* fscript, fscript_func_call_t* iter,\n                                       value_t* result) {\n  value_t v;\n  uint32_t i = 0;\n  uint32_t n = 0;\n  bool_t done = FALSE;\n  FSCRIPT_FUNC_CHECK(iter->args.size > 1, RET_FAIL);\n  FSCRIPT_FUNC_CHECK(fscript_eval_arg(fscript, iter, 0, &v) == RET_OK, RET_BAD_PARAMS);\n\n  n = value_int(&v);\n  fscript->loop_count++;\n  for (i = 0; i < n && !done; i++) {\n    fscript_exec_loop_body(fscript, iter, 1, result, &done);\n  }\n  fscript->loop_count--;\n\n  return RET_OK;\n}\nstatic ret_t fscript_exec_while(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  return fscript_exec_while_or_until(fscript, iter, result, TRUE);\n}\n\nstatic ret_t fscript_exec_until(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  return fscript_exec_while_or_until(fscript, iter, result, FALSE);\n}\n\nstatic ret_t fscript_exec_core_func(fscript_t* fscript, fscript_func_call_t* iter,\n                                    value_t* result) {\n  if (iter->func == func_if) {\n    return fscript_exec_if(fscript, iter, result);\n  } else if (iter->func == func_while) {\n    return fscript_exec_while(fscript, iter, result);\n  } else if (iter->func == func_until) {\n    return fscript_exec_until(fscript, iter, result);\n  } else if (iter->func == func_repeat) {\n    return fscript_exec_repeat(fscript, iter, result);\n  } else if (iter->func == func_for) {\n    return fscript_exec_for(fscript, iter, result);\n  } else if (iter->func == func_for_in) {\n    return fscript_exec_for_in(fscript, iter, result);\n  } else if (iter->func == func_repeat_times) {\n    return fscript_exec_repeat_times(fscript, iter, result);\n  } else if (iter->func == func_function_def) {\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t fscript_exec_ext_func(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  value_t v;\n  uint32_t i = 0;\n  ret_t ret = RET_OK;\n  fscript_args_t args;\n  value_t args_values[5];\n\n  value_set_int(&v, 0);\n  if (iter->args.size <= ARRAY_SIZE(args_values)) {\n    memset(&args, 0x00, sizeof(args));\n    memset(&args_values, 0x00, sizeof(args_values));\n    args.capacity = ARRAY_SIZE(args_values);\n    args.args = args_values;\n  } else {\n    func_args_init(&args, iter->args.size);\n  }\n  args.size = iter->args.size;\n\n  return_value_if_fail((args.args != NULL || args.size == 0), RET_OOM);\n  for (i = 0; i < iter->args.size; i++) {\n    ret = fscript_eval_arg(fscript, iter, i, args.args + i);\n    if (fscript->breaked || fscript->continued || fscript->returned) {\n      value_deep_copy(result, args.args + i);\n      if (iter->args.size <= ARRAY_SIZE(args_values)) {\n        func_args_reset(&args);\n      } else {\n        func_args_deinit(&args);\n      }\n      return RET_OK;\n    }\n  }\n\n  value_set_int(result, 0);\n  fscript->curr = iter;\n  ret = iter->func(fscript, &args, result);\n\n  if (iter->args.size <= ARRAY_SIZE(args_values)) {\n    func_args_reset(&args);\n  } else {\n    func_args_deinit(&args);\n  }\n\n  return ret;\n}\n\nret_t fscript_exec_func_default(fscript_t* fscript, fscript_func_call_t* iter, value_t* result) {\n  fscript->curr = iter;\n  result->type = VALUE_TYPE_INVALID;\n\n  if (iter->func == func_pending && iter->ctx != NULL) {\n    tk_object_t* obj = NULL;\n    void* ctx = iter->ctx;\n    char* name = (char*)(iter->ctx);\n    char* p = strchr(name, '.');\n    iter->ctx = NULL;\n\n    if (p != NULL) {\n      *p = '\\0';\n      obj = fscript_locals_get_object(fscript, name);\n      name = p + 1;\n    }\n    obj = obj != NULL ? obj : fscript->obj;\n    fscript_func_call_init_func(iter, obj, fscript->funcs_def, name, tk_strlen(name));\n\n    if (iter->func == func_noop) {\n      log_warn(\"not found func %s\\n\", name);\n    }\n    TKMEM_FREE(ctx);\n  }\n\n  if (fscript_exec_core_func(fscript, iter, result) == RET_NOT_FOUND) {\n    return_value_if_fail(fscript_exec_ext_func(fscript, iter, result) == RET_OK, RET_FAIL);\n  }\n\n  return RET_OK;\n}\n\nret_t fscript_exec(fscript_t* fscript, value_t* result) {\n  fscript_func_call_t* iter = NULL;\n  return_value_if_fail(fscript != NULL, RET_FAIL);\n\n  if (s_hooks != NULL && s_hooks->before_exec != NULL) {\n    s_hooks->before_exec(fscript);\n  }\n\n  value_set_str(result, NULL);\n  iter = fscript->first;\n  while (iter != NULL) {\n    break_if_fail(iter->func != NULL);\n    value_reset(result);\n    break_if_fail(fscript_exec_func(fscript, NULL, iter, result) == RET_OK);\n    if (fscript->returned) {\n      fscript->returned = FALSE;\n      break;\n    }\n    iter = iter->next;\n  }\n\n  if (s_hooks != NULL && s_hooks->after_exec != NULL) {\n    s_hooks->after_exec(fscript);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t on_free_func_def(void* ctx, const void* data) {\n  named_value_t* iter = (named_value_t*)(data);\n  fscript_function_def_destroy(value_func_def(&(iter->value)));\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_reset(fscript_t* fscript) {\n  return_value_if_fail(fscript != NULL, RET_FAIL);\n\n  if (s_hooks != NULL && s_hooks->on_deinit != NULL) {\n    s_hooks->on_deinit(fscript);\n  }\n\n  str_reset(&(fscript->str));\n  fscript_locals_destroy(fscript);\n  if (fscript->funcs_def != NULL) {\n    tk_object_foreach_prop(fscript->funcs_def, on_free_func_def, NULL);\n  }\n  TK_OBJECT_UNREF(fscript->funcs_def);\n  TKMEM_FREE(fscript->error_message);\n  fscript_func_call_destroy(fscript->first);\n  TKMEM_FREE(fscript->code_id);\n  memset(fscript, 0x00, sizeof(fscript_t));\n\n  return RET_OK;\n}\n\nret_t fscript_deinit(fscript_t* fscript) {\n  return fscript_reset(fscript);\n}\n\nret_t fscript_destroy(fscript_t* fscript) {\n  return_value_if_fail(fscript != NULL, RET_FAIL);\n  fscript_deinit(fscript);\n\n  TKMEM_FREE(fscript);\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_init(fscript_parser_t* parser, tk_object_t* obj, const char* str,\n                                 fscript_parser_error_t* error) {\n  memset(parser, 0x00, sizeof(fscript_parser_t));\n\n  parser->obj = obj;\n  parser->str = str;\n  parser->cursor = str;\n  parser->error = error;\n  parser->symbols = darray_create(5, NULL, (tk_compare_t)tk_str_cmp);\n\n  str_init(&(parser->temp), 64);\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_deinit(fscript_parser_t* parser) {\n  str_reset(&(parser->temp));\n  TKMEM_FREE(parser->code_id);\n  darray_destroy(parser->symbols);\n  fscript_func_call_destroy(parser->first);\n  if (parser->funcs_def != NULL) {\n    tk_object_foreach_prop(parser->funcs_def, on_free_func_def, NULL);\n  }\n  TK_OBJECT_UNREF(parser->funcs_def);\n\n  return RET_OK;\n}\n\nstatic char fscript_parser_get_char(fscript_parser_t* parser) {\n  char c = '\\0';\n  return_value_if_fail(parser != NULL, c);\n  if (parser->c) {\n    c = parser->c;\n    parser->c = '\\0';\n    return c;\n  }\n\n  c = parser->cursor[0];\n  if (c) {\n    if (c == '\\n') {\n      parser->row++;\n      parser->col = 0;\n    } else {\n      parser->col++;\n    }\n\n    parser->cursor++;\n  }\n\n  return c;\n}\n\nstatic ret_t fscript_parser_unget_char(fscript_parser_t* parser, char c) {\n  return_value_if_fail(parser->cursor > parser->str, RET_BAD_PARAMS);\n  parser->c = c;\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_set_error(fscript_parser_t* parser, const char* str) {\n  return_value_if_fail(parser != NULL && str != NULL, RET_BAD_PARAMS);\n\n  if (parser->error != NULL) {\n    parser->error->row = parser->row;\n    parser->error->col = parser->col;\n    parser->error->offset = parser->cursor - parser->str;\n    parser->error->message = tk_str_copy(parser->error->message, str);\n    parser->error->token = tk_str_copy(parser->error->token, parser->token.token);\n  }\n\n  log_warn(\"code: \\\"%s\\\"\\n\", parser->str);\n  log_warn(\"token: \\\"%s\\\"\\n\", parser->token.token);\n  log_warn(\"at line(%u) col (%u): %s\\n\", parser->row, parser->col, str);\n\n  return RET_FAIL;\n}\n\nstatic ret_t fscript_parser_skip_seperators(fscript_parser_t* parser) {\n  char c = '\\0';\n  do {\n    c = fscript_parser_get_char(parser);\n  } while (tk_isspace(c));\n  fscript_parser_unget_char(parser, c);\n\n  return RET_OK;\n}\n\n#define STR_CODE_ID_START \"code_id(\\\"\"\n#define STR_CODE_ID_END \"\\\")\"\n\nstatic ret_t fscript_parser_skip_line_comment(fscript_parser_t* parser) {\n  char c = '\\0';\n  str_t* str = &(parser->temp);\n  str_clear(str);\n  do {\n    c = fscript_parser_get_char(parser);\n    str_append_char(str, c);\n  } while (c != '\\0' && c != '\\r' && c != '\\n');\n\n  if (str->size > sizeof(STR_CODE_ID_START)) {\n    const char* end = NULL;\n    const char* start = strstr(str->str, STR_CODE_ID_START);\n    if (start != NULL) {\n      start += strlen(STR_CODE_ID_START);\n      end = strstr(start, STR_CODE_ID_END);\n      if (end != NULL) {\n        TKMEM_FREE(parser->code_id);\n        parser->code_id = tk_strndup(start, end - start);\n        log_debug(\"code_id:%s\\n\", parser->code_id);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_skip_block_comment(fscript_parser_t* parser) {\n  char c = '\\0';\n  do {\n    c = fscript_parser_get_char(parser);\n    if (c == '*' && parser->cursor[0] == '/') {\n      c = fscript_parser_get_char(parser);\n      break;\n    }\n  } while (c != '\\0');\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_skip_seperators_and_comments(fscript_parser_t* parser) {\n  char c = '\\0';\n\n  while (TRUE) {\n    fscript_parser_skip_seperators(parser);\n    c = fscript_parser_get_char(parser);\n    if (c == '/') {\n      if (parser->cursor[0] == '/') {\n        c = fscript_parser_get_char(parser);\n        fscript_parser_skip_line_comment(parser);\n      } else if (parser->cursor[0] == '*') {\n        c = fscript_parser_get_char(parser);\n        fscript_parser_skip_block_comment(parser);\n      } else {\n        break;\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (c) {\n    parser->cursor--;\n    if (parser->col > 0) {\n      parser->col--;\n    }\n  }\n\n  return RET_OK;\n}\n\n#define TOKEN_INIT(t, ttype, str) \\\n  t->type = ttype;                \\\n  t->token = str->str;            \\\n  t->size = str->size;\n\nstatic ret_t fscript_parser_parse_str(fscript_parser_t* parser, char quota) {\n  char c = '\\0';\n  bool_t escape = FALSE;\n  str_t* str = &(parser->temp);\n  token_t* t = &(parser->token);\n\n  str_set(str, \"\");\n  do {\n    c = fscript_parser_get_char(parser);\n    if (escape) {\n      if (c == 'r') {\n        str_append_char(str, '\\r');\n      } else if (c == 'n') {\n        str_append_char(str, '\\n');\n      } else if (c == 't') {\n        str_append_char(str, '\\t');\n      } else {\n        str_append_char(str, c);\n      }\n      escape = FALSE;\n      continue;\n    }\n\n    if (c == quota || c == '\\0') {\n      break;\n    } else if (c == '\\\\') {\n      escape = TRUE;\n      continue;\n    }\n    str_append_char(str, c);\n  } while (TRUE);\n\n  TOKEN_INIT(t, TOKEN_STR, str);\n  if (c != '\\0' && c != quota) {\n    fscript_parser_unget_char(parser, c);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_get_non_ascii_char(fscript_parser_t* parser, str_t* str, uint8_t c,\n                                               uint32_t n) {\n  str_append_char(str, c);\n  while (n > 1) {\n    c = fscript_parser_get_char(parser);\n    str_append_char(str, c);\n    n--;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_parse_id_or_number(fscript_parser_t* parser, token_type_t def_type) {\n  char c = '\\0';\n  str_t* str = &(parser->temp);\n  token_t* t = &(parser->token);\n  c = fscript_parser_get_char(parser);\n\n  str_set(str, \"\");\n  if (c) {\n    int32_t n = tk_utf8_get_bytes_of_leading((uint8_t)c);\n    fscript_parser_get_non_ascii_char(parser, str, c, n);\n  }\n\n  do {\n    c = fscript_parser_get_char(parser);\n    if (tk_isxdigit(c) || tk_isdigit(c) || tk_isalpha(c) || c == '.' || c == '_' || c == '[' ||\n        c == ']' || c == '#') {\n      str_append_char(str, c);\n    } else {\n      int32_t n = tk_utf8_get_bytes_of_leading((uint8_t)c);\n      if (n > 1) {\n        fscript_parser_get_non_ascii_char(parser, str, c, n);\n      } else {\n        break;\n      }\n    }\n  } while (TRUE);\n\n  if (tk_isspace(c)) {\n    fscript_parser_skip_seperators_and_comments(parser);\n    c = fscript_parser_get_char(parser);\n  }\n\n  str_trim(str, \" \\t\\r\\n\");\n  TOKEN_INIT(t, (c == '(' ? TOKEN_FUNC : def_type), str);\n  if (c != '\\0') {\n    fscript_parser_unget_char(parser, c);\n  }\n\n  if (t->type == TOKEN_ID) {\n    if (tk_str_eq(t->token, \"function\")) {\n      t->type = TOKEN_FUNC_DEF;\n    } else if (tk_str_eq(t->token, \"var\")) {\n      t->type = TOKEN_VAR;\n    } else if (tk_str_eq(t->token, \"return\")) {\n      t->type = TOKEN_RETURN;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_get_unary(fscript_parser_t* parser, char c, str_t* str) {\n  do {\n    fscript_parser_skip_seperators_and_comments(parser);\n    c = fscript_parser_get_char(parser);\n    if (c == str->str[0]) {\n      str_append_char(str, c);\n    } else {\n      fscript_parser_unget_char(parser, c);\n      break;\n    }\n  } while (TRUE);\n\n  return RET_OK;\n}\n\nstatic token_t* fscript_parser_get_token_ex(fscript_parser_t* parser, bool_t operator) {\n  char c = 0;\n  str_t* str = &(parser->temp);\n  token_t* t = &(parser->token);\n\n  if (t->valid) {\n    t->valid = FALSE;\n    return t;\n  }\n\n  fscript_parser_skip_seperators_and_comments(parser);\n  c = fscript_parser_get_char(parser);\n\n  str_set_with_len(str, &c, 1);\n  t->token = str->str;\n  t->size = 1;\n  switch (c) {\n    case '\\0': {\n      t->type = TOKEN_EOF;\n      return NULL;\n    }\n    case '(': {\n      t->type = TOKEN_LPAREN;\n      return t;\n    }\n    case ')': {\n      t->type = TOKEN_RPAREN;\n      return t;\n    }\n    case '{': {\n      t->type = TOKEN_LBRACKET;\n      return t;\n    }\n    case '}': {\n      t->type = TOKEN_RBRACKET;\n      return t;\n    }\n    case ',': {\n      t->type = TOKEN_COMMA;\n      return t;\n    }\n    case ';': {\n      t->type = TOKEN_SEMICOLON;\n      return t;\n    }\n    case '?': {\n      t->type = TOKEN_QUESTION;\n      return t;\n    }\n    case ':': {\n      t->type = TOKEN_COLON;\n      return t;\n    }\n    case '*':\n    case '/':\n    case '%':\n    case '^':\n    case '#': {\n      t->type = TOKEN_FUNC;\n      return t;\n    }\n    case '>':\n    case '<':\n    case '=': {\n      c = fscript_parser_get_char(parser);\n      if (str->str[0] == c || c == '=') {\n        str_append_char(str, c);\n      } else {\n        fscript_parser_unget_char(parser, c);\n      }\n      t->type = TOKEN_FUNC;\n      t->size = str->size;\n      return t;\n    }\n    case '~':\n    case '!': {\n      c = fscript_parser_get_char(parser);\n      if (c == '=') {\n        str_append_char(str, c);\n      } else {\n        fscript_parser_unget_char(parser, c);\n        fscript_parser_get_unary(parser, c, str);\n      }\n      TOKEN_INIT(t, TOKEN_FUNC, str);\n      return t;\n    }\n    case '|':\n    case '&': {\n      c = fscript_parser_get_char(parser);\n      if (c == str->str[0]) {\n        str_append_char(str, c);\n      } else {\n        fscript_parser_unget_char(parser, c);\n      }\n\n      t->type = TOKEN_FUNC;\n      t->size = str->size;\n      return t;\n    }\n    case '\\\"':\n    case '\\'': {\n      fscript_parser_parse_str(parser, c);\n      return t;\n    }\n    default: {\n      if (c == '+' || c == '-') {\n        fscript_parser_skip_seperators_and_comments(parser);\n        if (operator|| !tk_isdigit(parser->cursor[0])) {\n          fscript_parser_get_unary(parser, c, str);\n          TOKEN_INIT(t, TOKEN_FUNC, str);\n        } else {\n          fscript_parser_unget_char(parser, c);\n          fscript_parser_parse_id_or_number(parser, TOKEN_NUMBER);\n        }\n      } else if (tk_isdigit(c)) {\n        fscript_parser_unget_char(parser, c);\n        fscript_parser_parse_id_or_number(parser, TOKEN_NUMBER);\n      } else {\n        fscript_parser_unget_char(parser, c);\n        fscript_parser_parse_id_or_number(parser, TOKEN_ID);\n      }\n      return t;\n    }\n  }\n}\n\nstatic token_t* fscript_parser_get_token(fscript_parser_t* parser) {\n  return fscript_parser_get_token_ex(parser, FALSE);\n}\n\nstatic ret_t fscript_parser_expect_token(fscript_parser_t* parser, token_type_t type,\n                                         const char* msg) {\n  token_t* t = fscript_parser_get_token(parser);\n  if (t == NULL || t->type != type) {\n    return fscript_parser_set_error(parser, msg);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parser_unget_token(fscript_parser_t* parser) {\n  if (parser->token.type != TOKEN_EOF) {\n    parser->token.valid = TRUE;\n  }\n  return RET_OK;\n}\n\nstatic ret_t token_to_value(fscript_parser_t* parser, token_t* t, value_t* v) {\n  if (t->type == TOKEN_NUMBER) {\n    char number[64];\n    tk_strncpy_s(number, sizeof(number) - 1, t->token, t->size);\n    if (strchr(number, '.') != NULL) {\n      value_set_double(v, tk_atof(number));\n    } else {\n      uint64_t vv = 0;\n      const char* str = number;\n      bool_t has_minus = FALSE;\n      if (*str == '-') {\n        has_minus = TRUE;\n        str++;\n      }\n\n      vv = tk_atoul(str);\n      if (vv < INT_MAX) {\n        if (has_minus) {\n          value_set_int32(v, -vv);\n        } else {\n          value_set_int32(v, vv);\n        }\n      } else if (vv < UINT32_MAX) {\n        if (has_minus) {\n          value_set_int64(v, -vv);\n        } else {\n          value_set_uint32(v, vv);\n        }\n      } else {\n        if (has_minus) {\n          value_set_int64(v, -vv);\n        } else {\n          value_set_uint64(v, vv);\n        }\n      }\n    }\n  } else if (t->type == TOKEN_STR) {\n    value_dup_str_with_len(v, t->token, t->size);\n  } else if (t->type == TOKEN_ID) {\n    if (t->token[0] == 't' && strncmp(t->token, \"true\", 4) == 0) {\n      value_set_bool(v, TRUE);\n    } else if (t->token[0] == 'f' && strncmp(t->token, \"false\", 5) == 0) {\n      value_set_bool(v, FALSE);\n    } else {\n      const char* name = NULL;\n      const char* p = NULL;\n      value_set_id(v, t->token, t->size);\n      name = value_id(v);\n      p = strchr(name, '.');\n      if (p != NULL) {\n        char first_name[TK_NAME_LEN + 1];\n        tk_strncpy_s(first_name, TK_NAME_LEN, name, p - name);\n        value_id_suboffset(v) = p - name + 1;\n        value_id_index(v) = darray_find_index(parser->symbols, (void*)first_name);\n      } else {\n        value_id_suboffset(v) = 0;\n        value_id_index(v) = darray_find_index(parser->symbols, (void*)name);\n      }\n    }\n  } else {\n    return RET_FAIL;\n  }\n\n  return RET_OK;\n}\n\nret_t fscript_eval(tk_object_t* obj, const char* script, value_t* result) {\n  value_t v;\n  ret_t ret = RET_OK;\n  fscript_t* fscript = fscript_create(obj, script);\n  return_value_if_fail(fscript != NULL, RET_BAD_PARAMS);\n\n  if (fscript_exec(fscript, &v) == RET_OK && result != NULL) {\n    value_deep_copy(result, &v);\n  }\n  value_reset(&v);\n  fscript_destroy(fscript);\n\n  return ret;\n}\n\n/*expr parser*/\nstatic ret_t fexpr_parse_block(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  value_t v;\n  fscript_func_call_t* statements = fscript_func_call_create(parser, \"expr\", 4);\n  return_value_if_fail(statements != NULL, RET_OOM);\n\n  if (fscript_parse_statements(parser, statements) == RET_OK) {\n    func_args_push(&(acall->args), value_set_func(&v, statements));\n  } else {\n    fscript_func_call_destroy(statements);\n  }\n\n  fscript_parser_expect_token(parser, TOKEN_RBRACKET, \"expect \\\"}\\\"\");\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_function(fscript_parser_t* parser, value_t* result);\n\nstatic ret_t fexpr_parse_if(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  uint32_t i = 0;\n  token_t* t = NULL;\n  fexpr_parse_block(parser, acall);\n  t = fscript_parser_get_token(parser);\n\n  if (t != NULL && t->type == TOKEN_ID && tk_str_eq(t->token, \"else\")) {\n    t = fscript_parser_get_token(parser);\n    if (t != NULL && t->type == TOKEN_FUNC && tk_str_eq(t->token, \"if\")) {\n      value_t result;\n      fscript_func_call_t* elseif = NULL;\n      fscript_parser_unget_token(parser);\n      return_value_if_fail(fexpr_parse_function(parser, &result) == RET_OK, RET_FAIL);\n      elseif = value_func(&result);\n      for (i = 0; i < elseif->args.size; i++) {\n        func_args_push(&(acall->args), elseif->args.args + i);\n      }\n      elseif->args.size = 0;\n      fscript_func_call_destroy(elseif);\n      return RET_OK;\n    } else {\n      fscript_parser_unget_token(parser);\n      fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\");\n      return fexpr_parse_block(parser, acall);\n    }\n  } else {\n    fscript_parser_unget_token(parser);\n    return RET_OK;\n  }\n}\n\nstatic ret_t fexpr_parse_function(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  fscript_args_t* args = NULL;\n  token_t* t = fscript_parser_get_token(parser);\n  fscript_func_call_t* acall = NULL;\n  if (t->token[0] == '-' && t->size == 1) {\n    acall = fscript_func_call_create(parser, \"minus\", 5);\n  } else {\n    acall = fscript_func_call_create(parser, t->token, t->size);\n  }\n  value_set_func(result, acall);\n  return_value_if_fail(acall != NULL, RET_BAD_PARAMS);\n\n  args = &(acall->args);\n  return_value_if_fail(fscript_parser_expect_token(parser, TOKEN_LPAREN, \"expect \\\"(\\\"\") == RET_OK,\n                       RET_FAIL);\n\n  do {\n    t = fscript_parser_get_token(parser);\n    if (t == NULL) {\n      return fscript_parser_set_error(parser, \"expect \\\")\\\"\");\n    }\n\n    if (t->type == TOKEN_RPAREN) {\n      break;\n    } else {\n      fscript_parser_unget_token(parser);\n    }\n    value_set_int(&v, 0);\n    return_value_if_fail(fexpr_parse(parser, &v) == RET_OK, RET_FAIL);\n    func_args_push(args, &v);\n    t = fscript_parser_get_token(parser);\n\n    if (t == NULL) {\n      return fscript_parser_set_error(parser, \"expect \\\")\\\"\");\n    } else if (t->type == TOKEN_RPAREN) {\n      break;\n    }\n    fscript_parser_unget_token(parser);\n    if (acall->func == func_for) {\n      fscript_parser_expect_token(parser, TOKEN_SEMICOLON, \"expect \\\";\\\"\");\n    } else {\n      fscript_parser_expect_token(parser, TOKEN_COMMA, \"expect \\\",\\\"\");\n    }\n  } while (TRUE);\n\n  if (acall->func == func_if && acall->args.size == 1) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_if(parser, acall);\n    }\n  } else if ((acall->func == func_while || acall->func == func_until ||\n              acall->func == func_repeat_times) &&\n             acall->args.size == 1) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_block(parser, acall);\n    }\n  } else if (acall->func == func_for && acall->args.size == 3) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_block(parser, acall);\n    }\n  } else if (acall->func == func_for_in && acall->args.size == 2) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_block(parser, acall);\n    }\n  } else if (acall->func == func_repeat && acall->args.size == 4) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_block(parser, acall);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_term(fscript_parser_t* parser, value_t* result) {\n  ret_t ret = RET_OK;\n  token_t* t = fscript_parser_get_token(parser);\n  value_set_int(result, 0);\n  return_value_if_fail(t != NULL, RET_BAD_PARAMS);\n\n  if (t->type == TOKEN_NUMBER || t->type == TOKEN_ID || t->type == TOKEN_STR) {\n    if (t->type == TOKEN_ID && t->token[0] == '.') {\n      fscript_parser_set_error(parser, \"var can't begin with '.'\");\n    }\n    ret = token_to_value(parser, t, result);\n  } else if (t->type == TOKEN_FUNC) {\n    fscript_parser_unget_token(parser);\n    ret = fexpr_parse_function(parser, result);\n  } else if (t->type == TOKEN_RETURN) {\n    fscript_func_call_t* acall = fscript_func_call_create(parser, \"return\", 6);\n    return_value_if_fail(acall != NULL, RET_OOM);\n    value_set_func(result, acall);\n    t = fscript_parser_get_token(parser);\n    if (t != NULL && t->type != TOKEN_SEMICOLON && t->type != TOKEN_RBRACKET) {\n      value_t v;\n      value_set_int(&v, 0);\n      fscript_parser_unget_token(parser);\n      if (fexpr_parse(parser, &v) == RET_OK) {\n        func_args_push(&(acall->args), &v);\n      }\n    } else {\n      fscript_parser_unget_token(parser);\n    }\n  } else if (t->type == TOKEN_LPAREN) {\n    ret = fexpr_parse(parser, result);\n    return_value_if_fail(ret == RET_OK, ret);\n    ret = fscript_parser_expect_token(parser, TOKEN_RPAREN, \"expect )\");\n  } else {\n    fscript_parser_unget_token(parser);\n  }\n\n  return ret;\n}\n\nstatic ret_t fexpr_parse_unary(fscript_parser_t* parser, value_t* result) {\n  char c = '\\0';\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n  token_t* t = fscript_parser_get_token_ex(parser, FALSE);\n  if (t == NULL || t->type == TOKEN_EOF) {\n    return RET_OK;\n  }\n\n  c = t->token[0];\n  if (t->type == TOKEN_FUNC && (c == '!' || c == '~' || c == '-')) {\n    value_t v;\n    uint32_t i = 0;\n    bool_t valid = FALSE;\n    for (i = 0; i < t->size; i++) {\n      if (t->token[i] != c) {\n        return fscript_parser_set_error(parser, \"unexpected token\");\n      } else {\n        valid = !valid;\n      }\n    }\n\n    if (valid) {\n      acall = fscript_func_call_create(parser, &c, 1);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      value_set_func(result, acall);\n      return_value_if_fail(fexpr_parse_term(parser, &v) == RET_OK, RET_FAIL);\n      func_args_push(args, &v);\n    } else {\n      return_value_if_fail(fexpr_parse_term(parser, result) == RET_OK, RET_FAIL);\n    }\n  } else {\n    fscript_parser_unget_token(parser);\n    return_value_if_fail(fexpr_parse_term(parser, result) == RET_OK, RET_FAIL);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fsexpr_parse_product(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n  return_value_if_fail(fexpr_parse_unary(parser, result) == RET_OK, RET_FAIL);\n\n  while (TRUE) {\n    t = fscript_parser_get_token_ex(parser, TRUE);\n    if (t == NULL || t->type != TOKEN_FUNC) {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n\n    if (t->token[0] == '*' || t->token[0] == '/' || t->token[0] == '%') {\n      acall = fscript_func_call_create(parser, t->token, t->size);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      func_args_push(args, result);\n      value_set_func(result, acall);\n      v.type = VALUE_TYPE_INVALID;\n      fexpr_parse_unary(parser, &v);\n      if (v.type == VALUE_TYPE_INVALID) {\n        fscript_parser_set_error(parser, \"expect an expression\");\n      } else {\n        func_args_push(args, &v);\n      }\n    } else {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_sum(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n  return_value_if_fail(fsexpr_parse_product(parser, result) == RET_OK, RET_FAIL);\n\n  while (TRUE) {\n    t = fscript_parser_get_token_ex(parser, TRUE);\n    if (t == NULL || t->type != TOKEN_FUNC) {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n\n    if (t->token[0] == '+' || t->token[0] == '-') {\n      parser->token.valid = FALSE;\n      acall = fscript_func_call_create(parser, t->token, t->size);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      func_args_push(args, result);\n      value_set_func(result, acall);\n      v.type = VALUE_TYPE_INVALID;\n      fsexpr_parse_product(parser, &v);\n      if (v.type == VALUE_TYPE_INVALID) {\n        fscript_parser_set_error(parser, \"expect an expression\");\n      } else {\n        func_args_push(args, &v);\n      }\n    } else {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_compare(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n\n  value_set_int(result, 0);\n  return_value_if_fail(fexpr_parse_sum(parser, result) == RET_OK, RET_FAIL);\n\n  t = fscript_parser_get_token_ex(parser, TRUE);\n  if (t == NULL || t->type != TOKEN_FUNC || tk_str_eq(t->token, \"=\")) {\n    fscript_parser_unget_token(parser);\n    return RET_OK;\n  }\n\n  if (t->token[0] == '>' || t->token[0] == '<' || t->token[0] == '=' ||\n      (t->token[0] == '!' && t->token[1] == '=')) {\n    acall = fscript_func_call_create(parser, t->token, t->size);\n    return_value_if_fail(acall != NULL, RET_OOM);\n    args = &(acall->args);\n    func_args_push(args, result);\n    value_set_func(result, acall);\n    v.type = VALUE_TYPE_INVALID;\n    fexpr_parse_sum(parser, &v);\n    if (v.type == VALUE_TYPE_INVALID) {\n      fscript_parser_set_error(parser, \"expect an expression\");\n    } else {\n      func_args_push(args, &v);\n    }\n  } else {\n    fscript_parser_unget_token(parser);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_logic(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n\n  value_set_int(result, 0);\n  return_value_if_fail(fexpr_parse_compare(parser, result) == RET_OK, RET_FAIL);\n\n  while (TRUE) {\n    t = fscript_parser_get_token_ex(parser, TRUE);\n    if (t == NULL || t->type != TOKEN_FUNC || tk_str_eq(t->token, \"=\")) {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n\n    if (t->token[0] == '|' || t->token[0] == '&' || t->token[0] == '^') {\n      acall = fscript_func_call_create(parser, t->token, t->size);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      func_args_push(args, result);\n      value_set_func(result, acall);\n      v.type = VALUE_TYPE_INVALID;\n      fexpr_parse_compare(parser, &v);\n      if (v.type == VALUE_TYPE_INVALID) {\n        fscript_parser_set_error(parser, \"expect an expression\");\n      } else {\n        func_args_push(args, &v);\n      }\n    } else {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t fexpr_parse_question(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  ret_t ret = RET_OK;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n\n  value_set_str(&v, NULL);\n  if (fexpr_parse_logic(parser, result) == RET_OK) {\n    t = fscript_parser_get_token(parser);\n    if (t && t->type == TOKEN_QUESTION) {\n      acall = fscript_func_call_create(parser, \"if\", 2);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      func_args_push(args, result);\n      value_set_func(result, acall);\n\n      value_reset(&v);\n      return_value_if_fail(fexpr_parse_logic(parser, &v) == RET_OK, RET_FAIL);\n      func_args_push(args, &v);\n\n      return_value_if_fail(fscript_parser_expect_token(parser, TOKEN_COLON, \"expect :\") == RET_OK,\n                           RET_FAIL);\n      return_value_if_fail(fexpr_parse_logic(parser, &v) == RET_OK, RET_FAIL);\n      func_args_push(args, &v);\n    } else {\n      fscript_parser_unget_token(parser);\n    }\n  } else {\n    ret = RET_FAIL;\n  }\n\n  return ret;\n}\n\nstatic ret_t fexpr_parse(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  bool_t is_local = FALSE;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n  value_set_int(result, 0);\n\n  t = fscript_parser_get_token_ex(parser, TRUE);\n  if (t == NULL || t->type == TOKEN_RBRACKET || t->type == TOKEN_SEMICOLON) {\n    value_reset(result);\n    fscript_parser_unget_token(parser);\n    return RET_OK;\n  }\n\n  if (t->type == TOKEN_VAR) {\n    is_local = TRUE;\n  } else {\n    fscript_parser_unget_token(parser);\n  }\n  return_value_if_fail(fexpr_parse_question(parser, result) == RET_OK, RET_FAIL);\n\n  t = fscript_parser_get_token_ex(parser, TRUE);\n  if (t != NULL && tk_str_eq(t->token, \"=\")) {\n    const char* name = is_local ? \"set_local\" : \"=\";\n    acall = fscript_func_call_create(parser, name, strlen(name));\n    return_value_if_fail(acall != NULL, RET_OOM);\n    args = &(acall->args);\n    func_args_push(args, result);\n    value_set_func(result, acall);\n    v.type = VALUE_TYPE_INVALID;\n    fexpr_parse_question(parser, &v);\n    if (v.type == VALUE_TYPE_INVALID) {\n      fscript_parser_set_error(parser, \"expect an expression\");\n    } else {\n      func_args_push(args, &v);\n    }\n\n    if (is_local) {\n      darray_push_unique(parser->symbols, (void*)value_id(args->args));\n    }\n  } else {\n    fscript_parser_unget_token(parser);\n  }\n\n  return RET_OK;\n}\n\nstatic fscript_t* fscript_init_with_parser(fscript_t* fscript, fscript_parser_t* parser) {\n  fscript = fscript != NULL ? fscript : TKMEM_ZALLOC(fscript_t);\n  return_value_if_fail(fscript != NULL, NULL);\n  fscript->str = parser->temp;\n  fscript->obj = parser->obj;\n  fscript->first = parser->first;\n  fscript->funcs_def = parser->funcs_def;\n  fscript->code_id = parser->code_id;\n  fscript->lines = parser->row + 1;\n\n  if (s_hooks != NULL && s_hooks->on_init != NULL) {\n    s_hooks->on_init(fscript, parser->str);\n  }\n\n  parser->obj = NULL;\n  parser->first = NULL;\n  parser->temp.str = NULL;\n  parser->funcs_def = NULL;\n  parser->code_id = NULL;\n\n  return fscript;\n}\n\nstatic ret_t func_function(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  ret_t ret = RET_OK;\n  darray_t* saved_locals = fscript->locals;\n  fscript_function_def_t* func_def = (fscript_function_def_t*)(fscript->curr->ctx);\n  fscript_func_call_t* func = func_def->body;\n\n  func->func = func_noop;\n  fscript->locals = NULL;\n  if (func_def->params.size > 0 && args->size > 0) {\n    uint32_t i = 0;\n    uint32_t n = tk_min(func_def->params.size, args->size);\n    for (i = 0; i < n; i++) {\n      const value_t* value = args->args + i;\n      const char* name = (const char*)(func_def->params.elms[i]);\n      fscript_locals_create(fscript, name, value);\n    }\n  }\n\n  ret = fscript_exec_func(fscript, func_def->name, func, result);\n\n  fscript_locals_destroy(fscript);\n  fscript->locals = saved_locals;\n  fscript->returned = FALSE;\n\n  return ret;\n}\n\nstatic ret_t fscript_parse_function_def(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  value_t v;\n  char func_name[TK_NAME_LEN + 1];\n  fscript_function_def_t* func_def = NULL;\n  fscript_func_call_t* statements = NULL;\n  token_t* t = fscript_parser_get_token(parser);\n  darray_t* saved_symbols = parser->symbols;\n\n  if (t->type != TOKEN_FUNC) {\n    return fscript_parser_set_error(parser, \"expect function name\\n\");\n  }\n  tk_strncpy(func_name, t->token, TK_NAME_LEN);\n  fscript_parser_expect_token(parser, TOKEN_LPAREN, \"expect \\\"(\\\"\");\n  if (parser->funcs_def == NULL) {\n    parser->funcs_def = object_default_create();\n  }\n\n  if (tk_object_get_prop(parser->funcs_def, func_name, &v) == RET_OK) {\n    return fscript_parser_set_error(parser, \"duplicate function\\n\");\n  }\n  statements = fscript_func_call_create(parser, \"func\", 4);\n  return_value_if_fail(statements != NULL, RET_OOM);\n\n  func_def = fscript_function_def_create(func_name, statements);\n  return_value_if_fail(func_def != NULL, RET_OOM);\n  value_set_func_def(&v, func_def);\n  tk_object_set_prop(parser->funcs_def, func_name, &v);\n\n  parser->symbols = darray_create(5, NULL, (tk_compare_t)tk_str_cmp);\n  while (TRUE) {\n    t = fscript_parser_get_token(parser);\n    if (t == NULL || t->type == TOKEN_EOF || t->type == TOKEN_RPAREN) {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n    if (t->type == TOKEN_ID) {\n      fscript_function_def_add_param(func_def, t->token);\n      darray_push_unique(parser->symbols,\n                         (void*)darray_get(&(func_def->params), func_def->params.size - 1));\n    } else if (t->type == TOKEN_COMMA) {\n    } else {\n      fscript_parser_unget_token(parser);\n      break;\n    }\n  }\n  fscript_parser_expect_token(parser, TOKEN_RPAREN, \"expect \\\")\\\"\");\n  fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\");\n  fscript_parse_statements(parser, statements);\n  fscript_parser_expect_token(parser, TOKEN_RBRACKET, \"expect \\\"}\\\"\");\n  darray_destroy(parser->symbols);\n  parser->symbols = saved_symbols;\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parse_statements(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  value_t v;\n  ret_t ret = RET_OK;\n  fscript_args_t* args = NULL;\n  return_value_if_fail(parser != NULL && acall != NULL, RET_BAD_PARAMS);\n\n  args = &(acall->args);\n\n  do {\n    token_t* t = NULL;\n    value_set_int(&v, 0);\n    ret = fexpr_parse(parser, &v);\n    if (ret == RET_OK) {\n      if (v.type != VALUE_TYPE_INVALID) {\n        func_args_push(args, &v);\n      }\n      t = fscript_parser_get_token(parser);\n      if (t == NULL) {\n        break;\n      }\n\n      if (t->type == TOKEN_FUNC || t->type == TOKEN_ID || t->type == TOKEN_NUMBER ||\n          t->type == TOKEN_STR || t->type == TOKEN_VAR || t->type == TOKEN_RETURN) {\n        fscript_parser_unget_token(parser);\n      } else if (t->type == TOKEN_RBRACKET || t->type == TOKEN_FUNC_DEF) {\n        fscript_parser_unget_token(parser);\n        break;\n      } else if (t->type != TOKEN_COMMA && t->type != TOKEN_SEMICOLON) {\n        return fscript_parser_set_error(parser, \"unexpected token\\n\");\n      }\n    } else {\n      if (v.type == VALUE_TYPE_FSCRIPT_FUNC) {\n        fscript_func_call_destroy(value_func(&v));\n      } else {\n        value_reset(&v);\n      }\n\n      break;\n    }\n  } while (parser->token.type != TOKEN_EOF);\n\n  return RET_OK;\n}\n\nstatic ret_t fscript_parse_all(fscript_parser_t* parser, fscript_func_call_t* acall) {\n  ret_t ret = RET_OK;\n  while (ret == RET_OK) {\n    token_t* t = fscript_parser_get_token(parser);\n    if (t && t->type == TOKEN_FUNC_DEF) {\n      ret = fscript_parse_function_def(parser, acall);\n    } else if (t == NULL || t->type == TOKEN_EOF) {\n      break;\n    } else if (t->type == TOKEN_RBRACKET) {\n      fscript_parser_set_error(parser, \"unexpected token\");\n      break;\n    } else {\n      fscript_parser_unget_token(parser);\n      ret = fscript_parse_statements(parser, acall);\n    }\n  }\n\n  return ret;\n}\n\nfscript_parser_error_t* fscript_parser_error_init(fscript_parser_error_t* error) {\n  return_value_if_fail(error != NULL, NULL);\n  memset(error, 0x00, sizeof(fscript_parser_error_t));\n\n  return error;\n}\n\nret_t fscript_parser_error_deinit(fscript_parser_error_t* error) {\n  return_value_if_fail(error != NULL, RET_BAD_PARAMS);\n  TKMEM_FREE(error->token);\n  TKMEM_FREE(error->message);\n\n  return RET_OK;\n}\n\nret_t fscript_syntax_check(tk_object_t* obj, const char* script, fscript_parser_error_t* error) {\n  ret_t ret = RET_OK;\n  fscript_parser_t parser;\n  return_value_if_fail(obj != NULL && script != NULL && error != NULL, RET_BAD_PARAMS);\n  fscript_parser_error_init(error);\n  fscript_parser_init(&parser, obj, script, error);\n\n  parser.first = fscript_func_call_create(&parser, \"expr\", 4);\n  ret = fscript_parse_all(&parser, parser.first);\n  fscript_parser_deinit(&parser);\n\n  return ret;\n}\n\nstatic fscript_t* fscript_load(fscript_t* fscript, tk_object_t* obj, const char* script,\n                               const char* first_call_name, bool_t keep_func_name) {\n  ret_t ret = RET_OK;\n  fscript_parser_t parser;\n  fscript_parser_error_t error;\n  return_value_if_fail(script != NULL, NULL);\n\n  fscript_parser_error_init(&error);\n  fscript_parser_init(&parser, obj, script, &error);\n  parser.keep_func_name = keep_func_name;\n  parser.first = fscript_func_call_create(&parser, first_call_name, strlen(first_call_name));\n  ret = fscript_parse_all(&parser, parser.first);\n  if (ret == RET_OK) {\n    fscript = fscript_init_with_parser(fscript, &parser);\n    fscript_parser_deinit(&parser);\n  } else {\n    log_warn(\"parser error:%s\\n\", script);\n    fscript_parser_deinit(&parser);\n  }\n  fscript_parser_error_deinit(&error);\n\n  return fscript;\n}\n\nret_t fscript_reload(fscript_t* fscript, const char* script) {\n  tk_object_t* obj = NULL;\n  return_value_if_fail(fscript != NULL && fscript->obj != NULL && script != NULL, RET_BAD_PARAMS);\n  obj = fscript->obj;\n  fscript_reset(fscript);\n\n  return fscript_load(fscript, obj, script, \"expr\", FALSE) != NULL ? RET_OK : RET_FAIL;\n}\n\nfscript_t* fscript_init(fscript_t* fscript, tk_object_t* obj, const char* script,\n                        const char* first_call_name, bool_t keep_func_name) {\n  return fscript_load(fscript, obj, script, first_call_name, keep_func_name);\n}\n\nfscript_t* fscript_create_ex(tk_object_t* obj, const char* script, bool_t keep_func_name) {\n  return fscript_load(NULL, obj, script, \"expr\", keep_func_name);\n}\n\nfscript_t* fscript_create(tk_object_t* obj, const char* script) {\n  return fscript_create_ex(obj, script, FALSE);\n}\n\n/*functions*/\nstatic ret_t func_get_last_error(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  if (fscript->error_code != RET_OK) {\n    tk_object_t* obj = object_default_create();\n    return_value_if_fail(obj != NULL, RET_OOM);\n    tk_object_set_prop_int(obj, \"col\", fscript->error_col);\n    tk_object_set_prop_int(obj, \"line\", fscript->error_row);\n    tk_object_set_prop_int(obj, \"code\", fscript->error_code);\n    tk_object_set_prop_str(obj, \"message\", fscript->error_message);\n    value_set_object(result, obj);\n    result->free_handle = TRUE;\n  } else {\n    value_set_int(result, 0);\n    value_reset(result);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_has_error(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  value_set_bool(result, fscript->error_code != RET_OK);\n  return RET_OK;\n}\n\nstatic ret_t func_clear_error(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  fscript_set_error(fscript, RET_OK, NULL, NULL);\n  return RET_OK;\n}\n\nstatic ret_t func_sum(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  double v = 0;\n  uint32_t i = 0;\n  bool_t has_str = FALSE;\n  bool_t has_float = FALSE;\n  FSCRIPT_FUNC_CHECK(args->size > 0, RET_BAD_PARAMS);\n\n  for (i = 0; i < args->size; i++) {\n    int type = args->args[i].type;\n    if (type == VALUE_TYPE_STRING) {\n      has_str = TRUE;\n    }\n    if (type == VALUE_TYPE_FLOAT || type == VALUE_TYPE_DOUBLE || type == VALUE_TYPE_FLOAT32) {\n      has_float = TRUE;\n    }\n  }\n\n  if (has_str) {\n    str_t str;\n    char buff[64];\n    str_init(&str, 100);\n    for (i = 0; i < args->size; i++) {\n      str_append(&str, value_str_ex(args->args + i, buff, sizeof(buff) - 1));\n    }\n    value_dup_str(result, str.str);\n    str_reset(&str);\n  } else {\n    for (i = 0; i < args->size; i++) {\n      v += value_double(args->args + i);\n    }\n    if (has_float) {\n      value_set_double(result, v);\n    } else {\n      value_set_int(result, (int)v);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_int(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int(result, value_int(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_i8(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int8(result, value_int8(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_i16(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int16(result, value_int16(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_i32(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int(result, value_int(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_i64(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_int64(result, value_int64(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_u8(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_uint8(result, value_uint8(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_u16(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_uint16(result, value_uint16(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_u32(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_uint32(result, value_uint32(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_u64(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_uint64(result, value_uint64(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_f32(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_float32(result, value_float32(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_double(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_double(result, value_double(args->args));\n  return RET_OK;\n}\n\nstatic ret_t func_binary(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  void* p = NULL;\n  uint32_t size = 0;\n  /*基本类型默认拷贝*/\n  bool_t clone = TRUE;\n  value_t* v = args->args;\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n\n  switch (v->type) {\n    case VALUE_TYPE_BOOL: {\n      size = sizeof(int8_t);\n      p = &(v->value.b);\n      break;\n    }\n    case VALUE_TYPE_INT8: {\n      size = sizeof(int8_t);\n      p = &(v->value.i8);\n      break;\n    }\n    case VALUE_TYPE_UINT8: {\n      size = sizeof(uint8_t);\n      p = &(v->value.u8);\n      break;\n    }\n    case VALUE_TYPE_INT16: {\n      size = sizeof(int16_t);\n      p = &(v->value.i16);\n      break;\n    }\n    case VALUE_TYPE_UINT16: {\n      size = sizeof(uint16_t);\n      p = &(v->value.u16);\n      break;\n    }\n    case VALUE_TYPE_INT32: {\n      size = sizeof(int32_t);\n      p = &(v->value.i32);\n      break;\n    }\n    case VALUE_TYPE_UINT32: {\n      size = sizeof(uint32_t);\n      p = &(v->value.u32);\n      break;\n    }\n    case VALUE_TYPE_INT64: {\n      size = sizeof(int64_t);\n      p = &(v->value.i64);\n      break;\n    }\n    case VALUE_TYPE_UINT64: {\n      size = sizeof(uint64_t);\n      p = &(v->value.u64);\n      break;\n    }\n    case VALUE_TYPE_FLOAT: {\n      size = sizeof(float_t);\n      p = &(v->value.f32);\n      break;\n    }\n    case VALUE_TYPE_FLOAT32: {\n      size = sizeof(float);\n      p = &(v->value.f32);\n      break;\n    }\n    case VALUE_TYPE_DOUBLE: {\n      size = sizeof(double);\n      p = &(v->value.f64);\n      break;\n    }\n    case VALUE_TYPE_STRING: {\n      p = (void*)value_str(v);\n      size = tk_strlen(value_str(v));\n      clone = FALSE;\n      break;\n    }\n    case VALUE_TYPE_WSTRING: {\n      p = (void*)value_wstr(v);\n      size = wcslen(value_wstr(v)) * sizeof(wchar_t);\n      clone = FALSE;\n      break;\n    }\n    case VALUE_TYPE_POINTER: {\n      p = value_pointer(v);\n      size = args->size > 1 ? value_uint32(args->args + 1) : 0;\n      clone = FALSE;\n      break;\n    }\n    case VALUE_TYPE_BINARY: {\n      p = v->value.binary_data.data;\n      size = v->value.binary_data.size;\n      clone = FALSE;\n      break;\n    }\n    case VALUE_TYPE_SIZED_STRING: {\n      p = v->value.sized_str.str;\n      size = v->value.sized_str.size;\n      clone = FALSE;\n      break;\n    }\n    default: {\n      log_debug(\"not supported type\\n\");\n      break;\n    }\n  }\n\n  if (p == NULL || size == 0) {\n    value_set_binary_data(result, p, size);\n    return RET_OK;\n  }\n\n  /*参数1指定长度*/\n  if (args->size > 1) {\n    uint32_t esize = value_uint32(args->args + 1);\n    if (esize <= size) {\n      size = esize;\n    } else {\n      log_debug(\"size is too large, use default\\n\");\n    }\n  }\n\n  /*参数2要求复制*/\n  if (args->size > 2 && value_bool(args->args + 2)) {\n    clone = TRUE;\n  }\n\n  if (clone) {\n    p = tk_memdup(p, size);\n    value_set_binary_data(result, p, size);\n    result->free_handle = TRUE;\n  } else {\n    value_set_binary_data(result, p, size);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_str(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  str_t* str = &(fscript->str);\n  value_t* v = args->args;\n  bool_t force_pointer_as_str = args->size == 2 && value_bool(args->args + 1);\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n\n  if (force_pointer_as_str) {\n    if (v->type == VALUE_TYPE_POINTER) {\n      value_set_str(result, (const char*)value_pointer(v));\n      return RET_OK;\n    } else if (v->type == VALUE_TYPE_BINARY) {\n      value_set_str(result, (const char*)(v->value.binary_data.data));\n      return RET_OK;\n    }\n  }\n  str_from_value(str, args->args);\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}\n\nstatic ret_t func_one_of(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  char sep = ';';\n  int32_t index = 0;\n  const char* strs = NULL;\n  const char* start = NULL;\n\n  value_set_str(result, \"\");\n  FSCRIPT_FUNC_CHECK(args->size >= 2, RET_BAD_PARAMS);\n  FSCRIPT_FUNC_CHECK(args->args[0].type == VALUE_TYPE_STRING, RET_BAD_PARAMS);\n  strs = value_str(args->args);\n  FSCRIPT_FUNC_CHECK(strs != NULL, RET_BAD_PARAMS);\n\n  if (args->size > 2 && args->args[2].type == VALUE_TYPE_STRING) {\n    const char* p = value_str(args->args + 2);\n    if (p != NULL) {\n      sep = *p;\n    }\n  }\n\n  start = strs;\n  index = value_int(args->args + 1);\n\n  while (index > 0) {\n    while (*start && *start != sep) {\n      start++;\n    }\n    if (*start == '\\0') {\n      break;\n    }\n    index--;\n    start++;\n  }\n\n  if (start != NULL) {\n    const char* end = strchr(start, sep);\n    if (end != NULL) {\n      value_dup_str_with_len(result, start, end - start);\n    } else {\n      value_dup_str(result, start);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_join(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  char buff[64];\n  str_t* str = &(fscript->str);\n  value_set_bool(result, FALSE);\n  FSCRIPT_FUNC_CHECK(args->size > 1, RET_BAD_PARAMS);\n\n  str_set(str, \"\");\n  value_set_bool(result, TRUE);\n  for (i = 1; i < args->size; i++) {\n    if (i > 1) {\n      str_append(str, value_str_ex(args->args, buff, sizeof(buff)));\n    }\n    str_append(str, value_str_ex(args->args + i, buff, sizeof(buff)));\n  }\n\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}\n\nstatic ret_t func_set_local(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  const char* name = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  name = value_id(args->args);\n  FSCRIPT_FUNC_CHECK(name != NULL, RET_BAD_PARAMS);\n  value_set_bool(result, fscript_locals_create(fscript, name, args->args + 1) == RET_OK);\n\n  return RET_OK;\n}\n\nstatic ret_t func_get(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  ret_t ret = RET_OK;\n  value_t* v = args->args;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  return_value_if_fail(v->type == VALUE_TYPE_ID, RET_BAD_PARAMS);\n\n  if (value_id_index(v) >= 0) {\n    ret = fscript_locals_get(fscript, v, result);\n  } else {\n    const char* name = value_id(v);\n    ret = fscript_get_var(fscript, name, result);\n  }\n\n  if (ret != RET_OK) {\n    result->type = VALUE_TYPE_INVALID;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_set(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  int32_t index = 0;\n  value_t* v = args->args;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  return_value_if_fail(v->type == VALUE_TYPE_ID, RET_BAD_PARAMS);\n\n  index = value_id_index(v);\n  if (index >= 0) {\n    value_set_bool(result, fscript_locals_set(fscript, v, args->args + 1) == RET_OK);\n  } else {\n    const char* name = value_id(v);\n    value_set_bool(result, fscript_set_var(fscript, name, args->args + 1) == RET_OK);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_unset(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  int32_t index = 0;\n  value_t* v = args->args;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  return_value_if_fail(v->type == VALUE_TYPE_ID, RET_BAD_PARAMS);\n\n  index = value_id_index(v);\n  if (index >= 0) {\n    fscript_locals_remove(fscript, index);\n  } else {\n    const char* name = value_id(v);\n    tk_object_remove_prop(fscript->obj, name);\n  }\n  value_set_bool(result, TRUE);\n\n  return RET_OK;\n}\n\nstatic ret_t func_expr(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  if (args->size >= 1) {\n    value_deep_copy(result, args->args + args->size - 1);\n  } else {\n    result->type = VALUE_TYPE_INVALID;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_print(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  char buff[64];\n\n  value_set_bool(result, TRUE);\n  for (i = 0; i < args->size; i++) {\n    log_info(\"%s \", value_str_ex(args->args + i, buff, sizeof(buff) - 1));\n  }\n  log_info(\"\\n\");\n\n  if (fscript->print != NULL) {\n    return fscript->print(fscript, args, result);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_iformat(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  str_t* str = &(fscript->str);\n  const char* format = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  format = value_str(args->args);\n  FSCRIPT_FUNC_CHECK(format != NULL, RET_BAD_PARAMS);\n\n  tk_snprintf(str->str, str->capacity - 1, format, value_int(args->args + 1));\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}\n\nstatic ret_t func_fformat(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  str_t* str = &(fscript->str);\n  const char* format = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  format = value_str(args->args);\n  FSCRIPT_FUNC_CHECK(format != NULL, RET_BAD_PARAMS);\n\n  tk_snprintf(str->str, str->capacity - 1, format, value_double(args->args + 1));\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}\n\nstatic ret_t func_and(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value_set_bool(result, value_bool(args->args) && value_bool(args->args + 1));\n\n  return RET_OK;\n}\n\nstatic ret_t func_or(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value_set_bool(result, value_bool(args->args) || value_bool(args->args + 1));\n\n  return RET_OK;\n}\n\nstatic ret_t func_not(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_bool(result, !value_bool(args->args));\n\n  return RET_OK;\n}\n\nstatic ret_t func_minus(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  if (args->args[0].type == VALUE_TYPE_INT32) {\n    value_set_int(result, -value_int(args->args));\n  } else {\n    value_set_double(result, -value_double(args->args));\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_div(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value_set_double(result, value_double(args->args) / value_double(args->args + 1));\n\n  return RET_OK;\n}\n\nstatic ret_t func_mod(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value_set_int(result, value_int(args->args) % value_int(args->args + 1));\n\n  return RET_OK;\n}\n\nstatic ret_t func_mul(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value_set_double(result, value_double(args->args) * value_double(args->args + 1));\n\n  return RET_OK;\n}\n\nstatic ret_t func_sub(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n  if (args->size == 1) {\n    func_minus(fscript, args, result);\n  } else {\n    if (args->args->type == VALUE_TYPE_INT32 && args->args[1].type == VALUE_TYPE_INT32) {\n      value_set_int(result, value_int(args->args) - value_int(args->args + 1));\n    } else {\n      value_set_double(result, value_double(args->args) - value_double(args->args + 1));\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_random(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  long v = random();\n  if (args->size == 2) {\n    int32_t min = value_int(args->args);\n    int32_t max = value_int(args->args + 1);\n    if (min < max) {\n      v = min + v % (max - min);\n    }\n  }\n\n  value_set_int(result, v);\n\n  return RET_OK;\n}\n\nstatic ret_t func_le(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  if (args->args[0].type == VALUE_TYPE_STRING && args->args[1].type == VALUE_TYPE_STRING) {\n    value_set_bool(result, tk_str_cmp(value_str(args->args), value_str(args->args + 1)) <= 0);\n  } else {\n    value_set_bool(result, value_double(args->args) <= value_double(args->args + 1));\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_less(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  if (args->args[0].type == VALUE_TYPE_STRING && args->args[1].type == VALUE_TYPE_STRING) {\n    value_set_bool(result, tk_str_cmp(value_str(args->args), value_str(args->args + 1)) < 0);\n  } else {\n    value_set_bool(result, value_double(args->args) < value_double(args->args + 1));\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_ge(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  if (args->args[0].type == VALUE_TYPE_STRING && args->args[1].type == VALUE_TYPE_STRING) {\n    value_set_bool(result, tk_str_cmp(value_str(args->args), value_str(args->args + 1)) >= 0);\n  } else {\n    value_set_bool(result, value_double(args->args) >= value_double(args->args + 1));\n  }\n  return RET_OK;\n}\n\nstatic ret_t func_great(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  if (args->args[0].type == VALUE_TYPE_STRING && args->args[1].type == VALUE_TYPE_STRING) {\n    value_set_bool(result, tk_str_cmp(value_str(args->args), value_str(args->args + 1)) > 0);\n  } else {\n    value_set_bool(result, value_double(args->args) > value_double(args->args + 1));\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_eq(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  value_t* v1 = NULL;\n  value_t* v2 = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  v1 = args->args;\n  v2 = args->args + 1;\n\n  if (v1->type == VALUE_TYPE_STRING && v2->type == VALUE_TYPE_STRING) {\n    value_set_bool(result, tk_str_eq(value_str(v1), value_str(v2)));\n  } else if (v1->type == VALUE_TYPE_POINTER && v2->type == VALUE_TYPE_POINTER) {\n    value_set_bool(result, value_pointer(v1) == value_pointer(v2));\n  } else if (v1->type == VALUE_TYPE_OBJECT && v2->type == VALUE_TYPE_OBJECT) {\n    value_set_bool(result, value_object(v1) == value_object(v2));\n  } else if (v1->type == VALUE_TYPE_BINARY && v2->type == VALUE_TYPE_BINARY) {\n    binary_data_t* bin1 = value_binary_data(v1);\n    binary_data_t* bin2 = value_binary_data(v2);\n    if (bin1->size == bin2->size) {\n      value_set_bool(result, tk_str_cmp((const char*)bin1->data, (const char*)bin2->data) == 0);\n    } else {\n      value_set_bool(result, FALSE);\n    }\n  } else if (v1->type == VALUE_TYPE_INT64 || v2->type == VALUE_TYPE_INT64) {\n    value_set_bool(result, value_int64(v1) == value_int64(v2));\n  } else if (v1->type == VALUE_TYPE_UINT64 || v2->type == VALUE_TYPE_UINT64) {\n    value_set_bool(result, value_uint64(v1) == value_uint64(v2));\n  } else if (v1->type != v2->type && !(value_is_digit(v1) && value_is_digit(v2))) {\n    value_set_bool(result, FALSE);\n  } else {\n    value_set_bool(result, tk_fequal(value_double(v1), value_double(v2)));\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_not_eq(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  func_eq(fscript, args, result);\n  value_set_bool(result, !value_bool(result));\n\n  return RET_OK;\n}\n\nstatic ret_t func_assert(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n  if (!value_bool(args->args)) {\n    fscript_set_error(fscript, RET_FAIL, __FUNCTION__,\n                      args->size > 1 ? value_str(args->args + 1) : \"unkown\");\n    if (args->size > 1 && value_bool(args->args + 1)) {\n      assert(0);\n    } else {\n      log_debug(\"assert failed at: (%d %d)\\n\", (int)(fscript->curr->row),\n                (int)(fscript->curr->col));\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_min(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  double v1 = 0;\n  double v2 = 0;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n\n  v1 = value_double(args->args);\n  v2 = value_double(args->args + 1);\n  value_set_double(result, tk_min(v1, v2));\n\n  return RET_OK;\n}\n\nstatic ret_t func_max(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  double v1 = 0;\n  double v2 = 0;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n\n  v1 = value_double(args->args);\n  v2 = value_double(args->args + 1);\n  value_set_double(result, tk_max(v1, v2));\n\n  return RET_OK;\n}\n\nstatic ret_t func_clamp(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  double v1 = 0;\n  double v2 = 0;\n  double v3 = 0;\n  FSCRIPT_FUNC_CHECK(args->size == 3, RET_BAD_PARAMS);\n\n  v1 = value_double(args->args);\n  v2 = value_double(args->args + 1);\n  v3 = value_double(args->args + 2);\n  value_set_double(result, tk_clamp(v1, v2, v3));\n\n  return RET_OK;\n}\n\nstatic ret_t func_round(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_double(result, tk_roundi(value_double(args->args)));\n  return RET_OK;\n}\n\nstatic ret_t func_floor(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_double(result, floor(value_double(args->args)));\n  return RET_OK;\n}\n\nstatic ret_t func_ceil(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_double(result, ceil(value_double(args->args)));\n  return RET_OK;\n}\n\nstatic ret_t func_abs(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_double(result, tk_abs(value_double(args->args)));\n  return RET_OK;\n}\n\nstatic ret_t func_len(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  char buff[64];\n  const char* str = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n\n  if (args->args->type == VALUE_TYPE_OBJECT) {\n    tk_object_t* obj = value_object(args->args);\n    value_set_uint32(result, tk_object_get_prop_int32(obj, \"size\", 0));\n  } else if (args->args->type == VALUE_TYPE_BINARY) {\n    binary_data_t* data = value_binary_data(args->args);\n    value_set_uint32(result, data != NULL ? data->size : 0);\n  } else if (args->args->type == VALUE_TYPE_STRING) {\n    value_set_uint32(result, tk_strlen(value_str(args->args)));\n  } else {\n    str = value_str_ex(args->args, buff, sizeof(buff) - 1);\n    value_set_uint32(result, tk_strlen(str));\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t func_toupper(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  str_t* str = &(fscript->str);\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  str_set(str, value_str(args->args));\n  str_to_upper(str);\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}\n\nstatic ret_t func_eval(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  return fscript_eval(fscript->obj, value_str(args->args), result);\n}\n\nstatic ret_t func_tolower(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  str_t* str = &(fscript->str);\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  str_set(str, value_str(args->args));\n  str_to_lower(str);\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}\n\nstatic ret_t func_trim(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  str_t* str = &(fscript->str);\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  str_set(str, value_str(args->args));\n  str_trim(str, \" \\t\\r\\n\");\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}\n\nstatic ret_t func_substr(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  str_t* str = &(fscript->str);\n  const char* org = NULL;\n  uint32_t total_len = 0;\n  uint32_t from = 0;\n  uint32_t len = 0;\n  FSCRIPT_FUNC_CHECK(args->size == 3, RET_BAD_PARAMS);\n  org = value_str(args->args);\n  from = value_uint32(args->args + 1);\n  len = value_uint32(args->args + 2);\n  total_len = tk_strlen(org);\n  FSCRIPT_FUNC_CHECK(org != NULL, RET_BAD_PARAMS);\n\n  if (from < total_len) {\n    len = tk_min(len, (total_len - from));\n    str_set_with_len(str, org + from, len);\n  } else {\n    str_set(str, \"\");\n  }\n\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}\n\nstatic ret_t func_replace(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  str_t* str = &(fscript->str);\n  const char* org = NULL;\n  const char* replace = NULL;\n  const char* replace_with = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 3, RET_BAD_PARAMS);\n\n  org = value_str(args->args);\nreplace = ",
    "raw_res": "0;",
    "prompt_res": "value_str(args->args + 1);",
    "gt": "value_str(args->args + 1);"
  },
  {
    "id": 834,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/rlog.c",
    "input": "﻿/**\n * File:   rlog.c\n * Author: AWTK Develop Team\n * Brief:  rotate log api\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2020-11-18 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/rlog.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/mutex_nest.h\"\n\n#ifdef HAS_STDIO\n#define my_return_value_if_fail(p, value)                                \\\n  if (!(p)) {                                                            \\\n    printf(\"%s:%d condition(\" #p \") failed!\\n\", __FUNCTION__, __LINE__); \\\n    fflush(stdout);                                                      \\\n    return (value);                                                      \\\n  }\n#else\n#define my_return_value_if_fail(p, value) \\\n  if (!(p)) {                             \\\n    return (value);                       \\\n  }\n#endif\n\nrlog_t* rlog_create(const char* filename_pattern, uint32_t max_size, uint32_t buff_size) {\n  rlog_t* log = NULL;\n  fs_stat_info_t fst;\n  fs_file_t* fp = NULL;\n  uint32_t index = 0;\n  char filename[MAX_PATH + 1];\n  my_return_value_if_fail(filename_pattern != NULL && max_size > 1000 && buff_size > 32, NULL);\n\n  memset(filename, 0x00, sizeof(filename));\n  tk_snprintf(filename, MAX_PATH, filename_pattern, (int)index);\n  if (fs_stat(os_fs(), filename, &fst) == RET_OK) {\n    if (fst.size < (max_size - buff_size)) {\n      fp = fs_open_file(os_fs(), filename, \"ab+\");\n    } else {\n      index = 1;\n      tk_snprintf(filename, MAX_PATH, filename_pattern, (int)(index));\n      fp = fs_open_file(os_fs(), filename, \"ab+\");\n    }\n  } else {\n    fp = fs_open_file(os_fs(), filename, \"wb+\");\n  }\n  my_return_value_if_fail(fp != NULL, NULL);\n\n  log = TKMEM_ZALLOC(rlog_t);\n  if (log != NULL) {\n    log->index = index;\n    log->max_size = max_size;\n    log->buff_size = buff_size;\n    log->mutex = tk_mutex_nest_create();\n    log->filename_pattern = tk_strdup(filename_pattern);\n\n    if (log->filename_pattern != NULL) {\n      log->fp = fp;\n    } else {\n      fs_file_close(fp);\n      TKMEM_FREE(log);\n    }\n  } else {\n    fs_file_close(fp);\n  }\n\n  return log;\n}\n\nret_t rlog_write(rlog_t* log, const char* str) {\n  uint32_t len = 0;\n  fs_stat_info_t fst;\n  my_return_value_if_fail(log != NULL && log->fp != NULL && str != NULL, RET_BAD_PARAMS);\n  my_return_value_if_fail(fs_file_stat(log->fp, &fst) == RET_OK, RET_BAD_PARAMS);\n\n  if (tk_mutex_nest_lock(log->mutex) == RET_OK) {\n    len = strlen(str);\n    if ((fst.size + len) > log->max_size) {\n      char filename0[MAX_PATH + 1];\n      char filename1[MAX_PATH + 1];\n\n      fs_file_close(log->fp);\n      memset(filename1, 0x00, sizeof(filename1));\n      tk_snprintf(filename1, MAX_PATH, log->filename_pattern, (int)1);\n      if (log->index == 1) {\n        memset(filename0, 0x00, sizeof(filename0));\n        tk_snprintf(filename0, MAX_PATH, log->filename_pattern, (int)0);\n        fs_remove_file(os_fs(), filename0);\n        fs_file_rename(os_fs(), filename1, filename0);\n      }\n      log->index = 1;\n      log->fp = fs_open_file(os_fs(), filename1, \"wb+\");\n    }\n    if (log->fp != NULL) {\n      fs_file_write(log->fp, str, len);\n      fs_file_sync(log->fp);\n    }\n    tk_mutex_nest_unlock(log->mutex);\n  }\n\n  return RET_OK;\n}\n\nret_t rlog_print(rlog_t* log, const char* format, ...) {\n  va_list va;\n  ret_t ret = RET_OK;\n  my_return_value_if_fail(log != NULL && log->fp != NULL && format != NULL, RET_BAD_PARAMS);\n  my_return_value_if_fail(log->buff_size > 0, RET_BAD_PARAMS);\n\n  if (tk_mutex_nest_lock(log->mutex) == RET_OK) {\n    if (log->buff == NULL) {\n      log->buff = TKMEM_ALLOC(log->buff_size + 1);\n      if (log->buff == NULL) {\n        tk_mutex_nest_unlock(log->mutex);\n        return RET_OOM;\n      }\n      memset(log->buff, 0x00, log->buff_size + 1);\n    }\n\n    va_start(va, format);\n    tk_vsnprintf(log->buff, log->buff_size, format, va);\n    va_end(va);\n\nret = ",
    "raw_res": "0;",
    "prompt_res": "rlog_write(log, log->buff);",
    "gt": "rlog_write(log, log->buff);"
  },
  {
    "id": 841,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/waitable_ring_buffer.c",
    "input": "﻿/**\n * File:   waitable_ring_buffer.c\n * Author: AWTK Develop Team\n * Brief:  waitable_ring_buffer\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2020-04-02 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/waitable_ring_buffer.h\"\n\nwaitable_ring_buffer_t* waitable_ring_buffer_create(uint32_t capacity, uint32_t block_size) {\n  waitable_ring_buffer_t* rb = TKMEM_ZALLOC(waitable_ring_buffer_t);\n  return_value_if_fail(rb != NULL, NULL);\n  rb->ring_buffer = ring_buffer_create(capacity * block_size, capacity * block_size);\n  goto_error_if_fail(rb->ring_buffer != NULL);\n\n  rb->block_size = block_size;\n  rb->mutex = tk_mutex_create();\n  goto_error_if_fail(rb->mutex != NULL);\n\n  rb->sema_read = tk_semaphore_create(0, NULL);\n  goto_error_if_fail(rb->sema_read != NULL);\n\nrb->sema_write = ",
    "raw_res": "tk_semaphore_create(0, NULL);",
    "prompt_res": "tk_semaphore_create(capacity, NULL);",
    "gt": "tk_semaphore_create(capacity, NULL);"
  },
  {
    "id": 897,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/object_array.c",
    "input": "﻿/**\n * File:   object_array.c\n * Author: AWTK Develop Team\n * Brief:  object array\n *\n * Copyright (c) 2019 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY { without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-01-10 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/value.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/named_value.h\"\n#include \"tkc/object_array.h\"\n\nstatic ret_t object_array_clean_invalid_props(tk_object_t* obj) {\n  object_array_t* o = OBJECT_ARRAY(obj);\n  event_t e = event_init(EVT_ITEMS_CHANGED, o);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n  if (o->size > 0) {\n    uint32_t i = 0;\n    value_t* dst = o->props;\n\n    for (i = 0; i < o->size; i++) {\n      value_t* iter = o->props + i;\n\n      if (iter->type != VALUE_TYPE_INVALID) {\n        if (dst != iter) {\n          memcpy(dst, iter, sizeof(value_t));\n        }\n        dst++;\n      }\n    }\n\n    o->size = dst - o->props;\n  }\n\n  emitter_dispatch(EMITTER(o), &e);\n\n  return RET_OK;\n}\n\nret_t object_array_clear_props(tk_object_t* obj) {\n  uint32_t i = 0;\n  object_array_t* o = OBJECT_ARRAY(obj);\n  event_t e = event_init(EVT_ITEMS_CHANGED, o);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n\n  for (i = 0; i < o->size; i++) {\n    value_t* iter = o->props + i;\n    value_reset(iter);\n  }\n\n  o->size = 0;\n  emitter_dispatch(EMITTER(o), &e);\n\n  return RET_OK;\n}\n\nstatic ret_t object_array_on_destroy(tk_object_t* obj) {\n  object_array_t* o = OBJECT_ARRAY(obj);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n\n  object_array_clear_props(obj);\n  o->capacity = 0;\n  TKMEM_FREE(o->props);\n\n  return RET_OK;\n}\n\nstatic int32_t object_array_compare(tk_object_t* obj, tk_object_t* other) {\n  return tk_str_cmp(obj->name, other->name);\n}\n\nstatic ret_t object_array_extend(tk_object_t* obj) {\n  ret_t ret = RET_OOM;\n  object_array_t* o = OBJECT_ARRAY(obj);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n\n  if (o->size < o->capacity) {\n    ret = RET_OK;\n  } else {\n    value_t* props = NULL;\n    uint32_t capacity = o->capacity + (o->capacity >> 1) + 1;\n    props = TKMEM_REALLOCT(value_t, o->props, capacity);\n\n    if (props != NULL) {\n      o->props = props;\n      o->capacity = capacity;\n      ret = RET_OK;\n    }\n  }\n\n  return ret;\n}\n\nret_t object_array_insert(tk_object_t* obj, uint32_t index, const value_t* v) {\n  value_t* s = NULL;\n  value_t* d = NULL;\n  value_t* p = NULL;\n  object_array_t* o = OBJECT_ARRAY(obj);\n  event_t e = event_init(EVT_ITEMS_CHANGED, o);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n\n  return_value_if_fail(o != NULL && v != NULL, RET_BAD_PARAMS);\n  index = tk_min(index, o->size);\n  return_value_if_fail(object_array_extend(obj) == RET_OK, RET_OOM);\n\n  p = o->props + index;\n  d = o->props + o->size;\n  s = d - 1;\n\n  while (s >= p) {\n    *d-- = *s--;\n  }\n  value_deep_copy(p, v);\n  o->size++;\n  emitter_dispatch(EMITTER(o), &e);\n\n  return RET_OK;\n}\n\nret_t object_array_push(tk_object_t* obj, const value_t* v) {\n  object_array_t* o = OBJECT_ARRAY(obj);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n\n  return object_array_insert(obj, o->size, v);\n}\n\nstatic int32_t object_array_parse_index(const char* name) {\n  if (tk_isdigit(*name)) {\n    return tk_atoi(name);\n  } else if (*name == '[') {\n    return tk_atoi(name + 1);\n  } else if (tk_str_eq(name, \"-1\")) {\n    return -1;\n  } else {\n    return -2;\n  }\n}\n\nint32_t object_array_index_of(tk_object_t* obj, const value_t* v) {\n  int32_t i = 0;\n  object_array_t* o = OBJECT_ARRAY(obj);\n  return_value_if_fail(o != NULL, -1);\n\n  for (i = 0; i < o->size; i++) {\n    value_t* iter = o->props + i;\n    if (value_equal(iter, v)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nint32_t object_array_last_index_of(tk_object_t* obj, const value_t* v) {\n  int32_t i = 0;\n  object_array_t* o = OBJECT_ARRAY(obj);\n  return_value_if_fail(o != NULL, -1);\n\n  if (o->size > 0) {\n    for (i = o->size - 1; i >= 0; i--) {\n      value_t* iter = o->props + i;\n      if (value_equal(iter, v)) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n}\n\nret_t object_array_remove(tk_object_t* obj, uint32_t index) {\n  return object_array_get_and_remove(obj, index, NULL);\n}\n\nret_t object_array_get_and_remove(tk_object_t* obj, uint32_t index, value_t* v) {\n  ret_t ret = RET_NOT_FOUND;\n  object_array_t* o = OBJECT_ARRAY(obj);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n\n  if (index < o->size) {\n    value_t* iter = o->props + index;\n    if (v != NULL) {\n      *v = *iter;\n      memset(iter, 0x00, sizeof(*iter));\n    } else {\n      value_reset(iter);\n    }\n    ret = object_array_clean_invalid_props(obj);\n  }\n\n  return ret;\n}\n\nret_t object_array_shift(tk_object_t* obj, value_t* v) {\n  return object_array_get_and_remove(obj, 0, v);\n}\n\nstatic ret_t object_array_remove_prop(tk_object_t* obj, const char* name) {\n  int32_t index = object_array_parse_index(name);\n\n  return object_array_remove(obj, index);\n}\n\nret_t object_array_pop(tk_object_t* obj, value_t* v) {\n  value_t* last = NULL;\n  object_array_t* o = OBJECT_ARRAY(obj);\n  event_t e = event_init(EVT_ITEMS_CHANGED, o);\n  return_value_if_fail(o != NULL && o->size > 0, RET_BAD_PARAMS);\n  last = o->props + o->size - 1;\n  *v = *last;\n  memset(last, 0x00, sizeof(value_t));\n  o->size--;\n\n  emitter_dispatch(EMITTER(o), &e);\n\n  return RET_OK;\n}\n\nret_t object_array_set(tk_object_t* obj, uint32_t index, const value_t* v) {\n  ret_t ret = RET_NOT_FOUND;\n  object_array_t* o = OBJECT_ARRAY(obj);\n  event_t e = event_init(EVT_ITEMS_CHANGED, o);\n  return_value_if_fail(object_array_extend(obj) == RET_OK, RET_OOM);\n\n  if (index < o->size) {\n    value_t* iter = o->props + index;\n    value_reset(iter);\n    ret = value_deep_copy(iter, v);\n    emitter_dispatch(EMITTER(o), &e);\n  } else if (index == 0xffffffff) {\n    ret = object_array_push(obj, v);\n  } else {\n    ret = RET_BAD_PARAMS;\n  }\n\n  return ret;\n}\n\nstatic ret_t object_array_set_prop(tk_object_t* obj, const char* name, const value_t* v) {\n  int32_t index = -1;\n  ret_t ret = RET_NOT_FOUND;\n  object_array_t* o = OBJECT_ARRAY(obj);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n\n  tk_object_t* sub = tk_object_get_child_object(obj, name, &name);\n  if (sub != NULL) {\n    return tk_object_set_prop(sub, name, v);\n  }\n\n  index = object_array_parse_index(name);\n  if (index != -2) {\n    ret = object_array_set(obj, index, v);\n  }\n\n  return ret;\n}\n\nret_t object_array_get(tk_object_t* obj, uint32_t i, value_t* v) {\n  ret_t ret = RET_NOT_FOUND;\n  object_array_t* o = OBJECT_ARRAY(obj);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n\n  if (i < o->size) {\n    value_t* iter = o->props + i;\nret = ",
    "raw_res": "value_deep_copy(v, iter);",
    "prompt_res": "value_copy(v, iter);",
    "gt": "value_copy(v, iter);"
  },
  {
    "id": 905,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/func_call_parser.c",
    "input": "﻿/**\n * File:   func_call_parser.h\n * Author: AWTK Develop Team\n * Brief:  func_call_parser\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is difunc_call_parseributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-10-20 Li XianJing <xianjimli@hotmail.com> adapt from uclib\n *\n */\n\n#include \"tkc/utils.h\"\n#include \"tkc/object_default.h\"\n#include \"tkc/func_call_parser.h\"\n\nfunc_call_parser_t* func_call_parser_init(func_call_parser_t* parser, const char* str,\n                                          uint32_t size) {\n  return_value_if_fail(parser != NULL && str != NULL, NULL);\n\n  tokenizer_init(&(parser->tokenizer), str, size, \"(=,)\\r\\n\\t \");\n\n  return parser;\n}\n\nret_t func_call_parser_parse(func_call_parser_t* parser) {\n  const char* token = NULL;\n  char name[TK_NAME_LEN + 1];\n  tokenizer_t* tokenizer = NULL;\n  return_value_if_fail(parser != NULL, RET_BAD_PARAMS);\n\n  tokenizer = &(parser->tokenizer);\n  return_value_if_fail(tokenizer_has_more(tokenizer) == TRUE, RET_BAD_PARAMS);\n\n  token = tokenizer_next(tokenizer);\n  if (parser->on_name != NULL) {\n    parser->on_name(parser, token);\n  }\n\n  while (tokenizer_has_more(tokenizer)) {\n    token = tokenizer_next(tokenizer);\n    if (token == NULL) {\n      break;\n    }\n    tk_strncpy(name, token, TK_NAME_LEN);\n\n    return_value_if_fail(tokenizer_has_more(tokenizer), RET_BAD_PARAMS);\n    token = tokenizer_next_str(tokenizer);\n\n    if (parser->on_param != NULL) {\n      parser->on_param(parser, name, token);\n    }\n  }\n\n  if (parser->on_done != NULL) {\n    parser->on_done(parser);\n  }\n\n  return RET_OK;\n}\n\nret_t func_call_parser_deinit(func_call_parser_t* parser) {\n  return_value_if_fail(parser != NULL, RET_BAD_PARAMS);\n\n  tokenizer_deinit(&(parser->tokenizer));\n  memset(parser, 0x00, sizeof(func_call_parser_t));\n\n  return RET_OK;\n}\n\ntypedef struct _object_parser_t {\n  func_call_parser_t base;\n\n  tk_object_t* obj;\n} object_parser_t;\n\nstatic ret_t parser_on_param(func_call_parser_t* parser, const char* name, const char* value) {\n  object_parser_t* p = (object_parser_t*)parser;\n\n  return tk_object_set_prop_str(p->obj, name, value);\n}\n\nstatic ret_t parser_on_name(func_call_parser_t* parser, const char* func_name) {\n  object_parser_t* p = (object_parser_t*)parser;\n\n  return tk_object_set_name(p->obj, func_name);\n}\n\ntk_object_t* func_call_parse(const char* str, uint32_t size) {\n  object_parser_t parser;\n  return_value_if_fail(str != NULL && size > 0, NULL);\n\n  memset(&parser, 0x00, sizeof(parser));\n  func_call_parser_init(&(parser.base), str, size);\n\nparser.obj = ",
    "raw_res": "0;",
    "prompt_res": "object_default_create();",
    "gt": "object_default_create();"
  },
  {
    "id": 909,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/object_locker.c",
    "input": "﻿/**\n * File:   object_locker.c\n * Author: AWTK Develop Team\n * Brief:  decorate object with lock\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY { without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2020-06-12 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/value.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/object_locker.h\"\n\nstatic ret_t object_locker_on_destroy(tk_object_t* obj) {\n  object_locker_t* o = OBJECT_LOCKER(obj);\n  return_value_if_fail(o != NULL && o->mutex != NULL, RET_BAD_PARAMS);\n  tk_mutex_nest_destroy(o->mutex);\n  emitter_off_by_ctx(EMITTER(o->obj), o);\n  TK_OBJECT_UNREF(o->obj);\n\n  return RET_OK;\n}\n\nstatic int32_t object_locker_compare(tk_object_t* obj, tk_object_t* other) {\n  object_locker_t* o = OBJECT_LOCKER(obj);\n  return_value_if_fail(o != NULL && o->obj != NULL, -1);\n  return tk_object_compare(o->obj, other);\n}\n\nstatic ret_t object_locker_remove_prop(tk_object_t* obj, const char* name) {\n  ret_t ret = RET_NOT_FOUND;\n  object_locker_t* o = OBJECT_LOCKER(obj);\n  return_value_if_fail(o != NULL && o->mutex != NULL, RET_BAD_PARAMS);\n  if (tk_mutex_nest_lock(o->mutex) == RET_OK) {\nret = ",
    "raw_res": "0;",
    "prompt_res": "tk_object_remove_prop(o->obj, name);",
    "gt": "tk_object_remove_prop(o->obj, name);"
  },
  {
    "id": 918,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/data_reader_file.c",
    "input": "﻿/**\n * File:   data_reader.c\n * Author: AWTK Develop Team\n * Brief:  data_reader\n *\n * Copyright (c) 2019 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2020-02-26 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/fs.h\"\n#include \"tkc/data_reader_file.h\"\n\ntypedef struct _data_reader_file_t {\n  data_reader_t data_reader;\n\n  fs_file_t* file;\n  uint64_t size;\n} data_reader_file_t;\n\nstatic int32_t data_reader_file_read(data_reader_t* reader, uint64_t offset, void* data,\n                                     uint32_t size) {\n  data_reader_file_t* file = (data_reader_file_t*)reader;\n  return_value_if_fail(fs_file_seek(file->file, offset) == RET_OK, 0);\n\n  return fs_file_read(file->file, data, size);\n}\n\nstatic uint64_t data_reader_file_get_size(data_reader_t* reader) {\n  data_reader_file_t* file = (data_reader_file_t*)reader;\n\n  return file->size;\n}\n\nstatic ret_t data_reader_file_destroy(data_reader_t* reader) {\n  data_reader_file_t* file = (data_reader_file_t*)reader;\n\n  fs_file_close(file->file);\n  TKMEM_FREE(file);\n\n  return RET_OK;\n}\n\nstatic const data_reader_vtable_t s_data_reader_file_vtable = {\n    .read = data_reader_file_read,\n    .get_size = data_reader_file_get_size,\n    .destroy = data_reader_file_destroy,\n};\n\ndata_reader_t* data_reader_file_create(const char* filename) {\n  fs_stat_info_t st;\n  data_reader_file_t* file = NULL;\n  return_value_if_fail(filename != NULL, NULL);\n  file = TKMEM_ZALLOC(data_reader_file_t);\n  return_value_if_fail(file != NULL, NULL);\n\n  if (fs_stat(os_fs(), filename, &st) == RET_OK) {\n    file->size = st.size;\nfile->file = ",
    "raw_res": "fs_file_open(os_fs(), filename, FS_FILE_OPEN_READ);",
    "prompt_res": "fs_open_file(os_fs(), filename, \"rb\");",
    "gt": "fs_open_file(os_fs(), filename, \"rb\");"
  },
  {
    "id": 927,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/mem.c",
    "input": "﻿/**\n * File:   mem.c\n * Author: AWTK Develop Team\n * Brief:  simple memory manager\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-13 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include <stdarg.h>\n#include \"tkc/mem.h\"\n#include \"tkc/time_now.h\"\n#include \"tkc/mem_allocator_oom.h\"\n#include \"tkc/mem_allocator_pool.h\"\n\nstatic mem_allocator_oom_t s_oom;\n\n#ifdef ENABLE_MEM_LEAK_CHECK\n#include \"tkc/mem_allocator_debug.h\"\nstatic mem_allocator_debug_t s_debug;\n#endif /*ENABLE_MEM_LEAK_CHECK*/\n\nstatic mem_allocator_t* s_allocator = NULL;\n\n#define MAX_BLOCK_SIZE 0xffff0000\n\n#ifdef HAS_STD_MALLOC\n#include \"tkc/mem_allocator_std.h\"\n\n#ifdef ENABLE_MEM_LEAK_CHECK\n#include \"tkc/mem_allocator_lock.h\"\nstatic mem_allocator_lock_t s_lock;\n#endif /*ENABLE_MEM_LEAK_CHECK*/\n\nbool_t tk_mem_is_valid_addr(void* addr) {\n  return ((uintptr_t)addr > 0x10000);\n}\n\nstatic mem_allocator_t* mem_allocator_get(void) {\n  static mem_allocator_std_t std;\n  if (s_allocator != NULL) {\n    return s_allocator;\n  }\n\n  s_allocator = mem_allocator_std_init(&std);\n#ifdef ENABLE_MEM_LEAK_CHECK\n  s_allocator = mem_allocator_debug_init(&s_debug, s_allocator);\n  s_allocator = mem_allocator_lock_init(&s_lock, s_allocator);\n#endif /*ENABLE_MEM_LEAK_CHECK*/\n  s_allocator = mem_allocator_oom_init(&s_oom, s_allocator);\n\n  return s_allocator;\n}\n\nret_t tk_mem_init_stage2(void) {\n  return RET_OK;\n}\n\n#else /*non std memory manager*/\n#include \"tkc/mem_allocator_lock.h\"\n#include \"tkc/mem_allocator_composite.h\"\n\nstatic mem_allocator_lock_t s_lock;\n\nstatic mem_allocator_pool_t pool;\nstatic mem_allocator_composite_t composite;\n\nbool_t tk_mem_is_valid_addr(void* addr) {\n  return mem_allocator_composite_is_valid_addr(MEM_ALLOCATOR(&composite), addr);\n}\n\nret_t tk_mem_init_ex(void* buffer, uint32_t size, ...) {\n  va_list va;\n  va_start(va, size);\n  s_allocator = mem_allocator_composite_init_va(&composite, buffer, size, va);\n  va_end(va);\n\n  return_value_if_fail(s_allocator != NULL, RET_BAD_PARAMS);\n\n  if (size > 32 * 1024) {\n    if (size < 100 * 1024) {\n      s_allocator = mem_allocator_pool_init(&pool, s_allocator, 100, 100, 80, 80, 32);\n    } else if (size < 1000 * 1024) {\n      s_allocator = mem_allocator_pool_init(&pool, s_allocator, 500, 500, 500, 200, 200);\n    } else {\n      s_allocator = mem_allocator_pool_init(&pool, s_allocator, 1000, 1000, 1000, 500, 500);\n    }\n  }\n#ifdef ENABLE_MEM_LEAK_CHECK\n  s_allocator = mem_allocator_debug_init(&s_debug, s_allocator);\n#endif /*ENABLE_MEM_LEAK_CHECK*/\n\n  return s_allocator != NULL ? RET_OK : RET_FAIL;\n}\n\nret_t tk_mem_init(void* buffer, uint32_t size) {\n  return tk_mem_init_ex(buffer, size, NULL, 0);\n}\n\nret_t tk_mem_init_stage2(void) {\n  return_value_if_fail(s_allocator != NULL, RET_FAIL);\n  s_allocator = mem_allocator_lock_init(&s_lock, s_allocator);\n  s_allocator = mem_allocator_oom_init(&s_oom, s_allocator);\n\n  return RET_OK;\n}\n\nstatic mem_allocator_t* mem_allocator_get(void) {\n  return s_allocator;\n}\n\n#if (!defined(WITH_SDL) && !defined(LINUX))\n#define EXPORT_STD_MALLOC 1\n#endif\n\n#if defined(EXPORT_STD_MALLOC)\n/*export std malloc*/\nvoid* calloc(size_t count, size_t size) {\n  return tk_calloc(count, size, __FUNCTION__, __LINE__);\n}\n\nvoid free(void* ptr) {\n  tk_free(ptr);\n}\n\nvoid* malloc(size_t size) {\n  return tk_alloc(size, __FUNCTION__, __LINE__);\n}\n\nvoid* realloc(void* ptr, size_t size) {\n  return tk_realloc(ptr, size, __FUNCTION__, __LINE__);\n}\n#endif /*WITH_SDL*/\n\n#endif /*HAS_STD_MALLOC*/\n\nvoid* tk_calloc(uint32_t nmemb, uint32_t size, const char* func, uint32_t line) {\n  void* addr = NULL;\n  uint32_t total_size = size * nmemb;\n  mem_allocator_t* allocator = mem_allocator_get();\n  return_value_if_fail(allocator != NULL, NULL);\n\naddr = ",
    "raw_res": "mem_allocator_calloc(allocator, total_size, func, line);",
    "prompt_res": "mem_allocator_alloc(allocator, total_size, func, line);",
    "gt": "mem_allocator_alloc(allocator, total_size, func, line);"
  },
  {
    "id": 976,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/typed_array.c",
    "input": "﻿/**\n * File:   typed_array.c\n * Author: AWTK Develop Team\n * Brief:  dynamic typed_array.\n *\n * Copyright (c) 2021 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2021-01-03 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/value.h\"\n#include \"tkc/typed_array.h\"\n\nstatic bool_t typed_array_is_type_supported(value_type_t type) {\n  switch (type) {\n    case VALUE_TYPE_BOOL:\n    case VALUE_TYPE_INT8:\n    case VALUE_TYPE_UINT8:\n    case VALUE_TYPE_INT16:\n    case VALUE_TYPE_UINT16:\n    case VALUE_TYPE_INT32:\n    case VALUE_TYPE_UINT32:\n    case VALUE_TYPE_INT64:\n    case VALUE_TYPE_UINT64:\n    case VALUE_TYPE_FLOAT:\n    case VALUE_TYPE_FLOAT32:\n    case VALUE_TYPE_DOUBLE: {\n      return TRUE;\n    }\n    default: {\n      return FALSE;\n    }\n  }\n}\n\ntyped_array_t* typed_array_create(value_type_t type, uint32_t capacity) {\n  typed_array_t* typed_array = NULL;\n  uint32_t element_size = value_type_size(type);\n  return_value_if_fail(typed_array_is_type_supported(type), NULL);\n  typed_array = TKMEM_ZALLOC(typed_array_t);\n  return_value_if_fail(typed_array != NULL, NULL);\n\n  typed_array->type = type;\n  typed_array->element_size = element_size;\n  if (capacity > 0) {\n    if (typed_array_extend(typed_array, capacity) != RET_OK) {\n      TKMEM_FREE(typed_array);\n      return NULL;\n    }\n  }\n\n  return typed_array;\n}\n\nret_t typed_array_get(typed_array_t* typed_array, uint32_t index, value_t* v) {\n  uint8_t* p = NULL;\n  return_value_if_fail(typed_array != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(typed_array->data != NULL && index < typed_array->size, RET_BAD_PARAMS);\n  p = typed_array->data + index * typed_array->element_size;\n\n  switch (typed_array->type) {\n    case VALUE_TYPE_BOOL: {\n      value_set_bool(v, *(bool_t*)p);\n      return RET_OK;\n    }\n    case VALUE_TYPE_INT8: {\n      value_set_int8(v, *(int8_t*)p);\n      return RET_OK;\n    }\n    case VALUE_TYPE_UINT8: {\n      value_set_uint8(v, *(uint8_t*)p);\n      return RET_OK;\n    }\n    case VALUE_TYPE_INT16: {\n      value_set_int16(v, *(int16_t*)p);\n      return RET_OK;\n    }\n    case VALUE_TYPE_UINT16: {\n      value_set_uint16(v, *(uint16_t*)p);\n      return RET_OK;\n    }\n    case VALUE_TYPE_INT32: {\n      value_set_int32(v, *(int32_t*)p);\n      return RET_OK;\n    }\n    case VALUE_TYPE_UINT32: {\n      value_set_uint32(v, *(uint32_t*)p);\n      return RET_OK;\n    }\n    case VALUE_TYPE_INT64: {\n      value_set_int64(v, *(int64_t*)p);\n      return RET_OK;\n    }\n    case VALUE_TYPE_UINT64: {\n      value_set_uint64(v, *(uint64_t*)p);\n      return RET_OK;\n    }\n    case VALUE_TYPE_FLOAT: {\n      value_set_float(v, *(float_t*)p);\n      return RET_OK;\n    }\n    case VALUE_TYPE_FLOAT32: {\n      value_set_float32(v, *(float*)p);\n      return RET_OK;\n    }\n    case VALUE_TYPE_DOUBLE: {\n      value_set_double(v, *(double*)p);\n      return RET_OK;\n    }\n    default: {\n      assert(!\"not supported type\");\n      return RET_NOT_IMPL;\n    }\n  }\n}\n\nret_t typed_array_set(typed_array_t* typed_array, uint32_t index, const value_t* v) {\n  uint8_t* p = NULL;\n  return_value_if_fail(typed_array != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(typed_array->data != NULL && index < typed_array->size, RET_BAD_PARAMS);\n  p = typed_array->data + index * typed_array->element_size;\n\n  switch (typed_array->type) {\n    case VALUE_TYPE_BOOL: {\n*(bool_t*)p = ",
    "raw_res": "value_get_bool(v);",
    "prompt_res": "value_bool(v);",
    "gt": "value_bool(v);"
  },
  {
    "id": 1016,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/tkc/value.c",
    "input": "﻿/**\n * File:   value.h\n * Author: AWTK Develop Team\n * Brief:  generic value type\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-27 Li XianJing <xianjimli@hotmail.com> adapt from uclib\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/value.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/object.h\"\n\nbool_t value_bool(const value_t* v) {\n  return_value_if_fail(v->type != VALUE_TYPE_INVALID, 0);\n\n  switch (v->type) {\n    case VALUE_TYPE_BOOL: {\n      return v->value.b;\n    }\n    case VALUE_TYPE_STRING: {\n      return tk_atob(v->value.str);\n    }\n    case VALUE_TYPE_WSTRING: {\n      return tk_watob(v->value.wstr);\n    }\n    default: {\n      return value_int(v) ? TRUE : FALSE;\n    }\n  }\n}\n\nvalue_t* value_init(value_t* v, uint32_t type) {\n  v->type = type;\n  v->free_handle = FALSE;\n\n  return v;\n}\n\nvalue_t* value_set_bool(value_t* v, bool_t value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.b = value;\n  return value_init(v, VALUE_TYPE_BOOL);\n}\n\nvalue_t* value_set_int8(value_t* v, int8_t value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.i8 = value;\n  return value_init(v, VALUE_TYPE_INT8);\n}\n\nint8_t value_int8(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n\n  if (v->type == VALUE_TYPE_INT8) {\n    return v->value.i8;\n  } else {\n    return (int8_t)value_int(v);\n  }\n}\n\nvalue_t* value_set_uint8(value_t* v, uint8_t value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.u8 = value;\n\n  return value_init(v, VALUE_TYPE_UINT8);\n}\n\nuint8_t value_uint8(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n\n  if (v->type == VALUE_TYPE_UINT8) {\n    return v->value.u8;\n  } else {\n    return (uint8_t)value_int(v);\n  }\n}\n\nvalue_t* value_set_int16(value_t* v, int16_t value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.i16 = value;\n\n  return value_init(v, VALUE_TYPE_INT16);\n}\n\nint16_t value_int16(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n\n  if (v->type == VALUE_TYPE_INT16) {\n    return v->value.i16;\n  } else {\n    return (int16_t)value_int(v);\n  }\n}\n\nvalue_t* value_set_uint16(value_t* v, uint16_t value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.u16 = value;\n\n  return value_init(v, VALUE_TYPE_UINT16);\n}\n\nuint16_t value_uint16(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n\n  if (v->type == VALUE_TYPE_UINT16) {\n    return v->value.u16;\n  } else {\n    return (uint16_t)value_int(v);\n  }\n}\n\nvalue_t* value_set_int32(value_t* v, int32_t value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.i32 = value;\n  return value_init(v, VALUE_TYPE_INT32);\n}\n\nint32_t value_int32(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n\n  if (v->type == VALUE_TYPE_INT32) {\n    return v->value.i32;\n  } else {\n    return (int32_t)value_int(v);\n  }\n}\n\nvalue_t* value_set_uint32(value_t* v, uint32_t value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.u32 = value;\n  return value_init(v, VALUE_TYPE_UINT32);\n}\n\nuint32_t value_uint32(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n\n  if (v->type == VALUE_TYPE_UINT32) {\n    return v->value.u32;\n  } else {\n    return (uint32_t)value_int(v);\n  }\n}\n\nvalue_t* value_set_int64(value_t* v, int64_t value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.i64 = value;\n  return value_init(v, VALUE_TYPE_INT64);\n}\n\nint64_t value_int64(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n\n  if (v->type == VALUE_TYPE_INT64) {\n    return v->value.i64;\n  } else if (v->type == VALUE_TYPE_UINT64) {\n    return v->value.u64;\n  } else if (v->type == VALUE_TYPE_STRING) {\n    return tk_atol(v->value.str);\n  } else {\n    return (int64_t)value_int(v);\n  }\n}\n\nvalue_t* value_set_uint64(value_t* v, uint64_t value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.u64 = value;\n\n  return value_init(v, VALUE_TYPE_UINT64);\n}\n\nuint64_t value_uint64(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n\n  if (v->type == VALUE_TYPE_UINT64) {\n    return v->value.u64;\n  } else if (v->type == VALUE_TYPE_INT64) {\n    return v->value.i64;\n  } else if (v->type == VALUE_TYPE_STRING) {\n    return tk_atoul(v->value.str);\n  } else {\n    return (uint64_t)value_int(v);\n  }\n}\n\nvalue_t* value_set_pointer(value_t* v, void* value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.ptr = value;\n  return value_init(v, VALUE_TYPE_POINTER);\n}\n\nvoid* value_pointer(const value_t* v) {\n  return_value_if_fail(v != NULL, NULL);\n  switch (v->type) {\n    case VALUE_TYPE_STRING: {\n      return (void*)(v->value.str);\n    }\n    case VALUE_TYPE_WSTRING: {\n      return (void*)(v->value.wstr);\n    }\n    case VALUE_TYPE_OBJECT: {\n      return (v->value.object);\n    }\n    case VALUE_TYPE_POINTER: {\n      return (v->value.ptr);\n    }\n    default:\n      break;\n  }\n\n  return NULL;\n}\n\nvalue_t* value_set_float(value_t* v, float_t value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.f = value;\n\n  return value_init(v, VALUE_TYPE_FLOAT);\n}\n\nfloat_t value_float(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n  return_value_if_fail(v->type != VALUE_TYPE_INVALID, 0);\n\n  switch (v->type) {\n    case VALUE_TYPE_BOOL: {\n      return (float_t)v->value.b;\n    }\n    case VALUE_TYPE_INT8: {\n      return (float_t)v->value.i8;\n    }\n    case VALUE_TYPE_UINT8: {\n      return (float_t)v->value.u8;\n    }\n    case VALUE_TYPE_INT16: {\n      return (float_t)v->value.i16;\n    }\n    case VALUE_TYPE_UINT16: {\n      return (float_t)v->value.u16;\n    }\n    case VALUE_TYPE_INT32: {\n      return (float_t)v->value.i32;\n    }\n    case VALUE_TYPE_UINT32: {\n      return (float_t)v->value.u32;\n    }\n    case VALUE_TYPE_INT64: {\n      return (float_t)v->value.i64;\n    }\n    case VALUE_TYPE_UINT64: {\n      return (float_t)v->value.u64;\n    }\n    case VALUE_TYPE_FLOAT: {\n      return (float_t)v->value.f;\n    }\n    case VALUE_TYPE_FLOAT32: {\n      return (float_t)v->value.f32;\n    }\n    case VALUE_TYPE_DOUBLE: {\n      return (float_t)v->value.f64;\n    }\n    case VALUE_TYPE_STRING: {\n      return (float_t)tk_atof(v->value.str);\n    }\n    case VALUE_TYPE_WSTRING: {\n      return (float_t)tk_watof(v->value.wstr);\n    }\n    default:\n      break;\n  }\n\n  return 0;\n}\n\nvalue_t* value_set_float32(value_t* v, float value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.f32 = value;\n\n  return value_init(v, VALUE_TYPE_FLOAT32);\n}\n\nfloat value_float32(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n\n  if (v->type == VALUE_TYPE_FLOAT32) {\n    return v->value.f32;\n  } else {\n    return (float)value_float(v);\n  }\n}\n\nvalue_t* value_set_double(value_t* v, double value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.f64 = value;\n\n  return value_init(v, VALUE_TYPE_DOUBLE);\n}\n\ndouble value_double(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n\n  return_value_if_fail(v->type != VALUE_TYPE_INVALID, 0);\n\n  switch (v->type) {\n    case VALUE_TYPE_INT8: {\n      return (double)v->value.i8;\n    }\n    case VALUE_TYPE_UINT8: {\n      return (double)v->value.u8;\n    }\n    case VALUE_TYPE_INT16: {\n      return (double)v->value.i16;\n    }\n    case VALUE_TYPE_UINT16: {\n      return (double)v->value.u16;\n    }\n    case VALUE_TYPE_INT32: {\n      return (double)v->value.i32;\n    }\n    case VALUE_TYPE_UINT32: {\n      return (double)v->value.u32;\n    }\n    case VALUE_TYPE_INT64: {\n      return (double)v->value.i64;\n    }\n    case VALUE_TYPE_UINT64: {\n      return (double)v->value.u64;\n    }\n    case VALUE_TYPE_FLOAT: {\n      return (double)v->value.f;\n    }\n    case VALUE_TYPE_FLOAT32: {\n      return (double)v->value.f32;\n    }\n    case VALUE_TYPE_DOUBLE: {\n      return v->value.f64;\n    }\n    case VALUE_TYPE_STRING: {\n      return (double)tk_atof(v->value.str);\n    }\n    case VALUE_TYPE_WSTRING: {\n      return (double)tk_watof(v->value.wstr);\n    }\n    case VALUE_TYPE_BOOL: {\n      return value_bool(v) ? 1 : 0;\n    }\n    default:\n      break;\n  }\n\n  return 0;\n}\n\nvalue_t* value_set_str(value_t* v, const char* value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.str = value;\n  return value_init(v, VALUE_TYPE_STRING);\n}\n\nvalue_t* value_dup_str(value_t* v, const char* value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  value_init(v, VALUE_TYPE_STRING);\n  v->value.str = tk_strdup(value);\n  v->free_handle = TRUE;\n\n  return v;\n}\n\nvalue_t* value_dup_str_with_len(value_t* v, const char* value, uint32_t len) {\n  return_value_if_fail(v != NULL, NULL);\n\n  value_init(v, VALUE_TYPE_STRING);\n  v->value.str = tk_strndup(value, len);\n  v->free_handle = TRUE;\n\n  return v;\n}\n\nvalue_t* value_set_wstr(value_t* v, const wchar_t* value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.wstr = value;\n  return value_init(v, VALUE_TYPE_WSTRING);\n}\n\nconst char* value_str(const value_t* v) {\n  return_value_if_fail(v != NULL, NULL);\n  return_value_if_fail(v->type == VALUE_TYPE_STRING, NULL);\n\n  return v->value.str;\n}\n\nconst wchar_t* value_wstr(const value_t* v) {\n  return_value_if_fail(v != NULL, NULL);\n  return_value_if_fail(v->type == VALUE_TYPE_WSTRING, NULL);\n\n  return v->value.wstr;\n}\n\nret_t value_copy(value_t* dst, const value_t* src) {\n  return_value_if_fail(dst != NULL && src != NULL, RET_BAD_PARAMS);\n\n  if (dst == src) {\n    return RET_OK;\n  }\n\n  memcpy(dst, src, sizeof(value_t));\n  dst->free_handle = FALSE;\n\n  return RET_OK;\n}\n\nret_t value_deep_copy(value_t* dst, const value_t* src) {\n  return_value_if_fail(dst != NULL && src != NULL, RET_BAD_PARAMS);\n\n  value_copy(dst, src);\n\n  switch (dst->type) {\n    case VALUE_TYPE_STRING: {\n      dst->value.str = src->value.str != NULL ? tk_strdup(src->value.str) : NULL;\n      dst->free_handle = dst->value.str != NULL;\n      break;\n    }\n    case VALUE_TYPE_BINARY:\n    case VALUE_TYPE_GRADIENT:\n    case VALUE_TYPE_UBJSON: {\n      if (src->value.binary_data.data != NULL) {\n        uint32_t size = src->value.binary_data.size;\n        void* data = tk_memdup(src->value.binary_data.data, size);\n        return_value_if_fail(data != NULL, RET_OOM);\n\n        dst->free_handle = TRUE;\n        dst->value.binary_data.data = data;\n        dst->value.binary_data.size = size;\n      } else {\n        dst->free_handle = FALSE;\n      }\n      break;\n    }\n    case VALUE_TYPE_WSTRING: {\n      dst->value.wstr = tk_wstrdup(src->value.wstr);\n      dst->free_handle = dst->value.wstr != NULL;\n      break;\n    }\n    case VALUE_TYPE_OBJECT: {\n      tk_object_ref(dst->value.object);\n      dst->free_handle = dst->value.object != NULL;\n      break;\n    }\n    default:\n      break;\n  }\n\n  return RET_OK;\n}\n\nbool_t value_is_null(value_t* v) {\n  return v == NULL || v->type == VALUE_TYPE_INVALID;\n}\n\nint value_int(const value_t* v) {\n  return_value_if_fail(v->type != VALUE_TYPE_INVALID, 0);\n\n  switch (v->type) {\n    case VALUE_TYPE_INT8: {\n      return (int)v->value.i8;\n    }\n    case VALUE_TYPE_UINT8: {\n      return (int)v->value.u8;\n    }\n    case VALUE_TYPE_INT16: {\n      return (int)v->value.i16;\n    }\n    case VALUE_TYPE_UINT16: {\n      return (int)v->value.u16;\n    }\n    case VALUE_TYPE_INT32: {\n      return (int)v->value.i32;\n    }\n    case VALUE_TYPE_UINT32: {\n      return (int)v->value.u32;\n    }\n    case VALUE_TYPE_INT64: {\n      return (int)v->value.i64;\n    }\n    case VALUE_TYPE_UINT64: {\n      return (int)v->value.u64;\n    }\n    case VALUE_TYPE_FLOAT: {\n      return (int)v->value.f;\n    }\n    case VALUE_TYPE_FLOAT32: {\n      return (int)v->value.f32;\n    }\n    case VALUE_TYPE_DOUBLE: {\n      return (int)v->value.f64;\n    }\n    case VALUE_TYPE_BOOL: {\n      return (int)v->value.b;\n    }\n    case VALUE_TYPE_STRING: {\n      return tk_atoi(v->value.str);\n    }\n    case VALUE_TYPE_WSTRING: {\n      return tk_watoi(v->value.wstr);\n    }\n    default: {\n      assert(!\"not supported type\");\n    }\n  }\n\n  return 0;\n}\n\nbool_t value_equal(const value_t* v, const value_t* other) {\n  return_value_if_fail(v != NULL && other != NULL, FALSE);\n  if (v->type != other->type) {\n    return FALSE;\n  }\n\n  switch (v->type) {\n    case VALUE_TYPE_INT8: {\n      return v->value.i8 == other->value.i8;\n    }\n    case VALUE_TYPE_UINT8: {\n      return v->value.u8 == other->value.u8;\n    }\n    case VALUE_TYPE_INT16: {\n      return v->value.i16 == other->value.i16;\n    }\n    case VALUE_TYPE_UINT16: {\n      return v->value.u16 == other->value.u16;\n    }\n    case VALUE_TYPE_INT32: {\n      return v->value.i32 == other->value.i32;\n    }\n    case VALUE_TYPE_UINT32: {\n      return v->value.u32 == other->value.u32;\n    }\n    case VALUE_TYPE_INT64: {\n      return v->value.i64 == other->value.i64;\n    }\n    case VALUE_TYPE_BOOL: {\n      return v->value.b == other->value.b;\n    }\n    case VALUE_TYPE_POINTER: {\n      return v->value.ptr == other->value.ptr;\n    }\n    case VALUE_TYPE_UINT64: {\n      return v->value.u64 == other->value.u64;\n    }\n    case VALUE_TYPE_FLOAT: {\n      return tk_fequal(v->value.f, other->value.f32);\n    }\n    case VALUE_TYPE_FLOAT32: {\n      return tk_fequal(v->value.f32, other->value.f32);\n    }\n    case VALUE_TYPE_DOUBLE: {\n      return tk_lfequal(v->value.f64, other->value.f64);\n    }\n    case VALUE_TYPE_STRING: {\n      return (v->value.str == other->value.str) || tk_str_eq(v->value.str, other->value.str);\n    }\n    case VALUE_TYPE_WSTRING: {\n      return (v->value.wstr == other->value.wstr) || tk_wstr_eq(v->value.wstr, other->value.wstr);\n    }\n    case VALUE_TYPE_BINARY:\n    case VALUE_TYPE_GRADIENT:\n    case VALUE_TYPE_UBJSON: {\n      return (v->value.binary_data.data == other->value.binary_data.data);\n    }\n    case VALUE_TYPE_OBJECT: {\n      return tk_object_compare(v->value.object, other->value.object) == 0;\n    }\n    default:\n      break;\n  }\n\n  return FALSE;\n}\n\nvalue_t* value_set_int(value_t* v, int32_t value) {\n  return value_set_int32(v, value);\n}\n\nvalue_t* value_create() {\n  return TKMEM_ZALLOC(value_t);\n}\n\nret_t value_reset(value_t* v) {\n  return_value_if_fail(v != NULL, RET_BAD_PARAMS);\n\n  if (v->free_handle) {\n    switch (v->type) {\n      case VALUE_TYPE_SIZED_STRING: {\n        TKMEM_FREE(v->value.sized_str.str);\n        break;\n      }\n      case VALUE_TYPE_BINARY:\n      case VALUE_TYPE_UBJSON:\n      case VALUE_TYPE_GRADIENT: {\n        TKMEM_FREE(v->value.binary_data.data);\n        break;\n      }\n      case VALUE_TYPE_STRING: {\n        TKMEM_FREE(v->value.str);\n        break;\n      }\n      case VALUE_TYPE_WSTRING: {\n        TKMEM_FREE(v->value.wstr);\n        break;\n      }\n      case VALUE_TYPE_OBJECT: {\n        tk_object_t* obj = v->value.object;\n        v->value.object = NULL;\n        TK_OBJECT_UNREF(obj);\n        break;\n      }\n      case VALUE_TYPE_ID: {\n        TKMEM_FREE(v->value.id.id);\n        break;\n      }\n      case VALUE_TYPE_FUNC: {\n        TKMEM_FREE(v->value.func.func);\n        break;\n      }\n      default:\n        break;\n    }\n  }\n\n  memset(v, 0x00, sizeof(value_t));\n\n  return RET_OK;\n}\n\nret_t value_destroy(value_t* v) {\n  return_value_if_fail(v != NULL, RET_BAD_PARAMS);\n\n  value_reset(v);\n  TKMEM_FREE(v);\n\n  return RET_OK;\n}\n\nvalue_t* value_set_object(value_t* v, tk_object_t* value) {\n  return_value_if_fail(v != NULL && value != NULL, NULL);\n\n  v->value.object = value;\n  return value_init(v, VALUE_TYPE_OBJECT);\n}\n\ntk_object_t* value_object(const value_t* v) {\n  return_value_if_fail(v != NULL && v->type == VALUE_TYPE_OBJECT, NULL);\n\n  return v->value.object;\n}\n\nvalue_t* value_cast(value_t* value) {\n  return_value_if_fail(value != NULL, NULL);\n\n  return value;\n}\n\nvalue_t* value_set_token(value_t* v, uint32_t value) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.token = value;\n\n  return value_init(v, VALUE_TYPE_TOKEN);\n}\n\nuint32_t value_token(const value_t* v) {\n  return_value_if_fail(v != NULL, 0);\n  return_value_if_fail(v->type == VALUE_TYPE_TOKEN, 0);\n\n  return v->value.token;\n}\n\nvalue_t* value_set_sized_str(value_t* v, char* str, uint32_t size) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.sized_str.str = str;\n  v->value.sized_str.size = size;\n\n  return value_init(v, VALUE_TYPE_SIZED_STRING);\n}\n\nsized_str_t* value_sized_str(const value_t* v) {\n  return_value_if_fail(v != NULL, NULL);\n  return_value_if_fail(v->type == VALUE_TYPE_SIZED_STRING, NULL);\n\n  return (sized_str_t*)&(v->value.sized_str);\n}\n\nvalue_t* value_set_binary_data(value_t* v, void* data, uint32_t size) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.binary_data.data = data;\n  v->value.binary_data.size = size;\n\n  return value_init(v, VALUE_TYPE_BINARY);\n}\n\nvalue_t* value_dup_binary_data(value_t* v, const void* data, uint32_t size) {\n  void* new_data = NULL;\n  return_value_if_fail(v != NULL && data != NULL, NULL);\n\n  new_data = TKMEM_ALLOC(size);\n  return_value_if_fail(new_data != NULL, NULL);\n  memcpy(new_data, data, size);\n\n  value_init(v, VALUE_TYPE_BINARY);\n  v->value.binary_data.data = new_data;\n  v->value.binary_data.size = size;\n  v->free_handle = TRUE;\n\n  return v;\n}\n\nbinary_data_t* value_binary_data(const value_t* v) {\n  return_value_if_fail(v != NULL, NULL);\n  return_value_if_fail(v->type == VALUE_TYPE_BINARY || v->type == VALUE_TYPE_GRADIENT ||\n                           v->type == VALUE_TYPE_UBJSON,\n                       NULL);\n\n  return (binary_data_t*)&(v->value.binary_data);\n}\n\nvalue_t* value_set_ubjson(value_t* v, void* data, uint32_t size) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.binary_data.data = data;\n  v->value.binary_data.size = size;\n\n  return value_init(v, VALUE_TYPE_UBJSON);\n}\n\nbinary_data_t* value_ubjson(const value_t* v) {\n  return_value_if_fail(v != NULL, NULL);\n  return_value_if_fail(v->type == VALUE_TYPE_UBJSON, NULL);\n\n  return (binary_data_t*)&(v->value.binary_data);\n}\n\nvalue_t* value_set_gradient(value_t* v, void* data, uint32_t size) {\n  return_value_if_fail(v != NULL, NULL);\n\n  v->value.binary_data.data = data;\n  v->value.binary_data.size = size;\n\n  return value_init(v, VALUE_TYPE_GRADIENT);\n}\n\nbinary_data_t* value_gradient(const value_t* v) {\n  return_value_if_fail(v != NULL, NULL);\n  return_value_if_fail(v->type == VALUE_TYPE_GRADIENT, NULL);\n\n  return (binary_data_t*)&(v->value.binary_data);\n}\n\nconst char* value_str_ex(const value_t* v, char* buff, uint32_t size) {\n  return_value_if_fail(v != NULL && buff != NULL && size > 0, NULL);\n\n  if (v->type == VALUE_TYPE_STRING) {\n    return value_str(v);\n  } else if (v->type == VALUE_TYPE_DOUBLE || v->type == VALUE_TYPE_FLOAT32 ||\n             v->type == VALUE_TYPE_FLOAT) {\n    tk_snprintf(buff, size, \"%lf\", value_double(v));\n  } else if (v->type == VALUE_TYPE_WSTRING) {\n    tk_utf8_from_utf16(value_wstr(v), buff, size);\n  } else if (v->type == VALUE_TYPE_BOOL) {\n    tk_snprintf(buff, size, \"%s\", value_bool(v) ? \"true\" : \"false\");\n  } else if (v->type == VALUE_TYPE_UINT8 || v->type == VALUE_TYPE_UINT16 ||\n             v->type == VALUE_TYPE_UINT32) {\n    tk_snprintf(buff, size, \"%u\", value_uint32(v));\n  } else if (v->type == VALUE_TYPE_UINT64) {\n    tk_snprintf(buff, size, \"%\" PRIu64, value_uint64(v));\n  } else if (v->type == VALUE_TYPE_INT64) {\n    tk_snprintf(buff, size, \"%\" PRId64, value_int64(v));\n  } else if (v->type == VALUE_TYPE_ID) {\n    assert(v->value.id.id != NULL);\n    return v->value.id.id;\n  } else if (v->type == VALUE_TYPE_BINARY) {\n    binary_data_t* bin = value_binary_data(v);\n    if (bin != NULL) {\n      tk_snprintf(buff, size, \"binary(%p:%u)\", bin->data, bin->size);\n    } else {\n      tk_snprintf(buff, size, \"(null)\");\n    }\n  } else if (v->type == VALUE_TYPE_FUNC) {\n    return \"func\";\n  } else if (v->type == VALUE_TYPE_FUNC_DEF) {\n    return \"func_def\";\n  } else if (v->type == VALUE_TYPE_POINTER) {\n    tk_snprintf(buff, size, \"%p\", value_pointer(v));\n  } else if (v->type == VALUE_TYPE_OBJECT) {\ntk_object_t* obj = ",
    "raw_res": "0;",
    "prompt_res": "value_object(v);",
    "gt": "value_object(v);"
  },
  {
    "id": 1041,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/streams/mem/iostream_mem.c",
    "input": "﻿/**\n * File:   iostream_mem.c\n * Author: AWTK Develop Team\n * Brief:  iostream base on mem\n *\n * Copyright (c) 2019 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-09-18 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"streams/mem/istream_mem.h\"\n#include \"streams/mem/ostream_mem.h\"\n#include \"streams/mem/iostream_mem.h\"\n\nstatic ret_t tk_iostream_mem_on_destroy(tk_object_t* obj) {\n  tk_iostream_mem_t* iostream_mem = TK_IOSTREAM_MEM(obj);\n\n  tk_object_unref(TK_OBJECT(iostream_mem->istream));\n  tk_object_unref(TK_OBJECT(iostream_mem->ostream));\n\n  return RET_OK;\n}\n\nstatic const object_vtable_t s_tk_iostream_mem_vtable = {.type = \"tk_iostream_mem\",\n                                                         .desc = \"tk_iostream_mem\",\n                                                         .size = sizeof(tk_iostream_mem_t),\n                                                         .on_destroy = tk_iostream_mem_on_destroy};\n\nstatic tk_istream_t* tk_iostream_mem_get_istream(tk_iostream_t* stream) {\n  tk_iostream_mem_t* iostream_mem = TK_IOSTREAM_MEM(stream);\n\n  return iostream_mem->istream;\n}\n\nstatic tk_ostream_t* tk_iostream_mem_get_ostream(tk_iostream_t* stream) {\n  tk_iostream_mem_t* iostream_mem = TK_IOSTREAM_MEM(stream);\n\n  return iostream_mem->ostream;\n}\n\ntk_iostream_t* tk_iostream_mem_create(void* buff_in, uint32_t size_in, void* buff_out,\n                                      uint32_t size_out, bool_t own_buff) {\n  tk_object_t* obj = NULL;\n  tk_iostream_mem_t* iostream_mem = NULL;\n  return_value_if_fail(buff_in != NULL && size_in > 0, NULL);\n  return_value_if_fail(buff_out != NULL && size_out > 0, NULL);\n\n  obj = tk_object_create(&s_tk_iostream_mem_vtable);\n  iostream_mem = TK_IOSTREAM_MEM(obj);\n  if (iostream_mem == NULL) {\n    return_value_if_fail(iostream_mem != NULL, NULL);\n  }\n\n  iostream_mem->istream = tk_istream_mem_create(buff_in, size_in, 0, own_buff);\niostream_mem->ostream = ",
    "raw_res": "0;",
    "prompt_res": "tk_ostream_mem_create(buff_out, size_out, 0, own_buff);",
    "gt": "tk_ostream_mem_create(buff_out, size_out, 0, own_buff);"
  },
  {
    "id": 1110,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/streams/tools/tcp_send.c",
    "input": "﻿#include \"tkc/platform.h\"\n#include \"streams/inet/iostream_tcp.h\"\n\nint main(int argc, char* argv[]) {\n  int32_t ret = 0;\n  int32_t sock = 0;\n  tk_iostream_t* io = NULL;\n  const char* request = \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\";\n\n  tk_socket_init();\n  platform_prepare();\n  sock = tk_tcp_connect(\"localhost\", 8080);\n  return_value_if_fail(sock > 0, 0);\n\nio = ",
    "raw_res": "0;",
    "prompt_res": "tk_iostream_tcp_create(sock);",
    "gt": "tk_iostream_tcp_create(sock);"
  },
  {
    "id": 1146,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/streams/tools/tcp_recv.c",
    "input": "﻿#include \"tkc/platform.h\"\n#include \"streams/inet/iostream_tcp.h\"\n\nint main(int argc, char* argv[]) {\n  int32_t ret = 0;\n  int32_t lsock = 0;\n  tk_iostream_t* io = NULL;\n  const char* response = \"200 OK\\n\";\n\n  tk_socket_init();\n  platform_prepare();\n  lsock = tk_tcp_listen(8080);\n  return_value_if_fail(lsock > 0, 0);\n\n  log_debug(\"listen at 8080...\\n\");\n  while (1) {\n    int32_t sock = 0;\n    sock = tk_tcp_accept(lsock);\n    if (sock < 0) {\n      break;\n    }\n    log_debug(\"%d client come in...\\n\", sock);\nio = ",
    "raw_res": "io = tk_iostream_new(sock);",
    "prompt_res": "tk_iostream_tcp_create(sock);",
    "gt": "tk_iostream_tcp_create(sock);"
  },
  {
    "id": 1152,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/streams/tools/https_client.c",
    "input": "﻿#include \"tkc/platform.h\"\n#include \"streams/inet/iostream_mbedtls.h\"\n#include \"streams/inet/mbedtls_client.h\"\n\nint main(int argc, char* argv[]) {\n  int32_t ret = 0;\n  mbedtls_conn_t* conn = NULL;\n  const char* request = \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\";\n\n  platform_prepare();\n  conn = mbedtls_conn_client_create(\"localhost\", \"4433\", (const uint8_t*)mbedtls_test_cas_pem,\n                                    mbedtls_test_cas_pem_len);\n\n  if (conn != NULL) {\n    char buff[1024] = {0};\n    tk_iostream_t* io = tk_iostream_mbedtls_create(conn);\ntk_istream_t* in = ",
    "raw_res": "tk_istream_create(io);",
    "prompt_res": "tk_iostream_get_istream(io);",
    "gt": "tk_iostream_get_istream(io);"
  },
  {
    "id": 1191,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/image_loader/image_loader_stb.c",
    "input": "﻿/**\n * File:   image_loader.h\n * Author: AWTK Develop Team\n * Brief:  stb image loader\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-21 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#define STB_IMAGE_IMPLEMENTATION\n#define STBI_FREE TKMEM_FREE\n#define STBI_MALLOC TKMEM_ALLOC\n#define STBI_REALLOC(p, s) TKMEM_REALLOC(p, s)\n\n#include \"tkc/mem.h\"\n#include \"base/bitmap.h\"\n#include \"stb/stb_image.h\"\n#include \"base/system_info.h\"\n#include \"image_loader/image_loader_stb.h\"\n\nstatic uint8_t* convert_2_to_4(uint8_t* src, uint32_t w, uint32_t h) {\n  uint32_t i = 0;\n  uint8_t* s = src;\n  uint8_t* d = NULL;\n  uint8_t* data = NULL;\n  uint32_t size = w * h;\n  return_value_if_fail(src != NULL, NULL);\n\n  data = TKMEM_ALLOC(size * 4);\n  return_value_if_fail(data != NULL, NULL);\n\n  d = data;\n  for (i = 0; i < size; i++) {\n    d[0] = s[0];\n    d[1] = s[0];\n    d[2] = s[0];\n    d[3] = s[1];\n\n    d += 4;\n    s += 2;\n  }\n\n  return data;\n}\n\nret_t stb_load_image(int32_t subtype, const uint8_t* buff, uint32_t buff_size, bitmap_t* image,\n                     bool_t require_bgra, bool_t enable_bgr565, bool_t enable_rgb565,\n                     lcd_orientation_t o) {\n  int w = 0;\n  int h = 0;\n  int n = 0;\n  ret_t ret = RET_FAIL;\n\n  if (subtype != ASSET_TYPE_IMAGE_GIF) {\n    uint8_t* data = NULL;\n    int out_channel_order;\n    uint8_t* stb_data =\n        stbi_load_from_memory_ex(buff, buff_size, &w, &h, &n, &out_channel_order, 0);\n    return_value_if_fail(stb_data != NULL, RET_FAIL);\n\n    if (n == 2) {\n      n = 4;\n      data = convert_2_to_4(stb_data, w, h);\n    } else {\n      data = stb_data;\n    }\n#ifdef WITH_LCD_MONO\n    if (out_channel_order == STBI_ORDER_RGB) {\n      ret = bitmap_init_from_rgba(image, w, h, BITMAP_FMT_MONO, data, n, o);\n    } else {\n      ret = bitmap_init_from_bgra(image, w, h, BITMAP_FMT_MONO, data, n, o);\n    }\n#else\n    if (out_channel_order == STBI_ORDER_RGB) {\n      if (enable_bgr565 && rgba_data_is_opaque(data, w, h, n)) {\n        ret = bitmap_init_from_rgba(image, w, h, BITMAP_FMT_BGR565, data, n, o);\n      } else if (enable_rgb565 && rgba_data_is_opaque(data, w, h, n)) {\n        ret = bitmap_init_from_rgba(image, w, h, BITMAP_FMT_RGB565, data, n, o);\n      } else if (require_bgra) {\nret = ",
    "raw_res": "bitmap_init_from_bgra(image, w, h, BITMAP_FMT_RGBA8888, data, n, o);",
    "prompt_res": "bitmap_init_from_rgba(image, w, h, BITMAP_FMT_BGRA8888, data, n, o);",
    "gt": "bitmap_init_from_rgba(image, w, h, BITMAP_FMT_BGRA8888, data, n, o);"
  },
  {
    "id": 1193,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/image_loader/image_loader_stb.c",
    "input": "﻿/**\n * File:   image_loader.h\n * Author: AWTK Develop Team\n * Brief:  stb image loader\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-21 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#define STB_IMAGE_IMPLEMENTATION\n#define STBI_FREE TKMEM_FREE\n#define STBI_MALLOC TKMEM_ALLOC\n#define STBI_REALLOC(p, s) TKMEM_REALLOC(p, s)\n\n#include \"tkc/mem.h\"\n#include \"base/bitmap.h\"\n#include \"stb/stb_image.h\"\n#include \"base/system_info.h\"\n#include \"image_loader/image_loader_stb.h\"\n\nstatic uint8_t* convert_2_to_4(uint8_t* src, uint32_t w, uint32_t h) {\n  uint32_t i = 0;\n  uint8_t* s = src;\n  uint8_t* d = NULL;\n  uint8_t* data = NULL;\n  uint32_t size = w * h;\n  return_value_if_fail(src != NULL, NULL);\n\n  data = TKMEM_ALLOC(size * 4);\n  return_value_if_fail(data != NULL, NULL);\n\n  d = data;\n  for (i = 0; i < size; i++) {\n    d[0] = s[0];\n    d[1] = s[0];\n    d[2] = s[0];\n    d[3] = s[1];\n\n    d += 4;\n    s += 2;\n  }\n\n  return data;\n}\n\nret_t stb_load_image(int32_t subtype, const uint8_t* buff, uint32_t buff_size, bitmap_t* image,\n                     bool_t require_bgra, bool_t enable_bgr565, bool_t enable_rgb565,\n                     lcd_orientation_t o) {\n  int w = 0;\n  int h = 0;\n  int n = 0;\n  ret_t ret = RET_FAIL;\n\n  if (subtype != ASSET_TYPE_IMAGE_GIF) {\n    uint8_t* data = NULL;\n    int out_channel_order;\n    uint8_t* stb_data =\n        stbi_load_from_memory_ex(buff, buff_size, &w, &h, &n, &out_channel_order, 0);\n    return_value_if_fail(stb_data != NULL, RET_FAIL);\n\n    if (n == 2) {\n      n = 4;\n      data = convert_2_to_4(stb_data, w, h);\n    } else {\n      data = stb_data;\n    }\n#ifdef WITH_LCD_MONO\n    if (out_channel_order == STBI_ORDER_RGB) {\n      ret = bitmap_init_from_rgba(image, w, h, BITMAP_FMT_MONO, data, n, o);\n    } else {\n      ret = bitmap_init_from_bgra(image, w, h, BITMAP_FMT_MONO, data, n, o);\n    }\n#else\n    if (out_channel_order == STBI_ORDER_RGB) {\n      if (enable_bgr565 && rgba_data_is_opaque(data, w, h, n)) {\n        ret = bitmap_init_from_rgba(image, w, h, BITMAP_FMT_BGR565, data, n, o);\n      } else if (enable_rgb565 && rgba_data_is_opaque(data, w, h, n)) {\n        ret = bitmap_init_from_rgba(image, w, h, BITMAP_FMT_RGB565, data, n, o);\n      } else if (require_bgra) {\n        ret = bitmap_init_from_rgba(image, w, h, BITMAP_FMT_BGRA8888, data, n, o);\n      } else {\n        ret = bitmap_init_from_rgba(image, w, h, BITMAP_FMT_RGBA8888, data, n, o);\n      }\n    } else {\n      if (enable_bgr565 && rgba_data_is_opaque(data, w, h, n)) {\nret = ",
    "raw_res": "bitmap_init_from_rgba(image, w, h, BITMAP_FMT_BGR565, data, n, o);",
    "prompt_res": "bitmap_init_from_bgra(image, w, h, BITMAP_FMT_BGR565, data, n, o);",
    "gt": "bitmap_init_from_bgra(image, w, h, BITMAP_FMT_BGR565, data, n, o);"
  },
  {
    "id": 1202,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/image_loader/image_loader_stb.c",
    "input": "﻿/**\n * File:   image_loader.h\n * Author: AWTK Develop Team\n * Brief:  stb image loader\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-21 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#define STB_IMAGE_IMPLEMENTATION\n#define STBI_FREE TKMEM_FREE\n#define STBI_MALLOC TKMEM_ALLOC\n#define STBI_REALLOC(p, s) TKMEM_REALLOC(p, s)\n\n#include \"tkc/mem.h\"\n#include \"base/bitmap.h\"\n#include \"stb/stb_image.h\"\n#include \"base/system_info.h\"\n#include \"image_loader/image_loader_stb.h\"\n\nstatic uint8_t* convert_2_to_4(uint8_t* src, uint32_t w, uint32_t h) {\n  uint32_t i = 0;\n  uint8_t* s = src;\n  uint8_t* d = NULL;\n  uint8_t* data = NULL;\n  uint32_t size = w * h;\n  return_value_if_fail(src != NULL, NULL);\n\n  data = TKMEM_ALLOC(size * 4);\n  return_value_if_fail(data != NULL, NULL);\n\n  d = data;\n  for (i = 0; i < size; i++) {\n    d[0] = s[0];\n    d[1] = s[0];\n    d[2] = s[0];\n    d[3] = s[1];\n\n    d += 4;\n    s += 2;\n  }\n\n  return data;\n}\n\nret_t stb_load_image(int32_t subtype, const uint8_t* buff, uint32_t buff_size, bitmap_t* image,\n                     bool_t require_bgra, bool_t enable_bgr565, bool_t enable_rgb565,\n                     lcd_orientation_t o) {\n  int w = 0;\n  int h = 0;\n  int n = 0;\n  ret_t ret = RET_FAIL;\n\n  if (subtype != ASSET_TYPE_IMAGE_GIF) {\n    uint8_t* data = NULL;\n    int out_channel_order;\n    uint8_t* stb_data =\n        stbi_load_from_memory_ex(buff, buff_size, &w, &h, &n, &out_channel_order, 0);\n    return_value_if_fail(stb_data != NULL, RET_FAIL);\n\n    if (n == 2) {\n      n = 4;\n      data = convert_2_to_4(stb_data, w, h);\n    } else {\n      data = stb_data;\n    }\n#ifdef WITH_LCD_MONO\n    if (out_channel_order == STBI_ORDER_RGB) {\n      ret = bitmap_init_from_rgba(image, w, h, BITMAP_FMT_MONO, data, n, o);\n    } else {\n      ret = bitmap_init_from_bgra(image, w, h, BITMAP_FMT_MONO, data, n, o);\n    }\n#else\n    if (out_channel_order == STBI_ORDER_RGB) {\n      if (enable_bgr565 && rgba_data_is_opaque(data, w, h, n)) {\n        ret = bitmap_init_from_rgba(image, w, h, BITMAP_FMT_BGR565, data, n, o);\n      } else if (enable_rgb565 && rgba_data_is_opaque(data, w, h, n)) {\n        ret = bitmap_init_from_rgba(image, w, h, BITMAP_FMT_RGB565, data, n, o);\n      } else if (require_bgra) {\n        ret = bitmap_init_from_rgba(image, w, h, BITMAP_FMT_BGRA8888, data, n, o);\n      } else {\n        ret = bitmap_init_from_rgba(image, w, h, BITMAP_FMT_RGBA8888, data, n, o);\n      }\n    } else {\n      if (enable_bgr565 && rgba_data_is_opaque(data, w, h, n)) {\n        ret = bitmap_init_from_bgra(image, w, h, BITMAP_FMT_BGR565, data, n, o);\n      } else if (enable_rgb565 && rgba_data_is_opaque(data, w, h, n)) {\n        ret = bitmap_init_from_bgra(image, w, h, BITMAP_FMT_RGB565, data, n, o);\n      } else if (require_bgra) {\n        ret = bitmap_init_from_bgra(image, w, h, BITMAP_FMT_BGRA8888, data, n, o);\n      } else {\n        ret = bitmap_init_from_bgra(image, w, h, BITMAP_FMT_RGBA8888, data, n, o);\n      }\n    }\n#endif /*WITH_LCD_MONO*/\n    stbi_image_free((uint8_t*)(stb_data));\n    if (stb_data != data) {\n      TKMEM_FREE(data);\n    }\n  } else {\n    int z = 0;\n    int total_h = 0;\n    int* delays = NULL;\n    uint8_t* data = stbi_load_gif_from_memory(buff, buff_size, &delays, &w, &h, &z, &n, 0);\n\n    return_value_if_fail(data != NULL, RET_FAIL);\n\n    total_h = h * z;\n#ifdef WITH_LCD_MONO\n    ret = bitmap_init_from_rgba(image, w, total_h, BITMAP_FMT_MONO, data, n, o);\n#else\n    if (enable_bgr565 && rgba_data_is_opaque(data, w, total_h, n)) {\n      ret = bitmap_init_from_rgba(image, w, total_h, BITMAP_FMT_BGR565, data, n, o);\n    } else if (require_bgra) {\n      ret = bitmap_init_from_rgba(image, w, total_h, BITMAP_FMT_BGRA8888, data, n, o);\n    } else {\n      ret = bitmap_init_from_rgba(image, w, total_h, BITMAP_FMT_RGBA8888, data, n, o);\n    }\n#endif /*WITH_LCD_MONO*/\n\n    image->is_gif = TRUE;\n    image->gif_frame_h = h;\n    image->gif_frames_nr = z;\n    image->gif_delays = delays;\n\n    stbi_image_free((uint8_t*)(data));\n  }\n\n  return ret;\n}\n\nstatic ret_t image_loader_stb_load(image_loader_t* l, const asset_info_t* asset, bitmap_t* image) {\n  ret_t ret = RET_OK;\n  bool_t require_bgra = FALSE;\n  bool_t enable_bgr565 = FALSE;\n  bool_t enable_rgb565 = FALSE;\n  system_info_t* info = system_info();\n  lcd_orientation_t o = LCD_ORIENTATION_0;\n  return_value_if_fail(l != NULL && image != NULL && info != NULL, RET_BAD_PARAMS);\n\n  if (asset->subtype != ASSET_TYPE_IMAGE_JPG && asset->subtype != ASSET_TYPE_IMAGE_PNG &&\n      asset->subtype != ASSET_TYPE_IMAGE_GIF && asset->subtype != ASSET_TYPE_IMAGE_BMP) {\n    return RET_NOT_IMPL;\n  }\n\n#if !defined(WITH_GPU) && !defined(WITH_VGCANVAS_CAIRO) && defined(WITH_FAST_LCD_PORTRAIT)\n  if (system_info()->flags & SYSTEM_INFO_FLAG_FAST_LCD_PORTRAIT) {\n    o = info->lcd_orientation;\n  }\n#endif\n\n#ifdef WITHOUT_FAST_LCD_PORTRAIT_FOR_IMAGE\n  o = LCD_ORIENTATION_0;\n#endif\n\n#ifdef WITH_BITMAP_BGR565\n  enable_bgr565 = TRUE;\n#endif /*WITH_BITMAP_BGR565*/\n\n#ifdef WITH_BITMAP_RGB565\n  enable_rgb565 = TRUE;\n#endif /*WITH_BITMAP_RGB565*/\n\n#ifdef WITH_BITMAP_BGRA\n  require_bgra = TRUE;\n#endif /*WITH_BITMAP_BGRA*/\n\n  ret = stb_load_image(asset->subtype, asset->data, asset->size, image, require_bgra, enable_bgr565,\n                       enable_rgb565, o);\n\n#ifdef WITH_BITMAP_PREMULTI_ALPHA\n  if (ret == RET_OK) {\nret = ",
    "raw_res": "bitmap_premultiply_alpha(image);",
    "prompt_res": "bitmap_premulti_alpha(image);",
    "gt": "bitmap_premulti_alpha(image);"
  },
  {
    "id": 1263,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/window_manager/window_manager_simple.c",
    "input": "﻿/**\n * File:   window_manager_simple.c\n * Author: AWTK Develop Team\n * Brief:  default window manager\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-08-18 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"base/keys.h\"\n#include \"tkc/mem.h\"\n#include \"base/idle.h\"\n#include \"tkc/utils.h\"\n#include \"base/timer.h\"\n#include \"base/layout.h\"\n#include \"tkc/time_now.h\"\n#include \"base/dialog.h\"\n#include \"base/locale_info.h\"\n#include \"base/system_info.h\"\n#include \"base/image_manager.h\"\n#include \"window_manager/window_manager_simple.h\"\n\nret_t window_manager_paint_system_bar(widget_t* widget, canvas_t* c);\nstatic ret_t window_manager_simple_invalidate(widget_t* widget, const rect_t* r);\nstatic ret_t window_manager_simple_do_open_window(widget_t* wm, widget_t* window);\nstatic ret_t window_manager_simple_layout_child(widget_t* widget, widget_t* window);\n\nstatic bool_t window_is_fullscreen(widget_t* widget) {\n  value_t v;\n  value_set_bool(&v, FALSE);\n  widget_get_prop(widget, WIDGET_PROP_FULLSCREEN, &v);\n\n  return value_bool(&v);\n}\n\nstatic bool_t window_is_opened(widget_t* widget) {\n  int32_t stage = widget_get_prop_int(widget, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n\n  return stage == WINDOW_STAGE_OPENED || stage == WINDOW_STAGE_SUSPEND;\n}\n\nstatic widget_t* window_manager_find_prev_window(widget_t* widget) {\n  int32_t i = 0;\n  int32_t nr = 0;\n  return_value_if_fail(widget != NULL, NULL);\n\n  if (widget->children != NULL && widget->children->size > 0) {\n    nr = widget->children->size;\n    for (i = nr - 2; i >= 0; i--) {\n      widget_t* iter = (widget_t*)(widget->children->elms[i]);\n      if (widget_is_normal_window(iter)) {\n        return iter;\n      }\n    }\n  }\n\n  return NULL;\n}\n\nstatic ret_t window_manager_dispatch_window_open(widget_t* curr_win) {\n  window_manager_dispatch_window_event(curr_win, EVT_WINDOW_WILL_OPEN);\n\n  return window_manager_dispatch_window_event(curr_win, EVT_WINDOW_OPEN);\n}\n\nstatic ret_t window_manager_idle_dispatch_window_open(const idle_info_t* info) {\n  window_manager_dispatch_window_open(WIDGET(info->ctx));\n\n  return RET_REMOVE;\n}\n\nstatic ret_t window_manager_simple_do_open_window(widget_t* widget, widget_t* window) {\n  widget_add_idle(window, (idle_func_t)window_manager_idle_dispatch_window_open);\n\n  return RET_OK;\n}\n\nstatic ret_t wm_on_destroy_child(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  (void)e;\n  if (!widget->destroying) {\n    window_manager_dispatch_top_window_changed(widget);\n  }\n\n  return RET_REMOVE;\n}\n\nstatic ret_t window_manager_simple_open_window(widget_t* widget, widget_t* window) {\n  ret_t ret = RET_OK;\n  window_manager_simple_t* wm = WINDOW_MANAGER_SIMPLE(widget);\n  return_value_if_fail(widget != NULL && window != NULL, RET_BAD_PARAMS);\n\n  if (widget_is_system_bar(window)) {\n    return_value_if_fail(wm->system_bar == NULL, RET_BAD_PARAMS);\n  }\n\n  wm->prev_win = window_manager_get_top_window(widget);\n\n  window_manager_simple_do_open_window(widget, window);\n\n  ret = widget_add_child(widget, window);\n  return_value_if_fail(ret == RET_OK, RET_FAIL);\n  window_manager_simple_layout_child(widget, window);\n\n  window->dirty = FALSE;\n  widget->target = window;\n\n  if (!widget_is_keyboard(window)) {\n    widget->key_target = window;\n  }\n  widget_invalidate(window, NULL);\n\n  if (widget_is_system_bar(window)) {\n    wm->system_bar = window;\n  }\n\n  widget_set_prop_pointer(window, WIDGET_PROP_NATIVE_WINDOW, wm->native_window);\n  widget_on(window, EVT_DESTROY, wm_on_destroy_child, widget);\n  widget_update_style(widget);\n\n  return ret;\n}\n\nstatic ret_t window_manager_idle_destroy_window(const idle_info_t* info) {\n  widget_t* win = WIDGET(info->ctx);\n  widget_destroy(win);\n\n  return RET_OK;\n}\n\nstatic ret_t window_manager_prepare_close_window(widget_t* widget, widget_t* window) {\n  window_manager_simple_t* wm = WINDOW_MANAGER_SIMPLE(widget);\n  return_value_if_fail(widget != NULL && window != NULL, RET_BAD_PARAMS);\n\n  if (widget->target == window) {\n    widget->target = NULL;\n  }\n\n  if (widget->key_target == window) {\n    widget->key_target = NULL;\n  }\n\n  if (widget->grab_widget != NULL) {\n    if (widget->grab_widget == window) {\n      widget->grab_widget = NULL;\n    }\n  }\n\n  if (wm->system_bar == window) {\n    wm->system_bar = NULL;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t window_manager_simple_close_window(widget_t* widget, widget_t* window) {\n  window_manager_simple_t* wm = WINDOW_MANAGER_SIMPLE(widget);\n\n  return_value_if_fail(wm != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget_is_window(window), RET_BAD_PARAMS);\n  return_value_if_fail(window_is_opened(window), RET_BAD_PARAMS);\n\n  window_manager_prepare_close_window(widget, window);\n  window_manager_dispatch_window_event(window, EVT_WINDOW_CLOSE);\n  {\n    widget_t* prev_win = window_manager_find_prev_window(WIDGET(wm));\n    if (prev_win != NULL) {\n      if (!widget_is_keyboard(window)) {\n        window_manager_dispatch_window_event(prev_win, EVT_WINDOW_TO_FOREGROUND);\n      }\n    }\n    widget_remove_child(widget, window);\n    idle_add(window_manager_idle_destroy_window, window);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t window_manager_simple_close_window_force(widget_t* widget, widget_t* window) {\n  window_manager_simple_t* wm = WINDOW_MANAGER_SIMPLE(widget);\n\n  return_value_if_fail(wm != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget_is_window(window), RET_BAD_PARAMS);\n\n  window_manager_prepare_close_window(widget, window);\n  window_manager_dispatch_window_event(window, EVT_WINDOW_CLOSE);\n  widget_remove_child(widget, window);\n  widget_destroy(window);\n\n  return RET_OK;\n}\n\nstatic widget_t* window_manager_simple_find_target(widget_t* widget, xy_t x, xy_t y) {\n  return window_manager_find_target(widget, NULL, x, y);\n}\n\nstatic ret_t window_manager_paint_normal(widget_t* widget, canvas_t* c) {\n  uint64_t start_time = time_now_ms();\n  window_manager_simple_t* wm = WINDOW_MANAGER_SIMPLE(widget);\n\n  if (native_window_begin_frame(wm->native_window, LCD_DRAW_NORMAL) == RET_OK) {\n    ENSURE(widget_paint(WIDGET(wm), c) == RET_OK);\n    native_window_end_frame(wm->native_window);\n  }\n  wm->last_paint_cost = time_now_ms() - start_time;\n\n  return RET_OK;\n}\n\nstatic ret_t window_manager_simple_paint(widget_t* widget) {\n  ret_t ret = RET_OK;\n  window_manager_simple_t* wm = WINDOW_MANAGER_SIMPLE(widget);\n  canvas_t* c = native_window_get_canvas(wm->native_window);\n  return_value_if_fail(wm != NULL && c != NULL, RET_BAD_PARAMS);\n\n  canvas_set_global_alpha(c, 0xff);\n\n  ret = window_manager_paint_normal(widget, c);\n\n  return ret;\n}\n\nstatic ret_t window_manager_simple_invalidate(widget_t* widget, const rect_t* r) {\n  window_manager_simple_t* wm = WINDOW_MANAGER_SIMPLE(widget);\n\n  if (wm->native_window != NULL) {\n    native_window_invalidate(wm->native_window, r);\n  }\n\n  return RET_OK;\n}\n\nstatic widget_t* window_manager_simple_get_prev_window(widget_t* widget) {\n  window_manager_simple_t* wm = WINDOW_MANAGER_SIMPLE(widget);\n\n  return wm->prev_win;\n}\n\nstatic ret_t window_manager_simple_on_paint_children(widget_t* widget, canvas_t* c) {\n  int32_t start = 0;\n  bool_t has_fullscreen_win = FALSE;\n  window_manager_simple_t* wm = WINDOW_MANAGER_SIMPLE(widget);\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN_R(widget, iter, i)\n  if (iter->visible && widget_is_normal_window(iter)) {\n    start = i;\n    break;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  /*paint normal windows*/\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (i >= start && iter->visible) {\n    if (widget_is_normal_window(iter)) {\n      widget_paint(iter, c);\n\n      if (!has_fullscreen_win) {\n        has_fullscreen_win = window_is_fullscreen(iter);\n      }\n      start = i + 1;\n      break;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  /*paint system_bar*/\n  if (!has_fullscreen_win) {\n    window_manager_paint_system_bar(widget, c);\n  }\n  /*paint dialog and other*/\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (i >= start && iter->visible) {\n    if (wm->system_bar != iter && !widget_is_normal_window(iter)) {\n      widget_paint(iter, c);\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return RET_OK;\n}\n\nstatic ret_t window_manager_simple_on_remove_child(widget_t* widget, widget_t* window) {\n  widget_t* top = window_manager_get_top_main_window(widget);\n\n  if (top != NULL) {\n    rect_t r;\n    r = rect_init(window->x, window->y, window->w, window->h);\n    widget_invalidate(top, &r);\n  }\n\n  return RET_FAIL;\n}\n\nstatic ret_t window_manager_simple_get_prop(widget_t* widget, const char* name, value_t* v) {\n  window_manager_simple_t* wm = WINDOW_MANAGER_SIMPLE(widget);\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_CANVAS)) {\n    canvas_t* c = native_window_get_canvas(wm->native_window);\n    value_set_pointer(v, c);\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t window_manager_simple_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t window_manager_simple_on_destroy(widget_t* widget) {\n  window_manager_simple_t* wm = WINDOW_MANAGER_SIMPLE(widget);\n  tk_object_unref(TK_OBJECT(wm->native_window));\n\n  return RET_OK;\n}\n\nstatic ret_t window_manager_simple_on_layout_children(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  window_manager_simple_layout_child(widget, iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nstatic ret_t window_manager_simple_resize(widget_t* widget, wh_t w, wh_t h);\nstatic ret_t window_manager_simple_post_init(widget_t* widget, wh_t w, wh_t h);\nstatic ret_t window_manager_simple_dispatch_input_event(widget_t* widget, event_t* e);\n\nstatic ret_t window_manager_simple_get_pointer(widget_t* widget, xy_t* x, xy_t* y,\n                                               bool_t* pressed) {\n  window_manager_simple_t* wm = WINDOW_MANAGER_SIMPLE(widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (x != NULL) {\n    *x = wm->input_device_status.last_x;\n  }\n  if (y != NULL) {\n    *y = wm->input_device_status.last_y;\n  }\n  if (pressed != NULL) {\n    *pressed = wm->input_device_status.pressed;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t window_manager_simple_on_event(widget_t* widget, event_t* e) {\n  if (e->type == EVT_ORIENTATION_WILL_CHANGED) {\n    orientation_event_t* evt = orientation_event_cast(e);\n    lcd_orientation_t orientation = evt->orientation;\n    window_manager_simple_t* wm = WINDOW_MANAGER_SIMPLE(widget);\n    lcd_t* lcd = native_window_get_canvas(wm->native_window)->lcd;\n\n    wh_t w = wm->lcd_w;\n    wh_t h = wm->lcd_h;\n    if (orientation == LCD_ORIENTATION_90 || orientation == LCD_ORIENTATION_270) {\n      w = wm->lcd_h;\n      h = wm->lcd_w;\n    }\n\n    lcd_resize(lcd, w, h, 0);\n    window_manager_simple_resize(widget, w, h);\n    e->type = EVT_ORIENTATION_CHANGED;\n\n    widget_dispatch(widget, e);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t window_manager_simple_layout_child(widget_t* widget, widget_t* window) {\n  xy_t x = window->x;\n  xy_t y = window->y;\n  wh_t w = window->w;\n  wh_t h = window->h;\n  window_manager_simple_t* wm = WINDOW_MANAGER_SIMPLE(widget);\n  rect_t client_r = rect_init(0, 0, widget->w, widget->h);\n\n  if (wm->system_bar != NULL) {\n    widget_t* bar = wm->system_bar;\n    client_r = rect_init(0, bar->h, widget->w, widget->h - bar->h);\n  }\n\n  if (widget_is_normal_window(window)) {\n    if (window_is_fullscreen(window)) {\n      x = 0;\n      y = 0;\n      w = widget->w;\n      h = widget->h;\n    } else {\n      x = client_r.x;\n      y = client_r.y;\n      w = client_r.w;\n      h = client_r.h;\n    }\n  } else if (widget_is_system_bar(window)) {\n    x = 0;\n    y = 0;\n    w = widget->w;\n  } else if (widget_is_dialog(window)) {\n    x = (widget->w - window->w) >> 1;\n    y = (widget->h - window->h) >> 1;\n  } else {\n    x = window->x;\n    y = window->y;\n    w = window->w;\n    h = window->h;\n  }\n\n  widget_move_resize(window, x, y, w, h);\n  widget_layout(window);\n\n  return RET_OK;\n}\n\nstatic ret_t window_manager_simple_resize(widget_t* widget, wh_t w, wh_t h) {\nrect_t r = ",
    "raw_res": "{0, 0, w, h};",
    "prompt_res": "rect_init(0, 0, w, h);",
    "gt": "rect_init(0, 0, w, h);"
  },
  {
    "id": 1272,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/window_animators/window_animator_vtranslate.c",
    "input": "﻿/**\n * File:   window_animator_vtranslate.c\n * Author: AWTK Develop Team\n * Brief:  vertical translate window animator\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-04-22 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"window_animators/window_animator_vtranslate.h\"\n\nstatic ret_t window_animator_vtranslate_update_percent(window_animator_t* wa) {\n  float_t percent = 0.2f + 0.8f * wa->easing(wa->time_percent);\n  if (wa->open) {\n    wa->percent = percent;\n  } else {\n    wa->percent = 1.0f - percent;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t window_animator_vtranslate_draw_prev(window_animator_t* wa) {\n  canvas_t* c = wa->canvas;\n  widget_t* win = wa->prev_win;\n  widget_t* curr_win = wa->curr_win;\n  float_t percent = wa->percent;\n  float_t y = tk_roundi(curr_win->h * percent);\n  float_t h = win->h - y;\n\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  rectf_t src = rectf_init(win->x, y + win->y, win->w, h);\nrectf_t dst = ",
    "raw_res": "rectf_init(curr_win->x, curr_win->y, curr_win->w, curr_win->h);",
    "prompt_res": "rectf_init(win->x, win->y, win->w, h);",
    "gt": "rectf_init(win->x, win->y, win->w, h);"
  },
  {
    "id": 1279,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/window_animators/window_animator_common.c",
    "input": "﻿/**\n * File:   window_animator_common.c\n * Author: AWTK Develop Team\n * Brief:  window animator common used functions.\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-03-28 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#ifdef AWTK_WEB\n#include <emscripten.h>\n#endif /*AWTK_WEB*/\n\n#include \"base/window_manager.h\"\n#include \"base/window_animator.h\"\n#include \"base/dialog_highlighter_factory.h\"\n#include \"window_manager/window_manager_default.h\"\n#include \"window_animators/window_animator_common.h\"\n\nret_t window_animator_to_bottom_draw_curr(window_animator_t* wa) {\n  canvas_t* c = wa->canvas;\n  widget_t* win = wa->curr_win;\n  float_t percent = wa->percent;\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  int32_t y = win->y;\n  int32_t h = tk_roundi(win->h * percent);\n\n  rectf_t src = rectf_init(win->x, win->y + win->h - h, win->w, h);\n  rectf_t dst = rectf_init(win->x, y, win->w, h);\n\n  if (h == 0) {\n    return RET_OK;\n  }\n\n  return lcd_draw_image(c->lcd, &(wa->curr_img), rectf_scale(&src, wa->ratio), &dst);\n#else\n  int32_t y = -win->h * (1 - percent);\n  canvas_translate(c, 0, y);\n  widget_paint(win, c);\n  canvas_untranslate(c, 0, y);\n  return RET_OK;\n#endif /*WITHOUT_WINDOW_ANIMATOR_CACHE*/\n}\n\nret_t window_animator_to_top_draw_curr(window_animator_t* wa) {\n  canvas_t* c = wa->canvas;\n  widget_t* win = wa->curr_win;\n  float_t percent = wa->percent;\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  int32_t y = win->y + tk_roundi(win->h * (1 - percent));\n  int32_t h = win->y + win->h - y;\n\nrectf_t src = ",
    "raw_res": "rectf_init(win->x, win->y + win->h - h, win->w, h);",
    "prompt_res": "rectf_init(win->x, win->y, win->w, h);",
    "gt": "rectf_init(win->x, win->y, win->w, h);"
  },
  {
    "id": 1380,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/ext_widgets/slide_view/slide_indicator.c",
    "input": "﻿/**\n * File:   slide_indicator.h\n * Author: AWTK Develop Team\n * Brief:  slide_indicator\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-05-29 Xu ChaoZe <xuchaoze@zlg.cn> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"base/timer.h\"\n#include \"base/layout.h\"\n#include \"base/enums.h\"\n#include \"tkc/easing.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/func_call_parser.h\"\n#include \"slide_view/slide_indicator.h\"\n#include \"widget_animators/widget_animator_opacity.h\"\n#include \"base/widget_animator_manager.h\"\n\n#ifndef SLIDE_INDICATOR_HIDE_ANIMATOR_TIME\n#define SLIDE_INDICATOR_HIDE_ANIMATOR_TIME 1000\n#endif\n\nstatic ret_t slide_indicator_reset_indicated_widget(widget_t* widget);\nstatic ret_t slide_indicator_reset_indicated_widget(widget_t* widget);\nstatic ret_t slide_indicator_set_indicated_widget(widget_t* widget, widget_t* target);\nstatic ret_t slide_indicator_set_value_impl(widget_t* widget, uint32_t value, bool_t is_on_event);\n\n#define _RADIAN(cx, cy, x, y) atan2(-y + (cy), x - (cx))\n#define _DISTANCE(x1, y1, x2, y2) sqrt((x1 - (x2)) * (x1 - (x2)) + (y1 - (y2)) * (y1 - (y2)))\n\nstatic const key_type_value_t indicator_default_paint_value[] = {\n    {\"auto\", 0, INDICATOR_DEFAULT_PAINT_AUTO},\n    {\"stroke_dot\", 0, INDICATOR_DEFAULT_PAINT_STROKE_DOT},\n    {\"fill_dot\", 0, INDICATOR_DEFAULT_PAINT_FILL_DOT},\n    {\"stroke_rect\", 0, INDICATOR_DEFAULT_PAINT_STROKE_RECT},\n    {\"fill_rect\", 0, INDICATOR_DEFAULT_PAINT_FILL_RECT}};\n\nconst key_type_value_t* indicator_default_paint_find(const char* name) {\n  return find_item(indicator_default_paint_value, ARRAY_SIZE(indicator_default_paint_value), name);\n}\n\nstatic pointf_t slide_indicator_eval_anchor(widget_t* widget) {\n  point_t p = {0, 0};\n  pointf_t anchor = {0, 0};\n  const char* anchor_x = NULL;\n  const char* anchor_y = NULL;\n  slide_indicator_t* slide_indicator = SLIDE_INDICATOR(widget);\n  return_value_if_fail(slide_indicator != NULL, anchor);\n\n  anchor_x = slide_indicator->anchor_x;\n  anchor_y = slide_indicator->anchor_y;\n\n  if (TK_STR_IS_EMPTY(anchor_x) || TK_STR_IS_EMPTY(anchor_y)) {\n    widget_t* target = slide_indicator->indicated_widget;\n    return_value_if_fail(target != NULL, anchor);\n\n    widget_to_screen(target, &p);\n    p.x += target->w / 2;\n    p.y += target->h / 2;\n    widget_to_local(widget, &p);\n  }\n\n  if (TK_STR_IS_EMPTY(anchor_x)) {\n    anchor.x = p.x;\n  } else {\n    anchor.x = tk_eval_ratio_or_px(anchor_x, widget->w);\n  }\n\n  if (TK_STR_IS_EMPTY(anchor_y)) {\n    anchor.y = p.y;\n  } else {\n    anchor.y = tk_eval_ratio_or_px(anchor_y, widget->h);\n  }\n\n  return anchor;\n}\n\nret_t slide_indicator_set_anchor_x(widget_t* widget, const char* anchor) {\n  slide_indicator_t* slide_indicator = SLIDE_INDICATOR(widget);\n  return_value_if_fail(slide_indicator != NULL && anchor != NULL, RET_BAD_PARAMS);\n\n  slide_indicator->anchor_x = tk_str_copy(slide_indicator->anchor_x, anchor);\n\n  return RET_OK;\n}\n\nret_t slide_indicator_set_anchor_y(widget_t* widget, const char* anchor) {\n  slide_indicator_t* slide_indicator = SLIDE_INDICATOR(widget);\n  return_value_if_fail(slide_indicator != NULL && anchor != NULL, RET_BAD_PARAMS);\n\n  slide_indicator->anchor_y = tk_str_copy(slide_indicator->anchor_y, anchor);\n\n  return RET_OK;\n}\n\nstatic ret_t slide_indicator_get_prop(widget_t* widget, const char* name, value_t* v) {\n  slide_indicator_t* slide_indicator = SLIDE_INDICATOR(widget);\n  return_value_if_fail(slide_indicator != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_VALUE) || tk_str_eq(name, WIDGET_PROP_CURR_PAGE)) {\n    value_set_int(v, slide_indicator->value);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_MAX)) {\n    value_set_uint32(v, slide_indicator->max);\n    return RET_OK;\n  } else if (tk_str_eq(name, SLIDE_INDICATOR_PROP_DEFAULT_PAINT)) {\n    value_set_int(v, slide_indicator->default_paint);\n    return RET_OK;\n  } else if (tk_str_eq(name, SLIDE_INDICATOR_PROP_AUTO_HIDE)) {\n    value_set_int(v, slide_indicator->auto_hide);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_MARGIN)) {\n    value_set_int(v, slide_indicator->margin);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_SPACING)) {\n    value_set_float(v, slide_indicator->spacing);\n    return RET_OK;\n  } else if (tk_str_eq(name, SLIDE_INDICATOR_PROP_SIZE)) {\n    value_set_uint32(v, slide_indicator->size);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_ANCHOR_X)) {\n    value_set_str(v, slide_indicator->anchor_x);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_ANCHOR_Y)) {\n    value_set_str(v, slide_indicator->anchor_y);\n    return RET_OK;\n  } else if (tk_str_eq(name, SLIDE_INDICATOR_PROP_INDICATED_TARGET)) {\n    value_set_str(v, slide_indicator->indicated_target);\n    return RET_OK;\n  } else if (tk_str_eq(name, SLIDE_INDICATOR_PROP_transition)) {\n    value_set_bool(v, slide_indicator->transition);\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t slide_indicator_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  slide_indicator_t* slide_indicator = SLIDE_INDICATOR(widget);\n  return_value_if_fail(slide_indicator != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_VALUE) || tk_str_eq(name, WIDGET_PROP_CURR_PAGE)) {\n    return slide_indicator_set_value(widget, value_int(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_MAX)) {\n    return slide_indicator_set_max(widget, value_uint32(v));\n  } else if (tk_str_eq(name, SLIDE_INDICATOR_PROP_DEFAULT_PAINT)) {\n    if (v->type == VALUE_TYPE_STRING) {\n      const key_type_value_t* kv = indicator_default_paint_find(value_str(v));\n      if (kv != NULL) {\n        slide_indicator_set_default_paint(widget, (indicator_default_paint_t)(kv->value));\n      }\n    } else {\n      slide_indicator_set_default_paint(widget, (indicator_default_paint_t)value_int(v));\n    }\n    return RET_OK;\n  } else if (tk_str_eq(name, SLIDE_INDICATOR_PROP_AUTO_HIDE)) {\n    return slide_indicator_set_auto_hide(widget, value_uint16(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_MARGIN)) {\n    return slide_indicator_set_margin(widget, value_int(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_SPACING)) {\n    return slide_indicator_set_spacing(widget, value_float(v));\n  } else if (tk_str_eq(name, SLIDE_INDICATOR_PROP_SIZE)) {\n    return slide_indicator_set_size(widget, value_uint32(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_ANCHOR_X)) {\n    return slide_indicator_set_anchor_x(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_ANCHOR_Y)) {\n    return slide_indicator_set_anchor_y(widget, value_str(v));\n  } else if (tk_str_eq(name, SLIDE_INDICATOR_PROP_INDICATED_TARGET)) {\n    return slide_indicator_set_indicated_target(widget, value_str(v));\n  } else if (tk_str_eq(name, SLIDE_INDICATOR_PROP_transition)) {\n    return slide_indicator_set_transition(widget, value_bool(v));\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic widget_t* slide_indicator_find_target(widget_t* widget) {\n  value_t v;\n  widget_t* parent = NULL;\n  return_value_if_fail(widget != NULL, NULL);\n  parent = widget->parent;\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(parent, iter, i)\n  if (iter != NULL) {\n    if (widget_get_prop(iter, WIDGET_PROP_CURR_PAGE, &v) == RET_OK &&\n        widget_get_prop(iter, WIDGET_PROP_PAGE_MAX_NUMBER, &v) == RET_OK) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n  return NULL;\n}\n\nstatic ret_t slide_indicator_on_layout_children(widget_t* widget) {\n  slide_indicator_t* slide_indicator = SLIDE_INDICATOR(widget);\n  return_value_if_fail(slide_indicator != NULL, RET_BAD_PARAMS);\n\n  if (slide_indicator->indicated_widget != NULL &&\n      slide_indicator->indicated_widget->parent == widget->parent) {\n  } else {\n    if (slide_indicator_reset_indicated_widget(widget) == RET_OK) {\n      widget_t* target = NULL;\n      if (slide_indicator->indicated_target != NULL) {\n        target = widget_lookup(widget->parent, slide_indicator->indicated_target, FALSE);\n      } else {\n        target = slide_indicator_find_target(widget);\n      }\n      if (target) {\n        slide_indicator_set_indicated_widget(widget, target);\n      }\n    }\n  }\n  slide_indicator->reset_icon_rect_list = TRUE;\n  return widget_layout_children_default(widget);\n}\n\nstatic ret_t slide_indicator_fill_rect(canvas_t* c, rect_t* r, color_t color) {\n  canvas_set_fill_color(c, color);\n  canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n  return RET_OK;\n}\n\nstatic ret_t slide_indicator_stroke_rect(canvas_t* c, rect_t* r, color_t color) {\n  canvas_set_stroke_color(c, color);\n  canvas_stroke_rect(c, r->x, r->y, r->w, r->h);\n  return RET_OK;\n}\n\nstatic ret_t slide_indicator_draw_rect_by_vg(canvas_t* c, rectf_t* r, color_t color, bool_t fill) {\n  vgcanvas_t* vg = canvas_get_vgcanvas(c);\n  vgcanvas_save(vg);\n  vgcanvas_set_global_alpha(vg, c->global_alpha / 255.0f);\n  vgcanvas_translate(vg, c->ox, c->oy);\n  vgcanvas_begin_path(vg);\n  vgcanvas_set_fill_color(vg, color);\n  vgcanvas_rect(vg, r->x, r->y, r->w, r->h);\n  if (fill) {\n    vgcanvas_fill(vg);\n  } else {\n    vgcanvas_stroke(vg);\n  }\n  vgcanvas_restore(vg);\n  return RET_OK;\n}\n\nstatic ret_t slide_indicator_fill_dot(canvas_t* c, rectf_t* r, color_t color) {\n  float_t radius = tk_min(r->w, r->h) / 2;\n  vgcanvas_t* vg = canvas_get_vgcanvas(c);\n  vgcanvas_save(vg);\n  vgcanvas_set_global_alpha(vg, c->global_alpha / 255.0f);\n  vgcanvas_translate(vg, c->ox, c->oy);\n  vgcanvas_begin_path(vg);\n  vgcanvas_set_fill_color(vg, color);\n  vgcanvas_arc(vg, r->x + radius, r->y + radius, radius, 0, M_PI * 2, FALSE);\n  vgcanvas_fill(vg);\n  vgcanvas_restore(vg);\n  return RET_OK;\n}\n\nstatic ret_t slide_indicator_stroke_dot(canvas_t* c, rectf_t* r, color_t color) {\n  float_t radius = tk_min(r->w, r->h) / 2;\n  vgcanvas_t* vg = canvas_get_vgcanvas(c);\n  vgcanvas_save(vg);\n  vgcanvas_set_global_alpha(vg, c->global_alpha / 255.0f);\n  vgcanvas_translate(vg, c->ox, c->oy);\n  vgcanvas_begin_path(vg);\n  vgcanvas_set_stroke_color(vg, color);\n  vgcanvas_arc(vg, r->x + radius, r->y + radius, radius, 0, M_PI * 2, FALSE);\n  vgcanvas_stroke(vg);\n  vgcanvas_restore(vg);\n  return RET_OK;\n}\n\nstatic ret_t slide_indicator_default_paint_indicator(widget_t* widget, canvas_t* c, rectf_t* r,\n                                                     color_t color) {\n  rect_t rect = rect_from_rectf(r);\n  slide_indicator_t* slide_indicator = SLIDE_INDICATOR(widget);\n  return_value_if_fail(slide_indicator != NULL, RET_BAD_PARAMS);\n\n  switch (slide_indicator->default_paint) {\n    case INDICATOR_DEFAULT_PAINT_STROKE_DOT:\n      slide_indicator_stroke_dot(c, r, color);\n      break;\n    case INDICATOR_DEFAULT_PAINT_STROKE_RECT:\n      slide_indicator_stroke_rect(c, &rect, color);\n      break;\n    case INDICATOR_DEFAULT_PAINT_FILL_RECT:\n      slide_indicator_fill_rect(c, &rect, color);\n      break;\n    default:\n      slide_indicator_fill_dot(c, r, color);\n  }\n\n  return RET_OK;\n}\n\nstatic float_t slide_indicator_get_max_transition_size(slide_indicator_t* slide_indicator) {\n  return slide_indicator->icon_rect_spacing;\n}\n\nstatic ret_t slide_indicator_default_paint_active_indicator(widget_t* widget, canvas_t* c,\n                                                            rectf_t* r, color_t color) {\n  rect_t rect;\n  rectf_t rectf;\n  float_t x, y, w, h;\n  slide_indicator_t* slide_indicator = SLIDE_INDICATOR(widget);\n  return_value_if_fail(slide_indicator != NULL, RET_BAD_PARAMS);\n  if (slide_indicator->transition) {\n    float_t max_transition_size = slide_indicator_get_max_transition_size(slide_indicator);\n    w = r->w + max_transition_size;\n    h = r->h + max_transition_size;\n    x = r->x - max_transition_size / 2;\n    y = r->y - max_transition_size / 2;\n  } else {\n    x = r->x;\n    y = r->y;\n    w = r->w;\n    h = r->h;\n  }\n  switch (slide_indicator->default_paint) {\n    case INDICATOR_DEFAULT_PAINT_STROKE_RECT:\n    case INDICATOR_DEFAULT_PAINT_FILL_RECT:\n      if (slide_indicator->transition) {\n        rect = rect_init(x, y, w, h);\n        slide_indicator_fill_rect(c, &rect, color);\n      } else {\n        rectf = rectf_init(x, y, w, h);\n        slide_indicator_draw_rect_by_vg(c, &rectf, color, TRUE);\n      }\n      break;\n    default:\n      rectf = rectf_init(x, y, w, h);\n      slide_indicator_fill_dot(c, &rectf, color);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t slide_indicator_default_paint_indicator_by_transition(widget_t* widget, canvas_t* c,\n                                                                   rectf_t* r, color_t color,\n                                                                   color_t selected_color,\n                                                                   float_t active_offset) {\n  rectf_t new_rect;\n  float_t x, y, w, h, transition_size;\n  color_t new_color = color_init(0, 0, 0, 0);\n  color_t new_color1 = color_init(0, 0, 0, 0);\n  int32_t dr = selected_color.rgba.r - color.rgba.r;\n  int32_t dg = selected_color.rgba.g - color.rgba.g;\n  int32_t db = selected_color.rgba.b - color.rgba.b;\n  int32_t da = selected_color.rgba.a - color.rgba.a;\n  slide_indicator_t* slide_indicator = SLIDE_INDICATOR(widget);\n  return_value_if_fail(slide_indicator != NULL, RET_BAD_PARAMS);\n\n  new_color.rgba.r = color.rgba.r + dr * active_offset;\n  new_color.rgba.g = color.rgba.g + dg * active_offset;\n  new_color.rgba.b = color.rgba.b + db * active_offset;\n  new_color.rgba.a = color.rgba.a + da * active_offset;\n  if (slide_indicator->default_paint == INDICATOR_DEFAULT_PAINT_STROKE_DOT ||\n      slide_indicator->default_paint == INDICATOR_DEFAULT_PAINT_STROKE_RECT) {\n    new_color1.rgba.r = selected_color.rgba.r * active_offset;\n    new_color1.rgba.g = selected_color.rgba.g * active_offset;\n    new_color1.rgba.b = selected_color.rgba.b * active_offset;\n    new_color1.rgba.a = selected_color.rgba.a * active_offset;\n  }\n\n  transition_size = slide_indicator_get_max_transition_size(slide_indicator) * active_offset;\n  w = r->w + transition_size;\n  h = r->h + transition_size;\n  x = r->x - transition_size / 2;\n  y = r->y - transition_size / 2;\n\n  new_rect = rectf_init(x, y, w, h);\n  switch (slide_indicator->default_paint) {\n    case INDICATOR_DEFAULT_PAINT_STROKE_DOT:\n      slide_indicator_stroke_dot(c, &new_rect, new_color);\n      slide_indicator_fill_dot(c, &new_rect, new_color1);\n      break;\n    case INDICATOR_DEFAULT_PAINT_STROKE_RECT:\n      slide_indicator_draw_rect_by_vg(c, &new_rect, new_color, FALSE);\n      slide_indicator_draw_rect_by_vg(c, &new_rect, new_color1, TRUE);\n      break;\n    case INDICATOR_DEFAULT_PAINT_FILL_RECT:\n      slide_indicator_draw_rect_by_vg(c, &new_rect, new_color, TRUE);\n      break;\n    default:\n      slide_indicator_fill_dot(c, &new_rect, new_color);\n      break;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t slide_indicator_paint_one(widget_t* widget, canvas_t* c, rectf_t* r,\n                                       float_t active_offset) {\n  bitmap_t img;\n  style_t* style = widget->astyle;\n  color_t trans = color_init(0, 0, 0, 0);\n  slide_indicator_t* slide_indicator = SLIDE_INDICATOR(widget);\n  color_t color = style_get_color(style, STYLE_ID_FG_COLOR, trans);\n  color_t selected_color = style_get_color(style, STYLE_ID_SELECTED_FG_COLOR, trans);\n  const char* icon =\n      style_get_str(style, active_offset == 1.0f ? STYLE_ID_ACTIVE_ICON : STYLE_ID_ICON, NULL);\n\n  if (!slide_indicator->transition && icon && widget_load_image(widget, icon, &img) == RET_OK) {\n    int32_t x = r->x + ((int32_t)r->w >> 1);\n    int32_t y = r->y + ((int32_t)r->h >> 1);\n    canvas_draw_icon(c, &img, x, y);\n  } else {\n    if (slide_indicator->transition && 0.0f < active_offset && active_offset < 1.0f) {\n      slide_indicator_default_paint_indicator_by_transition(widget, c, r, color, selected_color,\n                                                            active_offset);\n    } else if (active_offset == 1.0f) {\n      slide_indicator_default_paint_active_indicator(widget, c, r, selected_color);\n    } else {\n      slide_indicator_default_paint_indicator(widget, c, r, color);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic float_t slide_indicator_get_offset_by_index(slide_indicator_t* slide_indicator,\n                                                   int32_t index) {\n  int32_t value = slide_indicator->curr_value;\n  float_t value_offset = slide_indicator->value_offset;\n  if (value_offset > 0.0f) {\n    if (value == index) {\n      return 1.0f - value_offset;\n    } else {\n      int32_t next_value = value + 1;\n      if (index == next_value) {\n        return value_offset;\n      } else if (next_value >= slide_indicator->max && slide_indicator->loop && index == 0) {\n        return value_offset;\n      }\n    }\n  } else if (value_offset < 0.0f) {\n    if (value == index) {\n      return 1.0f + value_offset;\n    } else {\n      int32_t next_value = value - 1;\n      if (index == next_value) {\n        return value_offset;\n      } else if (next_value < 0 && slide_indicator->loop && index == slide_indicator->max - 1) {\n        return value_offset;\n      }\n    }\n  } else {\n    if (value == index) {\n      return 1.0f;\n    }\n  }\n  return 0.0f;\n}\n\nstatic ret_t slide_indicator_paint_arc(widget_t* widget, canvas_t* c) {\n  uint32_t i = 0;\n  slide_indicator_t* slide_indicator = SLIDE_INDICATOR(widget);\n  darray_t* icon_rect_list = &(slide_indicator->icon_rect_list);\n\n  if (icon_rect_list->size != slide_indicator->max || slide_indicator->reset_icon_rect_list) {\n    rectf_t r;\n    uint32_t i = 0;\n    float_t offset = 0;\n    bool_t ccw = FALSE;\n    uint32_t nr = slide_indicator->max;\n    uint32_t size = slide_indicator->size;\n    pointf_t anchor = slide_indicator_eval_anchor(widget);\n    float_t cx = anchor.x;\n    float_t cy = anchor.y;\n    float_t margin = slide_indicator->margin;\n    float_t spacing = (slide_indicator->spacing / 180.0f * M_PI);\n    float_t center = _RADIAN(cx, cy, widget->w / 2, widget->h / 2);\n    float_t radius = _DISTANCE(cx, cy, widget->w / 2, widget->h / 2) - margin - size / 2;\n\n    if (cx > widget->w / 2 || cy < widget->h / 2) {\n      ccw = TRUE;\n    }\n\n    if (nr % 2) {\n      offset = ((nr / 2) * spacing);\n    } else {\n      offset = ((nr / 2) * spacing - spacing / 2);\n    }\n    offset = ccw ? (center - offset - 3 * M_PI / 2) : (center + offset + M_PI / 2);\n\n    r = rectf_init(0, 0, size, size);\n    darray_clear(icon_rect_list);\n    for (i = 0; i < nr; i++) {\n      rectf_t* tmp = TKMEM_ZALLOC(rectf_t);\n      if (ccw) {\n        r.x = cx + radius * sin(offset + i * spacing) - size / 2;\n        r.y = cy + radius * cos(-offset - i * spacing) - size / 2;\n      } else {\n        r.x = cx + radius * sin(offset - i * spacing) - size / 2;\n        r.y = cy + radius * cos(-offset + i * spacing) - size / 2;\n      }\n      memcpy(tmp, &r, sizeof(rectf_t));\n      darray_push(icon_rect_list, tmp);\n    }\n    slide_indicator->reset_icon_rect_list = FALSE;\n    slide_indicator->icon_rect_spacing = sin(spacing / 2) * radius * 2 / 5;\n  }\n\n  for (i = 0; i < icon_rect_list->size; i++) {\n    rectf_t* tmp = (rectf_t*)darray_get(icon_rect_list, i);\n    float_t offset = tk_abs(slide_indicator_get_offset_by_index(slide_indicator, i));\n    slide_indicator_paint_one(widget, c, tmp, offset);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t slide_indicator_paint_linear(widget_t* widget, canvas_t* c) {\n  uint32_t i = 0;\n  slide_indicator_t* slide_indicator = SLIDE_INDICATOR(widget);\n  darray_t* icon_rect_list = &(slide_indicator->icon_rect_list);\n\n  if (icon_rect_list->size != slide_indicator->max || slide_indicator->reset_icon_rect_list) {\n    rectf_t r;\n    uint32_t i = 0;\n    bool_t ccw = FALSE;\n    uint32_t offset = 0;\n    uint32_t nr = slide_indicator->max;\n    uint32_t size = slide_indicator->size;\n    pointf_t anchor = slide_indicator_eval_anchor(widget);\n    float_t cx = anchor.x;\n    float_t cy = anchor.y;\n    bool_t vertical = widget->w < widget->h;\n    uint32_t margin = slide_indicator->margin;\n    uint32_t spacing = slide_indicator->spacing;\n    uint32_t half_size = slide_indicator->size >> 1;\n\n    if (cx > widget->w / 2 || cy < widget->h / 2) {\n      ccw = TRUE;\n    }\n\n    if (nr % 2) {\n      offset = ((nr / 2) * spacing + half_size);\n    } else {\n      offset = ((nr / 2) * spacing - spacing / 2 + half_size);\n    }\n\n    if (vertical) {\n      if (ccw) {\n        r = rectf_init(widget->w - margin - size, cy - offset, size, size);\n      } else {\nr = ",
    "raw_res": "rectf_init(widget->w - margin - size, cy + offset, size, size);",
    "prompt_res": "rectf_init(margin, cy - offset, size, size);",
    "gt": "rectf_init(margin, cy - offset, size, size);"
  },
  {
    "id": 1486,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/ext_widgets/scroll_view/scroll_view.c",
    "input": "﻿/**\n * File:   scroll_view.c\n * Author: AWTK Develop Team\n * Brief:  scroll_view\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-07-03 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"base/layout.h\"\n#include \"base/velocity.h\"\n#include \"tkc/time_now.h\"\n#include \"scroll_view/scroll_view.h\"\n#include \"base/widget_vtable.h\"\n#include \"base/image_manager.h\"\n#include \"widget_animators/widget_animator_scroll.h\"\n\n#define SCROLL_VIEW_DEFAULT_XSPEED_SCALE 2.0f\n#define SCROLL_VIEW_DEFAULT_YSPEED_SCALE 2.0f\n\nstatic uint32_t scroll_view_get_curr_page(widget_t* widget);\nstatic uint32_t scroll_view_get_page_max_number(widget_t* widget);\n\nstatic ret_t scroll_view_set_xoffset(scroll_view_t* scroll_view, int32_t xoffset) {\n  offset_change_event_t evt;\n  if (scroll_view->xoffset != xoffset) {\n    offset_change_event_init(&evt, EVT_PAGE_CHANGING, WIDGET(scroll_view),\n                             (float_t)scroll_view->xoffset_save, (float_t)xoffset);\n\n    scroll_view->xoffset = xoffset;\n    widget_dispatch(WIDGET(scroll_view), (event_t*)&evt);\n  }\n  return RET_OK;\n}\n\nstatic ret_t scroll_view_set_yoffset(scroll_view_t* scroll_view, int32_t yoffset) {\n  offset_change_event_t evt;\n  if (scroll_view->yoffset != yoffset) {\n    offset_change_event_init(&evt, EVT_PAGE_CHANGING, WIDGET(scroll_view),\n                             (float_t)scroll_view->yoffset_save, (float_t)yoffset);\n    scroll_view->yoffset = yoffset;\n    widget_dispatch(WIDGET(scroll_view), (event_t*)&evt);\n  }\n  return RET_OK;\n}\n\nstatic ret_t scroll_view_get_item_rect(widget_t* parent, widget_t* widget, rect_t* item_rect) {\n  rect_t r;\n  point_t p;\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  memset(&p, 0x0, sizeof(point_t));\n  widget_to_screen_ex(iter, parent, &p);\n  r = rect_init(p.x, p.y, iter->w, iter->h);\n  rect_merge(item_rect, &r);\n  scroll_view_get_item_rect(parent, iter, item_rect);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nstatic ret_t scroll_view_update_virtual_size(widget_t* widget) {\n  int32_t virtual_w = 0;\n  int32_t virtual_h = 0;\n  scroll_view_t* scroll_view = SCROLL_VIEW(widget);\n  return_value_if_fail(scroll_view != NULL && widget != NULL, RET_BAD_PARAMS);\n\n  virtual_w = tk_max(scroll_view->virtual_w, widget->w);\n  virtual_h = tk_max(scroll_view->virtual_h, widget->h);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  int32_t r = 0;\n  int32_t b = 0;\n  if (scroll_view->recursive) {\n    rect_t rect = rect_init(0, 0, iter->w, iter->h);\n    scroll_view_get_item_rect(iter, iter, &rect);\n    r = iter->x + rect.x + rect.w;\n    b = iter->y + rect.y + rect.h;\n  } else {\n    r = iter->x + iter->w;\n    b = iter->y + iter->h;\n  }\n  if (r > virtual_w) {\n    virtual_w = r;\n  }\n  if (b > virtual_h) {\n    virtual_h = b;\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  scroll_view->virtual_w = virtual_w;\n  scroll_view->virtual_h = virtual_h;\n\n  return RET_OK;\n}\n\nstatic ret_t scroll_view_on_layout_children(widget_t* widget) {\n  scroll_view_t* scroll_view = SCROLL_VIEW(widget);\n  return_value_if_fail(widget != NULL && scroll_view != NULL, RET_BAD_PARAMS);\n\n  if (scroll_view->on_layout_children) {\n    scroll_view->on_layout_children(widget);\n  } else {\n    widget_layout_children_default(widget);\n    scroll_view_update_virtual_size(widget);\n    scroll_view_set_offset(widget,\n                           tk_min(scroll_view->xoffset, (scroll_view->virtual_w - widget->w)),\n                           tk_min(scroll_view->yoffset, (scroll_view->virtual_h - widget->h)));\n  }\n  if (scroll_view->snap_to_page) {\n    int32_t curr_page = scroll_view_get_curr_page(widget);\n    uint32_t max_page = scroll_view_get_page_max_number(widget);\n    scroll_view->xoffset_end = scroll_view->xoffset;\n    scroll_view->yoffset_end = scroll_view->yoffset;\n    scroll_view->fix_end_offset(widget);\n    scroll_view->xoffset = scroll_view->xoffset_end;\n    scroll_view->yoffset = scroll_view->yoffset_end;\n    if (scroll_view->curr_page != curr_page || scroll_view->max_page != max_page) {\n      scroll_view->max_page = max_page;\n      scroll_view->curr_page = curr_page;\n      widget_dispatch_simple_event(widget, EVT_PAGE_CHANGED);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t scroll_view_on_pointer_down(scroll_view_t* scroll_view, pointer_event_t* e) {\n  velocity_t* v = &(scroll_view->velocity);\n\n  velocity_reset(v);\n  scroll_view->down.x = e->x;\n  scroll_view->down.y = e->y;\n  scroll_view->xoffset_save = scroll_view->xoffset;\n  scroll_view->yoffset_save = scroll_view->yoffset;\n  scroll_view->xoffset_end = scroll_view->xoffset;\n  scroll_view->yoffset_end = scroll_view->yoffset;\n\n  velocity_update(v, e->e.time, e->x, e->y);\n\n  return RET_OK;\n}\n\nstatic ret_t scroll_view_on_scroll_done(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  scroll_view_t* scroll_view = SCROLL_VIEW(ctx);\n  return_value_if_fail(widget != NULL && scroll_view != NULL, RET_BAD_PARAMS);\n\n  scroll_view->wa = NULL;\n  scroll_view->curr_page = scroll_view_get_curr_page(widget);\n  widget_invalidate_force(widget, NULL);\n  widget_dispatch_simple_event(widget, EVT_SCROLL_END);\n  widget_dispatch_simple_event(widget, EVT_PAGE_CHANGED);\n\n  return RET_REMOVE;\n}\n\nstatic ret_t scroll_view_fix_end_offset_default(widget_t* widget) {\n  int32_t xoffset_end = 0;\n  int32_t yoffset_end = 0;\n  scroll_view_t* scroll_view = SCROLL_VIEW(widget);\n  return_value_if_fail(widget != NULL && scroll_view != NULL, RET_BAD_PARAMS);\n\n  xoffset_end = scroll_view->xoffset_end;\n  yoffset_end = scroll_view->yoffset_end;\n\n  xoffset_end = tk_max(xoffset_end, 0);\n  yoffset_end = tk_max(yoffset_end, 0);\n  xoffset_end = tk_min(xoffset_end, (scroll_view->virtual_w - widget->w));\n  yoffset_end = tk_min(yoffset_end, (scroll_view->virtual_h - widget->h));\n\n  if (scroll_view->virtual_w <= widget->w) {\n    xoffset_end = 0;\n  }\n\n  if (scroll_view->virtual_h <= widget->h) {\n    yoffset_end = 0;\n  }\n\n  scroll_view->xoffset_end = xoffset_end;\n  scroll_view->yoffset_end = yoffset_end;\n\n  return RET_OK;\n}\n\nstatic int32_t scroll_view_get_snap_to_page_offset_value(widget_t* widget, int32_t offset_end) {\n  uint32_t tmp = 0;\n  scroll_view_t* scroll_view = SCROLL_VIEW(widget);\n  return_value_if_fail(scroll_view != NULL, offset_end);\n  if (scroll_view->xslidable && !scroll_view->yslidable) {\n    tmp = widget->w;\n  } else if (!scroll_view->xslidable && scroll_view->yslidable) {\n    tmp = widget->h;\n  }\n  if (tmp != 0) {\n    int32_t n = (int32_t)((offset_end + tmp * 0.5f) / tmp);\n    if (scroll_view->move_to_page) {\n      if (scroll_view->curr_page - n > 1) {\n        n = scroll_view->curr_page - 1;\n      } else if (n - scroll_view->curr_page > 1) {\n        n = scroll_view->curr_page + 1;\n      }\n    }\n    offset_end = n * tmp;\n  }\n  return offset_end;\n}\n\nret_t scroll_view_scroll_to(widget_t* widget, int32_t xoffset_end, int32_t yoffset_end,\n                            int32_t duration) {\n  int32_t xoffset = 0;\n  int32_t yoffset = 0;\n  scroll_view_t* scroll_view = SCROLL_VIEW(widget);\n  return_value_if_fail(scroll_view != NULL, RET_FAIL);\n\n  if (scroll_view->snap_to_page) {\n    xoffset_end = scroll_view_get_snap_to_page_offset_value(widget, xoffset_end);\n    yoffset_end = scroll_view_get_snap_to_page_offset_value(widget, yoffset_end);\n  }\n\n  if (scroll_view->fix_end_offset) {\n    scroll_view->xoffset_end = xoffset_end;\n    scroll_view->yoffset_end = yoffset_end;\n    scroll_view->fix_end_offset(widget);\n    xoffset_end = scroll_view->xoffset_end;\n    yoffset_end = scroll_view->yoffset_end;\n  }\n\n  if (xoffset_end == scroll_view->xoffset && yoffset_end == scroll_view->yoffset) {\n    return RET_OK;\n  }\n\n  xoffset = scroll_view->xoffset;\n  yoffset = scroll_view->yoffset;\n\n  if (scroll_view->on_scroll_to) {\n    scroll_view->on_scroll_to(widget, xoffset_end, yoffset_end, duration);\n  }\n\n#ifndef WITHOUT_WIDGET_ANIMATORS\n  if (scroll_view->wa != NULL) {\n    widget_animator_scroll_t* wa = (widget_animator_scroll_t*)scroll_view->wa;\n    if (xoffset_end != scroll_view->xoffset) {\n      bool_t changed = wa->x_to != xoffset_end;\n      bool_t in_range = wa->x_to > 0 && wa->x_to < (scroll_view->virtual_w - widget->w);\n      if (changed && in_range) {\n        wa->x_to = xoffset_end;\n        wa->x_from = scroll_view->xoffset;\n      } else if (!scroll_view->yslidable) {\n        return RET_OK;\n      }\n    }\n\n    if (yoffset_end != scroll_view->yoffset) {\n      bool_t changed = wa->y_to != yoffset_end;\n      bool_t in_range = wa->y_to > 0 && wa->y_to < (scroll_view->virtual_h - widget->h);\n      if (changed && in_range) {\n        wa->y_to = yoffset_end;\n        wa->y_from = scroll_view->yoffset;\n      } else if (!scroll_view->xslidable) {\n        return RET_OK;\n      }\n    }\n\n    wa->base.now = 0;\n    wa->base.start_time = 0;\n  } else {\n    scroll_view->wa = widget_animator_scroll_create(widget, TK_ANIMATING_TIME, 0, EASING_SIN_INOUT);\n    return_value_if_fail(scroll_view->wa != NULL, RET_OOM);\n\n    widget_animator_scroll_set_params(scroll_view->wa, xoffset, yoffset, xoffset_end, yoffset_end);\n    widget_animator_on(scroll_view->wa, EVT_ANIM_END, scroll_view_on_scroll_done, scroll_view);\n    widget_animator_start(scroll_view->wa);\n    widget_dispatch_simple_event(widget, EVT_SCROLL_START);\n  }\n#else\n  scroll_view->xoffset = xoffset_end;\n  scroll_view->yoffset = yoffset_end;\n  scroll_view_on_scroll_done(widget, NULL);\n#endif /*WITHOUT_WIDGET_ANIMATORS*/\n  return RET_OK;\n}\n\nret_t scroll_view_scroll_delta_to(widget_t* widget, int32_t xoffset_delta, int32_t yoffset_delta,\n                                  int32_t duration) {\n  scroll_view_t* scroll_view = SCROLL_VIEW(widget);\n  return_value_if_fail(scroll_view != NULL, RET_FAIL);\n\n  scroll_view->xoffset_end = scroll_view->xoffset + xoffset_delta;\n  scroll_view->yoffset_end = scroll_view->yoffset + yoffset_delta;\n\n  return scroll_view_scroll_to(widget, scroll_view->xoffset_end, scroll_view->yoffset_end,\n                               duration);\n}\n\nstatic ret_t scroll_view_on_pointer_down_abort(scroll_view_t* scroll_view, pointer_event_t* e) {\n  widget_t* widget = WIDGET(scroll_view);\n  (void)e;\n\n  if (scroll_view->xslidable || scroll_view->yslidable) {\n    scroll_view_scroll_to(widget, scroll_view->xoffset_end, scroll_view->yoffset_end,\n                          TK_ANIMATING_TIME);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t scroll_view_on_pointer_up(scroll_view_t* scroll_view, pointer_event_t* e) {\n  widget_t* widget = WIDGET(scroll_view);\n  velocity_t* v = &(scroll_view->velocity);\n  int32_t move_dx = e->x - scroll_view->down.x;\n  int32_t move_dy = e->y - scroll_view->down.y;\n\n  velocity_update(v, e->e.time, e->x, e->y);\n  if (scroll_view->xslidable || scroll_view->yslidable) {\n#ifndef WITHOUT_WIDGET_ANIMATORS\n    int yv = v->yv;\n    int xv = v->xv;\n#else\n    int yv = 0;\n    int xv = 0;\n#endif /*WITHOUT_WIDGET_ANIMATORS*/\n    if (scroll_view->wa != NULL) {\n      widget_animator_scroll_t* wa = (widget_animator_scroll_t*)scroll_view->wa;\n      int32_t dx = wa->x_to - scroll_view->xoffset;\n      int32_t dy = wa->y_to - scroll_view->yoffset;\n      xv -= dx;\n      yv -= dy;\n      log_debug(\"dx=%d xv=%d dy=%d yv=%d\\n\", dx, xv, dy, yv);\n    }\n\n    if (scroll_view->xslidable) {\n      if (tk_abs(move_dx) > TK_CLICK_TOLERANCE) {\n        scroll_view->xoffset_end = scroll_view->xoffset - xv * scroll_view->xspeed_scale;\n      } else {\n        scroll_view->xoffset_end = scroll_view->xoffset - xv / scroll_view->xspeed_scale;\n      }\n    }\n\n    if (scroll_view->yslidable) {\n      if (tk_abs(move_dy) > TK_CLICK_TOLERANCE) {\n        scroll_view->yoffset_end = scroll_view->yoffset - yv * scroll_view->yspeed_scale;\n      } else {\n        scroll_view->yoffset_end = scroll_view->yoffset - yv / scroll_view->yspeed_scale;\n      }\n    }\n\n    scroll_view_scroll_to(widget, scroll_view->xoffset_end, scroll_view->yoffset_end,\n                          TK_ANIMATING_TIME);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t scroll_view_notify_scrolled(scroll_view_t* scroll_view) {\n  widget_t* widget = WIDGET(scroll_view);\n\n  if (scroll_view->on_scroll) {\n    scroll_view->on_scroll(widget, scroll_view->xoffset, scroll_view->yoffset);\n  }\n  widget_dispatch_simple_event(widget, EVT_SCROLL);\n\n  return RET_OK;\n}\n\nstatic ret_t scroll_view_on_pointer_move(scroll_view_t* scroll_view, pointer_event_t* e) {\n  int32_t dx = 0;\n  int32_t dy = 0;\n  velocity_t* v = NULL;\n  return_value_if_fail(scroll_view != NULL && e != NULL, RET_BAD_PARAMS);\n  v = &(scroll_view->velocity);\n  dx = e->x - scroll_view->down.x;\n  dy = e->y - scroll_view->down.y;\n  velocity_update(v, e->e.time, e->x, e->y);\n\n  if (scroll_view->wa == NULL) {\n    if (scroll_view->xslidable && dx) {\n      scroll_view_set_xoffset(scroll_view, scroll_view->xoffset_save - dx);\n    }\n\n    if (scroll_view->yslidable && dy) {\n      scroll_view_set_yoffset(scroll_view, scroll_view->yoffset_save - dy);\n    }\n\n    scroll_view_notify_scrolled(scroll_view);\n  }\n  scroll_view->first_move_after_down = FALSE;\n\n  return RET_OK;\n}\n\nstatic bool_t scroll_view_is_dragged(widget_t* widget, pointer_event_t* evt) {\n  int32_t delta = 0;\n  scroll_view_t* scroll_view = SCROLL_VIEW(widget);\n  return_value_if_fail(scroll_view != NULL, FALSE);\n  if (scroll_view->xslidable && scroll_view->yslidable) {\n    int32_t xdelta = evt->x - scroll_view->down.x;\n    int32_t ydelta = evt->y - scroll_view->down.y;\n    delta = tk_abs(xdelta) > tk_abs(ydelta) ? xdelta : ydelta;\n  } else if (scroll_view->yslidable) {\n    delta = evt->y - scroll_view->down.y;\n  } else {\n    delta = evt->x - scroll_view->down.x;\n  }\n\n  return scroll_view->snap_to_page || (tk_abs(delta) >= TK_DRAG_THRESHOLD);\n}\n\nstatic ret_t scroll_view_on_event(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  uint16_t type = e->type;\n  scroll_view_t* scroll_view = SCROLL_VIEW(widget);\n  return_value_if_fail(scroll_view != NULL, RET_BAD_PARAMS);\n\n  switch (type) {\n    case EVT_POINTER_DOWN:\n      scroll_view->pressed = TRUE;\n      scroll_view->dragged = FALSE;\n      widget_grab(widget->parent, widget);\n      scroll_view->first_move_after_down = TRUE;\n      scroll_view_on_pointer_down(scroll_view, (pointer_event_t*)e);\n      break;\n    case EVT_POINTER_DOWN_ABORT:\n      scroll_view_on_pointer_down_abort(scroll_view, (pointer_event_t*)e);\n      if (scroll_view->pressed) {\n        widget_ungrab(widget->parent, widget);\n      }\n      scroll_view->pressed = FALSE;\n      scroll_view->dragged = FALSE;\n      break;\n    case EVT_POINTER_UP: {\n      pointer_event_t* evt = (pointer_event_t*)e;\n      if (scroll_view->pressed && scroll_view_is_dragged(widget, evt)) {\n        scroll_view_on_pointer_up(scroll_view, (pointer_event_t*)e);\n      }\n      scroll_view->pressed = FALSE;\n      scroll_view->dragged = FALSE;\n      widget_ungrab(widget->parent, widget);\n      break;\n    }\n    case EVT_POINTER_MOVE: {\n      pointer_event_t* evt = (pointer_event_t*)e;\n      if (!scroll_view->pressed || !(scroll_view->xslidable || scroll_view->yslidable)) {\n        break;\n      }\n\n      if (scroll_view->dragged) {\n        scroll_view_on_pointer_move(scroll_view, evt);\n        widget_invalidate_force(widget, NULL);\n      } else {\n        if (scroll_view_is_dragged(widget, evt)) {\n          pointer_event_t abort = *evt;\n\n          abort.e.type = EVT_POINTER_DOWN_ABORT;\n          widget_dispatch_event_to_target_recursive(widget, (event_t*)(&abort));\n\n          scroll_view->dragged = TRUE;\n        }\n      }\n\n      ret = scroll_view->dragged ? RET_STOP : RET_OK;\n      break;\n    }\n    default:\n      break;\n  }\n\n  return ret;\n}\n\nstatic ret_t scroll_view_on_paint_children(widget_t* widget, canvas_t* c) {\n  rect_t r;\n  rect_t r_save;\n  int32_t xoffset = 0;\n  int32_t yoffset = 0;\n  vgcanvas_t* vg = NULL;\n  scroll_view_t* scroll_view = SCROLL_VIEW(widget);\n  return_value_if_fail(widget != NULL && c != NULL && scroll_view != NULL, RET_BAD_PARAMS);\n  vg = canvas_get_vgcanvas(c);\n  xoffset = -scroll_view->xoffset;\n  yoffset = -scroll_view->yoffset;\n  r = rect_init(c->ox, c->oy, widget->w, widget->h);\n\n  canvas_translate(c, xoffset, yoffset);\n  canvas_get_clip_rect(c, &r_save);\n\nr = ",
    "raw_res": "rect_init(c->ox, c->oy, widget->w, widget->h);",
    "prompt_res": "rect_intersect(&r, &r_save);",
    "gt": "rect_intersect(&r, &r_save);"
  },
  {
    "id": 1773,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/ext_widgets/gauge/gauge_pointer.c",
    "input": "﻿/**\n * File:   gauge_pointer.h\n * Author: AWTK Develop Team\n * Brief:  gauge_pointer\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-09-05 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/matrix.h\"\n#include \"svg/bsvg_draw.h\"\n#include \"base/widget_vtable.h\"\n#include \"gauge/gauge_pointer.h\"\n#include \"base/image_manager.h\"\n#include \"base/assets_manager.h\"\n\n#define ANCHOR_PX_STR_LEN 2\n#define DEFAULT_POINTER_SIZE 0.6f\n\nstatic rect_t gauge_pointer_calc_dirty_rect(widget_t* widget, int32_t img_w, int32_t img_h) {\n  xy_t x = 0;\n  xy_t y = 0;\n  matrix_t m;\n  xy_t min_x = 0;\n  xy_t min_y = 0;\n  xy_t max_x = 0;\n  xy_t max_y = 0;\n  int32_t w = img_w;\n  int32_t h = img_h;\n  int32_t ox = widget->x;\n  int32_t oy = widget->y;\n  gauge_pointer_t* gauge_pointer = GAUGE_POINTER(widget);\n  float_t rotation = TK_D2R(gauge_pointer->angle);\n  float_t anchor_x = tk_eval_ratio_or_px(gauge_pointer->anchor_x, widget->w);\n  float_t anchor_y = tk_eval_ratio_or_px(gauge_pointer->anchor_y, widget->h);\n\n  matrix_init(&m);\n  matrix_translate(&m, ox, oy);\n  matrix_translate(&m, anchor_x, anchor_y);\n  matrix_rotate(&m, rotation);\n  matrix_translate(&m, -anchor_x, -anchor_y);\n\n  matrix_transform_point(&m, 0, 0, &(x), &(y));\n  min_x = x;\n  max_x = x;\n  min_y = y;\n  max_y = y;\n\n  matrix_transform_point(&m, w, 0, &(x), &(y));\n  min_x = tk_min(min_x, x);\n  max_x = tk_max(max_x, x);\n  min_y = tk_min(min_y, y);\n  max_y = tk_max(max_y, y);\n\n  matrix_transform_point(&m, 0, h, &(x), &(y));\n  min_x = tk_min(min_x, x);\n  max_x = tk_max(max_x, x);\n  min_y = tk_min(min_y, y);\n  max_y = tk_max(max_y, y);\n\n  matrix_transform_point(&m, w, h, &(x), &(y));\n  min_x = tk_min(min_x, x);\n  max_x = tk_max(max_x, x);\n  min_y = tk_min(min_y, y);\n  max_y = tk_max(max_y, y);\n\n  return rect_init(min_x, min_y, max_x - min_x, max_y - min_y);\n}\n\nstatic ret_t gauge_pointer_invalidate(widget_t* widget, const rect_t* rect) {\n  rect_t r;\n  int32_t w = 0;\n  int32_t h = 0;\n  widget_t* parent = widget->parent;\n  gauge_pointer_t* gauge_pointer = GAUGE_POINTER(widget);\n\n  if (gauge_pointer->bsvg_asset != NULL || gauge_pointer->image == NULL) {\n    if (gauge_pointer->bsvg_asset != NULL) {\n      bsvg_t bsvg;\n      const asset_info_t* asset = gauge_pointer->bsvg_asset;\n\n      bsvg_init(&bsvg, (const uint32_t*)asset->data, asset->size);\n      w = bsvg.header->w;\n      h = bsvg.header->h;\n    } else {\n      w = widget->w;\n      h = widget->h * DEFAULT_POINTER_SIZE * 1.2f;\n    }\n  } else {\n    bitmap_t bitmap;\n    if (parent != NULL && !parent->destroying &&\n        widget_load_image(widget, gauge_pointer->image, &bitmap) == RET_OK) {\n      w = bitmap.w;\n      h = bitmap.h;\n    } else {\n      return RET_OK;\n    }\n  }\n\n  r = gauge_pointer_calc_dirty_rect(widget, w, h);\n  return widget_invalidate(parent, &r);\n}\n\nret_t gauge_pointer_set_angle(widget_t* widget, float_t angle) {\n  gauge_pointer_t* gauge_pointer = GAUGE_POINTER(widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (gauge_pointer->angle != angle) {\n    value_change_event_t evt;\n    value_change_event_init(&evt, EVT_VALUE_WILL_CHANGE, widget);\n    value_set_float(&(evt.old_value), gauge_pointer->angle);\n    value_set_float(&(evt.new_value), angle);\n\n    widget_invalidate(widget, NULL);\n    if (widget_dispatch(widget, (event_t*)&evt) != RET_STOP) {\n      gauge_pointer->angle = angle;\n      evt.e.type = EVT_VALUE_CHANGED;\n      widget_dispatch(widget, (event_t*)&evt);\n      widget_invalidate(widget, NULL);\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t gauge_pointer_set_anchor_for_str(widget_t* widget, const char* anchor, bool_t is_x) {\n  gauge_pointer_t* gauge_pointer = GAUGE_POINTER(widget);\n\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(anchor != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(gauge_pointer != NULL, RET_BAD_PARAMS);\n\n  if (is_x) {\n    gauge_pointer->anchor_x = tk_str_copy(gauge_pointer->anchor_x, anchor);\n  } else {\n    gauge_pointer->anchor_y = tk_str_copy(gauge_pointer->anchor_y, anchor);\n  }\n\n  return RET_OK;\n}\n\nret_t gauge_pointer_set_anchor(widget_t* widget, const char* anchor_x, const char* anchor_y) {\n  gauge_pointer_t* gauge_pointer = GAUGE_POINTER(widget);\n  return_value_if_fail(gauge_pointer != NULL, RET_BAD_PARAMS);\n\n  gauge_pointer_set_anchor_for_str(widget, anchor_x, TRUE);\n  gauge_pointer_set_anchor_for_str(widget, anchor_y, FALSE);\n\n  return RET_OK;\n}\n\nstatic ret_t gauge_pointer_load_svg_asset(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  gauge_pointer_t* gauge_pointer = GAUGE_POINTER(widget);\n  return_value_if_fail(gauge_pointer != NULL, RET_BAD_PARAMS);\n\n  if (gauge_pointer->image != NULL) {\n    const asset_info_t* asset = widget_load_asset(widget, ASSET_TYPE_IMAGE, gauge_pointer->image);\n\n    if (gauge_pointer->bsvg_asset != NULL) {\n      widget_unload_asset(widget, gauge_pointer->bsvg_asset);\n      gauge_pointer->bsvg_asset = NULL;\n    }\n    if (asset != NULL) {\n      if (asset->subtype == ASSET_TYPE_IMAGE_BSVG) {\n        gauge_pointer->bsvg_asset = asset;\n      } else {\n        widget_unload_asset(widget, asset);\n      }\n    }\n  }\n\n  return RET_REMOVE;\n}\n\nret_t gauge_pointer_set_image(widget_t* widget, const char* image) {\n  widget_t* win = widget_get_window(widget);\n  gauge_pointer_t* gauge_pointer = GAUGE_POINTER(widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(image != NULL && gauge_pointer != NULL, RET_BAD_PARAMS);\n  gauge_pointer->image = tk_str_copy(gauge_pointer->image, image);\n\n  if (gauge_pointer->image != NULL) {\n    if (win != NULL) {\n      gauge_pointer_load_svg_asset(widget, NULL);\n    } else {\n      widget_on(widget, EVT_BEFORE_PAINT, gauge_pointer_load_svg_asset, widget);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t gauge_pointer_get_prop(widget_t* widget, const char* name, value_t* v) {\n  gauge_pointer_t* gauge_pointer = GAUGE_POINTER(widget);\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, GAUGE_POINTER_PROP_ANGLE) || tk_str_eq(name, WIDGET_PROP_VALUE)) {\n    value_set_float(v, gauge_pointer->angle);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_IMAGE)) {\n    value_set_str(v, gauge_pointer->image);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_ANCHOR_X)) {\n    value_set_str(v, gauge_pointer->anchor_x);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_ANCHOR_Y)) {\n    value_set_str(v, gauge_pointer->anchor_y);\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t gauge_pointer_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, GAUGE_POINTER_PROP_ANGLE) || tk_str_eq(name, WIDGET_PROP_VALUE)) {\n    return gauge_pointer_set_angle(widget, value_float(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_IMAGE)) {\n    return gauge_pointer_set_image(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_ANCHOR_X)) {\n    return gauge_pointer_set_anchor_for_str(widget, value_str(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_ANCHOR_Y)) {\n    return gauge_pointer_set_anchor_for_str(widget, value_str(v), FALSE);\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t gauge_pointer_on_destroy(widget_t* widget) {\n  gauge_pointer_t* gauge_pointer = GAUGE_POINTER(widget);\n  return_value_if_fail(widget != NULL && gauge_pointer != NULL, RET_BAD_PARAMS);\n\n  TKMEM_FREE(gauge_pointer->image);\n  if (gauge_pointer->bsvg_asset != NULL) {\n    widget_unload_asset(widget, gauge_pointer->bsvg_asset);\n  }\n  TKMEM_FREE(gauge_pointer->anchor_x);\n  TKMEM_FREE(gauge_pointer->anchor_y);\n\n  return RET_OK;\n}\n\nstatic ret_t gauge_pointer_paint_default(widget_t* widget, vgcanvas_t* vg) {\n  float_t w, h;\n  float_t cx, cy;\n  color_t bg, fg;\n  color_t black = color_init(0, 0, 0, 0xff);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  w = widget->w;\n  h = widget->h;\n  cx = w * 0.5f;\n  cy = h * 0.5f;\n  bg = style_get_color(widget->astyle, STYLE_ID_BG_COLOR, black);\n  fg = style_get_color(widget->astyle, STYLE_ID_FG_COLOR, black);\n\n  vgcanvas_begin_path(vg);\n  vgcanvas_move_to(vg, cx, 0);\n  vgcanvas_line_to(vg, cx, cx + h * DEFAULT_POINTER_SIZE);\n  vgcanvas_set_line_width(vg, 2);\n  vgcanvas_set_stroke_color(vg, bg);\n  vgcanvas_stroke(vg);\n\n  vgcanvas_begin_path(vg);\n  vgcanvas_set_fill_color(vg, fg);\n  vgcanvas_arc(vg, cx, cy, cx, 0, M_PI * 2, FALSE);\n  vgcanvas_fill(vg);\n\n  return RET_OK;\n}\n\nstatic ret_t gauge_pointer_on_paint_self(widget_t* widget, canvas_t* c) {\n  bitmap_t bitmap;\n  float_t rotation = 0;\n  float_t anchor_x = 0;\n  float_t anchor_y = 0;\n  vgcanvas_t* vg = canvas_get_vgcanvas(c);\n  gauge_pointer_t* gauge_pointer = GAUGE_POINTER(widget);\n  return_value_if_fail(gauge_pointer != NULL && widget != NULL, RET_BAD_PARAMS);\n\n  anchor_x = tk_eval_ratio_or_px(gauge_pointer->anchor_x, widget->w);\n  anchor_y = tk_eval_ratio_or_px(gauge_pointer->anchor_y, widget->h);\n\n  rotation = TK_D2R(gauge_pointer->angle);\n\n  vgcanvas_save(vg);\n  vgcanvas_translate(vg, c->ox, c->oy);\n  vgcanvas_translate(vg, anchor_x, anchor_y);\n  vgcanvas_rotate(vg, rotation);\n  vgcanvas_translate(vg, -anchor_x, -anchor_y);\n\n  if (gauge_pointer->bsvg_asset != NULL) {\n    bsvg_t bsvg;\n    style_t* style = widget->astyle;\n    color_t black = color_init(0, 0, 0, 0xff);\ncolor_t bg = ",
    "raw_res": "0;",
    "prompt_res": "style_get_color(style, STYLE_ID_BG_COLOR, black);",
    "gt": "style_get_color(style, STYLE_ID_BG_COLOR, black);"
  },
  {
    "id": 1781,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/widget_animators/widget_animator_factory.c",
    "input": "﻿/**\n * File:   widget_animator_factory.c\n * Author: AWTK Develop Team\n * Brief:  widget animator factory\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-10-21 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"base/enums.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/func_call_parser.h\"\n#include \"base/widget_animator_factory.h\"\n\n#ifndef WITHOUT_WIDGET_ANIMATOR\n\n#include \"widget_animators/widget_animator_prop.h\"\n#include \"widget_animators/widget_animator_move.h\"\n#include \"widget_animators/widget_animator_scale.h\"\n\ntypedef struct _move_params_t {\n  xy_t x_to;\n  xy_t y_to;\n  xy_t x_from;\n  xy_t y_from;\n} move_params_t;\n\ntypedef struct _scale_params_t {\n  float_t x_to;\n  float_t y_to;\n  float_t x_from;\n  float_t y_from;\n} scale_params_t;\n\ntypedef struct _prop_params_t {\n  float_t to;\n  float_t from;\n} prop_params_t;\n\ntypedef struct _animator_params_t {\n  char type[TK_NAME_LEN + 1];\n  char name[TK_NAME_LEN + 1];\n\n  widget_t* widget;\n  union {\n    move_params_t move;\n    scale_params_t scale;\n    prop_params_t prop;\n  } u;\n\n  uint32_t delay;\n  int32_t easing;\n  uint32_t duration;\n  int32_t yoyo_times;\n  int32_t repeat_times;\n\n  float_t time_scale;\n  bool_t auto_start;\n  bool_t auto_destroy;\n\n} animator_params_t;\n\ntypedef struct _widget_animator_parser_t {\n  func_call_parser_t base;\n\n  animator_params_t params;\n} widget_animator_parser_t;\n\nstatic ret_t parser_on_name(func_call_parser_t* parser, const char* func_name) {\n  value_t v;\n  widget_animator_parser_t* p = (widget_animator_parser_t*)parser;\n  widget_t* widget = p->params.widget;\n  const char* type = p->params.type;\n\n  tk_strncpy(p->params.type, func_name, TK_NAME_LEN);\n  if (tk_str_eq(type, \"move\")) {\n    move_params_t* params = &p->params.u.move;\n\n    params->x_from = widget->x;\n    params->y_from = widget->y;\n    params->x_to = widget->x;\n    params->y_to = widget->y;\n  } else if (tk_str_eq(type, \"scale\")) {\n    float_t scale_x = 1.0f;\n    float_t scale_y = 1.0f;\n    scale_params_t* params = &p->params.u.scale;\n\n    if (widget_get_prop(widget, WIDGET_PROP_SCALE_X, &v) == RET_OK) {\n      scale_x = value_float(&v);\n    }\n    if (widget_get_prop(widget, WIDGET_PROP_SCALE_Y, &v) == RET_OK) {\n      scale_y = value_float(&v);\n    }\n\n    params->x_from = scale_x;\n    params->y_from = scale_y;\n    params->x_to = scale_x;\n    params->y_to = scale_y;\n  } else {\n    float_t value = 0;\n    const char* prop_name = p->params.type;\n    prop_params_t* params = &p->params.u.prop;\n\n    if (widget_get_prop(widget, prop_name, &v) == RET_OK) {\n      value = value_float(&v);\n    }\n\n    params->from = value;\n    params->to = value;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t parser_on_param(func_call_parser_t* parser, const char* name, const char* value) {\n  widget_animator_parser_t* p = (widget_animator_parser_t*)parser;\n  const char* type = p->params.type;\n\n  if (tk_str_eq(type, \"move\")) {\n    move_params_t* move = &p->params.u.move;\n    if (tk_str_eq(name, \"x_from\")) {\n      move->x_from = tk_atoi(value);\n      return RET_OK;\n    } else if (tk_str_eq(name, \"y_from\")) {\n      move->y_from = tk_atoi(value);\n      return RET_OK;\n    } else if (tk_str_eq(name, \"x_to\")) {\n      move->x_to = tk_atoi(value);\n      return RET_OK;\n    } else if (tk_str_eq(name, \"y_to\")) {\n      move->y_to = tk_atoi(value);\n      return RET_OK;\n    }\n  } else if (tk_str_eq(type, \"scale\")) {\n    scale_params_t* scale = &p->params.u.scale;\n    if (tk_str_eq(name, \"x_from\")) {\n      scale->x_from = tk_atof(value);\n      return RET_OK;\n    } else if (tk_str_eq(name, \"y_from\")) {\n      scale->y_from = tk_atof(value);\n      return RET_OK;\n    } else if (tk_str_eq(name, \"x_to\")) {\n      scale->x_to = tk_atof(value);\n      return RET_OK;\n    } else if (tk_str_eq(name, \"y_to\")) {\n      scale->y_to = tk_atof(value);\n      return RET_OK;\n    }\n  } else {\n    prop_params_t* v = &p->params.u.prop;\n    if (tk_str_eq(name, \"from\")) {\n      v->from = tk_atof(value);\n      return RET_OK;\n    } else if (tk_str_eq(name, \"to\")) {\n      v->to = tk_atof(value);\n      return RET_OK;\n    }\n  }\n\n  switch (name[0]) {\n    case 'y': /*yoyo_times*/\n    {\n      p->params.yoyo_times = tk_atoi(value);\n      break;\n    }\n    case 't': /*time_scale*/\n    {\n      p->params.time_scale = tk_atof(value);\n      break;\n    }\n    case 'n': /*name*/\n    {\n      tk_strncpy(p->params.name, value, TK_NAME_LEN);\n      break;\n    }\n    case 'r': /*repeat_times*/\n    {\n      p->params.repeat_times = tk_atoi(value);\n      break;\n    }\n    case 'd': /*duration|delay*/\n    {\n      if (tk_str_eq(name, \"delay\")) {\n        p->params.delay = tk_atoi(value);\n      } else if (tk_str_eq(name, \"duration\")) {\n        p->params.duration = tk_atoi(value);\n      }\n      break;\n    }\n    case 'a': /*auto_start|auto_destroy*/\n    {\n      if (tk_str_eq(name, \"auto_start\")) {\n        p->params.auto_start = tk_atob(value);\n      } else if (tk_str_eq(name, \"auto_destroy\")) {\n        p->params.auto_destroy = tk_atob(value);\n      }\n      break;\n    }\n    case 'e': {\n      const key_type_value_t* easing = easing_type_find(value);\n      p->params.easing = easing != NULL ? (int32_t)(easing->value) : -1;\n      break;\n    }\n    default:\n      break;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_animator_parser_parse(widget_animator_parser_t* parser, const char* str,\n                                          widget_t* widget) {\n  memset(parser, 0x00, sizeof(*parser));\n  func_call_parser_init(&(parser->base), str, strlen(str));\n\n  parser->params.delay = 0;\n  parser->params.duration = 500;\n  parser->params.yoyo_times = -1;\n  parser->params.repeat_times = -1;\n  parser->params.auto_start = TRUE;\n  parser->params.auto_destroy = TRUE;\n  parser->params.time_scale = 1;\n  parser->params.easing = EASING_SIN_INOUT;\n\n  parser->params.widget = widget;\n  parser->base.on_name = parser_on_name;\n  parser->base.on_param = parser_on_param;\n  parser->base.on_done = NULL;\n\n  return func_call_parser_parse(&(parser->base));\n}\n\nwidget_animator_t* widget_animator_create(widget_t* widget, const char* params) {\n  uint32_t delay = 0;\n  uint32_t easing = 0;\n  uint32_t duration = 0;\n  const char* type = NULL;\n  widget_animator_t* wa = NULL;\n  widget_animator_parser_t parser;\n  return_value_if_fail(params != NULL && widget != NULL, NULL);\n\n  widget_animator_parser_parse(&parser, params, widget);\n\n  delay = parser.params.delay;\n  easing = parser.params.easing;\n  duration = parser.params.duration;\n\n  type = parser.params.type;\n  if (tk_str_eq(type, \"move\")) {\n    move_params_t* move = &parser.params.u.move;\n    wa = widget_animator_move_create(widget, duration, delay, (easing_type_t)easing);\n\n    if(wa != NULL)\n      widget_animator_move_set_params(wa, move->x_from, move->y_from, move->x_to, move->y_to);\n    else\n      log_error(\"move wa is null!\");\n  } else if (tk_str_eq(type, \"scale\")) {\n    scale_params_t* scale = &parser.params.u.scale;\n    wa = widget_animator_scale_create(widget, duration, delay, (easing_type_t)easing);\n\n    if(wa != NULL)\n      widget_animator_scale_set_params(wa, scale->x_from, scale->y_from, scale->x_to, scale->y_to);\n    else\n      log_error(\"scale wa is null!\");\n  } else {\n    const char* prop_name = parser.params.type;\n    prop_params_t* param = &parser.params.u.prop;\n\nwa = ",
    "raw_res": "widget_animator_prop_create(widget, duration, delay, (easing_type_t)easing);",
    "prompt_res": "widget_animator_prop_create(widget, duration, delay, (easing_type_t)easing, prop_name);",
    "gt": "widget_animator_prop_create(widget, duration, delay, (easing_type_t)easing, prop_name);"
  },
  {
    "id": 1816,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/platforms/pc/fs_os.c",
    "input": "﻿#include \"tkc/types_def.h\"\n#undef ANDROID\n#ifdef ANDROID\n#include \"SDL.h\"\n#endif /*ANDROID*/\n\n#if defined(__APPLE__) || defined(LINUX)\n#include <unistd.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <pwd.h>\n#elif defined(WIN32)\n#include <stdio.h>\n#include <windows.h>\n#include <io.h>\n#include <direct.h>\n#include <Shlobj.h>\n#include <fileapi.h>\n#define unlink _unlink\n#define rename MoveFileA\n#define ftruncate _chsize\n#include \"./dirent.inc\"\n#include \"tkc/utf8.h\"\n#include \"tkc/mem.h\"\n#endif\n\n#if defined(__APPLE__)\n#include <mach-o/dyld.h>\n#endif /*__APPLE__*/\n\n#include <stdio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include \"tkc/fs.h\"\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n\n#if defined(WIN32) && !defined(MINGW)\nstatic ret_t fs_stat_info_from_stat(fs_stat_info_t* fst, struct _stat64i32* st) {\n#else\nstatic ret_t fs_stat_info_from_stat(fs_stat_info_t* fst, struct stat* st) {\n#endif /*WIN32*/\n  return_value_if_fail(fst != NULL && st != NULL, RET_BAD_PARAMS);\n\n  memset(fst, 0x00, sizeof(fs_stat_info_t));\n  fst->dev = st->st_dev;\n  fst->ino = st->st_ino;\n  fst->mode = st->st_mode;\n  fst->nlink = st->st_nlink;\n  fst->uid = st->st_uid;\n  fst->gid = st->st_gid;\n  fst->rdev = st->st_rdev;\n  fst->size = st->st_size;\n  fst->atime = st->st_atime;\n  fst->mtime = st->st_mtime;\n  fst->ctime = st->st_ctime;\n  fst->is_dir = (st->st_mode & S_IFDIR) != 0;\n#ifdef S_IFLNK\n  fst->is_link = (st->st_mode & S_IFLNK) != 0;\n#else\n  fst->is_link = FALSE;\n#endif /*S_IFLNK*/\n  fst->is_reg_file = (st->st_mode & S_IFREG) != 0;\n\n  return RET_OK;\n}\n\nstatic int32_t fs_os_file_read(fs_file_t* file, void* buffer, uint32_t size) {\n  FILE* fp = (FILE*)(file->data);\n\n  return (int32_t)fread(buffer, 1, size, fp);\n}\n\nstatic int32_t fs_os_file_write(fs_file_t* file, const void* buffer, uint32_t size) {\n  FILE* fp = (FILE*)(file->data);\n\n  return fwrite(buffer, 1, size, fp);\n}\n\nstatic int32_t fs_os_file_printf(fs_file_t* file, const char* const format_str, va_list vl) {\n  FILE* fp = (FILE*)(file->data);\n\n  return vfprintf(fp, format_str, vl);\n}\n\nstatic ret_t fs_os_file_seek(fs_file_t* file, int32_t offset) {\n  FILE* fp = (FILE*)(file->data);\n\n  return fseek(fp, offset, SEEK_SET) == 0 ? RET_OK : RET_FAIL;\n}\n\nstatic int64_t fs_os_file_tell(fs_file_t* file) {\n  FILE* fp = (FILE*)(file->data);\n\n  return ftell(fp);\n}\n\nstatic int64_t fs_os_file_size(fs_file_t* file) {\n  fs_stat_info_t st;\n\n  if (fs_file_stat(file, &st) == RET_OK && st.is_reg_file) {\n    return st.size;\n  } else {\n    return -1;\n  }\n}\n\nstatic ret_t fs_os_file_stat(fs_file_t* file, fs_stat_info_t* fst) {\n  int rc = 0;\n  FILE* fp = (FILE*)(file->data);\n#if defined(WIN32) && !defined(MINGW)\n  struct _stat64i32 st;\n  rc = _fstat64i32(fileno(fp), &st);\n#else\n  struct stat st;\n  rc = fstat(fileno(fp), &st);\n#endif\n  if (rc == 0) {\n    return fs_stat_info_from_stat(fst, &st);\n  } else {\n    memset(fst, 0x00, sizeof(fs_stat_info_t));\n\n    return RET_FAIL;\n  }\n}\n\nstatic ret_t fs_os_file_sync(fs_file_t* file) {\n  FILE* fp = (FILE*)(file->data);\n#ifdef WIN32\n  return fflush(fp) == 0 ? RET_OK : RET_FAIL;\n#else\n  fflush(fp);\n  return fsync(fileno(fp)) == 0 ? RET_OK : RET_FAIL;\n#endif /*WIN32*/\n}\n\nstatic ret_t fs_os_file_truncate(fs_file_t* file, int32_t size) {\n  FILE* fp = (FILE*)(file->data);\n\n  return ftruncate(fileno(fp), size) == 0 ? RET_OK : RET_FAIL;\n}\n\nstatic bool_t fs_os_file_eof(fs_file_t* file) {\n  FILE* fp = (FILE*)(file->data);\n\n  return feof(fp) != 0;\n}\n\nstatic ret_t fs_os_file_close(fs_file_t* file) {\n  FILE* fp = (FILE*)(file->data);\n  fclose(fp);\n  TKMEM_FREE(file);\n\n  return RET_OK;\n}\n\nstatic ret_t fs_os_dir_rewind(fs_dir_t* dir) {\n  DIR* d = (DIR*)(dir->data);\n\n  rewinddir(d);\n\n  return RET_OK;\n}\n\nstatic ret_t fs_os_dir_read(fs_dir_t* dir, fs_item_t* item) {\n  DIR* d = (DIR*)(dir->data);\n  struct dirent* ent = readdir(d);\n\n  memset(item, 0x00, sizeof(fs_item_t));\n  if (ent != NULL) {\n    uint8_t type = ent->d_type;\n    item->is_dir = (type & DT_DIR) != 0;\n    item->is_link = (type & DT_LNK) != 0;\n    item->is_reg_file = (type & DT_REG) != 0;\n#ifdef WIN32\n    str_t str;\n    str_init(&str, wcslen(ent->d_name) * 4 + 1);\n    str_from_wstr_with_len(&str, ent->d_name, wcslen(ent->d_name));\n    tk_strncpy(item->name, str.str, MAX_PATH);\n    str_reset(&str);\n#else\n    tk_strncpy(item->name, ent->d_name, MAX_PATH);\n#endif\n    return RET_OK;\n  } else {\n    return RET_FAIL;\n  }\n}\n\nstatic ret_t fs_os_dir_close(fs_dir_t* dir) {\n  DIR* d = (DIR*)dir->data;\n  closedir(d);\n  TKMEM_FREE(dir);\n\n  return RET_OK;\n}\n\nstatic const fs_file_vtable_t s_file_vtable = {.read = fs_os_file_read,\n                                               .write = fs_os_file_write,\n                                               .printf = fs_os_file_printf,\n                                               .seek = fs_os_file_seek,\n                                               .tell = fs_os_file_tell,\n                                               .size = fs_os_file_size,\n                                               .stat = fs_os_file_stat,\n                                               .sync = fs_os_file_sync,\n                                               .truncate = fs_os_file_truncate,\n                                               .eof = fs_os_file_eof,\n                                               .close = fs_os_file_close};\n\nstatic fs_file_t* fs_file_create(FILE* fp) {\n  fs_file_t* f = NULL;\n  return_value_if_fail(fp != NULL, NULL);\n\n  f = TKMEM_ZALLOC(fs_file_t);\n  if (f != NULL) {\n    f->vt = &s_file_vtable;\n    f->data = fp;\n  } else {\n    fclose(fp);\n  }\n\n  return f;\n}\n\nstatic fs_file_t* fs_os_open_file(fs_t* fs, const char* name, const char* mode) {\n  (void)fs;\n  return_value_if_fail(name != NULL && mode != NULL, NULL);\n#ifdef WIN32\n  fs_file_t* file = NULL;\n  wchar_t* w_name = tk_wstr_dup_utf8(name);\nwchar_t* w_mode = ",
    "raw_res": "0;",
    "prompt_res": "tk_wstr_dup_utf8(mode);",
    "gt": "tk_wstr_dup_utf8(mode);"
  },
  {
    "id": 1934,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/conf_io/conf_node.c",
    "input": "﻿/**\n * File:   conf_node.c\n * Author: AWTK Develop Team\n * Brief:  conf node\n *\n * Copyright (c) 2020 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2020-05-11 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"conf_io/conf_node.h\"\n\nstatic ret_t conf_node_destroy(conf_doc_t* doc, conf_node_t* node);\n\nconf_node_t* conf_node_get_first_child(conf_node_t* node) {\n  return_value_if_fail(node != NULL, NULL);\n  if (node->value_type != CONF_NODE_VALUE_NODE && node->value_type != CONF_NODE_VALUE_NONE) {\n    return NULL;\n  }\n\n  return node->value.first_child;\n}\n\nret_t conf_node_set_first_child(conf_node_t* node, conf_node_t* child) {\n  return_value_if_fail(node != NULL, RET_BAD_PARAMS);\n  node->value_type = CONF_NODE_VALUE_NODE;\n  node->value.first_child = child;\n\n  if (child != NULL) {\n    child->parent = node;\n  }\n\n  return RET_OK;\n}\n\nconf_doc_t* conf_doc_create(uint32_t prealloc_nodes_nr) {\n  uint32_t size = prealloc_nodes_nr * sizeof(conf_node_t);\n  conf_doc_t* doc = TKMEM_ZALLOC(conf_doc_t);\n  return_value_if_fail(doc != NULL, NULL);\n\n  if (prealloc_nodes_nr > 0) {\n    doc->prealloc_nodes = TKMEM_ALLOC(size);\n    if (doc->prealloc_nodes == NULL) {\n      TKMEM_FREE(doc);\n    } else {\n      memset(doc->prealloc_nodes, 0x00, size);\n      doc->prealloc_nodes_nr = prealloc_nodes_nr;\n    }\n  }\n  doc->max_deep_level = 0xffff;\n  tokenizer_init(&(doc->tokenizer), \"\", 0, \".\");\n\n  return doc;\n}\n\nstatic conf_node_t* conf_doc_find_free_node(conf_doc_t* doc) {\n  uint32_t i = 0;\n  return_value_if_fail(doc != NULL, NULL);\n  if (doc->prealloc_nodes_used >= doc->prealloc_nodes_nr) {\n    return NULL;\n  }\n\n  for (i = doc->prealloc_nodes_index; i < doc->prealloc_nodes_nr; i++) {\n    conf_node_t* iter = doc->prealloc_nodes + i;\n    if (iter->node_type == CONF_NODE_NONE) {\n      doc->prealloc_nodes_index = i;\n      doc->prealloc_nodes_used++;\n      return iter;\n    }\n  }\n\n  for (i = 0; i < doc->prealloc_nodes_index; i++) {\n    conf_node_t* iter = doc->prealloc_nodes + i;\n    if (iter->node_type == CONF_NODE_NONE) {\n      doc->prealloc_nodes_index = i;\n      doc->prealloc_nodes_used++;\n      return iter;\n    }\n  }\n\n  return NULL;\n}\n\nconf_node_t* conf_doc_create_node(conf_doc_t* doc, const char* name) {\n  conf_node_t* node = NULL;\n  return_value_if_fail(doc != NULL, NULL);\n  node = conf_doc_find_free_node(doc);\n\n  if (node != NULL) {\n    memset(node, 0x00, sizeof(conf_node_t));\n  } else {\n    node = TKMEM_ZALLOC(conf_node_t);\n  }\n  return_value_if_fail(node != NULL, NULL);\n\n  node->node_type = CONF_NODE_OBJECT;\n  if (name != NULL) {\n    uint32_t size = strlen(name);\n    if (size < sizeof(node->name)) {\n      node->is_small_name = TRUE;\n      strcpy(node->name.small_str, name);\n    } else {\n      node->is_small_name = FALSE;\n      node->name.str = tk_strdup(name);\n    }\n  }\n\n  return node;\n}\n\nstatic conf_node_t* conf_doc_dup_node_impl(conf_doc_t* doc, conf_node_t* node,\n                                           const char* new_name) {\n  conf_node_t* new_node = NULL;\n  return_value_if_fail(doc != NULL && node != NULL, NULL);\n\n  if (new_name == NULL) {\n    new_name = conf_node_get_name(node);\n  }\n  new_node = conf_doc_create_node(doc, new_name);\n  return_value_if_fail(new_node != NULL, NULL);\n\n  new_node->value_type = node->value_type;\n  if (node->value_type == CONF_NODE_VALUE_NODE) {\n    conf_node_t* iter = conf_node_get_first_child(node);\n    while (iter != NULL) {\n      conf_node_t* new_iter = conf_doc_dup_node_impl(doc, iter, NULL);\n      break_if_fail(new_iter != NULL);\n      conf_doc_append_child(doc, new_node, new_iter);\n\n      iter = iter->next;\n    }\n  } else if (node->value_type != CONF_NODE_VALUE_NONE) {\n    value_t v;\n    if (conf_node_get_value(node, &v) == RET_OK) {\n      conf_node_set_value(new_node, &v);\n    }\n  }\n\n  return new_node;\n}\n\nconf_node_t* conf_doc_dup_node(conf_doc_t* doc, conf_node_t* node, const char* new_name) {\n  conf_node_t* new_node = NULL;\n  return_value_if_fail(doc != NULL && node != NULL, NULL);\n  new_node = conf_doc_dup_node_impl(doc, node, new_name);\n  return_value_if_fail(new_node != NULL, NULL);\n\n  new_node->next = node->next;\n  node->next = new_node;\n  new_node->parent = node->parent;\n\n  return new_node;\n}\n\nret_t conf_doc_set_node_prop(conf_doc_t* doc, conf_node_t* node, const char* name,\n                             const value_t* v) {\n  conf_node_t* child = NULL;\n  return_value_if_fail(doc != NULL && node != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  child = conf_node_find_child(node, name);\n  if (child == NULL) {\n    child = conf_doc_create_node(doc, name);\n    return_value_if_fail(child != NULL, RET_BAD_PARAMS);\n\n    conf_node_set_value(child, v);\n    return conf_doc_append_child(doc, node, child);\n  } else {\n    return conf_node_set_value(child, v);\n  }\n}\n\nret_t conf_doc_destroy_node(conf_doc_t* doc, conf_node_t* node) {\n  return_value_if_fail(doc != NULL && node != NULL, RET_BAD_PARAMS);\n\n  if (!node->is_small_name) {\n    TKMEM_FREE(node->name.str);\n  }\n\n  if (node->value_type == CONF_NODE_VALUE_STRING) {\n    TKMEM_FREE(node->value.str);\n  }\n\n  memset(node, 0x00, sizeof(*node));\n\n  if (node >= doc->prealloc_nodes && node < (doc->prealloc_nodes + doc->prealloc_nodes_nr)) {\n    node->node_type = CONF_NODE_NONE;\n    doc->prealloc_nodes_used--;\n\n    return RET_OK;\n  }\n\n  TKMEM_FREE(node);\n\n  return RET_OK;\n}\n\nret_t conf_doc_append_sibling(conf_doc_t* doc, conf_node_t* node, conf_node_t* sibling) {\n  conf_node_t* iter = node;\n  return_value_if_fail(doc != NULL && node != NULL && sibling != NULL, RET_BAD_PARAMS);\n\n  sibling->parent = node->parent;\n  while (iter->next != NULL) iter = iter->next;\n  iter->next = sibling;\n\n  return RET_OK;\n}\n\nret_t conf_doc_append_child(conf_doc_t* doc, conf_node_t* node, conf_node_t* child) {\n  conf_node_t* first_child = conf_node_get_first_child(node);\n  return_value_if_fail(doc != NULL && node != NULL && child != NULL, RET_BAD_PARAMS);\n\n  if (first_child == NULL) {\n    conf_node_set_first_child(node, child);\n    return RET_OK;\n  } else {\n    return conf_doc_append_sibling(doc, first_child, child);\n  }\n}\n\nret_t conf_doc_remove_sibling(conf_doc_t* doc, conf_node_t* node, conf_node_t* sibling) {\n  conf_node_t* iter = node;\n  return_value_if_fail(doc != NULL && node != NULL && sibling != NULL, RET_BAD_PARAMS);\n\n  if (node == sibling) {\n    return conf_doc_remove_child(doc, node->parent, node);\n  } else {\n    while (iter->next != NULL) {\n      if (iter->next == sibling) {\n        iter->next = sibling->next;\n        sibling->next = NULL;\n        conf_doc_destroy_node(doc, sibling);\n        return RET_OK;\n      }\n      iter = iter->next;\n    }\n  }\n\n  return RET_NOT_FOUND;\n}\n\nret_t conf_doc_remove_child(conf_doc_t* doc, conf_node_t* node, conf_node_t* child) {\n  conf_node_t* first_child = conf_node_get_first_child(node);\n  return_value_if_fail(doc != NULL && node != NULL && child != NULL, RET_BAD_PARAMS);\n\n  if (first_child == child) {\n    conf_node_set_first_child(node, child->next);\n    conf_doc_destroy_node(doc, child);\n\n    return RET_OK;\n  } else {\n    return conf_doc_remove_sibling(doc, first_child, child);\n  }\n}\n\nret_t conf_doc_remove_child_by_name(conf_doc_t* doc, conf_node_t* node, const char* name) {\n  conf_node_t* iter = NULL;\n  conf_node_t* prev = NULL;\n  conf_node_t* first_child = conf_node_get_first_child(node);\n  return_value_if_fail(doc != NULL && node != NULL, RET_BAD_PARAMS);\n\n  iter = first_child;\n  prev = first_child;\n  while (iter != NULL) {\n    if (tk_str_eq(conf_node_get_name(iter), name)) {\n      if (iter == first_child) {\n        conf_node_set_first_child(node, iter->next);\n      } else {\n        prev->next = iter->next;\n      }\n      conf_doc_destroy_node(doc, iter);\n\n      return RET_OK;\n    }\n    prev = iter;\n    iter = iter->next;\n  }\n\n  return RET_NOT_FOUND;\n}\n\nret_t conf_doc_remove_children(conf_doc_t* doc, conf_node_t* node) {\n  conf_node_t* iter = NULL;\n  conf_node_t* first_child = conf_node_get_first_child(node);\n  return_value_if_fail(doc != NULL && node != NULL, RET_BAD_PARAMS);\n\n  if (first_child == NULL) {\n    return RET_OK;\n  }\n\n  iter = first_child;\n  return_value_if_fail(iter != NULL, RET_BAD_PARAMS);\n  conf_node_set_first_child(node, NULL);\n\n  while (iter != NULL) {\n    conf_node_t* next = iter->next;\n\n    conf_doc_remove_children(doc, iter);\n    conf_doc_destroy_node(doc, iter);\n    iter = next;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t conf_node_destroy(conf_doc_t* doc, conf_node_t* node) {\n  conf_node_t* iter = node;\n  return_value_if_fail(doc != NULL && node != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    conf_node_t* next = iter->next;\n    conf_doc_remove_children(doc, iter);\n    conf_doc_destroy_node(doc, iter);\n    iter = next;\n  }\n\n  return RET_OK;\n}\n\nconst char* conf_node_get_name(conf_node_t* node) {\n  return_value_if_fail(node != NULL, NULL);\n\n  return node->is_small_name ? node->name.small_str : node->name.str;\n}\n\nuint32_t conf_node_count_children(conf_node_t* node) {\n  uint32_t i = 0;\n  conf_node_t* first = conf_node_get_first_child(node);\n  return_value_if_fail(node != NULL, 0);\n\n  while (first != NULL) {\n    i++;\n    first = first->next;\n  }\n\n  return i;\n}\n\nstatic int32_t conf_node_get_index(conf_node_t* node) {\n  uint32_t i = 0;\n  conf_node_t* iter = NULL;\n  return_value_if_fail(node != NULL, 0);\n  iter = conf_node_get_first_child(node->parent);\n\n  while (iter != NULL) {\n    if (iter == node) {\n      return i;\n    }\n    i++;\n    iter = iter->next;\n  }\n  assert(!\"impossible\");\n  return -1;\n}\n\nconf_node_t* conf_node_find_sibling(conf_node_t* node, const char* name) {\n  conf_node_t* iter = NULL;\n  if (node == NULL) {\n    return NULL;\n  }\n\n  return_value_if_fail(name != NULL, NULL);\n\n  if (node->parent != NULL) {\n    iter = conf_node_get_first_child(node->parent);\n  } else {\n    iter = node;\n  }\n  while (iter != NULL) {\n    if (tk_str_eq(conf_node_get_name(iter), name)) {\n      return iter;\n    }\n\n    iter = iter->next;\n  }\n\n  return NULL;\n}\n\nconf_node_t* conf_node_find_sibling_by_index(conf_node_t* node, int32_t index) {\n  int32_t i = 0;\n  conf_node_t* iter = NULL;\n  return_value_if_fail(node != NULL && index >= 0, NULL);\n\n  if (node->parent != NULL) {\n    iter = conf_node_get_first_child(node->parent);\n  } else {\n    iter = node;\n  }\n\n  for (i = 0; i < index && iter != NULL; i++) {\n    iter = iter->next;\n  }\n\n  return iter;\n}\n\nconf_node_t* conf_node_find_child(conf_node_t* node, const char* name) {\n  conf_node_t* first_child = conf_node_get_first_child(node);\n  return_value_if_fail(node != NULL && name != NULL, NULL);\n\n  return conf_node_find_sibling(first_child, name);\n}\n\nconf_node_t* conf_node_find_child_by_index(conf_node_t* node, int32_t index) {\n  conf_node_t* first_child = conf_node_get_first_child(node);\n  return_value_if_fail(node != NULL, NULL);\n\n  return conf_node_find_sibling_by_index(first_child, index);\n}\n\nret_t conf_doc_destroy(conf_doc_t* doc) {\n  return_value_if_fail(doc != NULL, RET_BAD_PARAMS);\n\n  conf_node_destroy(doc, doc->root);\n  doc->root = NULL;\n  tokenizer_deinit(&(doc->tokenizer));\n  TKMEM_FREE(doc->prealloc_nodes);\n\n  TKMEM_FREE(doc);\n\n  return RET_OK;\n}\n\nret_t conf_node_set_value(conf_node_t* node, const value_t* v) {\n  return_value_if_fail(node != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(node->value_type != CONF_NODE_VALUE_NODE, RET_BAD_PARAMS);\n\n  if (node->value_type == CONF_NODE_VALUE_STRING) {\n    TKMEM_FREE(node->value.str);\n  }\n\n  switch (v->type) {\n    case VALUE_TYPE_BOOL: {\n      node->value_type = CONF_NODE_VALUE_BOOL;\n      node->value.b = value_bool(v);\n      break;\n    }\n    case VALUE_TYPE_INT8: {\n      node->value_type = CONF_NODE_VALUE_INT8;\n      node->value.i8 = value_int8(v);\n      break;\n    }\n    case VALUE_TYPE_UINT8: {\n      node->value_type = CONF_NODE_VALUE_UINT8;\n      node->value.u8 = value_uint8(v);\n      break;\n    }\n    case VALUE_TYPE_INT16: {\n      node->value_type = CONF_NODE_VALUE_INT16;\n      node->value.i16 = value_int16(v);\n      break;\n    }\n    case VALUE_TYPE_UINT16: {\n      node->value_type = CONF_NODE_VALUE_UINT16;\n      node->value.u16 = value_uint16(v);\n      break;\n    }\n    case VALUE_TYPE_INT32: {\n      node->value_type = CONF_NODE_VALUE_INT32;\n      node->value.i32 = value_int32(v);\n      break;\n    }\n    case VALUE_TYPE_UINT32: {\n      node->value_type = CONF_NODE_VALUE_UINT32;\n      node->value.u32 = value_uint32(v);\n      break;\n    }\n    case VALUE_TYPE_INT64: {\n      node->value_type = CONF_NODE_VALUE_INT64;\n      node->value.i64 = value_int64(v);\n      break;\n    }\n    case VALUE_TYPE_UINT64: {\n      node->value_type = CONF_NODE_VALUE_UINT64;\n      node->value.u64 = value_uint64(v);\n      break;\n    }\n    case VALUE_TYPE_FLOAT:\n    case VALUE_TYPE_FLOAT32: {\n      node->value_type = CONF_NODE_VALUE_FLOAT32;\n      node->value.f32 = value_float32(v);\n      break;\n    }\n    case VALUE_TYPE_DOUBLE: {\n      node->value_type = CONF_NODE_VALUE_DOUBLE;\nnode->value.f64 = ",
    "raw_res": "value_float64(v);",
    "prompt_res": "value_double(v);",
    "gt": "value_double(v);"
  },
  {
    "id": 2057,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/bitmap.c",
    "input": "﻿/**\n * File:   bitmap.c\n * Author: AWTK Develop Team\n * Brief:  bitmap interface\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-13 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"base/pixel.h\"\n#include \"base/bitmap.h\"\n#include \"base/graphic_buffer.h\"\n\nbitmap_t* bitmap_create(void) {\n  bitmap_t* bitmap = TKMEM_ZALLOC(bitmap_t);\n  return_value_if_fail(bitmap != NULL, NULL);\n\n  bitmap->should_free_handle = TRUE;\n\n  return bitmap;\n}\n\nret_t bitmap_destroy_with_self(bitmap_t* bitmap) {\n  return_value_if_fail(bitmap != NULL, RET_BAD_PARAMS);\n  bitmap->should_free_handle = TRUE;\n\n  return bitmap_destroy(bitmap);\n}\n\nret_t bitmap_destroy(bitmap_t* bitmap) {\n  return_value_if_fail(bitmap != NULL, RET_BAD_PARAMS);\n\n  if (bitmap->specific_destroy != NULL) {\n    bitmap->specific_destroy(bitmap);\n  }\n\n  if (bitmap->destroy != NULL) {\n    bitmap->destroy(bitmap);\n  }\n\n  if (bitmap->should_free_data) {\n    if (bitmap->buffer != NULL) {\n      graphic_buffer_destroy(bitmap->buffer);\n    }\n\n    if (bitmap->gif_delays != NULL) {\n      TKMEM_FREE(bitmap->gif_delays);\n      bitmap->gif_delays = NULL;\n    }\n\n    TKMEM_FREE(bitmap->data_free_ptr);\n  }\n\n  if (bitmap->should_free_handle) {\n    memset(bitmap, 0x00, sizeof(bitmap_t));\n    TKMEM_FREE(bitmap);\n  } else {\n    memset(bitmap, 0x00, sizeof(bitmap_t));\n  }\n\n  return RET_OK;\n}\n\n#include \"base/pixel_pack_unpack.h\"\n\nuint32_t bitmap_get_bpp_of_format(bitmap_format_t format) {\n  switch (format) {\n    case BITMAP_FMT_RGBA8888:\n    case BITMAP_FMT_ABGR8888:\n    case BITMAP_FMT_BGRA8888:\n    case BITMAP_FMT_ARGB8888:\n      return 4;\n    case BITMAP_FMT_RGB565:\n    case BITMAP_FMT_BGR565:\n      return 2;\n    case BITMAP_FMT_RGB888:\n    case BITMAP_FMT_BGR888:\n      return 3;\n    case BITMAP_FMT_GRAY:\n      return 1;\n    default:\n      break;\n  }\n\n  return 0;\n}\n\nuint32_t bitmap_get_bpp(bitmap_t* bitmap) {\n  return_value_if_fail(bitmap != NULL, 0);\n\n  return bitmap_get_bpp_of_format((bitmap_format_t)(bitmap->format));\n}\n\nret_t bitmap_alloc_data(bitmap_t* bitmap) {\n  return_value_if_fail(bitmap != NULL && bitmap->w > 0 && bitmap->h > 0, RET_BAD_PARAMS);\n\n  return GRAPHIC_BUFFER_CREATE_FOR_BITMAP(bitmap);\n}\n\nbool_t bitmap_flag_is_lcd_orientation(bitmap_t* bitmap) {\n  return bitmap->flags & BITMAP_FLAG_LCD_ORIENTATION;\n}\n\n#ifdef AWTK_WEB\n#include <emscripten.h>\nstatic ret_t bitmap_web_destroy(bitmap_t* bitmap) {\n  int32_t id = tk_pointer_to_int(bitmap->specific);\n  EM_ASM_INT({ return VGCanvas.destroyMutableImage($0); }, id);\n\n  return RET_OK;\n}\n\n#endif /*AWTK_WEB*/\n\nbitmap_t* bitmap_create_ex(uint32_t w, uint32_t h, uint32_t line_length, bitmap_format_t format) {\n  bitmap_t* bitmap = TKMEM_ZALLOC(bitmap_t);\n  uint32_t bpp = bitmap_get_bpp_of_format(format);\n\n  return_value_if_fail(bitmap != NULL, NULL);\n\n  bitmap->w = w;\n  bitmap->h = h;\n  bitmap->format = format;\n  bitmap->should_free_handle = TRUE;\n\n  if (bpp < 4) {\n    bitmap->flags = BITMAP_FLAG_OPAQUE;\n  }\n\n  bitmap_set_line_length(bitmap, line_length);\n\n  bitmap_alloc_data(bitmap);\n  if (bitmap->buffer == NULL) {\n    TKMEM_FREE(bitmap);\n    bitmap = NULL;\n  } else {\n#ifdef AWTK_WEB\n    uint8_t* data = bitmap_lock_buffer_for_write(bitmap);\n    return_value_if_fail(format == BITMAP_FMT_RGBA8888, NULL);\n    int32_t id = EM_ASM_INT({ return VGCanvas.createMutableImage($0, $1, $2, $3, $4); }, data, w, h,\n                            line_length, format);\n    bitmap->specific = tk_pointer_from_int(id);\n    bitmap->specific_destroy = bitmap_web_destroy;\n    bitmap_unlock_buffer(bitmap);\n#endif /*AWTK_WEB*/\n  }\n\n  return bitmap;\n}\n\nret_t bitmap_get_pixel(bitmap_t* bitmap, uint32_t x, uint32_t y, rgba_t* rgba) {\n  ret_t ret = RET_OK;\n  const uint8_t* data = NULL;\n  uint8_t* bitmap_data = NULL;\n  uint32_t w = bitmap_get_physical_width(bitmap);\n  uint32_t h = bitmap_get_physical_height(bitmap);\n  uint32_t bpp = bitmap_get_bpp(bitmap);\n  return_value_if_fail(bitmap != NULL && bitmap->buffer != NULL && rgba != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(x < w && y < h, RET_BAD_PARAMS);\n\nbitmap_data = ",
    "raw_res": "0;",
    "prompt_res": "bitmap_lock_buffer_for_read(bitmap);",
    "gt": "bitmap_lock_buffer_for_read(bitmap);"
  },
  {
    "id": 2104,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/canvas.c",
    "input": "﻿/**\n * File:   canvas.c\n * Author: AWTK Develop Team\n * Brief:  canvas provides basic drawings functions.\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-13 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/wstr.h\"\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/utils.h\"\n#include \"base/bidi.h\"\n#include \"base/canvas.h\"\n#include \"base/vgcanvas.h\"\n#include \"tkc/time_now.h\"\n#include \"tkc/color_parser.h\"\n#include \"base/system_info.h\"\n\n#include \"base/lcd_profile.h\"\n\n#ifndef CANVAS_MEASURE_TEXT_CACHE_MAX_LENGTH\n#define CANVAS_MEASURE_TEXT_CACHE_MAX_LENGTH 127\n#endif\n\nstatic ret_t canvas_draw_fps(canvas_t* c);\nstatic ret_t canvas_draw_icon_ex(canvas_t* c, bitmap_t* img, const rect_t* src_r, xy_t cx, xy_t cy);\nstatic ret_t canvas_draw_image_center_ex(canvas_t* c, bitmap_t* img, const rect_t* src_r,\n                                         const rect_t* dst_in);\n\nstatic bool_t bitmap_check_rect(bitmap_t* img, const rect_t* r) {\n  return_value_if_fail(img != NULL && r != NULL, FALSE);\n\n  return r->x >= 0 && r->y >= 0 && r->w > 0 && r->h > 0 && (r->x + r->w) <= img->w &&\n         (r->y + r->h) <= img->h;\n}\n\nstatic rect_t* canvas_fix_rect(const rect_t* r, rect_t* o) {\n  if (r != NULL) {\n    *o = *r;\n\n    if (o->w < 0) {\n      o->w = -o->w;\n      o->x = o->x - o->w + 1;\n    }\n\n    if (o->h < 0) {\n      o->h = -o->h;\n      o->y = o->y - o->h + 1;\n    }\n\n    return o;\n  } else {\n    return NULL;\n  }\n}\n\nret_t canvas_translate(canvas_t* c, xy_t dx, xy_t dy) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  c->ox += dx;\n  c->oy += dy;\n\n  return RET_OK;\n}\n\nret_t canvas_untranslate(canvas_t* c, xy_t dx, xy_t dy) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  c->ox -= dx;\n  c->oy -= dy;\n\n  return RET_OK;\n}\n\ncanvas_t* canvas_init(canvas_t* c, lcd_t* lcd, font_manager_t* font_manager) {\n  return_value_if_fail(c != NULL && lcd != NULL && font_manager != NULL, NULL);\n\n  memset(c, 0x00, sizeof(canvas_t));\n\n  c->lcd = lcd_profile_create(lcd);\n  c->font_manager = font_manager;\n\n  c->clip_left = 0;\n  c->clip_top = 0;\n  c->clip_right = canvas_get_width(c) - 1;\n  c->clip_bottom = canvas_get_height(c) - 1;\n\n  c->last_text_str = TKMEM_ZALLOCN(wchar_t, CANVAS_MEASURE_TEXT_CACHE_MAX_LENGTH + 1);\n  return c;\n}\n\nwh_t canvas_get_width(canvas_t* c) {\n  return_value_if_fail(c != NULL, 0);\n\n  return lcd_get_width(c->lcd);\n}\n\nwh_t canvas_get_height(canvas_t* c) {\n  return_value_if_fail(c != NULL, 0);\n\n  return lcd_get_height(c->lcd);\n}\n\nret_t canvas_set_font_manager(canvas_t* c, font_manager_t* font_manager) {\n  return_value_if_fail(c != NULL && font_manager != NULL, RET_BAD_PARAMS);\n\n  c->font_manager = font_manager;\n\n  return RET_OK;\n}\n\nret_t canvas_set_assets_manager(canvas_t* c, assets_manager_t* assets_manager) {\n  vgcanvas_t* vgcanvas = NULL;\n  return_value_if_fail(c != NULL && assets_manager != NULL, RET_BAD_PARAMS);\n\n  vgcanvas = lcd_get_vgcanvas(c->lcd);\n  c->assets_manager = assets_manager;\n  if (vgcanvas != NULL) {\n    vgcanvas_set_assets_manager(vgcanvas, assets_manager);\n  }\n  if (c->font_manager != NULL) {\n    font_manager_set_assets_manager(c->font_manager, assets_manager);\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_get_clip_rect(canvas_t* c, rect_t* r) {\n  return_value_if_fail(c != NULL && r != NULL, RET_BAD_PARAMS);\n\n  r->x = c->clip_left;\n  r->y = c->clip_top;\n  r->w = c->clip_right - c->clip_left + 1;\n  r->h = c->clip_bottom - c->clip_top + 1;\n\n  if (c->lcd->get_clip_rect != NULL) {\n    return lcd_get_clip_rect(c->lcd, r);\n  }\n  return RET_OK;\n}\n\nbool_t canvas_is_rect_in_clip_rect(canvas_t* c, xy_t left, xy_t top, xy_t right, xy_t bottom) {\n  if (c->lcd->is_rect_in_clip_rect != NULL) {\n    return c->lcd->is_rect_in_clip_rect(c->lcd, left, top, right, bottom);\n  } else {\n    if (left > c->clip_right || right < c->clip_left || top > c->clip_bottom ||\n        bottom < c->clip_top) {\n      return FALSE;\n    }\n    return TRUE;\n  }\n}\n\nret_t canvas_set_clip_rect(canvas_t* c, const rect_t* r_in) {\n  wh_t lcd_w = 0;\n  wh_t lcd_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* r = canvas_fix_rect(r_in, &r_fix);\n\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  lcd_w = lcd_get_width(c->lcd);\n  lcd_h = lcd_get_height(c->lcd);\n\n  if (c->lcd->set_clip_rect != NULL) {\n    if (r != NULL) {\n      rect_t clip_r = rect_init(tk_max(0, r->x), tk_max(0, r->y), tk_max(0, r->w), tk_max(0, r->h));\n      lcd_set_clip_rect(c->lcd, &clip_r);\n    } else {\n      rect_t clip_r = rect_init(0, 0, lcd_w, lcd_h);\n      lcd_set_clip_rect(c->lcd, &clip_r);\n    }\n#ifdef WITH_GPU\n    /* 兼容以前的逻辑，以免以前的用户不使用 canvas_is_rect_in_clip_rect 来判断出问题 */\n    /* 把 canvas 的裁剪区设置为无限大，在 opengl 的状态下让 vg 来处理裁剪区的问题 */\n    c->clip_left = 0;\n    c->clip_top = 0;\n    c->clip_right = 0x7fffffff;\n    c->clip_bottom = 0x7fffffff;\n#endif\n  } else {\n    if (r != NULL) {\n      c->clip_left = tk_max(0, r->x);\n      c->clip_top = tk_max(0, r->y);\n      c->clip_right = tk_min(lcd_w - 1, r->x + r->w - 1);\n      c->clip_bottom = tk_min(lcd_h - 1, r->y + r->h - 1);\n    } else {\n      c->clip_left = 0;\n      c->clip_top = 0;\n      c->clip_right = lcd_w - 1;\n      c->clip_bottom = lcd_h - 1;\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_set_clip_rect_ex(canvas_t* c, const rect_t* r_in, bool_t translate) {\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* r = canvas_fix_rect(r_in, &r_fix);\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  if (r != NULL && translate) {\n    rect_t rr = *r;\n\n    rr.x += c->ox;\n    rr.y += c->oy;\n    return canvas_set_clip_rect(c, &rr);\n  } else {\n    return canvas_set_clip_rect(c, r);\n  }\n}\n\nret_t canvas_set_fill_color(canvas_t* c, color_t color) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  lcd_set_fill_color(c->lcd, color);\n\n  return RET_OK;\n}\n\nret_t canvas_set_text_color(canvas_t* c, color_t color) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  lcd_set_text_color(c->lcd, color);\n\n  return RET_OK;\n}\n\nret_t canvas_set_stroke_color(canvas_t* c, color_t color) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  lcd_set_stroke_color(c->lcd, color);\n\n  return RET_OK;\n}\n\nret_t canvas_set_global_alpha(canvas_t* c, uint8_t alpha) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  c->global_alpha = alpha;\n  lcd_set_global_alpha(c->lcd, alpha);\n\n  return RET_OK;\n}\n\nret_t canvas_set_font(canvas_t* c, const char* name, font_size_t size) {\n  return_value_if_fail(c != NULL && c->lcd != NULL, RET_BAD_PARAMS);\n\n  name = system_info_fix_font_name(name);\n  size = system_info()->font_scale * size;\n\n  if (c->font_size != size) {\n    c->font_size = size;\n    c->last_text_length = 0;\n  }\n  if (!tk_str_eq(name, c->font_name)) {\n    c->last_text_length = 0;\n    c->font_name = tk_str_copy(c->font_name, name);\n  }\n\n  if (c->last_text_length == 0) {\n    if (c->lcd->set_font_name != NULL) {\n      lcd_set_font_name(c->lcd, c->font_name);\n      lcd_set_font_size(c->lcd, size);\n    } else {\n      c->font = font_manager_get_font(c->font_manager, c->font_name, c->font_size);\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_reset_font(canvas_t* c) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  c->font_size = 0;\n  c->last_text_length = 0;\n  c->font = NULL;\n  TKMEM_FREE(c->font_name);\n\n  return RET_OK;\n}\n\nret_t canvas_set_text_align(canvas_t* c, align_h_t align_h, align_v_t align_v) {\n  return_value_if_fail(c != NULL && c->lcd != NULL, RET_BAD_PARAMS);\n\n  c->text_align_h = align_h;\n  c->text_align_v = align_v;\n\n  return RET_OK;\n}\n\nstatic float_t canvas_measure_text_default(canvas_t* c, const wchar_t* str, uint32_t nr) {\n  glyph_t g;\n  float_t w = 0;\n  uint32_t i = 0;\n  return_value_if_fail(c != NULL && str != NULL && c->font != NULL, 0);\n\n  for (i = 0; i < nr; i++) {\n    wchar_t chr = str[i];\n    if (font_get_glyph(c->font, chr, c->font_size, &g) == RET_OK) {\n      w += g.advance + 1;\n    } else {\n      w += 4;\n    }\n  }\n\n  return w;\n}\n\nfloat_t canvas_measure_text(canvas_t* c, const wchar_t* str, uint32_t nr) {\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, 0);\n\n  if (c->last_text_length != 0 && c->last_text_nr == nr && tk_wstr_eq(c->last_text_str, str)) {\n    return c->last_text_length;\n  } else {\n    if (nr > CANVAS_MEASURE_TEXT_CACHE_MAX_LENGTH) {\n      c->last_text_nr = 0;\n      c->last_text_str[0] = 0;\n    } else {\n      tk_memcpy(c->last_text_str, str, nr * sizeof(wchar_t));\n      c->last_text_nr = nr;\n      c->last_text_str[nr] = 0;\n    }\n  }\n\n  if (c->lcd->measure_text) {\n    c->last_text_length = lcd_measure_text(c->lcd, str, nr);\n  } else {\n    c->last_text_length = canvas_measure_text_default(c, str, nr);\n  }\n  return c->last_text_length;\n}\n\nfloat_t canvas_measure_utf8(canvas_t* c, const char* str) {\n  wstr_t s;\n  float_t ret = 0;\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, 0);\n\n  wstr_init(&s, 0);\n  return_value_if_fail(wstr_set_utf8(&s, str) == RET_OK, 0);\n\n  ret = canvas_measure_text(c, s.str, s.size);\n  wstr_reset(&s);\n\n  return ret;\n}\n\nret_t canvas_begin_frame(canvas_t* c, const dirty_rects_t* dirty_rects, lcd_draw_mode_t draw_mode) {\n  rect_t dirty_rect;\n  ret_t ret = RET_OK;\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  if (c->began_frame) {\n    return RET_OK;\n  } else {\n    c->began_frame = TRUE;\n  }\n\n  if (c->begin_frame) {\n    return c->begin_frame(c, dirty_rects, draw_mode);\n  }\n\n  c->ox = 0;\n  c->oy = 0;\n\n  canvas_set_global_alpha(c, 0xff);\n  lcd_set_canvas(c->lcd, c);\n  /* 把当前帧的脏矩形列表传入到 lcd 中和 fb 的脏矩形列表合并得出新的脏矩形列表。*/\n  if (c->lcd->support_dirty_rect) {\n    ret = lcd_begin_frame(c->lcd, dirty_rects, draw_mode);\n  } else {\n    ret = lcd_begin_frame(c->lcd, NULL, draw_mode);\n  }\n  return_value_if_fail(ret == RET_OK, ret);\n  /* 获取新的最大的脏矩形，然后设置裁剪区 */\n  ret = lcd_get_dirty_rect(c->lcd, &dirty_rect);\n  if (c->lcd->support_dirty_rect && ret == RET_OK) {\n    if (draw_mode == LCD_DRAW_NORMAL && c->lcd->type == LCD_VGCANVAS) {\n      rect_t r = dirty_rect;\n\n      /*for vgcanvas anti alias*/\n      r.x--;\n      r.y--;\n      r.w += 2;\n      r.h += 2;\n\n      canvas_set_clip_rect(c, &r);\n    } else {\n      canvas_set_clip_rect(c, &dirty_rect);\n    }\n  } else {\n    canvas_set_clip_rect(c, NULL);\n  }\n\n  return ret;\n}\n\nstatic ret_t canvas_draw_hline_impl(canvas_t* c, xy_t x, xy_t y, wh_t w) {\n  rect_t r;\n  xy_t x2 = x + w - 1;\n\n  if (!canvas_is_rect_in_clip_rect(c, x, y, x2, y)) {\n    return RET_OK;\n  }\n  canvas_get_clip_rect(c, &r);\n\n  x = tk_max(x, r.x);\n  x2 = tk_min(x2, r.x + r.w - 1);\n  w = x2 - x + 1;\n\n  return lcd_draw_hline(c->lcd, x, y, w);\n}\n\nret_t canvas_draw_hline(canvas_t* c, xy_t x, xy_t y, wh_t w) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  if (w < 0) {\n    w = -w;\n    x = x - w + 1;\n  }\n\n  return canvas_draw_hline_impl(c, c->ox + x, c->oy + y, w);\n}\n\nstatic ret_t canvas_draw_vline_impl(canvas_t* c, xy_t x, xy_t y, wh_t h) {\n  rect_t r;\n  xy_t y2 = y + h - 1;\n\n  if (!canvas_is_rect_in_clip_rect(c, x, y, x, y2)) {\n    return RET_OK;\n  }\n  canvas_get_clip_rect(c, &r);\n\n  y = tk_max(y, r.y);\n  y2 = tk_min(y2, r.y + r.h - 1);\n  h = y2 - y + 1;\n\n  return lcd_draw_vline(c->lcd, x, y, h);\n}\n\nret_t canvas_draw_vline(canvas_t* c, xy_t x, xy_t y, wh_t h) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  if (h < 0) {\n    h = -h;\n    y = y - h + 1;\n  }\n\n  return canvas_draw_vline_impl(c, c->ox + x, c->oy + y, h);\n}\n\nstatic ret_t canvas_draw_line_impl(canvas_t* c, xy_t x1, xy_t y1, xy_t x2, xy_t y2) {\n  if (x1 == x2) {\n    return canvas_draw_vline_impl(c, x1, y1, tk_abs(y2 - y1) + 1);\n  } else if (y1 == y2) {\n    return canvas_draw_hline_impl(c, x1, y1, tk_abs(x2 - x1) + 1);\n  } else {\n    assert(!\"Not implemented yet, please use vgcanvas to draw line\");\n    return RET_NOT_IMPL;\n  }\n}\n\nret_t canvas_draw_line(canvas_t* c, xy_t x1, xy_t y1, xy_t x2, xy_t y2) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  return canvas_draw_line_impl(c, c->ox + x1, c->oy + y1, c->ox + x2, c->oy + y2);\n}\n\n#define MAX_POINTS_PER_DRAW 20\n\nstatic ret_t canvas_do_draw_points(canvas_t* c, const point_t* points, uint32_t nr) {\n  uint32_t i = 0;\n  uint32_t real_nr = 0;\n\n  point_t real_points[MAX_POINTS_PER_DRAW];\n  return_value_if_fail(nr <= MAX_POINTS_PER_DRAW, RET_BAD_PARAMS);\n\n  for (i = 0; i < nr; i++) {\n    const point_t* p = points + i;\n    xy_t x = p->x + c->ox;\n    xy_t y = p->y + c->oy;\n    if (!canvas_is_rect_in_clip_rect(c, x, y, x, y)) {\n      continue;\n    }\n\n    real_points[real_nr].x = x;\n    real_points[real_nr].y = y;\n\n    real_nr++;\n  }\n\n  return lcd_draw_points(c->lcd, real_points, real_nr);\n}\n\nstatic ret_t canvas_draw_points_impl(canvas_t* c, const point_t* points, uint32_t nr) {\n  uint32_t i = 0;\n  const point_t* p = points;\n  uint32_t n = (nr / MAX_POINTS_PER_DRAW);\n  uint32_t r = (nr % MAX_POINTS_PER_DRAW);\n\n  for (i = 0; i <= n; i++) {\n    if (i == n) {\n      canvas_do_draw_points(c, p, r);\n    } else {\n      canvas_do_draw_points(c, p, MAX_POINTS_PER_DRAW);\n      p += MAX_POINTS_PER_DRAW;\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_draw_points(canvas_t* c, const point_t* points, uint32_t nr) {\n  return_value_if_fail(c != NULL && points != NULL, RET_BAD_PARAMS);\n\n  return canvas_draw_points_impl(c, points, nr);\n}\n\nstatic ret_t canvas_fill_rect_impl(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  rect_t r;\n  xy_t x2 = x + w - 1;\n  xy_t y2 = y + h - 1;\n\n  if (!canvas_is_rect_in_clip_rect(c, x, y, x2, y2)) {\n    return RET_OK;\n  }\n  canvas_get_clip_rect(c, &r);\n\n  x = tk_max(x, r.x);\n  y = tk_max(y, r.y);\n  x2 = tk_min(x2, r.x + r.w - 1);\n  y2 = tk_min(y2, r.y + r.h - 1);\n  w = x2 - x + 1;\n  h = y2 - y + 1;\n\n  return lcd_fill_rect(c->lcd, x, y, w, h);\n}\n\nret_t canvas_fill_rect(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  fix_xywh(x, y, w, h);\n  return canvas_fill_rect_impl(c, c->ox + x, c->oy + y, w, h);\n}\n\nstatic ret_t canvas_fill_rect_gradient_impl(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h,\n                                            gradient_t* gradient) {\n  rect_t r;\n  xy_t x2 = x + w - 1;\n  xy_t y2 = y + h - 1;\n  vgcanvas_t* vg = NULL;\n\n  if (!canvas_is_rect_in_clip_rect(c, x, y, x2, y2)) {\n    return RET_OK;\n  }\n\n  canvas_get_clip_rect(c, &r);\n\n  x = tk_max(x, r.x);\n  y = tk_max(y, r.y);\n  x2 = tk_min(x2, r.x + r.w - 1);\n  y2 = tk_min(y2, r.y + r.h - 1);\n  w = x2 - x + 1;\n  h = y2 - y + 1;\n  if (w == 0 || h == 0) {\n    return RET_OK;\n  }\n\n  /*FIXME: to support general cases*/\n  return_value_if_fail(gradient->type == GRADIENT_LINEAR && gradient->degree == 180,\n                       RET_BAD_PARAMS);\n\n#ifndef WITH_GPU\n  if (gradient->type == GRADIENT_LINEAR) {\n    if (gradient->degree == 180) {\n      uint32_t i = 0;\n      lcd_t* lcd = c->lcd;\n      for (i = 0; i < h; i++) {\n        float offset = (float)i / (float)h;\n        color_t color = gradient_get_color(gradient, offset);\n        lcd_set_stroke_color(lcd, color);\n        lcd_draw_hline(lcd, x, y + i, w);\n      }\n      return RET_OK;\n    }\n  }\n#endif\n  vg = canvas_get_vgcanvas(c);\n  if (vg != NULL) {\n    vg_gradient_t vg_gradient;\n    rect_t rect = {x, y, w, h};\n    vgcanvas_save(vg);\n    vgcanvas_set_antialias(vg, FALSE);\n    vg_gradient_init_with_gradient(&vg_gradient, &rect, gradient);\n    vgcanvas_set_fill_gradient(vg, &vg_gradient);\n    vgcanvas_rect(vg, x, y, w, h);\n    vgcanvas_fill(vg);\n    vgcanvas_restore(vg);\n  }\n\n  return RET_NOT_IMPL;\n}\n\nret_t canvas_fill_rect_gradient(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h, gradient_t* gradient) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  fix_xywh(x, y, w, h);\n  return canvas_fill_rect_gradient_impl(c, c->ox + x, c->oy + y, w, h, gradient);\n}\n\nstatic ret_t canvas_clear_rect_impl(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  rect_t r;\n  xy_t x2 = x + w - 1;\n  xy_t y2 = y + h - 1;\n\n  if (!canvas_is_rect_in_clip_rect(c, x, y, x2, y2)) {\n    return RET_OK;\n  }\n\n  canvas_get_clip_rect(c, &r);\n\n  x = tk_max(x, r.x);\n  y = tk_max(y, r.y);\n  x2 = tk_min(x2, r.x + r.w - 1);\n  y2 = tk_min(y2, r.y + r.h - 1);\n  w = x2 - x + 1;\n  h = y2 - y + 1;\n\n  return lcd_clear_rect(c->lcd, x, y, w, h);\n}\n\nret_t canvas_clear_rect(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  fix_xywh(x, y, w, h);\n  return canvas_clear_rect_impl(c, c->ox + x, c->oy + y, w, h);\n}\n\nstatic ret_t canvas_stroke_rect_impl(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return_value_if_fail(c != NULL && c->lcd != NULL && w > 0 && h > 0, RET_BAD_PARAMS);\n\n  if (c->lcd->stroke_rect != NULL) {\n    lcd_stroke_rect(c->lcd, x, y, w, h);\n  } else {\n    canvas_draw_hline_impl(c, x, y, w);\n    canvas_draw_hline_impl(c, x, y + h - 1, w);\n    canvas_draw_vline_impl(c, x, y, h);\n    canvas_draw_vline_impl(c, x + w - 1, y, h);\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_stroke_rect(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  fix_xywh(x, y, w, h);\n  return canvas_stroke_rect_impl(c, c->ox + x, c->oy + y, w, h);\n}\n\nstatic ret_t canvas_draw_glyph(canvas_t* c, glyph_t* g, xy_t x, xy_t y) {\n  rect_t r;\n  rect_t src;\n  rect_t dst;\n  xy_t x2 = x + g->w - 1;\n  xy_t y2 = y + g->h - 1;\n\n  if (g->data == NULL || !canvas_is_rect_in_clip_rect(c, x, y, x2, y2)) {\n    return RET_OK;\n  }\n  canvas_get_clip_rect(c, &r);\n\n  dst.x = tk_max(x, r.x);\n  dst.y = tk_max(y, r.y);\n  dst.w = tk_min(x2, r.x + r.w - 1) - dst.x + 1;\n  dst.h = tk_min(y2, r.y + r.h - 1) - dst.y + 1;\n\n  src.x = dst.x - x;\n  src.y = dst.y - y;\n  src.w = dst.w;\n  src.h = dst.h;\n\n  return lcd_draw_glyph(c->lcd, g, &src, dst.x, dst.y);\n}\n\nstatic ret_t canvas_draw_char_impl(canvas_t* c, wchar_t chr, xy_t x, xy_t y) {\n  glyph_t g;\n  font_size_t font_size = c->font_size;\n  font_vmetrics_t vmetrics = font_get_vmetrics(c->font, c->font_size);\n  return_value_if_fail(font_get_glyph(c->font, chr, font_size, &g) == RET_OK, RET_BAD_PARAMS);\n\n  x += g.x;\n  y += vmetrics.ascent + g.y;\n\n  return canvas_draw_glyph(c, &g, x, y);\n}\n\nret_t canvas_draw_char(canvas_t* c, wchar_t chr, xy_t x, xy_t y) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  return canvas_draw_char_impl(c, chr, c->ox + x, c->oy + y);\n}\n\nstatic ret_t canvas_draw_text_impl(canvas_t* c, const wchar_t* str, uint32_t nr, xy_t x, xy_t y,\n                                   bool_t line_breaker) {\n  glyph_t g;\n  uint32_t i = 0;\n  xy_t left = x;\n  font_vmetrics_t vmetrics = font_get_vmetrics(c->font, c->font_size);\n  font_size_t font_size = c->font_size;\n  int32_t baseline = vmetrics.ascent;\n  return_value_if_fail(c->font != NULL, RET_BAD_PARAMS);\n  for (i = 0; i < nr; i++) {\n    wchar_t chr = str[i];\n\n    if (chr == '\\r' || chr == '\\n') {\n      if ((i + 1) == nr) {\n        break;\n      }\n\n      if (chr == '\\r' && str[i + 1] == '\\n') {\n        i++;\n      }\n\n      if (line_breaker) {\n        y += font_size;\n        x = left;\n        continue;\n      } else {\n        chr = ' ';\n      }\n    }\n\n    if (font_get_glyph(c->font, chr, c->font_size, &g) == RET_OK) {\n      xy_t xx = x + g.x;\n      xy_t yy = y + g.y + baseline;\n\n      canvas_draw_glyph(c, &g, xx, yy);\n      x += g.advance + 1;\n    } else {\n      x += 4;\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_draw_text(canvas_t* c, const wchar_t* str, uint32_t nr, xy_t x, xy_t y) {\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, RET_BAD_PARAMS);\n  if (c->lcd->draw_text != NULL) {\n    return lcd_draw_text(c->lcd, str, nr, c->ox + x, c->oy + y);\n  } else {\n    return canvas_draw_text_impl(c, str, nr, c->ox + x, c->oy + y, FALSE);\n  }\n}\n\nret_t canvas_draw_utf8(canvas_t* c, const char* str, xy_t x, xy_t y) {\n  wstr_t s;\n  ret_t ret = RET_FAIL;\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, RET_BAD_PARAMS);\n\n  wstr_init(&s, 0);\n  return_value_if_fail(wstr_set_utf8(&s, str) == RET_OK, RET_OOM);\n\n  ret = canvas_draw_text(c, s.str, s.size, x, y);\n  wstr_reset(&s);\n\n  return ret;\n}\n\nstatic ret_t canvas_do_draw_image(canvas_t* c, bitmap_t* img, const rect_t* s, const rect_t* d) {\n  rect_t r;\n  rectf_t src;\n  rectf_t dst;\n  float_t scale_w = 0;\n  float_t scale_h = 0;\n\n  xy_t x = d->x;\n  xy_t y = d->y;\n  xy_t x2 = d->x + d->w - 1;\n  xy_t y2 = d->y + d->h - 1;\n\n  if (d->w <= 0 || d->h <= 0 || s->w <= 0 || s->h <= 0 ||\n      !canvas_is_rect_in_clip_rect(c, x, y, x2, y2)) {\n    return RET_OK;\n  }\n  canvas_get_clip_rect(c, &r);\n\n  dst.x = tk_max(x, r.x);\n  dst.y = tk_max(y, r.y);\n  dst.w = tk_min(x2, r.x + r.w - 1) - dst.x + 1;\n  dst.h = tk_min(y2, r.y + r.h - 1) - dst.y + 1;\n\n  /* 因为 blend 函数中缩放，使用 256 倍的定点数，所以这里为了减低多次转换数据出现误差 */\n  scale_w = ((s->w << 8) / d->w / 256.0f);\n  scale_h = ((s->h << 8) / d->h / 256.0f);\n\n  src.x = s->x + (dst.x - x) * scale_w;\n  src.y = s->y + (dst.y - y) * scale_h;\n  src.w = dst.w * s->w / d->w;\n  src.h = dst.h * s->h / d->h;\n\n  if (src.x >= img->w || src.y >= img->h) {\n    return RET_OK;\n  }\n\n  src.w = tk_min((img->w - src.x), src.w);\n  src.h = tk_min((img->h - src.y), src.h);\n\n  if (src.w <= 0 || src.h <= 0 || dst.w <= 0 || dst.h <= 0) {\n    return RET_OK;\n  }\n\n  return lcd_draw_image(c->lcd, img, &src, &dst);\n}\n\nret_t canvas_draw_image(canvas_t* c, bitmap_t* img, const rect_t* src, const rect_t* dst_in) {\n  rect_t d;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && src != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  d.x = c->ox + dst->x;\n  d.y = c->oy + dst->y;\n  d.w = dst->w;\n  d.h = dst->h;\n\n  return canvas_do_draw_image(c, img, src, &d);\n}\n\nstatic ret_t canvas_draw_image_repeat_default(canvas_t* c, bitmap_t* img, const rect_t* src_in,\n                                              const rect_t* dst_in, wh_t dst_w, wh_t dst_h) {\n  rect_t s;\n  rect_t d;\n  xy_t x = 0;\n  xy_t y = 0;\n  wh_t sw = 0;\n  wh_t sh = 0;\n  wh_t dw = 0;\n  wh_t dh = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL && src_in != NULL && dst_in != NULL,\n                       RET_BAD_PARAMS);\n\n  s.x = src_in->x;\n  s.y = src_in->y;\n  s.w = src_in->w;\n  s.h = src_in->h;\n\n  d = *dst;\n\n  while (y < dst->h) {\n    dh = tk_min(dst_h, dst->h - y);\n    sh = tk_min(src_in->h, dst->h - y);\n    while (x < dst->w) {\n      dw = tk_min(dst_w, dst->w - x);\n      sw = tk_min(src_in->w, dst->w - x);\n\n      s.w = sw;\n      s.h = sh;\n\n      d.w = dw;\n      d.h = dh;\n      d.x = x + dst->x;\n      d.y = y + dst->y;\n      canvas_draw_image(c, img, &s, &d);\n      x += dw;\n    }\n    y += dh;\n    x = 0;\n  }\n  return RET_OK;\n}\n\nstatic ret_t canvas_draw_image_repeat_x_impl(canvas_t* c, bitmap_t* img, const rect_t* src_in,\n                                             const rect_t* dst_in) {\n  rect_t d;\n  return_value_if_fail(\n      c != NULL && c->lcd != NULL && img != NULL && src_in != NULL && dst_in != NULL,\n      RET_BAD_PARAMS);\n  d.x = dst_in->x + c->ox;\n  d.y = dst_in->y + c->oy;\n  d.w = dst_in->w;\n  d.h = dst_in->h;\n\n  if (c->lcd->draw_image_repeat != NULL &&\n      c->lcd->draw_image_repeat(c->lcd, img, src_in, &d, src_in->w, dst_in->h) == RET_OK) {\n    return RET_OK;\n  }\n\n  return canvas_draw_image_repeat_default(c, img, src_in, dst_in, src_in->w, dst_in->h);\n}\n\nstatic ret_t canvas_draw_image_repeat_y_impl(canvas_t* c, bitmap_t* img, const rect_t* src_in,\n                                             const rect_t* dst_in) {\n  rect_t d;\n  return_value_if_fail(\n      c != NULL && c->lcd != NULL && img != NULL && src_in != NULL && dst_in != NULL,\n      RET_BAD_PARAMS);\n  d.x = dst_in->x + c->ox;\n  d.y = dst_in->y + c->oy;\n  d.w = dst_in->w;\n  d.h = dst_in->h;\n\n  if (c->lcd->draw_image_repeat != NULL &&\n      c->lcd->draw_image_repeat(c->lcd, img, src_in, &d, dst_in->w, src_in->h) == RET_OK) {\n    return RET_OK;\n  }\n\n  return canvas_draw_image_repeat_default(c, img, src_in, dst_in, dst_in->w, src_in->h);\n}\n\nstatic ret_t canvas_draw_image_repeat_impl(canvas_t* c, bitmap_t* img, const rect_t* src_in,\n                                           const rect_t* dst_in) {\n  rect_t d;\n  return_value_if_fail(\n      c != NULL && c->lcd != NULL && img != NULL && src_in != NULL && dst_in != NULL,\n      RET_BAD_PARAMS);\n  d.x = dst_in->x + c->ox;\n  d.y = dst_in->y + c->oy;\n  d.w = dst_in->w;\n  d.h = dst_in->h;\n\n  if (c->lcd->draw_image_repeat != NULL &&\n      c->lcd->draw_image_repeat(c->lcd, img, src_in, &d, src_in->w, src_in->h) == RET_OK) {\n    return RET_OK;\n  }\n\n  return canvas_draw_image_repeat_default(c, img, src_in, dst_in, src_in->w, src_in->h);\n}\n\nret_t canvas_draw_image_repeat(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  s.x = 0;\n  s.y = 0;\n  s.w = img->w;\n  s.h = img->h;\n  canvas_draw_image_repeat_impl(c, img, &s, dst_in);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_repeat9(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t x = 0;\n  xy_t y = 0;\n  wh_t w = 0;\n  wh_t h = 0;\n  wh_t w_w = 0;\n  wh_t h_h = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  wh_t image_w = 0;\n  wh_t image_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  image_w = tk_min(img_w, dst_w);\n  image_h = tk_min(img_h, dst_h);\n  w = image_w >> 1;\n  h = image_h >> 1;\n\n  w_w = dst_w - w * 2;\n  h_h = dst_h - h * 2;\n\n  /*draw four corners*/\n  /*left top*/\n  s = rect_init(0, 0, w, h);\n  d = rect_init(0, 0, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*right top*/\n  s = rect_init(img_w - w, 0, w, h);\n  d = rect_init(dst_w - w, 0, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*left bottom*/\n  s = rect_init(0, img_h - h, w, h);\n  d = rect_init(0, dst_h - h, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*right bottom*/\n  s = rect_init(img_w - w, img_h - h, w, h);\n  d = rect_init(dst_w - w, dst_h - h, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*fill center*/\n  x = w;\n  if (w_w > 0) {\n    int32_t tmp = image_w - w - w;\n    s = rect_init(tmp > 0 ? w : w - 1, 0, tmp > 0 ? tmp : 2, h);\n    d = rect_init(w, 0, w_w, h);\n    canvas_draw_image_repeat_x_impl(c, img, &s, &d);\n\n    s = rect_init(tmp > 0 ? w : w - 1, img_h - h, tmp > 0 ? tmp : 2, h);\n    d = rect_init(w, h + h_h, w_w, h);\n    canvas_draw_image_repeat_x_impl(c, img, &s, &d);\n  }\n\n  /*fill middle*/\n  y = h;\n  if (h_h > 0) {\n    int32_t tmp = image_h - h - h;\n    s = rect_init(0, tmp > 0 ? h : h - 1, w, tmp > 0 ? tmp : 2);\n    d = rect_init(0, h, w, h_h);\n    canvas_draw_image_repeat_y_impl(c, img, &s, &d);\n\n    s = rect_init(img_w - w, tmp > 0 ? h : h - 1, w, tmp > 0 ? tmp : 2);\n    d = rect_init(w + w_w, h, w, h_h);\n    canvas_draw_image_repeat_y_impl(c, img, &s, &d);\n  }\n\n  /*fill center/middle*/\n  if (w_w > 0 && h_h > 0) {\n    int32_t tmp_w = image_w - w - w;\n    int32_t tmp_h = image_h - h - h;\n    s = rect_init(tmp_w > 0 ? w : w - 1, tmp_h > 0 ? h : h - 1, tmp_w > 0 ? tmp_w : 2,\n                  tmp_h > 0 ? tmp_h : 2);\n    d = rect_init(w, h, w_w, h_h);\n    canvas_draw_image_repeat_impl(c, img, &s, &d);\n  }\n\n  canvas_untranslate(c, dst->x, dst->y);\n\n  (void)x;\n  (void)y;\n  (void)dst_w;\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_repeat_x(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  s.x = 0;\n  s.y = 0;\n  s.w = img->w;\n  s.h = img->h;\n\n  canvas_draw_image_repeat_x_impl(c, img, &s, dst_in);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_repeat3_x(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t y = 0;\n  wh_t w = 0;\n  wh_t w_w = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  wh_t image_w = 0;\n  int32_t tmp = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  image_w = tk_min(img_w, dst_w);\n  w = image_w >> 1;\n  w_w = dst_w - (w << 1);\n\n  y = (dst_h - img_h) >> 1;\n  if (y < 0) {\n    img_h += y;\n    y = 0;\n  }\n\n  /*left*/\ns = ",
    "raw_res": "rect_init(0, y, w, img_h);",
    "prompt_res": "rect_init(0, 0, w, img_h);",
    "gt": "rect_init(0, 0, w, img_h);"
  },
  {
    "id": 2143,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/canvas.c",
    "input": "﻿/**\n * File:   canvas.c\n * Author: AWTK Develop Team\n * Brief:  canvas provides basic drawings functions.\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-13 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/wstr.h\"\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/utils.h\"\n#include \"base/bidi.h\"\n#include \"base/canvas.h\"\n#include \"base/vgcanvas.h\"\n#include \"tkc/time_now.h\"\n#include \"tkc/color_parser.h\"\n#include \"base/system_info.h\"\n\n#include \"base/lcd_profile.h\"\n\n#ifndef CANVAS_MEASURE_TEXT_CACHE_MAX_LENGTH\n#define CANVAS_MEASURE_TEXT_CACHE_MAX_LENGTH 127\n#endif\n\nstatic ret_t canvas_draw_fps(canvas_t* c);\nstatic ret_t canvas_draw_icon_ex(canvas_t* c, bitmap_t* img, const rect_t* src_r, xy_t cx, xy_t cy);\nstatic ret_t canvas_draw_image_center_ex(canvas_t* c, bitmap_t* img, const rect_t* src_r,\n                                         const rect_t* dst_in);\n\nstatic bool_t bitmap_check_rect(bitmap_t* img, const rect_t* r) {\n  return_value_if_fail(img != NULL && r != NULL, FALSE);\n\n  return r->x >= 0 && r->y >= 0 && r->w > 0 && r->h > 0 && (r->x + r->w) <= img->w &&\n         (r->y + r->h) <= img->h;\n}\n\nstatic rect_t* canvas_fix_rect(const rect_t* r, rect_t* o) {\n  if (r != NULL) {\n    *o = *r;\n\n    if (o->w < 0) {\n      o->w = -o->w;\n      o->x = o->x - o->w + 1;\n    }\n\n    if (o->h < 0) {\n      o->h = -o->h;\n      o->y = o->y - o->h + 1;\n    }\n\n    return o;\n  } else {\n    return NULL;\n  }\n}\n\nret_t canvas_translate(canvas_t* c, xy_t dx, xy_t dy) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  c->ox += dx;\n  c->oy += dy;\n\n  return RET_OK;\n}\n\nret_t canvas_untranslate(canvas_t* c, xy_t dx, xy_t dy) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  c->ox -= dx;\n  c->oy -= dy;\n\n  return RET_OK;\n}\n\ncanvas_t* canvas_init(canvas_t* c, lcd_t* lcd, font_manager_t* font_manager) {\n  return_value_if_fail(c != NULL && lcd != NULL && font_manager != NULL, NULL);\n\n  memset(c, 0x00, sizeof(canvas_t));\n\n  c->lcd = lcd_profile_create(lcd);\n  c->font_manager = font_manager;\n\n  c->clip_left = 0;\n  c->clip_top = 0;\n  c->clip_right = canvas_get_width(c) - 1;\n  c->clip_bottom = canvas_get_height(c) - 1;\n\n  c->last_text_str = TKMEM_ZALLOCN(wchar_t, CANVAS_MEASURE_TEXT_CACHE_MAX_LENGTH + 1);\n  return c;\n}\n\nwh_t canvas_get_width(canvas_t* c) {\n  return_value_if_fail(c != NULL, 0);\n\n  return lcd_get_width(c->lcd);\n}\n\nwh_t canvas_get_height(canvas_t* c) {\n  return_value_if_fail(c != NULL, 0);\n\n  return lcd_get_height(c->lcd);\n}\n\nret_t canvas_set_font_manager(canvas_t* c, font_manager_t* font_manager) {\n  return_value_if_fail(c != NULL && font_manager != NULL, RET_BAD_PARAMS);\n\n  c->font_manager = font_manager;\n\n  return RET_OK;\n}\n\nret_t canvas_set_assets_manager(canvas_t* c, assets_manager_t* assets_manager) {\n  vgcanvas_t* vgcanvas = NULL;\n  return_value_if_fail(c != NULL && assets_manager != NULL, RET_BAD_PARAMS);\n\n  vgcanvas = lcd_get_vgcanvas(c->lcd);\n  c->assets_manager = assets_manager;\n  if (vgcanvas != NULL) {\n    vgcanvas_set_assets_manager(vgcanvas, assets_manager);\n  }\n  if (c->font_manager != NULL) {\n    font_manager_set_assets_manager(c->font_manager, assets_manager);\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_get_clip_rect(canvas_t* c, rect_t* r) {\n  return_value_if_fail(c != NULL && r != NULL, RET_BAD_PARAMS);\n\n  r->x = c->clip_left;\n  r->y = c->clip_top;\n  r->w = c->clip_right - c->clip_left + 1;\n  r->h = c->clip_bottom - c->clip_top + 1;\n\n  if (c->lcd->get_clip_rect != NULL) {\n    return lcd_get_clip_rect(c->lcd, r);\n  }\n  return RET_OK;\n}\n\nbool_t canvas_is_rect_in_clip_rect(canvas_t* c, xy_t left, xy_t top, xy_t right, xy_t bottom) {\n  if (c->lcd->is_rect_in_clip_rect != NULL) {\n    return c->lcd->is_rect_in_clip_rect(c->lcd, left, top, right, bottom);\n  } else {\n    if (left > c->clip_right || right < c->clip_left || top > c->clip_bottom ||\n        bottom < c->clip_top) {\n      return FALSE;\n    }\n    return TRUE;\n  }\n}\n\nret_t canvas_set_clip_rect(canvas_t* c, const rect_t* r_in) {\n  wh_t lcd_w = 0;\n  wh_t lcd_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* r = canvas_fix_rect(r_in, &r_fix);\n\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  lcd_w = lcd_get_width(c->lcd);\n  lcd_h = lcd_get_height(c->lcd);\n\n  if (c->lcd->set_clip_rect != NULL) {\n    if (r != NULL) {\n      rect_t clip_r = rect_init(tk_max(0, r->x), tk_max(0, r->y), tk_max(0, r->w), tk_max(0, r->h));\n      lcd_set_clip_rect(c->lcd, &clip_r);\n    } else {\n      rect_t clip_r = rect_init(0, 0, lcd_w, lcd_h);\n      lcd_set_clip_rect(c->lcd, &clip_r);\n    }\n#ifdef WITH_GPU\n    /* 兼容以前的逻辑，以免以前的用户不使用 canvas_is_rect_in_clip_rect 来判断出问题 */\n    /* 把 canvas 的裁剪区设置为无限大，在 opengl 的状态下让 vg 来处理裁剪区的问题 */\n    c->clip_left = 0;\n    c->clip_top = 0;\n    c->clip_right = 0x7fffffff;\n    c->clip_bottom = 0x7fffffff;\n#endif\n  } else {\n    if (r != NULL) {\n      c->clip_left = tk_max(0, r->x);\n      c->clip_top = tk_max(0, r->y);\n      c->clip_right = tk_min(lcd_w - 1, r->x + r->w - 1);\n      c->clip_bottom = tk_min(lcd_h - 1, r->y + r->h - 1);\n    } else {\n      c->clip_left = 0;\n      c->clip_top = 0;\n      c->clip_right = lcd_w - 1;\n      c->clip_bottom = lcd_h - 1;\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_set_clip_rect_ex(canvas_t* c, const rect_t* r_in, bool_t translate) {\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* r = canvas_fix_rect(r_in, &r_fix);\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  if (r != NULL && translate) {\n    rect_t rr = *r;\n\n    rr.x += c->ox;\n    rr.y += c->oy;\n    return canvas_set_clip_rect(c, &rr);\n  } else {\n    return canvas_set_clip_rect(c, r);\n  }\n}\n\nret_t canvas_set_fill_color(canvas_t* c, color_t color) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  lcd_set_fill_color(c->lcd, color);\n\n  return RET_OK;\n}\n\nret_t canvas_set_text_color(canvas_t* c, color_t color) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  lcd_set_text_color(c->lcd, color);\n\n  return RET_OK;\n}\n\nret_t canvas_set_stroke_color(canvas_t* c, color_t color) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  lcd_set_stroke_color(c->lcd, color);\n\n  return RET_OK;\n}\n\nret_t canvas_set_global_alpha(canvas_t* c, uint8_t alpha) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  c->global_alpha = alpha;\n  lcd_set_global_alpha(c->lcd, alpha);\n\n  return RET_OK;\n}\n\nret_t canvas_set_font(canvas_t* c, const char* name, font_size_t size) {\n  return_value_if_fail(c != NULL && c->lcd != NULL, RET_BAD_PARAMS);\n\n  name = system_info_fix_font_name(name);\n  size = system_info()->font_scale * size;\n\n  if (c->font_size != size) {\n    c->font_size = size;\n    c->last_text_length = 0;\n  }\n  if (!tk_str_eq(name, c->font_name)) {\n    c->last_text_length = 0;\n    c->font_name = tk_str_copy(c->font_name, name);\n  }\n\n  if (c->last_text_length == 0) {\n    if (c->lcd->set_font_name != NULL) {\n      lcd_set_font_name(c->lcd, c->font_name);\n      lcd_set_font_size(c->lcd, size);\n    } else {\n      c->font = font_manager_get_font(c->font_manager, c->font_name, c->font_size);\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_reset_font(canvas_t* c) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  c->font_size = 0;\n  c->last_text_length = 0;\n  c->font = NULL;\n  TKMEM_FREE(c->font_name);\n\n  return RET_OK;\n}\n\nret_t canvas_set_text_align(canvas_t* c, align_h_t align_h, align_v_t align_v) {\n  return_value_if_fail(c != NULL && c->lcd != NULL, RET_BAD_PARAMS);\n\n  c->text_align_h = align_h;\n  c->text_align_v = align_v;\n\n  return RET_OK;\n}\n\nstatic float_t canvas_measure_text_default(canvas_t* c, const wchar_t* str, uint32_t nr) {\n  glyph_t g;\n  float_t w = 0;\n  uint32_t i = 0;\n  return_value_if_fail(c != NULL && str != NULL && c->font != NULL, 0);\n\n  for (i = 0; i < nr; i++) {\n    wchar_t chr = str[i];\n    if (font_get_glyph(c->font, chr, c->font_size, &g) == RET_OK) {\n      w += g.advance + 1;\n    } else {\n      w += 4;\n    }\n  }\n\n  return w;\n}\n\nfloat_t canvas_measure_text(canvas_t* c, const wchar_t* str, uint32_t nr) {\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, 0);\n\n  if (c->last_text_length != 0 && c->last_text_nr == nr && tk_wstr_eq(c->last_text_str, str)) {\n    return c->last_text_length;\n  } else {\n    if (nr > CANVAS_MEASURE_TEXT_CACHE_MAX_LENGTH) {\n      c->last_text_nr = 0;\n      c->last_text_str[0] = 0;\n    } else {\n      tk_memcpy(c->last_text_str, str, nr * sizeof(wchar_t));\n      c->last_text_nr = nr;\n      c->last_text_str[nr] = 0;\n    }\n  }\n\n  if (c->lcd->measure_text) {\n    c->last_text_length = lcd_measure_text(c->lcd, str, nr);\n  } else {\n    c->last_text_length = canvas_measure_text_default(c, str, nr);\n  }\n  return c->last_text_length;\n}\n\nfloat_t canvas_measure_utf8(canvas_t* c, const char* str) {\n  wstr_t s;\n  float_t ret = 0;\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, 0);\n\n  wstr_init(&s, 0);\n  return_value_if_fail(wstr_set_utf8(&s, str) == RET_OK, 0);\n\n  ret = canvas_measure_text(c, s.str, s.size);\n  wstr_reset(&s);\n\n  return ret;\n}\n\nret_t canvas_begin_frame(canvas_t* c, const dirty_rects_t* dirty_rects, lcd_draw_mode_t draw_mode) {\n  rect_t dirty_rect;\n  ret_t ret = RET_OK;\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  if (c->began_frame) {\n    return RET_OK;\n  } else {\n    c->began_frame = TRUE;\n  }\n\n  if (c->begin_frame) {\n    return c->begin_frame(c, dirty_rects, draw_mode);\n  }\n\n  c->ox = 0;\n  c->oy = 0;\n\n  canvas_set_global_alpha(c, 0xff);\n  lcd_set_canvas(c->lcd, c);\n  /* 把当前帧的脏矩形列表传入到 lcd 中和 fb 的脏矩形列表合并得出新的脏矩形列表。*/\n  if (c->lcd->support_dirty_rect) {\n    ret = lcd_begin_frame(c->lcd, dirty_rects, draw_mode);\n  } else {\n    ret = lcd_begin_frame(c->lcd, NULL, draw_mode);\n  }\n  return_value_if_fail(ret == RET_OK, ret);\n  /* 获取新的最大的脏矩形，然后设置裁剪区 */\n  ret = lcd_get_dirty_rect(c->lcd, &dirty_rect);\n  if (c->lcd->support_dirty_rect && ret == RET_OK) {\n    if (draw_mode == LCD_DRAW_NORMAL && c->lcd->type == LCD_VGCANVAS) {\n      rect_t r = dirty_rect;\n\n      /*for vgcanvas anti alias*/\n      r.x--;\n      r.y--;\n      r.w += 2;\n      r.h += 2;\n\n      canvas_set_clip_rect(c, &r);\n    } else {\n      canvas_set_clip_rect(c, &dirty_rect);\n    }\n  } else {\n    canvas_set_clip_rect(c, NULL);\n  }\n\n  return ret;\n}\n\nstatic ret_t canvas_draw_hline_impl(canvas_t* c, xy_t x, xy_t y, wh_t w) {\n  rect_t r;\n  xy_t x2 = x + w - 1;\n\n  if (!canvas_is_rect_in_clip_rect(c, x, y, x2, y)) {\n    return RET_OK;\n  }\n  canvas_get_clip_rect(c, &r);\n\n  x = tk_max(x, r.x);\n  x2 = tk_min(x2, r.x + r.w - 1);\n  w = x2 - x + 1;\n\n  return lcd_draw_hline(c->lcd, x, y, w);\n}\n\nret_t canvas_draw_hline(canvas_t* c, xy_t x, xy_t y, wh_t w) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  if (w < 0) {\n    w = -w;\n    x = x - w + 1;\n  }\n\n  return canvas_draw_hline_impl(c, c->ox + x, c->oy + y, w);\n}\n\nstatic ret_t canvas_draw_vline_impl(canvas_t* c, xy_t x, xy_t y, wh_t h) {\n  rect_t r;\n  xy_t y2 = y + h - 1;\n\n  if (!canvas_is_rect_in_clip_rect(c, x, y, x, y2)) {\n    return RET_OK;\n  }\n  canvas_get_clip_rect(c, &r);\n\n  y = tk_max(y, r.y);\n  y2 = tk_min(y2, r.y + r.h - 1);\n  h = y2 - y + 1;\n\n  return lcd_draw_vline(c->lcd, x, y, h);\n}\n\nret_t canvas_draw_vline(canvas_t* c, xy_t x, xy_t y, wh_t h) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  if (h < 0) {\n    h = -h;\n    y = y - h + 1;\n  }\n\n  return canvas_draw_vline_impl(c, c->ox + x, c->oy + y, h);\n}\n\nstatic ret_t canvas_draw_line_impl(canvas_t* c, xy_t x1, xy_t y1, xy_t x2, xy_t y2) {\n  if (x1 == x2) {\n    return canvas_draw_vline_impl(c, x1, y1, tk_abs(y2 - y1) + 1);\n  } else if (y1 == y2) {\n    return canvas_draw_hline_impl(c, x1, y1, tk_abs(x2 - x1) + 1);\n  } else {\n    assert(!\"Not implemented yet, please use vgcanvas to draw line\");\n    return RET_NOT_IMPL;\n  }\n}\n\nret_t canvas_draw_line(canvas_t* c, xy_t x1, xy_t y1, xy_t x2, xy_t y2) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  return canvas_draw_line_impl(c, c->ox + x1, c->oy + y1, c->ox + x2, c->oy + y2);\n}\n\n#define MAX_POINTS_PER_DRAW 20\n\nstatic ret_t canvas_do_draw_points(canvas_t* c, const point_t* points, uint32_t nr) {\n  uint32_t i = 0;\n  uint32_t real_nr = 0;\n\n  point_t real_points[MAX_POINTS_PER_DRAW];\n  return_value_if_fail(nr <= MAX_POINTS_PER_DRAW, RET_BAD_PARAMS);\n\n  for (i = 0; i < nr; i++) {\n    const point_t* p = points + i;\n    xy_t x = p->x + c->ox;\n    xy_t y = p->y + c->oy;\n    if (!canvas_is_rect_in_clip_rect(c, x, y, x, y)) {\n      continue;\n    }\n\n    real_points[real_nr].x = x;\n    real_points[real_nr].y = y;\n\n    real_nr++;\n  }\n\n  return lcd_draw_points(c->lcd, real_points, real_nr);\n}\n\nstatic ret_t canvas_draw_points_impl(canvas_t* c, const point_t* points, uint32_t nr) {\n  uint32_t i = 0;\n  const point_t* p = points;\n  uint32_t n = (nr / MAX_POINTS_PER_DRAW);\n  uint32_t r = (nr % MAX_POINTS_PER_DRAW);\n\n  for (i = 0; i <= n; i++) {\n    if (i == n) {\n      canvas_do_draw_points(c, p, r);\n    } else {\n      canvas_do_draw_points(c, p, MAX_POINTS_PER_DRAW);\n      p += MAX_POINTS_PER_DRAW;\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_draw_points(canvas_t* c, const point_t* points, uint32_t nr) {\n  return_value_if_fail(c != NULL && points != NULL, RET_BAD_PARAMS);\n\n  return canvas_draw_points_impl(c, points, nr);\n}\n\nstatic ret_t canvas_fill_rect_impl(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  rect_t r;\n  xy_t x2 = x + w - 1;\n  xy_t y2 = y + h - 1;\n\n  if (!canvas_is_rect_in_clip_rect(c, x, y, x2, y2)) {\n    return RET_OK;\n  }\n  canvas_get_clip_rect(c, &r);\n\n  x = tk_max(x, r.x);\n  y = tk_max(y, r.y);\n  x2 = tk_min(x2, r.x + r.w - 1);\n  y2 = tk_min(y2, r.y + r.h - 1);\n  w = x2 - x + 1;\n  h = y2 - y + 1;\n\n  return lcd_fill_rect(c->lcd, x, y, w, h);\n}\n\nret_t canvas_fill_rect(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  fix_xywh(x, y, w, h);\n  return canvas_fill_rect_impl(c, c->ox + x, c->oy + y, w, h);\n}\n\nstatic ret_t canvas_fill_rect_gradient_impl(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h,\n                                            gradient_t* gradient) {\n  rect_t r;\n  xy_t x2 = x + w - 1;\n  xy_t y2 = y + h - 1;\n  vgcanvas_t* vg = NULL;\n\n  if (!canvas_is_rect_in_clip_rect(c, x, y, x2, y2)) {\n    return RET_OK;\n  }\n\n  canvas_get_clip_rect(c, &r);\n\n  x = tk_max(x, r.x);\n  y = tk_max(y, r.y);\n  x2 = tk_min(x2, r.x + r.w - 1);\n  y2 = tk_min(y2, r.y + r.h - 1);\n  w = x2 - x + 1;\n  h = y2 - y + 1;\n  if (w == 0 || h == 0) {\n    return RET_OK;\n  }\n\n  /*FIXME: to support general cases*/\n  return_value_if_fail(gradient->type == GRADIENT_LINEAR && gradient->degree == 180,\n                       RET_BAD_PARAMS);\n\n#ifndef WITH_GPU\n  if (gradient->type == GRADIENT_LINEAR) {\n    if (gradient->degree == 180) {\n      uint32_t i = 0;\n      lcd_t* lcd = c->lcd;\n      for (i = 0; i < h; i++) {\n        float offset = (float)i / (float)h;\n        color_t color = gradient_get_color(gradient, offset);\n        lcd_set_stroke_color(lcd, color);\n        lcd_draw_hline(lcd, x, y + i, w);\n      }\n      return RET_OK;\n    }\n  }\n#endif\n  vg = canvas_get_vgcanvas(c);\n  if (vg != NULL) {\n    vg_gradient_t vg_gradient;\n    rect_t rect = {x, y, w, h};\n    vgcanvas_save(vg);\n    vgcanvas_set_antialias(vg, FALSE);\n    vg_gradient_init_with_gradient(&vg_gradient, &rect, gradient);\n    vgcanvas_set_fill_gradient(vg, &vg_gradient);\n    vgcanvas_rect(vg, x, y, w, h);\n    vgcanvas_fill(vg);\n    vgcanvas_restore(vg);\n  }\n\n  return RET_NOT_IMPL;\n}\n\nret_t canvas_fill_rect_gradient(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h, gradient_t* gradient) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  fix_xywh(x, y, w, h);\n  return canvas_fill_rect_gradient_impl(c, c->ox + x, c->oy + y, w, h, gradient);\n}\n\nstatic ret_t canvas_clear_rect_impl(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  rect_t r;\n  xy_t x2 = x + w - 1;\n  xy_t y2 = y + h - 1;\n\n  if (!canvas_is_rect_in_clip_rect(c, x, y, x2, y2)) {\n    return RET_OK;\n  }\n\n  canvas_get_clip_rect(c, &r);\n\n  x = tk_max(x, r.x);\n  y = tk_max(y, r.y);\n  x2 = tk_min(x2, r.x + r.w - 1);\n  y2 = tk_min(y2, r.y + r.h - 1);\n  w = x2 - x + 1;\n  h = y2 - y + 1;\n\n  return lcd_clear_rect(c->lcd, x, y, w, h);\n}\n\nret_t canvas_clear_rect(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  fix_xywh(x, y, w, h);\n  return canvas_clear_rect_impl(c, c->ox + x, c->oy + y, w, h);\n}\n\nstatic ret_t canvas_stroke_rect_impl(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return_value_if_fail(c != NULL && c->lcd != NULL && w > 0 && h > 0, RET_BAD_PARAMS);\n\n  if (c->lcd->stroke_rect != NULL) {\n    lcd_stroke_rect(c->lcd, x, y, w, h);\n  } else {\n    canvas_draw_hline_impl(c, x, y, w);\n    canvas_draw_hline_impl(c, x, y + h - 1, w);\n    canvas_draw_vline_impl(c, x, y, h);\n    canvas_draw_vline_impl(c, x + w - 1, y, h);\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_stroke_rect(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  fix_xywh(x, y, w, h);\n  return canvas_stroke_rect_impl(c, c->ox + x, c->oy + y, w, h);\n}\n\nstatic ret_t canvas_draw_glyph(canvas_t* c, glyph_t* g, xy_t x, xy_t y) {\n  rect_t r;\n  rect_t src;\n  rect_t dst;\n  xy_t x2 = x + g->w - 1;\n  xy_t y2 = y + g->h - 1;\n\n  if (g->data == NULL || !canvas_is_rect_in_clip_rect(c, x, y, x2, y2)) {\n    return RET_OK;\n  }\n  canvas_get_clip_rect(c, &r);\n\n  dst.x = tk_max(x, r.x);\n  dst.y = tk_max(y, r.y);\n  dst.w = tk_min(x2, r.x + r.w - 1) - dst.x + 1;\n  dst.h = tk_min(y2, r.y + r.h - 1) - dst.y + 1;\n\n  src.x = dst.x - x;\n  src.y = dst.y - y;\n  src.w = dst.w;\n  src.h = dst.h;\n\n  return lcd_draw_glyph(c->lcd, g, &src, dst.x, dst.y);\n}\n\nstatic ret_t canvas_draw_char_impl(canvas_t* c, wchar_t chr, xy_t x, xy_t y) {\n  glyph_t g;\n  font_size_t font_size = c->font_size;\n  font_vmetrics_t vmetrics = font_get_vmetrics(c->font, c->font_size);\n  return_value_if_fail(font_get_glyph(c->font, chr, font_size, &g) == RET_OK, RET_BAD_PARAMS);\n\n  x += g.x;\n  y += vmetrics.ascent + g.y;\n\n  return canvas_draw_glyph(c, &g, x, y);\n}\n\nret_t canvas_draw_char(canvas_t* c, wchar_t chr, xy_t x, xy_t y) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  return canvas_draw_char_impl(c, chr, c->ox + x, c->oy + y);\n}\n\nstatic ret_t canvas_draw_text_impl(canvas_t* c, const wchar_t* str, uint32_t nr, xy_t x, xy_t y,\n                                   bool_t line_breaker) {\n  glyph_t g;\n  uint32_t i = 0;\n  xy_t left = x;\n  font_vmetrics_t vmetrics = font_get_vmetrics(c->font, c->font_size);\n  font_size_t font_size = c->font_size;\n  int32_t baseline = vmetrics.ascent;\n  return_value_if_fail(c->font != NULL, RET_BAD_PARAMS);\n  for (i = 0; i < nr; i++) {\n    wchar_t chr = str[i];\n\n    if (chr == '\\r' || chr == '\\n') {\n      if ((i + 1) == nr) {\n        break;\n      }\n\n      if (chr == '\\r' && str[i + 1] == '\\n') {\n        i++;\n      }\n\n      if (line_breaker) {\n        y += font_size;\n        x = left;\n        continue;\n      } else {\n        chr = ' ';\n      }\n    }\n\n    if (font_get_glyph(c->font, chr, c->font_size, &g) == RET_OK) {\n      xy_t xx = x + g.x;\n      xy_t yy = y + g.y + baseline;\n\n      canvas_draw_glyph(c, &g, xx, yy);\n      x += g.advance + 1;\n    } else {\n      x += 4;\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_draw_text(canvas_t* c, const wchar_t* str, uint32_t nr, xy_t x, xy_t y) {\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, RET_BAD_PARAMS);\n  if (c->lcd->draw_text != NULL) {\n    return lcd_draw_text(c->lcd, str, nr, c->ox + x, c->oy + y);\n  } else {\n    return canvas_draw_text_impl(c, str, nr, c->ox + x, c->oy + y, FALSE);\n  }\n}\n\nret_t canvas_draw_utf8(canvas_t* c, const char* str, xy_t x, xy_t y) {\n  wstr_t s;\n  ret_t ret = RET_FAIL;\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, RET_BAD_PARAMS);\n\n  wstr_init(&s, 0);\n  return_value_if_fail(wstr_set_utf8(&s, str) == RET_OK, RET_OOM);\n\n  ret = canvas_draw_text(c, s.str, s.size, x, y);\n  wstr_reset(&s);\n\n  return ret;\n}\n\nstatic ret_t canvas_do_draw_image(canvas_t* c, bitmap_t* img, const rect_t* s, const rect_t* d) {\n  rect_t r;\n  rectf_t src;\n  rectf_t dst;\n  float_t scale_w = 0;\n  float_t scale_h = 0;\n\n  xy_t x = d->x;\n  xy_t y = d->y;\n  xy_t x2 = d->x + d->w - 1;\n  xy_t y2 = d->y + d->h - 1;\n\n  if (d->w <= 0 || d->h <= 0 || s->w <= 0 || s->h <= 0 ||\n      !canvas_is_rect_in_clip_rect(c, x, y, x2, y2)) {\n    return RET_OK;\n  }\n  canvas_get_clip_rect(c, &r);\n\n  dst.x = tk_max(x, r.x);\n  dst.y = tk_max(y, r.y);\n  dst.w = tk_min(x2, r.x + r.w - 1) - dst.x + 1;\n  dst.h = tk_min(y2, r.y + r.h - 1) - dst.y + 1;\n\n  /* 因为 blend 函数中缩放，使用 256 倍的定点数，所以这里为了减低多次转换数据出现误差 */\n  scale_w = ((s->w << 8) / d->w / 256.0f);\n  scale_h = ((s->h << 8) / d->h / 256.0f);\n\n  src.x = s->x + (dst.x - x) * scale_w;\n  src.y = s->y + (dst.y - y) * scale_h;\n  src.w = dst.w * s->w / d->w;\n  src.h = dst.h * s->h / d->h;\n\n  if (src.x >= img->w || src.y >= img->h) {\n    return RET_OK;\n  }\n\n  src.w = tk_min((img->w - src.x), src.w);\n  src.h = tk_min((img->h - src.y), src.h);\n\n  if (src.w <= 0 || src.h <= 0 || dst.w <= 0 || dst.h <= 0) {\n    return RET_OK;\n  }\n\n  return lcd_draw_image(c->lcd, img, &src, &dst);\n}\n\nret_t canvas_draw_image(canvas_t* c, bitmap_t* img, const rect_t* src, const rect_t* dst_in) {\n  rect_t d;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && src != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  d.x = c->ox + dst->x;\n  d.y = c->oy + dst->y;\n  d.w = dst->w;\n  d.h = dst->h;\n\n  return canvas_do_draw_image(c, img, src, &d);\n}\n\nstatic ret_t canvas_draw_image_repeat_default(canvas_t* c, bitmap_t* img, const rect_t* src_in,\n                                              const rect_t* dst_in, wh_t dst_w, wh_t dst_h) {\n  rect_t s;\n  rect_t d;\n  xy_t x = 0;\n  xy_t y = 0;\n  wh_t sw = 0;\n  wh_t sh = 0;\n  wh_t dw = 0;\n  wh_t dh = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL && src_in != NULL && dst_in != NULL,\n                       RET_BAD_PARAMS);\n\n  s.x = src_in->x;\n  s.y = src_in->y;\n  s.w = src_in->w;\n  s.h = src_in->h;\n\n  d = *dst;\n\n  while (y < dst->h) {\n    dh = tk_min(dst_h, dst->h - y);\n    sh = tk_min(src_in->h, dst->h - y);\n    while (x < dst->w) {\n      dw = tk_min(dst_w, dst->w - x);\n      sw = tk_min(src_in->w, dst->w - x);\n\n      s.w = sw;\n      s.h = sh;\n\n      d.w = dw;\n      d.h = dh;\n      d.x = x + dst->x;\n      d.y = y + dst->y;\n      canvas_draw_image(c, img, &s, &d);\n      x += dw;\n    }\n    y += dh;\n    x = 0;\n  }\n  return RET_OK;\n}\n\nstatic ret_t canvas_draw_image_repeat_x_impl(canvas_t* c, bitmap_t* img, const rect_t* src_in,\n                                             const rect_t* dst_in) {\n  rect_t d;\n  return_value_if_fail(\n      c != NULL && c->lcd != NULL && img != NULL && src_in != NULL && dst_in != NULL,\n      RET_BAD_PARAMS);\n  d.x = dst_in->x + c->ox;\n  d.y = dst_in->y + c->oy;\n  d.w = dst_in->w;\n  d.h = dst_in->h;\n\n  if (c->lcd->draw_image_repeat != NULL &&\n      c->lcd->draw_image_repeat(c->lcd, img, src_in, &d, src_in->w, dst_in->h) == RET_OK) {\n    return RET_OK;\n  }\n\n  return canvas_draw_image_repeat_default(c, img, src_in, dst_in, src_in->w, dst_in->h);\n}\n\nstatic ret_t canvas_draw_image_repeat_y_impl(canvas_t* c, bitmap_t* img, const rect_t* src_in,\n                                             const rect_t* dst_in) {\n  rect_t d;\n  return_value_if_fail(\n      c != NULL && c->lcd != NULL && img != NULL && src_in != NULL && dst_in != NULL,\n      RET_BAD_PARAMS);\n  d.x = dst_in->x + c->ox;\n  d.y = dst_in->y + c->oy;\n  d.w = dst_in->w;\n  d.h = dst_in->h;\n\n  if (c->lcd->draw_image_repeat != NULL &&\n      c->lcd->draw_image_repeat(c->lcd, img, src_in, &d, dst_in->w, src_in->h) == RET_OK) {\n    return RET_OK;\n  }\n\n  return canvas_draw_image_repeat_default(c, img, src_in, dst_in, dst_in->w, src_in->h);\n}\n\nstatic ret_t canvas_draw_image_repeat_impl(canvas_t* c, bitmap_t* img, const rect_t* src_in,\n                                           const rect_t* dst_in) {\n  rect_t d;\n  return_value_if_fail(\n      c != NULL && c->lcd != NULL && img != NULL && src_in != NULL && dst_in != NULL,\n      RET_BAD_PARAMS);\n  d.x = dst_in->x + c->ox;\n  d.y = dst_in->y + c->oy;\n  d.w = dst_in->w;\n  d.h = dst_in->h;\n\n  if (c->lcd->draw_image_repeat != NULL &&\n      c->lcd->draw_image_repeat(c->lcd, img, src_in, &d, src_in->w, src_in->h) == RET_OK) {\n    return RET_OK;\n  }\n\n  return canvas_draw_image_repeat_default(c, img, src_in, dst_in, src_in->w, src_in->h);\n}\n\nret_t canvas_draw_image_repeat(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  s.x = 0;\n  s.y = 0;\n  s.w = img->w;\n  s.h = img->h;\n  canvas_draw_image_repeat_impl(c, img, &s, dst_in);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_repeat9(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t x = 0;\n  xy_t y = 0;\n  wh_t w = 0;\n  wh_t h = 0;\n  wh_t w_w = 0;\n  wh_t h_h = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  wh_t image_w = 0;\n  wh_t image_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  image_w = tk_min(img_w, dst_w);\n  image_h = tk_min(img_h, dst_h);\n  w = image_w >> 1;\n  h = image_h >> 1;\n\n  w_w = dst_w - w * 2;\n  h_h = dst_h - h * 2;\n\n  /*draw four corners*/\n  /*left top*/\n  s = rect_init(0, 0, w, h);\n  d = rect_init(0, 0, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*right top*/\n  s = rect_init(img_w - w, 0, w, h);\n  d = rect_init(dst_w - w, 0, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*left bottom*/\n  s = rect_init(0, img_h - h, w, h);\n  d = rect_init(0, dst_h - h, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*right bottom*/\n  s = rect_init(img_w - w, img_h - h, w, h);\n  d = rect_init(dst_w - w, dst_h - h, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*fill center*/\n  x = w;\n  if (w_w > 0) {\n    int32_t tmp = image_w - w - w;\n    s = rect_init(tmp > 0 ? w : w - 1, 0, tmp > 0 ? tmp : 2, h);\n    d = rect_init(w, 0, w_w, h);\n    canvas_draw_image_repeat_x_impl(c, img, &s, &d);\n\n    s = rect_init(tmp > 0 ? w : w - 1, img_h - h, tmp > 0 ? tmp : 2, h);\n    d = rect_init(w, h + h_h, w_w, h);\n    canvas_draw_image_repeat_x_impl(c, img, &s, &d);\n  }\n\n  /*fill middle*/\n  y = h;\n  if (h_h > 0) {\n    int32_t tmp = image_h - h - h;\n    s = rect_init(0, tmp > 0 ? h : h - 1, w, tmp > 0 ? tmp : 2);\n    d = rect_init(0, h, w, h_h);\n    canvas_draw_image_repeat_y_impl(c, img, &s, &d);\n\n    s = rect_init(img_w - w, tmp > 0 ? h : h - 1, w, tmp > 0 ? tmp : 2);\n    d = rect_init(w + w_w, h, w, h_h);\n    canvas_draw_image_repeat_y_impl(c, img, &s, &d);\n  }\n\n  /*fill center/middle*/\n  if (w_w > 0 && h_h > 0) {\n    int32_t tmp_w = image_w - w - w;\n    int32_t tmp_h = image_h - h - h;\n    s = rect_init(tmp_w > 0 ? w : w - 1, tmp_h > 0 ? h : h - 1, tmp_w > 0 ? tmp_w : 2,\n                  tmp_h > 0 ? tmp_h : 2);\n    d = rect_init(w, h, w_w, h_h);\n    canvas_draw_image_repeat_impl(c, img, &s, &d);\n  }\n\n  canvas_untranslate(c, dst->x, dst->y);\n\n  (void)x;\n  (void)y;\n  (void)dst_w;\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_repeat_x(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  s.x = 0;\n  s.y = 0;\n  s.w = img->w;\n  s.h = img->h;\n\n  canvas_draw_image_repeat_x_impl(c, img, &s, dst_in);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_repeat3_x(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t y = 0;\n  wh_t w = 0;\n  wh_t w_w = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  wh_t image_w = 0;\n  int32_t tmp = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  image_w = tk_min(img_w, dst_w);\n  w = image_w >> 1;\n  w_w = dst_w - (w << 1);\n\n  y = (dst_h - img_h) >> 1;\n  if (y < 0) {\n    img_h += y;\n    y = 0;\n  }\n\n  /*left*/\n  s = rect_init(0, 0, w, img_h);\n  d = rect_init(0, y, w, img_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*center*/\n  tmp = image_w - w - w;\n  if (dst_w > img_w) {\n    s = rect_init(w, 0, tmp > 0 ? tmp : 2, img_h);\n    d = rect_init(w, y, w_w, img_h);\n    canvas_draw_image_repeat_x_impl(c, img, &s, &d);\n  }\n\n  /*right*/\n  s = rect_init(img_w - w, 0, w, img_h);\n  d = rect_init(dst_w - w, y, w, img_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  canvas_untranslate(c, dst->x, dst->y);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_repeat_y(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  s.x = 0;\n  s.y = 0;\n  s.w = img->w;\n  s.h = img->h;\n  canvas_draw_image_repeat_y_impl(c, img, &s, dst_in);\n  return RET_OK;\n}\n\nret_t canvas_draw_image_repeat3_y(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t x = 0;\n  wh_t h = 0;\n  wh_t h_h = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  wh_t image_h = 0;\n  int32_t tmp = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  image_h = tk_min(img_h, dst_h);\n  h = image_h >> 1;\n  h_h = dst_h - (h << 1);\n\n  x = (dst->w - img->w) >> 1;\n  if (x < 0) {\n    img_w += x;\n    x = 0;\n  }\n  /*top*/\n  s = rect_init(0, 0, img_w, h);\n  d = rect_init(x, 0, img_w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*middle*/\n  tmp = image_h - h - h;\n  if (dst_h > img_h) {\n    s = rect_init(0, tmp > 0 ? h : h - 1, img_w, tmp > 0 ? tmp : 2);\n    d = rect_init(x, h, img_w, h_h);\n    canvas_draw_image_repeat_y_impl(c, img, &s, &d);\n  }\n\n  /*bottom*/\n  s = rect_init(0, img_h - h, img_w, h);\n  d = rect_init(x, dst_h - h, img_w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  canvas_untranslate(c, dst->x, dst->y);\n  (void)dst_w;\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_repeat_y_inverse(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t y = 0;\n  wh_t h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  s.x = 0;\n  s.y = 0;\n  s.w = img->w;\n  s.h = img->h;\n\n  d = *dst;\n\n  while (y < dst->h) {\n    h = tk_min(img->h, dst->h - y);\n    s.h = h;\n    d.h = h;\n    y += h;\n    d.y = dst->y + (dst->h - y);\n\n    if (s.h < img->h) {\n      s.y = img->h - s.h;\n      canvas_draw_image(c, img, &s, &d);\n    } else {\n      s.y = 0;\n      canvas_draw_image(c, img, &s, &d);\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_patch3_y_scale_x(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  wh_t h = 0;\n  wh_t h_h = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  h = tk_min(img_h, dst_h) / 3;\n  h_h = dst_h - h * 2;\n\n  /*top*/\n  s = rect_init(0, 0, img_w, h);\n  d = rect_init(0, 0, dst_w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*middle*/\n  s = rect_init(0, h, img_w, img_h - 2 * h);\n  d = rect_init(0, h, dst_w, h_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*bottom*/\n  s = rect_init(0, img_h - h, img_w, h);\n  d = rect_init(0, dst_h - h, dst_w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  canvas_untranslate(c, dst->x, dst->y);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_patch3_y(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t x = 0;\n  wh_t h = 0;\n  wh_t h_h = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  h = tk_min(img_h, dst_h) / 3;\n  h_h = dst_h - h * 2;\n\n  x = (dst->w - img->w) >> 1;\n  /*top*/\n  s = rect_init(0, 0, img_w, h);\n  d = rect_init(x, 0, img_w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*middle*/\n  s = rect_init(0, h, img_w, img_h - 2 * h);\n  d = rect_init(x, h, img_w, h_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*bottom*/\n  s = rect_init(0, img_h - h, img_w, h);\n  d = rect_init(x, dst_h - h, img_w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  canvas_untranslate(c, dst->x, dst->y);\n  (void)dst_w;\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_patch3_x_scale_y(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  wh_t w = 0;\n  wh_t w_w = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  w = tk_min(img_w, dst_w) / 3;\n  w_w = dst_w - w * 2;\n\n  /*left*/\n  s = rect_init(0, 0, w, img_h);\n  d = rect_init(0, 0, w, dst_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*center*/\n  s = rect_init(w, 0, img_w - 2 * w, img_h);\n  d = rect_init(w, 0, w_w, dst_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*right*/\n  s = rect_init(img_w - w, 0, w, img_h);\n  d = rect_init(dst_w - w, 0, w, dst_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  canvas_untranslate(c, dst->x, dst->y);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_patch3_x(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t y = 0;\n  wh_t w = 0;\n  wh_t w_w = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  w = tk_min(img_w, dst_w) / 3;\n  w_w = dst_w - w * 2;\n\n  y = (dst_h - img_h) >> 1;\n  /*left*/\n  s = rect_init(0, 0, w, img_h);\n  d = rect_init(0, y, w, img_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*center*/\n  s = rect_init(w, 0, img_w - 2 * w, img_h);\n  d = rect_init(w, y, w_w, img_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*right*/\n  s = rect_init(img_w - w, 0, w, img_h);\n  d = rect_init(dst_w - w, y, w, img_h);\n  canvas_draw_image(c, img, &s, &d);\n\n  canvas_untranslate(c, dst->x, dst->y);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_image_patch9(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  xy_t x = 0;\n  xy_t y = 0;\n  wh_t w = 0;\n  wh_t h = 0;\n  wh_t w_w = 0;\n  wh_t h_h = 0;\n  wh_t img_w = 0;\n  wh_t img_h = 0;\n  wh_t dst_w = 0;\n  wh_t dst_h = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  img_w = img->w;\n  img_h = img->h;\n  dst_w = dst->w;\n  dst_h = dst->h;\n\n  canvas_translate(c, dst->x, dst->y);\n\n  w = tk_min(img_w, dst_w) / 3;\n  h = tk_min(img_h, dst_h) / 3;\n\n  w_w = dst_w - w * 2;\n  h_h = dst_h - h * 2;\n\n  /*draw four corners*/\n  /*left top*/\n  s = rect_init(0, 0, w, h);\n  d = rect_init(0, 0, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*right top*/\n  s = rect_init(img_w - w, 0, w, h);\n  d = rect_init(dst_w - w, 0, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*left bottom*/\n  s = rect_init(0, img_h - h, w, h);\n  d = rect_init(0, dst_h - h, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*right bottom*/\n  s = rect_init(img_w - w, img_h - h, w, h);\n  d = rect_init(dst_w - w, dst_h - h, w, h);\n  canvas_draw_image(c, img, &s, &d);\n\n  /*fill center*/\n  x = w;\n  if (w_w > 0) {\n    s = rect_init(w, 0, img_w - 2 * w, h);\n    d = rect_init(w, 0, w_w, h);\n    canvas_draw_image(c, img, &s, &d);\n\n    s = rect_init(w, img_h - h, img_w - 2 * w, h);\n    d = rect_init(w, h + h_h, w_w, h);\n    canvas_draw_image(c, img, &s, &d);\n  }\n\n  /*fill middle*/\n  y = h;\n  if (h_h > 0) {\n    s = rect_init(0, h, w, img_h - 2 * h);\n    d = rect_init(0, h, w, h_h);\n    canvas_draw_image(c, img, &s, &d);\n\n    s = rect_init(img_w - w, h, w, img_h - 2 * h);\n    d = rect_init(w + w_w, h, w, h_h);\n    canvas_draw_image(c, img, &s, &d);\n  }\n\n  /*fill center/middle*/\n  if (w_w > 0 && h_h > 0) {\n    s = rect_init(w, h, img_w - 2 * w, img_h - 2 * h);\n    d = rect_init(w, h, w_w, h_h);\n    canvas_draw_image(c, img, &s, &d);\n  }\n\n  canvas_untranslate(c, dst->x, dst->y);\n\n  (void)x;\n  (void)y;\n  (void)dst_w;\n\n  return RET_OK;\n}\n\nret_t canvas_end_frame(canvas_t* c) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  if (c->began_frame) {\n    c->began_frame = FALSE;\n  } else {\n    return RET_OK;\n  }\n\n  if (c->end_frame != NULL) {\n    return c->end_frame(c);\n  }\n\n  canvas_draw_fps(c);\n  canvas_set_global_alpha(c, 0xff);\n\n  return lcd_end_frame(c->lcd);\n}\n\nret_t canvas_draw_image_scale_w(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  wh_t src_h = 0;\n  wh_t dst_h = 0;\n  float scale = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  scale = (float)(dst->w) / img->w;\n  dst_h = tk_min(img->h * scale, dst->h);\n  src_h = tk_min(img->h, dst_h / scale);\n\n  s.x = 0;\n  s.y = 0;\n  s.w = img->w;\n  s.h = src_h;\n\n  d = *dst;\n  d.h = dst_h;\n\n  return canvas_draw_image(c, img, &s, &d);\n}\n\nret_t canvas_draw_image_scale_h(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  wh_t src_w = 0;\n  wh_t dst_w = 0;\n  float scale = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  scale = (float)(dst->h) / img->h;\n  dst_w = tk_min(img->w * scale, dst->w);\n  src_w = tk_min(img->w, dst_w / scale);\n\n  s.x = 0;\n  s.y = 0;\n  s.h = img->h;\n  s.w = src_w;\n\n  d = *dst;\n  d.w = dst_w;\n\n  return canvas_draw_image(c, img, &s, &d);\n}\n\nret_t canvas_draw_image_scale(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t s;\n  rect_t d;\n  float scale = 0;\n  float scalex = 0;\n  float scaley = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  s.x = 0;\n  s.y = 0;\n  s.h = img->h;\n  s.w = img->w;\n\n  scalex = (float)(dst->w) / img->w;\n  scaley = (float)(dst->h) / img->h;\n  scale = tk_min(scalex, scaley);\n\n  d.w = img->w * scale;\n  d.h = img->h * scale;\n  d.x = dst->x + ((dst->w - d.w) >> 1);\n  d.y = dst->y + ((dst->h - d.h) >> 1);\n\n  return canvas_draw_image(c, img, &s, &d);\n}\n\nret_t canvas_draw_image_scale_down(canvas_t* c, bitmap_t* img, const rect_t* src,\n                                   const rect_t* dst_in) {\n  rect_t d;\n  float scale = 0;\n  float scalex = 0;\n  float scaley = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && src != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  scalex = (float)(dst->w) / src->w;\n  scaley = (float)(dst->h) / src->h;\n  scale = tk_min(scalex, scaley);\n\n  if (scale >= 1) {\n    d.w = src->w;\n    d.h = src->h;\n  } else {\n    d.w = src->w * scale;\n    d.h = src->h * scale;\n  }\n  d.x = dst->x + ((dst->w - d.w) >> 1);\n  d.y = dst->y + ((dst->h - d.h) >> 1);\n\n  return canvas_draw_image(c, img, src, &d);\n}\n\nret_t canvas_draw_image_matrix(canvas_t* c, bitmap_t* img, matrix_t* matrix) {\n  draw_image_info_t info;\n  return_value_if_fail(c != NULL && img != NULL && matrix != NULL && c->lcd != NULL,\n                       RET_BAD_PARAMS);\n\n  info.img = img;\n  info.matrix = *matrix;\n  info.src = rect_init(0, 0, img->w, img->h);\n  info.dst = rect_init(0, 0, img->w, img->h);\n  canvas_get_clip_rect(c, &info.clip);\n\n  return lcd_draw_image_matrix(c->lcd, &info);\n}\n\nret_t canvas_draw_image_ex(canvas_t* c, bitmap_t* img, image_draw_type_t draw_type,\n                           const rect_t* dst_in) {\n  rect_t src;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n  switch (draw_type) {\n    case IMAGE_DRAW_DEFAULT:\n      src = rect_init(0, 0, tk_min(dst->w, img->w), tk_min(dst->h, img->h));\n      dst->w = src.w;\n      dst->h = src.h;\n      return canvas_draw_image(c, img, &src, dst);\n    case IMAGE_DRAW_CENTER:\n      return canvas_draw_image_center(c, img, dst);\n    case IMAGE_DRAW_SCALE:\n      src = rect_init(0, 0, img->w, img->h);\n      return canvas_draw_image(c, img, &src, dst);\n    case IMAGE_DRAW_SCALE_AUTO:\n      return canvas_draw_image_scale(c, img, dst);\n    case IMAGE_DRAW_SCALE_DOWN: {\n      rect_t src = rect_init(0, 0, img->w, img->h);\n      return canvas_draw_image_scale_down(c, img, &src, dst);\n    }\n#ifndef AWTK_LITE\n    case IMAGE_DRAW_ICON: {\n      xy_t cx = dst->x + (dst->w >> 1);\n      xy_t cy = dst->y + (dst->h >> 1);\n      return canvas_draw_icon(c, img, cx, cy);\n    }\n    case IMAGE_DRAW_SCALE_W:\n      return canvas_draw_image_scale_w(c, img, dst);\n    case IMAGE_DRAW_SCALE_H:\n      return canvas_draw_image_scale_h(c, img, dst);\n    case IMAGE_DRAW_REPEAT:\n      return canvas_draw_image_repeat(c, img, dst);\n    case IMAGE_DRAW_REPEAT_X:\n      return canvas_draw_image_repeat_x(c, img, dst);\n    case IMAGE_DRAW_REPEAT_Y:\n      return canvas_draw_image_repeat_y(c, img, dst);\n    case IMAGE_DRAW_REPEAT_Y_INVERSE:\n      return canvas_draw_image_repeat_y_inverse(c, img, dst);\n    case IMAGE_DRAW_PATCH9:\n      return canvas_draw_image_patch9(c, img, dst);\n    case IMAGE_DRAW_PATCH3_X:\n      return canvas_draw_image_patch3_x(c, img, dst);\n    case IMAGE_DRAW_PATCH3_Y:\n      return canvas_draw_image_patch3_y(c, img, dst);\n    case IMAGE_DRAW_PATCH3_X_SCALE_Y:\n      return canvas_draw_image_patch3_x_scale_y(c, img, dst);\n    case IMAGE_DRAW_PATCH3_Y_SCALE_X:\n      return canvas_draw_image_patch3_y_scale_x(c, img, dst);\n    case IMAGE_DRAW_REPEAT9:\n      return canvas_draw_image_repeat9(c, img, dst);\n    case IMAGE_DRAW_REPEAT3_X:\n      return canvas_draw_image_repeat3_x(c, img, dst);\n    case IMAGE_DRAW_REPEAT3_Y:\n      return canvas_draw_image_repeat3_y(c, img, dst);\n#endif /*AWTK_LITE*/\n    default:\n      return canvas_draw_image_center(c, img, dst);\n  }\n}\n\nret_t canvas_draw_image_ex2(canvas_t* c, bitmap_t* img, image_draw_type_t draw_type,\n                            const rect_t* src_in, const rect_t* dst_in) {\n  rect_t src;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(bitmap_check_rect(img, src_in), RET_BAD_PARAMS);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  switch (draw_type) {\n    case IMAGE_DRAW_DEFAULT:\n      src = *src_in;\n      dst->w = src.w;\n      dst->h = src.h;\n      return canvas_draw_image(c, img, &src, dst);\n    case IMAGE_DRAW_ICON: {\n      xy_t cx = dst->x + (dst->w >> 1);\n      xy_t cy = dst->y + (dst->h >> 1);\n      return canvas_draw_icon_ex(c, img, src_in, cx, cy);\n    }\n    case IMAGE_DRAW_CENTER:\n      return canvas_draw_image_center_ex(c, img, src_in, dst);\n    case IMAGE_DRAW_SCALE:\n      return canvas_draw_image(c, img, src_in, dst);\n    default:\n      /*TODO*/\n      assert(!\"not supported yet!\");\n      return RET_FAIL;\n  }\n}\n\nstatic ret_t canvas_draw_icon_ex(canvas_t* c, bitmap_t* img, const rect_t* src_r, xy_t cx,\n                                 xy_t cy) {\n  rect_t src;\n  rect_t dst;\n  wh_t hw = 0;\n  wh_t hh = 0;\n  float_t ratio = 0;\n  return_value_if_fail(c != NULL && c->lcd != NULL && img != NULL && src_r != NULL, RET_BAD_PARAMS);\n\n  src = *src_r;\n  ratio = c->lcd->ratio;\n  if (ratio > 1) {\n    float_t w = (src.w / ratio);\n    float_t h = (src.h / ratio);\n    float_t hw = w / 2;\n    float_t hh = h / 2;\n\n    dst = rect_init(cx - hw, cy - hh, w, h);\n  } else {\n    hw = src.w >> 1;\n    hh = src.h >> 1;\n    dst = rect_init(cx - hw, cy - hh, src.w, src.h);\n  }\n\n  return canvas_draw_image(c, img, &src, &dst);\n}\n\nret_t canvas_draw_icon(canvas_t* c, bitmap_t* img, xy_t cx, xy_t cy) {\n  rect_t src;\n  return_value_if_fail(c != NULL && c->lcd != NULL && img != NULL, RET_BAD_PARAMS);\n  src = rect_init(0, 0, img->w, img->h);\n\n  return canvas_draw_icon_ex(c, img, &src, cx, cy);\n}\n\nret_t canvas_draw_icon_in_rect(canvas_t* c, bitmap_t* img, const rect_t* r_in) {\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* r = canvas_fix_rect(r_in, &r_fix);\n  return_value_if_fail(c != NULL && c->lcd != NULL && img != NULL && r != NULL, RET_BAD_PARAMS);\n\n  return canvas_draw_icon(c, img, r->x + (r->w >> 1), r->y + (r->h >> 1));\n}\n\nstatic ret_t canvas_draw_image_center_ex(canvas_t* c, bitmap_t* img, const rect_t* src_r,\n                                         const rect_t* dst_in) {\n  xy_t dx = 0;\n  xy_t dy = 0;\n  xy_t sx = 0;\n  xy_t sy = 0;\n  wh_t sw = 0;\n  wh_t sh = 0;\n  rect_t src;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  dx = ((dst->w - src_r->w) >> 1);\n  dy = ((dst->h - src_r->h) >> 1);\n\n  if (dx < 0) {\n    sx = -dx;\n    dx = 0;\n    sw = src_r->w - 2 * sx;\n  } else {\n    sw = src_r->w;\n  }\n\n  if (dy < 0) {\n    sy = -dy;\n    dy = 0;\n    sh = src_r->h - 2 * sy;\n  } else {\n    sh = src_r->h;\n  }\n\n  dx += dst->x;\n  dy += dst->y;\n\n  src = rect_init(sx + src_r->x, sy + src_r->y, sw, sh);\n  *dst = rect_init(dx, dy, sw, sh);\n\n  return canvas_draw_image(c, img, &src, dst);\n}\n\nret_t canvas_draw_image_center(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n  rect_t src;\n  return_value_if_fail(c != NULL && img != NULL && dst_in != NULL, RET_BAD_PARAMS);\n  src = rect_init(0, 0, img->w, img->h);\n\n  return canvas_draw_image_center_ex(c, img, &src, dst_in);\n}\n\nret_t canvas_draw_image_at(canvas_t* c, bitmap_t* img, xy_t x, xy_t y) {\n  rect_t src;\n  rect_t dst;\n  float_t ratio = 0;\n  return_value_if_fail(c != NULL && c->lcd != NULL && img != NULL, RET_BAD_PARAMS);\n\n  x += c->ox;\n  y += c->oy;\n  ratio = c->lcd->ratio;\n  src = rect_init(0, 0, img->w, img->h);\n\n  if (ratio > 1) {\n    dst = rect_init(x, y, img->w / ratio, img->h / ratio);\n  } else {\n    dst = rect_init(x, y, img->w, img->h);\n  }\n\n  return canvas_do_draw_image(c, img, &src, &dst);\n}\n\nret_t canvas_set_fps(canvas_t* c, bool_t show_fps, uint32_t fps) {\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  c->show_fps = show_fps;\n  c->fps = fps;\n\n  return RET_OK;\n}\n\nstatic ret_t canvas_draw_fps(canvas_t* c) {\n  lcd_t* lcd = c->lcd;\n\n  if (c->show_fps && c->lcd->draw_mode == LCD_DRAW_NORMAL) {\n    rect_t r;\n    char fps[20];\n    wchar_t wfps[20];\n\n    r = rect_init(0, 0, 60, 30);\n    canvas_set_font(c, NULL, 16);\n    canvas_set_text_color(c, color_init(0xf0, 0xf0, 0xf0, 0xff));\n    canvas_set_fill_color(c, color_init(0x20, 0x20, 0x20, 0xff));\n\n    lcd->fps_rect = r;\n    tk_snprintf(fps, sizeof(fps), \"%dfps\", (int)(c->fps));\n\n    tk_utf8_to_utf16(fps, wfps, strlen(fps) + 1);\n    canvas_fill_rect(c, r.x, r.y, r.w, r.h);\n    canvas_draw_text(c, wfps, wcslen(wfps), r.x + 8, r.y + 8);\n  } else {\n    lcd->fps_rect.w = 0;\n    lcd->fps_rect.h = 0;\n  }\n\n  return RET_OK;\n}\n\nfloat_t canvas_get_font_height(canvas_t* c) {\n  font_vmetrics_t vmetrics;\n  return_value_if_fail(c != NULL && c->font_size > 0, 0);\n  vmetrics = font_get_vmetrics(c->font, c->font_size);\n\n  return vmetrics.ascent - vmetrics.descent;\n}\n\nret_t canvas_draw_text_in_rect(canvas_t* c, const wchar_t* str, uint32_t nr, const rect_t* r_in) {\n  int x = 0;\n  int y = 0;\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n  int32_t text_w = 0;\n  int32_t height = canvas_get_font_height(c);\n  rect_t* r = canvas_fix_rect(r_in, &r_fix);\n  return_value_if_fail(c != NULL && str != NULL && r != NULL, RET_BAD_PARAMS);\n\n  text_w = canvas_measure_text(c, str, nr);\n\n  switch (c->text_align_v) {\n    case ALIGN_V_TOP:\n      y = r->y;\n      break;\n    case ALIGN_V_BOTTOM:\n      y = r->y + (r->h - height);\n      break;\n    default:\n      y = r->y + ((r->h - height) >> 1);\n      break;\n  }\n\n  switch (c->text_align_h) {\n    case ALIGN_H_LEFT:\n      x = r->x;\n      break;\n    case ALIGN_H_RIGHT:\n      x = r->x + (r->w - text_w);\n      break;\n    default:\n      x = r->x + ((r->w - text_w) >> 1);\n      break;\n  }\n\n  return canvas_draw_text(c, str, nr, x, y);\n}\n\n#define STR_ELLIPSES L\"...\"\n\nstatic ret_t canvas_draw_text_in_rect_ellipses(canvas_t* c, const wchar_t* str, uint32_t nr,\n                                               const rect_t* r_in, bidi_type_t type) {\n  uint32_t i = 0;\n  rect_t r = *r_in;\n  float_t text_w = 0;\n  float_t ellipses_w = canvas_measure_text(c, STR_ELLIPSES, wcslen(STR_ELLIPSES));\n\n  for (i = 0; i < nr; i++) {\n    float_t char_w = canvas_measure_text(c, str + i, 1);\n    if ((text_w + char_w + ellipses_w) >= r.w) {\n      break;\n    }\n\n    text_w += char_w;\n  }\n\n  r.w = text_w;\n  canvas_draw_text_in_rect(c, str, i, &r);\n  r.x = text_w;\n  r.w = ellipses_w;\n  canvas_draw_text_in_rect(c, STR_ELLIPSES, wcslen(STR_ELLIPSES), &r);\n\n  return RET_OK;\n}\n\nret_t canvas_draw_text_bidi_in_rect(canvas_t* c, const wchar_t* str, uint32_t nr,\n                                    const rect_t* r_in, const char* bidi_type, bool_t ellipses) {\n  bidi_t b;\n  ret_t ret = RET_FAIL;\n  return_value_if_fail(c != NULL && str != NULL && r_in != NULL, RET_BAD_PARAMS);\n\n  if (nr == 0) {\n    return RET_OK;\n  }\n\n  bidi_init(&b, FALSE, FALSE, bidi_type_from_name(bidi_type));\n  if (bidi_log2vis(&b, str, nr) == RET_OK) {\n    float_t text_w = canvas_measure_text(c, b.vis_str, b.vis_str_size);\n    if (ellipses && text_w > r_in->w) {\n      ret = canvas_draw_text_in_rect_ellipses(c, b.vis_str, b.vis_str_size, r_in, b.resolved_type);\n    } else {\nret = ",
    "raw_res": "",
    "prompt_res": "canvas_draw_text_in_rect(c, b.vis_str, b.vis_str_size, r_in);",
    "gt": "canvas_draw_text_in_rect(c, b.vis_str, b.vis_str_size, r_in);"
  },
  {
    "id": 2192,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/text_edit.c",
    "input": "﻿/**\n * File:   text_edit.c\n * Author: AWTK Develop Team\n * Brief:  text_edit\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-06-08 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include <wctype.h>\n\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/darray.h\"\n#include \"base/bidi.h\"\n#include \"base/line_parser.h\"\n#include \"base/events.h\"\n#include \"base/text_edit.h\"\n#include \"base/line_break.h\"\n#include \"base/clip_board.h\"\n#include \"base/input_method.h\"\n\n#define CHAR_SPACING 1\n#define FONT_BASELINE 1.25f\n#define STB_TEXTEDIT_CHARTYPE wchar_t\n#define STB_TEXTEDIT_NEWLINE (wchar_t)('\\n')\n#define STB_TEXTEDIT_STRING text_edit_t\n\n#if !defined(WITH_SDL)\n#define STB_TEXTEDIT_UNDOSTATECOUNT 10\n#define STB_TEXTEDIT_UNDOCHARCOUNT 32\n#endif /*WITH_SDL*/\n#define STB_TEXTEDIT_GETWIDTH_NEWLINE 0xffff\n\n#include \"stb/stb_textedit.h\"\n\n#define GET_CANVAS(text_edit) widget_get_canvas(WIDGET(text_edit->widget))\ntypedef struct _text_layout_info_t {\n  int32_t w;\n  int32_t h;\n  int32_t ox;\n  int32_t oy;\n\n  uint32_t virtual_w;\n  uint32_t virtual_h;\n  uint32_t widget_w;\n  uint32_t widget_h;\n  uint32_t margin_l;\n  uint32_t margin_t;\n  uint32_t margin_r;\n  uint32_t margin_b;\n} text_layout_info_t;\n\ntypedef struct _line_info_t {\n  uint16_t x;\n  uint32_t offset;\n  uint16_t length;\n  uint16_t text_w;\n} line_info_t;\n\ntypedef struct _row_info_t {\n  uint16_t length;\n  uint32_t line_num;\n  darray_t info;\n} row_info_t;\n\ntypedef struct _rows_t {\n  uint32_t size;\n  uint32_t capacity;\n  uint32_t* row_line;\n  row_info_t row[1];\n} rows_t;\n\ntypedef struct _text_edit_impl_t {\n  text_edit_t text_edit;\n  STB_TexteditState state;\n\n  rows_t* rows;\n  uint32_t max_chars;\n  point_t caret;\n  bool_t overwrite;\n  bool_t wrap_word;\n  bool_t single_line;\n  bool_t caret_visible;\n  uint32_t line_height;\n  uint32_t last_line_number;\n  uint32_t last_row_number;\n  uint32_t caret_line_index;\n  text_layout_info_t layout_info;\n\n  bool_t preedit;\n  uint32_t preedit_chars_nr;\n\n  bool_t lock_scrollbar_value;\n\n  /*for single line edit*/\n  wchar_t mask_char;\n  bool_t mask;\n  wstr_t tips;\n  bool_t is_mlines;\n\n  bool_t is_first_time_layout;\n  int32_t font_size;\n  const char* font_name;\n  void* on_state_changed_ctx;\n  text_edit_on_state_changed_t on_state_changed;\n} text_edit_impl_t;\n\n#define DECL_IMPL(te) text_edit_impl_t* impl = (text_edit_impl_t*)(te)\n\nstatic ret_t text_edit_notify(text_edit_t* text_edit);\nstatic bool_t text_edit_is_need_layout(text_edit_t* text_edit);\nstatic int32_t text_edit_calc_x(text_edit_t* text_edit, line_info_t* iter);\n\nstatic align_h_t widget_get_text_align_h(widget_t* widget) {\n  return (align_h_t)style_get_int(widget->astyle, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_LEFT);\n}\n\n#define TEXT_EDIT_GET_WIDGET_MARGIN(widget, style, out_value, type)             \\\n  {                                                                             \\\n    value_t v;                                                                  \\\n    value_set_int(&v, 0);                                                       \\\n    if (widget_get_prop((widget), WIDGET_PROP_##type##_MARGIN, &v) == RET_OK) { \\\n      (out_value) = value_int(&v);                                              \\\n    }                                                                           \\\n    TEXT_EDIT_GET_STYLE_MARGIN(style, out_value, type)                          \\\n  }\n\nstatic ret_t widget_get_text_layout_info(widget_t* widget, text_layout_info_t* info) {\n  style_t* style = widget->astyle;\n  return_value_if_fail(widget != NULL && info != NULL && style != NULL, RET_BAD_PARAMS);\n\n  info->widget_w = widget->w;\n  info->widget_h = widget->h;\n  info->virtual_w = tk_max(info->virtual_w, widget->w);\n  info->virtual_h = tk_max(info->virtual_h, widget->h);\n\n  TEXT_EDIT_GET_WIDGET_MARGIN(widget, style, info->margin_l, LEFT);\n  TEXT_EDIT_GET_WIDGET_MARGIN(widget, style, info->margin_r, RIGHT);\n  TEXT_EDIT_GET_WIDGET_MARGIN(widget, style, info->margin_t, TOP);\n  TEXT_EDIT_GET_WIDGET_MARGIN(widget, style, info->margin_b, BOTTOM);\n\n  info->w = info->widget_w - info->margin_l - info->margin_r;\n  info->h = info->widget_h - info->margin_t - info->margin_b;\n\n  return RET_OK;\n}\n\nstatic rows_t* rows_create(uint32_t capacity) {\n  uint32_t msize = sizeof(rows_t) + capacity * sizeof(row_info_t);\n  rows_t* rows = (rows_t*)TKMEM_ALLOC(msize);\n  uint32_t i = 0;\n  return_value_if_fail(rows != NULL, NULL);\n\n  memset(rows, 0x00, msize);\n  for (i = 0; i < capacity; i++) {\n    darray_init(&rows->row[i].info, 4, default_destroy, NULL);\n    darray_push(&rows->row[i].info, TKMEM_ZALLOC(line_info_t));\n    rows->row[i].line_num = 1;\n  }\n\n  rows->row_line = TKMEM_ZALLOCN(uint32_t, capacity);\n  rows->capacity = capacity;\n\n  return rows;\n}\n\nstatic line_info_t* line_find_by_offset(rows_t* rows, uint32_t offset) {\n  uint32_t i = 0;\n  return_value_if_fail(rows != NULL, NULL);\n\n  for (i = 0; i < rows->size; i++) {\n    uint32_t j = 0;\n    row_info_t* row = rows->row + i;\n    for (j = 0; j < row->line_num; j++) {\n      line_info_t* line = (line_info_t*)darray_get(&row->info, j);\n      if (line->offset == offset) {\n        return line;\n      }\n    }\n  }\n\n  return NULL;\n}\n\nstatic ret_t rows_destroy(rows_t* rows) {\n  uint32_t i = 0;\n  return_value_if_fail(rows != NULL, RET_BAD_PARAMS);\n\n  for (i = 0; i < rows->capacity; i++) {\n    darray_deinit(&rows->row[i].info);\n  }\n  TKMEM_FREE(rows->row_line);\n  TKMEM_FREE(rows);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_set_caret_pos(text_edit_impl_t* impl, uint32_t x, uint32_t y,\n                                     uint32_t font_size, uint32_t line_number) {\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  uint32_t caret_top = layout_info->margin_t + y;\n  uint32_t caret_bottom = layout_info->margin_t + y + font_size;\n  uint32_t caret_left = layout_info->margin_l + x;\n  uint32_t caret_right = layout_info->margin_l + x + 1;\n\n  uint32_t view_top = layout_info->oy + layout_info->margin_t;\n  uint32_t view_bottom = layout_info->oy + layout_info->margin_t + layout_info->h;\n  uint32_t view_left = layout_info->ox + layout_info->margin_l;\n  uint32_t view_right = layout_info->ox + layout_info->margin_l + layout_info->w;\n\n  impl->caret.x = x;\n  impl->caret.y = y;\n  impl->caret_line_index = line_number;\n\n  if (!impl->lock_scrollbar_value) {\n    if (view_top > caret_top) {\n      layout_info->oy = caret_top - layout_info->margin_t;\n    }\n\n    if (view_bottom < caret_bottom) {\n      layout_info->oy = caret_bottom - layout_info->h;\n    }\n\n    if (view_left > caret_left) {\n      layout_info->ox = caret_left - layout_info->margin_l;\n    }\n\n    if (view_right < caret_right || (view_left > caret_left + layout_info->w)) {\n      layout_info->ox = caret_right - layout_info->w - layout_info->margin_l;\n    }\n  }\n\n  if (layout_info->ox < 0) {\n    layout_info->ox = 0;\n  }\n\n  if (impl->wrap_word) {\n    layout_info->ox = 0;\n  }\n\n  if (impl->single_line) {\n    layout_info->oy = 0;\n  }\n\n  return RET_OK;\n}\n\nstatic uint32_t text_edit_measure_text_on_canvas(text_edit_t* text_edit, wchar_t* str,\n                                                 wchar_t mask_char, uint32_t size, canvas_t* c) {\n  uint32_t i = 0;\n  uint32_t w = 0;\n  DECL_IMPL(text_edit);\n\n  for (i = 0; i < size; i++) {\n    bool_t preedit = impl->preedit && i < impl->state.cursor &&\n                     i >= (impl->state.cursor - impl->preedit_chars_nr);\n    wchar_t chr = (mask_char && !preedit) ? mask_char : str[i];\n\n    w += canvas_measure_text(c, &chr, 1) + CHAR_SPACING;\n  }\n\n  return w;\n}\n\nstatic uint32_t text_edit_measure_text(text_edit_t* text_edit, wchar_t* str, wchar_t mask_char,\n                                       uint32_t size) {\n  return text_edit_measure_text_on_canvas(text_edit, str, mask_char, size, GET_CANVAS(text_edit));\n}\n\nstatic row_info_t* text_edit_single_line_layout_line(text_edit_t* text_edit, uint32_t row_num,\n                                                     uint32_t line_index, uint32_t offset) {\n  uint32_t y = 0;\n  uint32_t caret_x = 0;\n  uint32_t view_left = 0;\n  uint32_t caret_left = 0;\n  DECL_IMPL(text_edit);\n  canvas_t* c = GET_CANVAS(text_edit);\n  wstr_t* text = &(text_edit->widget->text);\n  STB_TexteditState* state = &(impl->state);\n  row_info_t* row = impl->rows->row + row_num;\n  wchar_t mask_char = impl->mask ? impl->mask_char : 0;\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  align_h_t align_h = widget_get_text_align_h(text_edit->widget);\n  uint32_t text_w = text_edit_measure_text(text_edit, text->str, mask_char, text->size);\n  uint32_t caret_text_w = text_edit_measure_text(text_edit, text->str, mask_char, state->cursor);\n  line_info_t* line = (line_info_t*)darray_head(&row->info);\n\n  assert(offset == 0 && row_num == 0);\n\n  memset(row, 0x00, sizeof(row_info_t) - sizeof(darray_t));\n\n  row->line_num = 1;\n  line->offset = 0;\n  line->text_w = text_w;\n  line->length = text->size;\n  row->length = line->length;\n  line->x = text_edit_calc_x(text_edit, line);\n  layout_info->virtual_h = tk_max(y, layout_info->widget_h);\n\n  caret_x = caret_text_w;\n  caret_left = layout_info->margin_l + caret_x;\n  view_left = layout_info->ox + layout_info->margin_l;\n  if ((text_w < layout_info->w) ||\n      (view_left + c->font_size >= caret_left && state->cursor == text->size)) {\n    layout_info->ox = 0;\n    if (align_h == ALIGN_H_RIGHT) {\n      caret_x = layout_info->w - (text_w - caret_text_w);\n    } else if (align_h == ALIGN_H_CENTER) {\n      caret_x = (layout_info->w - text_w) / 2 + caret_text_w;\n    }\n  }\n  text_edit_set_caret_pos(impl, caret_x, y, c->font_size, line_index);\n\n  return row;\n}\n\nstatic row_info_t* text_edit_multi_line_layout_line(text_edit_t* text_edit, uint32_t row_num,\n                                                    uint32_t line_index, uint32_t offset) {\n  uint32_t i = 0;\n  uint32_t x = 0;\n  DECL_IMPL(text_edit);\n  wchar_t last_char = 0;\n  point_t caret = {-1, -1};\n  canvas_t* c = GET_CANVAS(text_edit);\n  wstr_t* text = &(text_edit->widget->text);\n  STB_TexteditState* state = &(impl->state);\n  row_info_t* row = impl->rows->row + row_num;\n  uint32_t line_height = impl->line_height;\n  uint32_t y = line_index * line_height;\n  uint32_t offset0 = offset;\n  uint32_t last_breakable_i = 0;\n  uint32_t last_breakable_x = 0;\n  line_info_t* last_line = NULL;\n  text_layout_info_t* layout_info = &(impl->layout_info);\n\n  memset(row, 0x00, sizeof(row_info_t) - sizeof(darray_t));\n  row->line_num = 1;\n\n  for (i = offset; i < text->size; i++) {\n    wchar_t* p = text->str + i;\n    break_type_t word_break = LINE_BREAK_NO;\n    break_type_t line_break = LINE_BREAK_NO;\n    uint32_t char_w = canvas_measure_text(c, p, 1) + CHAR_SPACING;\n\n    if (i == state->cursor) {\n      caret.x = x;\n      caret.y = y;\n    }\n\n    last_char = *p;\n    line_break = line_break_check(*p, p[1]);\n    if (line_break == LINE_BREAK_MUST) {\n      i++;\n      break;\n    }\n\n    if (impl->wrap_word) {\n      if ((x + char_w) > layout_info->w) {\n        if (last_breakable_x > 0) {\n          i = last_breakable_i + 1;\n          x = last_breakable_x;\n          last_breakable_x = 0;\n        }\n        if (i == offset) {\n          i++;\n        }\n\n        last_line = (line_info_t*)darray_get(&row->info, row->line_num - 1);\n        memset(last_line, 0x00, sizeof(line_info_t));\n        last_line->text_w = x;\n        last_line->offset = offset;\n        last_line->length = i - offset;\n\n        row->line_num++;\n        if (row->info.size < row->line_num) {\n          darray_push(&row->info, TKMEM_ZALLOC(line_info_t));\n        }\n\n        p = text->str + i;\n        char_w = canvas_measure_text(c, p, 1) + CHAR_SPACING;\n\n        x = char_w;\n        y += line_height;\n        offset = i;\n        line_index++;\n        if (state->cursor == i) {\n          caret.x = 0;\n          caret.y = y;\n        }\n        continue;\n      }\n\n      x += char_w;\n      word_break = word_break_check(*p, p[1]);\n      if (word_break == LINE_BREAK_ALLOW && line_break == LINE_BREAK_ALLOW) {\n        last_breakable_x = x;\n        last_breakable_i = i;\n      }\n    } else {\n      x += char_w;\n    }\n  }\n\n  while (row->info.size > row->line_num) {\n    row->info.destroy(darray_pop(&row->info));\n  }\n\n  if (last_char == STB_TEXTEDIT_NEWLINE) {\n    impl->last_row_number = row_num + 1;\n    impl->last_line_number = line_index + 1;\n  } else {\n    impl->last_row_number = row_num;\n    impl->last_line_number = line_index;\n  }\n\n  if (i == state->cursor && state->cursor == text->size) {\n    if (last_char == STB_TEXTEDIT_NEWLINE) {\n      caret.x = 0;\n      caret.y = y + line_height;\n    } else {\n      caret.x = x;\n      caret.y = y;\n    }\n  }\n  if (caret.x >= 0 && caret.y >= 0) {\n    /* 计算好了再统一修改光标坐标，以免多次修改导致滚动条的位置突变 */\n    text_edit_set_caret_pos(impl, caret.x, caret.y, c->font_size, line_index);\n  }\n\n  last_line = (line_info_t*)darray_get(&row->info, row->line_num - 1);\n  memset(last_line, 0x00, sizeof(line_info_t));\n  last_line->text_w = x;\n  last_line->offset = offset;\n  last_line->length = i - offset;\n\n  row->length = i - offset0;\n  layout_info->virtual_h = tk_max(y + line_height, layout_info->widget_h);\n\n  return row;\n}\n\nstatic ret_t text_edit_fix_oy(text_edit_impl_t* impl) {\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  uint32_t total_line_height = (impl->last_line_number + 1) * impl->line_height;\n  uint32_t max_oy = (total_line_height > layout_info->h) ? total_line_height - layout_info->h : 0;\n\n  layout_info->oy = tk_min(layout_info->oy, max_oy);\n\n  return RET_OK;\n}\n\nstatic row_info_t* text_edit_layout_line(text_edit_t* text_edit, uint32_t row_num,\n                                         uint32_t line_index, uint32_t offset) {\n  DECL_IMPL(text_edit);\n  if (impl->single_line) {\n    return text_edit_single_line_layout_line(text_edit, row_num, line_index, offset);\n  } else {\n    return text_edit_multi_line_layout_line(text_edit, row_num, line_index, offset);\n  }\n}\n\nstatic ret_t text_edit_layout_impl(text_edit_t* text_edit) {\n  uint32_t i = 0;\n  uint32_t offset = 0;\n  DECL_IMPL(text_edit);\n  row_info_t* iter = NULL;\n  canvas_t* c = GET_CANVAS(text_edit);\n  uint32_t max_rows = impl->rows->capacity;\n  wstr_t* text = &(text_edit->widget->text);\n  uint32_t size = text_edit->widget->text.size;\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  uint32_t char_w = 0;\n  uint32_t line_index = 0;\n  impl->caret.x = 0;\n  impl->caret.y = 0;\n  impl->rows->size = 0;\n\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  widget_prepare_text_style(text_edit->widget, c);\n  impl->line_height = c->font_size * FONT_BASELINE;\n  widget_get_text_layout_info(text_edit->widget, layout_info);\n  char_w = canvas_measure_text(c, text->str, 1) + CHAR_SPACING;\n\n  if (layout_info->w < char_w) {\n    return RET_OK;\n  }\n\n  while ((offset < size || size == 0) && i < max_rows) {\n    iter = text_edit_layout_line(text_edit, i, line_index, offset);\n    if (iter == NULL || iter->length == 0) {\n      break;\n    }\n    line_index += iter->line_num;\n    offset += iter->length;\n    i++;\n  }\n\n  if (offset < size) {\n    text->size = offset;\n    text->str[offset] = L'\\0';\n  }\n\n  impl->rows->size = i;\n\n  text_edit_fix_oy(impl);\n\n  text_edit_notify(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_layout(text_edit_t* text_edit) {\n  if (text_edit == NULL || GET_CANVAS(text_edit) == NULL || text_edit->widget == NULL ||\n      text_edit->widget->initializing || text_edit->widget->loading) {\n    return RET_BAD_PARAMS;\n  }\n\n  return text_edit_layout_impl(text_edit);\n}\n\nstatic void text_edit_layout_for_stb(StbTexteditRow* row, STB_TEXTEDIT_STRING* str, int offset) {\n  DECL_IMPL(str);\n  canvas_t* c = GET_CANVAS(str);\n  if (c == NULL) return;\n  uint32_t font_size = c->font_size;\n  line_info_t* info = line_find_by_offset(impl->rows, offset);\n\n  if (info != NULL) {\n    row->x0 = info->x;\n    row->x1 = info->x + info->text_w;\n    row->num_chars = info->length;\n  } else {\n    row->x0 = 0;\n    row->x1 = 0;\n    row->num_chars = 1;\n  }\n\n  row->ymin = 0;\n  row->ymax = font_size;\n  row->baseline_y_delta = impl->line_height;\n\n  return;\n}\n\nstatic ret_t text_edit_paint_caret(text_edit_t* text_edit, canvas_t* c) {\n  DECL_IMPL(text_edit);\n  widget_t* widget = text_edit->widget;\n  style_t* style = widget->astyle;\n  color_t black = color_init(0, 0, 0, 0xff);\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  color_t caret_color = style_get_color(style, STYLE_ID_TEXT_COLOR, black);\n  uint32_t x = layout_info->margin_l + impl->caret.x - layout_info->ox;\n  uint32_t y = layout_info->margin_t + impl->caret.y - layout_info->oy;\n\n  if (impl->single_line) {\n    y += (layout_info->h - c->font_size) / 2;\n  }\n\n  canvas_set_stroke_color(c, caret_color);\n  canvas_draw_vline(c, x, y, c->font_size);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_paint_tips_mlines_text(text_edit_t* text_edit, canvas_t* c,\n                                              line_parser_t* p) {\n  int32_t y = 0;\n  int32_t w = 0;\n  int32_t font_size = 0;\n  int32_t line_height = 0;\n  DECL_IMPL(text_edit);\n  text_layout_info_t* layout_info = 0;\n  return_value_if_fail(text_edit != NULL && text_edit->widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  font_size = c->font_size;\n  layout_info = &(impl->layout_info);\n  line_height = font_size + style_get_int(text_edit->widget->astyle, STYLE_ID_SPACER, 2);\n\n  w = layout_info->w;\n  y = layout_info->margin_t;\n  while (line_parser_next(p) == RET_OK) {\n    uint32_t size = 0;\n    rect_t r = rect_init(layout_info->margin_l, y, w, font_size);\n\n    if ((y + font_size) > layout_info->h) {\n      break;\n    }\n\n    for (size = 0; size < p->line_size; size++) {\n      if (CHAR_IS_LINE_BREAK(p->line[size])) {\n        break;\n      }\n    }\n    canvas_draw_text_in_rect(c, p->line, size, &r);\n\n    y += line_height;\n  }\n  return RET_OK;\n}\n\nstatic ret_t text_edit_paint_tips_text(text_edit_t* text_edit, canvas_t* c) {\n  DECL_IMPL(text_edit);\n  wstr_t* text = &(impl->tips);\n  text_layout_info_t* layout_info = &(impl->layout_info);\n\n  if (text->size > 0) {\n    if (impl->is_mlines) {\n      line_parser_t p;\n      line_parser_init(&p, c, (const wchar_t*)(text->str), text->size, c->font_size, layout_info->w,\n                       TRUE, TRUE);\n      if (p.total_lines > 1) {\n        text_edit_paint_tips_mlines_text(text_edit, c, &p);\n      } else {\n        align_h_t align_h = c->text_align_h;\n        align_v_t align_v = c->text_align_v;\n        rect_t r =\n            rect_init(layout_info->margin_l, layout_info->margin_t, layout_info->w, layout_info->h);\n        canvas_set_text_align(c, align_h, ALIGN_V_TOP);\n        canvas_draw_text_in_rect(c, text->str, text->size, &r);\n        canvas_set_text_align(c, align_h, align_v);\n      }\n      line_parser_deinit(&p);\n    } else {\n      rect_t r =\n          rect_init(layout_info->margin_l, layout_info->margin_t, layout_info->w, layout_info->h);\n      canvas_draw_text_in_rect(c, text->str, text->size, &r);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic int32_t text_edit_calc_x_on_canvas(text_edit_t* text_edit, line_info_t* iter, canvas_t* c) {\n  DECL_IMPL(text_edit);\n  widget_t* widget = text_edit->widget;\n  wstr_t* text = &(widget->text);\n  wchar_t chr = impl->mask ? impl->mask_char : 0;\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  align_h_t align_h = widget_get_text_align_h(text_edit->widget);\n\n  uint32_t row_width =\n      text_edit_measure_text_on_canvas(text_edit, text->str + iter->offset, chr, iter->length, c);\n  if (row_width < layout_info->w) {\n    switch (align_h) {\n      case ALIGN_H_CENTER: {\n        return (layout_info->w - row_width) / 2;\n      }\n      case ALIGN_H_RIGHT: {\n        return (layout_info->w - row_width);\n      }\n      default: {\n        break;\n      }\n    }\n  }\n\n  return 0;\n}\n\nstatic int32_t text_edit_calc_x(text_edit_t* text_edit, line_info_t* iter) {\n  return text_edit_calc_x_on_canvas(text_edit, iter, GET_CANVAS(text_edit));\n}\n\nstatic ret_t text_edit_paint_line(text_edit_t* text_edit, canvas_t* c, line_info_t* iter,\n                                  uint32_t y) {\n  bidi_t b;\n  uint32_t x = 0;\n  uint32_t k = 0;\n  widget_t* widget = text_edit->widget;\n  const char* bidi_type = widget_get_prop_str(widget, WIDGET_PROP_BIDI, NULL);\n  DECL_IMPL(text_edit);\n  wstr_t* text = &(widget->text);\n  style_t* style = widget->astyle;\n  STB_TexteditState* state = &(impl->state);\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  uint32_t view_left = layout_info->ox + layout_info->margin_l;\n  uint32_t view_right = layout_info->ox + layout_info->margin_l + layout_info->w;\n\n  color_t black = color_init(0, 0, 0, 0xff);\n  color_t white = color_init(0xf0, 0xf0, 0xf0, 0xff);\n\n  uint32_t select_start = tk_min(state->select_start, state->select_end);\n  uint32_t select_end = tk_max(state->select_start, state->select_end);\n\n  if (impl->single_line) {\n    x = layout_info->margin_l + text_edit_calc_x_on_canvas(text_edit, iter, c);\n  } else {\n    x = layout_info->margin_l;\n  }\n\n  bidi_init(&b, FALSE, FALSE, bidi_type_from_name(bidi_type));\n  ENSURE(bidi_log2vis(&b, text->str + iter->offset, iter->length) == RET_OK);\n\n  for (k = 0; k < iter->length; k++) {\n    uint32_t offset = iter->offset + k;\n    uint32_t cursor = state->cursor;\n    bool_t selected = offset >= select_start && offset < select_end;\n    bool_t preedit =\n        impl->preedit && offset < cursor && offset >= (cursor - impl->preedit_chars_nr);\n    wchar_t chr = (impl->mask && !preedit) ? impl->mask_char : b.vis_str[k];\n    uint32_t char_w = canvas_measure_text(c, &chr, 1);\n\n    if ((x + char_w) < view_left) {\n      x += char_w + CHAR_SPACING;\n      continue;\n    }\n\n    if (x > view_right) {\n      break;\n    }\n\n    if (chr != STB_TEXTEDIT_NEWLINE) {\n      xy_t rx = x - layout_info->ox;\n      xy_t ry = y - layout_info->oy;\n\n      if (selected || preedit) {\n        color_t select_bg_color = style_get_color(style, STYLE_ID_SELECTED_BG_COLOR, white);\n        color_t select_text_color = style_get_color(style, STYLE_ID_SELECTED_TEXT_COLOR, black);\n\n        canvas_set_fill_color(c, select_bg_color);\n        canvas_fill_rect(c, rx, ry, char_w + CHAR_SPACING, c->font_size);\n\n        canvas_set_text_color(c, select_text_color);\n      } else {\n        color_t text_color = style_get_color(style, STYLE_ID_TEXT_COLOR, black);\n        canvas_set_text_color(c, text_color);\n      }\n\n      /*FIXME: 密码编辑时，*字符本身偏高，看起来不像居中。但是无法拿到字模信息，只好手工修正一下。*/\n      if (impl->mask && !preedit && impl->mask_char == '*') {\n        int32_t oy = c->font_size / 6;\n        canvas_draw_text(c, &chr, 1, rx, ry + oy);\n      } else {\n        canvas_draw_text(c, &chr, 1, rx, ry);\n      }\n\n      x += char_w + CHAR_SPACING;\n    }\n  }\n  bidi_deinit(&b);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_paint_real_text(text_edit_t* text_edit, canvas_t* c) {\n  DECL_IMPL(text_edit);\n  rows_t* rows = impl->rows;\n  uint32_t line_height = impl->line_height;\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  int32_t view_top = layout_info->oy + layout_info->margin_t;\n  int32_t view_bottom = layout_info->oy + layout_info->margin_t + layout_info->h;\n\n  uint32_t i = 0;\n  uint32_t k = 0;\n  for (i = 0; i < rows->size; i++) {\n    uint32_t j = 0;\n    row_info_t* row = rows->row + i;\n\n    for (j = 0; j < row->line_num; j++, k++) {\n      line_info_t* line = (line_info_t*)darray_get(&row->info, j);\n      int32_t y = 0;\n\n      if (impl->single_line) {\n        y = (layout_info->h - c->font_size) / 2 + layout_info->margin_t;\n\n      } else {\n        y = k * line_height + layout_info->margin_t;\n      }\n\n      if ((y + c->font_size) < view_top) {\n        continue;\n      }\n\n      if (y > view_bottom) {\n        break;\n      }\n\n      text_edit_paint_line(text_edit, c, line, y);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_paint_text(text_edit_t* text_edit, canvas_t* c) {\n  widget_t* widget = text_edit->widget;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->text.size > 0) {\n    return text_edit_paint_real_text(text_edit, c);\n  } else {\n    color_t trans =\n        style_get_color(widget->astyle, STYLE_ID_TEXT_COLOR, color_init(0x0, 0x0, 0x0, 0x0));\n    color_t tc = style_get_color(widget->astyle, STYLE_ID_TIPS_TEXT_COLOR, trans);\n    align_h_t align_h =\n        (align_h_t)style_get_int(widget->astyle, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_LEFT);\n    align_v_t align_v =\n        (align_v_t)style_get_int(widget->astyle, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    canvas_set_text_color(c, tc);\n    canvas_set_text_align(c, align_h, align_v);\n    return text_edit_paint_tips_text(text_edit, c);\n  }\n}\n\nstatic ret_t text_edit_do_paint(text_edit_t* text_edit, canvas_t* c) {\n  bool_t is_notify = FALSE;\n  uint32_t new_line_height = 0;\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL && c != NULL, RET_BAD_PARAMS);\n\n  widget_prepare_text_style(text_edit->widget, c);\n  widget_get_text_layout_info(text_edit->widget, &(impl->layout_info));\n\n  new_line_height = c->font_size * FONT_BASELINE;\n  is_notify = impl->line_height != new_line_height;\n  impl->line_height = new_line_height;\n\n  if (text_edit_paint_text(text_edit, c) == RET_OK) {\n    DECL_IMPL(text_edit);\n    STB_TexteditState* state = &(impl->state);\n\n    if (state->select_start == state->select_end && impl->caret_visible) {\n      text_edit_paint_caret(text_edit, c);\n    }\n  }\n\n  if (is_notify) {\n    text_edit_layout(text_edit);\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_paint(text_edit_t* text_edit, canvas_t* c) {\n  rect_t save_r;\n  rect_t clip_r;\n  rect_t edit_r;\n  DECL_IMPL(text_edit);\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  style_t* style = text_edit->widget->astyle;\n\n  if (impl->is_first_time_layout) {\n    text_edit_layout(text_edit);\n    impl->is_first_time_layout = FALSE;\n\n    impl->font_size = style_get_int(style, STYLE_ID_FONT_SIZE, TK_DEFAULT_FONT_SIZE);\n    impl->font_name = system_info_fix_font_name(style_get_str(style, STYLE_ID_FONT_NAME, NULL));\n  } else {\n    if (text_edit_is_need_layout(text_edit)) {\n      text_edit_layout(text_edit);\n    }\n  }\n\n  canvas_get_clip_rect(c, &save_r);\n\n  edit_r = rect_init(c->ox + layout_info->margin_l, c->oy + layout_info->margin_t, layout_info->w,\n                     layout_info->h);\n  clip_r = rect_intersect(&save_r, &edit_r);\n\n  canvas_save(c);\n  canvas_set_clip_rect(c, &clip_r);\n  text_edit_do_paint(text_edit, c);\n  canvas_restore(c);\n\n  canvas_set_clip_rect(c, &save_r);\n\n  return RET_OK;\n}\n\nstatic int text_edit_remove(STB_TEXTEDIT_STRING* str, int pos, int num) {\n  wstr_t* text = &(str->widget->text);\n  wstr_remove(text, pos, num);\n\n  return TRUE;\n}\n\nstatic int text_edit_get_char_width(STB_TEXTEDIT_STRING* str, int pos, int offset) {\n  wstr_t* text = &(str->widget->text);\n  wchar_t chr = text->str[pos + offset];\n\n  if (chr == STB_TEXTEDIT_NEWLINE) {\n    return STB_TEXTEDIT_GETWIDTH_NEWLINE;\n  } else {\n    return canvas_measure_text(GET_CANVAS(str), &chr, 1) + CHAR_SPACING;\n  }\n}\n\nstatic int text_edit_insert(STB_TEXTEDIT_STRING* str, int pos, STB_TEXTEDIT_CHARTYPE* newtext,\n                            int num) {\n  bool_t ret = FALSE;\n  wstr_t* text = &(str->widget->text);\n  DECL_IMPL(str);\n  uint32_t line_break_num = impl->rows->capacity > impl->last_row_number\n                                ? impl->rows->capacity - impl->last_row_number\n                                : 0;\n  uint32_t i = 0;\n\n  for (i = 0; i < num; i++) {\n    if (i + 1 < num && TWINS_WCHAR_IS_LINE_BREAK(newtext[i], newtext[i + 1])) {\n      line_break_num--;\n      i++;\n    } else if (WCHAR_IS_LINE_BREAK(newtext[i])) {\n      line_break_num--;\n    }\n    if (line_break_num == 0) {\n      num = i;\n      break;\n    }\n  }\n\n  if (impl->max_chars > 0) {\n    uint32_t surplus_char = impl->max_chars > text->size ? impl->max_chars - text->size : 0;\n    num = tk_min(num, surplus_char);\n  }\n\n  if (num > 0) {\n    wstr_insert(text, pos, newtext, num);\n    ret = TRUE;\n  }\n\n  return (int)ret;\n}\n\n#define KEYDOWN_BIT 0x80000000\n#define STB_TEXTEDIT_STRINGLEN(str) ((str)->widget->text.size)\n#define STB_TEXTEDIT_LAYOUTROW text_edit_layout_for_stb\n#define STB_TEXTEDIT_GETWIDTH(str, n, i) text_edit_get_char_width(str, n, i)\n#define STB_TEXTEDIT_KEYTOTEXT(key) (((key)&KEYDOWN_BIT) ? 0 : ((uint16_t)key))\n#define STB_TEXTEDIT_GETCHAR(str, i) (((str)->widget->text).str[i])\n#define STB_TEXTEDIT_IS_SPACE(ch) iswspace(ch)\n#define STB_TEXTEDIT_DELETECHARS text_edit_remove\n#define STB_TEXTEDIT_INSERTCHARS text_edit_insert\n\n#define STB_TEXTEDIT_K_SHIFT 0x40000000\n#define STB_TEXTEDIT_K_CONTROL 0x20000000\n#define STB_TEXTEDIT_K_LEFT (KEYDOWN_BIT | 1)\n#define STB_TEXTEDIT_K_RIGHT (KEYDOWN_BIT | 2)  // VK_RIGHT\n#define STB_TEXTEDIT_K_UP (KEYDOWN_BIT | 3)  // VK_UP\n#define STB_TEXTEDIT_K_DOWN (KEYDOWN_BIT | 4)  // VK_DOWN\n#define STB_TEXTEDIT_K_LINESTART (KEYDOWN_BIT | 5)  // VK_HOME\n#define STB_TEXTEDIT_K_LINEEND (KEYDOWN_BIT | 6)  // VK_END\n#define STB_TEXTEDIT_K_TEXTSTART (STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_CONTROL)\n#define STB_TEXTEDIT_K_TEXTEND (STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_CONTROL)\n#define STB_TEXTEDIT_K_DELETE (KEYDOWN_BIT | 7)  // VK_DELETE\n#define STB_TEXTEDIT_K_BACKSPACE (KEYDOWN_BIT | 8)  // VK_BACKSPACE\n#define STB_TEXTEDIT_K_UNDO (KEYDOWN_BIT | STB_TEXTEDIT_K_CONTROL | 'z')\n#define STB_TEXTEDIT_K_REDO (KEYDOWN_BIT | STB_TEXTEDIT_K_CONTROL | 'y')\n#define STB_TEXTEDIT_K_INSERT (KEYDOWN_BIT | 9)  // VK_INSERT\n#define STB_TEXTEDIT_K_WORDLEFT (STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_CONTROL)\n#define STB_TEXTEDIT_K_WORDRIGHT (STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_CONTROL)\n#define STB_TEXTEDIT_K_PGUP (KEYDOWN_BIT | 10)  // VK_PGUP -- not implemented\n#define STB_TEXTEDIT_K_PGDOWN (KEYDOWN_BIT | 11)  // VK_PGDOWN -- not implemented\n\n#define STB_TEXTEDIT_IMPLEMENTATION 1\n\n#include \"stb/stb_textedit.h\"\n\ntext_edit_t* text_edit_create(widget_t* widget, bool_t single_line) {\n  text_edit_impl_t* impl = NULL;\n  return_value_if_fail(widget != NULL, NULL);\n\n  impl = TKMEM_ZALLOC(text_edit_impl_t);\n  return_value_if_fail(impl != NULL, NULL);\n\n  impl->is_first_time_layout = TRUE;\n  impl->wrap_word = !single_line;\n  impl->text_edit.widget = widget;\n  impl->single_line = single_line;\n\n  wstr_init(&(impl->tips), 0);\n  stb_textedit_initialize_state(&(impl->state), single_line);\n  if (!single_line) {\n    text_edit_set_max_rows((text_edit_t*)impl, 100);\n  } else {\n    text_edit_set_max_rows((text_edit_t*)impl, 1);\n  }\n\n  return (text_edit_t*)impl;\n}\n\nret_t text_edit_set_caret_visible(text_edit_t* text_edit, bool_t caret_visible) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit, RET_BAD_PARAMS);\n\n  impl->caret_visible = caret_visible;\n\n  return RET_OK;\n}\n\nret_t text_edit_invert_caret_visible(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit, RET_BAD_PARAMS);\n\n  impl->caret_visible = !impl->caret_visible;\n\n  return RET_OK;\n}\n\nret_t text_edit_set_max_rows(text_edit_t* text_edit, uint32_t max_rows) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL && max_rows >= 1, RET_BAD_PARAMS);\n\n  if (impl->rows != NULL) {\n    rows_destroy(impl->rows);\n    impl->rows = NULL;\n  }\n\n  if (impl->rows == NULL) {\n    impl->rows = rows_create(max_rows);\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_set_max_chars(text_edit_t* text_edit, uint32_t max_chars) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->max_chars = max_chars;\n\n  return RET_OK;\n}\n\nuint32_t text_edit_get_height(text_edit_t* text_edit, uint32_t offset) {\n  uint32_t i = 0;\n  uint32_t k = 0;\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, 0);\n\n  for (i = 0; i < impl->rows->size; i++) {\n    uint32_t j = 0;\n    row_info_t* row = impl->rows->row + i;\n    for (j = 0; j < row->line_num; j++, k++) {\n      line_info_t* line = (line_info_t*)darray_get(&row->info, j);\n      if (offset < line->offset + line->length) {\n        return impl->line_height * k;\n      }\n    }\n  }\n\n  return impl->line_height * ((k > 1) ? k - 1 : 0);\n}\n\nconst uint32_t* text_edit_get_lines_of_each_row(text_edit_t* text_edit) {\n  uint32_t* lines_of_each_row = NULL;\n  uint32_t size = 0;\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL && impl != NULL && impl->rows != NULL, NULL);\n\n  size = impl->rows->capacity;\n\n  if (size) {\n    uint32_t i = 0;\n    lines_of_each_row = impl->rows->row_line;\n    memset(lines_of_each_row, 0x00, sizeof(uint32_t) * size);\n\n    for (i = 0; i < impl->rows->size; i++) {\n      lines_of_each_row[i] = impl->rows->row[i].line_num;\n    }\n  }\n\n  return lines_of_each_row;\n}\n\nstatic uint32_t text_edit_get_line_break_offset(text_edit_t* text_edit, uint32_t num) {\n  uint32_t offset = 0;\n  uint32_t i = 0;\n  wstr_t* text = NULL;\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL && text_edit->widget != NULL, -1);\n  return_value_if_fail(0 < num && num < impl->rows->capacity, -1);\n\n  if (num >= impl->rows->size) {\n    return -1;\n  }\n\n  text = &text_edit->widget->text;\n\n  for (i = 0; i < num; i++) {\n    offset += impl->rows->row[i].length;\n  }\n\n  if (offset >= 2 && TWINS_WCHAR_IS_LINE_BREAK(text->str[offset - 2], text->str[offset - 1])) {\n    offset -= 2;\n  } else if (offset >= 1 && WCHAR_IS_LINE_BREAK(text->str[offset - 1])) {\n    offset--;\n  } else {\n    offset = -1;\n  }\n\n  return offset;\n}\n\nret_t text_edit_set_canvas(text_edit_t* text_edit, canvas_t* canvas) {\n  return_value_if_fail(text_edit != NULL && canvas != NULL, RET_BAD_PARAMS);\n\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nstatic point_t text_edit_normalize_point(text_edit_t* text_edit, xy_t x, xy_t y) {\n  DECL_IMPL(text_edit);\n  point_t point = {x, y};\n  text_layout_info_t* layout_info = &(impl->layout_info);\n\n  widget_to_local(text_edit->widget, &point);\n\n  point.x = point.x - layout_info->margin_l + layout_info->ox;\n  point.y = point.y - layout_info->margin_t + layout_info->oy;\n\n  return point;\n}\n\nstatic bool_t text_edit_is_need_layout(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  style_t* style = text_edit->widget->astyle;\n  uint16_t font_size = style_get_int(style, STYLE_ID_FONT_SIZE, TK_DEFAULT_FONT_SIZE);\n  const char* font_name = system_info_fix_font_name(style_get_str(style, STYLE_ID_FONT_NAME, NULL));\n\n  if (!tk_str_eq(font_name, impl->font_name) || font_size != impl->font_size) {\n    impl->font_name = font_name;\n    impl->font_size = font_size;\n    return TRUE;\n  }\n  return FALSE;\n}\n\nstatic ret_t text_edit_update_caret_pos(text_edit_t* text_edit) {\n  uint32_t i = 0;\n  uint32_t j = 0;\n  uint32_t k = 0;\n  uint32_t y = 0;\n  DECL_IMPL(text_edit);\n  uint32_t line_index = 0;\n  rows_t* rows = impl->rows;\n  bool_t is_setting = FALSE;\n  canvas_t* c = GET_CANVAS(text_edit);\n  uint32_t font_size = impl->font_size;\n  uint32_t line_height = impl->line_height;\n  wstr_t* text = &(text_edit->widget->text);\n\n  canvas_set_font(c, impl->font_name, font_size);\n\n  for (i = 0; i < rows->size; i++) {\n    row_info_t* row = rows->row + i;\n    for (j = 0; j < row->line_num; j++, y += line_height, line_index++) {\n      line_info_t* line = (line_info_t*)darray_get(&row->info, j);\n      uint32_t line_offset_begin = line->offset;\n      uint32_t line_offset_end = line->offset + line->length;\n      if ((line_offset_begin <= impl->state.cursor && impl->state.cursor < line_offset_end) ||\n          (j + 1 == row->line_num && impl->state.cursor == line_offset_end)) {\n        uint32_t x = line->x;\n        wchar_t last_char = 0;\n        wchar_t* p = text->str + line_offset_begin;\n        uint32_t offset = impl->state.cursor - line_offset_begin;\n        for (k = 0; k < line->length; k++, p++) {\n          if (offset == k) {\n            break;\n          }\n          x += (canvas_measure_text(c, p, 1) + CHAR_SPACING);\n          last_char = *p;\n        }\n        is_setting = TRUE;\n        if (last_char == STB_TEXTEDIT_NEWLINE) {\n          text_edit_set_caret_pos(impl, 0, y + line_height, c->font_size, line_index);\n        } else {\n          text_edit_set_caret_pos(impl, x, y, c->font_size, line_index);\n        }\n        break;\n      }\n    }\n    if (is_setting) {\n      break;\n    }\n  }\n  text_edit_fix_oy(impl);\n  text_edit_notify(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_click(text_edit_t* text_edit, xy_t x, xy_t y) {\n  point_t point;\n  DECL_IMPL(text_edit);\n  return_value_if_fail(impl != NULL, RET_BAD_PARAMS);\n\n  widget_prepare_text_style(text_edit->widget, GET_CANVAS(text_edit));\n  point = text_edit_normalize_point(text_edit, x, y);\n  stb_textedit_click(text_edit, &(impl->state), point.x, point.y);\n\n  if (impl->single_line || text_edit_is_need_layout(text_edit)) {\n    text_edit_layout(text_edit);\n  } else {\n    text_edit_update_caret_pos(text_edit);\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_drag(text_edit_t* text_edit, xy_t x, xy_t y) {\n  point_t point;\n  DECL_IMPL(text_edit);\n  return_value_if_fail(impl != NULL, RET_BAD_PARAMS);\n\n  widget_prepare_text_style(text_edit->widget, GET_CANVAS(text_edit));\n  point = text_edit_normalize_point(text_edit, x, y);\n  stb_textedit_drag(text_edit, &(impl->state), point.x, point.y);\n\n  if (impl->single_line || text_edit_is_need_layout(text_edit)) {\n    text_edit_layout(text_edit);\n  } else {\n    text_edit_update_caret_pos(text_edit);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_paste_from_clip_board(text_edit_t* text_edit) {\n  value_t v;\n  wstr_t str;\n  const char* data = clip_board_get_text();\n  if (data != NULL) {\n    value_set_str(&v, data);\n    wstr_init(&str, 0);\n    wstr_from_value(&str, &v);\n    wstr_normalize_newline(&str, STB_TEXTEDIT_NEWLINE);\n    text_edit_paste(text_edit, str.str, str.size);\n    wstr_reset(&str);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_handle_shortcut(text_edit_t* text_edit, key_event_t* evt,\n                                       STB_TexteditState* state, wstr_t* text) {\n#ifdef MACOS\n  if (evt->cmd) {\n#else\n  if (evt->ctrl) {\n#endif\n    uint32_t key = evt->key;\n    char c = tolower(key);\n    if (c == 'z' || c == 'Z') {\n      stb_textedit_key(text_edit, state, STB_TEXTEDIT_K_UNDO);\n    } else if (c == 'y' || c == 'Y') {\n      stb_textedit_key(text_edit, state, STB_TEXTEDIT_K_REDO);\n    } else if (c == 'c' || c == 'C') {\n      text_edit_copy(text_edit);\n    } else if (c == 'x' || c == 'X') {\n      text_edit_cut(text_edit);\n    } else if (c == 'a' || c == 'A') {\n      state->select_start = 0;\n      state->select_end = text->size;\n    } else if (c == 'v' || c == 'V') {\n      text_edit_paste_from_clip_board(text_edit);\n    } else if (key > 128 || !tk_isprint(key)) {\n      return RET_FAIL;\n    }\n\n    text_edit_layout(text_edit);\n\n    return RET_OK;\n  }\n\n  return RET_FAIL;\n}\n\nret_t text_edit_key_up(text_edit_t* text_edit, key_event_t* evt) {\n  uint32_t key = 0;\n  ret_t ret = RET_OK;\n  widget_t* widget = NULL;\n  input_method_t* im = input_method();\n  return_value_if_fail(im != NULL, RET_FAIL);\n  return_value_if_fail(text_edit != NULL && text_edit->widget != NULL && evt != NULL, RET_FAIL);\n\n  key = evt->key;\n  widget = text_edit->widget;\n  if (key == TK_KEY_OPEN_INPUT_METHOD) {\n    input_method_request(im, widget);\n    ret = RET_STOP;\n  } else if (key == TK_KEY_CLOSE_INPUT_METHOD) {\n    input_method_request(im, NULL);\n    ret = RET_STOP;\n  } else if (key == TK_KEY_TOGGLE_INPUT_METHOD) {\n    if (im->widget == widget) {\n      input_method_request(im, NULL);\n    } else {\n      input_method_request(im, widget);\n    }\n    ret = RET_STOP;\n  }\n\n  return ret;\n}\n\nret_t text_edit_key_down(text_edit_t* text_edit, key_event_t* evt) {\n  uint32_t key = 0;\n  wstr_t* text = NULL;\n  DECL_IMPL(text_edit);\n  bool_t move_caret_pos = FALSE;\n  STB_TexteditState* state = NULL;\n  text_layout_info_t* layout_info = NULL;\n  return_value_if_fail(impl != NULL, RET_BAD_PARAMS);\n\n  key = evt->key;\n  state = &(impl->state);\n  text = &(text_edit->widget->text);\n  layout_info = &(impl->layout_info);\n\n  switch (key) {\n#ifdef WITH_SDL\n    case TK_KEY_KP_DIVIDE:\n    case TK_KEY_KP_MULTIPLY:\n    case TK_KEY_KP_MINUS:\n    case TK_KEY_KP_PLUS:\n    case TK_KEY_KP_PERIOD:\n    case TK_KEY_NUMLOCKCLEAR:\n    case TK_KEY_KP_0:\n    case TK_KEY_KP_1:\n    case TK_KEY_KP_2:\n    case TK_KEY_KP_3:\n    case TK_KEY_KP_4:\n    case TK_KEY_KP_5:\n    case TK_KEY_KP_6:\n    case TK_KEY_KP_7:\n    case TK_KEY_KP_8:\n    case TK_KEY_KP_9:\n      return RET_OK;\n    case TK_KEY_KP_ENTER:\n#endif\n    case TK_KEY_RETURN: {\n      key = STB_TEXTEDIT_NEWLINE;\n      break;\n    }\n    case TK_KEY_LEFT: {\n      move_caret_pos = TRUE;\n      key = STB_TEXTEDIT_K_LEFT;\n      break;\n    }\n    case TK_KEY_RIGHT: {\n      move_caret_pos = TRUE;\n      key = STB_TEXTEDIT_K_RIGHT;\n      break;\n    }\n    case TK_KEY_DOWN: {\n      move_caret_pos = TRUE;\n      key = STB_TEXTEDIT_K_DOWN;\n      break;\n    }\n    case TK_KEY_UP: {\n      move_caret_pos = TRUE;\n      key = STB_TEXTEDIT_K_UP;\n      break;\n    }\n    case TK_KEY_HOME: {\n      move_caret_pos = TRUE;\n      state->cursor = 0;\n      key = STB_TEXTEDIT_K_LINESTART;\n      break;\n    }\n    case TK_KEY_END: {\n      move_caret_pos = TRUE;\n      state->cursor = text->size;\n      key = STB_TEXTEDIT_K_LINEEND;\n      break;\n    }\n    case TK_KEY_DELETE: {\n      key = STB_TEXTEDIT_K_DELETE;\n      break;\n    }\n    case TK_KEY_BACKSPACE: {\n      key = STB_TEXTEDIT_K_BACKSPACE;\n      break;\n    }\n    case TK_KEY_INSERT: {\n      key = STB_TEXTEDIT_K_INSERT;\n      break;\n    }\n    case TK_KEY_PAGEDOWN: {\n      move_caret_pos = TRUE;\n      if (impl->single_line) {\n        key = STB_TEXTEDIT_K_LINEEND;\n      } else {\n        int32_t lines = layout_info->h / impl->line_height;\n        int32_t next_lines = impl->caret_line_index + lines;\n        int32_t next_y = next_lines * impl->line_height;\n        if (layout_info->virtual_h > next_y) {\n          while (lines-- > 0) {\n            stb_textedit_key(text_edit, state, STB_TEXTEDIT_K_DOWN);\n          }\n        } else {\n          state->cursor = text->size;\n          stb_textedit_key(text_edit, state, STB_TEXTEDIT_K_LINEEND);\n        }\n        goto layout;\n\n        return RET_OK;\n      }\n      break;\n    }\n    case TK_KEY_PAGEUP: {\n      move_caret_pos = TRUE;\n      if (impl->single_line) {\n        key = STB_TEXTEDIT_K_LINESTART;\n      } else {\n        int32_t lines = layout_info->h / impl->line_height;\n        int32_t next_lines = impl->caret_line_index - lines;\n\n        if (next_lines > 0) {\n          while (lines-- > 0) {\n            stb_textedit_key(text_edit, state, STB_TEXTEDIT_K_UP);\n          }\n        } else {\n          state->cursor = 0;\n          stb_textedit_key(text_edit, state, STB_TEXTEDIT_K_LINESTART);\n        }\n        goto layout;\n      }\n      break;\n    }\n    case TK_KEY_F1:\n    case TK_KEY_F2:\n    case TK_KEY_F3:\n    case TK_KEY_F4:\n    case TK_KEY_F5:\n    case TK_KEY_F6:\n    case TK_KEY_F7:\n    case TK_KEY_F8:\n    case TK_KEY_F9:\n    case TK_KEY_F10:\n    case TK_KEY_F11:\n    case TK_KEY_F12:\n    case TK_KEY_LSHIFT:\n    case TK_KEY_RSHIFT:\n    case TK_KEY_LCTRL:\n    case TK_KEY_RCTRL:\n    case TK_KEY_LALT:\n    case TK_KEY_RALT:\n    case TK_KEY_CAPSLOCK:\n    case TK_KEY_COMMAND:\n    case TK_KEY_MENU:\n    case TK_KEY_WHEEL: {\n      return RET_OK;\n    }\n    default: {\n      if (key < 128 && tk_isprint(key)) {\n        app_type_t app_type = system_info()->app_type;\n        if (app_type == APP_DESKTOP || app_type == APP_MOBILE) {\n          text_edit_handle_shortcut(text_edit, evt, state, text);\n          return RET_OK;\n        }\n      }\n      break;\n    }\n  }\n\n  if (text_edit_handle_shortcut(text_edit, evt, state, text) == RET_OK) {\n    return RET_OK;\n  }\n\n  if (evt->shift) {\n    key |= STB_TEXTEDIT_K_SHIFT;\n  }\n\n  stb_textedit_key(text_edit, state, key);\nlayout:\n  if (!impl->single_line && move_caret_pos && !text_edit_is_need_layout(text_edit)) {\n    text_edit_update_caret_pos(text_edit);\n  } else {\n    text_edit_layout(text_edit);\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_copy(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  wstr_t* text = NULL;\n  uint32_t select_end = 0;\n  uint32_t select_start = 0;\n  STB_TexteditState* state = NULL;\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  state = &(impl->state);\n  text = &(text_edit->widget->text);\n  select_start = tk_min(state->select_start, state->select_end);\n  select_end = tk_max(state->select_start, state->select_end);\n\n  if (select_end > select_start) {\n    str_t str;\n    wstr_t wstr;\n    wchar_t* start = text->str + select_start;\n    uint32_t size = select_end - select_start;\n\n    wstr_init(&wstr, size + 1);\n    wstr_append_with_len(&wstr, start, size);\n\n    str_init(&str, 0);\n    str_from_wstr(&str, wstr.str);\n    clip_board_set_text(str.str);\n\n    str_reset(&str);\n    wstr_reset(&wstr);\n  }\n\n  return RET_OK;\n}\n\nchar* text_edit_get_selected_text(text_edit_t* text_edit) {\n  uint32_t size = 0;\n  text_edit_state_t state = {0};\n  char* ret = NULL;\n  return_value_if_fail(text_edit != NULL, NULL);\n\n  text_edit_get_state(text_edit, &state);\n  size = state.select_end - state.select_start;\n\n  if (size > 0) {\n    ret = tk_utf8_dup_utf16(text_edit->widget->text.str + state.select_start, size);\n  }\n\n  return ret;\n}\n\nret_t text_edit_cut(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  if (text_edit_copy(text_edit) == RET_OK) {\n    stb_textedit_cut(text_edit, &(impl->state));\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_paste(text_edit_t* text_edit, const wchar_t* str, uint32_t size) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL && str != NULL, RET_BAD_PARAMS);\n\n  stb_textedit_paste(text_edit, &(impl->state), str, size);\n  if (impl->preedit) {\n    impl->preedit_chars_nr += size;\n  }\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_set_cursor(text_edit_t* text_edit, uint32_t cursor) {\n  wstr_t* text = NULL;\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  text = &(text_edit->widget->text);\n\n  if (cursor > text->size) {\n    cursor = text->size;\n  }\n\n  if (impl->state.cursor != cursor) {\n    impl->state.cursor = cursor;\n    text_edit_layout(text_edit);\n  }\n\n  return RET_OK;\n}\n\nuint32_t text_edit_get_cursor(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, 0);\n\n  return impl->state.cursor;\n}\n\nret_t text_edit_set_wrap_word(text_edit_t* text_edit, bool_t wrap_word) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->wrap_word = wrap_word;\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_set_overwrite(text_edit_t* text_edit, bool_t overwrite) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->overwrite = overwrite;\n  text_edit_notify(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_set_mask(text_edit_t* text_edit, bool_t mask) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  if (impl->mask != mask) {\n    impl->mask = mask;\n    text_edit_layout(text_edit);\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_set_tips(text_edit_t* text_edit, const char* tips, bool_t mlines) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->is_mlines = mlines;\n  wstr_set_utf8(&(impl->tips), tips);\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_set_mask_char(text_edit_t* text_edit, wchar_t mask_char) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->mask_char = mask_char;\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_set_select(text_edit_t* text_edit, uint32_t start, uint32_t end) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  if (start > end) {\n    uint32_t t = start;\n    start = end;\n    end = t;\n  }\n\n  impl->state.select_start = start;\n  impl->state.select_end = tk_min(end, text_edit->widget->text.size);\n\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_select_all(text_edit_t* text_edit) {\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  return text_edit_set_select(text_edit, 0, text_edit->widget->text.size);\n}\n\nret_t text_edit_unselect(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->state.select_end = impl->state.select_start;\n\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_get_state(text_edit_t* text_edit, text_edit_state_t* state) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL && state != NULL, RET_BAD_PARAMS);\n\n  memset(state, 0x00, sizeof(text_edit_state_t));\n\n  state->ox = impl->layout_info.ox;\n  state->oy = impl->layout_info.oy;\n  state->virtual_w = impl->layout_info.virtual_w;\n  state->virtual_h = impl->layout_info.virtual_h;\n  state->rows = impl->rows->size;\n  state->max_chars = impl->max_chars;\n  state->caret = impl->caret;\n  state->preedit = impl->preedit;\n  state->line_height = impl->line_height;\n\n  state->cursor = impl->state.cursor;\n  state->max_rows = impl->rows->capacity;\n  state->last_row_number = impl->last_row_number;\n  state->last_line_number = impl->last_line_number;\n\n  state->select_start = tk_min(impl->state.select_start, impl->state.select_end);\n  state->select_end = tk_max(impl->state.select_start, impl->state.select_end);\n\n  state->mask = impl->mask;\n  state->overwrite = impl->overwrite;\n  state->wrap_word = impl->wrap_word;\n  state->mask_char = impl->mask_char;\n  state->caret_visible = impl->caret_visible;\n  state->single_line = impl->single_line;\n\n  return RET_OK;\n}\n\nret_t text_edit_destroy(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  wstr_reset(&(impl->tips));\n  rows_destroy(impl->rows);\n  TKMEM_FREE(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_set_offset(text_edit_t* text_edit, int32_t ox, int32_t oy) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->layout_info.ox = ox;\n  impl->layout_info.oy = oy;\n  text_edit_notify(text_edit);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_notify(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  if (impl->on_state_changed != NULL) {\n    text_edit_state_t state = {0};\n    text_edit_get_state(text_edit, &state);\n    impl->on_state_changed(impl->on_state_changed_ctx, &state);\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_set_on_state_changed(text_edit_t* text_edit,\n                                     text_edit_on_state_changed_t on_state_changed, void* ctx) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->on_state_changed = on_state_changed;\n  impl->on_state_changed_ctx = ctx;\n\n  return RET_OK;\n}\n\nret_t text_edit_preedit(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->preedit = TRUE;\n  impl->preedit_chars_nr = 0;\n\n  return RET_OK;\n}\n\nret_t text_edit_preedit_confirm(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->preedit = FALSE;\n  impl->preedit_chars_nr = 0;\n\n  return RET_OK;\n}\n\nret_t text_edit_preedit_clear(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  if (impl->preedit_chars_nr > 0) {\n    text_edit_remove(text_edit, impl->state.cursor - impl->preedit_chars_nr,\n                     impl->preedit_chars_nr);\n    impl->state.cursor = impl->state.cursor - impl->preedit_chars_nr;\n    impl->preedit_chars_nr = 0;\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_preedit_abort(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->preedit = FALSE;\n  text_edit_preedit_clear(text_edit);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_insert_wtext_with_len(text_edit_t* text_edit, uint32_t offset,\n                                             const wchar_t* wtext, uint32_t len) {\n  ret_t ret = RET_FAIL;\n  uint32_t size = 0;\n  return_value_if_fail(text_edit != NULL && text_edit->widget != NULL && wtext != NULL,\n                       RET_BAD_PARAMS);\n\n  size = wcslen(wtext);\n  len = tk_min(len, size);\n  offset = tk_min(offset, text_edit->widget->text.size);\n\n  ret = !!text_edit_insert(text_edit, offset, (wchar_t*)wtext, len) ? RET_OK : RET_SKIP;\n\n  if (ret == RET_OK) {\n    if (offset + len != text_edit_get_cursor(text_edit)) {\n      text_edit_set_cursor(text_edit, offset + len);\n    } else {\n      text_edit_layout(text_edit);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t text_edit_insert_text_with_len(text_edit_t* text_edit, uint32_t offset,\n                                            const char* text, uint32_t len) {\n  ret_t ret = RET_FAIL;\n  wstr_t s = {0};\n  return_value_if_fail(text_edit != NULL && text_edit->widget != NULL && text != NULL,\n                       RET_BAD_PARAMS);\n\n  wstr_set_utf8(&s, text);\n  ret = text_edit_insert_wtext_with_len(text_edit, offset, s.str, len);\n  wstr_reset(&s);\n\n  return ret;\n}\n\nret_t text_edit_insert_text(text_edit_t* text_edit, uint32_t offset, const char* text) {\n  return text_edit_insert_text_with_len(text_edit, offset, text, tk_strlen(text));\n}\n\nstatic ret_t text_edit_overwrite_text_fix_select(text_edit_t* text_edit, uint32_t insert_offset,\n                                                 uint32_t insert_len, uint32_t remove_offset,\n                                                 uint32_t remove_len) {\n  DECL_IMPL(text_edit);\n  wstr_t* wstr = &text_edit->widget->text;\n  uint32_t select_start = impl->state.select_start;\n  uint32_t select_end = impl->state.select_end;\n\n  if (impl->state.select_start > insert_offset) {\n    select_start = tk_min(select_start + insert_len, wstr->size);\n  }\n  if (impl->state.select_end > insert_offset) {\n    select_end = tk_min(select_end + insert_len, wstr->size);\n  }\n\n  if (tk_max(impl->state.select_start, impl->state.select_end) > remove_offset &&\n      tk_min(impl->state.select_start, impl->state.select_end) < remove_len) {\n    select_start = select_end = 0;\n  } else {\n    if (impl->state.select_start > remove_offset) {\n      select_start -= remove_len;\n    }\n    if (impl->state.select_end > remove_offset) {\n      select_end -= remove_len;\n    }\n  }\n  impl->state.select_start = select_start;\n  impl->state.select_end = select_end;\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_overwrite_text_not_at_last_row(text_edit_t* text_edit, uint32_t* p_offset,\n                                                      const char* text, uint32_t len) {\n  DECL_IMPL(text_edit);\n  wstr_t* wstr = &text_edit->widget->text;\n  wstr_t s = {0};\n  /* 获取最后一个换行符的偏移位置 */\n  uint32_t last_row_line_break =\n      text_edit_get_line_break_offset(text_edit, impl->rows->capacity - 1);\n  uint32_t rm_len = 0;\n  uint32_t rm_index = 0;\n\n  if (last_row_line_break < wstr->size) {\n    rm_index = tk_max(*p_offset, last_row_line_break);\n    if (wstr->size > rm_index) {\n      rm_len = wstr->size - rm_index;\n      wstr_remove(wstr, rm_index, rm_len);\n    }\n  }\n\n  wstr_set_utf8_with_len(&s, text, len);\n  wstr_insert(wstr, *p_offset, s.str, s.size);\n  text_edit_overwrite_text_fix_select(text_edit, *p_offset, s.size, rm_index, rm_len);\n  wstr_reset(&s);\n\n  if (*p_offset + len != text_edit_get_cursor(text_edit)) {\n    text_edit_set_cursor(text_edit, *p_offset + len);\n  } else {\n    text_edit_layout(text_edit);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_overwrite_text_at_last_row(text_edit_t* text_edit, uint32_t* p_offset,\n                                                  const char* text, uint32_t len) {\n  DECL_IMPL(text_edit);\n  wstr_t* wstr = &text_edit->widget->text;\n  uint32_t line_break_num = impl->rows->capacity > impl->last_row_number\n                                ? impl->rows->capacity - impl->last_row_number\n                                : 0;\n  wstr_t s = {0};\n  uint32_t rm_len = 0;\n\n  if (line_break_num <= 1) {\n    rm_len = impl->rows->row[0].length;\n    wstr_remove(wstr, 0, rm_len);\n    *p_offset = tk_min(*p_offset > rm_len ? *p_offset - rm_len : 0, wstr->size);\n\n    if (wstr->size > *p_offset) {\n      wstr_remove(wstr, *p_offset, wstr->size - *p_offset);\n      text_edit_overwrite_text_fix_select(text_edit, 0, 0, *p_offset, wstr->size - *p_offset);\n    }\n  }\n\n  wstr_set_utf8_with_len(&s, text, len);\n  wstr_insert(wstr, *p_offset, s.str, s.size);\n  text_edit_overwrite_text_fix_select(text_edit, *p_offset, s.size, 0, rm_len);\n  wstr_reset(&s);\n\n  if (*p_offset + len != text_edit_get_cursor(text_edit)) {\n    text_edit_set_cursor(text_edit, *p_offset + len);\n  } else {\n    text_edit_layout(text_edit);\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_overwrite_text(text_edit_t* text_edit, uint32_t* p_offset, const char* text,\n                               uint32_t len) {\n  DECL_IMPL(text_edit);\n  wstr_t* wstr = NULL;\n  uint32_t text_size = 0;\n  ret_t ret = RET_FAIL;\n  return_value_if_fail(text_edit != NULL && text_edit->widget != NULL && text != NULL,\n                       RET_BAD_PARAMS);\n\n  wstr = &text_edit->widget->text;\n  text_size = tk_strlen(text);\n  *p_offset = tk_min(wstr->size, *p_offset);\n  len = tk_min(len, text_size);\n\n  /* 插入位置 不在最后一行 */\n  if (*p_offset < wstr->size - impl->rows->row[impl->rows->capacity - 1].length) {\n    ret = text_edit_overwrite_text_not_at_last_row(text_edit, p_offset, text, len);\n  } else {\n    ret = text_edit_overwrite_text_at_last_row(text_edit, p_offset, text, len);\n  }\n  *p_offset += len;\n\n  return ret;\n}\n\nret_t text_edit_set_lock_scrollbar_value(text_edit_t* text_edit, bool_t lock) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->lock_scrollbar_value = lock;\n\n  return RET_OK;\n}\n\n#include \"window.h\"\n#include \"window_manager.h\"\n\nstatic ret_t text_edit_on_copy(void* ctx, event_t* e) {\n  text_edit_t* text_edit = (text_edit_t*)ctx;\n  text_edit_copy(text_edit);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_on_cut(void* ctx, event_t* e) {\n  text_edit_t* text_edit = (text_edit_t*)ctx;\n  text_edit_cut(text_edit);\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_on_paste(void* ctx, event_t* e) {\n  text_edit_t* text_edit = (text_edit_t*)ctx;\n  text_edit_paste_from_clip_board(text_edit);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_on_select_all(void* ctx, event_t* e) {\n  text_edit_t* text_edit = (text_edit_t*)ctx;\n  text_edit_select_all(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_show_context_menu(text_edit_t* text_edit, int32_t x, int32_t y) {\n  widget_t* win = window_open(\"edit_menu\");\n  widget_t* wm = window_manager();\n\n  if (win != NULL) {\n    DECL_IMPL(text_edit);\n    widget_t* copy = widget_lookup(win, \"copy\", TRUE);\nwidget_t* cut = ",
    "raw_res": "",
    "prompt_res": "widget_lookup(win, \"cut\", TRUE);",
    "gt": "widget_lookup(win, \"cut\", TRUE);"
  },
  {
    "id": 2193,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/text_edit.c",
    "input": "﻿/**\n * File:   text_edit.c\n * Author: AWTK Develop Team\n * Brief:  text_edit\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-06-08 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include <wctype.h>\n\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/darray.h\"\n#include \"base/bidi.h\"\n#include \"base/line_parser.h\"\n#include \"base/events.h\"\n#include \"base/text_edit.h\"\n#include \"base/line_break.h\"\n#include \"base/clip_board.h\"\n#include \"base/input_method.h\"\n\n#define CHAR_SPACING 1\n#define FONT_BASELINE 1.25f\n#define STB_TEXTEDIT_CHARTYPE wchar_t\n#define STB_TEXTEDIT_NEWLINE (wchar_t)('\\n')\n#define STB_TEXTEDIT_STRING text_edit_t\n\n#if !defined(WITH_SDL)\n#define STB_TEXTEDIT_UNDOSTATECOUNT 10\n#define STB_TEXTEDIT_UNDOCHARCOUNT 32\n#endif /*WITH_SDL*/\n#define STB_TEXTEDIT_GETWIDTH_NEWLINE 0xffff\n\n#include \"stb/stb_textedit.h\"\n\n#define GET_CANVAS(text_edit) widget_get_canvas(WIDGET(text_edit->widget))\ntypedef struct _text_layout_info_t {\n  int32_t w;\n  int32_t h;\n  int32_t ox;\n  int32_t oy;\n\n  uint32_t virtual_w;\n  uint32_t virtual_h;\n  uint32_t widget_w;\n  uint32_t widget_h;\n  uint32_t margin_l;\n  uint32_t margin_t;\n  uint32_t margin_r;\n  uint32_t margin_b;\n} text_layout_info_t;\n\ntypedef struct _line_info_t {\n  uint16_t x;\n  uint32_t offset;\n  uint16_t length;\n  uint16_t text_w;\n} line_info_t;\n\ntypedef struct _row_info_t {\n  uint16_t length;\n  uint32_t line_num;\n  darray_t info;\n} row_info_t;\n\ntypedef struct _rows_t {\n  uint32_t size;\n  uint32_t capacity;\n  uint32_t* row_line;\n  row_info_t row[1];\n} rows_t;\n\ntypedef struct _text_edit_impl_t {\n  text_edit_t text_edit;\n  STB_TexteditState state;\n\n  rows_t* rows;\n  uint32_t max_chars;\n  point_t caret;\n  bool_t overwrite;\n  bool_t wrap_word;\n  bool_t single_line;\n  bool_t caret_visible;\n  uint32_t line_height;\n  uint32_t last_line_number;\n  uint32_t last_row_number;\n  uint32_t caret_line_index;\n  text_layout_info_t layout_info;\n\n  bool_t preedit;\n  uint32_t preedit_chars_nr;\n\n  bool_t lock_scrollbar_value;\n\n  /*for single line edit*/\n  wchar_t mask_char;\n  bool_t mask;\n  wstr_t tips;\n  bool_t is_mlines;\n\n  bool_t is_first_time_layout;\n  int32_t font_size;\n  const char* font_name;\n  void* on_state_changed_ctx;\n  text_edit_on_state_changed_t on_state_changed;\n} text_edit_impl_t;\n\n#define DECL_IMPL(te) text_edit_impl_t* impl = (text_edit_impl_t*)(te)\n\nstatic ret_t text_edit_notify(text_edit_t* text_edit);\nstatic bool_t text_edit_is_need_layout(text_edit_t* text_edit);\nstatic int32_t text_edit_calc_x(text_edit_t* text_edit, line_info_t* iter);\n\nstatic align_h_t widget_get_text_align_h(widget_t* widget) {\n  return (align_h_t)style_get_int(widget->astyle, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_LEFT);\n}\n\n#define TEXT_EDIT_GET_WIDGET_MARGIN(widget, style, out_value, type)             \\\n  {                                                                             \\\n    value_t v;                                                                  \\\n    value_set_int(&v, 0);                                                       \\\n    if (widget_get_prop((widget), WIDGET_PROP_##type##_MARGIN, &v) == RET_OK) { \\\n      (out_value) = value_int(&v);                                              \\\n    }                                                                           \\\n    TEXT_EDIT_GET_STYLE_MARGIN(style, out_value, type)                          \\\n  }\n\nstatic ret_t widget_get_text_layout_info(widget_t* widget, text_layout_info_t* info) {\n  style_t* style = widget->astyle;\n  return_value_if_fail(widget != NULL && info != NULL && style != NULL, RET_BAD_PARAMS);\n\n  info->widget_w = widget->w;\n  info->widget_h = widget->h;\n  info->virtual_w = tk_max(info->virtual_w, widget->w);\n  info->virtual_h = tk_max(info->virtual_h, widget->h);\n\n  TEXT_EDIT_GET_WIDGET_MARGIN(widget, style, info->margin_l, LEFT);\n  TEXT_EDIT_GET_WIDGET_MARGIN(widget, style, info->margin_r, RIGHT);\n  TEXT_EDIT_GET_WIDGET_MARGIN(widget, style, info->margin_t, TOP);\n  TEXT_EDIT_GET_WIDGET_MARGIN(widget, style, info->margin_b, BOTTOM);\n\n  info->w = info->widget_w - info->margin_l - info->margin_r;\n  info->h = info->widget_h - info->margin_t - info->margin_b;\n\n  return RET_OK;\n}\n\nstatic rows_t* rows_create(uint32_t capacity) {\n  uint32_t msize = sizeof(rows_t) + capacity * sizeof(row_info_t);\n  rows_t* rows = (rows_t*)TKMEM_ALLOC(msize);\n  uint32_t i = 0;\n  return_value_if_fail(rows != NULL, NULL);\n\n  memset(rows, 0x00, msize);\n  for (i = 0; i < capacity; i++) {\n    darray_init(&rows->row[i].info, 4, default_destroy, NULL);\n    darray_push(&rows->row[i].info, TKMEM_ZALLOC(line_info_t));\n    rows->row[i].line_num = 1;\n  }\n\n  rows->row_line = TKMEM_ZALLOCN(uint32_t, capacity);\n  rows->capacity = capacity;\n\n  return rows;\n}\n\nstatic line_info_t* line_find_by_offset(rows_t* rows, uint32_t offset) {\n  uint32_t i = 0;\n  return_value_if_fail(rows != NULL, NULL);\n\n  for (i = 0; i < rows->size; i++) {\n    uint32_t j = 0;\n    row_info_t* row = rows->row + i;\n    for (j = 0; j < row->line_num; j++) {\n      line_info_t* line = (line_info_t*)darray_get(&row->info, j);\n      if (line->offset == offset) {\n        return line;\n      }\n    }\n  }\n\n  return NULL;\n}\n\nstatic ret_t rows_destroy(rows_t* rows) {\n  uint32_t i = 0;\n  return_value_if_fail(rows != NULL, RET_BAD_PARAMS);\n\n  for (i = 0; i < rows->capacity; i++) {\n    darray_deinit(&rows->row[i].info);\n  }\n  TKMEM_FREE(rows->row_line);\n  TKMEM_FREE(rows);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_set_caret_pos(text_edit_impl_t* impl, uint32_t x, uint32_t y,\n                                     uint32_t font_size, uint32_t line_number) {\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  uint32_t caret_top = layout_info->margin_t + y;\n  uint32_t caret_bottom = layout_info->margin_t + y + font_size;\n  uint32_t caret_left = layout_info->margin_l + x;\n  uint32_t caret_right = layout_info->margin_l + x + 1;\n\n  uint32_t view_top = layout_info->oy + layout_info->margin_t;\n  uint32_t view_bottom = layout_info->oy + layout_info->margin_t + layout_info->h;\n  uint32_t view_left = layout_info->ox + layout_info->margin_l;\n  uint32_t view_right = layout_info->ox + layout_info->margin_l + layout_info->w;\n\n  impl->caret.x = x;\n  impl->caret.y = y;\n  impl->caret_line_index = line_number;\n\n  if (!impl->lock_scrollbar_value) {\n    if (view_top > caret_top) {\n      layout_info->oy = caret_top - layout_info->margin_t;\n    }\n\n    if (view_bottom < caret_bottom) {\n      layout_info->oy = caret_bottom - layout_info->h;\n    }\n\n    if (view_left > caret_left) {\n      layout_info->ox = caret_left - layout_info->margin_l;\n    }\n\n    if (view_right < caret_right || (view_left > caret_left + layout_info->w)) {\n      layout_info->ox = caret_right - layout_info->w - layout_info->margin_l;\n    }\n  }\n\n  if (layout_info->ox < 0) {\n    layout_info->ox = 0;\n  }\n\n  if (impl->wrap_word) {\n    layout_info->ox = 0;\n  }\n\n  if (impl->single_line) {\n    layout_info->oy = 0;\n  }\n\n  return RET_OK;\n}\n\nstatic uint32_t text_edit_measure_text_on_canvas(text_edit_t* text_edit, wchar_t* str,\n                                                 wchar_t mask_char, uint32_t size, canvas_t* c) {\n  uint32_t i = 0;\n  uint32_t w = 0;\n  DECL_IMPL(text_edit);\n\n  for (i = 0; i < size; i++) {\n    bool_t preedit = impl->preedit && i < impl->state.cursor &&\n                     i >= (impl->state.cursor - impl->preedit_chars_nr);\n    wchar_t chr = (mask_char && !preedit) ? mask_char : str[i];\n\n    w += canvas_measure_text(c, &chr, 1) + CHAR_SPACING;\n  }\n\n  return w;\n}\n\nstatic uint32_t text_edit_measure_text(text_edit_t* text_edit, wchar_t* str, wchar_t mask_char,\n                                       uint32_t size) {\n  return text_edit_measure_text_on_canvas(text_edit, str, mask_char, size, GET_CANVAS(text_edit));\n}\n\nstatic row_info_t* text_edit_single_line_layout_line(text_edit_t* text_edit, uint32_t row_num,\n                                                     uint32_t line_index, uint32_t offset) {\n  uint32_t y = 0;\n  uint32_t caret_x = 0;\n  uint32_t view_left = 0;\n  uint32_t caret_left = 0;\n  DECL_IMPL(text_edit);\n  canvas_t* c = GET_CANVAS(text_edit);\n  wstr_t* text = &(text_edit->widget->text);\n  STB_TexteditState* state = &(impl->state);\n  row_info_t* row = impl->rows->row + row_num;\n  wchar_t mask_char = impl->mask ? impl->mask_char : 0;\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  align_h_t align_h = widget_get_text_align_h(text_edit->widget);\n  uint32_t text_w = text_edit_measure_text(text_edit, text->str, mask_char, text->size);\n  uint32_t caret_text_w = text_edit_measure_text(text_edit, text->str, mask_char, state->cursor);\n  line_info_t* line = (line_info_t*)darray_head(&row->info);\n\n  assert(offset == 0 && row_num == 0);\n\n  memset(row, 0x00, sizeof(row_info_t) - sizeof(darray_t));\n\n  row->line_num = 1;\n  line->offset = 0;\n  line->text_w = text_w;\n  line->length = text->size;\n  row->length = line->length;\n  line->x = text_edit_calc_x(text_edit, line);\n  layout_info->virtual_h = tk_max(y, layout_info->widget_h);\n\n  caret_x = caret_text_w;\n  caret_left = layout_info->margin_l + caret_x;\n  view_left = layout_info->ox + layout_info->margin_l;\n  if ((text_w < layout_info->w) ||\n      (view_left + c->font_size >= caret_left && state->cursor == text->size)) {\n    layout_info->ox = 0;\n    if (align_h == ALIGN_H_RIGHT) {\n      caret_x = layout_info->w - (text_w - caret_text_w);\n    } else if (align_h == ALIGN_H_CENTER) {\n      caret_x = (layout_info->w - text_w) / 2 + caret_text_w;\n    }\n  }\n  text_edit_set_caret_pos(impl, caret_x, y, c->font_size, line_index);\n\n  return row;\n}\n\nstatic row_info_t* text_edit_multi_line_layout_line(text_edit_t* text_edit, uint32_t row_num,\n                                                    uint32_t line_index, uint32_t offset) {\n  uint32_t i = 0;\n  uint32_t x = 0;\n  DECL_IMPL(text_edit);\n  wchar_t last_char = 0;\n  point_t caret = {-1, -1};\n  canvas_t* c = GET_CANVAS(text_edit);\n  wstr_t* text = &(text_edit->widget->text);\n  STB_TexteditState* state = &(impl->state);\n  row_info_t* row = impl->rows->row + row_num;\n  uint32_t line_height = impl->line_height;\n  uint32_t y = line_index * line_height;\n  uint32_t offset0 = offset;\n  uint32_t last_breakable_i = 0;\n  uint32_t last_breakable_x = 0;\n  line_info_t* last_line = NULL;\n  text_layout_info_t* layout_info = &(impl->layout_info);\n\n  memset(row, 0x00, sizeof(row_info_t) - sizeof(darray_t));\n  row->line_num = 1;\n\n  for (i = offset; i < text->size; i++) {\n    wchar_t* p = text->str + i;\n    break_type_t word_break = LINE_BREAK_NO;\n    break_type_t line_break = LINE_BREAK_NO;\n    uint32_t char_w = canvas_measure_text(c, p, 1) + CHAR_SPACING;\n\n    if (i == state->cursor) {\n      caret.x = x;\n      caret.y = y;\n    }\n\n    last_char = *p;\n    line_break = line_break_check(*p, p[1]);\n    if (line_break == LINE_BREAK_MUST) {\n      i++;\n      break;\n    }\n\n    if (impl->wrap_word) {\n      if ((x + char_w) > layout_info->w) {\n        if (last_breakable_x > 0) {\n          i = last_breakable_i + 1;\n          x = last_breakable_x;\n          last_breakable_x = 0;\n        }\n        if (i == offset) {\n          i++;\n        }\n\n        last_line = (line_info_t*)darray_get(&row->info, row->line_num - 1);\n        memset(last_line, 0x00, sizeof(line_info_t));\n        last_line->text_w = x;\n        last_line->offset = offset;\n        last_line->length = i - offset;\n\n        row->line_num++;\n        if (row->info.size < row->line_num) {\n          darray_push(&row->info, TKMEM_ZALLOC(line_info_t));\n        }\n\n        p = text->str + i;\n        char_w = canvas_measure_text(c, p, 1) + CHAR_SPACING;\n\n        x = char_w;\n        y += line_height;\n        offset = i;\n        line_index++;\n        if (state->cursor == i) {\n          caret.x = 0;\n          caret.y = y;\n        }\n        continue;\n      }\n\n      x += char_w;\n      word_break = word_break_check(*p, p[1]);\n      if (word_break == LINE_BREAK_ALLOW && line_break == LINE_BREAK_ALLOW) {\n        last_breakable_x = x;\n        last_breakable_i = i;\n      }\n    } else {\n      x += char_w;\n    }\n  }\n\n  while (row->info.size > row->line_num) {\n    row->info.destroy(darray_pop(&row->info));\n  }\n\n  if (last_char == STB_TEXTEDIT_NEWLINE) {\n    impl->last_row_number = row_num + 1;\n    impl->last_line_number = line_index + 1;\n  } else {\n    impl->last_row_number = row_num;\n    impl->last_line_number = line_index;\n  }\n\n  if (i == state->cursor && state->cursor == text->size) {\n    if (last_char == STB_TEXTEDIT_NEWLINE) {\n      caret.x = 0;\n      caret.y = y + line_height;\n    } else {\n      caret.x = x;\n      caret.y = y;\n    }\n  }\n  if (caret.x >= 0 && caret.y >= 0) {\n    /* 计算好了再统一修改光标坐标，以免多次修改导致滚动条的位置突变 */\n    text_edit_set_caret_pos(impl, caret.x, caret.y, c->font_size, line_index);\n  }\n\n  last_line = (line_info_t*)darray_get(&row->info, row->line_num - 1);\n  memset(last_line, 0x00, sizeof(line_info_t));\n  last_line->text_w = x;\n  last_line->offset = offset;\n  last_line->length = i - offset;\n\n  row->length = i - offset0;\n  layout_info->virtual_h = tk_max(y + line_height, layout_info->widget_h);\n\n  return row;\n}\n\nstatic ret_t text_edit_fix_oy(text_edit_impl_t* impl) {\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  uint32_t total_line_height = (impl->last_line_number + 1) * impl->line_height;\n  uint32_t max_oy = (total_line_height > layout_info->h) ? total_line_height - layout_info->h : 0;\n\n  layout_info->oy = tk_min(layout_info->oy, max_oy);\n\n  return RET_OK;\n}\n\nstatic row_info_t* text_edit_layout_line(text_edit_t* text_edit, uint32_t row_num,\n                                         uint32_t line_index, uint32_t offset) {\n  DECL_IMPL(text_edit);\n  if (impl->single_line) {\n    return text_edit_single_line_layout_line(text_edit, row_num, line_index, offset);\n  } else {\n    return text_edit_multi_line_layout_line(text_edit, row_num, line_index, offset);\n  }\n}\n\nstatic ret_t text_edit_layout_impl(text_edit_t* text_edit) {\n  uint32_t i = 0;\n  uint32_t offset = 0;\n  DECL_IMPL(text_edit);\n  row_info_t* iter = NULL;\n  canvas_t* c = GET_CANVAS(text_edit);\n  uint32_t max_rows = impl->rows->capacity;\n  wstr_t* text = &(text_edit->widget->text);\n  uint32_t size = text_edit->widget->text.size;\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  uint32_t char_w = 0;\n  uint32_t line_index = 0;\n  impl->caret.x = 0;\n  impl->caret.y = 0;\n  impl->rows->size = 0;\n\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  widget_prepare_text_style(text_edit->widget, c);\n  impl->line_height = c->font_size * FONT_BASELINE;\n  widget_get_text_layout_info(text_edit->widget, layout_info);\n  char_w = canvas_measure_text(c, text->str, 1) + CHAR_SPACING;\n\n  if (layout_info->w < char_w) {\n    return RET_OK;\n  }\n\n  while ((offset < size || size == 0) && i < max_rows) {\n    iter = text_edit_layout_line(text_edit, i, line_index, offset);\n    if (iter == NULL || iter->length == 0) {\n      break;\n    }\n    line_index += iter->line_num;\n    offset += iter->length;\n    i++;\n  }\n\n  if (offset < size) {\n    text->size = offset;\n    text->str[offset] = L'\\0';\n  }\n\n  impl->rows->size = i;\n\n  text_edit_fix_oy(impl);\n\n  text_edit_notify(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_layout(text_edit_t* text_edit) {\n  if (text_edit == NULL || GET_CANVAS(text_edit) == NULL || text_edit->widget == NULL ||\n      text_edit->widget->initializing || text_edit->widget->loading) {\n    return RET_BAD_PARAMS;\n  }\n\n  return text_edit_layout_impl(text_edit);\n}\n\nstatic void text_edit_layout_for_stb(StbTexteditRow* row, STB_TEXTEDIT_STRING* str, int offset) {\n  DECL_IMPL(str);\n  canvas_t* c = GET_CANVAS(str);\n  if (c == NULL) return;\n  uint32_t font_size = c->font_size;\n  line_info_t* info = line_find_by_offset(impl->rows, offset);\n\n  if (info != NULL) {\n    row->x0 = info->x;\n    row->x1 = info->x + info->text_w;\n    row->num_chars = info->length;\n  } else {\n    row->x0 = 0;\n    row->x1 = 0;\n    row->num_chars = 1;\n  }\n\n  row->ymin = 0;\n  row->ymax = font_size;\n  row->baseline_y_delta = impl->line_height;\n\n  return;\n}\n\nstatic ret_t text_edit_paint_caret(text_edit_t* text_edit, canvas_t* c) {\n  DECL_IMPL(text_edit);\n  widget_t* widget = text_edit->widget;\n  style_t* style = widget->astyle;\n  color_t black = color_init(0, 0, 0, 0xff);\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  color_t caret_color = style_get_color(style, STYLE_ID_TEXT_COLOR, black);\n  uint32_t x = layout_info->margin_l + impl->caret.x - layout_info->ox;\n  uint32_t y = layout_info->margin_t + impl->caret.y - layout_info->oy;\n\n  if (impl->single_line) {\n    y += (layout_info->h - c->font_size) / 2;\n  }\n\n  canvas_set_stroke_color(c, caret_color);\n  canvas_draw_vline(c, x, y, c->font_size);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_paint_tips_mlines_text(text_edit_t* text_edit, canvas_t* c,\n                                              line_parser_t* p) {\n  int32_t y = 0;\n  int32_t w = 0;\n  int32_t font_size = 0;\n  int32_t line_height = 0;\n  DECL_IMPL(text_edit);\n  text_layout_info_t* layout_info = 0;\n  return_value_if_fail(text_edit != NULL && text_edit->widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  font_size = c->font_size;\n  layout_info = &(impl->layout_info);\n  line_height = font_size + style_get_int(text_edit->widget->astyle, STYLE_ID_SPACER, 2);\n\n  w = layout_info->w;\n  y = layout_info->margin_t;\n  while (line_parser_next(p) == RET_OK) {\n    uint32_t size = 0;\n    rect_t r = rect_init(layout_info->margin_l, y, w, font_size);\n\n    if ((y + font_size) > layout_info->h) {\n      break;\n    }\n\n    for (size = 0; size < p->line_size; size++) {\n      if (CHAR_IS_LINE_BREAK(p->line[size])) {\n        break;\n      }\n    }\n    canvas_draw_text_in_rect(c, p->line, size, &r);\n\n    y += line_height;\n  }\n  return RET_OK;\n}\n\nstatic ret_t text_edit_paint_tips_text(text_edit_t* text_edit, canvas_t* c) {\n  DECL_IMPL(text_edit);\n  wstr_t* text = &(impl->tips);\n  text_layout_info_t* layout_info = &(impl->layout_info);\n\n  if (text->size > 0) {\n    if (impl->is_mlines) {\n      line_parser_t p;\n      line_parser_init(&p, c, (const wchar_t*)(text->str), text->size, c->font_size, layout_info->w,\n                       TRUE, TRUE);\n      if (p.total_lines > 1) {\n        text_edit_paint_tips_mlines_text(text_edit, c, &p);\n      } else {\n        align_h_t align_h = c->text_align_h;\n        align_v_t align_v = c->text_align_v;\n        rect_t r =\n            rect_init(layout_info->margin_l, layout_info->margin_t, layout_info->w, layout_info->h);\n        canvas_set_text_align(c, align_h, ALIGN_V_TOP);\n        canvas_draw_text_in_rect(c, text->str, text->size, &r);\n        canvas_set_text_align(c, align_h, align_v);\n      }\n      line_parser_deinit(&p);\n    } else {\n      rect_t r =\n          rect_init(layout_info->margin_l, layout_info->margin_t, layout_info->w, layout_info->h);\n      canvas_draw_text_in_rect(c, text->str, text->size, &r);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic int32_t text_edit_calc_x_on_canvas(text_edit_t* text_edit, line_info_t* iter, canvas_t* c) {\n  DECL_IMPL(text_edit);\n  widget_t* widget = text_edit->widget;\n  wstr_t* text = &(widget->text);\n  wchar_t chr = impl->mask ? impl->mask_char : 0;\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  align_h_t align_h = widget_get_text_align_h(text_edit->widget);\n\n  uint32_t row_width =\n      text_edit_measure_text_on_canvas(text_edit, text->str + iter->offset, chr, iter->length, c);\n  if (row_width < layout_info->w) {\n    switch (align_h) {\n      case ALIGN_H_CENTER: {\n        return (layout_info->w - row_width) / 2;\n      }\n      case ALIGN_H_RIGHT: {\n        return (layout_info->w - row_width);\n      }\n      default: {\n        break;\n      }\n    }\n  }\n\n  return 0;\n}\n\nstatic int32_t text_edit_calc_x(text_edit_t* text_edit, line_info_t* iter) {\n  return text_edit_calc_x_on_canvas(text_edit, iter, GET_CANVAS(text_edit));\n}\n\nstatic ret_t text_edit_paint_line(text_edit_t* text_edit, canvas_t* c, line_info_t* iter,\n                                  uint32_t y) {\n  bidi_t b;\n  uint32_t x = 0;\n  uint32_t k = 0;\n  widget_t* widget = text_edit->widget;\n  const char* bidi_type = widget_get_prop_str(widget, WIDGET_PROP_BIDI, NULL);\n  DECL_IMPL(text_edit);\n  wstr_t* text = &(widget->text);\n  style_t* style = widget->astyle;\n  STB_TexteditState* state = &(impl->state);\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  uint32_t view_left = layout_info->ox + layout_info->margin_l;\n  uint32_t view_right = layout_info->ox + layout_info->margin_l + layout_info->w;\n\n  color_t black = color_init(0, 0, 0, 0xff);\n  color_t white = color_init(0xf0, 0xf0, 0xf0, 0xff);\n\n  uint32_t select_start = tk_min(state->select_start, state->select_end);\n  uint32_t select_end = tk_max(state->select_start, state->select_end);\n\n  if (impl->single_line) {\n    x = layout_info->margin_l + text_edit_calc_x_on_canvas(text_edit, iter, c);\n  } else {\n    x = layout_info->margin_l;\n  }\n\n  bidi_init(&b, FALSE, FALSE, bidi_type_from_name(bidi_type));\n  ENSURE(bidi_log2vis(&b, text->str + iter->offset, iter->length) == RET_OK);\n\n  for (k = 0; k < iter->length; k++) {\n    uint32_t offset = iter->offset + k;\n    uint32_t cursor = state->cursor;\n    bool_t selected = offset >= select_start && offset < select_end;\n    bool_t preedit =\n        impl->preedit && offset < cursor && offset >= (cursor - impl->preedit_chars_nr);\n    wchar_t chr = (impl->mask && !preedit) ? impl->mask_char : b.vis_str[k];\n    uint32_t char_w = canvas_measure_text(c, &chr, 1);\n\n    if ((x + char_w) < view_left) {\n      x += char_w + CHAR_SPACING;\n      continue;\n    }\n\n    if (x > view_right) {\n      break;\n    }\n\n    if (chr != STB_TEXTEDIT_NEWLINE) {\n      xy_t rx = x - layout_info->ox;\n      xy_t ry = y - layout_info->oy;\n\n      if (selected || preedit) {\n        color_t select_bg_color = style_get_color(style, STYLE_ID_SELECTED_BG_COLOR, white);\n        color_t select_text_color = style_get_color(style, STYLE_ID_SELECTED_TEXT_COLOR, black);\n\n        canvas_set_fill_color(c, select_bg_color);\n        canvas_fill_rect(c, rx, ry, char_w + CHAR_SPACING, c->font_size);\n\n        canvas_set_text_color(c, select_text_color);\n      } else {\n        color_t text_color = style_get_color(style, STYLE_ID_TEXT_COLOR, black);\n        canvas_set_text_color(c, text_color);\n      }\n\n      /*FIXME: 密码编辑时，*字符本身偏高，看起来不像居中。但是无法拿到字模信息，只好手工修正一下。*/\n      if (impl->mask && !preedit && impl->mask_char == '*') {\n        int32_t oy = c->font_size / 6;\n        canvas_draw_text(c, &chr, 1, rx, ry + oy);\n      } else {\n        canvas_draw_text(c, &chr, 1, rx, ry);\n      }\n\n      x += char_w + CHAR_SPACING;\n    }\n  }\n  bidi_deinit(&b);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_paint_real_text(text_edit_t* text_edit, canvas_t* c) {\n  DECL_IMPL(text_edit);\n  rows_t* rows = impl->rows;\n  uint32_t line_height = impl->line_height;\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  int32_t view_top = layout_info->oy + layout_info->margin_t;\n  int32_t view_bottom = layout_info->oy + layout_info->margin_t + layout_info->h;\n\n  uint32_t i = 0;\n  uint32_t k = 0;\n  for (i = 0; i < rows->size; i++) {\n    uint32_t j = 0;\n    row_info_t* row = rows->row + i;\n\n    for (j = 0; j < row->line_num; j++, k++) {\n      line_info_t* line = (line_info_t*)darray_get(&row->info, j);\n      int32_t y = 0;\n\n      if (impl->single_line) {\n        y = (layout_info->h - c->font_size) / 2 + layout_info->margin_t;\n\n      } else {\n        y = k * line_height + layout_info->margin_t;\n      }\n\n      if ((y + c->font_size) < view_top) {\n        continue;\n      }\n\n      if (y > view_bottom) {\n        break;\n      }\n\n      text_edit_paint_line(text_edit, c, line, y);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_paint_text(text_edit_t* text_edit, canvas_t* c) {\n  widget_t* widget = text_edit->widget;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->text.size > 0) {\n    return text_edit_paint_real_text(text_edit, c);\n  } else {\n    color_t trans =\n        style_get_color(widget->astyle, STYLE_ID_TEXT_COLOR, color_init(0x0, 0x0, 0x0, 0x0));\n    color_t tc = style_get_color(widget->astyle, STYLE_ID_TIPS_TEXT_COLOR, trans);\n    align_h_t align_h =\n        (align_h_t)style_get_int(widget->astyle, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_LEFT);\n    align_v_t align_v =\n        (align_v_t)style_get_int(widget->astyle, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    canvas_set_text_color(c, tc);\n    canvas_set_text_align(c, align_h, align_v);\n    return text_edit_paint_tips_text(text_edit, c);\n  }\n}\n\nstatic ret_t text_edit_do_paint(text_edit_t* text_edit, canvas_t* c) {\n  bool_t is_notify = FALSE;\n  uint32_t new_line_height = 0;\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL && c != NULL, RET_BAD_PARAMS);\n\n  widget_prepare_text_style(text_edit->widget, c);\n  widget_get_text_layout_info(text_edit->widget, &(impl->layout_info));\n\n  new_line_height = c->font_size * FONT_BASELINE;\n  is_notify = impl->line_height != new_line_height;\n  impl->line_height = new_line_height;\n\n  if (text_edit_paint_text(text_edit, c) == RET_OK) {\n    DECL_IMPL(text_edit);\n    STB_TexteditState* state = &(impl->state);\n\n    if (state->select_start == state->select_end && impl->caret_visible) {\n      text_edit_paint_caret(text_edit, c);\n    }\n  }\n\n  if (is_notify) {\n    text_edit_layout(text_edit);\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_paint(text_edit_t* text_edit, canvas_t* c) {\n  rect_t save_r;\n  rect_t clip_r;\n  rect_t edit_r;\n  DECL_IMPL(text_edit);\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  style_t* style = text_edit->widget->astyle;\n\n  if (impl->is_first_time_layout) {\n    text_edit_layout(text_edit);\n    impl->is_first_time_layout = FALSE;\n\n    impl->font_size = style_get_int(style, STYLE_ID_FONT_SIZE, TK_DEFAULT_FONT_SIZE);\n    impl->font_name = system_info_fix_font_name(style_get_str(style, STYLE_ID_FONT_NAME, NULL));\n  } else {\n    if (text_edit_is_need_layout(text_edit)) {\n      text_edit_layout(text_edit);\n    }\n  }\n\n  canvas_get_clip_rect(c, &save_r);\n\n  edit_r = rect_init(c->ox + layout_info->margin_l, c->oy + layout_info->margin_t, layout_info->w,\n                     layout_info->h);\n  clip_r = rect_intersect(&save_r, &edit_r);\n\n  canvas_save(c);\n  canvas_set_clip_rect(c, &clip_r);\n  text_edit_do_paint(text_edit, c);\n  canvas_restore(c);\n\n  canvas_set_clip_rect(c, &save_r);\n\n  return RET_OK;\n}\n\nstatic int text_edit_remove(STB_TEXTEDIT_STRING* str, int pos, int num) {\n  wstr_t* text = &(str->widget->text);\n  wstr_remove(text, pos, num);\n\n  return TRUE;\n}\n\nstatic int text_edit_get_char_width(STB_TEXTEDIT_STRING* str, int pos, int offset) {\n  wstr_t* text = &(str->widget->text);\n  wchar_t chr = text->str[pos + offset];\n\n  if (chr == STB_TEXTEDIT_NEWLINE) {\n    return STB_TEXTEDIT_GETWIDTH_NEWLINE;\n  } else {\n    return canvas_measure_text(GET_CANVAS(str), &chr, 1) + CHAR_SPACING;\n  }\n}\n\nstatic int text_edit_insert(STB_TEXTEDIT_STRING* str, int pos, STB_TEXTEDIT_CHARTYPE* newtext,\n                            int num) {\n  bool_t ret = FALSE;\n  wstr_t* text = &(str->widget->text);\n  DECL_IMPL(str);\n  uint32_t line_break_num = impl->rows->capacity > impl->last_row_number\n                                ? impl->rows->capacity - impl->last_row_number\n                                : 0;\n  uint32_t i = 0;\n\n  for (i = 0; i < num; i++) {\n    if (i + 1 < num && TWINS_WCHAR_IS_LINE_BREAK(newtext[i], newtext[i + 1])) {\n      line_break_num--;\n      i++;\n    } else if (WCHAR_IS_LINE_BREAK(newtext[i])) {\n      line_break_num--;\n    }\n    if (line_break_num == 0) {\n      num = i;\n      break;\n    }\n  }\n\n  if (impl->max_chars > 0) {\n    uint32_t surplus_char = impl->max_chars > text->size ? impl->max_chars - text->size : 0;\n    num = tk_min(num, surplus_char);\n  }\n\n  if (num > 0) {\n    wstr_insert(text, pos, newtext, num);\n    ret = TRUE;\n  }\n\n  return (int)ret;\n}\n\n#define KEYDOWN_BIT 0x80000000\n#define STB_TEXTEDIT_STRINGLEN(str) ((str)->widget->text.size)\n#define STB_TEXTEDIT_LAYOUTROW text_edit_layout_for_stb\n#define STB_TEXTEDIT_GETWIDTH(str, n, i) text_edit_get_char_width(str, n, i)\n#define STB_TEXTEDIT_KEYTOTEXT(key) (((key)&KEYDOWN_BIT) ? 0 : ((uint16_t)key))\n#define STB_TEXTEDIT_GETCHAR(str, i) (((str)->widget->text).str[i])\n#define STB_TEXTEDIT_IS_SPACE(ch) iswspace(ch)\n#define STB_TEXTEDIT_DELETECHARS text_edit_remove\n#define STB_TEXTEDIT_INSERTCHARS text_edit_insert\n\n#define STB_TEXTEDIT_K_SHIFT 0x40000000\n#define STB_TEXTEDIT_K_CONTROL 0x20000000\n#define STB_TEXTEDIT_K_LEFT (KEYDOWN_BIT | 1)\n#define STB_TEXTEDIT_K_RIGHT (KEYDOWN_BIT | 2)  // VK_RIGHT\n#define STB_TEXTEDIT_K_UP (KEYDOWN_BIT | 3)  // VK_UP\n#define STB_TEXTEDIT_K_DOWN (KEYDOWN_BIT | 4)  // VK_DOWN\n#define STB_TEXTEDIT_K_LINESTART (KEYDOWN_BIT | 5)  // VK_HOME\n#define STB_TEXTEDIT_K_LINEEND (KEYDOWN_BIT | 6)  // VK_END\n#define STB_TEXTEDIT_K_TEXTSTART (STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_CONTROL)\n#define STB_TEXTEDIT_K_TEXTEND (STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_CONTROL)\n#define STB_TEXTEDIT_K_DELETE (KEYDOWN_BIT | 7)  // VK_DELETE\n#define STB_TEXTEDIT_K_BACKSPACE (KEYDOWN_BIT | 8)  // VK_BACKSPACE\n#define STB_TEXTEDIT_K_UNDO (KEYDOWN_BIT | STB_TEXTEDIT_K_CONTROL | 'z')\n#define STB_TEXTEDIT_K_REDO (KEYDOWN_BIT | STB_TEXTEDIT_K_CONTROL | 'y')\n#define STB_TEXTEDIT_K_INSERT (KEYDOWN_BIT | 9)  // VK_INSERT\n#define STB_TEXTEDIT_K_WORDLEFT (STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_CONTROL)\n#define STB_TEXTEDIT_K_WORDRIGHT (STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_CONTROL)\n#define STB_TEXTEDIT_K_PGUP (KEYDOWN_BIT | 10)  // VK_PGUP -- not implemented\n#define STB_TEXTEDIT_K_PGDOWN (KEYDOWN_BIT | 11)  // VK_PGDOWN -- not implemented\n\n#define STB_TEXTEDIT_IMPLEMENTATION 1\n\n#include \"stb/stb_textedit.h\"\n\ntext_edit_t* text_edit_create(widget_t* widget, bool_t single_line) {\n  text_edit_impl_t* impl = NULL;\n  return_value_if_fail(widget != NULL, NULL);\n\n  impl = TKMEM_ZALLOC(text_edit_impl_t);\n  return_value_if_fail(impl != NULL, NULL);\n\n  impl->is_first_time_layout = TRUE;\n  impl->wrap_word = !single_line;\n  impl->text_edit.widget = widget;\n  impl->single_line = single_line;\n\n  wstr_init(&(impl->tips), 0);\n  stb_textedit_initialize_state(&(impl->state), single_line);\n  if (!single_line) {\n    text_edit_set_max_rows((text_edit_t*)impl, 100);\n  } else {\n    text_edit_set_max_rows((text_edit_t*)impl, 1);\n  }\n\n  return (text_edit_t*)impl;\n}\n\nret_t text_edit_set_caret_visible(text_edit_t* text_edit, bool_t caret_visible) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit, RET_BAD_PARAMS);\n\n  impl->caret_visible = caret_visible;\n\n  return RET_OK;\n}\n\nret_t text_edit_invert_caret_visible(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit, RET_BAD_PARAMS);\n\n  impl->caret_visible = !impl->caret_visible;\n\n  return RET_OK;\n}\n\nret_t text_edit_set_max_rows(text_edit_t* text_edit, uint32_t max_rows) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL && max_rows >= 1, RET_BAD_PARAMS);\n\n  if (impl->rows != NULL) {\n    rows_destroy(impl->rows);\n    impl->rows = NULL;\n  }\n\n  if (impl->rows == NULL) {\n    impl->rows = rows_create(max_rows);\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_set_max_chars(text_edit_t* text_edit, uint32_t max_chars) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->max_chars = max_chars;\n\n  return RET_OK;\n}\n\nuint32_t text_edit_get_height(text_edit_t* text_edit, uint32_t offset) {\n  uint32_t i = 0;\n  uint32_t k = 0;\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, 0);\n\n  for (i = 0; i < impl->rows->size; i++) {\n    uint32_t j = 0;\n    row_info_t* row = impl->rows->row + i;\n    for (j = 0; j < row->line_num; j++, k++) {\n      line_info_t* line = (line_info_t*)darray_get(&row->info, j);\n      if (offset < line->offset + line->length) {\n        return impl->line_height * k;\n      }\n    }\n  }\n\n  return impl->line_height * ((k > 1) ? k - 1 : 0);\n}\n\nconst uint32_t* text_edit_get_lines_of_each_row(text_edit_t* text_edit) {\n  uint32_t* lines_of_each_row = NULL;\n  uint32_t size = 0;\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL && impl != NULL && impl->rows != NULL, NULL);\n\n  size = impl->rows->capacity;\n\n  if (size) {\n    uint32_t i = 0;\n    lines_of_each_row = impl->rows->row_line;\n    memset(lines_of_each_row, 0x00, sizeof(uint32_t) * size);\n\n    for (i = 0; i < impl->rows->size; i++) {\n      lines_of_each_row[i] = impl->rows->row[i].line_num;\n    }\n  }\n\n  return lines_of_each_row;\n}\n\nstatic uint32_t text_edit_get_line_break_offset(text_edit_t* text_edit, uint32_t num) {\n  uint32_t offset = 0;\n  uint32_t i = 0;\n  wstr_t* text = NULL;\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL && text_edit->widget != NULL, -1);\n  return_value_if_fail(0 < num && num < impl->rows->capacity, -1);\n\n  if (num >= impl->rows->size) {\n    return -1;\n  }\n\n  text = &text_edit->widget->text;\n\n  for (i = 0; i < num; i++) {\n    offset += impl->rows->row[i].length;\n  }\n\n  if (offset >= 2 && TWINS_WCHAR_IS_LINE_BREAK(text->str[offset - 2], text->str[offset - 1])) {\n    offset -= 2;\n  } else if (offset >= 1 && WCHAR_IS_LINE_BREAK(text->str[offset - 1])) {\n    offset--;\n  } else {\n    offset = -1;\n  }\n\n  return offset;\n}\n\nret_t text_edit_set_canvas(text_edit_t* text_edit, canvas_t* canvas) {\n  return_value_if_fail(text_edit != NULL && canvas != NULL, RET_BAD_PARAMS);\n\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nstatic point_t text_edit_normalize_point(text_edit_t* text_edit, xy_t x, xy_t y) {\n  DECL_IMPL(text_edit);\n  point_t point = {x, y};\n  text_layout_info_t* layout_info = &(impl->layout_info);\n\n  widget_to_local(text_edit->widget, &point);\n\n  point.x = point.x - layout_info->margin_l + layout_info->ox;\n  point.y = point.y - layout_info->margin_t + layout_info->oy;\n\n  return point;\n}\n\nstatic bool_t text_edit_is_need_layout(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  style_t* style = text_edit->widget->astyle;\n  uint16_t font_size = style_get_int(style, STYLE_ID_FONT_SIZE, TK_DEFAULT_FONT_SIZE);\n  const char* font_name = system_info_fix_font_name(style_get_str(style, STYLE_ID_FONT_NAME, NULL));\n\n  if (!tk_str_eq(font_name, impl->font_name) || font_size != impl->font_size) {\n    impl->font_name = font_name;\n    impl->font_size = font_size;\n    return TRUE;\n  }\n  return FALSE;\n}\n\nstatic ret_t text_edit_update_caret_pos(text_edit_t* text_edit) {\n  uint32_t i = 0;\n  uint32_t j = 0;\n  uint32_t k = 0;\n  uint32_t y = 0;\n  DECL_IMPL(text_edit);\n  uint32_t line_index = 0;\n  rows_t* rows = impl->rows;\n  bool_t is_setting = FALSE;\n  canvas_t* c = GET_CANVAS(text_edit);\n  uint32_t font_size = impl->font_size;\n  uint32_t line_height = impl->line_height;\n  wstr_t* text = &(text_edit->widget->text);\n\n  canvas_set_font(c, impl->font_name, font_size);\n\n  for (i = 0; i < rows->size; i++) {\n    row_info_t* row = rows->row + i;\n    for (j = 0; j < row->line_num; j++, y += line_height, line_index++) {\n      line_info_t* line = (line_info_t*)darray_get(&row->info, j);\n      uint32_t line_offset_begin = line->offset;\n      uint32_t line_offset_end = line->offset + line->length;\n      if ((line_offset_begin <= impl->state.cursor && impl->state.cursor < line_offset_end) ||\n          (j + 1 == row->line_num && impl->state.cursor == line_offset_end)) {\n        uint32_t x = line->x;\n        wchar_t last_char = 0;\n        wchar_t* p = text->str + line_offset_begin;\n        uint32_t offset = impl->state.cursor - line_offset_begin;\n        for (k = 0; k < line->length; k++, p++) {\n          if (offset == k) {\n            break;\n          }\n          x += (canvas_measure_text(c, p, 1) + CHAR_SPACING);\n          last_char = *p;\n        }\n        is_setting = TRUE;\n        if (last_char == STB_TEXTEDIT_NEWLINE) {\n          text_edit_set_caret_pos(impl, 0, y + line_height, c->font_size, line_index);\n        } else {\n          text_edit_set_caret_pos(impl, x, y, c->font_size, line_index);\n        }\n        break;\n      }\n    }\n    if (is_setting) {\n      break;\n    }\n  }\n  text_edit_fix_oy(impl);\n  text_edit_notify(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_click(text_edit_t* text_edit, xy_t x, xy_t y) {\n  point_t point;\n  DECL_IMPL(text_edit);\n  return_value_if_fail(impl != NULL, RET_BAD_PARAMS);\n\n  widget_prepare_text_style(text_edit->widget, GET_CANVAS(text_edit));\n  point = text_edit_normalize_point(text_edit, x, y);\n  stb_textedit_click(text_edit, &(impl->state), point.x, point.y);\n\n  if (impl->single_line || text_edit_is_need_layout(text_edit)) {\n    text_edit_layout(text_edit);\n  } else {\n    text_edit_update_caret_pos(text_edit);\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_drag(text_edit_t* text_edit, xy_t x, xy_t y) {\n  point_t point;\n  DECL_IMPL(text_edit);\n  return_value_if_fail(impl != NULL, RET_BAD_PARAMS);\n\n  widget_prepare_text_style(text_edit->widget, GET_CANVAS(text_edit));\n  point = text_edit_normalize_point(text_edit, x, y);\n  stb_textedit_drag(text_edit, &(impl->state), point.x, point.y);\n\n  if (impl->single_line || text_edit_is_need_layout(text_edit)) {\n    text_edit_layout(text_edit);\n  } else {\n    text_edit_update_caret_pos(text_edit);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_paste_from_clip_board(text_edit_t* text_edit) {\n  value_t v;\n  wstr_t str;\n  const char* data = clip_board_get_text();\n  if (data != NULL) {\n    value_set_str(&v, data);\n    wstr_init(&str, 0);\n    wstr_from_value(&str, &v);\n    wstr_normalize_newline(&str, STB_TEXTEDIT_NEWLINE);\n    text_edit_paste(text_edit, str.str, str.size);\n    wstr_reset(&str);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_handle_shortcut(text_edit_t* text_edit, key_event_t* evt,\n                                       STB_TexteditState* state, wstr_t* text) {\n#ifdef MACOS\n  if (evt->cmd) {\n#else\n  if (evt->ctrl) {\n#endif\n    uint32_t key = evt->key;\n    char c = tolower(key);\n    if (c == 'z' || c == 'Z') {\n      stb_textedit_key(text_edit, state, STB_TEXTEDIT_K_UNDO);\n    } else if (c == 'y' || c == 'Y') {\n      stb_textedit_key(text_edit, state, STB_TEXTEDIT_K_REDO);\n    } else if (c == 'c' || c == 'C') {\n      text_edit_copy(text_edit);\n    } else if (c == 'x' || c == 'X') {\n      text_edit_cut(text_edit);\n    } else if (c == 'a' || c == 'A') {\n      state->select_start = 0;\n      state->select_end = text->size;\n    } else if (c == 'v' || c == 'V') {\n      text_edit_paste_from_clip_board(text_edit);\n    } else if (key > 128 || !tk_isprint(key)) {\n      return RET_FAIL;\n    }\n\n    text_edit_layout(text_edit);\n\n    return RET_OK;\n  }\n\n  return RET_FAIL;\n}\n\nret_t text_edit_key_up(text_edit_t* text_edit, key_event_t* evt) {\n  uint32_t key = 0;\n  ret_t ret = RET_OK;\n  widget_t* widget = NULL;\n  input_method_t* im = input_method();\n  return_value_if_fail(im != NULL, RET_FAIL);\n  return_value_if_fail(text_edit != NULL && text_edit->widget != NULL && evt != NULL, RET_FAIL);\n\n  key = evt->key;\n  widget = text_edit->widget;\n  if (key == TK_KEY_OPEN_INPUT_METHOD) {\n    input_method_request(im, widget);\n    ret = RET_STOP;\n  } else if (key == TK_KEY_CLOSE_INPUT_METHOD) {\n    input_method_request(im, NULL);\n    ret = RET_STOP;\n  } else if (key == TK_KEY_TOGGLE_INPUT_METHOD) {\n    if (im->widget == widget) {\n      input_method_request(im, NULL);\n    } else {\n      input_method_request(im, widget);\n    }\n    ret = RET_STOP;\n  }\n\n  return ret;\n}\n\nret_t text_edit_key_down(text_edit_t* text_edit, key_event_t* evt) {\n  uint32_t key = 0;\n  wstr_t* text = NULL;\n  DECL_IMPL(text_edit);\n  bool_t move_caret_pos = FALSE;\n  STB_TexteditState* state = NULL;\n  text_layout_info_t* layout_info = NULL;\n  return_value_if_fail(impl != NULL, RET_BAD_PARAMS);\n\n  key = evt->key;\n  state = &(impl->state);\n  text = &(text_edit->widget->text);\n  layout_info = &(impl->layout_info);\n\n  switch (key) {\n#ifdef WITH_SDL\n    case TK_KEY_KP_DIVIDE:\n    case TK_KEY_KP_MULTIPLY:\n    case TK_KEY_KP_MINUS:\n    case TK_KEY_KP_PLUS:\n    case TK_KEY_KP_PERIOD:\n    case TK_KEY_NUMLOCKCLEAR:\n    case TK_KEY_KP_0:\n    case TK_KEY_KP_1:\n    case TK_KEY_KP_2:\n    case TK_KEY_KP_3:\n    case TK_KEY_KP_4:\n    case TK_KEY_KP_5:\n    case TK_KEY_KP_6:\n    case TK_KEY_KP_7:\n    case TK_KEY_KP_8:\n    case TK_KEY_KP_9:\n      return RET_OK;\n    case TK_KEY_KP_ENTER:\n#endif\n    case TK_KEY_RETURN: {\n      key = STB_TEXTEDIT_NEWLINE;\n      break;\n    }\n    case TK_KEY_LEFT: {\n      move_caret_pos = TRUE;\n      key = STB_TEXTEDIT_K_LEFT;\n      break;\n    }\n    case TK_KEY_RIGHT: {\n      move_caret_pos = TRUE;\n      key = STB_TEXTEDIT_K_RIGHT;\n      break;\n    }\n    case TK_KEY_DOWN: {\n      move_caret_pos = TRUE;\n      key = STB_TEXTEDIT_K_DOWN;\n      break;\n    }\n    case TK_KEY_UP: {\n      move_caret_pos = TRUE;\n      key = STB_TEXTEDIT_K_UP;\n      break;\n    }\n    case TK_KEY_HOME: {\n      move_caret_pos = TRUE;\n      state->cursor = 0;\n      key = STB_TEXTEDIT_K_LINESTART;\n      break;\n    }\n    case TK_KEY_END: {\n      move_caret_pos = TRUE;\n      state->cursor = text->size;\n      key = STB_TEXTEDIT_K_LINEEND;\n      break;\n    }\n    case TK_KEY_DELETE: {\n      key = STB_TEXTEDIT_K_DELETE;\n      break;\n    }\n    case TK_KEY_BACKSPACE: {\n      key = STB_TEXTEDIT_K_BACKSPACE;\n      break;\n    }\n    case TK_KEY_INSERT: {\n      key = STB_TEXTEDIT_K_INSERT;\n      break;\n    }\n    case TK_KEY_PAGEDOWN: {\n      move_caret_pos = TRUE;\n      if (impl->single_line) {\n        key = STB_TEXTEDIT_K_LINEEND;\n      } else {\n        int32_t lines = layout_info->h / impl->line_height;\n        int32_t next_lines = impl->caret_line_index + lines;\n        int32_t next_y = next_lines * impl->line_height;\n        if (layout_info->virtual_h > next_y) {\n          while (lines-- > 0) {\n            stb_textedit_key(text_edit, state, STB_TEXTEDIT_K_DOWN);\n          }\n        } else {\n          state->cursor = text->size;\n          stb_textedit_key(text_edit, state, STB_TEXTEDIT_K_LINEEND);\n        }\n        goto layout;\n\n        return RET_OK;\n      }\n      break;\n    }\n    case TK_KEY_PAGEUP: {\n      move_caret_pos = TRUE;\n      if (impl->single_line) {\n        key = STB_TEXTEDIT_K_LINESTART;\n      } else {\n        int32_t lines = layout_info->h / impl->line_height;\n        int32_t next_lines = impl->caret_line_index - lines;\n\n        if (next_lines > 0) {\n          while (lines-- > 0) {\n            stb_textedit_key(text_edit, state, STB_TEXTEDIT_K_UP);\n          }\n        } else {\n          state->cursor = 0;\n          stb_textedit_key(text_edit, state, STB_TEXTEDIT_K_LINESTART);\n        }\n        goto layout;\n      }\n      break;\n    }\n    case TK_KEY_F1:\n    case TK_KEY_F2:\n    case TK_KEY_F3:\n    case TK_KEY_F4:\n    case TK_KEY_F5:\n    case TK_KEY_F6:\n    case TK_KEY_F7:\n    case TK_KEY_F8:\n    case TK_KEY_F9:\n    case TK_KEY_F10:\n    case TK_KEY_F11:\n    case TK_KEY_F12:\n    case TK_KEY_LSHIFT:\n    case TK_KEY_RSHIFT:\n    case TK_KEY_LCTRL:\n    case TK_KEY_RCTRL:\n    case TK_KEY_LALT:\n    case TK_KEY_RALT:\n    case TK_KEY_CAPSLOCK:\n    case TK_KEY_COMMAND:\n    case TK_KEY_MENU:\n    case TK_KEY_WHEEL: {\n      return RET_OK;\n    }\n    default: {\n      if (key < 128 && tk_isprint(key)) {\n        app_type_t app_type = system_info()->app_type;\n        if (app_type == APP_DESKTOP || app_type == APP_MOBILE) {\n          text_edit_handle_shortcut(text_edit, evt, state, text);\n          return RET_OK;\n        }\n      }\n      break;\n    }\n  }\n\n  if (text_edit_handle_shortcut(text_edit, evt, state, text) == RET_OK) {\n    return RET_OK;\n  }\n\n  if (evt->shift) {\n    key |= STB_TEXTEDIT_K_SHIFT;\n  }\n\n  stb_textedit_key(text_edit, state, key);\nlayout:\n  if (!impl->single_line && move_caret_pos && !text_edit_is_need_layout(text_edit)) {\n    text_edit_update_caret_pos(text_edit);\n  } else {\n    text_edit_layout(text_edit);\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_copy(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  wstr_t* text = NULL;\n  uint32_t select_end = 0;\n  uint32_t select_start = 0;\n  STB_TexteditState* state = NULL;\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  state = &(impl->state);\n  text = &(text_edit->widget->text);\n  select_start = tk_min(state->select_start, state->select_end);\n  select_end = tk_max(state->select_start, state->select_end);\n\n  if (select_end > select_start) {\n    str_t str;\n    wstr_t wstr;\n    wchar_t* start = text->str + select_start;\n    uint32_t size = select_end - select_start;\n\n    wstr_init(&wstr, size + 1);\n    wstr_append_with_len(&wstr, start, size);\n\n    str_init(&str, 0);\n    str_from_wstr(&str, wstr.str);\n    clip_board_set_text(str.str);\n\n    str_reset(&str);\n    wstr_reset(&wstr);\n  }\n\n  return RET_OK;\n}\n\nchar* text_edit_get_selected_text(text_edit_t* text_edit) {\n  uint32_t size = 0;\n  text_edit_state_t state = {0};\n  char* ret = NULL;\n  return_value_if_fail(text_edit != NULL, NULL);\n\n  text_edit_get_state(text_edit, &state);\n  size = state.select_end - state.select_start;\n\n  if (size > 0) {\n    ret = tk_utf8_dup_utf16(text_edit->widget->text.str + state.select_start, size);\n  }\n\n  return ret;\n}\n\nret_t text_edit_cut(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  if (text_edit_copy(text_edit) == RET_OK) {\n    stb_textedit_cut(text_edit, &(impl->state));\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_paste(text_edit_t* text_edit, const wchar_t* str, uint32_t size) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL && str != NULL, RET_BAD_PARAMS);\n\n  stb_textedit_paste(text_edit, &(impl->state), str, size);\n  if (impl->preedit) {\n    impl->preedit_chars_nr += size;\n  }\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_set_cursor(text_edit_t* text_edit, uint32_t cursor) {\n  wstr_t* text = NULL;\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  text = &(text_edit->widget->text);\n\n  if (cursor > text->size) {\n    cursor = text->size;\n  }\n\n  if (impl->state.cursor != cursor) {\n    impl->state.cursor = cursor;\n    text_edit_layout(text_edit);\n  }\n\n  return RET_OK;\n}\n\nuint32_t text_edit_get_cursor(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, 0);\n\n  return impl->state.cursor;\n}\n\nret_t text_edit_set_wrap_word(text_edit_t* text_edit, bool_t wrap_word) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->wrap_word = wrap_word;\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_set_overwrite(text_edit_t* text_edit, bool_t overwrite) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->overwrite = overwrite;\n  text_edit_notify(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_set_mask(text_edit_t* text_edit, bool_t mask) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  if (impl->mask != mask) {\n    impl->mask = mask;\n    text_edit_layout(text_edit);\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_set_tips(text_edit_t* text_edit, const char* tips, bool_t mlines) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->is_mlines = mlines;\n  wstr_set_utf8(&(impl->tips), tips);\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_set_mask_char(text_edit_t* text_edit, wchar_t mask_char) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->mask_char = mask_char;\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_set_select(text_edit_t* text_edit, uint32_t start, uint32_t end) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  if (start > end) {\n    uint32_t t = start;\n    start = end;\n    end = t;\n  }\n\n  impl->state.select_start = start;\n  impl->state.select_end = tk_min(end, text_edit->widget->text.size);\n\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_select_all(text_edit_t* text_edit) {\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  return text_edit_set_select(text_edit, 0, text_edit->widget->text.size);\n}\n\nret_t text_edit_unselect(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->state.select_end = impl->state.select_start;\n\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_get_state(text_edit_t* text_edit, text_edit_state_t* state) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL && state != NULL, RET_BAD_PARAMS);\n\n  memset(state, 0x00, sizeof(text_edit_state_t));\n\n  state->ox = impl->layout_info.ox;\n  state->oy = impl->layout_info.oy;\n  state->virtual_w = impl->layout_info.virtual_w;\n  state->virtual_h = impl->layout_info.virtual_h;\n  state->rows = impl->rows->size;\n  state->max_chars = impl->max_chars;\n  state->caret = impl->caret;\n  state->preedit = impl->preedit;\n  state->line_height = impl->line_height;\n\n  state->cursor = impl->state.cursor;\n  state->max_rows = impl->rows->capacity;\n  state->last_row_number = impl->last_row_number;\n  state->last_line_number = impl->last_line_number;\n\n  state->select_start = tk_min(impl->state.select_start, impl->state.select_end);\n  state->select_end = tk_max(impl->state.select_start, impl->state.select_end);\n\n  state->mask = impl->mask;\n  state->overwrite = impl->overwrite;\n  state->wrap_word = impl->wrap_word;\n  state->mask_char = impl->mask_char;\n  state->caret_visible = impl->caret_visible;\n  state->single_line = impl->single_line;\n\n  return RET_OK;\n}\n\nret_t text_edit_destroy(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  wstr_reset(&(impl->tips));\n  rows_destroy(impl->rows);\n  TKMEM_FREE(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_set_offset(text_edit_t* text_edit, int32_t ox, int32_t oy) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->layout_info.ox = ox;\n  impl->layout_info.oy = oy;\n  text_edit_notify(text_edit);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_notify(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  if (impl->on_state_changed != NULL) {\n    text_edit_state_t state = {0};\n    text_edit_get_state(text_edit, &state);\n    impl->on_state_changed(impl->on_state_changed_ctx, &state);\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_set_on_state_changed(text_edit_t* text_edit,\n                                     text_edit_on_state_changed_t on_state_changed, void* ctx) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->on_state_changed = on_state_changed;\n  impl->on_state_changed_ctx = ctx;\n\n  return RET_OK;\n}\n\nret_t text_edit_preedit(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->preedit = TRUE;\n  impl->preedit_chars_nr = 0;\n\n  return RET_OK;\n}\n\nret_t text_edit_preedit_confirm(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->preedit = FALSE;\n  impl->preedit_chars_nr = 0;\n\n  return RET_OK;\n}\n\nret_t text_edit_preedit_clear(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  if (impl->preedit_chars_nr > 0) {\n    text_edit_remove(text_edit, impl->state.cursor - impl->preedit_chars_nr,\n                     impl->preedit_chars_nr);\n    impl->state.cursor = impl->state.cursor - impl->preedit_chars_nr;\n    impl->preedit_chars_nr = 0;\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_preedit_abort(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->preedit = FALSE;\n  text_edit_preedit_clear(text_edit);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_insert_wtext_with_len(text_edit_t* text_edit, uint32_t offset,\n                                             const wchar_t* wtext, uint32_t len) {\n  ret_t ret = RET_FAIL;\n  uint32_t size = 0;\n  return_value_if_fail(text_edit != NULL && text_edit->widget != NULL && wtext != NULL,\n                       RET_BAD_PARAMS);\n\n  size = wcslen(wtext);\n  len = tk_min(len, size);\n  offset = tk_min(offset, text_edit->widget->text.size);\n\n  ret = !!text_edit_insert(text_edit, offset, (wchar_t*)wtext, len) ? RET_OK : RET_SKIP;\n\n  if (ret == RET_OK) {\n    if (offset + len != text_edit_get_cursor(text_edit)) {\n      text_edit_set_cursor(text_edit, offset + len);\n    } else {\n      text_edit_layout(text_edit);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t text_edit_insert_text_with_len(text_edit_t* text_edit, uint32_t offset,\n                                            const char* text, uint32_t len) {\n  ret_t ret = RET_FAIL;\n  wstr_t s = {0};\n  return_value_if_fail(text_edit != NULL && text_edit->widget != NULL && text != NULL,\n                       RET_BAD_PARAMS);\n\n  wstr_set_utf8(&s, text);\n  ret = text_edit_insert_wtext_with_len(text_edit, offset, s.str, len);\n  wstr_reset(&s);\n\n  return ret;\n}\n\nret_t text_edit_insert_text(text_edit_t* text_edit, uint32_t offset, const char* text) {\n  return text_edit_insert_text_with_len(text_edit, offset, text, tk_strlen(text));\n}\n\nstatic ret_t text_edit_overwrite_text_fix_select(text_edit_t* text_edit, uint32_t insert_offset,\n                                                 uint32_t insert_len, uint32_t remove_offset,\n                                                 uint32_t remove_len) {\n  DECL_IMPL(text_edit);\n  wstr_t* wstr = &text_edit->widget->text;\n  uint32_t select_start = impl->state.select_start;\n  uint32_t select_end = impl->state.select_end;\n\n  if (impl->state.select_start > insert_offset) {\n    select_start = tk_min(select_start + insert_len, wstr->size);\n  }\n  if (impl->state.select_end > insert_offset) {\n    select_end = tk_min(select_end + insert_len, wstr->size);\n  }\n\n  if (tk_max(impl->state.select_start, impl->state.select_end) > remove_offset &&\n      tk_min(impl->state.select_start, impl->state.select_end) < remove_len) {\n    select_start = select_end = 0;\n  } else {\n    if (impl->state.select_start > remove_offset) {\n      select_start -= remove_len;\n    }\n    if (impl->state.select_end > remove_offset) {\n      select_end -= remove_len;\n    }\n  }\n  impl->state.select_start = select_start;\n  impl->state.select_end = select_end;\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_overwrite_text_not_at_last_row(text_edit_t* text_edit, uint32_t* p_offset,\n                                                      const char* text, uint32_t len) {\n  DECL_IMPL(text_edit);\n  wstr_t* wstr = &text_edit->widget->text;\n  wstr_t s = {0};\n  /* 获取最后一个换行符的偏移位置 */\n  uint32_t last_row_line_break =\n      text_edit_get_line_break_offset(text_edit, impl->rows->capacity - 1);\n  uint32_t rm_len = 0;\n  uint32_t rm_index = 0;\n\n  if (last_row_line_break < wstr->size) {\n    rm_index = tk_max(*p_offset, last_row_line_break);\n    if (wstr->size > rm_index) {\n      rm_len = wstr->size - rm_index;\n      wstr_remove(wstr, rm_index, rm_len);\n    }\n  }\n\n  wstr_set_utf8_with_len(&s, text, len);\n  wstr_insert(wstr, *p_offset, s.str, s.size);\n  text_edit_overwrite_text_fix_select(text_edit, *p_offset, s.size, rm_index, rm_len);\n  wstr_reset(&s);\n\n  if (*p_offset + len != text_edit_get_cursor(text_edit)) {\n    text_edit_set_cursor(text_edit, *p_offset + len);\n  } else {\n    text_edit_layout(text_edit);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_overwrite_text_at_last_row(text_edit_t* text_edit, uint32_t* p_offset,\n                                                  const char* text, uint32_t len) {\n  DECL_IMPL(text_edit);\n  wstr_t* wstr = &text_edit->widget->text;\n  uint32_t line_break_num = impl->rows->capacity > impl->last_row_number\n                                ? impl->rows->capacity - impl->last_row_number\n                                : 0;\n  wstr_t s = {0};\n  uint32_t rm_len = 0;\n\n  if (line_break_num <= 1) {\n    rm_len = impl->rows->row[0].length;\n    wstr_remove(wstr, 0, rm_len);\n    *p_offset = tk_min(*p_offset > rm_len ? *p_offset - rm_len : 0, wstr->size);\n\n    if (wstr->size > *p_offset) {\n      wstr_remove(wstr, *p_offset, wstr->size - *p_offset);\n      text_edit_overwrite_text_fix_select(text_edit, 0, 0, *p_offset, wstr->size - *p_offset);\n    }\n  }\n\n  wstr_set_utf8_with_len(&s, text, len);\n  wstr_insert(wstr, *p_offset, s.str, s.size);\n  text_edit_overwrite_text_fix_select(text_edit, *p_offset, s.size, 0, rm_len);\n  wstr_reset(&s);\n\n  if (*p_offset + len != text_edit_get_cursor(text_edit)) {\n    text_edit_set_cursor(text_edit, *p_offset + len);\n  } else {\n    text_edit_layout(text_edit);\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_overwrite_text(text_edit_t* text_edit, uint32_t* p_offset, const char* text,\n                               uint32_t len) {\n  DECL_IMPL(text_edit);\n  wstr_t* wstr = NULL;\n  uint32_t text_size = 0;\n  ret_t ret = RET_FAIL;\n  return_value_if_fail(text_edit != NULL && text_edit->widget != NULL && text != NULL,\n                       RET_BAD_PARAMS);\n\n  wstr = &text_edit->widget->text;\n  text_size = tk_strlen(text);\n  *p_offset = tk_min(wstr->size, *p_offset);\n  len = tk_min(len, text_size);\n\n  /* 插入位置 不在最后一行 */\n  if (*p_offset < wstr->size - impl->rows->row[impl->rows->capacity - 1].length) {\n    ret = text_edit_overwrite_text_not_at_last_row(text_edit, p_offset, text, len);\n  } else {\n    ret = text_edit_overwrite_text_at_last_row(text_edit, p_offset, text, len);\n  }\n  *p_offset += len;\n\n  return ret;\n}\n\nret_t text_edit_set_lock_scrollbar_value(text_edit_t* text_edit, bool_t lock) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->lock_scrollbar_value = lock;\n\n  return RET_OK;\n}\n\n#include \"window.h\"\n#include \"window_manager.h\"\n\nstatic ret_t text_edit_on_copy(void* ctx, event_t* e) {\n  text_edit_t* text_edit = (text_edit_t*)ctx;\n  text_edit_copy(text_edit);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_on_cut(void* ctx, event_t* e) {\n  text_edit_t* text_edit = (text_edit_t*)ctx;\n  text_edit_cut(text_edit);\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_on_paste(void* ctx, event_t* e) {\n  text_edit_t* text_edit = (text_edit_t*)ctx;\n  text_edit_paste_from_clip_board(text_edit);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_on_select_all(void* ctx, event_t* e) {\n  text_edit_t* text_edit = (text_edit_t*)ctx;\n  text_edit_select_all(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_show_context_menu(text_edit_t* text_edit, int32_t x, int32_t y) {\n  widget_t* win = window_open(\"edit_menu\");\n  widget_t* wm = window_manager();\n\n  if (win != NULL) {\n    DECL_IMPL(text_edit);\n    widget_t* copy = widget_lookup(win, \"copy\", TRUE);\n    widget_t* cut = widget_lookup(win, \"cut\", TRUE);\nwidget_t* paste = ",
    "raw_res": "",
    "prompt_res": "widget_lookup(win, \"paste\", TRUE);",
    "gt": "widget_lookup(win, \"paste\", TRUE);"
  },
  {
    "id": 2194,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/text_edit.c",
    "input": "﻿/**\n * File:   text_edit.c\n * Author: AWTK Develop Team\n * Brief:  text_edit\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-06-08 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include <wctype.h>\n\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/darray.h\"\n#include \"base/bidi.h\"\n#include \"base/line_parser.h\"\n#include \"base/events.h\"\n#include \"base/text_edit.h\"\n#include \"base/line_break.h\"\n#include \"base/clip_board.h\"\n#include \"base/input_method.h\"\n\n#define CHAR_SPACING 1\n#define FONT_BASELINE 1.25f\n#define STB_TEXTEDIT_CHARTYPE wchar_t\n#define STB_TEXTEDIT_NEWLINE (wchar_t)('\\n')\n#define STB_TEXTEDIT_STRING text_edit_t\n\n#if !defined(WITH_SDL)\n#define STB_TEXTEDIT_UNDOSTATECOUNT 10\n#define STB_TEXTEDIT_UNDOCHARCOUNT 32\n#endif /*WITH_SDL*/\n#define STB_TEXTEDIT_GETWIDTH_NEWLINE 0xffff\n\n#include \"stb/stb_textedit.h\"\n\n#define GET_CANVAS(text_edit) widget_get_canvas(WIDGET(text_edit->widget))\ntypedef struct _text_layout_info_t {\n  int32_t w;\n  int32_t h;\n  int32_t ox;\n  int32_t oy;\n\n  uint32_t virtual_w;\n  uint32_t virtual_h;\n  uint32_t widget_w;\n  uint32_t widget_h;\n  uint32_t margin_l;\n  uint32_t margin_t;\n  uint32_t margin_r;\n  uint32_t margin_b;\n} text_layout_info_t;\n\ntypedef struct _line_info_t {\n  uint16_t x;\n  uint32_t offset;\n  uint16_t length;\n  uint16_t text_w;\n} line_info_t;\n\ntypedef struct _row_info_t {\n  uint16_t length;\n  uint32_t line_num;\n  darray_t info;\n} row_info_t;\n\ntypedef struct _rows_t {\n  uint32_t size;\n  uint32_t capacity;\n  uint32_t* row_line;\n  row_info_t row[1];\n} rows_t;\n\ntypedef struct _text_edit_impl_t {\n  text_edit_t text_edit;\n  STB_TexteditState state;\n\n  rows_t* rows;\n  uint32_t max_chars;\n  point_t caret;\n  bool_t overwrite;\n  bool_t wrap_word;\n  bool_t single_line;\n  bool_t caret_visible;\n  uint32_t line_height;\n  uint32_t last_line_number;\n  uint32_t last_row_number;\n  uint32_t caret_line_index;\n  text_layout_info_t layout_info;\n\n  bool_t preedit;\n  uint32_t preedit_chars_nr;\n\n  bool_t lock_scrollbar_value;\n\n  /*for single line edit*/\n  wchar_t mask_char;\n  bool_t mask;\n  wstr_t tips;\n  bool_t is_mlines;\n\n  bool_t is_first_time_layout;\n  int32_t font_size;\n  const char* font_name;\n  void* on_state_changed_ctx;\n  text_edit_on_state_changed_t on_state_changed;\n} text_edit_impl_t;\n\n#define DECL_IMPL(te) text_edit_impl_t* impl = (text_edit_impl_t*)(te)\n\nstatic ret_t text_edit_notify(text_edit_t* text_edit);\nstatic bool_t text_edit_is_need_layout(text_edit_t* text_edit);\nstatic int32_t text_edit_calc_x(text_edit_t* text_edit, line_info_t* iter);\n\nstatic align_h_t widget_get_text_align_h(widget_t* widget) {\n  return (align_h_t)style_get_int(widget->astyle, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_LEFT);\n}\n\n#define TEXT_EDIT_GET_WIDGET_MARGIN(widget, style, out_value, type)             \\\n  {                                                                             \\\n    value_t v;                                                                  \\\n    value_set_int(&v, 0);                                                       \\\n    if (widget_get_prop((widget), WIDGET_PROP_##type##_MARGIN, &v) == RET_OK) { \\\n      (out_value) = value_int(&v);                                              \\\n    }                                                                           \\\n    TEXT_EDIT_GET_STYLE_MARGIN(style, out_value, type)                          \\\n  }\n\nstatic ret_t widget_get_text_layout_info(widget_t* widget, text_layout_info_t* info) {\n  style_t* style = widget->astyle;\n  return_value_if_fail(widget != NULL && info != NULL && style != NULL, RET_BAD_PARAMS);\n\n  info->widget_w = widget->w;\n  info->widget_h = widget->h;\n  info->virtual_w = tk_max(info->virtual_w, widget->w);\n  info->virtual_h = tk_max(info->virtual_h, widget->h);\n\n  TEXT_EDIT_GET_WIDGET_MARGIN(widget, style, info->margin_l, LEFT);\n  TEXT_EDIT_GET_WIDGET_MARGIN(widget, style, info->margin_r, RIGHT);\n  TEXT_EDIT_GET_WIDGET_MARGIN(widget, style, info->margin_t, TOP);\n  TEXT_EDIT_GET_WIDGET_MARGIN(widget, style, info->margin_b, BOTTOM);\n\n  info->w = info->widget_w - info->margin_l - info->margin_r;\n  info->h = info->widget_h - info->margin_t - info->margin_b;\n\n  return RET_OK;\n}\n\nstatic rows_t* rows_create(uint32_t capacity) {\n  uint32_t msize = sizeof(rows_t) + capacity * sizeof(row_info_t);\n  rows_t* rows = (rows_t*)TKMEM_ALLOC(msize);\n  uint32_t i = 0;\n  return_value_if_fail(rows != NULL, NULL);\n\n  memset(rows, 0x00, msize);\n  for (i = 0; i < capacity; i++) {\n    darray_init(&rows->row[i].info, 4, default_destroy, NULL);\n    darray_push(&rows->row[i].info, TKMEM_ZALLOC(line_info_t));\n    rows->row[i].line_num = 1;\n  }\n\n  rows->row_line = TKMEM_ZALLOCN(uint32_t, capacity);\n  rows->capacity = capacity;\n\n  return rows;\n}\n\nstatic line_info_t* line_find_by_offset(rows_t* rows, uint32_t offset) {\n  uint32_t i = 0;\n  return_value_if_fail(rows != NULL, NULL);\n\n  for (i = 0; i < rows->size; i++) {\n    uint32_t j = 0;\n    row_info_t* row = rows->row + i;\n    for (j = 0; j < row->line_num; j++) {\n      line_info_t* line = (line_info_t*)darray_get(&row->info, j);\n      if (line->offset == offset) {\n        return line;\n      }\n    }\n  }\n\n  return NULL;\n}\n\nstatic ret_t rows_destroy(rows_t* rows) {\n  uint32_t i = 0;\n  return_value_if_fail(rows != NULL, RET_BAD_PARAMS);\n\n  for (i = 0; i < rows->capacity; i++) {\n    darray_deinit(&rows->row[i].info);\n  }\n  TKMEM_FREE(rows->row_line);\n  TKMEM_FREE(rows);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_set_caret_pos(text_edit_impl_t* impl, uint32_t x, uint32_t y,\n                                     uint32_t font_size, uint32_t line_number) {\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  uint32_t caret_top = layout_info->margin_t + y;\n  uint32_t caret_bottom = layout_info->margin_t + y + font_size;\n  uint32_t caret_left = layout_info->margin_l + x;\n  uint32_t caret_right = layout_info->margin_l + x + 1;\n\n  uint32_t view_top = layout_info->oy + layout_info->margin_t;\n  uint32_t view_bottom = layout_info->oy + layout_info->margin_t + layout_info->h;\n  uint32_t view_left = layout_info->ox + layout_info->margin_l;\n  uint32_t view_right = layout_info->ox + layout_info->margin_l + layout_info->w;\n\n  impl->caret.x = x;\n  impl->caret.y = y;\n  impl->caret_line_index = line_number;\n\n  if (!impl->lock_scrollbar_value) {\n    if (view_top > caret_top) {\n      layout_info->oy = caret_top - layout_info->margin_t;\n    }\n\n    if (view_bottom < caret_bottom) {\n      layout_info->oy = caret_bottom - layout_info->h;\n    }\n\n    if (view_left > caret_left) {\n      layout_info->ox = caret_left - layout_info->margin_l;\n    }\n\n    if (view_right < caret_right || (view_left > caret_left + layout_info->w)) {\n      layout_info->ox = caret_right - layout_info->w - layout_info->margin_l;\n    }\n  }\n\n  if (layout_info->ox < 0) {\n    layout_info->ox = 0;\n  }\n\n  if (impl->wrap_word) {\n    layout_info->ox = 0;\n  }\n\n  if (impl->single_line) {\n    layout_info->oy = 0;\n  }\n\n  return RET_OK;\n}\n\nstatic uint32_t text_edit_measure_text_on_canvas(text_edit_t* text_edit, wchar_t* str,\n                                                 wchar_t mask_char, uint32_t size, canvas_t* c) {\n  uint32_t i = 0;\n  uint32_t w = 0;\n  DECL_IMPL(text_edit);\n\n  for (i = 0; i < size; i++) {\n    bool_t preedit = impl->preedit && i < impl->state.cursor &&\n                     i >= (impl->state.cursor - impl->preedit_chars_nr);\n    wchar_t chr = (mask_char && !preedit) ? mask_char : str[i];\n\n    w += canvas_measure_text(c, &chr, 1) + CHAR_SPACING;\n  }\n\n  return w;\n}\n\nstatic uint32_t text_edit_measure_text(text_edit_t* text_edit, wchar_t* str, wchar_t mask_char,\n                                       uint32_t size) {\n  return text_edit_measure_text_on_canvas(text_edit, str, mask_char, size, GET_CANVAS(text_edit));\n}\n\nstatic row_info_t* text_edit_single_line_layout_line(text_edit_t* text_edit, uint32_t row_num,\n                                                     uint32_t line_index, uint32_t offset) {\n  uint32_t y = 0;\n  uint32_t caret_x = 0;\n  uint32_t view_left = 0;\n  uint32_t caret_left = 0;\n  DECL_IMPL(text_edit);\n  canvas_t* c = GET_CANVAS(text_edit);\n  wstr_t* text = &(text_edit->widget->text);\n  STB_TexteditState* state = &(impl->state);\n  row_info_t* row = impl->rows->row + row_num;\n  wchar_t mask_char = impl->mask ? impl->mask_char : 0;\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  align_h_t align_h = widget_get_text_align_h(text_edit->widget);\n  uint32_t text_w = text_edit_measure_text(text_edit, text->str, mask_char, text->size);\n  uint32_t caret_text_w = text_edit_measure_text(text_edit, text->str, mask_char, state->cursor);\n  line_info_t* line = (line_info_t*)darray_head(&row->info);\n\n  assert(offset == 0 && row_num == 0);\n\n  memset(row, 0x00, sizeof(row_info_t) - sizeof(darray_t));\n\n  row->line_num = 1;\n  line->offset = 0;\n  line->text_w = text_w;\n  line->length = text->size;\n  row->length = line->length;\n  line->x = text_edit_calc_x(text_edit, line);\n  layout_info->virtual_h = tk_max(y, layout_info->widget_h);\n\n  caret_x = caret_text_w;\n  caret_left = layout_info->margin_l + caret_x;\n  view_left = layout_info->ox + layout_info->margin_l;\n  if ((text_w < layout_info->w) ||\n      (view_left + c->font_size >= caret_left && state->cursor == text->size)) {\n    layout_info->ox = 0;\n    if (align_h == ALIGN_H_RIGHT) {\n      caret_x = layout_info->w - (text_w - caret_text_w);\n    } else if (align_h == ALIGN_H_CENTER) {\n      caret_x = (layout_info->w - text_w) / 2 + caret_text_w;\n    }\n  }\n  text_edit_set_caret_pos(impl, caret_x, y, c->font_size, line_index);\n\n  return row;\n}\n\nstatic row_info_t* text_edit_multi_line_layout_line(text_edit_t* text_edit, uint32_t row_num,\n                                                    uint32_t line_index, uint32_t offset) {\n  uint32_t i = 0;\n  uint32_t x = 0;\n  DECL_IMPL(text_edit);\n  wchar_t last_char = 0;\n  point_t caret = {-1, -1};\n  canvas_t* c = GET_CANVAS(text_edit);\n  wstr_t* text = &(text_edit->widget->text);\n  STB_TexteditState* state = &(impl->state);\n  row_info_t* row = impl->rows->row + row_num;\n  uint32_t line_height = impl->line_height;\n  uint32_t y = line_index * line_height;\n  uint32_t offset0 = offset;\n  uint32_t last_breakable_i = 0;\n  uint32_t last_breakable_x = 0;\n  line_info_t* last_line = NULL;\n  text_layout_info_t* layout_info = &(impl->layout_info);\n\n  memset(row, 0x00, sizeof(row_info_t) - sizeof(darray_t));\n  row->line_num = 1;\n\n  for (i = offset; i < text->size; i++) {\n    wchar_t* p = text->str + i;\n    break_type_t word_break = LINE_BREAK_NO;\n    break_type_t line_break = LINE_BREAK_NO;\n    uint32_t char_w = canvas_measure_text(c, p, 1) + CHAR_SPACING;\n\n    if (i == state->cursor) {\n      caret.x = x;\n      caret.y = y;\n    }\n\n    last_char = *p;\n    line_break = line_break_check(*p, p[1]);\n    if (line_break == LINE_BREAK_MUST) {\n      i++;\n      break;\n    }\n\n    if (impl->wrap_word) {\n      if ((x + char_w) > layout_info->w) {\n        if (last_breakable_x > 0) {\n          i = last_breakable_i + 1;\n          x = last_breakable_x;\n          last_breakable_x = 0;\n        }\n        if (i == offset) {\n          i++;\n        }\n\n        last_line = (line_info_t*)darray_get(&row->info, row->line_num - 1);\n        memset(last_line, 0x00, sizeof(line_info_t));\n        last_line->text_w = x;\n        last_line->offset = offset;\n        last_line->length = i - offset;\n\n        row->line_num++;\n        if (row->info.size < row->line_num) {\n          darray_push(&row->info, TKMEM_ZALLOC(line_info_t));\n        }\n\n        p = text->str + i;\n        char_w = canvas_measure_text(c, p, 1) + CHAR_SPACING;\n\n        x = char_w;\n        y += line_height;\n        offset = i;\n        line_index++;\n        if (state->cursor == i) {\n          caret.x = 0;\n          caret.y = y;\n        }\n        continue;\n      }\n\n      x += char_w;\n      word_break = word_break_check(*p, p[1]);\n      if (word_break == LINE_BREAK_ALLOW && line_break == LINE_BREAK_ALLOW) {\n        last_breakable_x = x;\n        last_breakable_i = i;\n      }\n    } else {\n      x += char_w;\n    }\n  }\n\n  while (row->info.size > row->line_num) {\n    row->info.destroy(darray_pop(&row->info));\n  }\n\n  if (last_char == STB_TEXTEDIT_NEWLINE) {\n    impl->last_row_number = row_num + 1;\n    impl->last_line_number = line_index + 1;\n  } else {\n    impl->last_row_number = row_num;\n    impl->last_line_number = line_index;\n  }\n\n  if (i == state->cursor && state->cursor == text->size) {\n    if (last_char == STB_TEXTEDIT_NEWLINE) {\n      caret.x = 0;\n      caret.y = y + line_height;\n    } else {\n      caret.x = x;\n      caret.y = y;\n    }\n  }\n  if (caret.x >= 0 && caret.y >= 0) {\n    /* 计算好了再统一修改光标坐标，以免多次修改导致滚动条的位置突变 */\n    text_edit_set_caret_pos(impl, caret.x, caret.y, c->font_size, line_index);\n  }\n\n  last_line = (line_info_t*)darray_get(&row->info, row->line_num - 1);\n  memset(last_line, 0x00, sizeof(line_info_t));\n  last_line->text_w = x;\n  last_line->offset = offset;\n  last_line->length = i - offset;\n\n  row->length = i - offset0;\n  layout_info->virtual_h = tk_max(y + line_height, layout_info->widget_h);\n\n  return row;\n}\n\nstatic ret_t text_edit_fix_oy(text_edit_impl_t* impl) {\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  uint32_t total_line_height = (impl->last_line_number + 1) * impl->line_height;\n  uint32_t max_oy = (total_line_height > layout_info->h) ? total_line_height - layout_info->h : 0;\n\n  layout_info->oy = tk_min(layout_info->oy, max_oy);\n\n  return RET_OK;\n}\n\nstatic row_info_t* text_edit_layout_line(text_edit_t* text_edit, uint32_t row_num,\n                                         uint32_t line_index, uint32_t offset) {\n  DECL_IMPL(text_edit);\n  if (impl->single_line) {\n    return text_edit_single_line_layout_line(text_edit, row_num, line_index, offset);\n  } else {\n    return text_edit_multi_line_layout_line(text_edit, row_num, line_index, offset);\n  }\n}\n\nstatic ret_t text_edit_layout_impl(text_edit_t* text_edit) {\n  uint32_t i = 0;\n  uint32_t offset = 0;\n  DECL_IMPL(text_edit);\n  row_info_t* iter = NULL;\n  canvas_t* c = GET_CANVAS(text_edit);\n  uint32_t max_rows = impl->rows->capacity;\n  wstr_t* text = &(text_edit->widget->text);\n  uint32_t size = text_edit->widget->text.size;\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  uint32_t char_w = 0;\n  uint32_t line_index = 0;\n  impl->caret.x = 0;\n  impl->caret.y = 0;\n  impl->rows->size = 0;\n\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  widget_prepare_text_style(text_edit->widget, c);\n  impl->line_height = c->font_size * FONT_BASELINE;\n  widget_get_text_layout_info(text_edit->widget, layout_info);\n  char_w = canvas_measure_text(c, text->str, 1) + CHAR_SPACING;\n\n  if (layout_info->w < char_w) {\n    return RET_OK;\n  }\n\n  while ((offset < size || size == 0) && i < max_rows) {\n    iter = text_edit_layout_line(text_edit, i, line_index, offset);\n    if (iter == NULL || iter->length == 0) {\n      break;\n    }\n    line_index += iter->line_num;\n    offset += iter->length;\n    i++;\n  }\n\n  if (offset < size) {\n    text->size = offset;\n    text->str[offset] = L'\\0';\n  }\n\n  impl->rows->size = i;\n\n  text_edit_fix_oy(impl);\n\n  text_edit_notify(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_layout(text_edit_t* text_edit) {\n  if (text_edit == NULL || GET_CANVAS(text_edit) == NULL || text_edit->widget == NULL ||\n      text_edit->widget->initializing || text_edit->widget->loading) {\n    return RET_BAD_PARAMS;\n  }\n\n  return text_edit_layout_impl(text_edit);\n}\n\nstatic void text_edit_layout_for_stb(StbTexteditRow* row, STB_TEXTEDIT_STRING* str, int offset) {\n  DECL_IMPL(str);\n  canvas_t* c = GET_CANVAS(str);\n  if (c == NULL) return;\n  uint32_t font_size = c->font_size;\n  line_info_t* info = line_find_by_offset(impl->rows, offset);\n\n  if (info != NULL) {\n    row->x0 = info->x;\n    row->x1 = info->x + info->text_w;\n    row->num_chars = info->length;\n  } else {\n    row->x0 = 0;\n    row->x1 = 0;\n    row->num_chars = 1;\n  }\n\n  row->ymin = 0;\n  row->ymax = font_size;\n  row->baseline_y_delta = impl->line_height;\n\n  return;\n}\n\nstatic ret_t text_edit_paint_caret(text_edit_t* text_edit, canvas_t* c) {\n  DECL_IMPL(text_edit);\n  widget_t* widget = text_edit->widget;\n  style_t* style = widget->astyle;\n  color_t black = color_init(0, 0, 0, 0xff);\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  color_t caret_color = style_get_color(style, STYLE_ID_TEXT_COLOR, black);\n  uint32_t x = layout_info->margin_l + impl->caret.x - layout_info->ox;\n  uint32_t y = layout_info->margin_t + impl->caret.y - layout_info->oy;\n\n  if (impl->single_line) {\n    y += (layout_info->h - c->font_size) / 2;\n  }\n\n  canvas_set_stroke_color(c, caret_color);\n  canvas_draw_vline(c, x, y, c->font_size);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_paint_tips_mlines_text(text_edit_t* text_edit, canvas_t* c,\n                                              line_parser_t* p) {\n  int32_t y = 0;\n  int32_t w = 0;\n  int32_t font_size = 0;\n  int32_t line_height = 0;\n  DECL_IMPL(text_edit);\n  text_layout_info_t* layout_info = 0;\n  return_value_if_fail(text_edit != NULL && text_edit->widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  font_size = c->font_size;\n  layout_info = &(impl->layout_info);\n  line_height = font_size + style_get_int(text_edit->widget->astyle, STYLE_ID_SPACER, 2);\n\n  w = layout_info->w;\n  y = layout_info->margin_t;\n  while (line_parser_next(p) == RET_OK) {\n    uint32_t size = 0;\n    rect_t r = rect_init(layout_info->margin_l, y, w, font_size);\n\n    if ((y + font_size) > layout_info->h) {\n      break;\n    }\n\n    for (size = 0; size < p->line_size; size++) {\n      if (CHAR_IS_LINE_BREAK(p->line[size])) {\n        break;\n      }\n    }\n    canvas_draw_text_in_rect(c, p->line, size, &r);\n\n    y += line_height;\n  }\n  return RET_OK;\n}\n\nstatic ret_t text_edit_paint_tips_text(text_edit_t* text_edit, canvas_t* c) {\n  DECL_IMPL(text_edit);\n  wstr_t* text = &(impl->tips);\n  text_layout_info_t* layout_info = &(impl->layout_info);\n\n  if (text->size > 0) {\n    if (impl->is_mlines) {\n      line_parser_t p;\n      line_parser_init(&p, c, (const wchar_t*)(text->str), text->size, c->font_size, layout_info->w,\n                       TRUE, TRUE);\n      if (p.total_lines > 1) {\n        text_edit_paint_tips_mlines_text(text_edit, c, &p);\n      } else {\n        align_h_t align_h = c->text_align_h;\n        align_v_t align_v = c->text_align_v;\n        rect_t r =\n            rect_init(layout_info->margin_l, layout_info->margin_t, layout_info->w, layout_info->h);\n        canvas_set_text_align(c, align_h, ALIGN_V_TOP);\n        canvas_draw_text_in_rect(c, text->str, text->size, &r);\n        canvas_set_text_align(c, align_h, align_v);\n      }\n      line_parser_deinit(&p);\n    } else {\n      rect_t r =\n          rect_init(layout_info->margin_l, layout_info->margin_t, layout_info->w, layout_info->h);\n      canvas_draw_text_in_rect(c, text->str, text->size, &r);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic int32_t text_edit_calc_x_on_canvas(text_edit_t* text_edit, line_info_t* iter, canvas_t* c) {\n  DECL_IMPL(text_edit);\n  widget_t* widget = text_edit->widget;\n  wstr_t* text = &(widget->text);\n  wchar_t chr = impl->mask ? impl->mask_char : 0;\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  align_h_t align_h = widget_get_text_align_h(text_edit->widget);\n\n  uint32_t row_width =\n      text_edit_measure_text_on_canvas(text_edit, text->str + iter->offset, chr, iter->length, c);\n  if (row_width < layout_info->w) {\n    switch (align_h) {\n      case ALIGN_H_CENTER: {\n        return (layout_info->w - row_width) / 2;\n      }\n      case ALIGN_H_RIGHT: {\n        return (layout_info->w - row_width);\n      }\n      default: {\n        break;\n      }\n    }\n  }\n\n  return 0;\n}\n\nstatic int32_t text_edit_calc_x(text_edit_t* text_edit, line_info_t* iter) {\n  return text_edit_calc_x_on_canvas(text_edit, iter, GET_CANVAS(text_edit));\n}\n\nstatic ret_t text_edit_paint_line(text_edit_t* text_edit, canvas_t* c, line_info_t* iter,\n                                  uint32_t y) {\n  bidi_t b;\n  uint32_t x = 0;\n  uint32_t k = 0;\n  widget_t* widget = text_edit->widget;\n  const char* bidi_type = widget_get_prop_str(widget, WIDGET_PROP_BIDI, NULL);\n  DECL_IMPL(text_edit);\n  wstr_t* text = &(widget->text);\n  style_t* style = widget->astyle;\n  STB_TexteditState* state = &(impl->state);\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  uint32_t view_left = layout_info->ox + layout_info->margin_l;\n  uint32_t view_right = layout_info->ox + layout_info->margin_l + layout_info->w;\n\n  color_t black = color_init(0, 0, 0, 0xff);\n  color_t white = color_init(0xf0, 0xf0, 0xf0, 0xff);\n\n  uint32_t select_start = tk_min(state->select_start, state->select_end);\n  uint32_t select_end = tk_max(state->select_start, state->select_end);\n\n  if (impl->single_line) {\n    x = layout_info->margin_l + text_edit_calc_x_on_canvas(text_edit, iter, c);\n  } else {\n    x = layout_info->margin_l;\n  }\n\n  bidi_init(&b, FALSE, FALSE, bidi_type_from_name(bidi_type));\n  ENSURE(bidi_log2vis(&b, text->str + iter->offset, iter->length) == RET_OK);\n\n  for (k = 0; k < iter->length; k++) {\n    uint32_t offset = iter->offset + k;\n    uint32_t cursor = state->cursor;\n    bool_t selected = offset >= select_start && offset < select_end;\n    bool_t preedit =\n        impl->preedit && offset < cursor && offset >= (cursor - impl->preedit_chars_nr);\n    wchar_t chr = (impl->mask && !preedit) ? impl->mask_char : b.vis_str[k];\n    uint32_t char_w = canvas_measure_text(c, &chr, 1);\n\n    if ((x + char_w) < view_left) {\n      x += char_w + CHAR_SPACING;\n      continue;\n    }\n\n    if (x > view_right) {\n      break;\n    }\n\n    if (chr != STB_TEXTEDIT_NEWLINE) {\n      xy_t rx = x - layout_info->ox;\n      xy_t ry = y - layout_info->oy;\n\n      if (selected || preedit) {\n        color_t select_bg_color = style_get_color(style, STYLE_ID_SELECTED_BG_COLOR, white);\n        color_t select_text_color = style_get_color(style, STYLE_ID_SELECTED_TEXT_COLOR, black);\n\n        canvas_set_fill_color(c, select_bg_color);\n        canvas_fill_rect(c, rx, ry, char_w + CHAR_SPACING, c->font_size);\n\n        canvas_set_text_color(c, select_text_color);\n      } else {\n        color_t text_color = style_get_color(style, STYLE_ID_TEXT_COLOR, black);\n        canvas_set_text_color(c, text_color);\n      }\n\n      /*FIXME: 密码编辑时，*字符本身偏高，看起来不像居中。但是无法拿到字模信息，只好手工修正一下。*/\n      if (impl->mask && !preedit && impl->mask_char == '*') {\n        int32_t oy = c->font_size / 6;\n        canvas_draw_text(c, &chr, 1, rx, ry + oy);\n      } else {\n        canvas_draw_text(c, &chr, 1, rx, ry);\n      }\n\n      x += char_w + CHAR_SPACING;\n    }\n  }\n  bidi_deinit(&b);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_paint_real_text(text_edit_t* text_edit, canvas_t* c) {\n  DECL_IMPL(text_edit);\n  rows_t* rows = impl->rows;\n  uint32_t line_height = impl->line_height;\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  int32_t view_top = layout_info->oy + layout_info->margin_t;\n  int32_t view_bottom = layout_info->oy + layout_info->margin_t + layout_info->h;\n\n  uint32_t i = 0;\n  uint32_t k = 0;\n  for (i = 0; i < rows->size; i++) {\n    uint32_t j = 0;\n    row_info_t* row = rows->row + i;\n\n    for (j = 0; j < row->line_num; j++, k++) {\n      line_info_t* line = (line_info_t*)darray_get(&row->info, j);\n      int32_t y = 0;\n\n      if (impl->single_line) {\n        y = (layout_info->h - c->font_size) / 2 + layout_info->margin_t;\n\n      } else {\n        y = k * line_height + layout_info->margin_t;\n      }\n\n      if ((y + c->font_size) < view_top) {\n        continue;\n      }\n\n      if (y > view_bottom) {\n        break;\n      }\n\n      text_edit_paint_line(text_edit, c, line, y);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_paint_text(text_edit_t* text_edit, canvas_t* c) {\n  widget_t* widget = text_edit->widget;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->text.size > 0) {\n    return text_edit_paint_real_text(text_edit, c);\n  } else {\n    color_t trans =\n        style_get_color(widget->astyle, STYLE_ID_TEXT_COLOR, color_init(0x0, 0x0, 0x0, 0x0));\n    color_t tc = style_get_color(widget->astyle, STYLE_ID_TIPS_TEXT_COLOR, trans);\n    align_h_t align_h =\n        (align_h_t)style_get_int(widget->astyle, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_LEFT);\n    align_v_t align_v =\n        (align_v_t)style_get_int(widget->astyle, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    canvas_set_text_color(c, tc);\n    canvas_set_text_align(c, align_h, align_v);\n    return text_edit_paint_tips_text(text_edit, c);\n  }\n}\n\nstatic ret_t text_edit_do_paint(text_edit_t* text_edit, canvas_t* c) {\n  bool_t is_notify = FALSE;\n  uint32_t new_line_height = 0;\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL && c != NULL, RET_BAD_PARAMS);\n\n  widget_prepare_text_style(text_edit->widget, c);\n  widget_get_text_layout_info(text_edit->widget, &(impl->layout_info));\n\n  new_line_height = c->font_size * FONT_BASELINE;\n  is_notify = impl->line_height != new_line_height;\n  impl->line_height = new_line_height;\n\n  if (text_edit_paint_text(text_edit, c) == RET_OK) {\n    DECL_IMPL(text_edit);\n    STB_TexteditState* state = &(impl->state);\n\n    if (state->select_start == state->select_end && impl->caret_visible) {\n      text_edit_paint_caret(text_edit, c);\n    }\n  }\n\n  if (is_notify) {\n    text_edit_layout(text_edit);\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_paint(text_edit_t* text_edit, canvas_t* c) {\n  rect_t save_r;\n  rect_t clip_r;\n  rect_t edit_r;\n  DECL_IMPL(text_edit);\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  style_t* style = text_edit->widget->astyle;\n\n  if (impl->is_first_time_layout) {\n    text_edit_layout(text_edit);\n    impl->is_first_time_layout = FALSE;\n\n    impl->font_size = style_get_int(style, STYLE_ID_FONT_SIZE, TK_DEFAULT_FONT_SIZE);\n    impl->font_name = system_info_fix_font_name(style_get_str(style, STYLE_ID_FONT_NAME, NULL));\n  } else {\n    if (text_edit_is_need_layout(text_edit)) {\n      text_edit_layout(text_edit);\n    }\n  }\n\n  canvas_get_clip_rect(c, &save_r);\n\n  edit_r = rect_init(c->ox + layout_info->margin_l, c->oy + layout_info->margin_t, layout_info->w,\n                     layout_info->h);\n  clip_r = rect_intersect(&save_r, &edit_r);\n\n  canvas_save(c);\n  canvas_set_clip_rect(c, &clip_r);\n  text_edit_do_paint(text_edit, c);\n  canvas_restore(c);\n\n  canvas_set_clip_rect(c, &save_r);\n\n  return RET_OK;\n}\n\nstatic int text_edit_remove(STB_TEXTEDIT_STRING* str, int pos, int num) {\n  wstr_t* text = &(str->widget->text);\n  wstr_remove(text, pos, num);\n\n  return TRUE;\n}\n\nstatic int text_edit_get_char_width(STB_TEXTEDIT_STRING* str, int pos, int offset) {\n  wstr_t* text = &(str->widget->text);\n  wchar_t chr = text->str[pos + offset];\n\n  if (chr == STB_TEXTEDIT_NEWLINE) {\n    return STB_TEXTEDIT_GETWIDTH_NEWLINE;\n  } else {\n    return canvas_measure_text(GET_CANVAS(str), &chr, 1) + CHAR_SPACING;\n  }\n}\n\nstatic int text_edit_insert(STB_TEXTEDIT_STRING* str, int pos, STB_TEXTEDIT_CHARTYPE* newtext,\n                            int num) {\n  bool_t ret = FALSE;\n  wstr_t* text = &(str->widget->text);\n  DECL_IMPL(str);\n  uint32_t line_break_num = impl->rows->capacity > impl->last_row_number\n                                ? impl->rows->capacity - impl->last_row_number\n                                : 0;\n  uint32_t i = 0;\n\n  for (i = 0; i < num; i++) {\n    if (i + 1 < num && TWINS_WCHAR_IS_LINE_BREAK(newtext[i], newtext[i + 1])) {\n      line_break_num--;\n      i++;\n    } else if (WCHAR_IS_LINE_BREAK(newtext[i])) {\n      line_break_num--;\n    }\n    if (line_break_num == 0) {\n      num = i;\n      break;\n    }\n  }\n\n  if (impl->max_chars > 0) {\n    uint32_t surplus_char = impl->max_chars > text->size ? impl->max_chars - text->size : 0;\n    num = tk_min(num, surplus_char);\n  }\n\n  if (num > 0) {\n    wstr_insert(text, pos, newtext, num);\n    ret = TRUE;\n  }\n\n  return (int)ret;\n}\n\n#define KEYDOWN_BIT 0x80000000\n#define STB_TEXTEDIT_STRINGLEN(str) ((str)->widget->text.size)\n#define STB_TEXTEDIT_LAYOUTROW text_edit_layout_for_stb\n#define STB_TEXTEDIT_GETWIDTH(str, n, i) text_edit_get_char_width(str, n, i)\n#define STB_TEXTEDIT_KEYTOTEXT(key) (((key)&KEYDOWN_BIT) ? 0 : ((uint16_t)key))\n#define STB_TEXTEDIT_GETCHAR(str, i) (((str)->widget->text).str[i])\n#define STB_TEXTEDIT_IS_SPACE(ch) iswspace(ch)\n#define STB_TEXTEDIT_DELETECHARS text_edit_remove\n#define STB_TEXTEDIT_INSERTCHARS text_edit_insert\n\n#define STB_TEXTEDIT_K_SHIFT 0x40000000\n#define STB_TEXTEDIT_K_CONTROL 0x20000000\n#define STB_TEXTEDIT_K_LEFT (KEYDOWN_BIT | 1)\n#define STB_TEXTEDIT_K_RIGHT (KEYDOWN_BIT | 2)  // VK_RIGHT\n#define STB_TEXTEDIT_K_UP (KEYDOWN_BIT | 3)  // VK_UP\n#define STB_TEXTEDIT_K_DOWN (KEYDOWN_BIT | 4)  // VK_DOWN\n#define STB_TEXTEDIT_K_LINESTART (KEYDOWN_BIT | 5)  // VK_HOME\n#define STB_TEXTEDIT_K_LINEEND (KEYDOWN_BIT | 6)  // VK_END\n#define STB_TEXTEDIT_K_TEXTSTART (STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_CONTROL)\n#define STB_TEXTEDIT_K_TEXTEND (STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_CONTROL)\n#define STB_TEXTEDIT_K_DELETE (KEYDOWN_BIT | 7)  // VK_DELETE\n#define STB_TEXTEDIT_K_BACKSPACE (KEYDOWN_BIT | 8)  // VK_BACKSPACE\n#define STB_TEXTEDIT_K_UNDO (KEYDOWN_BIT | STB_TEXTEDIT_K_CONTROL | 'z')\n#define STB_TEXTEDIT_K_REDO (KEYDOWN_BIT | STB_TEXTEDIT_K_CONTROL | 'y')\n#define STB_TEXTEDIT_K_INSERT (KEYDOWN_BIT | 9)  // VK_INSERT\n#define STB_TEXTEDIT_K_WORDLEFT (STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_CONTROL)\n#define STB_TEXTEDIT_K_WORDRIGHT (STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_CONTROL)\n#define STB_TEXTEDIT_K_PGUP (KEYDOWN_BIT | 10)  // VK_PGUP -- not implemented\n#define STB_TEXTEDIT_K_PGDOWN (KEYDOWN_BIT | 11)  // VK_PGDOWN -- not implemented\n\n#define STB_TEXTEDIT_IMPLEMENTATION 1\n\n#include \"stb/stb_textedit.h\"\n\ntext_edit_t* text_edit_create(widget_t* widget, bool_t single_line) {\n  text_edit_impl_t* impl = NULL;\n  return_value_if_fail(widget != NULL, NULL);\n\n  impl = TKMEM_ZALLOC(text_edit_impl_t);\n  return_value_if_fail(impl != NULL, NULL);\n\n  impl->is_first_time_layout = TRUE;\n  impl->wrap_word = !single_line;\n  impl->text_edit.widget = widget;\n  impl->single_line = single_line;\n\n  wstr_init(&(impl->tips), 0);\n  stb_textedit_initialize_state(&(impl->state), single_line);\n  if (!single_line) {\n    text_edit_set_max_rows((text_edit_t*)impl, 100);\n  } else {\n    text_edit_set_max_rows((text_edit_t*)impl, 1);\n  }\n\n  return (text_edit_t*)impl;\n}\n\nret_t text_edit_set_caret_visible(text_edit_t* text_edit, bool_t caret_visible) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit, RET_BAD_PARAMS);\n\n  impl->caret_visible = caret_visible;\n\n  return RET_OK;\n}\n\nret_t text_edit_invert_caret_visible(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit, RET_BAD_PARAMS);\n\n  impl->caret_visible = !impl->caret_visible;\n\n  return RET_OK;\n}\n\nret_t text_edit_set_max_rows(text_edit_t* text_edit, uint32_t max_rows) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL && max_rows >= 1, RET_BAD_PARAMS);\n\n  if (impl->rows != NULL) {\n    rows_destroy(impl->rows);\n    impl->rows = NULL;\n  }\n\n  if (impl->rows == NULL) {\n    impl->rows = rows_create(max_rows);\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_set_max_chars(text_edit_t* text_edit, uint32_t max_chars) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->max_chars = max_chars;\n\n  return RET_OK;\n}\n\nuint32_t text_edit_get_height(text_edit_t* text_edit, uint32_t offset) {\n  uint32_t i = 0;\n  uint32_t k = 0;\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, 0);\n\n  for (i = 0; i < impl->rows->size; i++) {\n    uint32_t j = 0;\n    row_info_t* row = impl->rows->row + i;\n    for (j = 0; j < row->line_num; j++, k++) {\n      line_info_t* line = (line_info_t*)darray_get(&row->info, j);\n      if (offset < line->offset + line->length) {\n        return impl->line_height * k;\n      }\n    }\n  }\n\n  return impl->line_height * ((k > 1) ? k - 1 : 0);\n}\n\nconst uint32_t* text_edit_get_lines_of_each_row(text_edit_t* text_edit) {\n  uint32_t* lines_of_each_row = NULL;\n  uint32_t size = 0;\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL && impl != NULL && impl->rows != NULL, NULL);\n\n  size = impl->rows->capacity;\n\n  if (size) {\n    uint32_t i = 0;\n    lines_of_each_row = impl->rows->row_line;\n    memset(lines_of_each_row, 0x00, sizeof(uint32_t) * size);\n\n    for (i = 0; i < impl->rows->size; i++) {\n      lines_of_each_row[i] = impl->rows->row[i].line_num;\n    }\n  }\n\n  return lines_of_each_row;\n}\n\nstatic uint32_t text_edit_get_line_break_offset(text_edit_t* text_edit, uint32_t num) {\n  uint32_t offset = 0;\n  uint32_t i = 0;\n  wstr_t* text = NULL;\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL && text_edit->widget != NULL, -1);\n  return_value_if_fail(0 < num && num < impl->rows->capacity, -1);\n\n  if (num >= impl->rows->size) {\n    return -1;\n  }\n\n  text = &text_edit->widget->text;\n\n  for (i = 0; i < num; i++) {\n    offset += impl->rows->row[i].length;\n  }\n\n  if (offset >= 2 && TWINS_WCHAR_IS_LINE_BREAK(text->str[offset - 2], text->str[offset - 1])) {\n    offset -= 2;\n  } else if (offset >= 1 && WCHAR_IS_LINE_BREAK(text->str[offset - 1])) {\n    offset--;\n  } else {\n    offset = -1;\n  }\n\n  return offset;\n}\n\nret_t text_edit_set_canvas(text_edit_t* text_edit, canvas_t* canvas) {\n  return_value_if_fail(text_edit != NULL && canvas != NULL, RET_BAD_PARAMS);\n\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nstatic point_t text_edit_normalize_point(text_edit_t* text_edit, xy_t x, xy_t y) {\n  DECL_IMPL(text_edit);\n  point_t point = {x, y};\n  text_layout_info_t* layout_info = &(impl->layout_info);\n\n  widget_to_local(text_edit->widget, &point);\n\n  point.x = point.x - layout_info->margin_l + layout_info->ox;\n  point.y = point.y - layout_info->margin_t + layout_info->oy;\n\n  return point;\n}\n\nstatic bool_t text_edit_is_need_layout(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  style_t* style = text_edit->widget->astyle;\n  uint16_t font_size = style_get_int(style, STYLE_ID_FONT_SIZE, TK_DEFAULT_FONT_SIZE);\n  const char* font_name = system_info_fix_font_name(style_get_str(style, STYLE_ID_FONT_NAME, NULL));\n\n  if (!tk_str_eq(font_name, impl->font_name) || font_size != impl->font_size) {\n    impl->font_name = font_name;\n    impl->font_size = font_size;\n    return TRUE;\n  }\n  return FALSE;\n}\n\nstatic ret_t text_edit_update_caret_pos(text_edit_t* text_edit) {\n  uint32_t i = 0;\n  uint32_t j = 0;\n  uint32_t k = 0;\n  uint32_t y = 0;\n  DECL_IMPL(text_edit);\n  uint32_t line_index = 0;\n  rows_t* rows = impl->rows;\n  bool_t is_setting = FALSE;\n  canvas_t* c = GET_CANVAS(text_edit);\n  uint32_t font_size = impl->font_size;\n  uint32_t line_height = impl->line_height;\n  wstr_t* text = &(text_edit->widget->text);\n\n  canvas_set_font(c, impl->font_name, font_size);\n\n  for (i = 0; i < rows->size; i++) {\n    row_info_t* row = rows->row + i;\n    for (j = 0; j < row->line_num; j++, y += line_height, line_index++) {\n      line_info_t* line = (line_info_t*)darray_get(&row->info, j);\n      uint32_t line_offset_begin = line->offset;\n      uint32_t line_offset_end = line->offset + line->length;\n      if ((line_offset_begin <= impl->state.cursor && impl->state.cursor < line_offset_end) ||\n          (j + 1 == row->line_num && impl->state.cursor == line_offset_end)) {\n        uint32_t x = line->x;\n        wchar_t last_char = 0;\n        wchar_t* p = text->str + line_offset_begin;\n        uint32_t offset = impl->state.cursor - line_offset_begin;\n        for (k = 0; k < line->length; k++, p++) {\n          if (offset == k) {\n            break;\n          }\n          x += (canvas_measure_text(c, p, 1) + CHAR_SPACING);\n          last_char = *p;\n        }\n        is_setting = TRUE;\n        if (last_char == STB_TEXTEDIT_NEWLINE) {\n          text_edit_set_caret_pos(impl, 0, y + line_height, c->font_size, line_index);\n        } else {\n          text_edit_set_caret_pos(impl, x, y, c->font_size, line_index);\n        }\n        break;\n      }\n    }\n    if (is_setting) {\n      break;\n    }\n  }\n  text_edit_fix_oy(impl);\n  text_edit_notify(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_click(text_edit_t* text_edit, xy_t x, xy_t y) {\n  point_t point;\n  DECL_IMPL(text_edit);\n  return_value_if_fail(impl != NULL, RET_BAD_PARAMS);\n\n  widget_prepare_text_style(text_edit->widget, GET_CANVAS(text_edit));\n  point = text_edit_normalize_point(text_edit, x, y);\n  stb_textedit_click(text_edit, &(impl->state), point.x, point.y);\n\n  if (impl->single_line || text_edit_is_need_layout(text_edit)) {\n    text_edit_layout(text_edit);\n  } else {\n    text_edit_update_caret_pos(text_edit);\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_drag(text_edit_t* text_edit, xy_t x, xy_t y) {\n  point_t point;\n  DECL_IMPL(text_edit);\n  return_value_if_fail(impl != NULL, RET_BAD_PARAMS);\n\n  widget_prepare_text_style(text_edit->widget, GET_CANVAS(text_edit));\n  point = text_edit_normalize_point(text_edit, x, y);\n  stb_textedit_drag(text_edit, &(impl->state), point.x, point.y);\n\n  if (impl->single_line || text_edit_is_need_layout(text_edit)) {\n    text_edit_layout(text_edit);\n  } else {\n    text_edit_update_caret_pos(text_edit);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_paste_from_clip_board(text_edit_t* text_edit) {\n  value_t v;\n  wstr_t str;\n  const char* data = clip_board_get_text();\n  if (data != NULL) {\n    value_set_str(&v, data);\n    wstr_init(&str, 0);\n    wstr_from_value(&str, &v);\n    wstr_normalize_newline(&str, STB_TEXTEDIT_NEWLINE);\n    text_edit_paste(text_edit, str.str, str.size);\n    wstr_reset(&str);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_handle_shortcut(text_edit_t* text_edit, key_event_t* evt,\n                                       STB_TexteditState* state, wstr_t* text) {\n#ifdef MACOS\n  if (evt->cmd) {\n#else\n  if (evt->ctrl) {\n#endif\n    uint32_t key = evt->key;\n    char c = tolower(key);\n    if (c == 'z' || c == 'Z') {\n      stb_textedit_key(text_edit, state, STB_TEXTEDIT_K_UNDO);\n    } else if (c == 'y' || c == 'Y') {\n      stb_textedit_key(text_edit, state, STB_TEXTEDIT_K_REDO);\n    } else if (c == 'c' || c == 'C') {\n      text_edit_copy(text_edit);\n    } else if (c == 'x' || c == 'X') {\n      text_edit_cut(text_edit);\n    } else if (c == 'a' || c == 'A') {\n      state->select_start = 0;\n      state->select_end = text->size;\n    } else if (c == 'v' || c == 'V') {\n      text_edit_paste_from_clip_board(text_edit);\n    } else if (key > 128 || !tk_isprint(key)) {\n      return RET_FAIL;\n    }\n\n    text_edit_layout(text_edit);\n\n    return RET_OK;\n  }\n\n  return RET_FAIL;\n}\n\nret_t text_edit_key_up(text_edit_t* text_edit, key_event_t* evt) {\n  uint32_t key = 0;\n  ret_t ret = RET_OK;\n  widget_t* widget = NULL;\n  input_method_t* im = input_method();\n  return_value_if_fail(im != NULL, RET_FAIL);\n  return_value_if_fail(text_edit != NULL && text_edit->widget != NULL && evt != NULL, RET_FAIL);\n\n  key = evt->key;\n  widget = text_edit->widget;\n  if (key == TK_KEY_OPEN_INPUT_METHOD) {\n    input_method_request(im, widget);\n    ret = RET_STOP;\n  } else if (key == TK_KEY_CLOSE_INPUT_METHOD) {\n    input_method_request(im, NULL);\n    ret = RET_STOP;\n  } else if (key == TK_KEY_TOGGLE_INPUT_METHOD) {\n    if (im->widget == widget) {\n      input_method_request(im, NULL);\n    } else {\n      input_method_request(im, widget);\n    }\n    ret = RET_STOP;\n  }\n\n  return ret;\n}\n\nret_t text_edit_key_down(text_edit_t* text_edit, key_event_t* evt) {\n  uint32_t key = 0;\n  wstr_t* text = NULL;\n  DECL_IMPL(text_edit);\n  bool_t move_caret_pos = FALSE;\n  STB_TexteditState* state = NULL;\n  text_layout_info_t* layout_info = NULL;\n  return_value_if_fail(impl != NULL, RET_BAD_PARAMS);\n\n  key = evt->key;\n  state = &(impl->state);\n  text = &(text_edit->widget->text);\n  layout_info = &(impl->layout_info);\n\n  switch (key) {\n#ifdef WITH_SDL\n    case TK_KEY_KP_DIVIDE:\n    case TK_KEY_KP_MULTIPLY:\n    case TK_KEY_KP_MINUS:\n    case TK_KEY_KP_PLUS:\n    case TK_KEY_KP_PERIOD:\n    case TK_KEY_NUMLOCKCLEAR:\n    case TK_KEY_KP_0:\n    case TK_KEY_KP_1:\n    case TK_KEY_KP_2:\n    case TK_KEY_KP_3:\n    case TK_KEY_KP_4:\n    case TK_KEY_KP_5:\n    case TK_KEY_KP_6:\n    case TK_KEY_KP_7:\n    case TK_KEY_KP_8:\n    case TK_KEY_KP_9:\n      return RET_OK;\n    case TK_KEY_KP_ENTER:\n#endif\n    case TK_KEY_RETURN: {\n      key = STB_TEXTEDIT_NEWLINE;\n      break;\n    }\n    case TK_KEY_LEFT: {\n      move_caret_pos = TRUE;\n      key = STB_TEXTEDIT_K_LEFT;\n      break;\n    }\n    case TK_KEY_RIGHT: {\n      move_caret_pos = TRUE;\n      key = STB_TEXTEDIT_K_RIGHT;\n      break;\n    }\n    case TK_KEY_DOWN: {\n      move_caret_pos = TRUE;\n      key = STB_TEXTEDIT_K_DOWN;\n      break;\n    }\n    case TK_KEY_UP: {\n      move_caret_pos = TRUE;\n      key = STB_TEXTEDIT_K_UP;\n      break;\n    }\n    case TK_KEY_HOME: {\n      move_caret_pos = TRUE;\n      state->cursor = 0;\n      key = STB_TEXTEDIT_K_LINESTART;\n      break;\n    }\n    case TK_KEY_END: {\n      move_caret_pos = TRUE;\n      state->cursor = text->size;\n      key = STB_TEXTEDIT_K_LINEEND;\n      break;\n    }\n    case TK_KEY_DELETE: {\n      key = STB_TEXTEDIT_K_DELETE;\n      break;\n    }\n    case TK_KEY_BACKSPACE: {\n      key = STB_TEXTEDIT_K_BACKSPACE;\n      break;\n    }\n    case TK_KEY_INSERT: {\n      key = STB_TEXTEDIT_K_INSERT;\n      break;\n    }\n    case TK_KEY_PAGEDOWN: {\n      move_caret_pos = TRUE;\n      if (impl->single_line) {\n        key = STB_TEXTEDIT_K_LINEEND;\n      } else {\n        int32_t lines = layout_info->h / impl->line_height;\n        int32_t next_lines = impl->caret_line_index + lines;\n        int32_t next_y = next_lines * impl->line_height;\n        if (layout_info->virtual_h > next_y) {\n          while (lines-- > 0) {\n            stb_textedit_key(text_edit, state, STB_TEXTEDIT_K_DOWN);\n          }\n        } else {\n          state->cursor = text->size;\n          stb_textedit_key(text_edit, state, STB_TEXTEDIT_K_LINEEND);\n        }\n        goto layout;\n\n        return RET_OK;\n      }\n      break;\n    }\n    case TK_KEY_PAGEUP: {\n      move_caret_pos = TRUE;\n      if (impl->single_line) {\n        key = STB_TEXTEDIT_K_LINESTART;\n      } else {\n        int32_t lines = layout_info->h / impl->line_height;\n        int32_t next_lines = impl->caret_line_index - lines;\n\n        if (next_lines > 0) {\n          while (lines-- > 0) {\n            stb_textedit_key(text_edit, state, STB_TEXTEDIT_K_UP);\n          }\n        } else {\n          state->cursor = 0;\n          stb_textedit_key(text_edit, state, STB_TEXTEDIT_K_LINESTART);\n        }\n        goto layout;\n      }\n      break;\n    }\n    case TK_KEY_F1:\n    case TK_KEY_F2:\n    case TK_KEY_F3:\n    case TK_KEY_F4:\n    case TK_KEY_F5:\n    case TK_KEY_F6:\n    case TK_KEY_F7:\n    case TK_KEY_F8:\n    case TK_KEY_F9:\n    case TK_KEY_F10:\n    case TK_KEY_F11:\n    case TK_KEY_F12:\n    case TK_KEY_LSHIFT:\n    case TK_KEY_RSHIFT:\n    case TK_KEY_LCTRL:\n    case TK_KEY_RCTRL:\n    case TK_KEY_LALT:\n    case TK_KEY_RALT:\n    case TK_KEY_CAPSLOCK:\n    case TK_KEY_COMMAND:\n    case TK_KEY_MENU:\n    case TK_KEY_WHEEL: {\n      return RET_OK;\n    }\n    default: {\n      if (key < 128 && tk_isprint(key)) {\n        app_type_t app_type = system_info()->app_type;\n        if (app_type == APP_DESKTOP || app_type == APP_MOBILE) {\n          text_edit_handle_shortcut(text_edit, evt, state, text);\n          return RET_OK;\n        }\n      }\n      break;\n    }\n  }\n\n  if (text_edit_handle_shortcut(text_edit, evt, state, text) == RET_OK) {\n    return RET_OK;\n  }\n\n  if (evt->shift) {\n    key |= STB_TEXTEDIT_K_SHIFT;\n  }\n\n  stb_textedit_key(text_edit, state, key);\nlayout:\n  if (!impl->single_line && move_caret_pos && !text_edit_is_need_layout(text_edit)) {\n    text_edit_update_caret_pos(text_edit);\n  } else {\n    text_edit_layout(text_edit);\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_copy(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  wstr_t* text = NULL;\n  uint32_t select_end = 0;\n  uint32_t select_start = 0;\n  STB_TexteditState* state = NULL;\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  state = &(impl->state);\n  text = &(text_edit->widget->text);\n  select_start = tk_min(state->select_start, state->select_end);\n  select_end = tk_max(state->select_start, state->select_end);\n\n  if (select_end > select_start) {\n    str_t str;\n    wstr_t wstr;\n    wchar_t* start = text->str + select_start;\n    uint32_t size = select_end - select_start;\n\n    wstr_init(&wstr, size + 1);\n    wstr_append_with_len(&wstr, start, size);\n\n    str_init(&str, 0);\n    str_from_wstr(&str, wstr.str);\n    clip_board_set_text(str.str);\n\n    str_reset(&str);\n    wstr_reset(&wstr);\n  }\n\n  return RET_OK;\n}\n\nchar* text_edit_get_selected_text(text_edit_t* text_edit) {\n  uint32_t size = 0;\n  text_edit_state_t state = {0};\n  char* ret = NULL;\n  return_value_if_fail(text_edit != NULL, NULL);\n\n  text_edit_get_state(text_edit, &state);\n  size = state.select_end - state.select_start;\n\n  if (size > 0) {\n    ret = tk_utf8_dup_utf16(text_edit->widget->text.str + state.select_start, size);\n  }\n\n  return ret;\n}\n\nret_t text_edit_cut(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  if (text_edit_copy(text_edit) == RET_OK) {\n    stb_textedit_cut(text_edit, &(impl->state));\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_paste(text_edit_t* text_edit, const wchar_t* str, uint32_t size) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL && str != NULL, RET_BAD_PARAMS);\n\n  stb_textedit_paste(text_edit, &(impl->state), str, size);\n  if (impl->preedit) {\n    impl->preedit_chars_nr += size;\n  }\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_set_cursor(text_edit_t* text_edit, uint32_t cursor) {\n  wstr_t* text = NULL;\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  text = &(text_edit->widget->text);\n\n  if (cursor > text->size) {\n    cursor = text->size;\n  }\n\n  if (impl->state.cursor != cursor) {\n    impl->state.cursor = cursor;\n    text_edit_layout(text_edit);\n  }\n\n  return RET_OK;\n}\n\nuint32_t text_edit_get_cursor(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, 0);\n\n  return impl->state.cursor;\n}\n\nret_t text_edit_set_wrap_word(text_edit_t* text_edit, bool_t wrap_word) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->wrap_word = wrap_word;\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_set_overwrite(text_edit_t* text_edit, bool_t overwrite) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->overwrite = overwrite;\n  text_edit_notify(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_set_mask(text_edit_t* text_edit, bool_t mask) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  if (impl->mask != mask) {\n    impl->mask = mask;\n    text_edit_layout(text_edit);\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_set_tips(text_edit_t* text_edit, const char* tips, bool_t mlines) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->is_mlines = mlines;\n  wstr_set_utf8(&(impl->tips), tips);\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_set_mask_char(text_edit_t* text_edit, wchar_t mask_char) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->mask_char = mask_char;\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_set_select(text_edit_t* text_edit, uint32_t start, uint32_t end) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  if (start > end) {\n    uint32_t t = start;\n    start = end;\n    end = t;\n  }\n\n  impl->state.select_start = start;\n  impl->state.select_end = tk_min(end, text_edit->widget->text.size);\n\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_select_all(text_edit_t* text_edit) {\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  return text_edit_set_select(text_edit, 0, text_edit->widget->text.size);\n}\n\nret_t text_edit_unselect(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->state.select_end = impl->state.select_start;\n\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_get_state(text_edit_t* text_edit, text_edit_state_t* state) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL && state != NULL, RET_BAD_PARAMS);\n\n  memset(state, 0x00, sizeof(text_edit_state_t));\n\n  state->ox = impl->layout_info.ox;\n  state->oy = impl->layout_info.oy;\n  state->virtual_w = impl->layout_info.virtual_w;\n  state->virtual_h = impl->layout_info.virtual_h;\n  state->rows = impl->rows->size;\n  state->max_chars = impl->max_chars;\n  state->caret = impl->caret;\n  state->preedit = impl->preedit;\n  state->line_height = impl->line_height;\n\n  state->cursor = impl->state.cursor;\n  state->max_rows = impl->rows->capacity;\n  state->last_row_number = impl->last_row_number;\n  state->last_line_number = impl->last_line_number;\n\n  state->select_start = tk_min(impl->state.select_start, impl->state.select_end);\n  state->select_end = tk_max(impl->state.select_start, impl->state.select_end);\n\n  state->mask = impl->mask;\n  state->overwrite = impl->overwrite;\n  state->wrap_word = impl->wrap_word;\n  state->mask_char = impl->mask_char;\n  state->caret_visible = impl->caret_visible;\n  state->single_line = impl->single_line;\n\n  return RET_OK;\n}\n\nret_t text_edit_destroy(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  wstr_reset(&(impl->tips));\n  rows_destroy(impl->rows);\n  TKMEM_FREE(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_set_offset(text_edit_t* text_edit, int32_t ox, int32_t oy) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->layout_info.ox = ox;\n  impl->layout_info.oy = oy;\n  text_edit_notify(text_edit);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_notify(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  if (impl->on_state_changed != NULL) {\n    text_edit_state_t state = {0};\n    text_edit_get_state(text_edit, &state);\n    impl->on_state_changed(impl->on_state_changed_ctx, &state);\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_set_on_state_changed(text_edit_t* text_edit,\n                                     text_edit_on_state_changed_t on_state_changed, void* ctx) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->on_state_changed = on_state_changed;\n  impl->on_state_changed_ctx = ctx;\n\n  return RET_OK;\n}\n\nret_t text_edit_preedit(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->preedit = TRUE;\n  impl->preedit_chars_nr = 0;\n\n  return RET_OK;\n}\n\nret_t text_edit_preedit_confirm(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->preedit = FALSE;\n  impl->preedit_chars_nr = 0;\n\n  return RET_OK;\n}\n\nret_t text_edit_preedit_clear(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  if (impl->preedit_chars_nr > 0) {\n    text_edit_remove(text_edit, impl->state.cursor - impl->preedit_chars_nr,\n                     impl->preedit_chars_nr);\n    impl->state.cursor = impl->state.cursor - impl->preedit_chars_nr;\n    impl->preedit_chars_nr = 0;\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_preedit_abort(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->preedit = FALSE;\n  text_edit_preedit_clear(text_edit);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_insert_wtext_with_len(text_edit_t* text_edit, uint32_t offset,\n                                             const wchar_t* wtext, uint32_t len) {\n  ret_t ret = RET_FAIL;\n  uint32_t size = 0;\n  return_value_if_fail(text_edit != NULL && text_edit->widget != NULL && wtext != NULL,\n                       RET_BAD_PARAMS);\n\n  size = wcslen(wtext);\n  len = tk_min(len, size);\n  offset = tk_min(offset, text_edit->widget->text.size);\n\n  ret = !!text_edit_insert(text_edit, offset, (wchar_t*)wtext, len) ? RET_OK : RET_SKIP;\n\n  if (ret == RET_OK) {\n    if (offset + len != text_edit_get_cursor(text_edit)) {\n      text_edit_set_cursor(text_edit, offset + len);\n    } else {\n      text_edit_layout(text_edit);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t text_edit_insert_text_with_len(text_edit_t* text_edit, uint32_t offset,\n                                            const char* text, uint32_t len) {\n  ret_t ret = RET_FAIL;\n  wstr_t s = {0};\n  return_value_if_fail(text_edit != NULL && text_edit->widget != NULL && text != NULL,\n                       RET_BAD_PARAMS);\n\n  wstr_set_utf8(&s, text);\n  ret = text_edit_insert_wtext_with_len(text_edit, offset, s.str, len);\n  wstr_reset(&s);\n\n  return ret;\n}\n\nret_t text_edit_insert_text(text_edit_t* text_edit, uint32_t offset, const char* text) {\n  return text_edit_insert_text_with_len(text_edit, offset, text, tk_strlen(text));\n}\n\nstatic ret_t text_edit_overwrite_text_fix_select(text_edit_t* text_edit, uint32_t insert_offset,\n                                                 uint32_t insert_len, uint32_t remove_offset,\n                                                 uint32_t remove_len) {\n  DECL_IMPL(text_edit);\n  wstr_t* wstr = &text_edit->widget->text;\n  uint32_t select_start = impl->state.select_start;\n  uint32_t select_end = impl->state.select_end;\n\n  if (impl->state.select_start > insert_offset) {\n    select_start = tk_min(select_start + insert_len, wstr->size);\n  }\n  if (impl->state.select_end > insert_offset) {\n    select_end = tk_min(select_end + insert_len, wstr->size);\n  }\n\n  if (tk_max(impl->state.select_start, impl->state.select_end) > remove_offset &&\n      tk_min(impl->state.select_start, impl->state.select_end) < remove_len) {\n    select_start = select_end = 0;\n  } else {\n    if (impl->state.select_start > remove_offset) {\n      select_start -= remove_len;\n    }\n    if (impl->state.select_end > remove_offset) {\n      select_end -= remove_len;\n    }\n  }\n  impl->state.select_start = select_start;\n  impl->state.select_end = select_end;\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_overwrite_text_not_at_last_row(text_edit_t* text_edit, uint32_t* p_offset,\n                                                      const char* text, uint32_t len) {\n  DECL_IMPL(text_edit);\n  wstr_t* wstr = &text_edit->widget->text;\n  wstr_t s = {0};\n  /* 获取最后一个换行符的偏移位置 */\n  uint32_t last_row_line_break =\n      text_edit_get_line_break_offset(text_edit, impl->rows->capacity - 1);\n  uint32_t rm_len = 0;\n  uint32_t rm_index = 0;\n\n  if (last_row_line_break < wstr->size) {\n    rm_index = tk_max(*p_offset, last_row_line_break);\n    if (wstr->size > rm_index) {\n      rm_len = wstr->size - rm_index;\n      wstr_remove(wstr, rm_index, rm_len);\n    }\n  }\n\n  wstr_set_utf8_with_len(&s, text, len);\n  wstr_insert(wstr, *p_offset, s.str, s.size);\n  text_edit_overwrite_text_fix_select(text_edit, *p_offset, s.size, rm_index, rm_len);\n  wstr_reset(&s);\n\n  if (*p_offset + len != text_edit_get_cursor(text_edit)) {\n    text_edit_set_cursor(text_edit, *p_offset + len);\n  } else {\n    text_edit_layout(text_edit);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_overwrite_text_at_last_row(text_edit_t* text_edit, uint32_t* p_offset,\n                                                  const char* text, uint32_t len) {\n  DECL_IMPL(text_edit);\n  wstr_t* wstr = &text_edit->widget->text;\n  uint32_t line_break_num = impl->rows->capacity > impl->last_row_number\n                                ? impl->rows->capacity - impl->last_row_number\n                                : 0;\n  wstr_t s = {0};\n  uint32_t rm_len = 0;\n\n  if (line_break_num <= 1) {\n    rm_len = impl->rows->row[0].length;\n    wstr_remove(wstr, 0, rm_len);\n    *p_offset = tk_min(*p_offset > rm_len ? *p_offset - rm_len : 0, wstr->size);\n\n    if (wstr->size > *p_offset) {\n      wstr_remove(wstr, *p_offset, wstr->size - *p_offset);\n      text_edit_overwrite_text_fix_select(text_edit, 0, 0, *p_offset, wstr->size - *p_offset);\n    }\n  }\n\n  wstr_set_utf8_with_len(&s, text, len);\n  wstr_insert(wstr, *p_offset, s.str, s.size);\n  text_edit_overwrite_text_fix_select(text_edit, *p_offset, s.size, 0, rm_len);\n  wstr_reset(&s);\n\n  if (*p_offset + len != text_edit_get_cursor(text_edit)) {\n    text_edit_set_cursor(text_edit, *p_offset + len);\n  } else {\n    text_edit_layout(text_edit);\n  }\n\n  return RET_OK;\n}\n\nret_t text_edit_overwrite_text(text_edit_t* text_edit, uint32_t* p_offset, const char* text,\n                               uint32_t len) {\n  DECL_IMPL(text_edit);\n  wstr_t* wstr = NULL;\n  uint32_t text_size = 0;\n  ret_t ret = RET_FAIL;\n  return_value_if_fail(text_edit != NULL && text_edit->widget != NULL && text != NULL,\n                       RET_BAD_PARAMS);\n\n  wstr = &text_edit->widget->text;\n  text_size = tk_strlen(text);\n  *p_offset = tk_min(wstr->size, *p_offset);\n  len = tk_min(len, text_size);\n\n  /* 插入位置 不在最后一行 */\n  if (*p_offset < wstr->size - impl->rows->row[impl->rows->capacity - 1].length) {\n    ret = text_edit_overwrite_text_not_at_last_row(text_edit, p_offset, text, len);\n  } else {\n    ret = text_edit_overwrite_text_at_last_row(text_edit, p_offset, text, len);\n  }\n  *p_offset += len;\n\n  return ret;\n}\n\nret_t text_edit_set_lock_scrollbar_value(text_edit_t* text_edit, bool_t lock) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->lock_scrollbar_value = lock;\n\n  return RET_OK;\n}\n\n#include \"window.h\"\n#include \"window_manager.h\"\n\nstatic ret_t text_edit_on_copy(void* ctx, event_t* e) {\n  text_edit_t* text_edit = (text_edit_t*)ctx;\n  text_edit_copy(text_edit);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_on_cut(void* ctx, event_t* e) {\n  text_edit_t* text_edit = (text_edit_t*)ctx;\n  text_edit_cut(text_edit);\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_on_paste(void* ctx, event_t* e) {\n  text_edit_t* text_edit = (text_edit_t*)ctx;\n  text_edit_paste_from_clip_board(text_edit);\n\n  return RET_OK;\n}\n\nstatic ret_t text_edit_on_select_all(void* ctx, event_t* e) {\n  text_edit_t* text_edit = (text_edit_t*)ctx;\n  text_edit_select_all(text_edit);\n\n  return RET_OK;\n}\n\nret_t text_edit_show_context_menu(text_edit_t* text_edit, int32_t x, int32_t y) {\n  widget_t* win = window_open(\"edit_menu\");\n  widget_t* wm = window_manager();\n\n  if (win != NULL) {\n    DECL_IMPL(text_edit);\n    widget_t* copy = widget_lookup(win, \"copy\", TRUE);\n    widget_t* cut = widget_lookup(win, \"cut\", TRUE);\n    widget_t* paste = widget_lookup(win, \"paste\", TRUE);\nwidget_t* select_all = ",
    "raw_res": "",
    "prompt_res": "widget_lookup(win, \"select_all\", TRUE);",
    "gt": "widget_lookup(win, \"select_all\", TRUE);"
  },
  {
    "id": 2197,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/locale_info.c",
    "input": "﻿/**\n * File:   locale_info.c\n * Author: AWTK Develop Team\n * Brief:  locale_info\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-05-02 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utils.h\"\n#include \"base/locale_info.h\"\n\nstatic locale_info_t* s_locale = NULL;\n\nstatic locale_info_t* locale_info_init(locale_info_t* locale_info, const char* language,\n                                       const char* country);\nstatic ret_t locale_info_deinit(locale_info_t* locale_info);\n\nlocale_info_t* locale_info() {\n  return s_locale;\n}\n\nret_t locale_info_set(locale_info_t* locale_info) {\n  s_locale = locale_info;\n\n  return RET_OK;\n}\n\nlocale_info_t* locale_info_create(const char* language, const char* country) {\n  locale_info_t* locale_info = TKMEM_ZALLOC(locale_info_t);\n\n  return locale_info_init(locale_info, language, country);\n}\n\nstatic locale_info_t* locale_info_init(locale_info_t* locale_info, const char* language,\n                                       const char* country) {\n  return_value_if_fail(locale_info != NULL, NULL);\n\n  locale_info->emitter = emitter_create();\n  locale_info_change(locale_info, language, country);\n\n  return locale_info;\n}\n\nconst char* locale_info_tr(locale_info_t* locale_info, const char* text) {\n  str_table_t* table = NULL;\n  const char* tr_text = NULL;\n  return_value_if_fail(locale_info != NULL && text != NULL, text);\n  return_value_if_fail(locale_info->strs != NULL, text);\n\n  table = (str_table_t*)(locale_info->strs->data);\n\ntr_text = ",
    "raw_res": "0;",
    "prompt_res": "str_table_lookup(table, text);",
    "gt": "str_table_lookup(table, text);"
  },
  {
    "id": 2350,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/shortcut.c",
    "input": "﻿/**\n * File:   shortcut.c\n * Author: AWTK Develop Team\n * Brief:  shortcut\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2019-05-27 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include <tkc/mem.h>\n#include \"tkc/tokenizer.h\"\n\n#include \"base/enums.h\"\n#include \"base/shortcut.h\"\n\nshortcut_t* shortcut_init(shortcut_t* shortcut, uint32_t key) {\n  return_value_if_fail(shortcut != NULL, NULL);\n  memset(shortcut, 0x00, sizeof(shortcut_t));\n\n  shortcut->key = key;\n  shortcut->is_valid = TRUE;\n\n  return shortcut;\n}\n\nshortcut_t* shortcut_init_with_str(shortcut_t* shortcut, const char* str) {\n  tokenizer_t t;\n  const char* k = NULL;\n  return_value_if_fail(shortcut != NULL && str != NULL, NULL);\n  return_value_if_fail(tokenizer_init_ex(&t, str, strlen(str), \" _+\", NULL) != NULL, NULL);\n\n  memset(shortcut, 0, sizeof(shortcut_t));\n  while (tokenizer_has_more(&t)) {\nk = ",
    "raw_res": "0;",
    "prompt_res": "tokenizer_next(&t);",
    "gt": "tokenizer_next(&t);"
  },
  {
    "id": 2458,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/widget.c",
    "input": "﻿/**\n * File:   widget.c\n * Author: AWTK Develop Team\n * Brief:  basic class of all widget\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-13 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/fscript.h\"\n#include \"tkc/tokenizer.h\"\n#include \"tkc/color_parser.h\"\n#include \"tkc/object_default.h\"\n\n#include \"base/keys.h\"\n#include \"base/enums.h\"\n#include \"base/theme.h\"\n#include \"tkc/time_now.h\"\n#include \"base/idle.h\"\n#include \"base/widget.h\"\n#include \"base/layout.h\"\n#include \"native_window.h\"\n#include \"base/main_loop.h\"\n#include \"base/ui_feedback.h\"\n#include \"base/system_info.h\"\n#include \"base/window_manager.h\"\n#include \"base/widget_vtable.h\"\n#include \"base/style_mutable.h\"\n#include \"base/style_factory.h\"\n#include \"base/widget_animator_manager.h\"\n#include \"base/widget_animator_factory.h\"\n#include \"base/window_base.h\"\n#include \"blend/image_g2d.h\"\n\nret_t widget_focus_up(widget_t* widget);\nret_t widget_focus_down(widget_t* widget);\nret_t widget_focus_left(widget_t* widget);\nret_t widget_focus_right(widget_t* widget);\nstatic ret_t widget_unref_async(widget_t* widget);\nstatic ret_t widget_ensure_style_mutable(widget_t* widget);\nstatic ret_t widget_dispatch_blur_event(widget_t* widget);\n/*虚函数的包装*/\nstatic ret_t widget_on_paint_done(widget_t* widget, canvas_t* c);\nstatic ret_t widget_on_paint_begin(widget_t* widget, canvas_t* c);\nstatic ret_t widget_on_paint_end(widget_t* widget, canvas_t* c);\n\ntypedef widget_t* (*widget_find_wanted_focus_widget_t)(widget_t* widget, darray_t* all_focusable);\nstatic ret_t widget_move_focus(widget_t* widget, widget_find_wanted_focus_widget_t find);\n\n#define widget_set_xywh(widget, val, update_layout, invalidate)    \\\n  do {                                                             \\\n    if (widget->val != val) {                                      \\\n      if (invalidate) widget_invalidate_force(widget, NULL);       \\\n      widget->val = val;                                           \\\n      if (invalidate) widget_invalidate_force(widget, NULL);       \\\n    }                                                              \\\n    if (update_layout && widget->self_layout != NULL) {            \\\n      self_layouter_set_param_str(widget->self_layout, #val, \"n\"); \\\n    }                                                              \\\n  } while (0)\n\nstatic ret_t widget_set_x(widget_t* widget, xy_t x, bool_t update_layout) {\n  widget_set_xywh(widget, x, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_y(widget_t* widget, xy_t y, bool_t update_layout) {\n  widget_set_xywh(widget, y, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_w(widget_t* widget, wh_t w, bool_t update_layout) {\n  widget_set_xywh(widget, w, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_h(widget_t* widget, xy_t h, bool_t update_layout) {\n  widget_set_xywh(widget, h, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic bool_t widget_is_strongly_focus(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n  if (win != NULL) {\n    return WINDOW_BASE(win)->strongly_focus;\n  } else {\n    return FALSE;\n  }\n}\n\nret_t widget_set_need_update_style(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (!widget->need_update_style) {\n    widget_invalidate_force(widget, NULL);\n  }\n\n  widget->need_update_style = TRUE;\n\n  return RET_OK;\n}\n\nret_t widget_update_style_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_update_style(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_update_style_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_set_need_update_style_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_need_update_style(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_set_need_update_style_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_update_style(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->astyle != NULL, RET_BAD_PARAMS);\n\n  if (widget->need_update_style) {\n    widget->need_update_style = FALSE;\n    return style_notify_widget_state_changed(widget->astyle, widget);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_real_destroy(widget_t* widget) {\n  ENSURE(widget->ref_count == 1);\n\n  if (widget->vt->on_destroy) {\n    widget->vt->on_destroy(widget);\n  }\n\n  TKMEM_FREE(widget->name);\n  TKMEM_FREE(widget->state);\n  TKMEM_FREE(widget->style);\n  TKMEM_FREE(widget->tr_text);\n  TKMEM_FREE(widget->animation);\n  TKMEM_FREE(widget->pointer_cursor);\n  TK_OBJECT_UNREF(widget->custom_props);\n  wstr_reset(&(widget->text));\n  style_destroy(widget->astyle);\n\n  memset(widget, 0x00, sizeof(widget_t));\n  TKMEM_FREE(widget);\n\n  return RET_OK;\n}\n\nstatic widget_t* widget_real_create(const widget_vtable_t* vt) {\n  widget_t* widget = TKMEM_ALLOC(vt->size);\n  return_value_if_fail(widget != NULL, NULL);\n\n  memset(widget, 0x00, vt->size);\n  widget->vt = vt;\n\n  return widget;\n}\n\nstatic bool_t widget_is_scrollable(widget_t* widget) {\n  return widget != NULL && widget->vt != NULL && widget->vt->scrollable;\n}\n\nstatic bool_t widget_with_focus_state(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n  value_set_bool(&v, FALSE);\n  widget_get_prop(widget, WIDGET_PROP_WITH_FOCUS_STATE, &v);\n\n  return value_bool(&v);\n}\n\nbool_t widget_is_focusable(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  if (!widget->visible || !widget->sensitive || !widget->enable) {\n    return FALSE;\n  }\n\n  return widget->focusable || widget->vt->focusable;\n}\n\nret_t widget_move(widget_t* widget, xy_t x, xy_t y) {\n  event_t e = event_init(EVT_WILL_MOVE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->x != x || widget->y != y) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, x, TRUE, FALSE);\n    widget_set_xywh(widget, y, TRUE, FALSE);\n    widget_invalidate_force(widget, NULL);\n\n    e.type = EVT_MOVE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_to_center(widget_t* widget) {\n  int32_t x = 0;\n  int32_t y = 0;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, RET_BAD_PARAMS);\n\n  x = (widget->parent->w - widget->w) / 2;\n  y = (widget->parent->h - widget->h) / 2;\n\n  return widget_move(widget, x, y);\n}\n\nret_t widget_resize(widget_t* widget, wh_t w, wh_t h) {\n  event_t e = event_init(EVT_WILL_RESIZE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->w != w || widget->h != h) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, w, TRUE, FALSE);\n    widget_set_xywh(widget, h, TRUE, FALSE);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget);\n\n    e.type = EVT_RESIZE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_resize_ex(widget_t* widget, xy_t x, xy_t y, wh_t w, wh_t h,\n                            bool_t update_layout) {\n  event_t e = event_init(EVT_WILL_MOVE_RESIZE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->x != x || widget->y != y || widget->w != w || widget->h != h) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, x, update_layout, FALSE);\n    widget_set_xywh(widget, y, update_layout, FALSE);\n    widget_set_xywh(widget, w, update_layout, FALSE);\n    widget_set_xywh(widget, h, update_layout, FALSE);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget);\n\n    e.type = EVT_MOVE_RESIZE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_resize(widget_t* widget, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return widget_move_resize_ex(widget, x, y, w, h, TRUE);\n}\n\nfloat_t widget_get_value(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_VALUE, &v) == RET_OK ? value_float32(&v) : 0.0f;\n}\n\nret_t widget_set_value(widget_t* widget, float_t value) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_VALUE, value_set_float32(&v, value));\n}\n\nret_t widget_add_value(widget_t* widget, float_t delta) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_value(widget, widget_get_value(widget) + delta);\n}\n\nint32_t widget_get_value_int(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_VALUE, &v) == RET_OK ? value_int(&v) : 0;\n}\n\nret_t widget_set_value_int(widget_t* widget, int32_t value) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_VALUE, value_set_int(&v, value));\n}\n\nret_t widget_add_value_int(widget_t* widget, int32_t delta) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_value_int(widget, widget_get_value_int(widget) + delta);\n}\n\nstatic ret_t widget_animate_prop_float_to(widget_t* widget, const char* name, float_t value,\n                                          uint32_t duration) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL, RET_BAD_PARAMS);\n  if (duration == 0) {\n    ret = widget_set_prop_float(widget, name, value);\n  } else {\n    float_t prev_value = widget_get_prop_float(widget, name, 0.0f);\n    widget_destroy_animator(widget, name);\n\n    if (prev_value != value) {\n      char params[128] = {0};\n      tk_snprintf(params, sizeof(params) - 1, \"%s(from=%f,to=%f,duration=%d)\", name, prev_value,\n                  value, duration);\n      ret = widget_create_animator(widget, params);\n    }\n  }\n  return ret;\n}\n\nret_t widget_animate_value_to(widget_t* widget, float_t value, uint32_t duration) {\n  return widget_animate_prop_float_to(widget, WIDGET_PROP_VALUE, value, duration);\n}\n\nbool_t widget_is_window_opened(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n    return WINDOW_STAGE_OPENED == stage || WINDOW_STAGE_SUSPEND == stage;\n  } else {\n    return FALSE;\n  }\n}\n\nbool_t widget_is_window_created(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n    return WINDOW_STAGE_OPENED == stage || WINDOW_STAGE_SUSPEND == stage ||\n           WINDOW_STAGE_LOADED == stage || WINDOW_STAGE_CREATED == stage;\n  } else {\n    return FALSE;\n  }\n}\n\nret_t widget_get_window_theme(widget_t* widget, theme_t** win_theme, theme_t** default_theme) {\n  value_t v;\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    if (widget_get_prop(win, WIDGET_PROP_THEME_OBJ, &v) == RET_OK) {\n      *win_theme = (theme_t*)value_pointer(&v);\n    }\n\n    if (widget_get_prop(win, WIDGET_PROP_DEFAULT_THEME_OBJ, &v) == RET_OK) {\n      *default_theme = (theme_t*)value_pointer(&v);\n    }\n  }\n  return RET_OK;\n}\n\nbool_t widget_is_style_exist(widget_t* widget, const char* style_name, const char* state_name) {\n  const void* data = NULL;\n  const char* style = NULL;\n  const char* state = NULL;\n  theme_t* win_theme = NULL;\n  theme_t* default_theme = NULL;\n  const char* type = widget_get_type(widget);\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(widget != NULL && win != NULL, FALSE);\n\n  if (style_name == NULL || *style_name == 0) {\n    style = TK_DEFAULT_STYLE;\n  } else {\n    style = style_name;\n  }\n\n  if (state_name == NULL || *state_name == 0) {\n    state = WIDGET_STATE_NORMAL;\n  } else {\n    state = state_name;\n  }\n\n  return_value_if_fail(widget_get_window_theme(widget, &win_theme, &default_theme) == RET_OK,\n                       FALSE);\n\n  if (win_theme != NULL) {\n    data = theme_find_style(win_theme, type, style, state);\n  }\n\n  if (data == NULL && default_theme != NULL) {\n    data = theme_find_style(default_theme, type, style, state);\n  }\n\n  return data != NULL;\n}\n\nret_t widget_use_style(widget_t* widget, const char* value) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_need_update_style(widget);\n  widget->style = tk_str_copy(widget->style, value);\n\n  if (widget_is_window_opened(widget)) {\n    widget_update_style(widget);\n    return widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_text(widget_t* widget, const wchar_t* text) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_wstr(&v, text));\n}\n\nret_t widget_set_text_utf8(widget_t* widget, const char* text) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_str(&v, text));\n}\n\nret_t widget_get_text_utf8(widget_t* widget, char* text, uint32_t size) {\n  value_t v;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && text != NULL && size > 0, RET_BAD_PARAMS);\n\n  value_set_str(&v, NULL);\n  memset(text, 0x00, size);\n  if (widget_get_prop(widget, WIDGET_PROP_TEXT, &v) == RET_OK) {\n    if (v.type == VALUE_TYPE_STRING) {\n      tk_strncpy(text, value_str(&v), size - 1);\n      ret = RET_OK;\n    } else if (v.type == VALUE_TYPE_WSTRING) {\n      tk_utf8_from_utf16(value_wstr(&v), text, size);\n      ret = RET_OK;\n    }\n  }\n\n  return ret;\n}\n\nimage_manager_t* widget_get_image_manager(widget_t* widget) {\n  image_manager_t* ret = image_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = image_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_IMAGE_MANAGER, &v) == RET_OK) {\n      ret = (image_manager_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nlocale_info_t* widget_get_locale_info(widget_t* widget) {\n  locale_info_t* ret = locale_info();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = locale_info();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_LOCALE_INFO, &v) == RET_OK) {\n      ret = (locale_info_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nassets_manager_t* widget_get_assets_manager(widget_t* widget) {\n  assets_manager_t* am = assets_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, am);\n\n  if (widget->assets_manager != NULL) {\n    return widget->assets_manager;\n  }\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    am = assets_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_ASSETS_MANAGER, &v) == RET_OK) {\n      am = (assets_manager_t*)value_pointer(&v);\n    }\n  }\n  widget->assets_manager = am;\n\n  return am;\n}\n\nfont_manager_t* widget_get_font_manager(widget_t* widget) {\n  font_manager_t* ret = font_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = font_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_FONT_MANAGER, &v) == RET_OK) {\n      ret = (font_manager_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_apply_tr_text_before_paint(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  if (widget->tr_text != NULL) {\n    const char* text = locale_info_tr(widget_get_locale_info(widget), widget->tr_text);\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n  }\n\n  return RET_REMOVE;\n}\n\nret_t widget_set_tr_text(widget_t* widget, const char* text) {\n  const char* tr_text = NULL;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(widget != NULL, RET_OK);\n\n  if (text == NULL || *text == '\\0') {\n    if (widget->tr_text != NULL) {\n      TKMEM_FREE(widget->tr_text);\n      widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n    }\n\n    return RET_OK;\n  }\n\n  widget->tr_text = tk_str_copy(widget->tr_text, text);\n  if (win != NULL) {\n    tr_text = locale_info_tr(widget_get_locale_info(widget), text);\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, tr_text);\n  } else {\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n    widget_on(widget, EVT_BEFORE_PAINT, widget_apply_tr_text_before_paint, widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_re_translate_text(widget_t* widget) {\n  if (widget->vt->on_re_translate != NULL) {\n    widget->vt->on_re_translate(widget);\n  }\n  if (widget->tr_text != NULL) {\n    value_t v;\n    const char* tr_text = locale_info_tr(widget_get_locale_info(widget), widget->tr_text);\n    widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_str(&v, tr_text));\n    widget_invalidate(widget, NULL);\n  }\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_re_translate_text(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nconst wchar_t* widget_get_text(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_TEXT, &v) == RET_OK ? value_wstr(&v) : 0;\n}\n\nret_t widget_set_name(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (name != NULL) {\n    widget->name = tk_str_copy(widget->name, name);\n  } else {\n    TKMEM_FREE(widget->name);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_theme(widget_t* widget, const char* name) {\n  theme_change_event_t will_event;\n  event_t* will_evt = theme_change_event_init(&will_event, EVT_THEME_WILL_CHANGE, name);\n  widget_dispatch(window_manager(), will_evt);\n#ifdef WITH_FS_RES\n  const asset_info_t* info = NULL;\n  theme_change_event_t event;\n  event_t* evt = theme_change_event_init(&event, EVT_THEME_CHANGED, name);\n  widget_t* wm = widget_get_window_manager(widget);\n  font_manager_t* fm = widget_get_font_manager(widget);\n  image_manager_t* imm = widget_get_image_manager(widget);\n  assets_manager_t* am = widget_get_assets_manager(widget);\n  locale_info_t* locale_info = widget_get_locale_info(widget);\n  return_value_if_fail(am != NULL && name != NULL, RET_BAD_PARAMS);\n\n  font_manager_unload_all(fm);\n  image_manager_unload_all(imm);\n  locale_info_reload(locale_info);\n  assets_manager_set_theme(am, name);\n  widget_reset_canvas(widget);\n\n  info = assets_manager_ref(am, ASSET_TYPE_STYLE, \"default\");\n  if (info != NULL) {\n    theme_set(theme_load_from_data(info->name, info->data, info->size));\n    assets_manager_unref(assets_manager(), info);\n  }\n\n  widget_dispatch(wm, evt);\n  widget_invalidate_force(wm, NULL);\n\n  log_debug(\"theme changed: %s\\n\", name);\n#endif\n\n  return RET_OK;\n}\n\nret_t widget_set_pointer_cursor(widget_t* widget, const char* cursor) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (!tk_str_eq(widget->pointer_cursor, cursor)) {\n    widget->pointer_cursor = tk_str_copy(widget->pointer_cursor, cursor);\n    widget_update_pointer_cursor(widget);\n  }\n\n  return RET_OK;\n}\n\n#ifndef WITHOUT_WIDGET_ANIMATORS\nret_t widget_set_animation(widget_t* widget, const char* animation) {\n  return_value_if_fail(widget != NULL && animation != NULL, RET_BAD_PARAMS);\n\n  widget->animation = tk_str_copy(widget->animation, animation);\n\n  return widget_create_animator(widget, animation);\n}\n\nret_t widget_create_animator(widget_t* widget, const char* animation) {\n  tokenizer_t t;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && animation != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(tokenizer_init(&t, animation, strlen(animation), \";\") != NULL, RET_OOM);\n\n  while (tokenizer_has_more(&t)) {\n    const char* params = tokenizer_next(&t);\n    if (widget_animator_create(widget, params) == NULL) {\n      ret = RET_BAD_PARAMS;\n      break;\n    }\n  }\n  tokenizer_deinit(&t);\n  widget_invalidate(widget, NULL);\n\n  return ret;\n}\n\nret_t widget_start_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_start(widget_animator_manager(), widget, name);\n}\n\nret_t widget_set_animator_time_scale(widget_t* widget, const char* name, float_t time_scale) {\n  return widget_animator_manager_set_time_scale(widget_animator_manager(), widget, name,\n                                                time_scale);\n}\n\nret_t widget_pause_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_pause(widget_animator_manager(), widget, name);\n}\n\nwidget_animator_t* widget_find_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_find(widget_animator_manager(), widget, name);\n}\n\nret_t widget_stop_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_stop(widget_animator_manager(), widget, name);\n}\n\nret_t widget_destroy_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_remove_all(widget_animator_manager(), widget, name);\n}\n#else\nret_t widget_start_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nret_t widget_create_animator(widget_t* widget, const char* animation) {\n  return RET_OK;\n}\nret_t widget_set_animation(widget_t* widget, const char* animation) {\n  return RET_OK;\n}\nret_t widget_set_animator_time_scale(widget_t* widget, const char* name, float_t time_scale) {\n  return RET_OK;\n}\nret_t widget_pause_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nwidget_animator_t* widget_find_animator(widget_t* widget, const char* name) {\n  return NULL;\n}\nret_t widget_stop_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nret_t widget_destroy_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\n#endif /*WITHOUT_WIDGET_ANIMATORS*/\n\nret_t widget_set_enable(widget_t* widget, bool_t enable) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->enable != enable) {\n    widget->enable = enable;\n    widget_set_need_update_style_recursive(widget);\n    widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_feedback(widget_t* widget, bool_t feedback) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->feedback = feedback;\n\n  return RET_OK;\n}\n\nret_t widget_set_auto_adjust_size(widget_t* widget, bool_t auto_adjust_size) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->auto_adjust_size = auto_adjust_size;\n  widget_set_need_relayout(widget);\n\n  return RET_OK;\n}\n\nret_t widget_set_floating(widget_t* widget, bool_t floating) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->floating = floating;\n\n  return RET_OK;\n}\n\nret_t widget_set_focused_internal(widget_t* widget, bool_t focused) {\n  widget_t* win = widget_get_window(widget);\n  int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (WINDOW_STAGE_SUSPEND == stage) {\n    log_debug(\"You can not set focus of a widget when window is in background\");\n    return RET_FAIL;\n  }\n\n  if (widget->focused != focused) {\n    widget->focused = focused;\n    widget_set_need_update_style(widget);\n\n    if (focused) {\n      event_t e = event_init(EVT_FOCUS, widget);\n      widget_set_as_key_target(widget);\n\n      widget_dispatch(widget, &e);\n    } else {\n      event_t e = event_init(EVT_BLUR, widget);\n      widget_dispatch(widget, &e);\n      widget_dispatch_blur_event(widget);\n    }\n\n    widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_focused(widget_t* widget, bool_t focused) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_focused_internal(widget, focused);\n  if (focused) {\n    widget_ensure_visible_in_viewport(widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_focusable(widget_t* widget, bool_t focusable) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->focusable = focusable;\n\n  return RET_OK;\n}\n\nret_t widget_set_state(widget_t* widget, const char* state) {\n  return_value_if_fail(widget != NULL && state != NULL, RET_BAD_PARAMS);\n\n  if (!tk_str_eq(widget->state, state)) {\n    widget_invalidate_force(widget, NULL);\n    widget->state = tk_str_copy(widget->state, state);\n    widget_set_need_update_style(widget);\n    widget_invalidate_force(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_state_for_style(widget_t* widget, bool_t active, bool_t checked) {\n  const char* state = WIDGET_STATE_NORMAL;\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, state);\n\n  state = (const char*)(widget->state);\n\n  while (iter != NULL) {\n    if (!iter->enable) {\n      if (active) return WIDGET_STATE_DISABLE_OF_ACTIVE;\n      if (checked) return WIDGET_STATE_DISABLE_OF_CHECKED;\n      return WIDGET_STATE_DISABLE;\n    }\n    iter = iter->parent;\n  }\n\n  if (widget_is_focusable(widget) || widget_with_focus_state(widget)) {\n    if (widget->focused) {\n      if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n        state = WIDGET_STATE_FOCUSED;\n      }\n    } else {\n      if (tk_str_eq(state, WIDGET_STATE_FOCUSED)) {\n        state = WIDGET_STATE_NORMAL;\n      }\n    }\n  }\n\n  if (active) {\n    if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n      state = WIDGET_STATE_NORMAL_OF_ACTIVE;\n    } else if (tk_str_eq(state, WIDGET_STATE_PRESSED)) {\n      state = WIDGET_STATE_PRESSED_OF_ACTIVE;\n    } else if (tk_str_eq(state, WIDGET_STATE_OVER)) {\n      state = WIDGET_STATE_OVER_OF_ACTIVE;\n    } else if (widget_is_focusable(widget) && widget->focused) {\n      state = WIDGET_STATE_FOCUSED_OF_ACTIVE;\n    }\n  } else if (checked) {\n    if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n      state = WIDGET_STATE_NORMAL_OF_CHECKED;\n    } else if (tk_str_eq(state, WIDGET_STATE_PRESSED)) {\n      state = WIDGET_STATE_PRESSED_OF_CHECKED;\n    } else if (tk_str_eq(state, WIDGET_STATE_OVER)) {\n      state = WIDGET_STATE_OVER_OF_CHECKED;\n    } else if (widget_is_focusable(widget) && widget->focused) {\n      state = WIDGET_STATE_FOCUSED_OF_CHECKED;\n    }\n  }\n\n  return state;\n}\n\nret_t widget_set_opacity(widget_t* widget, uint8_t opacity) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->opacity = opacity;\n  widget_invalidate(widget, NULL);\n\n  return RET_OK;\n}\n\nret_t widget_set_dirty_rect_tolerance(widget_t* widget, uint16_t dirty_rect_tolerance) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->dirty_rect_tolerance = dirty_rect_tolerance;\n  widget_invalidate(widget, NULL);\n\n  return RET_OK;\n}\n\nret_t widget_destroy_children(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->children != NULL) {\n    WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n\n    widget_remove_child_prepare(widget, iter);\n    widget_unref(iter);\n\n    widget->children->elms[i] = NULL;\n\n    WIDGET_FOR_EACH_CHILD_END();\n    widget->children->size = 0;\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_style_type(widget_t* widget) {\n  theme_t* win_theme = NULL;\n  theme_t* default_theme = NULL;\n  const char* style_type = THEME_DEFAULT_STYLE_TYPE;\n\n  if (widget_get_window_theme(widget, &win_theme, &default_theme) == RET_OK) {\n    theme_t* t = win_theme != NULL ? win_theme : (default_theme != NULL ? default_theme : theme());\n    if (t != NULL) {\n      style_type = theme_get_style_type(t);\n    }\n  }\n\n  return style_type;\n}\n\nstatic ret_t widget_update_style_object(widget_t* widget) {\n  const char* style_type = widget_get_style_type(widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  if (widget->astyle == NULL) {\n    widget->astyle = style_factory_create_style(style_factory(), style_type);\n    ENSURE(widget->astyle != NULL);\n\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  } else if (widget->astyle != NULL &&\n             !tk_str_eq(style_get_style_type(widget->astyle), style_type)) {\n    style_t* style = style_factory_create_style(style_factory(), style_type);\n    ENSURE(style != NULL);\n    if (style_is_mutable(widget->astyle)) {\n      style_mutable_set_default_style(widget->astyle, style);\n    } else {\n      style_destroy(widget->astyle);\n      widget->astyle = style;\n    }\n\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  }\n  return RET_OK;\n}\n\nstatic ret_t widget_update_style_object_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_update_style_object(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_update_style_object_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_add_child(widget_t* widget, widget_t* child) {\n  event_t e = event_init(EVT_WIDGET_ADD_CHILD, widget);\n  return_value_if_fail(widget != NULL && child != NULL && child->parent == NULL, RET_BAD_PARAMS);\n\n  child->parent = widget;\n\n  if (widget->children == NULL) {\n    widget->children = darray_create(4, NULL, NULL);\n  }\n\n  if (widget->vt->on_add_child) {\n    if (widget->vt->on_add_child(widget, child) == RET_OK) {\n      return RET_OK;\n    }\n  }\n\n  if (child->vt->on_attach_parent) {\n    child->vt->on_attach_parent(child, widget);\n  }\n\n  ENSURE(darray_push(widget->children, child) == RET_OK);\n\n  if (!widget_is_window_manager(widget)) {\n    widget_set_need_relayout_children(widget);\n  }\n\n  if (!(child->initializing) && widget_get_window(child) != NULL) {\n    widget_set_need_update_style_recursive(child);\n    widget_update_style_object_recursive(child);\n  }\n\n  widget_dispatch(widget, &e);\n\n  return RET_OK;\n}\n\nret_t widget_remove_child_prepare(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n\n  if (!widget_is_window_manager(widget)) {\n    widget_set_need_relayout_children(widget);\n  }\n\n  widget_invalidate_force(child, NULL);\n  if (widget->target == child) {\n    widget->target = NULL;\n  }\n\n  if (widget->grab_widget == child) {\n    widget->grab_widget = NULL;\n    widget->grab_widget_count = 0;\n  }\n\n  if (widget->key_target == child) {\n    widget_dispatch_blur_event(widget->key_target);\n    widget->key_target = NULL;\n  }\n\n  if (widget->vt->on_remove_child) {\n    if (widget->vt->on_remove_child(widget, child) == RET_OK) {\n      return RET_OK;\n    }\n  }\n\n  if (child->vt->on_detach_parent) {\n    child->vt->on_detach_parent(child, widget);\n  }\n  child->parent = NULL;\n\n  return RET_OK;\n}\n\nret_t widget_remove_child(widget_t* widget, widget_t* child) {\n  ret_t ret = RET_OK;\n  event_t e = event_init(EVT_WIDGET_REMOVE_CHILD, widget);\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n\n  widget_remove_child_prepare(widget, child);\n  ret = darray_remove(widget->children, child);\n\n  if (ret == RET_OK) {\n    widget_dispatch(widget, &e);\n  }\n\n  return ret;\n}\n\nret_t widget_insert_child(widget_t* widget, uint32_t index, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget_add_child(widget, child) == RET_OK, RET_FAIL);\n\n  return widget_restack(child, index);\n}\n\nret_t widget_restack(widget_t* widget, uint32_t index) {\n  uint32_t i = 0;\n  uint32_t nr = 0;\n  int32_t old_index = 0;\n  widget_t** children = NULL;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, RET_BAD_PARAMS);\n\n  old_index = widget_index_of(widget);\n  nr = widget_count_children(widget->parent);\n  return_value_if_fail(old_index >= 0 && nr > 0, RET_BAD_PARAMS);\n\n  if (index >= nr) {\n    index = nr - 1;\n  }\n\n  if (index == old_index || nr == 1) {\n    return RET_OK;\n  }\n\n  children = (widget_t**)(widget->parent->children->elms);\n  if (index < old_index) {\n    for (i = old_index; i > index; i--) {\n      children[i] = children[i - 1];\n    }\n  } else {\n    for (i = old_index; i < index; i++) {\n      children[i] = children[i + 1];\n    }\n  }\n  children[index] = widget;\n\n  return RET_OK;\n}\n\nstatic widget_t* widget_lookup_child(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL && name != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (iter->name != NULL && tk_str_eq(iter->name, name)) {\n    return iter;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return NULL;\n}\n\nwidget_t* widget_child(widget_t* widget, const char* path) {\n  return widget_lookup_child(widget, path);\n}\n\nwidget_t* widget_get_focused_widget(widget_t* widget) {\n  widget_t* iter = NULL;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(win != NULL, NULL);\n\n  iter = win->key_target;\n  for (iter = win->key_target; iter != NULL; iter = iter->key_target) {\n    if (iter->focusable && iter->focused) {\n      return iter;\n    }\n\n    if (iter->key_target == NULL) {\n      return iter;\n    }\n  }\n\n  return NULL;\n}\n\nstatic widget_t* widget_lookup_all(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL && name != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (iter->name != NULL && tk_str_eq(iter->name, name)) {\n    return iter;\n  } else {\n    iter = widget_lookup_all(iter, name);\n    if (iter != NULL) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nwidget_t* widget_lookup(widget_t* widget, const char* name, bool_t recursive) {\n  if (recursive) {\n    return widget_lookup_all(widget, name);\n  } else {\n    return widget_lookup_child(widget, name);\n  }\n}\n\nstatic widget_t* widget_lookup_by_type_child(widget_t* widget, const char* type) {\n  return_value_if_fail(widget != NULL && type != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (tk_str_eq(iter->vt->type, type)) {\n    return iter;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return NULL;\n}\n\nstatic widget_t* widget_lookup_by_type_all(widget_t* widget, const char* type) {\n  return_value_if_fail(widget != NULL && type != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (tk_str_eq(iter->vt->type, type)) {\n    return iter;\n  } else {\n    iter = widget_lookup_by_type_all(iter, type);\n    if (iter != NULL) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nwidget_t* widget_lookup_by_type(widget_t* widget, const char* type, bool_t recursive) {\n  if (recursive) {\n    return widget_lookup_by_type_all(widget, type);\n  } else {\n    return widget_lookup_by_type_child(widget, type);\n  }\n}\n\nstatic ret_t widget_set_visible_self(widget_t* widget, bool_t visible) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->visible != visible) {\n    widget_invalidate_force(widget, NULL);\n    widget->visible = visible;\n    widget_set_need_update_style(widget);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget->parent);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_sensitive(widget_t* widget, bool_t sensitive) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->sensitive = sensitive;\n\n  return RET_OK;\n}\n\nret_t widget_set_visible_only(widget_t* widget, bool_t visible) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->visible = visible;\n\n  return RET_OK;\n}\n\nret_t widget_set_visible(widget_t* widget, bool_t visible, ...) {\n  return widget_set_visible_self(widget, visible);\n}\n\nwidget_t* widget_find_target(widget_t* widget, xy_t x, xy_t y) {\n  widget_t* ret = NULL;\n  return_value_if_fail(widget != NULL, NULL);\n\n  if (widget->vt && widget->vt->find_target) {\n    ret = widget->vt->find_target(widget, x, y);\n  } else {\n    ret = widget_find_target_default(widget, x, y);\n  }\n\n  return ret;\n}\n\nret_t widget_on_event_before_children(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt && widget->vt->on_event_before_children) {\n    ret = widget->vt->on_event_before_children(widget, e);\n  }\n\n  return ret;\n}\n\nstatic const char* widget_get_pointer_cursor(widget_t* widget) {\n  if (widget->pointer_cursor != NULL) {\n    return widget->pointer_cursor;\n  } else if (widget->vt->pointer_cursor != NULL) {\n    return widget->vt->pointer_cursor;\n  }\n\n  return WIDGET_CURSOR_DEFAULT;\n}\n\nret_t widget_update_pointer_cursor(widget_t* widget) {\n  widget_t* wm = widget_get_window_manager(widget);\n  return_value_if_fail(wm != NULL, RET_BAD_PARAMS);\n\n  return window_manager_set_cursor(wm, widget_get_pointer_cursor(widget));\n}\n\nret_t widget_dispatch(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  if (e->target == NULL) {\n    e->target = widget;\n  }\n\n  if (widget->vt && widget->vt->on_event) {\n    ret = widget->vt->on_event(widget, e);\n  } else {\n    ret = widget_on_event_default(widget, e);\n  }\n\n  if (ret != RET_STOP) {\n    if (widget->emitter != NULL) {\n      void* saved_target = e->target;\n\n      e->target = widget;\n      ret = emitter_dispatch(widget->emitter, e);\n      e->target = saved_target;\n    }\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t dispatch_in_idle(const idle_info_t* info) {\n  event_t* e = (event_t*)(info->ctx);\n  widget_t* widget = WIDGET(e->target);\n\n  widget_dispatch(widget, e);\n  widget_unref(widget);\n  event_destroy(e);\n\n  return RET_REMOVE;\n}\n\nret_t widget_dispatch_async(widget_t* widget, event_t* e) {\n  event_t* evt = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(e->target == widget, RET_BAD_PARAMS);\n\n  evt = event_clone(e);\n  return_value_if_fail(evt != NULL, RET_OOM);\n\n  widget_ref(widget);\n  idle_add(dispatch_in_idle, evt);\n\n  return RET_OK;\n}\n\nstatic ret_t widget_dispatch_callback(void* ctx, const void* data) {\n  widget_t* widget = WIDGET(data);\n\n  return widget_dispatch(widget, (event_t*)ctx);\n}\n\nret_t widget_dispatch_recursive(widget_t* widget, event_t* e) {\n  return widget_foreach(widget, widget_dispatch_callback, e);\n}\n\nuint32_t widget_on_with_tag(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx,\n                            uint32_t tag) {\n  return_value_if_fail(widget != NULL && on_event != NULL, RET_BAD_PARAMS);\n  if (widget->emitter == NULL) {\n    widget->emitter = emitter_create();\n  }\n\n  return emitter_on_with_tag(widget->emitter, type, on_event, ctx, tag);\n}\n\nuint32_t widget_on(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx) {\n  return widget_on_with_tag(widget, type, on_event, ctx, 0);\n}\n\nuint32_t widget_child_on(widget_t* widget, const char* name, uint32_t type, event_func_t on_event,\n                         void* ctx) {\n  return widget_on(widget_lookup(widget, name, TRUE), type, on_event, ctx);\n}\n\nret_t widget_off(widget_t* widget, uint32_t id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->emitter != NULL, RET_BAD_PARAMS);\n\n  return emitter_off(widget->emitter, id);\n}\n\nret_t widget_off_by_tag(widget_t* widget, uint32_t tag) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_tag(widget->emitter, tag);\n}\n\nret_t widget_off_by_ctx(widget_t* widget, void* ctx) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_ctx(widget->emitter, ctx);\n}\n\nret_t widget_off_by_func(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx) {\n  return_value_if_fail(widget != NULL && on_event != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_func(widget->emitter, type, on_event, ctx);\n}\n\nret_t widget_calc_icon_text_rect(const rect_t* ir, int32_t font_size, float_t text_size,\n                                 int32_t icon_at, uint32_t img_w, uint32_t img_h, int32_t spacer,\n                                 rect_t* r_text, rect_t* r_icon) {\n  return_value_if_fail(ir != NULL && (r_text != NULL || r_icon != NULL), RET_BAD_PARAMS);\n\n  if (r_icon == NULL) {\n    *r_text = *ir;\n\n    return RET_OK;\n  }\n\n  if (r_text == NULL) {\n    *r_icon = *ir;\n\n    return RET_OK;\n  }\n\n  return_value_if_fail(spacer < ir->h && spacer < ir->w, RET_BAD_PARAMS);\n  switch (icon_at) {\n    case ICON_AT_CENTRE: {\n      int32_t w = ir->w - spacer - text_size - img_w;\n      int32_t icon_h = ir->h - img_h;\n      *r_text = rect_init(ir->x + img_w + spacer + w / 2, ir->y, text_size, ir->h);\n      *r_icon = rect_init(ir->x + w / 2, ir->y + icon_h / 2, img_w, img_h);\n      break;\n    }\n    case ICON_AT_RIGHT: {\n      uint32_t w = img_w;\n      float_t ratio = system_info()->device_pixel_ratio;\n      if (ratio > 1) {\n        w = img_w / ratio;\n      }\n      w = tk_min(tk_max(w, ir->h), ir->w);\n      *r_icon = rect_init(ir->x + ir->w - w, ir->y, w, ir->h);\n      *r_text = rect_init(ir->x, ir->y, ir->w - ir->h - spacer, ir->h);\n      break;\n    }\n    case ICON_AT_TOP: {\n      int32_t icon_h = ir->h - font_size - spacer;\n      *r_icon = rect_init(ir->x, ir->y, ir->w, icon_h);\n      *r_text = rect_init(ir->x, icon_h + spacer, ir->w, font_size);\n      break;\n    }\n    case ICON_AT_BOTTOM: {\n      int32_t icon_h = ir->h - font_size - spacer;\n      *r_icon = rect_init(ir->x, ir->y + ir->h - icon_h, ir->w, icon_h);\n      *r_text = rect_init(ir->x, ir->y, ir->w, font_size);\n      break;\n    }\n    case ICON_AT_LEFT:\n    default: {\n      *r_icon = rect_init(ir->x, ir->y, ir->h, ir->h);\n      *r_text = rect_init(ir->x + ir->h + spacer, ir->y, ir->w - ir->h - spacer, ir->h);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_bidi(widget_t* widget) {\n  value_t v;\n  if (widget_get_prop(widget, WIDGET_PROP_BIDI, &v) == RET_OK) {\n    return value_str(&v);\n  }\n\n  return NULL;\n}\n\nret_t widget_draw_icon_text(widget_t* widget, canvas_t* c, const char* icon, wstr_t* text) {\n  rect_t ir;\n  wh_t w = 0;\n  wh_t h = 0;\n  bitmap_t img;\n  rect_t r_icon;\n  rect_t r_text;\n  int32_t margin = 0;\n  int32_t spacer = 0;\n  int32_t icon_at = 0;\n  uint16_t font_size = 0;\n  float_t text_size = 0.0f;\n  int32_t margin_left = 0;\n  int32_t margin_right = 0;\n  int32_t margin_top = 0;\n  int32_t margin_bottom = 0;\n  style_t* style = widget->astyle;\n  int32_t align_h = ALIGN_H_LEFT;\n  int32_t align_v = ALIGN_V_MIDDLE;\n  return_value_if_fail(widget->astyle != NULL, RET_BAD_PARAMS);\n\n  spacer = style_get_int(style, STYLE_ID_SPACER, 2);\n  margin = style_get_int(style, STYLE_ID_MARGIN, 0);\n  margin_top = style_get_int(style, STYLE_ID_MARGIN_TOP, margin);\n  margin_left = style_get_int(style, STYLE_ID_MARGIN_LEFT, margin);\n  margin_right = style_get_int(style, STYLE_ID_MARGIN_RIGHT, margin);\n  margin_bottom = style_get_int(style, STYLE_ID_MARGIN_BOTTOM, margin);\n  icon_at = style_get_int(style, STYLE_ID_ICON_AT, ICON_AT_AUTO);\n\n  w = widget->w - margin_left - margin_right;\n  h = widget->h - margin_top - margin_bottom;\n  ir = rect_init(margin_left, margin_top, w, h);\n\n  if (text == NULL) {\n    text = &(widget->text);\n  }\n\n  if (icon == NULL) {\n    icon = style_get_str(style, STYLE_ID_ICON, NULL);\n  }\n\n  widget_prepare_text_style(widget, c);\n\n  font_size = c->font_size;\n  text_size = text->str ? canvas_measure_text(c, text->str, text->size) : 0;\n  if (icon_at == ICON_AT_RIGHT || icon_at == ICON_AT_LEFT) {\n    align_v = style_get_int(style, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    align_h = style_get_int(style, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_LEFT);\n  } else {\n    align_v = style_get_int(style, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    align_h = style_get_int(style, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_CENTER);\n  }\n  canvas_set_text_align(c, (align_h_t)align_h, (align_v_t)align_v);\n\n  if (icon != NULL && widget_load_image(widget, icon, &img) == RET_OK) {\n    float_t dpr = system_info()->device_pixel_ratio;\n\n    if (text->size > 0) {\n      if ((h > (img.h / dpr + font_size) && icon_at == ICON_AT_AUTO)) {\n        icon_at = ICON_AT_TOP;\n      }\n\n      widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer, &r_text,\n                                 &r_icon);\n\n      canvas_draw_icon_in_rect(c, &img, &r_icon);\n      widget_draw_text_in_rect(widget, c, text->str, text->size, &r_text, FALSE);\n    } else {\n      if (icon_at == ICON_AT_AUTO) {\n        widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer, NULL,\n                                   &r_icon);\n      } else {\n        widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer,\n                                   &r_text, &r_icon);\n      }\n      canvas_draw_icon_in_rect(c, &img, &r_icon);\n    }\n  } else if (text != NULL && text->size > 0) {\n    widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, 0, 0, spacer, &r_text, NULL);\n    widget_draw_text_in_rect(widget, c, text->str, text->size, &r_text, FALSE);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_fill_rect(widget_t* widget, canvas_t* c, const rect_t* r, bool_t bg,\n                       image_draw_type_t draw_type) {\n  bitmap_t img;\n  ret_t ret = RET_OK;\n  gradient_t agradient;\n  style_t* style = widget->astyle;\n  uint32_t radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  const char* color_key = bg ? STYLE_ID_BG_COLOR : STYLE_ID_FG_COLOR;\n  const char* image_key = bg ? STYLE_ID_BG_IMAGE : STYLE_ID_FG_IMAGE;\n  rect_t bg_r = rect_init(widget->x, widget->y, widget->w, widget->h);\n  uint32_t radius_tl = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_LEFT, radius);\n  uint32_t radius_tr = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_RIGHT, radius);\n  uint32_t radius_bl = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_LEFT, radius);\n  uint32_t radius_br = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_RIGHT, radius);\n  uint32_t clear_bg = style_get_uint(style, STYLE_ID_CLEAR_BG, 0);\n  const char* draw_type_key = bg ? STYLE_ID_BG_IMAGE_DRAW_TYPE : STYLE_ID_FG_IMAGE_DRAW_TYPE;\n  gradient_t* gradient = style_get_gradient(style, color_key, &agradient);\n  const char* image_name = style_get_str(style, image_key, NULL);\n\n  if (gradient != NULL && r->w > 0 && r->h > 0) {\n    color_t color = gradient_get_first_color(gradient);\n    canvas_set_fill_color(c, color);\n    if (gradient->nr > 1 || color.rgba.a) {\n      if (radius_tl > 3 || radius_tr > 3 || radius_bl > 3 || radius_br > 3) {\n        /*TODO: support gradient*/\n        if (bg) {\n          ret = canvas_fill_rounded_rect_gradient_ex(c, r, NULL, gradient, radius_tl, radius_tr,\n                                                     radius_bl, radius_br);\n        } else {\n          ret = canvas_fill_rounded_rect_gradient_ex(c, r, &bg_r, gradient, radius_tl, radius_tr,\n                                                     radius_bl, radius_br);\n        }\n        if (ret == RET_FAIL) {\n          canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n        }\n      } else if (gradient->nr > 1) {\n        canvas_fill_rect_gradient(c, r->x, r->y, r->w, r->h, gradient);\n      } else {\n        if (clear_bg) {\n          canvas_clear_rect(c, r->x, r->y, r->w, r->h);\n        } else {\n          canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n        }\n      }\n    } else if (clear_bg) {\n      canvas_clear_rect(c, r->x, r->y, r->w, r->h);\n    }\n  }\n\n  if (image_name != NULL && *image_name && r->w > 0 && r->h > 0) {\n    char name[MAX_PATH + 1];\n    const char* region = strrchr(image_name, '#');\n    if (region != NULL) {\n      memset(name, 0x00, sizeof(name));\n      tk_strncpy(name, image_name, region - image_name);\n      image_name = name;\n    }\n\n    if (widget_load_image(widget, image_name, &img) == RET_OK) {\n      draw_type = (image_draw_type_t)style_get_int(style, draw_type_key, draw_type);\n\n      if (region == NULL) {\n        canvas_draw_image_ex(c, &img, draw_type, r);\n      } else {\n        rect_t src;\n        rect_t dst = *r;\n        if (tk_str_eq(region, \"#\")) {\n          src = rect_init(widget->x, widget->y, widget->w, widget->h);\n        } else if (tk_str_eq(region, \"#g\")) {\n          point_t p = {widget->x, widget->y};\n          widget_to_global(widget, &p);\n          src = rect_init(p.x, p.y, widget->w, widget->h);\n        } else {\n          image_region_parse(img.w, img.h, region, &src);\n        }\n\n        canvas_draw_image_ex2(c, &img, draw_type, &src, &dst);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_stroke_border_rect_for_border_type(canvas_t* c, const rect_t* r, color_t bd,\n                                                int32_t border, uint32_t border_width) {\n  wh_t w = r->w;\n  wh_t h = r->h;\n  xy_t x = r->x + 0.5;\n  xy_t y = r->y + 0.5;\n  xy_t y1 = y;\n  wh_t h1 = h;\n  bool_t draw_top = FALSE;\n  bool_t draw_bottom = FALSE;\n  canvas_set_fill_color(c, bd);\n  if (border & BORDER_TOP) {\n    draw_top = TRUE;\n    canvas_fill_rect(c, x, y, w, border_width);\n  }\n  if (border & BORDER_BOTTOM) {\n    draw_bottom = TRUE;\n    canvas_fill_rect(c, x, y + h - border_width, w, border_width);\n  }\n  /* 减少重复绘制的部分，可以修复有透明的时候重叠区域显示不正常为问题 */\n  if (draw_top) {\n    y1 += border_width;\n    h1 -= border_width;\n  }\n  if (draw_bottom) {\n    h1 -= border_width;\n  }\n  if (border & BORDER_LEFT) {\n    canvas_fill_rect(c, x, y1, border_width, h1);\n  }\n  if (border & BORDER_RIGHT) {\n    canvas_fill_rect(c, x + w - border_width, y1, border_width, h1);\n  }\n  return RET_OK;\n}\n\nret_t widget_stroke_border_rect(widget_t* widget, canvas_t* c, const rect_t* r) {\n  style_t* style = widget->astyle;\n  color_t trans = color_init(0, 0, 0, 0);\n  color_t bd = style_get_color(style, STYLE_ID_BORDER_COLOR, trans);\n  uint32_t radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  int32_t border = style_get_int(style, STYLE_ID_BORDER, BORDER_ALL);\n  uint32_t border_width = style_get_int(style, STYLE_ID_BORDER_WIDTH, 1);\n  uint32_t radius_tl = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_LEFT, radius);\n  uint32_t radius_tr = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_RIGHT, radius);\n  uint32_t radius_bl = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_LEFT, radius);\n  uint32_t radius_br = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_RIGHT, radius);\n\n  if (bd.rgba.a) {\n    canvas_set_stroke_color(c, bd);\n    if (radius_tl > 3 || radius_tr > 3 || radius_bl > 3 || radius_br > 3) {\n      if (canvas_stroke_rounded_rect_ex(c, r, NULL, &bd, radius_tl, radius_tr, radius_bl, radius_br,\n                                        border_width, border) != RET_OK) {\n        widget_stroke_border_rect_for_border_type(c, r, bd, border, border_width);\n      }\n    } else {\n      widget_stroke_border_rect_for_border_type(c, r, bd, border, border_width);\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_draw_background(widget_t* widget, canvas_t* c) {\n  rect_t r;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  r = rect_init(0, 0, widget->w, widget->h);\n\n  return widget_fill_rect(widget, c, &r, TRUE, IMAGE_DRAW_CENTER);\n}\n\nret_t widget_fill_bg_rect(widget_t* widget, canvas_t* c, const rect_t* r,\n                          image_draw_type_t draw_type) {\n  return widget_fill_rect(widget, c, r, TRUE, draw_type);\n}\n\nret_t widget_fill_fg_rect(widget_t* widget, canvas_t* c, const rect_t* r,\n                          image_draw_type_t draw_type) {\n  return widget_fill_rect(widget, c, r, FALSE, draw_type);\n}\n\nstatic ret_t widget_draw_border(widget_t* widget, canvas_t* c) {\n  rect_t r;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  r = rect_init(0, 0, widget->w, widget->h);\n  return widget_stroke_border_rect(widget, c, &r);\n}\n\nret_t widget_paint_helper(widget_t* widget, canvas_t* c, const char* icon, wstr_t* text) {\n  if (style_is_valid(widget->astyle)) {\n    widget_draw_icon_text(widget, c, icon, text);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_paint_impl(widget_t* widget, canvas_t* c) {\n  int32_t ox = widget->x;\n  int32_t oy = widget->y;\n  uint8_t save_alpha = c->global_alpha;\n\n  if (widget->opacity < TK_OPACITY_ALPHA) {\n    canvas_set_global_alpha(c, (widget->opacity * save_alpha) / 0xff);\n  }\n\n  if (widget->astyle != NULL) {\n    ox += style_get_int(widget->astyle, STYLE_ID_X_OFFSET, 0);\n    oy += style_get_int(widget->astyle, STYLE_ID_Y_OFFSET, 0);\n  }\n\n  canvas_translate(c, ox, oy);\n  widget_on_paint_begin(widget, c);\n  widget_on_paint_background(widget, c);\n  widget_on_paint_self(widget, c);\n  widget_on_paint_children(widget, c);\n  widget_on_paint_border(widget, c);\n  widget_on_paint_end(widget, c);\n\n  canvas_untranslate(c, ox, oy);\n  if (widget->opacity < TK_OPACITY_ALPHA) {\n    canvas_set_global_alpha(c, save_alpha);\n  }\n\n  widget_on_paint_done(widget, c);\n\n  return RET_OK;\n}\n\nret_t widget_paint(widget_t* widget, canvas_t* c) {\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  if (!widget->visible || widget->opacity <= 0x08 || widget->w <= 0 || widget->h <= 0) {\n    widget->dirty = FALSE;\n    return RET_OK;\n  }\n\n  if (widget->need_update_style) {\n    widget_update_style(widget);\n  }\n\n  canvas_save(c);\n  widget_paint_impl(widget, c);\n  canvas_restore(c);\n\n  widget->dirty = FALSE;\n\n  return RET_OK;\n}\n\nstatic const widget_cmd_t s_widget_cmds[] = {\n    {WIDGET_EXEC_START_ANIMATOR, widget_start_animator},\n    {WIDGET_EXEC_STOP_ANIMATOR, widget_stop_animator},\n    {WIDGET_EXEC_PAUSE_ANIMATOR, widget_pause_animator},\n    {WIDGET_EXEC_DESTROY_ANIMATOR, widget_destroy_animator}};\n\nstatic ret_t widget_do_exec(widget_t* widget, const char* cmd, const char* args) {\n  uint32_t i = 0;\n\n  for (i = 0; i < ARRAY_SIZE(s_widget_cmds); i++) {\n    const widget_cmd_t* iter = s_widget_cmds + i;\n    if (tk_str_eq(cmd, iter->name)) {\n      return iter->exec(widget, args);\n    }\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t widget_exec(widget_t* widget, const char* str) {\n  if (str != NULL) {\n    char cmd[TK_NAME_LEN + 1] = {0};\n    const char* args = strchr(str, ':');\n\n    if (args != NULL) {\n      return_value_if_fail((args - str) < TK_NAME_LEN, RET_BAD_PARAMS);\n      tk_strncpy(cmd, str, args - str);\n      args += 1;\n    } else {\n      return_value_if_fail(strlen(str) < TK_NAME_LEN, RET_BAD_PARAMS);\n      tk_strcpy(cmd, str);\n    }\n\n    return widget_do_exec(widget, cmd, args);\n  } else {\n    return RET_NOT_FOUND;\n  }\n}\n\nstatic widget_t* widget_get_top_widget_grab_key(widget_t* widget) {\n  return_value_if_fail(widget != NULL, NULL);\n  WIDGET_FOR_EACH_CHILD_BEGIN_R(widget, iter, i)\n  value_t v;\n  widget_t* widget_grab_key = widget_get_top_widget_grab_key(iter);\n  if (widget_grab_key == NULL && iter != NULL && iter->visible && iter->custom_props != NULL) {\n    ret_t ret = tk_object_get_prop(iter->custom_props, WIDGET_PROP_GRAB_KEYS, &v);\n    if (ret == RET_OK && value_bool(&v)) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nstatic ret_t widget_on_ungrab_keys(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  window_manager_t* wm = WINDOW_MANAGER(widget_get_window_manager(widget));\n\n  wm->widget_grab_key = widget_get_top_widget_grab_key(WIDGET(wm));\n\n  return RET_REMOVE;\n}\n\nstatic ret_t widget_exec_code(void* ctx, event_t* evt) {\n#ifndef WITHOUT_FSCRIPT\n  value_t v;\n  value_t result;\n  ret_t ret = RET_OK;\n  tk_object_t* obj = NULL;\n  widget_t* widget = WIDGET(evt->target);\n  const char* code = (const char*)ctx;\n  if (widget_get_prop(widget, STR_PROP_MODEL, &v) == RET_OK) {\n    obj = value_object(&v);\n  }\n  if (obj != NULL) {\n    TK_OBJECT_REF(obj);\n  } else {\n    obj = object_default_create();\n  }\n  return_value_if_fail(obj != NULL && code != NULL, RET_REMOVE);\n\n  tk_object_set_prop_pointer(obj, STR_PROP_SELF, widget);\n\n  switch (evt->type) {\n    case EVT_CLICK:\n    case EVT_POINTER_DOWN:\n    case EVT_POINTER_MOVE:\n    case EVT_POINTER_UP: {\n      pointer_event_t* e = pointer_event_cast(evt);\n      tk_object_set_prop_int(obj, \"x\", e->x);\n      tk_object_set_prop_int(obj, \"y\", e->y);\n      tk_object_set_prop_bool(obj, \"alt\", e->alt);\n      tk_object_set_prop_bool(obj, \"cmd\", e->cmd);\n      tk_object_set_prop_bool(obj, \"menu\", e->menu);\n      tk_object_set_prop_bool(obj, \"ctrl\", e->ctrl);\n      break;\n    }\n    case EVT_KEY_DOWN:\n    case EVT_KEY_LONG_PRESS:\n    case EVT_KEY_UP: {\n      key_event_t* e = key_event_cast(evt);\n      const key_type_value_t* kv = keys_type_find_by_value(e->key);\n      if (kv != NULL) {\n        tk_object_set_prop_str(obj, \"key\", kv->name);\n      } else {\n        tk_object_set_prop_str(obj, \"key\", \"unkown\");\n      }\n      tk_object_set_prop_bool(obj, \"alt\", e->alt);\n      tk_object_set_prop_bool(obj, \"cmd\", e->cmd);\n      tk_object_set_prop_bool(obj, \"menu\", e->menu);\n      tk_object_set_prop_bool(obj, \"ctrl\", e->ctrl);\n      break;\n    }\n    default:\n      break;\n  }\n\n  value_set_int(&result, 0);\n  fscript_eval(obj, code, &result);\n  if (tk_object_get_prop_bool(obj, \"RET_STOP\", FALSE)) {\n    ret = RET_STOP;\n  }\n  if (tk_object_get_prop_bool(obj, \"RET_REMOVE\", FALSE)) {\n    ret = RET_REMOVE;\n  }\n  value_reset(&result);\n  TK_OBJECT_UNREF(obj);\n\n  return ret;\n#else\n  return RET_OK;\n#endif\n}\n\nstatic ret_t widget_free_code(void* ctx, event_t* evt) {\n  widget_t* widget = WIDGET(evt->target);\n  widget_off_by_ctx(widget, ctx);\n  TKMEM_FREE(ctx);\n\n  return RET_REMOVE;\n}\n\n#define STR_ANIMATE_PREFIX \"animate:\"\n#define TK_ANIMATING_TIME 500 /* 单位：毫秒（ms） */\nret_t widget_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  ret_t ret = RET_OK;\n  prop_change_event_t e;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_EXEC)) {\n    ret = widget_exec(widget, value_str(v));\n    if (ret != RET_NOT_FOUND) {\n      return ret;\n    }\n  }\n\n  e.value = v;\n  e.name = name;\n  e.e = event_init(EVT_PROP_WILL_CHANGE, widget);\n  widget_dispatch(widget, (event_t*)&e);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    widget_set_x(widget, (xy_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    widget_set_y(widget, (xy_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    widget_set_w(widget, (wh_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    widget_set_h(widget, (wh_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    widget->opacity = (uint8_t)value_int(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    widget_set_visible(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    widget->sensitive = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    widget->floating = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    widget->focusable = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    widget->with_focus_state = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    widget->dirty_rect_tolerance = value_int(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    const char* name = value_str(v);\n    return widget_use_style(widget, name);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    widget_set_enable(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    widget->feedback = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    widget_set_auto_adjust_size(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    widget_set_name(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_TR_TEXT)) {\n    widget_set_tr_text(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    widget_set_animation(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    widget_set_self_layout(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_LAYOUT) || tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    widget_set_children_layout(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_POINTER_CURSOR)) {\n    widget_set_pointer_cursor(widget, value_str(v));\n  } else {\n    ret = RET_NOT_FOUND;\n  }\n\n  if (widget->vt->set_prop) {\n    if (tk_str_start_with(name, STR_ANIMATE_PREFIX)) {\n      return widget_animate_prop_float_to(widget, name + strlen(STR_ANIMATE_PREFIX),\n                                          value_float32(v), TK_ANIMATING_TIME);\n    } else {\n      ret_t ret1 = widget->vt->set_prop(widget, name, v);\n      if (ret == RET_NOT_FOUND) {\n        ret = ret1;\n      }\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_FOCUSED) || tk_str_eq(name, WIDGET_PROP_FOCUS)) {\n      widget_set_focused(widget, value_bool(v));\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n      wstr_from_value(&(widget->text), v);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_EXEC)) {\n      ret = RET_NOT_FOUND;\n    } else if (tk_str_start_with(name, \"style:\") || tk_str_start_with(name, \"style.\")) {\n      return widget_set_style(widget, name + 6, v);\n    } else {\n      if (widget->custom_props == NULL) {\n        widget->custom_props = object_default_create();\n      }\n\n      if (tk_str_eq(name, WIDGET_PROP_GRAB_KEYS)) {\n        window_manager_t* wm = WINDOW_MANAGER(widget_get_window_manager(widget));\n\n        if (value_bool(v)) {\n          widget_on(widget, EVT_DESTROY, widget_on_ungrab_keys, widget);\n          wm->widget_grab_key = widget;\n        }\n      }\n\n      if (strncmp(name, STR_ON_EVENT_PREFIX, sizeof(STR_ON_EVENT_PREFIX) - 1) == 0) {\n        int32_t etype = event_from_name(name + sizeof(STR_ON_EVENT_PREFIX) - 1);\n        if (etype != EVT_NONE) {\n          char* code = tk_strdup(value_str(v));\n          if (code != NULL) {\n            name += sizeof(STR_ON_EVENT_PREFIX) - 1;\n            if (strncmp(name, STR_GLOBAL_EVENT_PREFIX, sizeof(STR_GLOBAL_EVENT_PREFIX) - 1) == 0) {\n              widget_t* wm = window_manager();\n              widget_on(wm, etype, widget_exec_code, code);\n              widget_on(wm, EVT_DESTROY, widget_free_code, code);\n            } else {\n              widget_on(widget, etype, widget_exec_code, code);\n              widget_on(widget, EVT_DESTROY, widget_free_code, code);\n            }\n            ret = RET_OK;\n          }\n        } else {\n          log_debug(\"not found event %s\\n\", name);\n        }\n      } else {\n        ret = tk_object_set_prop(widget->custom_props, name, v);\n      }\n    }\n  }\n\n  if (ret != RET_NOT_FOUND) {\n    e.e.type = EVT_PROP_CHANGED;\n    widget_dispatch(widget, (event_t*)&e);\n    widget_invalidate(widget, NULL);\n  }\n\n  return ret;\n}\n\nret_t widget_get_prop(widget_t* widget, const char* name, value_t* v) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    value_set_int32(v, widget->x);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    value_set_int32(v, widget->y);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    value_set_int32(v, widget->w);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    value_set_int32(v, widget->h);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    value_set_int32(v, widget->opacity);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    value_set_bool(v, widget->visible);\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    value_set_bool(v, widget->sensitive);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    value_set_bool(v, widget->floating);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    value_set_bool(v, widget_is_focusable(widget));\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSED)) {\n    value_set_bool(v, widget->focused);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    value_set_bool(v, widget->with_focus_state);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    value_set_int(v, widget->dirty_rect_tolerance);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    value_set_str(v, widget->style);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    value_set_bool(v, widget->enable);\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    value_set_bool(v, widget->feedback);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    value_set_bool(v, widget->auto_adjust_size);\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    value_set_str(v, widget->name);\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    value_set_str(v, widget->animation);\n  } else if (tk_str_eq(name, WIDGET_PROP_POINTER_CURSOR)) {\n    value_set_str(v, widget->pointer_cursor);\n  } else if (tk_str_eq(name, WIDGET_PROP_LOADING)) {\n    value_set_bool(v, widget->loading);\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    if (widget->self_layout != NULL) {\n      value_set_str(v, self_layouter_to_string(widget->self_layout));\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  } else if (tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    if (widget->children_layout != NULL) {\n      value_set_str(v, children_layouter_to_string(widget->children_layout));\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  } else {\n    if (widget->vt->get_prop) {\n      ret = widget->vt->get_prop(widget, name, v);\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  }\n\n  /*default*/\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_LAYOUT_W)) {\n      value_set_int32(v, widget->w);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_LAYOUT_H)) {\n      value_set_int32(v, widget->h);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n      wchar_t* text = widget->text.str;\n      if (text != NULL) {\n        text[widget->text.size] = 0;\n      }\n      value_set_wstr(v, text);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_STATE_FOR_STYLE)) {\n      value_set_str(v, widget_get_state_for_style(widget, FALSE, FALSE));\n      ret = RET_OK;\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (widget->custom_props != NULL) {\n      ret = tk_object_get_prop(widget->custom_props, name, v);\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_TYPE)) {\n      value_set_str(v, widget->vt->type);\n      ret = RET_OK;\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_set_prop_str(widget_t* widget, const char* name, const char* str) {\n  value_t v;\n  value_set_str(&v, str);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nconst char* widget_get_prop_str(widget_t* widget, const char* name, const char* defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_str(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_pointer(widget_t* widget, const char* name, void* pointer) {\n  value_t v;\n  value_set_pointer(&v, pointer);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nvoid* widget_get_prop_pointer(widget_t* widget, const char* name) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_pointer(&v);\n  } else {\n    return NULL;\n  }\n}\n\nret_t widget_set_prop_float(widget_t* widget, const char* name, float_t num) {\n  value_t v;\n  value_set_float32(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nfloat_t widget_get_prop_float(widget_t* widget, const char* name, float_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_float32(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_int(widget_t* widget, const char* name, int32_t num) {\n  value_t v;\n  value_set_int(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nint32_t widget_get_prop_int(widget_t* widget, const char* name, int32_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_int(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_bool(widget_t* widget, const char* name, bool_t num) {\n  value_t v;\n  value_set_bool(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nbool_t widget_get_prop_bool(widget_t* widget, const char* name, bool_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_bool(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_on_paint_background(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_background) {\n    ret = widget->vt->on_paint_background(widget, c);\n  } else {\n    if (style_is_valid(widget->astyle)) {\n      widget_draw_background(widget, c);\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_self(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_self) {\n    ret = widget->vt->on_paint_self(widget, c);\n  } else {\n    paint_event_t e;\n    widget_dispatch(widget, paint_event_init(&e, EVT_PAINT, widget, c));\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_children(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_children) {\n    ret = widget->vt->on_paint_children(widget, c);\n  } else {\n    ret = widget_on_paint_children_default(widget, c);\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_border(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_border) {\n    ret = widget->vt->on_paint_border(widget, c);\n  } else {\n    if (style_is_valid(widget->astyle)) {\n      ret = widget_draw_border(widget, c);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_begin(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_begin) {\n    ret = widget->vt->on_paint_begin(widget, c);\n  }\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_BEFORE_PAINT, widget, c));\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_done(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_PAINT_DONE, widget, c));\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_end(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_end) {\n    ret = widget->vt->on_paint_end(widget, c);\n  }\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_AFTER_PAINT, widget, c));\n\n  return ret;\n}\n\nret_t widget_dispatch_to_target(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  e->target = widget;\n  widget_dispatch(widget, e);\n\n  if (widget->target) {\nret = ",
    "raw_res": "",
    "prompt_res": "widget_dispatch_to_target(widget->target, e);",
    "gt": "widget_dispatch_to_target(widget->target, e);"
  },
  {
    "id": 2482,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/widget.c",
    "input": "﻿/**\n * File:   widget.c\n * Author: AWTK Develop Team\n * Brief:  basic class of all widget\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-13 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/fscript.h\"\n#include \"tkc/tokenizer.h\"\n#include \"tkc/color_parser.h\"\n#include \"tkc/object_default.h\"\n\n#include \"base/keys.h\"\n#include \"base/enums.h\"\n#include \"base/theme.h\"\n#include \"tkc/time_now.h\"\n#include \"base/idle.h\"\n#include \"base/widget.h\"\n#include \"base/layout.h\"\n#include \"native_window.h\"\n#include \"base/main_loop.h\"\n#include \"base/ui_feedback.h\"\n#include \"base/system_info.h\"\n#include \"base/window_manager.h\"\n#include \"base/widget_vtable.h\"\n#include \"base/style_mutable.h\"\n#include \"base/style_factory.h\"\n#include \"base/widget_animator_manager.h\"\n#include \"base/widget_animator_factory.h\"\n#include \"base/window_base.h\"\n#include \"blend/image_g2d.h\"\n\nret_t widget_focus_up(widget_t* widget);\nret_t widget_focus_down(widget_t* widget);\nret_t widget_focus_left(widget_t* widget);\nret_t widget_focus_right(widget_t* widget);\nstatic ret_t widget_unref_async(widget_t* widget);\nstatic ret_t widget_ensure_style_mutable(widget_t* widget);\nstatic ret_t widget_dispatch_blur_event(widget_t* widget);\n/*虚函数的包装*/\nstatic ret_t widget_on_paint_done(widget_t* widget, canvas_t* c);\nstatic ret_t widget_on_paint_begin(widget_t* widget, canvas_t* c);\nstatic ret_t widget_on_paint_end(widget_t* widget, canvas_t* c);\n\ntypedef widget_t* (*widget_find_wanted_focus_widget_t)(widget_t* widget, darray_t* all_focusable);\nstatic ret_t widget_move_focus(widget_t* widget, widget_find_wanted_focus_widget_t find);\n\n#define widget_set_xywh(widget, val, update_layout, invalidate)    \\\n  do {                                                             \\\n    if (widget->val != val) {                                      \\\n      if (invalidate) widget_invalidate_force(widget, NULL);       \\\n      widget->val = val;                                           \\\n      if (invalidate) widget_invalidate_force(widget, NULL);       \\\n    }                                                              \\\n    if (update_layout && widget->self_layout != NULL) {            \\\n      self_layouter_set_param_str(widget->self_layout, #val, \"n\"); \\\n    }                                                              \\\n  } while (0)\n\nstatic ret_t widget_set_x(widget_t* widget, xy_t x, bool_t update_layout) {\n  widget_set_xywh(widget, x, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_y(widget_t* widget, xy_t y, bool_t update_layout) {\n  widget_set_xywh(widget, y, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_w(widget_t* widget, wh_t w, bool_t update_layout) {\n  widget_set_xywh(widget, w, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_h(widget_t* widget, xy_t h, bool_t update_layout) {\n  widget_set_xywh(widget, h, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic bool_t widget_is_strongly_focus(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n  if (win != NULL) {\n    return WINDOW_BASE(win)->strongly_focus;\n  } else {\n    return FALSE;\n  }\n}\n\nret_t widget_set_need_update_style(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (!widget->need_update_style) {\n    widget_invalidate_force(widget, NULL);\n  }\n\n  widget->need_update_style = TRUE;\n\n  return RET_OK;\n}\n\nret_t widget_update_style_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_update_style(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_update_style_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_set_need_update_style_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_need_update_style(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_set_need_update_style_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_update_style(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->astyle != NULL, RET_BAD_PARAMS);\n\n  if (widget->need_update_style) {\n    widget->need_update_style = FALSE;\n    return style_notify_widget_state_changed(widget->astyle, widget);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_real_destroy(widget_t* widget) {\n  ENSURE(widget->ref_count == 1);\n\n  if (widget->vt->on_destroy) {\n    widget->vt->on_destroy(widget);\n  }\n\n  TKMEM_FREE(widget->name);\n  TKMEM_FREE(widget->state);\n  TKMEM_FREE(widget->style);\n  TKMEM_FREE(widget->tr_text);\n  TKMEM_FREE(widget->animation);\n  TKMEM_FREE(widget->pointer_cursor);\n  TK_OBJECT_UNREF(widget->custom_props);\n  wstr_reset(&(widget->text));\n  style_destroy(widget->astyle);\n\n  memset(widget, 0x00, sizeof(widget_t));\n  TKMEM_FREE(widget);\n\n  return RET_OK;\n}\n\nstatic widget_t* widget_real_create(const widget_vtable_t* vt) {\n  widget_t* widget = TKMEM_ALLOC(vt->size);\n  return_value_if_fail(widget != NULL, NULL);\n\n  memset(widget, 0x00, vt->size);\n  widget->vt = vt;\n\n  return widget;\n}\n\nstatic bool_t widget_is_scrollable(widget_t* widget) {\n  return widget != NULL && widget->vt != NULL && widget->vt->scrollable;\n}\n\nstatic bool_t widget_with_focus_state(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n  value_set_bool(&v, FALSE);\n  widget_get_prop(widget, WIDGET_PROP_WITH_FOCUS_STATE, &v);\n\n  return value_bool(&v);\n}\n\nbool_t widget_is_focusable(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  if (!widget->visible || !widget->sensitive || !widget->enable) {\n    return FALSE;\n  }\n\n  return widget->focusable || widget->vt->focusable;\n}\n\nret_t widget_move(widget_t* widget, xy_t x, xy_t y) {\n  event_t e = event_init(EVT_WILL_MOVE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->x != x || widget->y != y) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, x, TRUE, FALSE);\n    widget_set_xywh(widget, y, TRUE, FALSE);\n    widget_invalidate_force(widget, NULL);\n\n    e.type = EVT_MOVE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_to_center(widget_t* widget) {\n  int32_t x = 0;\n  int32_t y = 0;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, RET_BAD_PARAMS);\n\n  x = (widget->parent->w - widget->w) / 2;\n  y = (widget->parent->h - widget->h) / 2;\n\n  return widget_move(widget, x, y);\n}\n\nret_t widget_resize(widget_t* widget, wh_t w, wh_t h) {\n  event_t e = event_init(EVT_WILL_RESIZE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->w != w || widget->h != h) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, w, TRUE, FALSE);\n    widget_set_xywh(widget, h, TRUE, FALSE);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget);\n\n    e.type = EVT_RESIZE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_resize_ex(widget_t* widget, xy_t x, xy_t y, wh_t w, wh_t h,\n                            bool_t update_layout) {\n  event_t e = event_init(EVT_WILL_MOVE_RESIZE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->x != x || widget->y != y || widget->w != w || widget->h != h) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, x, update_layout, FALSE);\n    widget_set_xywh(widget, y, update_layout, FALSE);\n    widget_set_xywh(widget, w, update_layout, FALSE);\n    widget_set_xywh(widget, h, update_layout, FALSE);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget);\n\n    e.type = EVT_MOVE_RESIZE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_resize(widget_t* widget, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return widget_move_resize_ex(widget, x, y, w, h, TRUE);\n}\n\nfloat_t widget_get_value(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_VALUE, &v) == RET_OK ? value_float32(&v) : 0.0f;\n}\n\nret_t widget_set_value(widget_t* widget, float_t value) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_VALUE, value_set_float32(&v, value));\n}\n\nret_t widget_add_value(widget_t* widget, float_t delta) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_value(widget, widget_get_value(widget) + delta);\n}\n\nint32_t widget_get_value_int(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_VALUE, &v) == RET_OK ? value_int(&v) : 0;\n}\n\nret_t widget_set_value_int(widget_t* widget, int32_t value) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_VALUE, value_set_int(&v, value));\n}\n\nret_t widget_add_value_int(widget_t* widget, int32_t delta) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_value_int(widget, widget_get_value_int(widget) + delta);\n}\n\nstatic ret_t widget_animate_prop_float_to(widget_t* widget, const char* name, float_t value,\n                                          uint32_t duration) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL, RET_BAD_PARAMS);\n  if (duration == 0) {\n    ret = widget_set_prop_float(widget, name, value);\n  } else {\n    float_t prev_value = widget_get_prop_float(widget, name, 0.0f);\n    widget_destroy_animator(widget, name);\n\n    if (prev_value != value) {\n      char params[128] = {0};\n      tk_snprintf(params, sizeof(params) - 1, \"%s(from=%f,to=%f,duration=%d)\", name, prev_value,\n                  value, duration);\n      ret = widget_create_animator(widget, params);\n    }\n  }\n  return ret;\n}\n\nret_t widget_animate_value_to(widget_t* widget, float_t value, uint32_t duration) {\n  return widget_animate_prop_float_to(widget, WIDGET_PROP_VALUE, value, duration);\n}\n\nbool_t widget_is_window_opened(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n    return WINDOW_STAGE_OPENED == stage || WINDOW_STAGE_SUSPEND == stage;\n  } else {\n    return FALSE;\n  }\n}\n\nbool_t widget_is_window_created(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n    return WINDOW_STAGE_OPENED == stage || WINDOW_STAGE_SUSPEND == stage ||\n           WINDOW_STAGE_LOADED == stage || WINDOW_STAGE_CREATED == stage;\n  } else {\n    return FALSE;\n  }\n}\n\nret_t widget_get_window_theme(widget_t* widget, theme_t** win_theme, theme_t** default_theme) {\n  value_t v;\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    if (widget_get_prop(win, WIDGET_PROP_THEME_OBJ, &v) == RET_OK) {\n      *win_theme = (theme_t*)value_pointer(&v);\n    }\n\n    if (widget_get_prop(win, WIDGET_PROP_DEFAULT_THEME_OBJ, &v) == RET_OK) {\n      *default_theme = (theme_t*)value_pointer(&v);\n    }\n  }\n  return RET_OK;\n}\n\nbool_t widget_is_style_exist(widget_t* widget, const char* style_name, const char* state_name) {\n  const void* data = NULL;\n  const char* style = NULL;\n  const char* state = NULL;\n  theme_t* win_theme = NULL;\n  theme_t* default_theme = NULL;\n  const char* type = widget_get_type(widget);\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(widget != NULL && win != NULL, FALSE);\n\n  if (style_name == NULL || *style_name == 0) {\n    style = TK_DEFAULT_STYLE;\n  } else {\n    style = style_name;\n  }\n\n  if (state_name == NULL || *state_name == 0) {\n    state = WIDGET_STATE_NORMAL;\n  } else {\n    state = state_name;\n  }\n\n  return_value_if_fail(widget_get_window_theme(widget, &win_theme, &default_theme) == RET_OK,\n                       FALSE);\n\n  if (win_theme != NULL) {\n    data = theme_find_style(win_theme, type, style, state);\n  }\n\n  if (data == NULL && default_theme != NULL) {\n    data = theme_find_style(default_theme, type, style, state);\n  }\n\n  return data != NULL;\n}\n\nret_t widget_use_style(widget_t* widget, const char* value) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_need_update_style(widget);\n  widget->style = tk_str_copy(widget->style, value);\n\n  if (widget_is_window_opened(widget)) {\n    widget_update_style(widget);\n    return widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_text(widget_t* widget, const wchar_t* text) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_wstr(&v, text));\n}\n\nret_t widget_set_text_utf8(widget_t* widget, const char* text) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_str(&v, text));\n}\n\nret_t widget_get_text_utf8(widget_t* widget, char* text, uint32_t size) {\n  value_t v;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && text != NULL && size > 0, RET_BAD_PARAMS);\n\n  value_set_str(&v, NULL);\n  memset(text, 0x00, size);\n  if (widget_get_prop(widget, WIDGET_PROP_TEXT, &v) == RET_OK) {\n    if (v.type == VALUE_TYPE_STRING) {\n      tk_strncpy(text, value_str(&v), size - 1);\n      ret = RET_OK;\n    } else if (v.type == VALUE_TYPE_WSTRING) {\n      tk_utf8_from_utf16(value_wstr(&v), text, size);\n      ret = RET_OK;\n    }\n  }\n\n  return ret;\n}\n\nimage_manager_t* widget_get_image_manager(widget_t* widget) {\n  image_manager_t* ret = image_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = image_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_IMAGE_MANAGER, &v) == RET_OK) {\n      ret = (image_manager_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nlocale_info_t* widget_get_locale_info(widget_t* widget) {\n  locale_info_t* ret = locale_info();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = locale_info();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_LOCALE_INFO, &v) == RET_OK) {\n      ret = (locale_info_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nassets_manager_t* widget_get_assets_manager(widget_t* widget) {\n  assets_manager_t* am = assets_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, am);\n\n  if (widget->assets_manager != NULL) {\n    return widget->assets_manager;\n  }\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    am = assets_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_ASSETS_MANAGER, &v) == RET_OK) {\n      am = (assets_manager_t*)value_pointer(&v);\n    }\n  }\n  widget->assets_manager = am;\n\n  return am;\n}\n\nfont_manager_t* widget_get_font_manager(widget_t* widget) {\n  font_manager_t* ret = font_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = font_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_FONT_MANAGER, &v) == RET_OK) {\n      ret = (font_manager_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_apply_tr_text_before_paint(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  if (widget->tr_text != NULL) {\n    const char* text = locale_info_tr(widget_get_locale_info(widget), widget->tr_text);\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n  }\n\n  return RET_REMOVE;\n}\n\nret_t widget_set_tr_text(widget_t* widget, const char* text) {\n  const char* tr_text = NULL;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(widget != NULL, RET_OK);\n\n  if (text == NULL || *text == '\\0') {\n    if (widget->tr_text != NULL) {\n      TKMEM_FREE(widget->tr_text);\n      widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n    }\n\n    return RET_OK;\n  }\n\n  widget->tr_text = tk_str_copy(widget->tr_text, text);\n  if (win != NULL) {\n    tr_text = locale_info_tr(widget_get_locale_info(widget), text);\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, tr_text);\n  } else {\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n    widget_on(widget, EVT_BEFORE_PAINT, widget_apply_tr_text_before_paint, widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_re_translate_text(widget_t* widget) {\n  if (widget->vt->on_re_translate != NULL) {\n    widget->vt->on_re_translate(widget);\n  }\n  if (widget->tr_text != NULL) {\n    value_t v;\n    const char* tr_text = locale_info_tr(widget_get_locale_info(widget), widget->tr_text);\n    widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_str(&v, tr_text));\n    widget_invalidate(widget, NULL);\n  }\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_re_translate_text(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nconst wchar_t* widget_get_text(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_TEXT, &v) == RET_OK ? value_wstr(&v) : 0;\n}\n\nret_t widget_set_name(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (name != NULL) {\n    widget->name = tk_str_copy(widget->name, name);\n  } else {\n    TKMEM_FREE(widget->name);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_theme(widget_t* widget, const char* name) {\n  theme_change_event_t will_event;\n  event_t* will_evt = theme_change_event_init(&will_event, EVT_THEME_WILL_CHANGE, name);\n  widget_dispatch(window_manager(), will_evt);\n#ifdef WITH_FS_RES\n  const asset_info_t* info = NULL;\n  theme_change_event_t event;\n  event_t* evt = theme_change_event_init(&event, EVT_THEME_CHANGED, name);\n  widget_t* wm = widget_get_window_manager(widget);\n  font_manager_t* fm = widget_get_font_manager(widget);\n  image_manager_t* imm = widget_get_image_manager(widget);\n  assets_manager_t* am = widget_get_assets_manager(widget);\n  locale_info_t* locale_info = widget_get_locale_info(widget);\n  return_value_if_fail(am != NULL && name != NULL, RET_BAD_PARAMS);\n\n  font_manager_unload_all(fm);\n  image_manager_unload_all(imm);\n  locale_info_reload(locale_info);\n  assets_manager_set_theme(am, name);\n  widget_reset_canvas(widget);\n\n  info = assets_manager_ref(am, ASSET_TYPE_STYLE, \"default\");\n  if (info != NULL) {\n    theme_set(theme_load_from_data(info->name, info->data, info->size));\n    assets_manager_unref(assets_manager(), info);\n  }\n\n  widget_dispatch(wm, evt);\n  widget_invalidate_force(wm, NULL);\n\n  log_debug(\"theme changed: %s\\n\", name);\n#endif\n\n  return RET_OK;\n}\n\nret_t widget_set_pointer_cursor(widget_t* widget, const char* cursor) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (!tk_str_eq(widget->pointer_cursor, cursor)) {\n    widget->pointer_cursor = tk_str_copy(widget->pointer_cursor, cursor);\n    widget_update_pointer_cursor(widget);\n  }\n\n  return RET_OK;\n}\n\n#ifndef WITHOUT_WIDGET_ANIMATORS\nret_t widget_set_animation(widget_t* widget, const char* animation) {\n  return_value_if_fail(widget != NULL && animation != NULL, RET_BAD_PARAMS);\n\n  widget->animation = tk_str_copy(widget->animation, animation);\n\n  return widget_create_animator(widget, animation);\n}\n\nret_t widget_create_animator(widget_t* widget, const char* animation) {\n  tokenizer_t t;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && animation != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(tokenizer_init(&t, animation, strlen(animation), \";\") != NULL, RET_OOM);\n\n  while (tokenizer_has_more(&t)) {\n    const char* params = tokenizer_next(&t);\n    if (widget_animator_create(widget, params) == NULL) {\n      ret = RET_BAD_PARAMS;\n      break;\n    }\n  }\n  tokenizer_deinit(&t);\n  widget_invalidate(widget, NULL);\n\n  return ret;\n}\n\nret_t widget_start_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_start(widget_animator_manager(), widget, name);\n}\n\nret_t widget_set_animator_time_scale(widget_t* widget, const char* name, float_t time_scale) {\n  return widget_animator_manager_set_time_scale(widget_animator_manager(), widget, name,\n                                                time_scale);\n}\n\nret_t widget_pause_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_pause(widget_animator_manager(), widget, name);\n}\n\nwidget_animator_t* widget_find_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_find(widget_animator_manager(), widget, name);\n}\n\nret_t widget_stop_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_stop(widget_animator_manager(), widget, name);\n}\n\nret_t widget_destroy_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_remove_all(widget_animator_manager(), widget, name);\n}\n#else\nret_t widget_start_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nret_t widget_create_animator(widget_t* widget, const char* animation) {\n  return RET_OK;\n}\nret_t widget_set_animation(widget_t* widget, const char* animation) {\n  return RET_OK;\n}\nret_t widget_set_animator_time_scale(widget_t* widget, const char* name, float_t time_scale) {\n  return RET_OK;\n}\nret_t widget_pause_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nwidget_animator_t* widget_find_animator(widget_t* widget, const char* name) {\n  return NULL;\n}\nret_t widget_stop_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nret_t widget_destroy_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\n#endif /*WITHOUT_WIDGET_ANIMATORS*/\n\nret_t widget_set_enable(widget_t* widget, bool_t enable) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->enable != enable) {\n    widget->enable = enable;\n    widget_set_need_update_style_recursive(widget);\n    widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_feedback(widget_t* widget, bool_t feedback) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->feedback = feedback;\n\n  return RET_OK;\n}\n\nret_t widget_set_auto_adjust_size(widget_t* widget, bool_t auto_adjust_size) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->auto_adjust_size = auto_adjust_size;\n  widget_set_need_relayout(widget);\n\n  return RET_OK;\n}\n\nret_t widget_set_floating(widget_t* widget, bool_t floating) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->floating = floating;\n\n  return RET_OK;\n}\n\nret_t widget_set_focused_internal(widget_t* widget, bool_t focused) {\n  widget_t* win = widget_get_window(widget);\n  int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (WINDOW_STAGE_SUSPEND == stage) {\n    log_debug(\"You can not set focus of a widget when window is in background\");\n    return RET_FAIL;\n  }\n\n  if (widget->focused != focused) {\n    widget->focused = focused;\n    widget_set_need_update_style(widget);\n\n    if (focused) {\n      event_t e = event_init(EVT_FOCUS, widget);\n      widget_set_as_key_target(widget);\n\n      widget_dispatch(widget, &e);\n    } else {\n      event_t e = event_init(EVT_BLUR, widget);\n      widget_dispatch(widget, &e);\n      widget_dispatch_blur_event(widget);\n    }\n\n    widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_focused(widget_t* widget, bool_t focused) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_focused_internal(widget, focused);\n  if (focused) {\n    widget_ensure_visible_in_viewport(widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_focusable(widget_t* widget, bool_t focusable) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->focusable = focusable;\n\n  return RET_OK;\n}\n\nret_t widget_set_state(widget_t* widget, const char* state) {\n  return_value_if_fail(widget != NULL && state != NULL, RET_BAD_PARAMS);\n\n  if (!tk_str_eq(widget->state, state)) {\n    widget_invalidate_force(widget, NULL);\n    widget->state = tk_str_copy(widget->state, state);\n    widget_set_need_update_style(widget);\n    widget_invalidate_force(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_state_for_style(widget_t* widget, bool_t active, bool_t checked) {\n  const char* state = WIDGET_STATE_NORMAL;\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, state);\n\n  state = (const char*)(widget->state);\n\n  while (iter != NULL) {\n    if (!iter->enable) {\n      if (active) return WIDGET_STATE_DISABLE_OF_ACTIVE;\n      if (checked) return WIDGET_STATE_DISABLE_OF_CHECKED;\n      return WIDGET_STATE_DISABLE;\n    }\n    iter = iter->parent;\n  }\n\n  if (widget_is_focusable(widget) || widget_with_focus_state(widget)) {\n    if (widget->focused) {\n      if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n        state = WIDGET_STATE_FOCUSED;\n      }\n    } else {\n      if (tk_str_eq(state, WIDGET_STATE_FOCUSED)) {\n        state = WIDGET_STATE_NORMAL;\n      }\n    }\n  }\n\n  if (active) {\n    if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n      state = WIDGET_STATE_NORMAL_OF_ACTIVE;\n    } else if (tk_str_eq(state, WIDGET_STATE_PRESSED)) {\n      state = WIDGET_STATE_PRESSED_OF_ACTIVE;\n    } else if (tk_str_eq(state, WIDGET_STATE_OVER)) {\n      state = WIDGET_STATE_OVER_OF_ACTIVE;\n    } else if (widget_is_focusable(widget) && widget->focused) {\n      state = WIDGET_STATE_FOCUSED_OF_ACTIVE;\n    }\n  } else if (checked) {\n    if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n      state = WIDGET_STATE_NORMAL_OF_CHECKED;\n    } else if (tk_str_eq(state, WIDGET_STATE_PRESSED)) {\n      state = WIDGET_STATE_PRESSED_OF_CHECKED;\n    } else if (tk_str_eq(state, WIDGET_STATE_OVER)) {\n      state = WIDGET_STATE_OVER_OF_CHECKED;\n    } else if (widget_is_focusable(widget) && widget->focused) {\n      state = WIDGET_STATE_FOCUSED_OF_CHECKED;\n    }\n  }\n\n  return state;\n}\n\nret_t widget_set_opacity(widget_t* widget, uint8_t opacity) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->opacity = opacity;\n  widget_invalidate(widget, NULL);\n\n  return RET_OK;\n}\n\nret_t widget_set_dirty_rect_tolerance(widget_t* widget, uint16_t dirty_rect_tolerance) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->dirty_rect_tolerance = dirty_rect_tolerance;\n  widget_invalidate(widget, NULL);\n\n  return RET_OK;\n}\n\nret_t widget_destroy_children(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->children != NULL) {\n    WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n\n    widget_remove_child_prepare(widget, iter);\n    widget_unref(iter);\n\n    widget->children->elms[i] = NULL;\n\n    WIDGET_FOR_EACH_CHILD_END();\n    widget->children->size = 0;\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_style_type(widget_t* widget) {\n  theme_t* win_theme = NULL;\n  theme_t* default_theme = NULL;\n  const char* style_type = THEME_DEFAULT_STYLE_TYPE;\n\n  if (widget_get_window_theme(widget, &win_theme, &default_theme) == RET_OK) {\n    theme_t* t = win_theme != NULL ? win_theme : (default_theme != NULL ? default_theme : theme());\n    if (t != NULL) {\n      style_type = theme_get_style_type(t);\n    }\n  }\n\n  return style_type;\n}\n\nstatic ret_t widget_update_style_object(widget_t* widget) {\n  const char* style_type = widget_get_style_type(widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  if (widget->astyle == NULL) {\n    widget->astyle = style_factory_create_style(style_factory(), style_type);\n    ENSURE(widget->astyle != NULL);\n\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  } else if (widget->astyle != NULL &&\n             !tk_str_eq(style_get_style_type(widget->astyle), style_type)) {\n    style_t* style = style_factory_create_style(style_factory(), style_type);\n    ENSURE(style != NULL);\n    if (style_is_mutable(widget->astyle)) {\n      style_mutable_set_default_style(widget->astyle, style);\n    } else {\n      style_destroy(widget->astyle);\n      widget->astyle = style;\n    }\n\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  }\n  return RET_OK;\n}\n\nstatic ret_t widget_update_style_object_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_update_style_object(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_update_style_object_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_add_child(widget_t* widget, widget_t* child) {\n  event_t e = event_init(EVT_WIDGET_ADD_CHILD, widget);\n  return_value_if_fail(widget != NULL && child != NULL && child->parent == NULL, RET_BAD_PARAMS);\n\n  child->parent = widget;\n\n  if (widget->children == NULL) {\n    widget->children = darray_create(4, NULL, NULL);\n  }\n\n  if (widget->vt->on_add_child) {\n    if (widget->vt->on_add_child(widget, child) == RET_OK) {\n      return RET_OK;\n    }\n  }\n\n  if (child->vt->on_attach_parent) {\n    child->vt->on_attach_parent(child, widget);\n  }\n\n  ENSURE(darray_push(widget->children, child) == RET_OK);\n\n  if (!widget_is_window_manager(widget)) {\n    widget_set_need_relayout_children(widget);\n  }\n\n  if (!(child->initializing) && widget_get_window(child) != NULL) {\n    widget_set_need_update_style_recursive(child);\n    widget_update_style_object_recursive(child);\n  }\n\n  widget_dispatch(widget, &e);\n\n  return RET_OK;\n}\n\nret_t widget_remove_child_prepare(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n\n  if (!widget_is_window_manager(widget)) {\n    widget_set_need_relayout_children(widget);\n  }\n\n  widget_invalidate_force(child, NULL);\n  if (widget->target == child) {\n    widget->target = NULL;\n  }\n\n  if (widget->grab_widget == child) {\n    widget->grab_widget = NULL;\n    widget->grab_widget_count = 0;\n  }\n\n  if (widget->key_target == child) {\n    widget_dispatch_blur_event(widget->key_target);\n    widget->key_target = NULL;\n  }\n\n  if (widget->vt->on_remove_child) {\n    if (widget->vt->on_remove_child(widget, child) == RET_OK) {\n      return RET_OK;\n    }\n  }\n\n  if (child->vt->on_detach_parent) {\n    child->vt->on_detach_parent(child, widget);\n  }\n  child->parent = NULL;\n\n  return RET_OK;\n}\n\nret_t widget_remove_child(widget_t* widget, widget_t* child) {\n  ret_t ret = RET_OK;\n  event_t e = event_init(EVT_WIDGET_REMOVE_CHILD, widget);\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n\n  widget_remove_child_prepare(widget, child);\n  ret = darray_remove(widget->children, child);\n\n  if (ret == RET_OK) {\n    widget_dispatch(widget, &e);\n  }\n\n  return ret;\n}\n\nret_t widget_insert_child(widget_t* widget, uint32_t index, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget_add_child(widget, child) == RET_OK, RET_FAIL);\n\n  return widget_restack(child, index);\n}\n\nret_t widget_restack(widget_t* widget, uint32_t index) {\n  uint32_t i = 0;\n  uint32_t nr = 0;\n  int32_t old_index = 0;\n  widget_t** children = NULL;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, RET_BAD_PARAMS);\n\n  old_index = widget_index_of(widget);\n  nr = widget_count_children(widget->parent);\n  return_value_if_fail(old_index >= 0 && nr > 0, RET_BAD_PARAMS);\n\n  if (index >= nr) {\n    index = nr - 1;\n  }\n\n  if (index == old_index || nr == 1) {\n    return RET_OK;\n  }\n\n  children = (widget_t**)(widget->parent->children->elms);\n  if (index < old_index) {\n    for (i = old_index; i > index; i--) {\n      children[i] = children[i - 1];\n    }\n  } else {\n    for (i = old_index; i < index; i++) {\n      children[i] = children[i + 1];\n    }\n  }\n  children[index] = widget;\n\n  return RET_OK;\n}\n\nstatic widget_t* widget_lookup_child(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL && name != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (iter->name != NULL && tk_str_eq(iter->name, name)) {\n    return iter;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return NULL;\n}\n\nwidget_t* widget_child(widget_t* widget, const char* path) {\n  return widget_lookup_child(widget, path);\n}\n\nwidget_t* widget_get_focused_widget(widget_t* widget) {\n  widget_t* iter = NULL;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(win != NULL, NULL);\n\n  iter = win->key_target;\n  for (iter = win->key_target; iter != NULL; iter = iter->key_target) {\n    if (iter->focusable && iter->focused) {\n      return iter;\n    }\n\n    if (iter->key_target == NULL) {\n      return iter;\n    }\n  }\n\n  return NULL;\n}\n\nstatic widget_t* widget_lookup_all(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL && name != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (iter->name != NULL && tk_str_eq(iter->name, name)) {\n    return iter;\n  } else {\n    iter = widget_lookup_all(iter, name);\n    if (iter != NULL) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nwidget_t* widget_lookup(widget_t* widget, const char* name, bool_t recursive) {\n  if (recursive) {\n    return widget_lookup_all(widget, name);\n  } else {\n    return widget_lookup_child(widget, name);\n  }\n}\n\nstatic widget_t* widget_lookup_by_type_child(widget_t* widget, const char* type) {\n  return_value_if_fail(widget != NULL && type != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (tk_str_eq(iter->vt->type, type)) {\n    return iter;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return NULL;\n}\n\nstatic widget_t* widget_lookup_by_type_all(widget_t* widget, const char* type) {\n  return_value_if_fail(widget != NULL && type != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (tk_str_eq(iter->vt->type, type)) {\n    return iter;\n  } else {\n    iter = widget_lookup_by_type_all(iter, type);\n    if (iter != NULL) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nwidget_t* widget_lookup_by_type(widget_t* widget, const char* type, bool_t recursive) {\n  if (recursive) {\n    return widget_lookup_by_type_all(widget, type);\n  } else {\n    return widget_lookup_by_type_child(widget, type);\n  }\n}\n\nstatic ret_t widget_set_visible_self(widget_t* widget, bool_t visible) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->visible != visible) {\n    widget_invalidate_force(widget, NULL);\n    widget->visible = visible;\n    widget_set_need_update_style(widget);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget->parent);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_sensitive(widget_t* widget, bool_t sensitive) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->sensitive = sensitive;\n\n  return RET_OK;\n}\n\nret_t widget_set_visible_only(widget_t* widget, bool_t visible) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->visible = visible;\n\n  return RET_OK;\n}\n\nret_t widget_set_visible(widget_t* widget, bool_t visible, ...) {\n  return widget_set_visible_self(widget, visible);\n}\n\nwidget_t* widget_find_target(widget_t* widget, xy_t x, xy_t y) {\n  widget_t* ret = NULL;\n  return_value_if_fail(widget != NULL, NULL);\n\n  if (widget->vt && widget->vt->find_target) {\n    ret = widget->vt->find_target(widget, x, y);\n  } else {\n    ret = widget_find_target_default(widget, x, y);\n  }\n\n  return ret;\n}\n\nret_t widget_on_event_before_children(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt && widget->vt->on_event_before_children) {\n    ret = widget->vt->on_event_before_children(widget, e);\n  }\n\n  return ret;\n}\n\nstatic const char* widget_get_pointer_cursor(widget_t* widget) {\n  if (widget->pointer_cursor != NULL) {\n    return widget->pointer_cursor;\n  } else if (widget->vt->pointer_cursor != NULL) {\n    return widget->vt->pointer_cursor;\n  }\n\n  return WIDGET_CURSOR_DEFAULT;\n}\n\nret_t widget_update_pointer_cursor(widget_t* widget) {\n  widget_t* wm = widget_get_window_manager(widget);\n  return_value_if_fail(wm != NULL, RET_BAD_PARAMS);\n\n  return window_manager_set_cursor(wm, widget_get_pointer_cursor(widget));\n}\n\nret_t widget_dispatch(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  if (e->target == NULL) {\n    e->target = widget;\n  }\n\n  if (widget->vt && widget->vt->on_event) {\n    ret = widget->vt->on_event(widget, e);\n  } else {\n    ret = widget_on_event_default(widget, e);\n  }\n\n  if (ret != RET_STOP) {\n    if (widget->emitter != NULL) {\n      void* saved_target = e->target;\n\n      e->target = widget;\n      ret = emitter_dispatch(widget->emitter, e);\n      e->target = saved_target;\n    }\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t dispatch_in_idle(const idle_info_t* info) {\n  event_t* e = (event_t*)(info->ctx);\n  widget_t* widget = WIDGET(e->target);\n\n  widget_dispatch(widget, e);\n  widget_unref(widget);\n  event_destroy(e);\n\n  return RET_REMOVE;\n}\n\nret_t widget_dispatch_async(widget_t* widget, event_t* e) {\n  event_t* evt = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(e->target == widget, RET_BAD_PARAMS);\n\n  evt = event_clone(e);\n  return_value_if_fail(evt != NULL, RET_OOM);\n\n  widget_ref(widget);\n  idle_add(dispatch_in_idle, evt);\n\n  return RET_OK;\n}\n\nstatic ret_t widget_dispatch_callback(void* ctx, const void* data) {\n  widget_t* widget = WIDGET(data);\n\n  return widget_dispatch(widget, (event_t*)ctx);\n}\n\nret_t widget_dispatch_recursive(widget_t* widget, event_t* e) {\n  return widget_foreach(widget, widget_dispatch_callback, e);\n}\n\nuint32_t widget_on_with_tag(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx,\n                            uint32_t tag) {\n  return_value_if_fail(widget != NULL && on_event != NULL, RET_BAD_PARAMS);\n  if (widget->emitter == NULL) {\n    widget->emitter = emitter_create();\n  }\n\n  return emitter_on_with_tag(widget->emitter, type, on_event, ctx, tag);\n}\n\nuint32_t widget_on(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx) {\n  return widget_on_with_tag(widget, type, on_event, ctx, 0);\n}\n\nuint32_t widget_child_on(widget_t* widget, const char* name, uint32_t type, event_func_t on_event,\n                         void* ctx) {\n  return widget_on(widget_lookup(widget, name, TRUE), type, on_event, ctx);\n}\n\nret_t widget_off(widget_t* widget, uint32_t id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->emitter != NULL, RET_BAD_PARAMS);\n\n  return emitter_off(widget->emitter, id);\n}\n\nret_t widget_off_by_tag(widget_t* widget, uint32_t tag) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_tag(widget->emitter, tag);\n}\n\nret_t widget_off_by_ctx(widget_t* widget, void* ctx) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_ctx(widget->emitter, ctx);\n}\n\nret_t widget_off_by_func(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx) {\n  return_value_if_fail(widget != NULL && on_event != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_func(widget->emitter, type, on_event, ctx);\n}\n\nret_t widget_calc_icon_text_rect(const rect_t* ir, int32_t font_size, float_t text_size,\n                                 int32_t icon_at, uint32_t img_w, uint32_t img_h, int32_t spacer,\n                                 rect_t* r_text, rect_t* r_icon) {\n  return_value_if_fail(ir != NULL && (r_text != NULL || r_icon != NULL), RET_BAD_PARAMS);\n\n  if (r_icon == NULL) {\n    *r_text = *ir;\n\n    return RET_OK;\n  }\n\n  if (r_text == NULL) {\n    *r_icon = *ir;\n\n    return RET_OK;\n  }\n\n  return_value_if_fail(spacer < ir->h && spacer < ir->w, RET_BAD_PARAMS);\n  switch (icon_at) {\n    case ICON_AT_CENTRE: {\n      int32_t w = ir->w - spacer - text_size - img_w;\n      int32_t icon_h = ir->h - img_h;\n      *r_text = rect_init(ir->x + img_w + spacer + w / 2, ir->y, text_size, ir->h);\n      *r_icon = rect_init(ir->x + w / 2, ir->y + icon_h / 2, img_w, img_h);\n      break;\n    }\n    case ICON_AT_RIGHT: {\n      uint32_t w = img_w;\n      float_t ratio = system_info()->device_pixel_ratio;\n      if (ratio > 1) {\n        w = img_w / ratio;\n      }\n      w = tk_min(tk_max(w, ir->h), ir->w);\n      *r_icon = rect_init(ir->x + ir->w - w, ir->y, w, ir->h);\n      *r_text = rect_init(ir->x, ir->y, ir->w - ir->h - spacer, ir->h);\n      break;\n    }\n    case ICON_AT_TOP: {\n      int32_t icon_h = ir->h - font_size - spacer;\n      *r_icon = rect_init(ir->x, ir->y, ir->w, icon_h);\n      *r_text = rect_init(ir->x, icon_h + spacer, ir->w, font_size);\n      break;\n    }\n    case ICON_AT_BOTTOM: {\n      int32_t icon_h = ir->h - font_size - spacer;\n      *r_icon = rect_init(ir->x, ir->y + ir->h - icon_h, ir->w, icon_h);\n      *r_text = rect_init(ir->x, ir->y, ir->w, font_size);\n      break;\n    }\n    case ICON_AT_LEFT:\n    default: {\n      *r_icon = rect_init(ir->x, ir->y, ir->h, ir->h);\n      *r_text = rect_init(ir->x + ir->h + spacer, ir->y, ir->w - ir->h - spacer, ir->h);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_bidi(widget_t* widget) {\n  value_t v;\n  if (widget_get_prop(widget, WIDGET_PROP_BIDI, &v) == RET_OK) {\n    return value_str(&v);\n  }\n\n  return NULL;\n}\n\nret_t widget_draw_icon_text(widget_t* widget, canvas_t* c, const char* icon, wstr_t* text) {\n  rect_t ir;\n  wh_t w = 0;\n  wh_t h = 0;\n  bitmap_t img;\n  rect_t r_icon;\n  rect_t r_text;\n  int32_t margin = 0;\n  int32_t spacer = 0;\n  int32_t icon_at = 0;\n  uint16_t font_size = 0;\n  float_t text_size = 0.0f;\n  int32_t margin_left = 0;\n  int32_t margin_right = 0;\n  int32_t margin_top = 0;\n  int32_t margin_bottom = 0;\n  style_t* style = widget->astyle;\n  int32_t align_h = ALIGN_H_LEFT;\n  int32_t align_v = ALIGN_V_MIDDLE;\n  return_value_if_fail(widget->astyle != NULL, RET_BAD_PARAMS);\n\n  spacer = style_get_int(style, STYLE_ID_SPACER, 2);\n  margin = style_get_int(style, STYLE_ID_MARGIN, 0);\n  margin_top = style_get_int(style, STYLE_ID_MARGIN_TOP, margin);\n  margin_left = style_get_int(style, STYLE_ID_MARGIN_LEFT, margin);\n  margin_right = style_get_int(style, STYLE_ID_MARGIN_RIGHT, margin);\n  margin_bottom = style_get_int(style, STYLE_ID_MARGIN_BOTTOM, margin);\n  icon_at = style_get_int(style, STYLE_ID_ICON_AT, ICON_AT_AUTO);\n\n  w = widget->w - margin_left - margin_right;\n  h = widget->h - margin_top - margin_bottom;\n  ir = rect_init(margin_left, margin_top, w, h);\n\n  if (text == NULL) {\n    text = &(widget->text);\n  }\n\n  if (icon == NULL) {\n    icon = style_get_str(style, STYLE_ID_ICON, NULL);\n  }\n\n  widget_prepare_text_style(widget, c);\n\n  font_size = c->font_size;\n  text_size = text->str ? canvas_measure_text(c, text->str, text->size) : 0;\n  if (icon_at == ICON_AT_RIGHT || icon_at == ICON_AT_LEFT) {\n    align_v = style_get_int(style, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    align_h = style_get_int(style, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_LEFT);\n  } else {\n    align_v = style_get_int(style, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    align_h = style_get_int(style, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_CENTER);\n  }\n  canvas_set_text_align(c, (align_h_t)align_h, (align_v_t)align_v);\n\n  if (icon != NULL && widget_load_image(widget, icon, &img) == RET_OK) {\n    float_t dpr = system_info()->device_pixel_ratio;\n\n    if (text->size > 0) {\n      if ((h > (img.h / dpr + font_size) && icon_at == ICON_AT_AUTO)) {\n        icon_at = ICON_AT_TOP;\n      }\n\n      widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer, &r_text,\n                                 &r_icon);\n\n      canvas_draw_icon_in_rect(c, &img, &r_icon);\n      widget_draw_text_in_rect(widget, c, text->str, text->size, &r_text, FALSE);\n    } else {\n      if (icon_at == ICON_AT_AUTO) {\n        widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer, NULL,\n                                   &r_icon);\n      } else {\n        widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer,\n                                   &r_text, &r_icon);\n      }\n      canvas_draw_icon_in_rect(c, &img, &r_icon);\n    }\n  } else if (text != NULL && text->size > 0) {\n    widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, 0, 0, spacer, &r_text, NULL);\n    widget_draw_text_in_rect(widget, c, text->str, text->size, &r_text, FALSE);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_fill_rect(widget_t* widget, canvas_t* c, const rect_t* r, bool_t bg,\n                       image_draw_type_t draw_type) {\n  bitmap_t img;\n  ret_t ret = RET_OK;\n  gradient_t agradient;\n  style_t* style = widget->astyle;\n  uint32_t radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  const char* color_key = bg ? STYLE_ID_BG_COLOR : STYLE_ID_FG_COLOR;\n  const char* image_key = bg ? STYLE_ID_BG_IMAGE : STYLE_ID_FG_IMAGE;\n  rect_t bg_r = rect_init(widget->x, widget->y, widget->w, widget->h);\n  uint32_t radius_tl = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_LEFT, radius);\n  uint32_t radius_tr = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_RIGHT, radius);\n  uint32_t radius_bl = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_LEFT, radius);\n  uint32_t radius_br = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_RIGHT, radius);\n  uint32_t clear_bg = style_get_uint(style, STYLE_ID_CLEAR_BG, 0);\n  const char* draw_type_key = bg ? STYLE_ID_BG_IMAGE_DRAW_TYPE : STYLE_ID_FG_IMAGE_DRAW_TYPE;\n  gradient_t* gradient = style_get_gradient(style, color_key, &agradient);\n  const char* image_name = style_get_str(style, image_key, NULL);\n\n  if (gradient != NULL && r->w > 0 && r->h > 0) {\n    color_t color = gradient_get_first_color(gradient);\n    canvas_set_fill_color(c, color);\n    if (gradient->nr > 1 || color.rgba.a) {\n      if (radius_tl > 3 || radius_tr > 3 || radius_bl > 3 || radius_br > 3) {\n        /*TODO: support gradient*/\n        if (bg) {\n          ret = canvas_fill_rounded_rect_gradient_ex(c, r, NULL, gradient, radius_tl, radius_tr,\n                                                     radius_bl, radius_br);\n        } else {\n          ret = canvas_fill_rounded_rect_gradient_ex(c, r, &bg_r, gradient, radius_tl, radius_tr,\n                                                     radius_bl, radius_br);\n        }\n        if (ret == RET_FAIL) {\n          canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n        }\n      } else if (gradient->nr > 1) {\n        canvas_fill_rect_gradient(c, r->x, r->y, r->w, r->h, gradient);\n      } else {\n        if (clear_bg) {\n          canvas_clear_rect(c, r->x, r->y, r->w, r->h);\n        } else {\n          canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n        }\n      }\n    } else if (clear_bg) {\n      canvas_clear_rect(c, r->x, r->y, r->w, r->h);\n    }\n  }\n\n  if (image_name != NULL && *image_name && r->w > 0 && r->h > 0) {\n    char name[MAX_PATH + 1];\n    const char* region = strrchr(image_name, '#');\n    if (region != NULL) {\n      memset(name, 0x00, sizeof(name));\n      tk_strncpy(name, image_name, region - image_name);\n      image_name = name;\n    }\n\n    if (widget_load_image(widget, image_name, &img) == RET_OK) {\n      draw_type = (image_draw_type_t)style_get_int(style, draw_type_key, draw_type);\n\n      if (region == NULL) {\n        canvas_draw_image_ex(c, &img, draw_type, r);\n      } else {\n        rect_t src;\n        rect_t dst = *r;\n        if (tk_str_eq(region, \"#\")) {\n          src = rect_init(widget->x, widget->y, widget->w, widget->h);\n        } else if (tk_str_eq(region, \"#g\")) {\n          point_t p = {widget->x, widget->y};\n          widget_to_global(widget, &p);\n          src = rect_init(p.x, p.y, widget->w, widget->h);\n        } else {\n          image_region_parse(img.w, img.h, region, &src);\n        }\n\n        canvas_draw_image_ex2(c, &img, draw_type, &src, &dst);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_stroke_border_rect_for_border_type(canvas_t* c, const rect_t* r, color_t bd,\n                                                int32_t border, uint32_t border_width) {\n  wh_t w = r->w;\n  wh_t h = r->h;\n  xy_t x = r->x + 0.5;\n  xy_t y = r->y + 0.5;\n  xy_t y1 = y;\n  wh_t h1 = h;\n  bool_t draw_top = FALSE;\n  bool_t draw_bottom = FALSE;\n  canvas_set_fill_color(c, bd);\n  if (border & BORDER_TOP) {\n    draw_top = TRUE;\n    canvas_fill_rect(c, x, y, w, border_width);\n  }\n  if (border & BORDER_BOTTOM) {\n    draw_bottom = TRUE;\n    canvas_fill_rect(c, x, y + h - border_width, w, border_width);\n  }\n  /* 减少重复绘制的部分，可以修复有透明的时候重叠区域显示不正常为问题 */\n  if (draw_top) {\n    y1 += border_width;\n    h1 -= border_width;\n  }\n  if (draw_bottom) {\n    h1 -= border_width;\n  }\n  if (border & BORDER_LEFT) {\n    canvas_fill_rect(c, x, y1, border_width, h1);\n  }\n  if (border & BORDER_RIGHT) {\n    canvas_fill_rect(c, x + w - border_width, y1, border_width, h1);\n  }\n  return RET_OK;\n}\n\nret_t widget_stroke_border_rect(widget_t* widget, canvas_t* c, const rect_t* r) {\n  style_t* style = widget->astyle;\n  color_t trans = color_init(0, 0, 0, 0);\n  color_t bd = style_get_color(style, STYLE_ID_BORDER_COLOR, trans);\n  uint32_t radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  int32_t border = style_get_int(style, STYLE_ID_BORDER, BORDER_ALL);\n  uint32_t border_width = style_get_int(style, STYLE_ID_BORDER_WIDTH, 1);\n  uint32_t radius_tl = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_LEFT, radius);\n  uint32_t radius_tr = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_RIGHT, radius);\n  uint32_t radius_bl = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_LEFT, radius);\n  uint32_t radius_br = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_RIGHT, radius);\n\n  if (bd.rgba.a) {\n    canvas_set_stroke_color(c, bd);\n    if (radius_tl > 3 || radius_tr > 3 || radius_bl > 3 || radius_br > 3) {\n      if (canvas_stroke_rounded_rect_ex(c, r, NULL, &bd, radius_tl, radius_tr, radius_bl, radius_br,\n                                        border_width, border) != RET_OK) {\n        widget_stroke_border_rect_for_border_type(c, r, bd, border, border_width);\n      }\n    } else {\n      widget_stroke_border_rect_for_border_type(c, r, bd, border, border_width);\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_draw_background(widget_t* widget, canvas_t* c) {\n  rect_t r;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  r = rect_init(0, 0, widget->w, widget->h);\n\n  return widget_fill_rect(widget, c, &r, TRUE, IMAGE_DRAW_CENTER);\n}\n\nret_t widget_fill_bg_rect(widget_t* widget, canvas_t* c, const rect_t* r,\n                          image_draw_type_t draw_type) {\n  return widget_fill_rect(widget, c, r, TRUE, draw_type);\n}\n\nret_t widget_fill_fg_rect(widget_t* widget, canvas_t* c, const rect_t* r,\n                          image_draw_type_t draw_type) {\n  return widget_fill_rect(widget, c, r, FALSE, draw_type);\n}\n\nstatic ret_t widget_draw_border(widget_t* widget, canvas_t* c) {\n  rect_t r;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  r = rect_init(0, 0, widget->w, widget->h);\n  return widget_stroke_border_rect(widget, c, &r);\n}\n\nret_t widget_paint_helper(widget_t* widget, canvas_t* c, const char* icon, wstr_t* text) {\n  if (style_is_valid(widget->astyle)) {\n    widget_draw_icon_text(widget, c, icon, text);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_paint_impl(widget_t* widget, canvas_t* c) {\n  int32_t ox = widget->x;\n  int32_t oy = widget->y;\n  uint8_t save_alpha = c->global_alpha;\n\n  if (widget->opacity < TK_OPACITY_ALPHA) {\n    canvas_set_global_alpha(c, (widget->opacity * save_alpha) / 0xff);\n  }\n\n  if (widget->astyle != NULL) {\n    ox += style_get_int(widget->astyle, STYLE_ID_X_OFFSET, 0);\n    oy += style_get_int(widget->astyle, STYLE_ID_Y_OFFSET, 0);\n  }\n\n  canvas_translate(c, ox, oy);\n  widget_on_paint_begin(widget, c);\n  widget_on_paint_background(widget, c);\n  widget_on_paint_self(widget, c);\n  widget_on_paint_children(widget, c);\n  widget_on_paint_border(widget, c);\n  widget_on_paint_end(widget, c);\n\n  canvas_untranslate(c, ox, oy);\n  if (widget->opacity < TK_OPACITY_ALPHA) {\n    canvas_set_global_alpha(c, save_alpha);\n  }\n\n  widget_on_paint_done(widget, c);\n\n  return RET_OK;\n}\n\nret_t widget_paint(widget_t* widget, canvas_t* c) {\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  if (!widget->visible || widget->opacity <= 0x08 || widget->w <= 0 || widget->h <= 0) {\n    widget->dirty = FALSE;\n    return RET_OK;\n  }\n\n  if (widget->need_update_style) {\n    widget_update_style(widget);\n  }\n\n  canvas_save(c);\n  widget_paint_impl(widget, c);\n  canvas_restore(c);\n\n  widget->dirty = FALSE;\n\n  return RET_OK;\n}\n\nstatic const widget_cmd_t s_widget_cmds[] = {\n    {WIDGET_EXEC_START_ANIMATOR, widget_start_animator},\n    {WIDGET_EXEC_STOP_ANIMATOR, widget_stop_animator},\n    {WIDGET_EXEC_PAUSE_ANIMATOR, widget_pause_animator},\n    {WIDGET_EXEC_DESTROY_ANIMATOR, widget_destroy_animator}};\n\nstatic ret_t widget_do_exec(widget_t* widget, const char* cmd, const char* args) {\n  uint32_t i = 0;\n\n  for (i = 0; i < ARRAY_SIZE(s_widget_cmds); i++) {\n    const widget_cmd_t* iter = s_widget_cmds + i;\n    if (tk_str_eq(cmd, iter->name)) {\n      return iter->exec(widget, args);\n    }\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t widget_exec(widget_t* widget, const char* str) {\n  if (str != NULL) {\n    char cmd[TK_NAME_LEN + 1] = {0};\n    const char* args = strchr(str, ':');\n\n    if (args != NULL) {\n      return_value_if_fail((args - str) < TK_NAME_LEN, RET_BAD_PARAMS);\n      tk_strncpy(cmd, str, args - str);\n      args += 1;\n    } else {\n      return_value_if_fail(strlen(str) < TK_NAME_LEN, RET_BAD_PARAMS);\n      tk_strcpy(cmd, str);\n    }\n\n    return widget_do_exec(widget, cmd, args);\n  } else {\n    return RET_NOT_FOUND;\n  }\n}\n\nstatic widget_t* widget_get_top_widget_grab_key(widget_t* widget) {\n  return_value_if_fail(widget != NULL, NULL);\n  WIDGET_FOR_EACH_CHILD_BEGIN_R(widget, iter, i)\n  value_t v;\n  widget_t* widget_grab_key = widget_get_top_widget_grab_key(iter);\n  if (widget_grab_key == NULL && iter != NULL && iter->visible && iter->custom_props != NULL) {\n    ret_t ret = tk_object_get_prop(iter->custom_props, WIDGET_PROP_GRAB_KEYS, &v);\n    if (ret == RET_OK && value_bool(&v)) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nstatic ret_t widget_on_ungrab_keys(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  window_manager_t* wm = WINDOW_MANAGER(widget_get_window_manager(widget));\n\n  wm->widget_grab_key = widget_get_top_widget_grab_key(WIDGET(wm));\n\n  return RET_REMOVE;\n}\n\nstatic ret_t widget_exec_code(void* ctx, event_t* evt) {\n#ifndef WITHOUT_FSCRIPT\n  value_t v;\n  value_t result;\n  ret_t ret = RET_OK;\n  tk_object_t* obj = NULL;\n  widget_t* widget = WIDGET(evt->target);\n  const char* code = (const char*)ctx;\n  if (widget_get_prop(widget, STR_PROP_MODEL, &v) == RET_OK) {\n    obj = value_object(&v);\n  }\n  if (obj != NULL) {\n    TK_OBJECT_REF(obj);\n  } else {\n    obj = object_default_create();\n  }\n  return_value_if_fail(obj != NULL && code != NULL, RET_REMOVE);\n\n  tk_object_set_prop_pointer(obj, STR_PROP_SELF, widget);\n\n  switch (evt->type) {\n    case EVT_CLICK:\n    case EVT_POINTER_DOWN:\n    case EVT_POINTER_MOVE:\n    case EVT_POINTER_UP: {\n      pointer_event_t* e = pointer_event_cast(evt);\n      tk_object_set_prop_int(obj, \"x\", e->x);\n      tk_object_set_prop_int(obj, \"y\", e->y);\n      tk_object_set_prop_bool(obj, \"alt\", e->alt);\n      tk_object_set_prop_bool(obj, \"cmd\", e->cmd);\n      tk_object_set_prop_bool(obj, \"menu\", e->menu);\n      tk_object_set_prop_bool(obj, \"ctrl\", e->ctrl);\n      break;\n    }\n    case EVT_KEY_DOWN:\n    case EVT_KEY_LONG_PRESS:\n    case EVT_KEY_UP: {\n      key_event_t* e = key_event_cast(evt);\n      const key_type_value_t* kv = keys_type_find_by_value(e->key);\n      if (kv != NULL) {\n        tk_object_set_prop_str(obj, \"key\", kv->name);\n      } else {\n        tk_object_set_prop_str(obj, \"key\", \"unkown\");\n      }\n      tk_object_set_prop_bool(obj, \"alt\", e->alt);\n      tk_object_set_prop_bool(obj, \"cmd\", e->cmd);\n      tk_object_set_prop_bool(obj, \"menu\", e->menu);\n      tk_object_set_prop_bool(obj, \"ctrl\", e->ctrl);\n      break;\n    }\n    default:\n      break;\n  }\n\n  value_set_int(&result, 0);\n  fscript_eval(obj, code, &result);\n  if (tk_object_get_prop_bool(obj, \"RET_STOP\", FALSE)) {\n    ret = RET_STOP;\n  }\n  if (tk_object_get_prop_bool(obj, \"RET_REMOVE\", FALSE)) {\n    ret = RET_REMOVE;\n  }\n  value_reset(&result);\n  TK_OBJECT_UNREF(obj);\n\n  return ret;\n#else\n  return RET_OK;\n#endif\n}\n\nstatic ret_t widget_free_code(void* ctx, event_t* evt) {\n  widget_t* widget = WIDGET(evt->target);\n  widget_off_by_ctx(widget, ctx);\n  TKMEM_FREE(ctx);\n\n  return RET_REMOVE;\n}\n\n#define STR_ANIMATE_PREFIX \"animate:\"\n#define TK_ANIMATING_TIME 500 /* 单位：毫秒（ms） */\nret_t widget_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  ret_t ret = RET_OK;\n  prop_change_event_t e;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_EXEC)) {\n    ret = widget_exec(widget, value_str(v));\n    if (ret != RET_NOT_FOUND) {\n      return ret;\n    }\n  }\n\n  e.value = v;\n  e.name = name;\n  e.e = event_init(EVT_PROP_WILL_CHANGE, widget);\n  widget_dispatch(widget, (event_t*)&e);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    widget_set_x(widget, (xy_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    widget_set_y(widget, (xy_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    widget_set_w(widget, (wh_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    widget_set_h(widget, (wh_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    widget->opacity = (uint8_t)value_int(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    widget_set_visible(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    widget->sensitive = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    widget->floating = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    widget->focusable = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    widget->with_focus_state = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    widget->dirty_rect_tolerance = value_int(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    const char* name = value_str(v);\n    return widget_use_style(widget, name);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    widget_set_enable(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    widget->feedback = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    widget_set_auto_adjust_size(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    widget_set_name(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_TR_TEXT)) {\n    widget_set_tr_text(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    widget_set_animation(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    widget_set_self_layout(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_LAYOUT) || tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    widget_set_children_layout(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_POINTER_CURSOR)) {\n    widget_set_pointer_cursor(widget, value_str(v));\n  } else {\n    ret = RET_NOT_FOUND;\n  }\n\n  if (widget->vt->set_prop) {\n    if (tk_str_start_with(name, STR_ANIMATE_PREFIX)) {\n      return widget_animate_prop_float_to(widget, name + strlen(STR_ANIMATE_PREFIX),\n                                          value_float32(v), TK_ANIMATING_TIME);\n    } else {\n      ret_t ret1 = widget->vt->set_prop(widget, name, v);\n      if (ret == RET_NOT_FOUND) {\n        ret = ret1;\n      }\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_FOCUSED) || tk_str_eq(name, WIDGET_PROP_FOCUS)) {\n      widget_set_focused(widget, value_bool(v));\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n      wstr_from_value(&(widget->text), v);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_EXEC)) {\n      ret = RET_NOT_FOUND;\n    } else if (tk_str_start_with(name, \"style:\") || tk_str_start_with(name, \"style.\")) {\n      return widget_set_style(widget, name + 6, v);\n    } else {\n      if (widget->custom_props == NULL) {\n        widget->custom_props = object_default_create();\n      }\n\n      if (tk_str_eq(name, WIDGET_PROP_GRAB_KEYS)) {\n        window_manager_t* wm = WINDOW_MANAGER(widget_get_window_manager(widget));\n\n        if (value_bool(v)) {\n          widget_on(widget, EVT_DESTROY, widget_on_ungrab_keys, widget);\n          wm->widget_grab_key = widget;\n        }\n      }\n\n      if (strncmp(name, STR_ON_EVENT_PREFIX, sizeof(STR_ON_EVENT_PREFIX) - 1) == 0) {\n        int32_t etype = event_from_name(name + sizeof(STR_ON_EVENT_PREFIX) - 1);\n        if (etype != EVT_NONE) {\n          char* code = tk_strdup(value_str(v));\n          if (code != NULL) {\n            name += sizeof(STR_ON_EVENT_PREFIX) - 1;\n            if (strncmp(name, STR_GLOBAL_EVENT_PREFIX, sizeof(STR_GLOBAL_EVENT_PREFIX) - 1) == 0) {\n              widget_t* wm = window_manager();\n              widget_on(wm, etype, widget_exec_code, code);\n              widget_on(wm, EVT_DESTROY, widget_free_code, code);\n            } else {\n              widget_on(widget, etype, widget_exec_code, code);\n              widget_on(widget, EVT_DESTROY, widget_free_code, code);\n            }\n            ret = RET_OK;\n          }\n        } else {\n          log_debug(\"not found event %s\\n\", name);\n        }\n      } else {\n        ret = tk_object_set_prop(widget->custom_props, name, v);\n      }\n    }\n  }\n\n  if (ret != RET_NOT_FOUND) {\n    e.e.type = EVT_PROP_CHANGED;\n    widget_dispatch(widget, (event_t*)&e);\n    widget_invalidate(widget, NULL);\n  }\n\n  return ret;\n}\n\nret_t widget_get_prop(widget_t* widget, const char* name, value_t* v) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    value_set_int32(v, widget->x);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    value_set_int32(v, widget->y);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    value_set_int32(v, widget->w);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    value_set_int32(v, widget->h);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    value_set_int32(v, widget->opacity);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    value_set_bool(v, widget->visible);\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    value_set_bool(v, widget->sensitive);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    value_set_bool(v, widget->floating);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    value_set_bool(v, widget_is_focusable(widget));\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSED)) {\n    value_set_bool(v, widget->focused);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    value_set_bool(v, widget->with_focus_state);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    value_set_int(v, widget->dirty_rect_tolerance);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    value_set_str(v, widget->style);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    value_set_bool(v, widget->enable);\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    value_set_bool(v, widget->feedback);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    value_set_bool(v, widget->auto_adjust_size);\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    value_set_str(v, widget->name);\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    value_set_str(v, widget->animation);\n  } else if (tk_str_eq(name, WIDGET_PROP_POINTER_CURSOR)) {\n    value_set_str(v, widget->pointer_cursor);\n  } else if (tk_str_eq(name, WIDGET_PROP_LOADING)) {\n    value_set_bool(v, widget->loading);\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    if (widget->self_layout != NULL) {\n      value_set_str(v, self_layouter_to_string(widget->self_layout));\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  } else if (tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    if (widget->children_layout != NULL) {\n      value_set_str(v, children_layouter_to_string(widget->children_layout));\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  } else {\n    if (widget->vt->get_prop) {\n      ret = widget->vt->get_prop(widget, name, v);\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  }\n\n  /*default*/\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_LAYOUT_W)) {\n      value_set_int32(v, widget->w);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_LAYOUT_H)) {\n      value_set_int32(v, widget->h);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n      wchar_t* text = widget->text.str;\n      if (text != NULL) {\n        text[widget->text.size] = 0;\n      }\n      value_set_wstr(v, text);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_STATE_FOR_STYLE)) {\n      value_set_str(v, widget_get_state_for_style(widget, FALSE, FALSE));\n      ret = RET_OK;\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (widget->custom_props != NULL) {\n      ret = tk_object_get_prop(widget->custom_props, name, v);\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_TYPE)) {\n      value_set_str(v, widget->vt->type);\n      ret = RET_OK;\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_set_prop_str(widget_t* widget, const char* name, const char* str) {\n  value_t v;\n  value_set_str(&v, str);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nconst char* widget_get_prop_str(widget_t* widget, const char* name, const char* defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_str(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_pointer(widget_t* widget, const char* name, void* pointer) {\n  value_t v;\n  value_set_pointer(&v, pointer);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nvoid* widget_get_prop_pointer(widget_t* widget, const char* name) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_pointer(&v);\n  } else {\n    return NULL;\n  }\n}\n\nret_t widget_set_prop_float(widget_t* widget, const char* name, float_t num) {\n  value_t v;\n  value_set_float32(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nfloat_t widget_get_prop_float(widget_t* widget, const char* name, float_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_float32(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_int(widget_t* widget, const char* name, int32_t num) {\n  value_t v;\n  value_set_int(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nint32_t widget_get_prop_int(widget_t* widget, const char* name, int32_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_int(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_bool(widget_t* widget, const char* name, bool_t num) {\n  value_t v;\n  value_set_bool(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nbool_t widget_get_prop_bool(widget_t* widget, const char* name, bool_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_bool(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_on_paint_background(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_background) {\n    ret = widget->vt->on_paint_background(widget, c);\n  } else {\n    if (style_is_valid(widget->astyle)) {\n      widget_draw_background(widget, c);\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_self(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_self) {\n    ret = widget->vt->on_paint_self(widget, c);\n  } else {\n    paint_event_t e;\n    widget_dispatch(widget, paint_event_init(&e, EVT_PAINT, widget, c));\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_children(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_children) {\n    ret = widget->vt->on_paint_children(widget, c);\n  } else {\n    ret = widget_on_paint_children_default(widget, c);\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_border(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_border) {\n    ret = widget->vt->on_paint_border(widget, c);\n  } else {\n    if (style_is_valid(widget->astyle)) {\n      ret = widget_draw_border(widget, c);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_begin(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_begin) {\n    ret = widget->vt->on_paint_begin(widget, c);\n  }\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_BEFORE_PAINT, widget, c));\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_done(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_PAINT_DONE, widget, c));\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_end(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_end) {\n    ret = widget->vt->on_paint_end(widget, c);\n  }\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_AFTER_PAINT, widget, c));\n\n  return ret;\n}\n\nret_t widget_dispatch_to_target(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  e->target = widget;\n  widget_dispatch(widget, e);\n\n  if (widget->target) {\n    ret = widget_dispatch_to_target(widget->target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_map_key(widget_t* widget, key_event_t* e) {\n  value_t v;\n  const key_type_value_t* kv = NULL;\n\n  if (widget->custom_props != NULL) {\n    kv = keys_type_find_by_value(e->key);\n    if (kv != NULL) {\n      const char* to = NULL;\n      char from[TK_NAME_LEN + 1] = {0};\n      char fixed_name[TK_NAME_LEN + 1];\n\n      tk_snprintf(from, sizeof(from), \"map_key:%s\", kv->name);\n      if (tk_object_get_prop(widget->custom_props, from, &v) == RET_OK) {\n        to = value_str(&v);\n      } else if (strlen(kv->name) > 1) {\n        tk_strcpy(fixed_name, kv->name);\n        tk_str_tolower(fixed_name);\n        tk_snprintf(from, sizeof(from), \"map_key:%s\", fixed_name);\n        if (tk_object_get_prop(widget->custom_props, from, &v) == RET_OK) {\n          to = value_str(&v);\n        }\n      }\n\n      if (to != NULL) {\n        kv = keys_type_find(to);\n        if (kv != NULL) {\n          e->key = kv->value;\n          log_debug(\"map key %s to %s\\n\", from, to);\n        }\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_dispatch_to_key_target(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  e->target = widget;\n  widget_dispatch(widget, e);\n\n  if (widget->key_target) {\n    ret = widget_dispatch_to_target(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_before_children(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    key_event_t before = *e;\n    before.e.type = EVT_KEY_DOWN_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_keydown_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_keydown(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_after_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_keydown) {\n    ret = widget->vt->on_keydown(widget, e);\n  }\n\n  return ret;\n}\n\nbool_t widget_is_activate_key(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL && e != NULL, FALSE);\n\n  return (widget->vt->space_key_to_activate && e->key == TK_KEY_SPACE) ||\n         (widget->vt->return_key_to_activate && key_code_is_enter(e->key));\n}\n\nstatic bool_t shortcut_fast_match(const char* shortcut, key_event_t* e) {\n  uint32_t key = e->key;\n  const char* kname = strrchr(shortcut, '+');\n  bool_t cmd = strstr(shortcut, \"cmd\") != NULL;\n  bool_t ctrl = strstr(shortcut, \"ctrl\") != NULL;\n  bool_t shift = strstr(shortcut, \"shift\") != NULL;\n  const key_type_value_t* kv = keys_type_find_by_value(key);\n\n  if (kv != NULL) {\n    if (kname == NULL) {\n      kname = shortcut;\n    } else {\n      kname++;\n    }\n\n    if (tk_str_ieq(kname, kv->name) && cmd == e->cmd && ctrl == e->ctrl && shift == e->shift) {\n      return TRUE;\n    }\n  }\n\n  return FALSE;\n}\n\nstatic bool_t widget_match_key(widget_t* widget, const char* prop, key_event_t* e) {\n  const char* shortcut = NULL;\n  widget_t* win = widget_get_window(widget);\n\n  if (widget_is_window_manager(widget)) {\n    return FALSE;\n  }\n\n  return_value_if_fail(win != NULL, FALSE);\n  shortcut = widget_get_prop_str(win, prop, NULL);\n\n  if (shortcut != NULL) {\n    return shortcut_fast_match(shortcut, e);\n  }\n\n  return FALSE;\n}\n\nstatic bool_t widget_is_move_focus_prev_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_PREV_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_next_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_NEXT_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_up_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_UP_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_down_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_DOWN_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_left_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_LEFT_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_right_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_RIGHT_KEY, e);\n}\n\nbool_t widget_is_change_focus_key(widget_t* widget, key_event_t* e) {\n  return widget_is_move_focus_prev_key(widget, e) || widget_is_move_focus_next_key(widget, e) ||\n         widget_is_move_focus_up_key(widget, e) || widget_is_move_focus_down_key(widget, e) ||\n         widget_is_move_focus_left_key(widget, e) || widget_is_move_focus_right_key(widget, e);\n}\n\nstatic ret_t widget_on_keydown_general(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  if (!widget_is_window_manager(widget)) {\n    if (widget_is_activate_key(widget, e)) {\n      ret = RET_STOP;\n      widget_set_state(widget, WIDGET_STATE_PRESSED);\n    } else if (widget_is_move_focus_next_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_next(widget);\n      } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n        ret = RET_STOP;\n        widget_focus_first(widget);\n      }\n    } else if (widget_is_move_focus_prev_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_prev(widget);\n      } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n        ret = RET_STOP;\n        widget_focus_first(widget);\n      }\n    } else if (widget_is_move_focus_up_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_up(widget);\n      }\n    } else if (widget_is_move_focus_down_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_down(widget);\n      }\n    } else if (widget_is_move_focus_left_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_left(widget);\n      }\n    } else if (widget_is_move_focus_right_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_right(widget);\n      }\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_impl(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_keydown_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keydown_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keydown_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_keydown(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  uint32_t key = e->key;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  widget_map_key(widget, e);\n  if (e->e.type == EVT_KEY_DOWN) {\n    ret = widget_on_keydown_impl(widget, e);\n    if (widget->feedback) {\n      ui_feedback_request(widget, (event_t*)e);\n    }\n\n    e->key = key;\n    if (ret != RET_STOP) {\n      ret = widget_on_keydown_general(widget, e);\n    }\n  } else if (e->e.type == EVT_KEY_LONG_PRESS) {\n    return_value_if_equal(widget_on_keydown_children(widget, e), RET_STOP);\n    ret = widget_on_keydown_after_children(widget, e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_before_children(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    key_event_t before = *e;\n    before.e.type = EVT_KEY_UP_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_keyup_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_keyup(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_after_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_keyup) {\n    ret = widget->vt->on_keyup(widget, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_impl(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_keyup_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keyup_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keyup_after_children(widget, e), RET_STOP);\n\n  if (widget_is_activate_key(widget, e)) {\n    pointer_event_t click;\n    if (widget_is_focusable(widget)) {\n      widget_set_state(widget, WIDGET_STATE_FOCUSED);\n    } else {\n      widget_set_state(widget, WIDGET_STATE_NORMAL);\n    }\n    widget_dispatch_async(widget, pointer_event_init(&click, EVT_CLICK, widget, 0, 0));\n\n    ret = RET_STOP;\n  } else if (widget_is_move_focus_next_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_prev_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_up_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_down_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_left_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_right_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_on_keyup(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  uint32_t key = e->key;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  widget_map_key(widget, e);\n  ret = widget_on_keyup_impl(widget, e);\n  if (widget->feedback) {\n    ui_feedback_request(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  e->key = key;\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_before_children(widget_t* widget, wheel_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    wheel_event_t before = *e;\n    before.e.type = EVT_WHEEL_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_wheel_children(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_wheel(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_after_children(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_wheel) {\n    ret = widget->vt->on_wheel(widget, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_impl(widget_t* widget, wheel_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_wheel_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_wheel_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_wheel_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_wheel(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_wheel_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}\n\nret_t widget_on_multi_gesture(widget_t* widget, multi_gesture_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\n    ret = widget_dispatch(target, (event_t*)e);\n  }\n\n  if (ret != RET_STOP) {\n    ret = widget_dispatch(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_dispatch_leave_event(widget_t* widget, pointer_event_t* e) {\n  widget_t* target = widget;\n\n  while (target != NULL) {\n    widget_t* curr = target;\n    pointer_event_t leave = *e;\n    leave.e.type = EVT_POINTER_LEAVE;\n\n    widget_dispatch(target, (event_t*)(&leave));\n    target = curr->target;\n    curr->target = NULL;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_dispatch_blur_event(widget_t* widget) {\n  widget_t* target = widget;\n  widget_t* temp;\n\n  while (target != NULL) {\n    widget_ref(target);\n    if (target->focused) {\n      target->focused = FALSE;\n      event_t e = event_init(EVT_BLUR, target);\n      widget_dispatch(target, &e);\n      widget_set_need_update_style(target);\n    }\n\n    if (target->parent && target->parent->key_target == target) {\n      target->parent->key_target = NULL;\n    }\n\n    temp = target->key_target;\n    widget_unref(target);\n    target = temp;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_dispatch_event_to_target_recursive(widget_t* widget, event_t* e) {\n  widget_t* target = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  target = widget->grab_widget ? widget->grab_widget : widget->target;\n  while (target != NULL) {\n    widget_dispatch(target, e);\n    target = target->target != NULL ? target->target : target->key_target;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_on_pointer_down_before_children(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    pointer_event_t before = *e;\n    before.e.type = EVT_POINTER_DOWN_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nret_t widget_on_pointer_down_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n\n  if (target != NULL && target->enable && target->sensitive) {\n    if (!(widget_is_keyboard(target))) {\n      if (widget_is_focusable(target) || !widget_is_strongly_focus(widget)) {\n        if (!target->focused) {\n          widget_set_focused_internal(target, TRUE);\n        } else {\n          widget->key_target = target;\n        }\n      }\n    }\n  } else if (widget->key_target && !widget_is_strongly_focus(widget)) {\n    widget_set_focused_internal(widget->key_target, FALSE);\n  }\n  return_value_if_equal(ret, RET_STOP);\n\n  if (widget->target != target) {\n    if (widget->target != NULL) {\n      widget_dispatch_leave_event(widget->target, e);\n    }\n    widget->target = target;\n  }\n\n  if (widget->target != NULL) {\n    ret = widget_on_pointer_down(widget->target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_down_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_pointer_down) {\n    return_value_if_equal(ret = widget->vt->on_pointer_down(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_down_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  widget->grab_widget = NULL;\n  widget->grab_widget_count = 0;\n  return_value_if_equal(widget_on_pointer_down_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_pointer_down_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_pointer_down_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_pointer_down(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_pointer_down_impl(widget, e);\n  if (widget->feedback) {\n    ui_feedback_request(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_move_before_children(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    pointer_event_t before = *e;\n    before.e.type = EVT_POINTER_MOVE_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nret_t widget_on_pointer_move_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n\n  if (target != widget->target) {\n    if (widget->target != NULL) {\n      widget_dispatch_leave_event(widget->target, e);\n    }\n\n    if (target != NULL) {\n      pointer_event_t enter = *e;\n      enter.e.type = EVT_POINTER_ENTER;\n      ret = widget_dispatch(target, (event_t*)(&enter));\n      widget_update_pointer_cursor(target);\n    } else {\n      widget_update_pointer_cursor(widget);\n    }\n\n    widget->target = target;\n  }\n  return_value_if_equal(ret, RET_STOP);\n\n  if (widget->target != NULL) {\n    ret = widget_on_pointer_move(widget->target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_move_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_pointer_move) {\n    return_value_if_equal(ret = widget->vt->on_pointer_move(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_move_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_pointer_move_before_children(widget, e), RET_STOP);\n  if (widget_on_pointer_move_children(widget, e) == RET_STOP) {\n    if (e->pressed) {\n      pointer_event_t abort;\n      pointer_event_init(&abort, EVT_POINTER_DOWN_ABORT, widget, e->x, e->y);\n      return_value_if_equal(widget_on_pointer_move_after_children(widget, &abort), RET_STOP);\n    }\n\n    return RET_STOP;\n  } else {\n    return widget_on_pointer_move_after_children(widget, e);\n  }\n}\n\nret_t widget_on_pointer_move(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_pointer_move_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_up_before_children(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    pointer_event_t before = *e;\n    before.e.type = EVT_POINTER_UP_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nret_t widget_on_pointer_up_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\n    ret = widget_on_pointer_up(target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_up_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_pointer_up) {\n    return_value_if_equal(ret = widget->vt->on_pointer_up(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_up_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_pointer_up_before_children(widget, e), RET_STOP);\n  if (widget_on_pointer_up_children(widget, e) == RET_STOP) {\n    if (e->pressed) {\n      pointer_event_t abort;\n      pointer_event_init(&abort, EVT_POINTER_DOWN_ABORT, widget, e->x, e->y);\n      return_value_if_equal(widget_on_pointer_up_after_children(widget, &abort), RET_STOP);\n    }\n\n    return RET_STOP;\n  } else {\n    return widget_on_pointer_up_after_children(widget, e);\n  }\n}\n\nret_t widget_on_pointer_up(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_pointer_up_impl(widget, e);\n  if (widget->feedback) {\n    ui_feedback_request(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_context_menu_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\n    ret = widget_on_context_menu(target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_context_menu_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_context_menu) {\n    return_value_if_equal(ret = widget->vt->on_context_menu(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_context_menu_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget_on_context_menu_children(widget, e) == RET_STOP) {\n    return RET_STOP;\n  } else {\n    return widget_on_context_menu_after_children(widget, e);\n  }\n}\n\nret_t widget_on_context_menu(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_context_menu_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}\n\nret_t widget_grab(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->grab_widget == NULL || widget->grab_widget == child, RET_BAD_PARAMS);\n\n  if (widget->grab_widget == NULL) {\n    widget->grab_widget = child;\n    widget->grab_widget_count = 1;\n  } else {\n    widget->grab_widget_count++;\n  }\n\n  if (widget->parent) {\n    widget_grab(widget->parent, widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_ungrab(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->grab_widget == child) {\n    if (widget->grab_widget->grab_widget_count < widget->grab_widget_count) {\n      widget->grab_widget_count--;\n      if (widget->grab_widget_count <= 0) {\n        widget->grab_widget = NULL;\n        widget->grab_widget_count = 0;\n      }\n\n      if (widget->parent) {\n        widget_ungrab(widget->parent, widget);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_foreach(widget_t* widget, tk_visit_t visit, void* ctx) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && visit != NULL, RET_BAD_PARAMS);\n\n  ret = visit(ctx, widget);\n  if (ret != RET_OK) {\n    return ret;\n  }\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  ret = widget_foreach(iter, visit, ctx);\n  if (ret == RET_STOP || ret == RET_DONE) {\n    return ret;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return RET_OK;\n}\n\nwidget_t* widget_get_window(widget_t* widget) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, NULL);\n\n  while (iter) {\n    if (widget_is_window(iter)) {\n      return iter;\n    }\n    iter = iter->parent;\n  }\n\n  return NULL;\n}\n\nstatic widget_t* widget_get_window_or_keyboard(widget_t* widget) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, NULL);\n\n  while (iter) {\n    if (widget_is_window(iter) || widget_is_keyboard(iter)) {\n      return iter;\n    }\n    iter = iter->parent;\n  }\n\n  return NULL;\n}\n\nwidget_t* widget_get_window_manager(widget_t* widget) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, NULL);\n\n  while (iter) {\n    if (widget_is_window_manager(iter)) {\n      return iter;\n    }\n    iter = iter->parent;\n  }\n\n  return window_manager();\n}\n\nuint32_t widget_add_timer(widget_t* widget, timer_func_t on_timer, uint32_t duration_ms) {\n  return_value_if_fail(widget != NULL && on_timer != NULL, TK_INVALID_ID);\n  return timer_add_with_type(on_timer, widget, duration_ms, TIMER_INFO_WIDGET_ADD);\n}\n\nret_t widget_remove_timer(widget_t* widget, uint32_t timer_id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return timer_remove(timer_id);\n}\n\nuint32_t widget_add_idle(widget_t* widget, idle_func_t on_idle) {\n  return_value_if_fail(widget != NULL && on_idle != NULL, TK_INVALID_ID);\n  return idle_add_with_type(on_idle, widget, IDLE_INFO_WIDGET_ADD);\n}\n\nret_t widget_remove_idle(widget_t* widget, uint32_t idle_id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return idle_remove(idle_id);\n}\n\nret_t widget_destroy_sync(widget_t* widget) {\n  event_t e = event_init(EVT_DESTROY, widget);\n  return_value_if_fail(widget != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n\n#ifndef WITHOUT_WIDGET_ANIMATORS\n  widget_destroy_animator(widget, NULL);\n#endif /*WITHOUT_WIDGET_ANIMATORS*/\n\n  widget->destroying = TRUE;\n  idle_remove_all_by_ctx_and_type(IDLE_INFO_WIDGET_ADD, widget);\n  timer_remove_all_by_ctx_and_type(TIMER_INFO_WIDGET_ADD, widget);\n\n  if (widget->emitter != NULL) {\n    widget_dispatch(widget, &e);\n    emitter_destroy(widget->emitter);\n    widget->emitter = NULL;\n  }\n\n  if (widget->children != NULL) {\n    widget_destroy_children(widget);\n    darray_destroy(widget->children);\n    widget->children = NULL;\n  }\n\n  if (widget->children_layout != NULL) {\n    children_layouter_destroy(widget->children_layout);\n    widget->children_layout = NULL;\n  }\n\n  if (widget->self_layout != NULL) {\n    self_layouter_destroy(widget->self_layout);\n    widget->self_layout = NULL;\n  }\n\n  widget->destroying = FALSE;\n\n  return widget_real_destroy(widget);\n}\n\nwidget_t* widget_create(widget_t* parent, const widget_vtable_t* vt, xy_t x, xy_t y, wh_t w,\n                        wh_t h) {\n  return_value_if_fail(vt != NULL, NULL);\n\n  return widget_init(widget_real_create(vt), parent, vt, x, y, w, h);\n}\n\nret_t widget_destroy(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->ref_count > 0 && widget->vt != NULL,\n                       RET_BAD_PARAMS);\n\n  if (widget->parent != NULL) {\n    widget_remove_child(widget->parent, widget);\n  }\n\n  return widget_unref_async(widget);\n}\n\nstatic ret_t widget_destroy_on_idle(const idle_info_t* info) {\n  widget_destroy(WIDGET(info->ctx));\n\n  return RET_REMOVE;\n}\n\nret_t widget_destroy_async(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->ref_count > 0 && widget->vt != NULL,\n                       RET_BAD_PARAMS);\n\n  return_value_if_fail(idle_add(widget_destroy_on_idle, widget) != TK_INVALID_ID, RET_FAIL);\n\n  return RET_OK;\n}\n\nstatic ret_t widget_set_parent_not_dirty(widget_t* widget) {\n  widget_t* iter = widget->parent;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    iter->dirty = FALSE;\n    if (iter->vt->is_window) {\n      break;\n    }\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_invalidate(widget_t* widget, const rect_t* r) {\n  rect_t rself;\n  return_value_if_fail(widget != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->dirty) {\n    return RET_OK;\n  }\n\n  if (r == NULL) {\n    rself = rect_init(0, 0, widget->w, widget->h);\n    r = &rself;\n  }\n\n  widget->dirty = TRUE;\n  widget_set_parent_not_dirty(widget);\n\n  if (widget->vt && widget->vt->invalidate) {\n    return widget->vt->invalidate(widget, r);\n  } else {\n    return widget_invalidate_default(widget, r);\n  }\n}\n\nret_t widget_invalidate_force(widget_t* widget, const rect_t* r) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->dirty = FALSE;\n  return widget_invalidate(widget, r);\n}\n\nwidget_t* widget_init(widget_t* widget, widget_t* parent, const widget_vtable_t* vt, xy_t x, xy_t y,\n                      wh_t w, wh_t h) {\n  return_value_if_fail(widget != NULL && vt != NULL, NULL);\n\n  widget->x = x;\n  widget->y = y;\n  widget->w = w;\n  widget->h = h;\n  widget->vt = vt;\n  widget->dirty = TRUE;\n  widget->ref_count = 1;\n  widget->opacity = 0xff;\n  widget->enable = TRUE;\n  widget->visible = TRUE;\n  widget->feedback = FALSE;\n  widget->auto_adjust_size = FALSE;\n  widget->sensitive = TRUE;\n  widget->emitter = NULL;\n  widget->children = NULL;\n  widget->initializing = TRUE;\n  widget->state = tk_strdup(WIDGET_STATE_NORMAL);\n  widget->target = NULL;\n  widget->key_target = NULL;\n  widget->grab_widget = NULL;\n  widget->grab_widget_count = 0;\n  widget->focused = FALSE;\n  widget->focusable = FALSE;\n  widget->with_focus_state = FALSE;\n  widget->dirty_rect_tolerance = 4;\n  widget->need_update_style = TRUE;\n\n  if (parent) {\n    widget_add_child(parent, widget);\n  }\n\n  wstr_init(&(widget->text), 0);\n  if (!widget->vt) {\n    widget->vt = widget_vtable_default();\n  }\n\n  if (widget->astyle == NULL &&\n      (widget_is_window_manager(widget) || widget_get_window(widget) != NULL)) {\n    widget->astyle = style_factory_create_style(style_factory(), widget_get_style_type(widget));\n    ENSURE(widget->astyle != NULL);\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  }\n\n  widget_invalidate_force(widget, NULL);\n\n  widget->initializing = FALSE;\n\n  return widget;\n}\n\nret_t widget_get_prop_default_value(widget_t* widget, const char* name, value_t* v) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    value_set_int32(v, 0xff);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    value_set_int(v, 4);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n    value_set_wstr(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSED)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    value_set_bool(v, FALSE);\n  } else {\n    if (widget->vt->get_prop_default_value) {\n      ret = widget->vt->get_prop_default_value(widget, name, v);\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_get_offset(widget_t* widget, xy_t* out_x, xy_t* out_y) {\n  return_value_if_fail(widget != NULL && out_x != NULL && out_y != NULL, RET_BAD_PARAMS);\n  *out_x = 0;\n  *out_y = 0;\n  if (widget->vt != NULL && widget->vt->get_offset != NULL) {\n    return widget->vt->get_offset(widget, out_x, out_y);\n  }\n  return RET_OK;\n}\n\nret_t widget_to_screen_ex(widget_t* widget, widget_t* parent, point_t* p) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL && p != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL && iter != parent) {\n    xy_t offset_x, offset_y;\n    if (widget_get_offset(iter, &offset_x, &offset_y) == RET_OK) {\n      p->x -= offset_x;\n      p->y -= offset_y;\n    }\n\n    p->x += iter->x;\n    p->y += iter->y;\n\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_to_screen(widget_t* widget, point_t* p) {\n  return widget_to_screen_ex(widget, NULL, p);\n}\n\nret_t widget_to_local(widget_t* widget, point_t* p) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL && p != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    xy_t offset_x = 0;\n    xy_t offset_y = 0;\n    if (widget_get_offset(iter, &offset_x, &offset_y) == RET_OK) {\n      p->x += offset_x;\n      p->y += offset_y;\n    }\n\n    p->x -= iter->x;\n    p->y -= iter->y;\n\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_to_global(widget_t* widget, point_t* p) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL && p != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    p->x += iter->x;\n    p->y += iter->y;\n\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nint32_t widget_count_children(widget_t* widget) {\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget->children != NULL ? widget->children->size : 0;\n}\n\nwidget_t* widget_get_child(widget_t* widget, int32_t index) {\n  return_value_if_fail(widget != NULL, NULL);\n  if (widget->children == NULL || index >= widget->children->size) {\n    return NULL;\n  }\n\n  return WIDGET(widget->children->elms[index]);\n}\n\nint32_t widget_index_of(widget_t* widget) {\n  widget_t* parent = NULL;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, -1);\n\n  parent = widget->parent;\n  WIDGET_FOR_EACH_CHILD_BEGIN(parent, iter, i)\n  if (iter == widget) {\n    return i;\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return -1;\n}\n\nret_t widget_prepare_text_style_ex(widget_t* widget, canvas_t* c, color_t default_trans,\n                                   const char* default_font, uint16_t default_font_size,\n                                   align_h_t default_align_h, align_v_t default_align_v) {\n  style_t* style = widget->astyle;\n  color_t tc = style_get_color(style, STYLE_ID_TEXT_COLOR, default_trans);\nconst char* font_name = ",
    "raw_res": "0;",
    "prompt_res": "style_get_str(style, STYLE_ID_FONT_NAME, default_font);",
    "gt": "style_get_str(style, STYLE_ID_FONT_NAME, default_font);"
  },
  {
    "id": 2491,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/widget.c",
    "input": "﻿/**\n * File:   widget.c\n * Author: AWTK Develop Team\n * Brief:  basic class of all widget\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-13 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/fscript.h\"\n#include \"tkc/tokenizer.h\"\n#include \"tkc/color_parser.h\"\n#include \"tkc/object_default.h\"\n\n#include \"base/keys.h\"\n#include \"base/enums.h\"\n#include \"base/theme.h\"\n#include \"tkc/time_now.h\"\n#include \"base/idle.h\"\n#include \"base/widget.h\"\n#include \"base/layout.h\"\n#include \"native_window.h\"\n#include \"base/main_loop.h\"\n#include \"base/ui_feedback.h\"\n#include \"base/system_info.h\"\n#include \"base/window_manager.h\"\n#include \"base/widget_vtable.h\"\n#include \"base/style_mutable.h\"\n#include \"base/style_factory.h\"\n#include \"base/widget_animator_manager.h\"\n#include \"base/widget_animator_factory.h\"\n#include \"base/window_base.h\"\n#include \"blend/image_g2d.h\"\n\nret_t widget_focus_up(widget_t* widget);\nret_t widget_focus_down(widget_t* widget);\nret_t widget_focus_left(widget_t* widget);\nret_t widget_focus_right(widget_t* widget);\nstatic ret_t widget_unref_async(widget_t* widget);\nstatic ret_t widget_ensure_style_mutable(widget_t* widget);\nstatic ret_t widget_dispatch_blur_event(widget_t* widget);\n/*虚函数的包装*/\nstatic ret_t widget_on_paint_done(widget_t* widget, canvas_t* c);\nstatic ret_t widget_on_paint_begin(widget_t* widget, canvas_t* c);\nstatic ret_t widget_on_paint_end(widget_t* widget, canvas_t* c);\n\ntypedef widget_t* (*widget_find_wanted_focus_widget_t)(widget_t* widget, darray_t* all_focusable);\nstatic ret_t widget_move_focus(widget_t* widget, widget_find_wanted_focus_widget_t find);\n\n#define widget_set_xywh(widget, val, update_layout, invalidate)    \\\n  do {                                                             \\\n    if (widget->val != val) {                                      \\\n      if (invalidate) widget_invalidate_force(widget, NULL);       \\\n      widget->val = val;                                           \\\n      if (invalidate) widget_invalidate_force(widget, NULL);       \\\n    }                                                              \\\n    if (update_layout && widget->self_layout != NULL) {            \\\n      self_layouter_set_param_str(widget->self_layout, #val, \"n\"); \\\n    }                                                              \\\n  } while (0)\n\nstatic ret_t widget_set_x(widget_t* widget, xy_t x, bool_t update_layout) {\n  widget_set_xywh(widget, x, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_y(widget_t* widget, xy_t y, bool_t update_layout) {\n  widget_set_xywh(widget, y, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_w(widget_t* widget, wh_t w, bool_t update_layout) {\n  widget_set_xywh(widget, w, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_h(widget_t* widget, xy_t h, bool_t update_layout) {\n  widget_set_xywh(widget, h, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic bool_t widget_is_strongly_focus(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n  if (win != NULL) {\n    return WINDOW_BASE(win)->strongly_focus;\n  } else {\n    return FALSE;\n  }\n}\n\nret_t widget_set_need_update_style(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (!widget->need_update_style) {\n    widget_invalidate_force(widget, NULL);\n  }\n\n  widget->need_update_style = TRUE;\n\n  return RET_OK;\n}\n\nret_t widget_update_style_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_update_style(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_update_style_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_set_need_update_style_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_need_update_style(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_set_need_update_style_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_update_style(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->astyle != NULL, RET_BAD_PARAMS);\n\n  if (widget->need_update_style) {\n    widget->need_update_style = FALSE;\n    return style_notify_widget_state_changed(widget->astyle, widget);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_real_destroy(widget_t* widget) {\n  ENSURE(widget->ref_count == 1);\n\n  if (widget->vt->on_destroy) {\n    widget->vt->on_destroy(widget);\n  }\n\n  TKMEM_FREE(widget->name);\n  TKMEM_FREE(widget->state);\n  TKMEM_FREE(widget->style);\n  TKMEM_FREE(widget->tr_text);\n  TKMEM_FREE(widget->animation);\n  TKMEM_FREE(widget->pointer_cursor);\n  TK_OBJECT_UNREF(widget->custom_props);\n  wstr_reset(&(widget->text));\n  style_destroy(widget->astyle);\n\n  memset(widget, 0x00, sizeof(widget_t));\n  TKMEM_FREE(widget);\n\n  return RET_OK;\n}\n\nstatic widget_t* widget_real_create(const widget_vtable_t* vt) {\n  widget_t* widget = TKMEM_ALLOC(vt->size);\n  return_value_if_fail(widget != NULL, NULL);\n\n  memset(widget, 0x00, vt->size);\n  widget->vt = vt;\n\n  return widget;\n}\n\nstatic bool_t widget_is_scrollable(widget_t* widget) {\n  return widget != NULL && widget->vt != NULL && widget->vt->scrollable;\n}\n\nstatic bool_t widget_with_focus_state(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n  value_set_bool(&v, FALSE);\n  widget_get_prop(widget, WIDGET_PROP_WITH_FOCUS_STATE, &v);\n\n  return value_bool(&v);\n}\n\nbool_t widget_is_focusable(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  if (!widget->visible || !widget->sensitive || !widget->enable) {\n    return FALSE;\n  }\n\n  return widget->focusable || widget->vt->focusable;\n}\n\nret_t widget_move(widget_t* widget, xy_t x, xy_t y) {\n  event_t e = event_init(EVT_WILL_MOVE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->x != x || widget->y != y) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, x, TRUE, FALSE);\n    widget_set_xywh(widget, y, TRUE, FALSE);\n    widget_invalidate_force(widget, NULL);\n\n    e.type = EVT_MOVE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_to_center(widget_t* widget) {\n  int32_t x = 0;\n  int32_t y = 0;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, RET_BAD_PARAMS);\n\n  x = (widget->parent->w - widget->w) / 2;\n  y = (widget->parent->h - widget->h) / 2;\n\n  return widget_move(widget, x, y);\n}\n\nret_t widget_resize(widget_t* widget, wh_t w, wh_t h) {\n  event_t e = event_init(EVT_WILL_RESIZE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->w != w || widget->h != h) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, w, TRUE, FALSE);\n    widget_set_xywh(widget, h, TRUE, FALSE);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget);\n\n    e.type = EVT_RESIZE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_resize_ex(widget_t* widget, xy_t x, xy_t y, wh_t w, wh_t h,\n                            bool_t update_layout) {\n  event_t e = event_init(EVT_WILL_MOVE_RESIZE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->x != x || widget->y != y || widget->w != w || widget->h != h) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, x, update_layout, FALSE);\n    widget_set_xywh(widget, y, update_layout, FALSE);\n    widget_set_xywh(widget, w, update_layout, FALSE);\n    widget_set_xywh(widget, h, update_layout, FALSE);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget);\n\n    e.type = EVT_MOVE_RESIZE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_resize(widget_t* widget, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return widget_move_resize_ex(widget, x, y, w, h, TRUE);\n}\n\nfloat_t widget_get_value(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_VALUE, &v) == RET_OK ? value_float32(&v) : 0.0f;\n}\n\nret_t widget_set_value(widget_t* widget, float_t value) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_VALUE, value_set_float32(&v, value));\n}\n\nret_t widget_add_value(widget_t* widget, float_t delta) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_value(widget, widget_get_value(widget) + delta);\n}\n\nint32_t widget_get_value_int(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_VALUE, &v) == RET_OK ? value_int(&v) : 0;\n}\n\nret_t widget_set_value_int(widget_t* widget, int32_t value) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_VALUE, value_set_int(&v, value));\n}\n\nret_t widget_add_value_int(widget_t* widget, int32_t delta) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_value_int(widget, widget_get_value_int(widget) + delta);\n}\n\nstatic ret_t widget_animate_prop_float_to(widget_t* widget, const char* name, float_t value,\n                                          uint32_t duration) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL, RET_BAD_PARAMS);\n  if (duration == 0) {\n    ret = widget_set_prop_float(widget, name, value);\n  } else {\n    float_t prev_value = widget_get_prop_float(widget, name, 0.0f);\n    widget_destroy_animator(widget, name);\n\n    if (prev_value != value) {\n      char params[128] = {0};\n      tk_snprintf(params, sizeof(params) - 1, \"%s(from=%f,to=%f,duration=%d)\", name, prev_value,\n                  value, duration);\n      ret = widget_create_animator(widget, params);\n    }\n  }\n  return ret;\n}\n\nret_t widget_animate_value_to(widget_t* widget, float_t value, uint32_t duration) {\n  return widget_animate_prop_float_to(widget, WIDGET_PROP_VALUE, value, duration);\n}\n\nbool_t widget_is_window_opened(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n    return WINDOW_STAGE_OPENED == stage || WINDOW_STAGE_SUSPEND == stage;\n  } else {\n    return FALSE;\n  }\n}\n\nbool_t widget_is_window_created(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n    return WINDOW_STAGE_OPENED == stage || WINDOW_STAGE_SUSPEND == stage ||\n           WINDOW_STAGE_LOADED == stage || WINDOW_STAGE_CREATED == stage;\n  } else {\n    return FALSE;\n  }\n}\n\nret_t widget_get_window_theme(widget_t* widget, theme_t** win_theme, theme_t** default_theme) {\n  value_t v;\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    if (widget_get_prop(win, WIDGET_PROP_THEME_OBJ, &v) == RET_OK) {\n      *win_theme = (theme_t*)value_pointer(&v);\n    }\n\n    if (widget_get_prop(win, WIDGET_PROP_DEFAULT_THEME_OBJ, &v) == RET_OK) {\n      *default_theme = (theme_t*)value_pointer(&v);\n    }\n  }\n  return RET_OK;\n}\n\nbool_t widget_is_style_exist(widget_t* widget, const char* style_name, const char* state_name) {\n  const void* data = NULL;\n  const char* style = NULL;\n  const char* state = NULL;\n  theme_t* win_theme = NULL;\n  theme_t* default_theme = NULL;\n  const char* type = widget_get_type(widget);\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(widget != NULL && win != NULL, FALSE);\n\n  if (style_name == NULL || *style_name == 0) {\n    style = TK_DEFAULT_STYLE;\n  } else {\n    style = style_name;\n  }\n\n  if (state_name == NULL || *state_name == 0) {\n    state = WIDGET_STATE_NORMAL;\n  } else {\n    state = state_name;\n  }\n\n  return_value_if_fail(widget_get_window_theme(widget, &win_theme, &default_theme) == RET_OK,\n                       FALSE);\n\n  if (win_theme != NULL) {\n    data = theme_find_style(win_theme, type, style, state);\n  }\n\n  if (data == NULL && default_theme != NULL) {\n    data = theme_find_style(default_theme, type, style, state);\n  }\n\n  return data != NULL;\n}\n\nret_t widget_use_style(widget_t* widget, const char* value) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_need_update_style(widget);\n  widget->style = tk_str_copy(widget->style, value);\n\n  if (widget_is_window_opened(widget)) {\n    widget_update_style(widget);\n    return widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_text(widget_t* widget, const wchar_t* text) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_wstr(&v, text));\n}\n\nret_t widget_set_text_utf8(widget_t* widget, const char* text) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_str(&v, text));\n}\n\nret_t widget_get_text_utf8(widget_t* widget, char* text, uint32_t size) {\n  value_t v;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && text != NULL && size > 0, RET_BAD_PARAMS);\n\n  value_set_str(&v, NULL);\n  memset(text, 0x00, size);\n  if (widget_get_prop(widget, WIDGET_PROP_TEXT, &v) == RET_OK) {\n    if (v.type == VALUE_TYPE_STRING) {\n      tk_strncpy(text, value_str(&v), size - 1);\n      ret = RET_OK;\n    } else if (v.type == VALUE_TYPE_WSTRING) {\n      tk_utf8_from_utf16(value_wstr(&v), text, size);\n      ret = RET_OK;\n    }\n  }\n\n  return ret;\n}\n\nimage_manager_t* widget_get_image_manager(widget_t* widget) {\n  image_manager_t* ret = image_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = image_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_IMAGE_MANAGER, &v) == RET_OK) {\n      ret = (image_manager_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nlocale_info_t* widget_get_locale_info(widget_t* widget) {\n  locale_info_t* ret = locale_info();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = locale_info();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_LOCALE_INFO, &v) == RET_OK) {\n      ret = (locale_info_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nassets_manager_t* widget_get_assets_manager(widget_t* widget) {\n  assets_manager_t* am = assets_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, am);\n\n  if (widget->assets_manager != NULL) {\n    return widget->assets_manager;\n  }\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    am = assets_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_ASSETS_MANAGER, &v) == RET_OK) {\n      am = (assets_manager_t*)value_pointer(&v);\n    }\n  }\n  widget->assets_manager = am;\n\n  return am;\n}\n\nfont_manager_t* widget_get_font_manager(widget_t* widget) {\n  font_manager_t* ret = font_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = font_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_FONT_MANAGER, &v) == RET_OK) {\n      ret = (font_manager_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_apply_tr_text_before_paint(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  if (widget->tr_text != NULL) {\n    const char* text = locale_info_tr(widget_get_locale_info(widget), widget->tr_text);\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n  }\n\n  return RET_REMOVE;\n}\n\nret_t widget_set_tr_text(widget_t* widget, const char* text) {\n  const char* tr_text = NULL;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(widget != NULL, RET_OK);\n\n  if (text == NULL || *text == '\\0') {\n    if (widget->tr_text != NULL) {\n      TKMEM_FREE(widget->tr_text);\n      widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n    }\n\n    return RET_OK;\n  }\n\n  widget->tr_text = tk_str_copy(widget->tr_text, text);\n  if (win != NULL) {\n    tr_text = locale_info_tr(widget_get_locale_info(widget), text);\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, tr_text);\n  } else {\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n    widget_on(widget, EVT_BEFORE_PAINT, widget_apply_tr_text_before_paint, widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_re_translate_text(widget_t* widget) {\n  if (widget->vt->on_re_translate != NULL) {\n    widget->vt->on_re_translate(widget);\n  }\n  if (widget->tr_text != NULL) {\n    value_t v;\n    const char* tr_text = locale_info_tr(widget_get_locale_info(widget), widget->tr_text);\n    widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_str(&v, tr_text));\n    widget_invalidate(widget, NULL);\n  }\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_re_translate_text(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nconst wchar_t* widget_get_text(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_TEXT, &v) == RET_OK ? value_wstr(&v) : 0;\n}\n\nret_t widget_set_name(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (name != NULL) {\n    widget->name = tk_str_copy(widget->name, name);\n  } else {\n    TKMEM_FREE(widget->name);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_theme(widget_t* widget, const char* name) {\n  theme_change_event_t will_event;\n  event_t* will_evt = theme_change_event_init(&will_event, EVT_THEME_WILL_CHANGE, name);\n  widget_dispatch(window_manager(), will_evt);\n#ifdef WITH_FS_RES\n  const asset_info_t* info = NULL;\n  theme_change_event_t event;\n  event_t* evt = theme_change_event_init(&event, EVT_THEME_CHANGED, name);\n  widget_t* wm = widget_get_window_manager(widget);\n  font_manager_t* fm = widget_get_font_manager(widget);\n  image_manager_t* imm = widget_get_image_manager(widget);\n  assets_manager_t* am = widget_get_assets_manager(widget);\n  locale_info_t* locale_info = widget_get_locale_info(widget);\n  return_value_if_fail(am != NULL && name != NULL, RET_BAD_PARAMS);\n\n  font_manager_unload_all(fm);\n  image_manager_unload_all(imm);\n  locale_info_reload(locale_info);\n  assets_manager_set_theme(am, name);\n  widget_reset_canvas(widget);\n\n  info = assets_manager_ref(am, ASSET_TYPE_STYLE, \"default\");\n  if (info != NULL) {\n    theme_set(theme_load_from_data(info->name, info->data, info->size));\n    assets_manager_unref(assets_manager(), info);\n  }\n\n  widget_dispatch(wm, evt);\n  widget_invalidate_force(wm, NULL);\n\n  log_debug(\"theme changed: %s\\n\", name);\n#endif\n\n  return RET_OK;\n}\n\nret_t widget_set_pointer_cursor(widget_t* widget, const char* cursor) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (!tk_str_eq(widget->pointer_cursor, cursor)) {\n    widget->pointer_cursor = tk_str_copy(widget->pointer_cursor, cursor);\n    widget_update_pointer_cursor(widget);\n  }\n\n  return RET_OK;\n}\n\n#ifndef WITHOUT_WIDGET_ANIMATORS\nret_t widget_set_animation(widget_t* widget, const char* animation) {\n  return_value_if_fail(widget != NULL && animation != NULL, RET_BAD_PARAMS);\n\n  widget->animation = tk_str_copy(widget->animation, animation);\n\n  return widget_create_animator(widget, animation);\n}\n\nret_t widget_create_animator(widget_t* widget, const char* animation) {\n  tokenizer_t t;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && animation != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(tokenizer_init(&t, animation, strlen(animation), \";\") != NULL, RET_OOM);\n\n  while (tokenizer_has_more(&t)) {\n    const char* params = tokenizer_next(&t);\n    if (widget_animator_create(widget, params) == NULL) {\n      ret = RET_BAD_PARAMS;\n      break;\n    }\n  }\n  tokenizer_deinit(&t);\n  widget_invalidate(widget, NULL);\n\n  return ret;\n}\n\nret_t widget_start_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_start(widget_animator_manager(), widget, name);\n}\n\nret_t widget_set_animator_time_scale(widget_t* widget, const char* name, float_t time_scale) {\n  return widget_animator_manager_set_time_scale(widget_animator_manager(), widget, name,\n                                                time_scale);\n}\n\nret_t widget_pause_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_pause(widget_animator_manager(), widget, name);\n}\n\nwidget_animator_t* widget_find_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_find(widget_animator_manager(), widget, name);\n}\n\nret_t widget_stop_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_stop(widget_animator_manager(), widget, name);\n}\n\nret_t widget_destroy_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_remove_all(widget_animator_manager(), widget, name);\n}\n#else\nret_t widget_start_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nret_t widget_create_animator(widget_t* widget, const char* animation) {\n  return RET_OK;\n}\nret_t widget_set_animation(widget_t* widget, const char* animation) {\n  return RET_OK;\n}\nret_t widget_set_animator_time_scale(widget_t* widget, const char* name, float_t time_scale) {\n  return RET_OK;\n}\nret_t widget_pause_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nwidget_animator_t* widget_find_animator(widget_t* widget, const char* name) {\n  return NULL;\n}\nret_t widget_stop_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nret_t widget_destroy_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\n#endif /*WITHOUT_WIDGET_ANIMATORS*/\n\nret_t widget_set_enable(widget_t* widget, bool_t enable) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->enable != enable) {\n    widget->enable = enable;\n    widget_set_need_update_style_recursive(widget);\n    widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_feedback(widget_t* widget, bool_t feedback) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->feedback = feedback;\n\n  return RET_OK;\n}\n\nret_t widget_set_auto_adjust_size(widget_t* widget, bool_t auto_adjust_size) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->auto_adjust_size = auto_adjust_size;\n  widget_set_need_relayout(widget);\n\n  return RET_OK;\n}\n\nret_t widget_set_floating(widget_t* widget, bool_t floating) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->floating = floating;\n\n  return RET_OK;\n}\n\nret_t widget_set_focused_internal(widget_t* widget, bool_t focused) {\n  widget_t* win = widget_get_window(widget);\n  int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (WINDOW_STAGE_SUSPEND == stage) {\n    log_debug(\"You can not set focus of a widget when window is in background\");\n    return RET_FAIL;\n  }\n\n  if (widget->focused != focused) {\n    widget->focused = focused;\n    widget_set_need_update_style(widget);\n\n    if (focused) {\n      event_t e = event_init(EVT_FOCUS, widget);\n      widget_set_as_key_target(widget);\n\n      widget_dispatch(widget, &e);\n    } else {\n      event_t e = event_init(EVT_BLUR, widget);\n      widget_dispatch(widget, &e);\n      widget_dispatch_blur_event(widget);\n    }\n\n    widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_focused(widget_t* widget, bool_t focused) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_focused_internal(widget, focused);\n  if (focused) {\n    widget_ensure_visible_in_viewport(widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_focusable(widget_t* widget, bool_t focusable) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->focusable = focusable;\n\n  return RET_OK;\n}\n\nret_t widget_set_state(widget_t* widget, const char* state) {\n  return_value_if_fail(widget != NULL && state != NULL, RET_BAD_PARAMS);\n\n  if (!tk_str_eq(widget->state, state)) {\n    widget_invalidate_force(widget, NULL);\n    widget->state = tk_str_copy(widget->state, state);\n    widget_set_need_update_style(widget);\n    widget_invalidate_force(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_state_for_style(widget_t* widget, bool_t active, bool_t checked) {\n  const char* state = WIDGET_STATE_NORMAL;\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, state);\n\n  state = (const char*)(widget->state);\n\n  while (iter != NULL) {\n    if (!iter->enable) {\n      if (active) return WIDGET_STATE_DISABLE_OF_ACTIVE;\n      if (checked) return WIDGET_STATE_DISABLE_OF_CHECKED;\n      return WIDGET_STATE_DISABLE;\n    }\n    iter = iter->parent;\n  }\n\n  if (widget_is_focusable(widget) || widget_with_focus_state(widget)) {\n    if (widget->focused) {\n      if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n        state = WIDGET_STATE_FOCUSED;\n      }\n    } else {\n      if (tk_str_eq(state, WIDGET_STATE_FOCUSED)) {\n        state = WIDGET_STATE_NORMAL;\n      }\n    }\n  }\n\n  if (active) {\n    if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n      state = WIDGET_STATE_NORMAL_OF_ACTIVE;\n    } else if (tk_str_eq(state, WIDGET_STATE_PRESSED)) {\n      state = WIDGET_STATE_PRESSED_OF_ACTIVE;\n    } else if (tk_str_eq(state, WIDGET_STATE_OVER)) {\n      state = WIDGET_STATE_OVER_OF_ACTIVE;\n    } else if (widget_is_focusable(widget) && widget->focused) {\n      state = WIDGET_STATE_FOCUSED_OF_ACTIVE;\n    }\n  } else if (checked) {\n    if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n      state = WIDGET_STATE_NORMAL_OF_CHECKED;\n    } else if (tk_str_eq(state, WIDGET_STATE_PRESSED)) {\n      state = WIDGET_STATE_PRESSED_OF_CHECKED;\n    } else if (tk_str_eq(state, WIDGET_STATE_OVER)) {\n      state = WIDGET_STATE_OVER_OF_CHECKED;\n    } else if (widget_is_focusable(widget) && widget->focused) {\n      state = WIDGET_STATE_FOCUSED_OF_CHECKED;\n    }\n  }\n\n  return state;\n}\n\nret_t widget_set_opacity(widget_t* widget, uint8_t opacity) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->opacity = opacity;\n  widget_invalidate(widget, NULL);\n\n  return RET_OK;\n}\n\nret_t widget_set_dirty_rect_tolerance(widget_t* widget, uint16_t dirty_rect_tolerance) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->dirty_rect_tolerance = dirty_rect_tolerance;\n  widget_invalidate(widget, NULL);\n\n  return RET_OK;\n}\n\nret_t widget_destroy_children(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->children != NULL) {\n    WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n\n    widget_remove_child_prepare(widget, iter);\n    widget_unref(iter);\n\n    widget->children->elms[i] = NULL;\n\n    WIDGET_FOR_EACH_CHILD_END();\n    widget->children->size = 0;\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_style_type(widget_t* widget) {\n  theme_t* win_theme = NULL;\n  theme_t* default_theme = NULL;\n  const char* style_type = THEME_DEFAULT_STYLE_TYPE;\n\n  if (widget_get_window_theme(widget, &win_theme, &default_theme) == RET_OK) {\n    theme_t* t = win_theme != NULL ? win_theme : (default_theme != NULL ? default_theme : theme());\n    if (t != NULL) {\n      style_type = theme_get_style_type(t);\n    }\n  }\n\n  return style_type;\n}\n\nstatic ret_t widget_update_style_object(widget_t* widget) {\n  const char* style_type = widget_get_style_type(widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  if (widget->astyle == NULL) {\n    widget->astyle = style_factory_create_style(style_factory(), style_type);\n    ENSURE(widget->astyle != NULL);\n\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  } else if (widget->astyle != NULL &&\n             !tk_str_eq(style_get_style_type(widget->astyle), style_type)) {\n    style_t* style = style_factory_create_style(style_factory(), style_type);\n    ENSURE(style != NULL);\n    if (style_is_mutable(widget->astyle)) {\n      style_mutable_set_default_style(widget->astyle, style);\n    } else {\n      style_destroy(widget->astyle);\n      widget->astyle = style;\n    }\n\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  }\n  return RET_OK;\n}\n\nstatic ret_t widget_update_style_object_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_update_style_object(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_update_style_object_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_add_child(widget_t* widget, widget_t* child) {\n  event_t e = event_init(EVT_WIDGET_ADD_CHILD, widget);\n  return_value_if_fail(widget != NULL && child != NULL && child->parent == NULL, RET_BAD_PARAMS);\n\n  child->parent = widget;\n\n  if (widget->children == NULL) {\n    widget->children = darray_create(4, NULL, NULL);\n  }\n\n  if (widget->vt->on_add_child) {\n    if (widget->vt->on_add_child(widget, child) == RET_OK) {\n      return RET_OK;\n    }\n  }\n\n  if (child->vt->on_attach_parent) {\n    child->vt->on_attach_parent(child, widget);\n  }\n\n  ENSURE(darray_push(widget->children, child) == RET_OK);\n\n  if (!widget_is_window_manager(widget)) {\n    widget_set_need_relayout_children(widget);\n  }\n\n  if (!(child->initializing) && widget_get_window(child) != NULL) {\n    widget_set_need_update_style_recursive(child);\n    widget_update_style_object_recursive(child);\n  }\n\n  widget_dispatch(widget, &e);\n\n  return RET_OK;\n}\n\nret_t widget_remove_child_prepare(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n\n  if (!widget_is_window_manager(widget)) {\n    widget_set_need_relayout_children(widget);\n  }\n\n  widget_invalidate_force(child, NULL);\n  if (widget->target == child) {\n    widget->target = NULL;\n  }\n\n  if (widget->grab_widget == child) {\n    widget->grab_widget = NULL;\n    widget->grab_widget_count = 0;\n  }\n\n  if (widget->key_target == child) {\n    widget_dispatch_blur_event(widget->key_target);\n    widget->key_target = NULL;\n  }\n\n  if (widget->vt->on_remove_child) {\n    if (widget->vt->on_remove_child(widget, child) == RET_OK) {\n      return RET_OK;\n    }\n  }\n\n  if (child->vt->on_detach_parent) {\n    child->vt->on_detach_parent(child, widget);\n  }\n  child->parent = NULL;\n\n  return RET_OK;\n}\n\nret_t widget_remove_child(widget_t* widget, widget_t* child) {\n  ret_t ret = RET_OK;\n  event_t e = event_init(EVT_WIDGET_REMOVE_CHILD, widget);\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n\n  widget_remove_child_prepare(widget, child);\n  ret = darray_remove(widget->children, child);\n\n  if (ret == RET_OK) {\n    widget_dispatch(widget, &e);\n  }\n\n  return ret;\n}\n\nret_t widget_insert_child(widget_t* widget, uint32_t index, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget_add_child(widget, child) == RET_OK, RET_FAIL);\n\n  return widget_restack(child, index);\n}\n\nret_t widget_restack(widget_t* widget, uint32_t index) {\n  uint32_t i = 0;\n  uint32_t nr = 0;\n  int32_t old_index = 0;\n  widget_t** children = NULL;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, RET_BAD_PARAMS);\n\n  old_index = widget_index_of(widget);\n  nr = widget_count_children(widget->parent);\n  return_value_if_fail(old_index >= 0 && nr > 0, RET_BAD_PARAMS);\n\n  if (index >= nr) {\n    index = nr - 1;\n  }\n\n  if (index == old_index || nr == 1) {\n    return RET_OK;\n  }\n\n  children = (widget_t**)(widget->parent->children->elms);\n  if (index < old_index) {\n    for (i = old_index; i > index; i--) {\n      children[i] = children[i - 1];\n    }\n  } else {\n    for (i = old_index; i < index; i++) {\n      children[i] = children[i + 1];\n    }\n  }\n  children[index] = widget;\n\n  return RET_OK;\n}\n\nstatic widget_t* widget_lookup_child(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL && name != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (iter->name != NULL && tk_str_eq(iter->name, name)) {\n    return iter;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return NULL;\n}\n\nwidget_t* widget_child(widget_t* widget, const char* path) {\n  return widget_lookup_child(widget, path);\n}\n\nwidget_t* widget_get_focused_widget(widget_t* widget) {\n  widget_t* iter = NULL;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(win != NULL, NULL);\n\n  iter = win->key_target;\n  for (iter = win->key_target; iter != NULL; iter = iter->key_target) {\n    if (iter->focusable && iter->focused) {\n      return iter;\n    }\n\n    if (iter->key_target == NULL) {\n      return iter;\n    }\n  }\n\n  return NULL;\n}\n\nstatic widget_t* widget_lookup_all(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL && name != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (iter->name != NULL && tk_str_eq(iter->name, name)) {\n    return iter;\n  } else {\n    iter = widget_lookup_all(iter, name);\n    if (iter != NULL) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nwidget_t* widget_lookup(widget_t* widget, const char* name, bool_t recursive) {\n  if (recursive) {\n    return widget_lookup_all(widget, name);\n  } else {\n    return widget_lookup_child(widget, name);\n  }\n}\n\nstatic widget_t* widget_lookup_by_type_child(widget_t* widget, const char* type) {\n  return_value_if_fail(widget != NULL && type != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (tk_str_eq(iter->vt->type, type)) {\n    return iter;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return NULL;\n}\n\nstatic widget_t* widget_lookup_by_type_all(widget_t* widget, const char* type) {\n  return_value_if_fail(widget != NULL && type != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (tk_str_eq(iter->vt->type, type)) {\n    return iter;\n  } else {\n    iter = widget_lookup_by_type_all(iter, type);\n    if (iter != NULL) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nwidget_t* widget_lookup_by_type(widget_t* widget, const char* type, bool_t recursive) {\n  if (recursive) {\n    return widget_lookup_by_type_all(widget, type);\n  } else {\n    return widget_lookup_by_type_child(widget, type);\n  }\n}\n\nstatic ret_t widget_set_visible_self(widget_t* widget, bool_t visible) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->visible != visible) {\n    widget_invalidate_force(widget, NULL);\n    widget->visible = visible;\n    widget_set_need_update_style(widget);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget->parent);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_sensitive(widget_t* widget, bool_t sensitive) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->sensitive = sensitive;\n\n  return RET_OK;\n}\n\nret_t widget_set_visible_only(widget_t* widget, bool_t visible) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->visible = visible;\n\n  return RET_OK;\n}\n\nret_t widget_set_visible(widget_t* widget, bool_t visible, ...) {\n  return widget_set_visible_self(widget, visible);\n}\n\nwidget_t* widget_find_target(widget_t* widget, xy_t x, xy_t y) {\n  widget_t* ret = NULL;\n  return_value_if_fail(widget != NULL, NULL);\n\n  if (widget->vt && widget->vt->find_target) {\n    ret = widget->vt->find_target(widget, x, y);\n  } else {\n    ret = widget_find_target_default(widget, x, y);\n  }\n\n  return ret;\n}\n\nret_t widget_on_event_before_children(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt && widget->vt->on_event_before_children) {\n    ret = widget->vt->on_event_before_children(widget, e);\n  }\n\n  return ret;\n}\n\nstatic const char* widget_get_pointer_cursor(widget_t* widget) {\n  if (widget->pointer_cursor != NULL) {\n    return widget->pointer_cursor;\n  } else if (widget->vt->pointer_cursor != NULL) {\n    return widget->vt->pointer_cursor;\n  }\n\n  return WIDGET_CURSOR_DEFAULT;\n}\n\nret_t widget_update_pointer_cursor(widget_t* widget) {\n  widget_t* wm = widget_get_window_manager(widget);\n  return_value_if_fail(wm != NULL, RET_BAD_PARAMS);\n\n  return window_manager_set_cursor(wm, widget_get_pointer_cursor(widget));\n}\n\nret_t widget_dispatch(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  if (e->target == NULL) {\n    e->target = widget;\n  }\n\n  if (widget->vt && widget->vt->on_event) {\n    ret = widget->vt->on_event(widget, e);\n  } else {\n    ret = widget_on_event_default(widget, e);\n  }\n\n  if (ret != RET_STOP) {\n    if (widget->emitter != NULL) {\n      void* saved_target = e->target;\n\n      e->target = widget;\n      ret = emitter_dispatch(widget->emitter, e);\n      e->target = saved_target;\n    }\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t dispatch_in_idle(const idle_info_t* info) {\n  event_t* e = (event_t*)(info->ctx);\n  widget_t* widget = WIDGET(e->target);\n\n  widget_dispatch(widget, e);\n  widget_unref(widget);\n  event_destroy(e);\n\n  return RET_REMOVE;\n}\n\nret_t widget_dispatch_async(widget_t* widget, event_t* e) {\n  event_t* evt = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(e->target == widget, RET_BAD_PARAMS);\n\n  evt = event_clone(e);\n  return_value_if_fail(evt != NULL, RET_OOM);\n\n  widget_ref(widget);\n  idle_add(dispatch_in_idle, evt);\n\n  return RET_OK;\n}\n\nstatic ret_t widget_dispatch_callback(void* ctx, const void* data) {\n  widget_t* widget = WIDGET(data);\n\n  return widget_dispatch(widget, (event_t*)ctx);\n}\n\nret_t widget_dispatch_recursive(widget_t* widget, event_t* e) {\n  return widget_foreach(widget, widget_dispatch_callback, e);\n}\n\nuint32_t widget_on_with_tag(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx,\n                            uint32_t tag) {\n  return_value_if_fail(widget != NULL && on_event != NULL, RET_BAD_PARAMS);\n  if (widget->emitter == NULL) {\n    widget->emitter = emitter_create();\n  }\n\n  return emitter_on_with_tag(widget->emitter, type, on_event, ctx, tag);\n}\n\nuint32_t widget_on(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx) {\n  return widget_on_with_tag(widget, type, on_event, ctx, 0);\n}\n\nuint32_t widget_child_on(widget_t* widget, const char* name, uint32_t type, event_func_t on_event,\n                         void* ctx) {\n  return widget_on(widget_lookup(widget, name, TRUE), type, on_event, ctx);\n}\n\nret_t widget_off(widget_t* widget, uint32_t id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->emitter != NULL, RET_BAD_PARAMS);\n\n  return emitter_off(widget->emitter, id);\n}\n\nret_t widget_off_by_tag(widget_t* widget, uint32_t tag) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_tag(widget->emitter, tag);\n}\n\nret_t widget_off_by_ctx(widget_t* widget, void* ctx) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_ctx(widget->emitter, ctx);\n}\n\nret_t widget_off_by_func(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx) {\n  return_value_if_fail(widget != NULL && on_event != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_func(widget->emitter, type, on_event, ctx);\n}\n\nret_t widget_calc_icon_text_rect(const rect_t* ir, int32_t font_size, float_t text_size,\n                                 int32_t icon_at, uint32_t img_w, uint32_t img_h, int32_t spacer,\n                                 rect_t* r_text, rect_t* r_icon) {\n  return_value_if_fail(ir != NULL && (r_text != NULL || r_icon != NULL), RET_BAD_PARAMS);\n\n  if (r_icon == NULL) {\n    *r_text = *ir;\n\n    return RET_OK;\n  }\n\n  if (r_text == NULL) {\n    *r_icon = *ir;\n\n    return RET_OK;\n  }\n\n  return_value_if_fail(spacer < ir->h && spacer < ir->w, RET_BAD_PARAMS);\n  switch (icon_at) {\n    case ICON_AT_CENTRE: {\n      int32_t w = ir->w - spacer - text_size - img_w;\n      int32_t icon_h = ir->h - img_h;\n      *r_text = rect_init(ir->x + img_w + spacer + w / 2, ir->y, text_size, ir->h);\n      *r_icon = rect_init(ir->x + w / 2, ir->y + icon_h / 2, img_w, img_h);\n      break;\n    }\n    case ICON_AT_RIGHT: {\n      uint32_t w = img_w;\n      float_t ratio = system_info()->device_pixel_ratio;\n      if (ratio > 1) {\n        w = img_w / ratio;\n      }\n      w = tk_min(tk_max(w, ir->h), ir->w);\n      *r_icon = rect_init(ir->x + ir->w - w, ir->y, w, ir->h);\n      *r_text = rect_init(ir->x, ir->y, ir->w - ir->h - spacer, ir->h);\n      break;\n    }\n    case ICON_AT_TOP: {\n      int32_t icon_h = ir->h - font_size - spacer;\n      *r_icon = rect_init(ir->x, ir->y, ir->w, icon_h);\n      *r_text = rect_init(ir->x, icon_h + spacer, ir->w, font_size);\n      break;\n    }\n    case ICON_AT_BOTTOM: {\n      int32_t icon_h = ir->h - font_size - spacer;\n      *r_icon = rect_init(ir->x, ir->y + ir->h - icon_h, ir->w, icon_h);\n      *r_text = rect_init(ir->x, ir->y, ir->w, font_size);\n      break;\n    }\n    case ICON_AT_LEFT:\n    default: {\n      *r_icon = rect_init(ir->x, ir->y, ir->h, ir->h);\n      *r_text = rect_init(ir->x + ir->h + spacer, ir->y, ir->w - ir->h - spacer, ir->h);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_bidi(widget_t* widget) {\n  value_t v;\n  if (widget_get_prop(widget, WIDGET_PROP_BIDI, &v) == RET_OK) {\n    return value_str(&v);\n  }\n\n  return NULL;\n}\n\nret_t widget_draw_icon_text(widget_t* widget, canvas_t* c, const char* icon, wstr_t* text) {\n  rect_t ir;\n  wh_t w = 0;\n  wh_t h = 0;\n  bitmap_t img;\n  rect_t r_icon;\n  rect_t r_text;\n  int32_t margin = 0;\n  int32_t spacer = 0;\n  int32_t icon_at = 0;\n  uint16_t font_size = 0;\n  float_t text_size = 0.0f;\n  int32_t margin_left = 0;\n  int32_t margin_right = 0;\n  int32_t margin_top = 0;\n  int32_t margin_bottom = 0;\n  style_t* style = widget->astyle;\n  int32_t align_h = ALIGN_H_LEFT;\n  int32_t align_v = ALIGN_V_MIDDLE;\n  return_value_if_fail(widget->astyle != NULL, RET_BAD_PARAMS);\n\n  spacer = style_get_int(style, STYLE_ID_SPACER, 2);\n  margin = style_get_int(style, STYLE_ID_MARGIN, 0);\n  margin_top = style_get_int(style, STYLE_ID_MARGIN_TOP, margin);\n  margin_left = style_get_int(style, STYLE_ID_MARGIN_LEFT, margin);\n  margin_right = style_get_int(style, STYLE_ID_MARGIN_RIGHT, margin);\n  margin_bottom = style_get_int(style, STYLE_ID_MARGIN_BOTTOM, margin);\n  icon_at = style_get_int(style, STYLE_ID_ICON_AT, ICON_AT_AUTO);\n\n  w = widget->w - margin_left - margin_right;\n  h = widget->h - margin_top - margin_bottom;\n  ir = rect_init(margin_left, margin_top, w, h);\n\n  if (text == NULL) {\n    text = &(widget->text);\n  }\n\n  if (icon == NULL) {\n    icon = style_get_str(style, STYLE_ID_ICON, NULL);\n  }\n\n  widget_prepare_text_style(widget, c);\n\n  font_size = c->font_size;\n  text_size = text->str ? canvas_measure_text(c, text->str, text->size) : 0;\n  if (icon_at == ICON_AT_RIGHT || icon_at == ICON_AT_LEFT) {\n    align_v = style_get_int(style, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    align_h = style_get_int(style, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_LEFT);\n  } else {\n    align_v = style_get_int(style, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    align_h = style_get_int(style, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_CENTER);\n  }\n  canvas_set_text_align(c, (align_h_t)align_h, (align_v_t)align_v);\n\n  if (icon != NULL && widget_load_image(widget, icon, &img) == RET_OK) {\n    float_t dpr = system_info()->device_pixel_ratio;\n\n    if (text->size > 0) {\n      if ((h > (img.h / dpr + font_size) && icon_at == ICON_AT_AUTO)) {\n        icon_at = ICON_AT_TOP;\n      }\n\n      widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer, &r_text,\n                                 &r_icon);\n\n      canvas_draw_icon_in_rect(c, &img, &r_icon);\n      widget_draw_text_in_rect(widget, c, text->str, text->size, &r_text, FALSE);\n    } else {\n      if (icon_at == ICON_AT_AUTO) {\n        widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer, NULL,\n                                   &r_icon);\n      } else {\n        widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer,\n                                   &r_text, &r_icon);\n      }\n      canvas_draw_icon_in_rect(c, &img, &r_icon);\n    }\n  } else if (text != NULL && text->size > 0) {\n    widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, 0, 0, spacer, &r_text, NULL);\n    widget_draw_text_in_rect(widget, c, text->str, text->size, &r_text, FALSE);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_fill_rect(widget_t* widget, canvas_t* c, const rect_t* r, bool_t bg,\n                       image_draw_type_t draw_type) {\n  bitmap_t img;\n  ret_t ret = RET_OK;\n  gradient_t agradient;\n  style_t* style = widget->astyle;\n  uint32_t radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  const char* color_key = bg ? STYLE_ID_BG_COLOR : STYLE_ID_FG_COLOR;\n  const char* image_key = bg ? STYLE_ID_BG_IMAGE : STYLE_ID_FG_IMAGE;\n  rect_t bg_r = rect_init(widget->x, widget->y, widget->w, widget->h);\n  uint32_t radius_tl = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_LEFT, radius);\n  uint32_t radius_tr = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_RIGHT, radius);\n  uint32_t radius_bl = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_LEFT, radius);\n  uint32_t radius_br = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_RIGHT, radius);\n  uint32_t clear_bg = style_get_uint(style, STYLE_ID_CLEAR_BG, 0);\n  const char* draw_type_key = bg ? STYLE_ID_BG_IMAGE_DRAW_TYPE : STYLE_ID_FG_IMAGE_DRAW_TYPE;\n  gradient_t* gradient = style_get_gradient(style, color_key, &agradient);\n  const char* image_name = style_get_str(style, image_key, NULL);\n\n  if (gradient != NULL && r->w > 0 && r->h > 0) {\n    color_t color = gradient_get_first_color(gradient);\n    canvas_set_fill_color(c, color);\n    if (gradient->nr > 1 || color.rgba.a) {\n      if (radius_tl > 3 || radius_tr > 3 || radius_bl > 3 || radius_br > 3) {\n        /*TODO: support gradient*/\n        if (bg) {\n          ret = canvas_fill_rounded_rect_gradient_ex(c, r, NULL, gradient, radius_tl, radius_tr,\n                                                     radius_bl, radius_br);\n        } else {\n          ret = canvas_fill_rounded_rect_gradient_ex(c, r, &bg_r, gradient, radius_tl, radius_tr,\n                                                     radius_bl, radius_br);\n        }\n        if (ret == RET_FAIL) {\n          canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n        }\n      } else if (gradient->nr > 1) {\n        canvas_fill_rect_gradient(c, r->x, r->y, r->w, r->h, gradient);\n      } else {\n        if (clear_bg) {\n          canvas_clear_rect(c, r->x, r->y, r->w, r->h);\n        } else {\n          canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n        }\n      }\n    } else if (clear_bg) {\n      canvas_clear_rect(c, r->x, r->y, r->w, r->h);\n    }\n  }\n\n  if (image_name != NULL && *image_name && r->w > 0 && r->h > 0) {\n    char name[MAX_PATH + 1];\n    const char* region = strrchr(image_name, '#');\n    if (region != NULL) {\n      memset(name, 0x00, sizeof(name));\n      tk_strncpy(name, image_name, region - image_name);\n      image_name = name;\n    }\n\n    if (widget_load_image(widget, image_name, &img) == RET_OK) {\n      draw_type = (image_draw_type_t)style_get_int(style, draw_type_key, draw_type);\n\n      if (region == NULL) {\n        canvas_draw_image_ex(c, &img, draw_type, r);\n      } else {\n        rect_t src;\n        rect_t dst = *r;\n        if (tk_str_eq(region, \"#\")) {\n          src = rect_init(widget->x, widget->y, widget->w, widget->h);\n        } else if (tk_str_eq(region, \"#g\")) {\n          point_t p = {widget->x, widget->y};\n          widget_to_global(widget, &p);\n          src = rect_init(p.x, p.y, widget->w, widget->h);\n        } else {\n          image_region_parse(img.w, img.h, region, &src);\n        }\n\n        canvas_draw_image_ex2(c, &img, draw_type, &src, &dst);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_stroke_border_rect_for_border_type(canvas_t* c, const rect_t* r, color_t bd,\n                                                int32_t border, uint32_t border_width) {\n  wh_t w = r->w;\n  wh_t h = r->h;\n  xy_t x = r->x + 0.5;\n  xy_t y = r->y + 0.5;\n  xy_t y1 = y;\n  wh_t h1 = h;\n  bool_t draw_top = FALSE;\n  bool_t draw_bottom = FALSE;\n  canvas_set_fill_color(c, bd);\n  if (border & BORDER_TOP) {\n    draw_top = TRUE;\n    canvas_fill_rect(c, x, y, w, border_width);\n  }\n  if (border & BORDER_BOTTOM) {\n    draw_bottom = TRUE;\n    canvas_fill_rect(c, x, y + h - border_width, w, border_width);\n  }\n  /* 减少重复绘制的部分，可以修复有透明的时候重叠区域显示不正常为问题 */\n  if (draw_top) {\n    y1 += border_width;\n    h1 -= border_width;\n  }\n  if (draw_bottom) {\n    h1 -= border_width;\n  }\n  if (border & BORDER_LEFT) {\n    canvas_fill_rect(c, x, y1, border_width, h1);\n  }\n  if (border & BORDER_RIGHT) {\n    canvas_fill_rect(c, x + w - border_width, y1, border_width, h1);\n  }\n  return RET_OK;\n}\n\nret_t widget_stroke_border_rect(widget_t* widget, canvas_t* c, const rect_t* r) {\n  style_t* style = widget->astyle;\n  color_t trans = color_init(0, 0, 0, 0);\n  color_t bd = style_get_color(style, STYLE_ID_BORDER_COLOR, trans);\n  uint32_t radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  int32_t border = style_get_int(style, STYLE_ID_BORDER, BORDER_ALL);\n  uint32_t border_width = style_get_int(style, STYLE_ID_BORDER_WIDTH, 1);\n  uint32_t radius_tl = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_LEFT, radius);\n  uint32_t radius_tr = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_RIGHT, radius);\n  uint32_t radius_bl = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_LEFT, radius);\n  uint32_t radius_br = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_RIGHT, radius);\n\n  if (bd.rgba.a) {\n    canvas_set_stroke_color(c, bd);\n    if (radius_tl > 3 || radius_tr > 3 || radius_bl > 3 || radius_br > 3) {\n      if (canvas_stroke_rounded_rect_ex(c, r, NULL, &bd, radius_tl, radius_tr, radius_bl, radius_br,\n                                        border_width, border) != RET_OK) {\n        widget_stroke_border_rect_for_border_type(c, r, bd, border, border_width);\n      }\n    } else {\n      widget_stroke_border_rect_for_border_type(c, r, bd, border, border_width);\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_draw_background(widget_t* widget, canvas_t* c) {\n  rect_t r;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  r = rect_init(0, 0, widget->w, widget->h);\n\n  return widget_fill_rect(widget, c, &r, TRUE, IMAGE_DRAW_CENTER);\n}\n\nret_t widget_fill_bg_rect(widget_t* widget, canvas_t* c, const rect_t* r,\n                          image_draw_type_t draw_type) {\n  return widget_fill_rect(widget, c, r, TRUE, draw_type);\n}\n\nret_t widget_fill_fg_rect(widget_t* widget, canvas_t* c, const rect_t* r,\n                          image_draw_type_t draw_type) {\n  return widget_fill_rect(widget, c, r, FALSE, draw_type);\n}\n\nstatic ret_t widget_draw_border(widget_t* widget, canvas_t* c) {\n  rect_t r;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  r = rect_init(0, 0, widget->w, widget->h);\n  return widget_stroke_border_rect(widget, c, &r);\n}\n\nret_t widget_paint_helper(widget_t* widget, canvas_t* c, const char* icon, wstr_t* text) {\n  if (style_is_valid(widget->astyle)) {\n    widget_draw_icon_text(widget, c, icon, text);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_paint_impl(widget_t* widget, canvas_t* c) {\n  int32_t ox = widget->x;\n  int32_t oy = widget->y;\n  uint8_t save_alpha = c->global_alpha;\n\n  if (widget->opacity < TK_OPACITY_ALPHA) {\n    canvas_set_global_alpha(c, (widget->opacity * save_alpha) / 0xff);\n  }\n\n  if (widget->astyle != NULL) {\n    ox += style_get_int(widget->astyle, STYLE_ID_X_OFFSET, 0);\n    oy += style_get_int(widget->astyle, STYLE_ID_Y_OFFSET, 0);\n  }\n\n  canvas_translate(c, ox, oy);\n  widget_on_paint_begin(widget, c);\n  widget_on_paint_background(widget, c);\n  widget_on_paint_self(widget, c);\n  widget_on_paint_children(widget, c);\n  widget_on_paint_border(widget, c);\n  widget_on_paint_end(widget, c);\n\n  canvas_untranslate(c, ox, oy);\n  if (widget->opacity < TK_OPACITY_ALPHA) {\n    canvas_set_global_alpha(c, save_alpha);\n  }\n\n  widget_on_paint_done(widget, c);\n\n  return RET_OK;\n}\n\nret_t widget_paint(widget_t* widget, canvas_t* c) {\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  if (!widget->visible || widget->opacity <= 0x08 || widget->w <= 0 || widget->h <= 0) {\n    widget->dirty = FALSE;\n    return RET_OK;\n  }\n\n  if (widget->need_update_style) {\n    widget_update_style(widget);\n  }\n\n  canvas_save(c);\n  widget_paint_impl(widget, c);\n  canvas_restore(c);\n\n  widget->dirty = FALSE;\n\n  return RET_OK;\n}\n\nstatic const widget_cmd_t s_widget_cmds[] = {\n    {WIDGET_EXEC_START_ANIMATOR, widget_start_animator},\n    {WIDGET_EXEC_STOP_ANIMATOR, widget_stop_animator},\n    {WIDGET_EXEC_PAUSE_ANIMATOR, widget_pause_animator},\n    {WIDGET_EXEC_DESTROY_ANIMATOR, widget_destroy_animator}};\n\nstatic ret_t widget_do_exec(widget_t* widget, const char* cmd, const char* args) {\n  uint32_t i = 0;\n\n  for (i = 0; i < ARRAY_SIZE(s_widget_cmds); i++) {\n    const widget_cmd_t* iter = s_widget_cmds + i;\n    if (tk_str_eq(cmd, iter->name)) {\n      return iter->exec(widget, args);\n    }\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t widget_exec(widget_t* widget, const char* str) {\n  if (str != NULL) {\n    char cmd[TK_NAME_LEN + 1] = {0};\n    const char* args = strchr(str, ':');\n\n    if (args != NULL) {\n      return_value_if_fail((args - str) < TK_NAME_LEN, RET_BAD_PARAMS);\n      tk_strncpy(cmd, str, args - str);\n      args += 1;\n    } else {\n      return_value_if_fail(strlen(str) < TK_NAME_LEN, RET_BAD_PARAMS);\n      tk_strcpy(cmd, str);\n    }\n\n    return widget_do_exec(widget, cmd, args);\n  } else {\n    return RET_NOT_FOUND;\n  }\n}\n\nstatic widget_t* widget_get_top_widget_grab_key(widget_t* widget) {\n  return_value_if_fail(widget != NULL, NULL);\n  WIDGET_FOR_EACH_CHILD_BEGIN_R(widget, iter, i)\n  value_t v;\n  widget_t* widget_grab_key = widget_get_top_widget_grab_key(iter);\n  if (widget_grab_key == NULL && iter != NULL && iter->visible && iter->custom_props != NULL) {\n    ret_t ret = tk_object_get_prop(iter->custom_props, WIDGET_PROP_GRAB_KEYS, &v);\n    if (ret == RET_OK && value_bool(&v)) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nstatic ret_t widget_on_ungrab_keys(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  window_manager_t* wm = WINDOW_MANAGER(widget_get_window_manager(widget));\n\n  wm->widget_grab_key = widget_get_top_widget_grab_key(WIDGET(wm));\n\n  return RET_REMOVE;\n}\n\nstatic ret_t widget_exec_code(void* ctx, event_t* evt) {\n#ifndef WITHOUT_FSCRIPT\n  value_t v;\n  value_t result;\n  ret_t ret = RET_OK;\n  tk_object_t* obj = NULL;\n  widget_t* widget = WIDGET(evt->target);\n  const char* code = (const char*)ctx;\n  if (widget_get_prop(widget, STR_PROP_MODEL, &v) == RET_OK) {\n    obj = value_object(&v);\n  }\n  if (obj != NULL) {\n    TK_OBJECT_REF(obj);\n  } else {\n    obj = object_default_create();\n  }\n  return_value_if_fail(obj != NULL && code != NULL, RET_REMOVE);\n\n  tk_object_set_prop_pointer(obj, STR_PROP_SELF, widget);\n\n  switch (evt->type) {\n    case EVT_CLICK:\n    case EVT_POINTER_DOWN:\n    case EVT_POINTER_MOVE:\n    case EVT_POINTER_UP: {\n      pointer_event_t* e = pointer_event_cast(evt);\n      tk_object_set_prop_int(obj, \"x\", e->x);\n      tk_object_set_prop_int(obj, \"y\", e->y);\n      tk_object_set_prop_bool(obj, \"alt\", e->alt);\n      tk_object_set_prop_bool(obj, \"cmd\", e->cmd);\n      tk_object_set_prop_bool(obj, \"menu\", e->menu);\n      tk_object_set_prop_bool(obj, \"ctrl\", e->ctrl);\n      break;\n    }\n    case EVT_KEY_DOWN:\n    case EVT_KEY_LONG_PRESS:\n    case EVT_KEY_UP: {\n      key_event_t* e = key_event_cast(evt);\n      const key_type_value_t* kv = keys_type_find_by_value(e->key);\n      if (kv != NULL) {\n        tk_object_set_prop_str(obj, \"key\", kv->name);\n      } else {\n        tk_object_set_prop_str(obj, \"key\", \"unkown\");\n      }\n      tk_object_set_prop_bool(obj, \"alt\", e->alt);\n      tk_object_set_prop_bool(obj, \"cmd\", e->cmd);\n      tk_object_set_prop_bool(obj, \"menu\", e->menu);\n      tk_object_set_prop_bool(obj, \"ctrl\", e->ctrl);\n      break;\n    }\n    default:\n      break;\n  }\n\n  value_set_int(&result, 0);\n  fscript_eval(obj, code, &result);\n  if (tk_object_get_prop_bool(obj, \"RET_STOP\", FALSE)) {\n    ret = RET_STOP;\n  }\n  if (tk_object_get_prop_bool(obj, \"RET_REMOVE\", FALSE)) {\n    ret = RET_REMOVE;\n  }\n  value_reset(&result);\n  TK_OBJECT_UNREF(obj);\n\n  return ret;\n#else\n  return RET_OK;\n#endif\n}\n\nstatic ret_t widget_free_code(void* ctx, event_t* evt) {\n  widget_t* widget = WIDGET(evt->target);\n  widget_off_by_ctx(widget, ctx);\n  TKMEM_FREE(ctx);\n\n  return RET_REMOVE;\n}\n\n#define STR_ANIMATE_PREFIX \"animate:\"\n#define TK_ANIMATING_TIME 500 /* 单位：毫秒（ms） */\nret_t widget_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  ret_t ret = RET_OK;\n  prop_change_event_t e;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_EXEC)) {\n    ret = widget_exec(widget, value_str(v));\n    if (ret != RET_NOT_FOUND) {\n      return ret;\n    }\n  }\n\n  e.value = v;\n  e.name = name;\n  e.e = event_init(EVT_PROP_WILL_CHANGE, widget);\n  widget_dispatch(widget, (event_t*)&e);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    widget_set_x(widget, (xy_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    widget_set_y(widget, (xy_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    widget_set_w(widget, (wh_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    widget_set_h(widget, (wh_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    widget->opacity = (uint8_t)value_int(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    widget_set_visible(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    widget->sensitive = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    widget->floating = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    widget->focusable = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    widget->with_focus_state = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    widget->dirty_rect_tolerance = value_int(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    const char* name = value_str(v);\n    return widget_use_style(widget, name);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    widget_set_enable(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    widget->feedback = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    widget_set_auto_adjust_size(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    widget_set_name(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_TR_TEXT)) {\n    widget_set_tr_text(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    widget_set_animation(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    widget_set_self_layout(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_LAYOUT) || tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    widget_set_children_layout(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_POINTER_CURSOR)) {\n    widget_set_pointer_cursor(widget, value_str(v));\n  } else {\n    ret = RET_NOT_FOUND;\n  }\n\n  if (widget->vt->set_prop) {\n    if (tk_str_start_with(name, STR_ANIMATE_PREFIX)) {\n      return widget_animate_prop_float_to(widget, name + strlen(STR_ANIMATE_PREFIX),\n                                          value_float32(v), TK_ANIMATING_TIME);\n    } else {\n      ret_t ret1 = widget->vt->set_prop(widget, name, v);\n      if (ret == RET_NOT_FOUND) {\n        ret = ret1;\n      }\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_FOCUSED) || tk_str_eq(name, WIDGET_PROP_FOCUS)) {\n      widget_set_focused(widget, value_bool(v));\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n      wstr_from_value(&(widget->text), v);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_EXEC)) {\n      ret = RET_NOT_FOUND;\n    } else if (tk_str_start_with(name, \"style:\") || tk_str_start_with(name, \"style.\")) {\n      return widget_set_style(widget, name + 6, v);\n    } else {\n      if (widget->custom_props == NULL) {\n        widget->custom_props = object_default_create();\n      }\n\n      if (tk_str_eq(name, WIDGET_PROP_GRAB_KEYS)) {\n        window_manager_t* wm = WINDOW_MANAGER(widget_get_window_manager(widget));\n\n        if (value_bool(v)) {\n          widget_on(widget, EVT_DESTROY, widget_on_ungrab_keys, widget);\n          wm->widget_grab_key = widget;\n        }\n      }\n\n      if (strncmp(name, STR_ON_EVENT_PREFIX, sizeof(STR_ON_EVENT_PREFIX) - 1) == 0) {\n        int32_t etype = event_from_name(name + sizeof(STR_ON_EVENT_PREFIX) - 1);\n        if (etype != EVT_NONE) {\n          char* code = tk_strdup(value_str(v));\n          if (code != NULL) {\n            name += sizeof(STR_ON_EVENT_PREFIX) - 1;\n            if (strncmp(name, STR_GLOBAL_EVENT_PREFIX, sizeof(STR_GLOBAL_EVENT_PREFIX) - 1) == 0) {\n              widget_t* wm = window_manager();\n              widget_on(wm, etype, widget_exec_code, code);\n              widget_on(wm, EVT_DESTROY, widget_free_code, code);\n            } else {\n              widget_on(widget, etype, widget_exec_code, code);\n              widget_on(widget, EVT_DESTROY, widget_free_code, code);\n            }\n            ret = RET_OK;\n          }\n        } else {\n          log_debug(\"not found event %s\\n\", name);\n        }\n      } else {\n        ret = tk_object_set_prop(widget->custom_props, name, v);\n      }\n    }\n  }\n\n  if (ret != RET_NOT_FOUND) {\n    e.e.type = EVT_PROP_CHANGED;\n    widget_dispatch(widget, (event_t*)&e);\n    widget_invalidate(widget, NULL);\n  }\n\n  return ret;\n}\n\nret_t widget_get_prop(widget_t* widget, const char* name, value_t* v) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    value_set_int32(v, widget->x);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    value_set_int32(v, widget->y);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    value_set_int32(v, widget->w);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    value_set_int32(v, widget->h);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    value_set_int32(v, widget->opacity);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    value_set_bool(v, widget->visible);\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    value_set_bool(v, widget->sensitive);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    value_set_bool(v, widget->floating);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    value_set_bool(v, widget_is_focusable(widget));\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSED)) {\n    value_set_bool(v, widget->focused);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    value_set_bool(v, widget->with_focus_state);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    value_set_int(v, widget->dirty_rect_tolerance);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    value_set_str(v, widget->style);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    value_set_bool(v, widget->enable);\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    value_set_bool(v, widget->feedback);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    value_set_bool(v, widget->auto_adjust_size);\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    value_set_str(v, widget->name);\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    value_set_str(v, widget->animation);\n  } else if (tk_str_eq(name, WIDGET_PROP_POINTER_CURSOR)) {\n    value_set_str(v, widget->pointer_cursor);\n  } else if (tk_str_eq(name, WIDGET_PROP_LOADING)) {\n    value_set_bool(v, widget->loading);\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    if (widget->self_layout != NULL) {\n      value_set_str(v, self_layouter_to_string(widget->self_layout));\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  } else if (tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    if (widget->children_layout != NULL) {\n      value_set_str(v, children_layouter_to_string(widget->children_layout));\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  } else {\n    if (widget->vt->get_prop) {\n      ret = widget->vt->get_prop(widget, name, v);\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  }\n\n  /*default*/\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_LAYOUT_W)) {\n      value_set_int32(v, widget->w);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_LAYOUT_H)) {\n      value_set_int32(v, widget->h);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n      wchar_t* text = widget->text.str;\n      if (text != NULL) {\n        text[widget->text.size] = 0;\n      }\n      value_set_wstr(v, text);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_STATE_FOR_STYLE)) {\n      value_set_str(v, widget_get_state_for_style(widget, FALSE, FALSE));\n      ret = RET_OK;\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (widget->custom_props != NULL) {\n      ret = tk_object_get_prop(widget->custom_props, name, v);\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_TYPE)) {\n      value_set_str(v, widget->vt->type);\n      ret = RET_OK;\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_set_prop_str(widget_t* widget, const char* name, const char* str) {\n  value_t v;\n  value_set_str(&v, str);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nconst char* widget_get_prop_str(widget_t* widget, const char* name, const char* defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_str(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_pointer(widget_t* widget, const char* name, void* pointer) {\n  value_t v;\n  value_set_pointer(&v, pointer);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nvoid* widget_get_prop_pointer(widget_t* widget, const char* name) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_pointer(&v);\n  } else {\n    return NULL;\n  }\n}\n\nret_t widget_set_prop_float(widget_t* widget, const char* name, float_t num) {\n  value_t v;\n  value_set_float32(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nfloat_t widget_get_prop_float(widget_t* widget, const char* name, float_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_float32(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_int(widget_t* widget, const char* name, int32_t num) {\n  value_t v;\n  value_set_int(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nint32_t widget_get_prop_int(widget_t* widget, const char* name, int32_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_int(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_bool(widget_t* widget, const char* name, bool_t num) {\n  value_t v;\n  value_set_bool(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nbool_t widget_get_prop_bool(widget_t* widget, const char* name, bool_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_bool(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_on_paint_background(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_background) {\n    ret = widget->vt->on_paint_background(widget, c);\n  } else {\n    if (style_is_valid(widget->astyle)) {\n      widget_draw_background(widget, c);\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_self(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_self) {\n    ret = widget->vt->on_paint_self(widget, c);\n  } else {\n    paint_event_t e;\n    widget_dispatch(widget, paint_event_init(&e, EVT_PAINT, widget, c));\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_children(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_children) {\n    ret = widget->vt->on_paint_children(widget, c);\n  } else {\n    ret = widget_on_paint_children_default(widget, c);\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_border(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_border) {\n    ret = widget->vt->on_paint_border(widget, c);\n  } else {\n    if (style_is_valid(widget->astyle)) {\n      ret = widget_draw_border(widget, c);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_begin(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_begin) {\n    ret = widget->vt->on_paint_begin(widget, c);\n  }\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_BEFORE_PAINT, widget, c));\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_done(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_PAINT_DONE, widget, c));\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_end(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_end) {\n    ret = widget->vt->on_paint_end(widget, c);\n  }\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_AFTER_PAINT, widget, c));\n\n  return ret;\n}\n\nret_t widget_dispatch_to_target(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  e->target = widget;\n  widget_dispatch(widget, e);\n\n  if (widget->target) {\n    ret = widget_dispatch_to_target(widget->target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_map_key(widget_t* widget, key_event_t* e) {\n  value_t v;\n  const key_type_value_t* kv = NULL;\n\n  if (widget->custom_props != NULL) {\n    kv = keys_type_find_by_value(e->key);\n    if (kv != NULL) {\n      const char* to = NULL;\n      char from[TK_NAME_LEN + 1] = {0};\n      char fixed_name[TK_NAME_LEN + 1];\n\n      tk_snprintf(from, sizeof(from), \"map_key:%s\", kv->name);\n      if (tk_object_get_prop(widget->custom_props, from, &v) == RET_OK) {\n        to = value_str(&v);\n      } else if (strlen(kv->name) > 1) {\n        tk_strcpy(fixed_name, kv->name);\n        tk_str_tolower(fixed_name);\n        tk_snprintf(from, sizeof(from), \"map_key:%s\", fixed_name);\n        if (tk_object_get_prop(widget->custom_props, from, &v) == RET_OK) {\n          to = value_str(&v);\n        }\n      }\n\n      if (to != NULL) {\n        kv = keys_type_find(to);\n        if (kv != NULL) {\n          e->key = kv->value;\n          log_debug(\"map key %s to %s\\n\", from, to);\n        }\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_dispatch_to_key_target(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  e->target = widget;\n  widget_dispatch(widget, e);\n\n  if (widget->key_target) {\n    ret = widget_dispatch_to_target(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_before_children(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    key_event_t before = *e;\n    before.e.type = EVT_KEY_DOWN_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_keydown_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_keydown(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_after_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_keydown) {\n    ret = widget->vt->on_keydown(widget, e);\n  }\n\n  return ret;\n}\n\nbool_t widget_is_activate_key(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL && e != NULL, FALSE);\n\n  return (widget->vt->space_key_to_activate && e->key == TK_KEY_SPACE) ||\n         (widget->vt->return_key_to_activate && key_code_is_enter(e->key));\n}\n\nstatic bool_t shortcut_fast_match(const char* shortcut, key_event_t* e) {\n  uint32_t key = e->key;\n  const char* kname = strrchr(shortcut, '+');\n  bool_t cmd = strstr(shortcut, \"cmd\") != NULL;\n  bool_t ctrl = strstr(shortcut, \"ctrl\") != NULL;\n  bool_t shift = strstr(shortcut, \"shift\") != NULL;\n  const key_type_value_t* kv = keys_type_find_by_value(key);\n\n  if (kv != NULL) {\n    if (kname == NULL) {\n      kname = shortcut;\n    } else {\n      kname++;\n    }\n\n    if (tk_str_ieq(kname, kv->name) && cmd == e->cmd && ctrl == e->ctrl && shift == e->shift) {\n      return TRUE;\n    }\n  }\n\n  return FALSE;\n}\n\nstatic bool_t widget_match_key(widget_t* widget, const char* prop, key_event_t* e) {\n  const char* shortcut = NULL;\n  widget_t* win = widget_get_window(widget);\n\n  if (widget_is_window_manager(widget)) {\n    return FALSE;\n  }\n\n  return_value_if_fail(win != NULL, FALSE);\n  shortcut = widget_get_prop_str(win, prop, NULL);\n\n  if (shortcut != NULL) {\n    return shortcut_fast_match(shortcut, e);\n  }\n\n  return FALSE;\n}\n\nstatic bool_t widget_is_move_focus_prev_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_PREV_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_next_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_NEXT_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_up_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_UP_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_down_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_DOWN_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_left_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_LEFT_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_right_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_RIGHT_KEY, e);\n}\n\nbool_t widget_is_change_focus_key(widget_t* widget, key_event_t* e) {\n  return widget_is_move_focus_prev_key(widget, e) || widget_is_move_focus_next_key(widget, e) ||\n         widget_is_move_focus_up_key(widget, e) || widget_is_move_focus_down_key(widget, e) ||\n         widget_is_move_focus_left_key(widget, e) || widget_is_move_focus_right_key(widget, e);\n}\n\nstatic ret_t widget_on_keydown_general(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  if (!widget_is_window_manager(widget)) {\n    if (widget_is_activate_key(widget, e)) {\n      ret = RET_STOP;\n      widget_set_state(widget, WIDGET_STATE_PRESSED);\n    } else if (widget_is_move_focus_next_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_next(widget);\n      } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n        ret = RET_STOP;\n        widget_focus_first(widget);\n      }\n    } else if (widget_is_move_focus_prev_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_prev(widget);\n      } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n        ret = RET_STOP;\n        widget_focus_first(widget);\n      }\n    } else if (widget_is_move_focus_up_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_up(widget);\n      }\n    } else if (widget_is_move_focus_down_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_down(widget);\n      }\n    } else if (widget_is_move_focus_left_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_left(widget);\n      }\n    } else if (widget_is_move_focus_right_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_right(widget);\n      }\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_impl(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_keydown_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keydown_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keydown_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_keydown(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  uint32_t key = e->key;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  widget_map_key(widget, e);\n  if (e->e.type == EVT_KEY_DOWN) {\n    ret = widget_on_keydown_impl(widget, e);\n    if (widget->feedback) {\n      ui_feedback_request(widget, (event_t*)e);\n    }\n\n    e->key = key;\n    if (ret != RET_STOP) {\n      ret = widget_on_keydown_general(widget, e);\n    }\n  } else if (e->e.type == EVT_KEY_LONG_PRESS) {\n    return_value_if_equal(widget_on_keydown_children(widget, e), RET_STOP);\n    ret = widget_on_keydown_after_children(widget, e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_before_children(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    key_event_t before = *e;\n    before.e.type = EVT_KEY_UP_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_keyup_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_keyup(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_after_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_keyup) {\n    ret = widget->vt->on_keyup(widget, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_impl(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_keyup_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keyup_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keyup_after_children(widget, e), RET_STOP);\n\n  if (widget_is_activate_key(widget, e)) {\n    pointer_event_t click;\n    if (widget_is_focusable(widget)) {\n      widget_set_state(widget, WIDGET_STATE_FOCUSED);\n    } else {\n      widget_set_state(widget, WIDGET_STATE_NORMAL);\n    }\n    widget_dispatch_async(widget, pointer_event_init(&click, EVT_CLICK, widget, 0, 0));\n\n    ret = RET_STOP;\n  } else if (widget_is_move_focus_next_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_prev_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_up_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_down_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_left_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_right_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_on_keyup(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  uint32_t key = e->key;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  widget_map_key(widget, e);\n  ret = widget_on_keyup_impl(widget, e);\n  if (widget->feedback) {\n    ui_feedback_request(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  e->key = key;\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_before_children(widget_t* widget, wheel_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    wheel_event_t before = *e;\n    before.e.type = EVT_WHEEL_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_wheel_children(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_wheel(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_after_children(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_wheel) {\n    ret = widget->vt->on_wheel(widget, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_impl(widget_t* widget, wheel_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_wheel_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_wheel_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_wheel_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_wheel(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_wheel_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}\n\nret_t widget_on_multi_gesture(widget_t* widget, multi_gesture_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\n    ret = widget_dispatch(target, (event_t*)e);\n  }\n\n  if (ret != RET_STOP) {\n    ret = widget_dispatch(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_dispatch_leave_event(widget_t* widget, pointer_event_t* e) {\n  widget_t* target = widget;\n\n  while (target != NULL) {\n    widget_t* curr = target;\n    pointer_event_t leave = *e;\n    leave.e.type = EVT_POINTER_LEAVE;\n\n    widget_dispatch(target, (event_t*)(&leave));\n    target = curr->target;\n    curr->target = NULL;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_dispatch_blur_event(widget_t* widget) {\n  widget_t* target = widget;\n  widget_t* temp;\n\n  while (target != NULL) {\n    widget_ref(target);\n    if (target->focused) {\n      target->focused = FALSE;\n      event_t e = event_init(EVT_BLUR, target);\n      widget_dispatch(target, &e);\n      widget_set_need_update_style(target);\n    }\n\n    if (target->parent && target->parent->key_target == target) {\n      target->parent->key_target = NULL;\n    }\n\n    temp = target->key_target;\n    widget_unref(target);\n    target = temp;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_dispatch_event_to_target_recursive(widget_t* widget, event_t* e) {\n  widget_t* target = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  target = widget->grab_widget ? widget->grab_widget : widget->target;\n  while (target != NULL) {\n    widget_dispatch(target, e);\n    target = target->target != NULL ? target->target : target->key_target;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_on_pointer_down_before_children(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    pointer_event_t before = *e;\n    before.e.type = EVT_POINTER_DOWN_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nret_t widget_on_pointer_down_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n\n  if (target != NULL && target->enable && target->sensitive) {\n    if (!(widget_is_keyboard(target))) {\n      if (widget_is_focusable(target) || !widget_is_strongly_focus(widget)) {\n        if (!target->focused) {\n          widget_set_focused_internal(target, TRUE);\n        } else {\n          widget->key_target = target;\n        }\n      }\n    }\n  } else if (widget->key_target && !widget_is_strongly_focus(widget)) {\n    widget_set_focused_internal(widget->key_target, FALSE);\n  }\n  return_value_if_equal(ret, RET_STOP);\n\n  if (widget->target != target) {\n    if (widget->target != NULL) {\n      widget_dispatch_leave_event(widget->target, e);\n    }\n    widget->target = target;\n  }\n\n  if (widget->target != NULL) {\n    ret = widget_on_pointer_down(widget->target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_down_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_pointer_down) {\n    return_value_if_equal(ret = widget->vt->on_pointer_down(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_down_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  widget->grab_widget = NULL;\n  widget->grab_widget_count = 0;\n  return_value_if_equal(widget_on_pointer_down_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_pointer_down_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_pointer_down_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_pointer_down(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_pointer_down_impl(widget, e);\n  if (widget->feedback) {\n    ui_feedback_request(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_move_before_children(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    pointer_event_t before = *e;\n    before.e.type = EVT_POINTER_MOVE_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nret_t widget_on_pointer_move_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n\n  if (target != widget->target) {\n    if (widget->target != NULL) {\n      widget_dispatch_leave_event(widget->target, e);\n    }\n\n    if (target != NULL) {\n      pointer_event_t enter = *e;\n      enter.e.type = EVT_POINTER_ENTER;\n      ret = widget_dispatch(target, (event_t*)(&enter));\n      widget_update_pointer_cursor(target);\n    } else {\n      widget_update_pointer_cursor(widget);\n    }\n\n    widget->target = target;\n  }\n  return_value_if_equal(ret, RET_STOP);\n\n  if (widget->target != NULL) {\n    ret = widget_on_pointer_move(widget->target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_move_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_pointer_move) {\n    return_value_if_equal(ret = widget->vt->on_pointer_move(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_move_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_pointer_move_before_children(widget, e), RET_STOP);\n  if (widget_on_pointer_move_children(widget, e) == RET_STOP) {\n    if (e->pressed) {\n      pointer_event_t abort;\n      pointer_event_init(&abort, EVT_POINTER_DOWN_ABORT, widget, e->x, e->y);\n      return_value_if_equal(widget_on_pointer_move_after_children(widget, &abort), RET_STOP);\n    }\n\n    return RET_STOP;\n  } else {\n    return widget_on_pointer_move_after_children(widget, e);\n  }\n}\n\nret_t widget_on_pointer_move(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_pointer_move_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_up_before_children(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    pointer_event_t before = *e;\n    before.e.type = EVT_POINTER_UP_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nret_t widget_on_pointer_up_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\n    ret = widget_on_pointer_up(target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_up_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_pointer_up) {\n    return_value_if_equal(ret = widget->vt->on_pointer_up(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_up_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_pointer_up_before_children(widget, e), RET_STOP);\n  if (widget_on_pointer_up_children(widget, e) == RET_STOP) {\n    if (e->pressed) {\n      pointer_event_t abort;\n      pointer_event_init(&abort, EVT_POINTER_DOWN_ABORT, widget, e->x, e->y);\n      return_value_if_equal(widget_on_pointer_up_after_children(widget, &abort), RET_STOP);\n    }\n\n    return RET_STOP;\n  } else {\n    return widget_on_pointer_up_after_children(widget, e);\n  }\n}\n\nret_t widget_on_pointer_up(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_pointer_up_impl(widget, e);\n  if (widget->feedback) {\n    ui_feedback_request(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_context_menu_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\n    ret = widget_on_context_menu(target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_context_menu_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_context_menu) {\n    return_value_if_equal(ret = widget->vt->on_context_menu(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_context_menu_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget_on_context_menu_children(widget, e) == RET_STOP) {\n    return RET_STOP;\n  } else {\n    return widget_on_context_menu_after_children(widget, e);\n  }\n}\n\nret_t widget_on_context_menu(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_context_menu_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}\n\nret_t widget_grab(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->grab_widget == NULL || widget->grab_widget == child, RET_BAD_PARAMS);\n\n  if (widget->grab_widget == NULL) {\n    widget->grab_widget = child;\n    widget->grab_widget_count = 1;\n  } else {\n    widget->grab_widget_count++;\n  }\n\n  if (widget->parent) {\n    widget_grab(widget->parent, widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_ungrab(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->grab_widget == child) {\n    if (widget->grab_widget->grab_widget_count < widget->grab_widget_count) {\n      widget->grab_widget_count--;\n      if (widget->grab_widget_count <= 0) {\n        widget->grab_widget = NULL;\n        widget->grab_widget_count = 0;\n      }\n\n      if (widget->parent) {\n        widget_ungrab(widget->parent, widget);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_foreach(widget_t* widget, tk_visit_t visit, void* ctx) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && visit != NULL, RET_BAD_PARAMS);\n\n  ret = visit(ctx, widget);\n  if (ret != RET_OK) {\n    return ret;\n  }\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  ret = widget_foreach(iter, visit, ctx);\n  if (ret == RET_STOP || ret == RET_DONE) {\n    return ret;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return RET_OK;\n}\n\nwidget_t* widget_get_window(widget_t* widget) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, NULL);\n\n  while (iter) {\n    if (widget_is_window(iter)) {\n      return iter;\n    }\n    iter = iter->parent;\n  }\n\n  return NULL;\n}\n\nstatic widget_t* widget_get_window_or_keyboard(widget_t* widget) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, NULL);\n\n  while (iter) {\n    if (widget_is_window(iter) || widget_is_keyboard(iter)) {\n      return iter;\n    }\n    iter = iter->parent;\n  }\n\n  return NULL;\n}\n\nwidget_t* widget_get_window_manager(widget_t* widget) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, NULL);\n\n  while (iter) {\n    if (widget_is_window_manager(iter)) {\n      return iter;\n    }\n    iter = iter->parent;\n  }\n\n  return window_manager();\n}\n\nuint32_t widget_add_timer(widget_t* widget, timer_func_t on_timer, uint32_t duration_ms) {\n  return_value_if_fail(widget != NULL && on_timer != NULL, TK_INVALID_ID);\n  return timer_add_with_type(on_timer, widget, duration_ms, TIMER_INFO_WIDGET_ADD);\n}\n\nret_t widget_remove_timer(widget_t* widget, uint32_t timer_id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return timer_remove(timer_id);\n}\n\nuint32_t widget_add_idle(widget_t* widget, idle_func_t on_idle) {\n  return_value_if_fail(widget != NULL && on_idle != NULL, TK_INVALID_ID);\n  return idle_add_with_type(on_idle, widget, IDLE_INFO_WIDGET_ADD);\n}\n\nret_t widget_remove_idle(widget_t* widget, uint32_t idle_id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return idle_remove(idle_id);\n}\n\nret_t widget_destroy_sync(widget_t* widget) {\n  event_t e = event_init(EVT_DESTROY, widget);\n  return_value_if_fail(widget != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n\n#ifndef WITHOUT_WIDGET_ANIMATORS\n  widget_destroy_animator(widget, NULL);\n#endif /*WITHOUT_WIDGET_ANIMATORS*/\n\n  widget->destroying = TRUE;\n  idle_remove_all_by_ctx_and_type(IDLE_INFO_WIDGET_ADD, widget);\n  timer_remove_all_by_ctx_and_type(TIMER_INFO_WIDGET_ADD, widget);\n\n  if (widget->emitter != NULL) {\n    widget_dispatch(widget, &e);\n    emitter_destroy(widget->emitter);\n    widget->emitter = NULL;\n  }\n\n  if (widget->children != NULL) {\n    widget_destroy_children(widget);\n    darray_destroy(widget->children);\n    widget->children = NULL;\n  }\n\n  if (widget->children_layout != NULL) {\n    children_layouter_destroy(widget->children_layout);\n    widget->children_layout = NULL;\n  }\n\n  if (widget->self_layout != NULL) {\n    self_layouter_destroy(widget->self_layout);\n    widget->self_layout = NULL;\n  }\n\n  widget->destroying = FALSE;\n\n  return widget_real_destroy(widget);\n}\n\nwidget_t* widget_create(widget_t* parent, const widget_vtable_t* vt, xy_t x, xy_t y, wh_t w,\n                        wh_t h) {\n  return_value_if_fail(vt != NULL, NULL);\n\n  return widget_init(widget_real_create(vt), parent, vt, x, y, w, h);\n}\n\nret_t widget_destroy(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->ref_count > 0 && widget->vt != NULL,\n                       RET_BAD_PARAMS);\n\n  if (widget->parent != NULL) {\n    widget_remove_child(widget->parent, widget);\n  }\n\n  return widget_unref_async(widget);\n}\n\nstatic ret_t widget_destroy_on_idle(const idle_info_t* info) {\n  widget_destroy(WIDGET(info->ctx));\n\n  return RET_REMOVE;\n}\n\nret_t widget_destroy_async(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->ref_count > 0 && widget->vt != NULL,\n                       RET_BAD_PARAMS);\n\n  return_value_if_fail(idle_add(widget_destroy_on_idle, widget) != TK_INVALID_ID, RET_FAIL);\n\n  return RET_OK;\n}\n\nstatic ret_t widget_set_parent_not_dirty(widget_t* widget) {\n  widget_t* iter = widget->parent;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    iter->dirty = FALSE;\n    if (iter->vt->is_window) {\n      break;\n    }\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_invalidate(widget_t* widget, const rect_t* r) {\n  rect_t rself;\n  return_value_if_fail(widget != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->dirty) {\n    return RET_OK;\n  }\n\n  if (r == NULL) {\n    rself = rect_init(0, 0, widget->w, widget->h);\n    r = &rself;\n  }\n\n  widget->dirty = TRUE;\n  widget_set_parent_not_dirty(widget);\n\n  if (widget->vt && widget->vt->invalidate) {\n    return widget->vt->invalidate(widget, r);\n  } else {\n    return widget_invalidate_default(widget, r);\n  }\n}\n\nret_t widget_invalidate_force(widget_t* widget, const rect_t* r) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->dirty = FALSE;\n  return widget_invalidate(widget, r);\n}\n\nwidget_t* widget_init(widget_t* widget, widget_t* parent, const widget_vtable_t* vt, xy_t x, xy_t y,\n                      wh_t w, wh_t h) {\n  return_value_if_fail(widget != NULL && vt != NULL, NULL);\n\n  widget->x = x;\n  widget->y = y;\n  widget->w = w;\n  widget->h = h;\n  widget->vt = vt;\n  widget->dirty = TRUE;\n  widget->ref_count = 1;\n  widget->opacity = 0xff;\n  widget->enable = TRUE;\n  widget->visible = TRUE;\n  widget->feedback = FALSE;\n  widget->auto_adjust_size = FALSE;\n  widget->sensitive = TRUE;\n  widget->emitter = NULL;\n  widget->children = NULL;\n  widget->initializing = TRUE;\n  widget->state = tk_strdup(WIDGET_STATE_NORMAL);\n  widget->target = NULL;\n  widget->key_target = NULL;\n  widget->grab_widget = NULL;\n  widget->grab_widget_count = 0;\n  widget->focused = FALSE;\n  widget->focusable = FALSE;\n  widget->with_focus_state = FALSE;\n  widget->dirty_rect_tolerance = 4;\n  widget->need_update_style = TRUE;\n\n  if (parent) {\n    widget_add_child(parent, widget);\n  }\n\n  wstr_init(&(widget->text), 0);\n  if (!widget->vt) {\n    widget->vt = widget_vtable_default();\n  }\n\n  if (widget->astyle == NULL &&\n      (widget_is_window_manager(widget) || widget_get_window(widget) != NULL)) {\n    widget->astyle = style_factory_create_style(style_factory(), widget_get_style_type(widget));\n    ENSURE(widget->astyle != NULL);\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  }\n\n  widget_invalidate_force(widget, NULL);\n\n  widget->initializing = FALSE;\n\n  return widget;\n}\n\nret_t widget_get_prop_default_value(widget_t* widget, const char* name, value_t* v) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    value_set_int32(v, 0xff);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    value_set_int(v, 4);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n    value_set_wstr(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSED)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    value_set_bool(v, FALSE);\n  } else {\n    if (widget->vt->get_prop_default_value) {\n      ret = widget->vt->get_prop_default_value(widget, name, v);\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_get_offset(widget_t* widget, xy_t* out_x, xy_t* out_y) {\n  return_value_if_fail(widget != NULL && out_x != NULL && out_y != NULL, RET_BAD_PARAMS);\n  *out_x = 0;\n  *out_y = 0;\n  if (widget->vt != NULL && widget->vt->get_offset != NULL) {\n    return widget->vt->get_offset(widget, out_x, out_y);\n  }\n  return RET_OK;\n}\n\nret_t widget_to_screen_ex(widget_t* widget, widget_t* parent, point_t* p) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL && p != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL && iter != parent) {\n    xy_t offset_x, offset_y;\n    if (widget_get_offset(iter, &offset_x, &offset_y) == RET_OK) {\n      p->x -= offset_x;\n      p->y -= offset_y;\n    }\n\n    p->x += iter->x;\n    p->y += iter->y;\n\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_to_screen(widget_t* widget, point_t* p) {\n  return widget_to_screen_ex(widget, NULL, p);\n}\n\nret_t widget_to_local(widget_t* widget, point_t* p) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL && p != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    xy_t offset_x = 0;\n    xy_t offset_y = 0;\n    if (widget_get_offset(iter, &offset_x, &offset_y) == RET_OK) {\n      p->x += offset_x;\n      p->y += offset_y;\n    }\n\n    p->x -= iter->x;\n    p->y -= iter->y;\n\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_to_global(widget_t* widget, point_t* p) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL && p != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    p->x += iter->x;\n    p->y += iter->y;\n\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nint32_t widget_count_children(widget_t* widget) {\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget->children != NULL ? widget->children->size : 0;\n}\n\nwidget_t* widget_get_child(widget_t* widget, int32_t index) {\n  return_value_if_fail(widget != NULL, NULL);\n  if (widget->children == NULL || index >= widget->children->size) {\n    return NULL;\n  }\n\n  return WIDGET(widget->children->elms[index]);\n}\n\nint32_t widget_index_of(widget_t* widget) {\n  widget_t* parent = NULL;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, -1);\n\n  parent = widget->parent;\n  WIDGET_FOR_EACH_CHILD_BEGIN(parent, iter, i)\n  if (iter == widget) {\n    return i;\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return -1;\n}\n\nret_t widget_prepare_text_style_ex(widget_t* widget, canvas_t* c, color_t default_trans,\n                                   const char* default_font, uint16_t default_font_size,\n                                   align_h_t default_align_h, align_v_t default_align_v) {\n  style_t* style = widget->astyle;\n  color_t tc = style_get_color(style, STYLE_ID_TEXT_COLOR, default_trans);\n  const char* font_name = style_get_str(style, STYLE_ID_FONT_NAME, default_font);\n  uint16_t font_size = style_get_int(style, STYLE_ID_FONT_SIZE, default_font_size);\n  align_h_t align_h = (align_h_t)style_get_int(style, STYLE_ID_TEXT_ALIGN_H, default_align_h);\n  align_v_t align_v = (align_v_t)style_get_int(style, STYLE_ID_TEXT_ALIGN_V, default_align_v);\n\n  canvas_set_text_color(c, tc);\n  canvas_set_font(c, font_name, font_size);\n  canvas_set_text_align(c, align_h, align_v);\n\n  return RET_OK;\n}\n\nret_t widget_prepare_text_style(widget_t* widget, canvas_t* c) {\n  color_t trans = color_init(0, 0, 0, 0);\n  return widget_prepare_text_style_ex(widget, c, trans, NULL, TK_DEFAULT_FONT_SIZE, ALIGN_H_CENTER,\n                                      ALIGN_V_MIDDLE);\n}\n\nstatic ret_t widget_copy_style(widget_t* clone, widget_t* widget) {\n  if (style_is_mutable(widget->astyle) && style_mutable_cast(widget->astyle) != NULL) {\n    if (!style_is_mutable(clone->astyle)) {\n      widget_ensure_style_mutable(clone);\n    }\n\n    if (style_mutable_cast(clone->astyle) != NULL) {\n      style_mutable_copy(clone->astyle, widget->astyle);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic const char* const s_widget_persistent_props[] = {WIDGET_PROP_NAME,\n                                                        WIDGET_PROP_STYLE,\n                                                        WIDGET_PROP_TR_TEXT,\n                                                        WIDGET_PROP_TEXT,\n                                                        WIDGET_PROP_ANIMATION,\n                                                        WIDGET_PROP_ENABLE,\n                                                        WIDGET_PROP_VISIBLE,\n                                                        WIDGET_PROP_FLOATING,\n                                                        WIDGET_PROP_CHILDREN_LAYOUT,\n                                                        WIDGET_PROP_SELF_LAYOUT,\n                                                        WIDGET_PROP_OPACITY,\n                                                        WIDGET_PROP_FOCUSED,\n                                                        WIDGET_PROP_FEEDBACK,\n                                                        WIDGET_PROP_AUTO_ADJUST_SIZE,\n                                                        WIDGET_PROP_FOCUSABLE,\n                                                        WIDGET_PROP_SENSITIVE,\n                                                        WIDGET_PROP_WITH_FOCUS_STATE,\n                                                        NULL};\n\nconst char* const* widget_get_persistent_props(void) {\n  return s_widget_persistent_props;\n}\n\nstatic ret_t widget_copy_base_props(widget_t* widget, widget_t* other) {\n  widget->state = tk_str_copy(widget->state, other->state);\n  widget->name = tk_str_copy(widget->name, other->name);\n  widget->style = tk_str_copy(widget->style, other->style);\n\n  if (other->text.str != NULL) {\n    widget_set_text(widget, other->text.str);\n  }\n\n  if (other->tr_text != NULL) {\n    widget_set_tr_text(widget, other->tr_text);\n  }\n\n  widget->enable = other->enable;\n  widget->visible = other->visible;\n  widget->floating = other->floating;\n  widget->opacity = other->opacity;\n  widget->feedback = other->feedback;\n  widget->auto_adjust_size = other->auto_adjust_size;\n  widget->focusable = other->focusable;\n  widget->sensitive = other->sensitive;\n  widget->auto_created = other->auto_created;\n  widget->with_focus_state = other->with_focus_state;\n  widget->dirty_rect_tolerance = other->dirty_rect_tolerance;\n\n  if (other->animation != NULL && *(other->animation)) {\n    widget_set_animation(widget, other->animation);\n  }\n\n  if (other->self_layout != NULL) {\n    widget->self_layout = self_layouter_clone(other->self_layout);\n  }\n\n  if (other->children_layout != NULL) {\n    widget->children_layout = children_layouter_clone(other->children_layout);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_copy(widget_t* widget, widget_t* other) {\n  return_value_if_fail(widget != NULL && other != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt == other->vt, RET_BAD_PARAMS);\n\n  widget_copy_style(widget, other);\n  widget_copy_base_props(widget, other);\n\n  if (other->custom_props) {\n    widget->custom_props = object_default_clone(OBJECT_DEFAULT(other->custom_props));\n  }\n\n  if (widget->vt->on_copy != NULL) {\n    widget->vt->on_copy(widget, other);\n  } else {\n    widget_on_copy_default(widget, other);\n  }\n\n  widget_set_need_update_style(widget);\n\n  return RET_OK;\n}\n\nwidget_t* widget_clone(widget_t* widget, widget_t* parent) {\n  widget_t* clone = NULL;\n  return_value_if_fail(widget != NULL && widget->vt != NULL && widget->vt->create != NULL, NULL);\n\n  clone = widget->vt->create(parent, widget->x, widget->y, widget->w, widget->h);\n  return_value_if_fail(clone != NULL, NULL);\n\n  widget_copy(clone, widget);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_clone(iter, clone);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return clone;\n}\n\n#define PROP_EQ(prop) (widget->prop == other->prop)\nbool_t widget_equal(widget_t* widget, widget_t* other) {\n  bool_t ret = FALSE;\n  const char* const* properties = NULL;\n  return_value_if_fail(widget != NULL && other != NULL, FALSE);\n\n  ret = PROP_EQ(opacity) && PROP_EQ(enable) && PROP_EQ(visible) && PROP_EQ(vt) && PROP_EQ(x) &&\n        PROP_EQ(y) && PROP_EQ(w) && PROP_EQ(h) && PROP_EQ(floating);\n  if (widget->name != NULL || other->name != NULL) {\n    ret = ret && (tk_str_eq(widget->name, other->name) || PROP_EQ(name));\n  }\n\n  if (widget->style != NULL || other->style != NULL) {\n    ret = ret && tk_str_eq(widget->style, other->style);\n  }\n\n  if (!ret) {\n    return ret;\n  }\n\n  ret = ret && wstr_equal(&(widget->text), &(other->text));\n\n  if (widget->tr_text != NULL || other->tr_text != NULL) {\n    ret = ret && (tk_str_eq(widget->tr_text, other->tr_text) || PROP_EQ(tr_text));\n  }\n\n  if (!ret) {\n    return ret;\n  }\n\n  properties = widget->vt->clone_properties;\n  if (properties != NULL) {\n    value_t v1;\n    value_t v2;\n    uint32_t i = 0;\n    for (i = 0; properties[i] != NULL; i++) {\n      const char* prop = properties[i];\n      if (widget_get_prop(widget, prop, &v1) != RET_OK) {\n        continue;\n      }\n\n      if (widget_get_prop(other, prop, &v2) != RET_OK) {\n        return FALSE;\n      }\n\n      if (!value_equal(&v1, &v2)) {\n        log_debug(\"prop %s not equal\\n\", prop);\n        return FALSE;\n      }\n    }\n  }\n\n  if (widget->children_layout != other->children_layout) {\n    const char* str1 = children_layouter_to_string(widget->children_layout);\nconst char* str2 = ",
    "raw_res": "",
    "prompt_res": "children_layouter_to_string(other->children_layout);",
    "gt": "children_layouter_to_string(other->children_layout);"
  },
  {
    "id": 2492,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/widget.c",
    "input": "﻿/**\n * File:   widget.c\n * Author: AWTK Develop Team\n * Brief:  basic class of all widget\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-13 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/fscript.h\"\n#include \"tkc/tokenizer.h\"\n#include \"tkc/color_parser.h\"\n#include \"tkc/object_default.h\"\n\n#include \"base/keys.h\"\n#include \"base/enums.h\"\n#include \"base/theme.h\"\n#include \"tkc/time_now.h\"\n#include \"base/idle.h\"\n#include \"base/widget.h\"\n#include \"base/layout.h\"\n#include \"native_window.h\"\n#include \"base/main_loop.h\"\n#include \"base/ui_feedback.h\"\n#include \"base/system_info.h\"\n#include \"base/window_manager.h\"\n#include \"base/widget_vtable.h\"\n#include \"base/style_mutable.h\"\n#include \"base/style_factory.h\"\n#include \"base/widget_animator_manager.h\"\n#include \"base/widget_animator_factory.h\"\n#include \"base/window_base.h\"\n#include \"blend/image_g2d.h\"\n\nret_t widget_focus_up(widget_t* widget);\nret_t widget_focus_down(widget_t* widget);\nret_t widget_focus_left(widget_t* widget);\nret_t widget_focus_right(widget_t* widget);\nstatic ret_t widget_unref_async(widget_t* widget);\nstatic ret_t widget_ensure_style_mutable(widget_t* widget);\nstatic ret_t widget_dispatch_blur_event(widget_t* widget);\n/*虚函数的包装*/\nstatic ret_t widget_on_paint_done(widget_t* widget, canvas_t* c);\nstatic ret_t widget_on_paint_begin(widget_t* widget, canvas_t* c);\nstatic ret_t widget_on_paint_end(widget_t* widget, canvas_t* c);\n\ntypedef widget_t* (*widget_find_wanted_focus_widget_t)(widget_t* widget, darray_t* all_focusable);\nstatic ret_t widget_move_focus(widget_t* widget, widget_find_wanted_focus_widget_t find);\n\n#define widget_set_xywh(widget, val, update_layout, invalidate)    \\\n  do {                                                             \\\n    if (widget->val != val) {                                      \\\n      if (invalidate) widget_invalidate_force(widget, NULL);       \\\n      widget->val = val;                                           \\\n      if (invalidate) widget_invalidate_force(widget, NULL);       \\\n    }                                                              \\\n    if (update_layout && widget->self_layout != NULL) {            \\\n      self_layouter_set_param_str(widget->self_layout, #val, \"n\"); \\\n    }                                                              \\\n  } while (0)\n\nstatic ret_t widget_set_x(widget_t* widget, xy_t x, bool_t update_layout) {\n  widget_set_xywh(widget, x, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_y(widget_t* widget, xy_t y, bool_t update_layout) {\n  widget_set_xywh(widget, y, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_w(widget_t* widget, wh_t w, bool_t update_layout) {\n  widget_set_xywh(widget, w, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_h(widget_t* widget, xy_t h, bool_t update_layout) {\n  widget_set_xywh(widget, h, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic bool_t widget_is_strongly_focus(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n  if (win != NULL) {\n    return WINDOW_BASE(win)->strongly_focus;\n  } else {\n    return FALSE;\n  }\n}\n\nret_t widget_set_need_update_style(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (!widget->need_update_style) {\n    widget_invalidate_force(widget, NULL);\n  }\n\n  widget->need_update_style = TRUE;\n\n  return RET_OK;\n}\n\nret_t widget_update_style_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_update_style(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_update_style_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_set_need_update_style_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_need_update_style(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_set_need_update_style_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_update_style(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->astyle != NULL, RET_BAD_PARAMS);\n\n  if (widget->need_update_style) {\n    widget->need_update_style = FALSE;\n    return style_notify_widget_state_changed(widget->astyle, widget);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_real_destroy(widget_t* widget) {\n  ENSURE(widget->ref_count == 1);\n\n  if (widget->vt->on_destroy) {\n    widget->vt->on_destroy(widget);\n  }\n\n  TKMEM_FREE(widget->name);\n  TKMEM_FREE(widget->state);\n  TKMEM_FREE(widget->style);\n  TKMEM_FREE(widget->tr_text);\n  TKMEM_FREE(widget->animation);\n  TKMEM_FREE(widget->pointer_cursor);\n  TK_OBJECT_UNREF(widget->custom_props);\n  wstr_reset(&(widget->text));\n  style_destroy(widget->astyle);\n\n  memset(widget, 0x00, sizeof(widget_t));\n  TKMEM_FREE(widget);\n\n  return RET_OK;\n}\n\nstatic widget_t* widget_real_create(const widget_vtable_t* vt) {\n  widget_t* widget = TKMEM_ALLOC(vt->size);\n  return_value_if_fail(widget != NULL, NULL);\n\n  memset(widget, 0x00, vt->size);\n  widget->vt = vt;\n\n  return widget;\n}\n\nstatic bool_t widget_is_scrollable(widget_t* widget) {\n  return widget != NULL && widget->vt != NULL && widget->vt->scrollable;\n}\n\nstatic bool_t widget_with_focus_state(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n  value_set_bool(&v, FALSE);\n  widget_get_prop(widget, WIDGET_PROP_WITH_FOCUS_STATE, &v);\n\n  return value_bool(&v);\n}\n\nbool_t widget_is_focusable(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  if (!widget->visible || !widget->sensitive || !widget->enable) {\n    return FALSE;\n  }\n\n  return widget->focusable || widget->vt->focusable;\n}\n\nret_t widget_move(widget_t* widget, xy_t x, xy_t y) {\n  event_t e = event_init(EVT_WILL_MOVE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->x != x || widget->y != y) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, x, TRUE, FALSE);\n    widget_set_xywh(widget, y, TRUE, FALSE);\n    widget_invalidate_force(widget, NULL);\n\n    e.type = EVT_MOVE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_to_center(widget_t* widget) {\n  int32_t x = 0;\n  int32_t y = 0;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, RET_BAD_PARAMS);\n\n  x = (widget->parent->w - widget->w) / 2;\n  y = (widget->parent->h - widget->h) / 2;\n\n  return widget_move(widget, x, y);\n}\n\nret_t widget_resize(widget_t* widget, wh_t w, wh_t h) {\n  event_t e = event_init(EVT_WILL_RESIZE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->w != w || widget->h != h) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, w, TRUE, FALSE);\n    widget_set_xywh(widget, h, TRUE, FALSE);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget);\n\n    e.type = EVT_RESIZE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_resize_ex(widget_t* widget, xy_t x, xy_t y, wh_t w, wh_t h,\n                            bool_t update_layout) {\n  event_t e = event_init(EVT_WILL_MOVE_RESIZE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->x != x || widget->y != y || widget->w != w || widget->h != h) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, x, update_layout, FALSE);\n    widget_set_xywh(widget, y, update_layout, FALSE);\n    widget_set_xywh(widget, w, update_layout, FALSE);\n    widget_set_xywh(widget, h, update_layout, FALSE);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget);\n\n    e.type = EVT_MOVE_RESIZE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_resize(widget_t* widget, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return widget_move_resize_ex(widget, x, y, w, h, TRUE);\n}\n\nfloat_t widget_get_value(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_VALUE, &v) == RET_OK ? value_float32(&v) : 0.0f;\n}\n\nret_t widget_set_value(widget_t* widget, float_t value) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_VALUE, value_set_float32(&v, value));\n}\n\nret_t widget_add_value(widget_t* widget, float_t delta) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_value(widget, widget_get_value(widget) + delta);\n}\n\nint32_t widget_get_value_int(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_VALUE, &v) == RET_OK ? value_int(&v) : 0;\n}\n\nret_t widget_set_value_int(widget_t* widget, int32_t value) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_VALUE, value_set_int(&v, value));\n}\n\nret_t widget_add_value_int(widget_t* widget, int32_t delta) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_value_int(widget, widget_get_value_int(widget) + delta);\n}\n\nstatic ret_t widget_animate_prop_float_to(widget_t* widget, const char* name, float_t value,\n                                          uint32_t duration) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL, RET_BAD_PARAMS);\n  if (duration == 0) {\n    ret = widget_set_prop_float(widget, name, value);\n  } else {\n    float_t prev_value = widget_get_prop_float(widget, name, 0.0f);\n    widget_destroy_animator(widget, name);\n\n    if (prev_value != value) {\n      char params[128] = {0};\n      tk_snprintf(params, sizeof(params) - 1, \"%s(from=%f,to=%f,duration=%d)\", name, prev_value,\n                  value, duration);\n      ret = widget_create_animator(widget, params);\n    }\n  }\n  return ret;\n}\n\nret_t widget_animate_value_to(widget_t* widget, float_t value, uint32_t duration) {\n  return widget_animate_prop_float_to(widget, WIDGET_PROP_VALUE, value, duration);\n}\n\nbool_t widget_is_window_opened(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n    return WINDOW_STAGE_OPENED == stage || WINDOW_STAGE_SUSPEND == stage;\n  } else {\n    return FALSE;\n  }\n}\n\nbool_t widget_is_window_created(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n    return WINDOW_STAGE_OPENED == stage || WINDOW_STAGE_SUSPEND == stage ||\n           WINDOW_STAGE_LOADED == stage || WINDOW_STAGE_CREATED == stage;\n  } else {\n    return FALSE;\n  }\n}\n\nret_t widget_get_window_theme(widget_t* widget, theme_t** win_theme, theme_t** default_theme) {\n  value_t v;\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    if (widget_get_prop(win, WIDGET_PROP_THEME_OBJ, &v) == RET_OK) {\n      *win_theme = (theme_t*)value_pointer(&v);\n    }\n\n    if (widget_get_prop(win, WIDGET_PROP_DEFAULT_THEME_OBJ, &v) == RET_OK) {\n      *default_theme = (theme_t*)value_pointer(&v);\n    }\n  }\n  return RET_OK;\n}\n\nbool_t widget_is_style_exist(widget_t* widget, const char* style_name, const char* state_name) {\n  const void* data = NULL;\n  const char* style = NULL;\n  const char* state = NULL;\n  theme_t* win_theme = NULL;\n  theme_t* default_theme = NULL;\n  const char* type = widget_get_type(widget);\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(widget != NULL && win != NULL, FALSE);\n\n  if (style_name == NULL || *style_name == 0) {\n    style = TK_DEFAULT_STYLE;\n  } else {\n    style = style_name;\n  }\n\n  if (state_name == NULL || *state_name == 0) {\n    state = WIDGET_STATE_NORMAL;\n  } else {\n    state = state_name;\n  }\n\n  return_value_if_fail(widget_get_window_theme(widget, &win_theme, &default_theme) == RET_OK,\n                       FALSE);\n\n  if (win_theme != NULL) {\n    data = theme_find_style(win_theme, type, style, state);\n  }\n\n  if (data == NULL && default_theme != NULL) {\n    data = theme_find_style(default_theme, type, style, state);\n  }\n\n  return data != NULL;\n}\n\nret_t widget_use_style(widget_t* widget, const char* value) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_need_update_style(widget);\n  widget->style = tk_str_copy(widget->style, value);\n\n  if (widget_is_window_opened(widget)) {\n    widget_update_style(widget);\n    return widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_text(widget_t* widget, const wchar_t* text) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_wstr(&v, text));\n}\n\nret_t widget_set_text_utf8(widget_t* widget, const char* text) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_str(&v, text));\n}\n\nret_t widget_get_text_utf8(widget_t* widget, char* text, uint32_t size) {\n  value_t v;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && text != NULL && size > 0, RET_BAD_PARAMS);\n\n  value_set_str(&v, NULL);\n  memset(text, 0x00, size);\n  if (widget_get_prop(widget, WIDGET_PROP_TEXT, &v) == RET_OK) {\n    if (v.type == VALUE_TYPE_STRING) {\n      tk_strncpy(text, value_str(&v), size - 1);\n      ret = RET_OK;\n    } else if (v.type == VALUE_TYPE_WSTRING) {\n      tk_utf8_from_utf16(value_wstr(&v), text, size);\n      ret = RET_OK;\n    }\n  }\n\n  return ret;\n}\n\nimage_manager_t* widget_get_image_manager(widget_t* widget) {\n  image_manager_t* ret = image_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = image_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_IMAGE_MANAGER, &v) == RET_OK) {\n      ret = (image_manager_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nlocale_info_t* widget_get_locale_info(widget_t* widget) {\n  locale_info_t* ret = locale_info();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = locale_info();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_LOCALE_INFO, &v) == RET_OK) {\n      ret = (locale_info_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nassets_manager_t* widget_get_assets_manager(widget_t* widget) {\n  assets_manager_t* am = assets_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, am);\n\n  if (widget->assets_manager != NULL) {\n    return widget->assets_manager;\n  }\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    am = assets_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_ASSETS_MANAGER, &v) == RET_OK) {\n      am = (assets_manager_t*)value_pointer(&v);\n    }\n  }\n  widget->assets_manager = am;\n\n  return am;\n}\n\nfont_manager_t* widget_get_font_manager(widget_t* widget) {\n  font_manager_t* ret = font_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = font_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_FONT_MANAGER, &v) == RET_OK) {\n      ret = (font_manager_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_apply_tr_text_before_paint(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  if (widget->tr_text != NULL) {\n    const char* text = locale_info_tr(widget_get_locale_info(widget), widget->tr_text);\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n  }\n\n  return RET_REMOVE;\n}\n\nret_t widget_set_tr_text(widget_t* widget, const char* text) {\n  const char* tr_text = NULL;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(widget != NULL, RET_OK);\n\n  if (text == NULL || *text == '\\0') {\n    if (widget->tr_text != NULL) {\n      TKMEM_FREE(widget->tr_text);\n      widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n    }\n\n    return RET_OK;\n  }\n\n  widget->tr_text = tk_str_copy(widget->tr_text, text);\n  if (win != NULL) {\n    tr_text = locale_info_tr(widget_get_locale_info(widget), text);\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, tr_text);\n  } else {\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n    widget_on(widget, EVT_BEFORE_PAINT, widget_apply_tr_text_before_paint, widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_re_translate_text(widget_t* widget) {\n  if (widget->vt->on_re_translate != NULL) {\n    widget->vt->on_re_translate(widget);\n  }\n  if (widget->tr_text != NULL) {\n    value_t v;\n    const char* tr_text = locale_info_tr(widget_get_locale_info(widget), widget->tr_text);\n    widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_str(&v, tr_text));\n    widget_invalidate(widget, NULL);\n  }\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_re_translate_text(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nconst wchar_t* widget_get_text(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_TEXT, &v) == RET_OK ? value_wstr(&v) : 0;\n}\n\nret_t widget_set_name(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (name != NULL) {\n    widget->name = tk_str_copy(widget->name, name);\n  } else {\n    TKMEM_FREE(widget->name);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_theme(widget_t* widget, const char* name) {\n  theme_change_event_t will_event;\n  event_t* will_evt = theme_change_event_init(&will_event, EVT_THEME_WILL_CHANGE, name);\n  widget_dispatch(window_manager(), will_evt);\n#ifdef WITH_FS_RES\n  const asset_info_t* info = NULL;\n  theme_change_event_t event;\n  event_t* evt = theme_change_event_init(&event, EVT_THEME_CHANGED, name);\n  widget_t* wm = widget_get_window_manager(widget);\n  font_manager_t* fm = widget_get_font_manager(widget);\n  image_manager_t* imm = widget_get_image_manager(widget);\n  assets_manager_t* am = widget_get_assets_manager(widget);\n  locale_info_t* locale_info = widget_get_locale_info(widget);\n  return_value_if_fail(am != NULL && name != NULL, RET_BAD_PARAMS);\n\n  font_manager_unload_all(fm);\n  image_manager_unload_all(imm);\n  locale_info_reload(locale_info);\n  assets_manager_set_theme(am, name);\n  widget_reset_canvas(widget);\n\n  info = assets_manager_ref(am, ASSET_TYPE_STYLE, \"default\");\n  if (info != NULL) {\n    theme_set(theme_load_from_data(info->name, info->data, info->size));\n    assets_manager_unref(assets_manager(), info);\n  }\n\n  widget_dispatch(wm, evt);\n  widget_invalidate_force(wm, NULL);\n\n  log_debug(\"theme changed: %s\\n\", name);\n#endif\n\n  return RET_OK;\n}\n\nret_t widget_set_pointer_cursor(widget_t* widget, const char* cursor) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (!tk_str_eq(widget->pointer_cursor, cursor)) {\n    widget->pointer_cursor = tk_str_copy(widget->pointer_cursor, cursor);\n    widget_update_pointer_cursor(widget);\n  }\n\n  return RET_OK;\n}\n\n#ifndef WITHOUT_WIDGET_ANIMATORS\nret_t widget_set_animation(widget_t* widget, const char* animation) {\n  return_value_if_fail(widget != NULL && animation != NULL, RET_BAD_PARAMS);\n\n  widget->animation = tk_str_copy(widget->animation, animation);\n\n  return widget_create_animator(widget, animation);\n}\n\nret_t widget_create_animator(widget_t* widget, const char* animation) {\n  tokenizer_t t;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && animation != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(tokenizer_init(&t, animation, strlen(animation), \";\") != NULL, RET_OOM);\n\n  while (tokenizer_has_more(&t)) {\n    const char* params = tokenizer_next(&t);\n    if (widget_animator_create(widget, params) == NULL) {\n      ret = RET_BAD_PARAMS;\n      break;\n    }\n  }\n  tokenizer_deinit(&t);\n  widget_invalidate(widget, NULL);\n\n  return ret;\n}\n\nret_t widget_start_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_start(widget_animator_manager(), widget, name);\n}\n\nret_t widget_set_animator_time_scale(widget_t* widget, const char* name, float_t time_scale) {\n  return widget_animator_manager_set_time_scale(widget_animator_manager(), widget, name,\n                                                time_scale);\n}\n\nret_t widget_pause_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_pause(widget_animator_manager(), widget, name);\n}\n\nwidget_animator_t* widget_find_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_find(widget_animator_manager(), widget, name);\n}\n\nret_t widget_stop_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_stop(widget_animator_manager(), widget, name);\n}\n\nret_t widget_destroy_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_remove_all(widget_animator_manager(), widget, name);\n}\n#else\nret_t widget_start_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nret_t widget_create_animator(widget_t* widget, const char* animation) {\n  return RET_OK;\n}\nret_t widget_set_animation(widget_t* widget, const char* animation) {\n  return RET_OK;\n}\nret_t widget_set_animator_time_scale(widget_t* widget, const char* name, float_t time_scale) {\n  return RET_OK;\n}\nret_t widget_pause_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nwidget_animator_t* widget_find_animator(widget_t* widget, const char* name) {\n  return NULL;\n}\nret_t widget_stop_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nret_t widget_destroy_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\n#endif /*WITHOUT_WIDGET_ANIMATORS*/\n\nret_t widget_set_enable(widget_t* widget, bool_t enable) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->enable != enable) {\n    widget->enable = enable;\n    widget_set_need_update_style_recursive(widget);\n    widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_feedback(widget_t* widget, bool_t feedback) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->feedback = feedback;\n\n  return RET_OK;\n}\n\nret_t widget_set_auto_adjust_size(widget_t* widget, bool_t auto_adjust_size) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->auto_adjust_size = auto_adjust_size;\n  widget_set_need_relayout(widget);\n\n  return RET_OK;\n}\n\nret_t widget_set_floating(widget_t* widget, bool_t floating) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->floating = floating;\n\n  return RET_OK;\n}\n\nret_t widget_set_focused_internal(widget_t* widget, bool_t focused) {\n  widget_t* win = widget_get_window(widget);\n  int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (WINDOW_STAGE_SUSPEND == stage) {\n    log_debug(\"You can not set focus of a widget when window is in background\");\n    return RET_FAIL;\n  }\n\n  if (widget->focused != focused) {\n    widget->focused = focused;\n    widget_set_need_update_style(widget);\n\n    if (focused) {\n      event_t e = event_init(EVT_FOCUS, widget);\n      widget_set_as_key_target(widget);\n\n      widget_dispatch(widget, &e);\n    } else {\n      event_t e = event_init(EVT_BLUR, widget);\n      widget_dispatch(widget, &e);\n      widget_dispatch_blur_event(widget);\n    }\n\n    widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_focused(widget_t* widget, bool_t focused) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_focused_internal(widget, focused);\n  if (focused) {\n    widget_ensure_visible_in_viewport(widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_focusable(widget_t* widget, bool_t focusable) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->focusable = focusable;\n\n  return RET_OK;\n}\n\nret_t widget_set_state(widget_t* widget, const char* state) {\n  return_value_if_fail(widget != NULL && state != NULL, RET_BAD_PARAMS);\n\n  if (!tk_str_eq(widget->state, state)) {\n    widget_invalidate_force(widget, NULL);\n    widget->state = tk_str_copy(widget->state, state);\n    widget_set_need_update_style(widget);\n    widget_invalidate_force(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_state_for_style(widget_t* widget, bool_t active, bool_t checked) {\n  const char* state = WIDGET_STATE_NORMAL;\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, state);\n\n  state = (const char*)(widget->state);\n\n  while (iter != NULL) {\n    if (!iter->enable) {\n      if (active) return WIDGET_STATE_DISABLE_OF_ACTIVE;\n      if (checked) return WIDGET_STATE_DISABLE_OF_CHECKED;\n      return WIDGET_STATE_DISABLE;\n    }\n    iter = iter->parent;\n  }\n\n  if (widget_is_focusable(widget) || widget_with_focus_state(widget)) {\n    if (widget->focused) {\n      if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n        state = WIDGET_STATE_FOCUSED;\n      }\n    } else {\n      if (tk_str_eq(state, WIDGET_STATE_FOCUSED)) {\n        state = WIDGET_STATE_NORMAL;\n      }\n    }\n  }\n\n  if (active) {\n    if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n      state = WIDGET_STATE_NORMAL_OF_ACTIVE;\n    } else if (tk_str_eq(state, WIDGET_STATE_PRESSED)) {\n      state = WIDGET_STATE_PRESSED_OF_ACTIVE;\n    } else if (tk_str_eq(state, WIDGET_STATE_OVER)) {\n      state = WIDGET_STATE_OVER_OF_ACTIVE;\n    } else if (widget_is_focusable(widget) && widget->focused) {\n      state = WIDGET_STATE_FOCUSED_OF_ACTIVE;\n    }\n  } else if (checked) {\n    if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n      state = WIDGET_STATE_NORMAL_OF_CHECKED;\n    } else if (tk_str_eq(state, WIDGET_STATE_PRESSED)) {\n      state = WIDGET_STATE_PRESSED_OF_CHECKED;\n    } else if (tk_str_eq(state, WIDGET_STATE_OVER)) {\n      state = WIDGET_STATE_OVER_OF_CHECKED;\n    } else if (widget_is_focusable(widget) && widget->focused) {\n      state = WIDGET_STATE_FOCUSED_OF_CHECKED;\n    }\n  }\n\n  return state;\n}\n\nret_t widget_set_opacity(widget_t* widget, uint8_t opacity) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->opacity = opacity;\n  widget_invalidate(widget, NULL);\n\n  return RET_OK;\n}\n\nret_t widget_set_dirty_rect_tolerance(widget_t* widget, uint16_t dirty_rect_tolerance) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->dirty_rect_tolerance = dirty_rect_tolerance;\n  widget_invalidate(widget, NULL);\n\n  return RET_OK;\n}\n\nret_t widget_destroy_children(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->children != NULL) {\n    WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n\n    widget_remove_child_prepare(widget, iter);\n    widget_unref(iter);\n\n    widget->children->elms[i] = NULL;\n\n    WIDGET_FOR_EACH_CHILD_END();\n    widget->children->size = 0;\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_style_type(widget_t* widget) {\n  theme_t* win_theme = NULL;\n  theme_t* default_theme = NULL;\n  const char* style_type = THEME_DEFAULT_STYLE_TYPE;\n\n  if (widget_get_window_theme(widget, &win_theme, &default_theme) == RET_OK) {\n    theme_t* t = win_theme != NULL ? win_theme : (default_theme != NULL ? default_theme : theme());\n    if (t != NULL) {\n      style_type = theme_get_style_type(t);\n    }\n  }\n\n  return style_type;\n}\n\nstatic ret_t widget_update_style_object(widget_t* widget) {\n  const char* style_type = widget_get_style_type(widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  if (widget->astyle == NULL) {\n    widget->astyle = style_factory_create_style(style_factory(), style_type);\n    ENSURE(widget->astyle != NULL);\n\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  } else if (widget->astyle != NULL &&\n             !tk_str_eq(style_get_style_type(widget->astyle), style_type)) {\n    style_t* style = style_factory_create_style(style_factory(), style_type);\n    ENSURE(style != NULL);\n    if (style_is_mutable(widget->astyle)) {\n      style_mutable_set_default_style(widget->astyle, style);\n    } else {\n      style_destroy(widget->astyle);\n      widget->astyle = style;\n    }\n\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  }\n  return RET_OK;\n}\n\nstatic ret_t widget_update_style_object_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_update_style_object(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_update_style_object_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_add_child(widget_t* widget, widget_t* child) {\n  event_t e = event_init(EVT_WIDGET_ADD_CHILD, widget);\n  return_value_if_fail(widget != NULL && child != NULL && child->parent == NULL, RET_BAD_PARAMS);\n\n  child->parent = widget;\n\n  if (widget->children == NULL) {\n    widget->children = darray_create(4, NULL, NULL);\n  }\n\n  if (widget->vt->on_add_child) {\n    if (widget->vt->on_add_child(widget, child) == RET_OK) {\n      return RET_OK;\n    }\n  }\n\n  if (child->vt->on_attach_parent) {\n    child->vt->on_attach_parent(child, widget);\n  }\n\n  ENSURE(darray_push(widget->children, child) == RET_OK);\n\n  if (!widget_is_window_manager(widget)) {\n    widget_set_need_relayout_children(widget);\n  }\n\n  if (!(child->initializing) && widget_get_window(child) != NULL) {\n    widget_set_need_update_style_recursive(child);\n    widget_update_style_object_recursive(child);\n  }\n\n  widget_dispatch(widget, &e);\n\n  return RET_OK;\n}\n\nret_t widget_remove_child_prepare(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n\n  if (!widget_is_window_manager(widget)) {\n    widget_set_need_relayout_children(widget);\n  }\n\n  widget_invalidate_force(child, NULL);\n  if (widget->target == child) {\n    widget->target = NULL;\n  }\n\n  if (widget->grab_widget == child) {\n    widget->grab_widget = NULL;\n    widget->grab_widget_count = 0;\n  }\n\n  if (widget->key_target == child) {\n    widget_dispatch_blur_event(widget->key_target);\n    widget->key_target = NULL;\n  }\n\n  if (widget->vt->on_remove_child) {\n    if (widget->vt->on_remove_child(widget, child) == RET_OK) {\n      return RET_OK;\n    }\n  }\n\n  if (child->vt->on_detach_parent) {\n    child->vt->on_detach_parent(child, widget);\n  }\n  child->parent = NULL;\n\n  return RET_OK;\n}\n\nret_t widget_remove_child(widget_t* widget, widget_t* child) {\n  ret_t ret = RET_OK;\n  event_t e = event_init(EVT_WIDGET_REMOVE_CHILD, widget);\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n\n  widget_remove_child_prepare(widget, child);\n  ret = darray_remove(widget->children, child);\n\n  if (ret == RET_OK) {\n    widget_dispatch(widget, &e);\n  }\n\n  return ret;\n}\n\nret_t widget_insert_child(widget_t* widget, uint32_t index, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget_add_child(widget, child) == RET_OK, RET_FAIL);\n\n  return widget_restack(child, index);\n}\n\nret_t widget_restack(widget_t* widget, uint32_t index) {\n  uint32_t i = 0;\n  uint32_t nr = 0;\n  int32_t old_index = 0;\n  widget_t** children = NULL;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, RET_BAD_PARAMS);\n\n  old_index = widget_index_of(widget);\n  nr = widget_count_children(widget->parent);\n  return_value_if_fail(old_index >= 0 && nr > 0, RET_BAD_PARAMS);\n\n  if (index >= nr) {\n    index = nr - 1;\n  }\n\n  if (index == old_index || nr == 1) {\n    return RET_OK;\n  }\n\n  children = (widget_t**)(widget->parent->children->elms);\n  if (index < old_index) {\n    for (i = old_index; i > index; i--) {\n      children[i] = children[i - 1];\n    }\n  } else {\n    for (i = old_index; i < index; i++) {\n      children[i] = children[i + 1];\n    }\n  }\n  children[index] = widget;\n\n  return RET_OK;\n}\n\nstatic widget_t* widget_lookup_child(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL && name != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (iter->name != NULL && tk_str_eq(iter->name, name)) {\n    return iter;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return NULL;\n}\n\nwidget_t* widget_child(widget_t* widget, const char* path) {\n  return widget_lookup_child(widget, path);\n}\n\nwidget_t* widget_get_focused_widget(widget_t* widget) {\n  widget_t* iter = NULL;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(win != NULL, NULL);\n\n  iter = win->key_target;\n  for (iter = win->key_target; iter != NULL; iter = iter->key_target) {\n    if (iter->focusable && iter->focused) {\n      return iter;\n    }\n\n    if (iter->key_target == NULL) {\n      return iter;\n    }\n  }\n\n  return NULL;\n}\n\nstatic widget_t* widget_lookup_all(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL && name != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (iter->name != NULL && tk_str_eq(iter->name, name)) {\n    return iter;\n  } else {\n    iter = widget_lookup_all(iter, name);\n    if (iter != NULL) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nwidget_t* widget_lookup(widget_t* widget, const char* name, bool_t recursive) {\n  if (recursive) {\n    return widget_lookup_all(widget, name);\n  } else {\n    return widget_lookup_child(widget, name);\n  }\n}\n\nstatic widget_t* widget_lookup_by_type_child(widget_t* widget, const char* type) {\n  return_value_if_fail(widget != NULL && type != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (tk_str_eq(iter->vt->type, type)) {\n    return iter;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return NULL;\n}\n\nstatic widget_t* widget_lookup_by_type_all(widget_t* widget, const char* type) {\n  return_value_if_fail(widget != NULL && type != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (tk_str_eq(iter->vt->type, type)) {\n    return iter;\n  } else {\n    iter = widget_lookup_by_type_all(iter, type);\n    if (iter != NULL) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nwidget_t* widget_lookup_by_type(widget_t* widget, const char* type, bool_t recursive) {\n  if (recursive) {\n    return widget_lookup_by_type_all(widget, type);\n  } else {\n    return widget_lookup_by_type_child(widget, type);\n  }\n}\n\nstatic ret_t widget_set_visible_self(widget_t* widget, bool_t visible) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->visible != visible) {\n    widget_invalidate_force(widget, NULL);\n    widget->visible = visible;\n    widget_set_need_update_style(widget);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget->parent);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_sensitive(widget_t* widget, bool_t sensitive) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->sensitive = sensitive;\n\n  return RET_OK;\n}\n\nret_t widget_set_visible_only(widget_t* widget, bool_t visible) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->visible = visible;\n\n  return RET_OK;\n}\n\nret_t widget_set_visible(widget_t* widget, bool_t visible, ...) {\n  return widget_set_visible_self(widget, visible);\n}\n\nwidget_t* widget_find_target(widget_t* widget, xy_t x, xy_t y) {\n  widget_t* ret = NULL;\n  return_value_if_fail(widget != NULL, NULL);\n\n  if (widget->vt && widget->vt->find_target) {\n    ret = widget->vt->find_target(widget, x, y);\n  } else {\n    ret = widget_find_target_default(widget, x, y);\n  }\n\n  return ret;\n}\n\nret_t widget_on_event_before_children(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt && widget->vt->on_event_before_children) {\n    ret = widget->vt->on_event_before_children(widget, e);\n  }\n\n  return ret;\n}\n\nstatic const char* widget_get_pointer_cursor(widget_t* widget) {\n  if (widget->pointer_cursor != NULL) {\n    return widget->pointer_cursor;\n  } else if (widget->vt->pointer_cursor != NULL) {\n    return widget->vt->pointer_cursor;\n  }\n\n  return WIDGET_CURSOR_DEFAULT;\n}\n\nret_t widget_update_pointer_cursor(widget_t* widget) {\n  widget_t* wm = widget_get_window_manager(widget);\n  return_value_if_fail(wm != NULL, RET_BAD_PARAMS);\n\n  return window_manager_set_cursor(wm, widget_get_pointer_cursor(widget));\n}\n\nret_t widget_dispatch(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  if (e->target == NULL) {\n    e->target = widget;\n  }\n\n  if (widget->vt && widget->vt->on_event) {\n    ret = widget->vt->on_event(widget, e);\n  } else {\n    ret = widget_on_event_default(widget, e);\n  }\n\n  if (ret != RET_STOP) {\n    if (widget->emitter != NULL) {\n      void* saved_target = e->target;\n\n      e->target = widget;\n      ret = emitter_dispatch(widget->emitter, e);\n      e->target = saved_target;\n    }\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t dispatch_in_idle(const idle_info_t* info) {\n  event_t* e = (event_t*)(info->ctx);\n  widget_t* widget = WIDGET(e->target);\n\n  widget_dispatch(widget, e);\n  widget_unref(widget);\n  event_destroy(e);\n\n  return RET_REMOVE;\n}\n\nret_t widget_dispatch_async(widget_t* widget, event_t* e) {\n  event_t* evt = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(e->target == widget, RET_BAD_PARAMS);\n\n  evt = event_clone(e);\n  return_value_if_fail(evt != NULL, RET_OOM);\n\n  widget_ref(widget);\n  idle_add(dispatch_in_idle, evt);\n\n  return RET_OK;\n}\n\nstatic ret_t widget_dispatch_callback(void* ctx, const void* data) {\n  widget_t* widget = WIDGET(data);\n\n  return widget_dispatch(widget, (event_t*)ctx);\n}\n\nret_t widget_dispatch_recursive(widget_t* widget, event_t* e) {\n  return widget_foreach(widget, widget_dispatch_callback, e);\n}\n\nuint32_t widget_on_with_tag(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx,\n                            uint32_t tag) {\n  return_value_if_fail(widget != NULL && on_event != NULL, RET_BAD_PARAMS);\n  if (widget->emitter == NULL) {\n    widget->emitter = emitter_create();\n  }\n\n  return emitter_on_with_tag(widget->emitter, type, on_event, ctx, tag);\n}\n\nuint32_t widget_on(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx) {\n  return widget_on_with_tag(widget, type, on_event, ctx, 0);\n}\n\nuint32_t widget_child_on(widget_t* widget, const char* name, uint32_t type, event_func_t on_event,\n                         void* ctx) {\n  return widget_on(widget_lookup(widget, name, TRUE), type, on_event, ctx);\n}\n\nret_t widget_off(widget_t* widget, uint32_t id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->emitter != NULL, RET_BAD_PARAMS);\n\n  return emitter_off(widget->emitter, id);\n}\n\nret_t widget_off_by_tag(widget_t* widget, uint32_t tag) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_tag(widget->emitter, tag);\n}\n\nret_t widget_off_by_ctx(widget_t* widget, void* ctx) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_ctx(widget->emitter, ctx);\n}\n\nret_t widget_off_by_func(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx) {\n  return_value_if_fail(widget != NULL && on_event != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_func(widget->emitter, type, on_event, ctx);\n}\n\nret_t widget_calc_icon_text_rect(const rect_t* ir, int32_t font_size, float_t text_size,\n                                 int32_t icon_at, uint32_t img_w, uint32_t img_h, int32_t spacer,\n                                 rect_t* r_text, rect_t* r_icon) {\n  return_value_if_fail(ir != NULL && (r_text != NULL || r_icon != NULL), RET_BAD_PARAMS);\n\n  if (r_icon == NULL) {\n    *r_text = *ir;\n\n    return RET_OK;\n  }\n\n  if (r_text == NULL) {\n    *r_icon = *ir;\n\n    return RET_OK;\n  }\n\n  return_value_if_fail(spacer < ir->h && spacer < ir->w, RET_BAD_PARAMS);\n  switch (icon_at) {\n    case ICON_AT_CENTRE: {\n      int32_t w = ir->w - spacer - text_size - img_w;\n      int32_t icon_h = ir->h - img_h;\n      *r_text = rect_init(ir->x + img_w + spacer + w / 2, ir->y, text_size, ir->h);\n      *r_icon = rect_init(ir->x + w / 2, ir->y + icon_h / 2, img_w, img_h);\n      break;\n    }\n    case ICON_AT_RIGHT: {\n      uint32_t w = img_w;\n      float_t ratio = system_info()->device_pixel_ratio;\n      if (ratio > 1) {\n        w = img_w / ratio;\n      }\n      w = tk_min(tk_max(w, ir->h), ir->w);\n      *r_icon = rect_init(ir->x + ir->w - w, ir->y, w, ir->h);\n      *r_text = rect_init(ir->x, ir->y, ir->w - ir->h - spacer, ir->h);\n      break;\n    }\n    case ICON_AT_TOP: {\n      int32_t icon_h = ir->h - font_size - spacer;\n      *r_icon = rect_init(ir->x, ir->y, ir->w, icon_h);\n      *r_text = rect_init(ir->x, icon_h + spacer, ir->w, font_size);\n      break;\n    }\n    case ICON_AT_BOTTOM: {\n      int32_t icon_h = ir->h - font_size - spacer;\n      *r_icon = rect_init(ir->x, ir->y + ir->h - icon_h, ir->w, icon_h);\n      *r_text = rect_init(ir->x, ir->y, ir->w, font_size);\n      break;\n    }\n    case ICON_AT_LEFT:\n    default: {\n      *r_icon = rect_init(ir->x, ir->y, ir->h, ir->h);\n      *r_text = rect_init(ir->x + ir->h + spacer, ir->y, ir->w - ir->h - spacer, ir->h);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_bidi(widget_t* widget) {\n  value_t v;\n  if (widget_get_prop(widget, WIDGET_PROP_BIDI, &v) == RET_OK) {\n    return value_str(&v);\n  }\n\n  return NULL;\n}\n\nret_t widget_draw_icon_text(widget_t* widget, canvas_t* c, const char* icon, wstr_t* text) {\n  rect_t ir;\n  wh_t w = 0;\n  wh_t h = 0;\n  bitmap_t img;\n  rect_t r_icon;\n  rect_t r_text;\n  int32_t margin = 0;\n  int32_t spacer = 0;\n  int32_t icon_at = 0;\n  uint16_t font_size = 0;\n  float_t text_size = 0.0f;\n  int32_t margin_left = 0;\n  int32_t margin_right = 0;\n  int32_t margin_top = 0;\n  int32_t margin_bottom = 0;\n  style_t* style = widget->astyle;\n  int32_t align_h = ALIGN_H_LEFT;\n  int32_t align_v = ALIGN_V_MIDDLE;\n  return_value_if_fail(widget->astyle != NULL, RET_BAD_PARAMS);\n\n  spacer = style_get_int(style, STYLE_ID_SPACER, 2);\n  margin = style_get_int(style, STYLE_ID_MARGIN, 0);\n  margin_top = style_get_int(style, STYLE_ID_MARGIN_TOP, margin);\n  margin_left = style_get_int(style, STYLE_ID_MARGIN_LEFT, margin);\n  margin_right = style_get_int(style, STYLE_ID_MARGIN_RIGHT, margin);\n  margin_bottom = style_get_int(style, STYLE_ID_MARGIN_BOTTOM, margin);\n  icon_at = style_get_int(style, STYLE_ID_ICON_AT, ICON_AT_AUTO);\n\n  w = widget->w - margin_left - margin_right;\n  h = widget->h - margin_top - margin_bottom;\n  ir = rect_init(margin_left, margin_top, w, h);\n\n  if (text == NULL) {\n    text = &(widget->text);\n  }\n\n  if (icon == NULL) {\n    icon = style_get_str(style, STYLE_ID_ICON, NULL);\n  }\n\n  widget_prepare_text_style(widget, c);\n\n  font_size = c->font_size;\n  text_size = text->str ? canvas_measure_text(c, text->str, text->size) : 0;\n  if (icon_at == ICON_AT_RIGHT || icon_at == ICON_AT_LEFT) {\n    align_v = style_get_int(style, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    align_h = style_get_int(style, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_LEFT);\n  } else {\n    align_v = style_get_int(style, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    align_h = style_get_int(style, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_CENTER);\n  }\n  canvas_set_text_align(c, (align_h_t)align_h, (align_v_t)align_v);\n\n  if (icon != NULL && widget_load_image(widget, icon, &img) == RET_OK) {\n    float_t dpr = system_info()->device_pixel_ratio;\n\n    if (text->size > 0) {\n      if ((h > (img.h / dpr + font_size) && icon_at == ICON_AT_AUTO)) {\n        icon_at = ICON_AT_TOP;\n      }\n\n      widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer, &r_text,\n                                 &r_icon);\n\n      canvas_draw_icon_in_rect(c, &img, &r_icon);\n      widget_draw_text_in_rect(widget, c, text->str, text->size, &r_text, FALSE);\n    } else {\n      if (icon_at == ICON_AT_AUTO) {\n        widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer, NULL,\n                                   &r_icon);\n      } else {\n        widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer,\n                                   &r_text, &r_icon);\n      }\n      canvas_draw_icon_in_rect(c, &img, &r_icon);\n    }\n  } else if (text != NULL && text->size > 0) {\n    widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, 0, 0, spacer, &r_text, NULL);\n    widget_draw_text_in_rect(widget, c, text->str, text->size, &r_text, FALSE);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_fill_rect(widget_t* widget, canvas_t* c, const rect_t* r, bool_t bg,\n                       image_draw_type_t draw_type) {\n  bitmap_t img;\n  ret_t ret = RET_OK;\n  gradient_t agradient;\n  style_t* style = widget->astyle;\n  uint32_t radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  const char* color_key = bg ? STYLE_ID_BG_COLOR : STYLE_ID_FG_COLOR;\n  const char* image_key = bg ? STYLE_ID_BG_IMAGE : STYLE_ID_FG_IMAGE;\n  rect_t bg_r = rect_init(widget->x, widget->y, widget->w, widget->h);\n  uint32_t radius_tl = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_LEFT, radius);\n  uint32_t radius_tr = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_RIGHT, radius);\n  uint32_t radius_bl = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_LEFT, radius);\n  uint32_t radius_br = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_RIGHT, radius);\n  uint32_t clear_bg = style_get_uint(style, STYLE_ID_CLEAR_BG, 0);\n  const char* draw_type_key = bg ? STYLE_ID_BG_IMAGE_DRAW_TYPE : STYLE_ID_FG_IMAGE_DRAW_TYPE;\n  gradient_t* gradient = style_get_gradient(style, color_key, &agradient);\n  const char* image_name = style_get_str(style, image_key, NULL);\n\n  if (gradient != NULL && r->w > 0 && r->h > 0) {\n    color_t color = gradient_get_first_color(gradient);\n    canvas_set_fill_color(c, color);\n    if (gradient->nr > 1 || color.rgba.a) {\n      if (radius_tl > 3 || radius_tr > 3 || radius_bl > 3 || radius_br > 3) {\n        /*TODO: support gradient*/\n        if (bg) {\n          ret = canvas_fill_rounded_rect_gradient_ex(c, r, NULL, gradient, radius_tl, radius_tr,\n                                                     radius_bl, radius_br);\n        } else {\n          ret = canvas_fill_rounded_rect_gradient_ex(c, r, &bg_r, gradient, radius_tl, radius_tr,\n                                                     radius_bl, radius_br);\n        }\n        if (ret == RET_FAIL) {\n          canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n        }\n      } else if (gradient->nr > 1) {\n        canvas_fill_rect_gradient(c, r->x, r->y, r->w, r->h, gradient);\n      } else {\n        if (clear_bg) {\n          canvas_clear_rect(c, r->x, r->y, r->w, r->h);\n        } else {\n          canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n        }\n      }\n    } else if (clear_bg) {\n      canvas_clear_rect(c, r->x, r->y, r->w, r->h);\n    }\n  }\n\n  if (image_name != NULL && *image_name && r->w > 0 && r->h > 0) {\n    char name[MAX_PATH + 1];\n    const char* region = strrchr(image_name, '#');\n    if (region != NULL) {\n      memset(name, 0x00, sizeof(name));\n      tk_strncpy(name, image_name, region - image_name);\n      image_name = name;\n    }\n\n    if (widget_load_image(widget, image_name, &img) == RET_OK) {\n      draw_type = (image_draw_type_t)style_get_int(style, draw_type_key, draw_type);\n\n      if (region == NULL) {\n        canvas_draw_image_ex(c, &img, draw_type, r);\n      } else {\n        rect_t src;\n        rect_t dst = *r;\n        if (tk_str_eq(region, \"#\")) {\n          src = rect_init(widget->x, widget->y, widget->w, widget->h);\n        } else if (tk_str_eq(region, \"#g\")) {\n          point_t p = {widget->x, widget->y};\n          widget_to_global(widget, &p);\n          src = rect_init(p.x, p.y, widget->w, widget->h);\n        } else {\n          image_region_parse(img.w, img.h, region, &src);\n        }\n\n        canvas_draw_image_ex2(c, &img, draw_type, &src, &dst);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_stroke_border_rect_for_border_type(canvas_t* c, const rect_t* r, color_t bd,\n                                                int32_t border, uint32_t border_width) {\n  wh_t w = r->w;\n  wh_t h = r->h;\n  xy_t x = r->x + 0.5;\n  xy_t y = r->y + 0.5;\n  xy_t y1 = y;\n  wh_t h1 = h;\n  bool_t draw_top = FALSE;\n  bool_t draw_bottom = FALSE;\n  canvas_set_fill_color(c, bd);\n  if (border & BORDER_TOP) {\n    draw_top = TRUE;\n    canvas_fill_rect(c, x, y, w, border_width);\n  }\n  if (border & BORDER_BOTTOM) {\n    draw_bottom = TRUE;\n    canvas_fill_rect(c, x, y + h - border_width, w, border_width);\n  }\n  /* 减少重复绘制的部分，可以修复有透明的时候重叠区域显示不正常为问题 */\n  if (draw_top) {\n    y1 += border_width;\n    h1 -= border_width;\n  }\n  if (draw_bottom) {\n    h1 -= border_width;\n  }\n  if (border & BORDER_LEFT) {\n    canvas_fill_rect(c, x, y1, border_width, h1);\n  }\n  if (border & BORDER_RIGHT) {\n    canvas_fill_rect(c, x + w - border_width, y1, border_width, h1);\n  }\n  return RET_OK;\n}\n\nret_t widget_stroke_border_rect(widget_t* widget, canvas_t* c, const rect_t* r) {\n  style_t* style = widget->astyle;\n  color_t trans = color_init(0, 0, 0, 0);\n  color_t bd = style_get_color(style, STYLE_ID_BORDER_COLOR, trans);\n  uint32_t radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  int32_t border = style_get_int(style, STYLE_ID_BORDER, BORDER_ALL);\n  uint32_t border_width = style_get_int(style, STYLE_ID_BORDER_WIDTH, 1);\n  uint32_t radius_tl = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_LEFT, radius);\n  uint32_t radius_tr = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_RIGHT, radius);\n  uint32_t radius_bl = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_LEFT, radius);\n  uint32_t radius_br = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_RIGHT, radius);\n\n  if (bd.rgba.a) {\n    canvas_set_stroke_color(c, bd);\n    if (radius_tl > 3 || radius_tr > 3 || radius_bl > 3 || radius_br > 3) {\n      if (canvas_stroke_rounded_rect_ex(c, r, NULL, &bd, radius_tl, radius_tr, radius_bl, radius_br,\n                                        border_width, border) != RET_OK) {\n        widget_stroke_border_rect_for_border_type(c, r, bd, border, border_width);\n      }\n    } else {\n      widget_stroke_border_rect_for_border_type(c, r, bd, border, border_width);\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_draw_background(widget_t* widget, canvas_t* c) {\n  rect_t r;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  r = rect_init(0, 0, widget->w, widget->h);\n\n  return widget_fill_rect(widget, c, &r, TRUE, IMAGE_DRAW_CENTER);\n}\n\nret_t widget_fill_bg_rect(widget_t* widget, canvas_t* c, const rect_t* r,\n                          image_draw_type_t draw_type) {\n  return widget_fill_rect(widget, c, r, TRUE, draw_type);\n}\n\nret_t widget_fill_fg_rect(widget_t* widget, canvas_t* c, const rect_t* r,\n                          image_draw_type_t draw_type) {\n  return widget_fill_rect(widget, c, r, FALSE, draw_type);\n}\n\nstatic ret_t widget_draw_border(widget_t* widget, canvas_t* c) {\n  rect_t r;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  r = rect_init(0, 0, widget->w, widget->h);\n  return widget_stroke_border_rect(widget, c, &r);\n}\n\nret_t widget_paint_helper(widget_t* widget, canvas_t* c, const char* icon, wstr_t* text) {\n  if (style_is_valid(widget->astyle)) {\n    widget_draw_icon_text(widget, c, icon, text);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_paint_impl(widget_t* widget, canvas_t* c) {\n  int32_t ox = widget->x;\n  int32_t oy = widget->y;\n  uint8_t save_alpha = c->global_alpha;\n\n  if (widget->opacity < TK_OPACITY_ALPHA) {\n    canvas_set_global_alpha(c, (widget->opacity * save_alpha) / 0xff);\n  }\n\n  if (widget->astyle != NULL) {\n    ox += style_get_int(widget->astyle, STYLE_ID_X_OFFSET, 0);\n    oy += style_get_int(widget->astyle, STYLE_ID_Y_OFFSET, 0);\n  }\n\n  canvas_translate(c, ox, oy);\n  widget_on_paint_begin(widget, c);\n  widget_on_paint_background(widget, c);\n  widget_on_paint_self(widget, c);\n  widget_on_paint_children(widget, c);\n  widget_on_paint_border(widget, c);\n  widget_on_paint_end(widget, c);\n\n  canvas_untranslate(c, ox, oy);\n  if (widget->opacity < TK_OPACITY_ALPHA) {\n    canvas_set_global_alpha(c, save_alpha);\n  }\n\n  widget_on_paint_done(widget, c);\n\n  return RET_OK;\n}\n\nret_t widget_paint(widget_t* widget, canvas_t* c) {\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  if (!widget->visible || widget->opacity <= 0x08 || widget->w <= 0 || widget->h <= 0) {\n    widget->dirty = FALSE;\n    return RET_OK;\n  }\n\n  if (widget->need_update_style) {\n    widget_update_style(widget);\n  }\n\n  canvas_save(c);\n  widget_paint_impl(widget, c);\n  canvas_restore(c);\n\n  widget->dirty = FALSE;\n\n  return RET_OK;\n}\n\nstatic const widget_cmd_t s_widget_cmds[] = {\n    {WIDGET_EXEC_START_ANIMATOR, widget_start_animator},\n    {WIDGET_EXEC_STOP_ANIMATOR, widget_stop_animator},\n    {WIDGET_EXEC_PAUSE_ANIMATOR, widget_pause_animator},\n    {WIDGET_EXEC_DESTROY_ANIMATOR, widget_destroy_animator}};\n\nstatic ret_t widget_do_exec(widget_t* widget, const char* cmd, const char* args) {\n  uint32_t i = 0;\n\n  for (i = 0; i < ARRAY_SIZE(s_widget_cmds); i++) {\n    const widget_cmd_t* iter = s_widget_cmds + i;\n    if (tk_str_eq(cmd, iter->name)) {\n      return iter->exec(widget, args);\n    }\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t widget_exec(widget_t* widget, const char* str) {\n  if (str != NULL) {\n    char cmd[TK_NAME_LEN + 1] = {0};\n    const char* args = strchr(str, ':');\n\n    if (args != NULL) {\n      return_value_if_fail((args - str) < TK_NAME_LEN, RET_BAD_PARAMS);\n      tk_strncpy(cmd, str, args - str);\n      args += 1;\n    } else {\n      return_value_if_fail(strlen(str) < TK_NAME_LEN, RET_BAD_PARAMS);\n      tk_strcpy(cmd, str);\n    }\n\n    return widget_do_exec(widget, cmd, args);\n  } else {\n    return RET_NOT_FOUND;\n  }\n}\n\nstatic widget_t* widget_get_top_widget_grab_key(widget_t* widget) {\n  return_value_if_fail(widget != NULL, NULL);\n  WIDGET_FOR_EACH_CHILD_BEGIN_R(widget, iter, i)\n  value_t v;\n  widget_t* widget_grab_key = widget_get_top_widget_grab_key(iter);\n  if (widget_grab_key == NULL && iter != NULL && iter->visible && iter->custom_props != NULL) {\n    ret_t ret = tk_object_get_prop(iter->custom_props, WIDGET_PROP_GRAB_KEYS, &v);\n    if (ret == RET_OK && value_bool(&v)) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nstatic ret_t widget_on_ungrab_keys(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  window_manager_t* wm = WINDOW_MANAGER(widget_get_window_manager(widget));\n\n  wm->widget_grab_key = widget_get_top_widget_grab_key(WIDGET(wm));\n\n  return RET_REMOVE;\n}\n\nstatic ret_t widget_exec_code(void* ctx, event_t* evt) {\n#ifndef WITHOUT_FSCRIPT\n  value_t v;\n  value_t result;\n  ret_t ret = RET_OK;\n  tk_object_t* obj = NULL;\n  widget_t* widget = WIDGET(evt->target);\n  const char* code = (const char*)ctx;\n  if (widget_get_prop(widget, STR_PROP_MODEL, &v) == RET_OK) {\n    obj = value_object(&v);\n  }\n  if (obj != NULL) {\n    TK_OBJECT_REF(obj);\n  } else {\n    obj = object_default_create();\n  }\n  return_value_if_fail(obj != NULL && code != NULL, RET_REMOVE);\n\n  tk_object_set_prop_pointer(obj, STR_PROP_SELF, widget);\n\n  switch (evt->type) {\n    case EVT_CLICK:\n    case EVT_POINTER_DOWN:\n    case EVT_POINTER_MOVE:\n    case EVT_POINTER_UP: {\n      pointer_event_t* e = pointer_event_cast(evt);\n      tk_object_set_prop_int(obj, \"x\", e->x);\n      tk_object_set_prop_int(obj, \"y\", e->y);\n      tk_object_set_prop_bool(obj, \"alt\", e->alt);\n      tk_object_set_prop_bool(obj, \"cmd\", e->cmd);\n      tk_object_set_prop_bool(obj, \"menu\", e->menu);\n      tk_object_set_prop_bool(obj, \"ctrl\", e->ctrl);\n      break;\n    }\n    case EVT_KEY_DOWN:\n    case EVT_KEY_LONG_PRESS:\n    case EVT_KEY_UP: {\n      key_event_t* e = key_event_cast(evt);\n      const key_type_value_t* kv = keys_type_find_by_value(e->key);\n      if (kv != NULL) {\n        tk_object_set_prop_str(obj, \"key\", kv->name);\n      } else {\n        tk_object_set_prop_str(obj, \"key\", \"unkown\");\n      }\n      tk_object_set_prop_bool(obj, \"alt\", e->alt);\n      tk_object_set_prop_bool(obj, \"cmd\", e->cmd);\n      tk_object_set_prop_bool(obj, \"menu\", e->menu);\n      tk_object_set_prop_bool(obj, \"ctrl\", e->ctrl);\n      break;\n    }\n    default:\n      break;\n  }\n\n  value_set_int(&result, 0);\n  fscript_eval(obj, code, &result);\n  if (tk_object_get_prop_bool(obj, \"RET_STOP\", FALSE)) {\n    ret = RET_STOP;\n  }\n  if (tk_object_get_prop_bool(obj, \"RET_REMOVE\", FALSE)) {\n    ret = RET_REMOVE;\n  }\n  value_reset(&result);\n  TK_OBJECT_UNREF(obj);\n\n  return ret;\n#else\n  return RET_OK;\n#endif\n}\n\nstatic ret_t widget_free_code(void* ctx, event_t* evt) {\n  widget_t* widget = WIDGET(evt->target);\n  widget_off_by_ctx(widget, ctx);\n  TKMEM_FREE(ctx);\n\n  return RET_REMOVE;\n}\n\n#define STR_ANIMATE_PREFIX \"animate:\"\n#define TK_ANIMATING_TIME 500 /* 单位：毫秒（ms） */\nret_t widget_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  ret_t ret = RET_OK;\n  prop_change_event_t e;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_EXEC)) {\n    ret = widget_exec(widget, value_str(v));\n    if (ret != RET_NOT_FOUND) {\n      return ret;\n    }\n  }\n\n  e.value = v;\n  e.name = name;\n  e.e = event_init(EVT_PROP_WILL_CHANGE, widget);\n  widget_dispatch(widget, (event_t*)&e);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    widget_set_x(widget, (xy_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    widget_set_y(widget, (xy_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    widget_set_w(widget, (wh_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    widget_set_h(widget, (wh_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    widget->opacity = (uint8_t)value_int(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    widget_set_visible(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    widget->sensitive = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    widget->floating = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    widget->focusable = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    widget->with_focus_state = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    widget->dirty_rect_tolerance = value_int(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    const char* name = value_str(v);\n    return widget_use_style(widget, name);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    widget_set_enable(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    widget->feedback = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    widget_set_auto_adjust_size(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    widget_set_name(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_TR_TEXT)) {\n    widget_set_tr_text(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    widget_set_animation(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    widget_set_self_layout(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_LAYOUT) || tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    widget_set_children_layout(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_POINTER_CURSOR)) {\n    widget_set_pointer_cursor(widget, value_str(v));\n  } else {\n    ret = RET_NOT_FOUND;\n  }\n\n  if (widget->vt->set_prop) {\n    if (tk_str_start_with(name, STR_ANIMATE_PREFIX)) {\n      return widget_animate_prop_float_to(widget, name + strlen(STR_ANIMATE_PREFIX),\n                                          value_float32(v), TK_ANIMATING_TIME);\n    } else {\n      ret_t ret1 = widget->vt->set_prop(widget, name, v);\n      if (ret == RET_NOT_FOUND) {\n        ret = ret1;\n      }\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_FOCUSED) || tk_str_eq(name, WIDGET_PROP_FOCUS)) {\n      widget_set_focused(widget, value_bool(v));\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n      wstr_from_value(&(widget->text), v);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_EXEC)) {\n      ret = RET_NOT_FOUND;\n    } else if (tk_str_start_with(name, \"style:\") || tk_str_start_with(name, \"style.\")) {\n      return widget_set_style(widget, name + 6, v);\n    } else {\n      if (widget->custom_props == NULL) {\n        widget->custom_props = object_default_create();\n      }\n\n      if (tk_str_eq(name, WIDGET_PROP_GRAB_KEYS)) {\n        window_manager_t* wm = WINDOW_MANAGER(widget_get_window_manager(widget));\n\n        if (value_bool(v)) {\n          widget_on(widget, EVT_DESTROY, widget_on_ungrab_keys, widget);\n          wm->widget_grab_key = widget;\n        }\n      }\n\n      if (strncmp(name, STR_ON_EVENT_PREFIX, sizeof(STR_ON_EVENT_PREFIX) - 1) == 0) {\n        int32_t etype = event_from_name(name + sizeof(STR_ON_EVENT_PREFIX) - 1);\n        if (etype != EVT_NONE) {\n          char* code = tk_strdup(value_str(v));\n          if (code != NULL) {\n            name += sizeof(STR_ON_EVENT_PREFIX) - 1;\n            if (strncmp(name, STR_GLOBAL_EVENT_PREFIX, sizeof(STR_GLOBAL_EVENT_PREFIX) - 1) == 0) {\n              widget_t* wm = window_manager();\n              widget_on(wm, etype, widget_exec_code, code);\n              widget_on(wm, EVT_DESTROY, widget_free_code, code);\n            } else {\n              widget_on(widget, etype, widget_exec_code, code);\n              widget_on(widget, EVT_DESTROY, widget_free_code, code);\n            }\n            ret = RET_OK;\n          }\n        } else {\n          log_debug(\"not found event %s\\n\", name);\n        }\n      } else {\n        ret = tk_object_set_prop(widget->custom_props, name, v);\n      }\n    }\n  }\n\n  if (ret != RET_NOT_FOUND) {\n    e.e.type = EVT_PROP_CHANGED;\n    widget_dispatch(widget, (event_t*)&e);\n    widget_invalidate(widget, NULL);\n  }\n\n  return ret;\n}\n\nret_t widget_get_prop(widget_t* widget, const char* name, value_t* v) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    value_set_int32(v, widget->x);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    value_set_int32(v, widget->y);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    value_set_int32(v, widget->w);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    value_set_int32(v, widget->h);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    value_set_int32(v, widget->opacity);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    value_set_bool(v, widget->visible);\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    value_set_bool(v, widget->sensitive);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    value_set_bool(v, widget->floating);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    value_set_bool(v, widget_is_focusable(widget));\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSED)) {\n    value_set_bool(v, widget->focused);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    value_set_bool(v, widget->with_focus_state);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    value_set_int(v, widget->dirty_rect_tolerance);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    value_set_str(v, widget->style);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    value_set_bool(v, widget->enable);\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    value_set_bool(v, widget->feedback);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    value_set_bool(v, widget->auto_adjust_size);\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    value_set_str(v, widget->name);\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    value_set_str(v, widget->animation);\n  } else if (tk_str_eq(name, WIDGET_PROP_POINTER_CURSOR)) {\n    value_set_str(v, widget->pointer_cursor);\n  } else if (tk_str_eq(name, WIDGET_PROP_LOADING)) {\n    value_set_bool(v, widget->loading);\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    if (widget->self_layout != NULL) {\n      value_set_str(v, self_layouter_to_string(widget->self_layout));\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  } else if (tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    if (widget->children_layout != NULL) {\n      value_set_str(v, children_layouter_to_string(widget->children_layout));\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  } else {\n    if (widget->vt->get_prop) {\n      ret = widget->vt->get_prop(widget, name, v);\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  }\n\n  /*default*/\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_LAYOUT_W)) {\n      value_set_int32(v, widget->w);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_LAYOUT_H)) {\n      value_set_int32(v, widget->h);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n      wchar_t* text = widget->text.str;\n      if (text != NULL) {\n        text[widget->text.size] = 0;\n      }\n      value_set_wstr(v, text);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_STATE_FOR_STYLE)) {\n      value_set_str(v, widget_get_state_for_style(widget, FALSE, FALSE));\n      ret = RET_OK;\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (widget->custom_props != NULL) {\n      ret = tk_object_get_prop(widget->custom_props, name, v);\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_TYPE)) {\n      value_set_str(v, widget->vt->type);\n      ret = RET_OK;\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_set_prop_str(widget_t* widget, const char* name, const char* str) {\n  value_t v;\n  value_set_str(&v, str);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nconst char* widget_get_prop_str(widget_t* widget, const char* name, const char* defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_str(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_pointer(widget_t* widget, const char* name, void* pointer) {\n  value_t v;\n  value_set_pointer(&v, pointer);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nvoid* widget_get_prop_pointer(widget_t* widget, const char* name) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_pointer(&v);\n  } else {\n    return NULL;\n  }\n}\n\nret_t widget_set_prop_float(widget_t* widget, const char* name, float_t num) {\n  value_t v;\n  value_set_float32(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nfloat_t widget_get_prop_float(widget_t* widget, const char* name, float_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_float32(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_int(widget_t* widget, const char* name, int32_t num) {\n  value_t v;\n  value_set_int(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nint32_t widget_get_prop_int(widget_t* widget, const char* name, int32_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_int(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_bool(widget_t* widget, const char* name, bool_t num) {\n  value_t v;\n  value_set_bool(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nbool_t widget_get_prop_bool(widget_t* widget, const char* name, bool_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_bool(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_on_paint_background(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_background) {\n    ret = widget->vt->on_paint_background(widget, c);\n  } else {\n    if (style_is_valid(widget->astyle)) {\n      widget_draw_background(widget, c);\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_self(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_self) {\n    ret = widget->vt->on_paint_self(widget, c);\n  } else {\n    paint_event_t e;\n    widget_dispatch(widget, paint_event_init(&e, EVT_PAINT, widget, c));\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_children(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_children) {\n    ret = widget->vt->on_paint_children(widget, c);\n  } else {\n    ret = widget_on_paint_children_default(widget, c);\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_border(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_border) {\n    ret = widget->vt->on_paint_border(widget, c);\n  } else {\n    if (style_is_valid(widget->astyle)) {\n      ret = widget_draw_border(widget, c);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_begin(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_begin) {\n    ret = widget->vt->on_paint_begin(widget, c);\n  }\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_BEFORE_PAINT, widget, c));\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_done(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_PAINT_DONE, widget, c));\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_end(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_end) {\n    ret = widget->vt->on_paint_end(widget, c);\n  }\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_AFTER_PAINT, widget, c));\n\n  return ret;\n}\n\nret_t widget_dispatch_to_target(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  e->target = widget;\n  widget_dispatch(widget, e);\n\n  if (widget->target) {\n    ret = widget_dispatch_to_target(widget->target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_map_key(widget_t* widget, key_event_t* e) {\n  value_t v;\n  const key_type_value_t* kv = NULL;\n\n  if (widget->custom_props != NULL) {\n    kv = keys_type_find_by_value(e->key);\n    if (kv != NULL) {\n      const char* to = NULL;\n      char from[TK_NAME_LEN + 1] = {0};\n      char fixed_name[TK_NAME_LEN + 1];\n\n      tk_snprintf(from, sizeof(from), \"map_key:%s\", kv->name);\n      if (tk_object_get_prop(widget->custom_props, from, &v) == RET_OK) {\n        to = value_str(&v);\n      } else if (strlen(kv->name) > 1) {\n        tk_strcpy(fixed_name, kv->name);\n        tk_str_tolower(fixed_name);\n        tk_snprintf(from, sizeof(from), \"map_key:%s\", fixed_name);\n        if (tk_object_get_prop(widget->custom_props, from, &v) == RET_OK) {\n          to = value_str(&v);\n        }\n      }\n\n      if (to != NULL) {\n        kv = keys_type_find(to);\n        if (kv != NULL) {\n          e->key = kv->value;\n          log_debug(\"map key %s to %s\\n\", from, to);\n        }\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_dispatch_to_key_target(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  e->target = widget;\n  widget_dispatch(widget, e);\n\n  if (widget->key_target) {\n    ret = widget_dispatch_to_target(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_before_children(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    key_event_t before = *e;\n    before.e.type = EVT_KEY_DOWN_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_keydown_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_keydown(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_after_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_keydown) {\n    ret = widget->vt->on_keydown(widget, e);\n  }\n\n  return ret;\n}\n\nbool_t widget_is_activate_key(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL && e != NULL, FALSE);\n\n  return (widget->vt->space_key_to_activate && e->key == TK_KEY_SPACE) ||\n         (widget->vt->return_key_to_activate && key_code_is_enter(e->key));\n}\n\nstatic bool_t shortcut_fast_match(const char* shortcut, key_event_t* e) {\n  uint32_t key = e->key;\n  const char* kname = strrchr(shortcut, '+');\n  bool_t cmd = strstr(shortcut, \"cmd\") != NULL;\n  bool_t ctrl = strstr(shortcut, \"ctrl\") != NULL;\n  bool_t shift = strstr(shortcut, \"shift\") != NULL;\n  const key_type_value_t* kv = keys_type_find_by_value(key);\n\n  if (kv != NULL) {\n    if (kname == NULL) {\n      kname = shortcut;\n    } else {\n      kname++;\n    }\n\n    if (tk_str_ieq(kname, kv->name) && cmd == e->cmd && ctrl == e->ctrl && shift == e->shift) {\n      return TRUE;\n    }\n  }\n\n  return FALSE;\n}\n\nstatic bool_t widget_match_key(widget_t* widget, const char* prop, key_event_t* e) {\n  const char* shortcut = NULL;\n  widget_t* win = widget_get_window(widget);\n\n  if (widget_is_window_manager(widget)) {\n    return FALSE;\n  }\n\n  return_value_if_fail(win != NULL, FALSE);\n  shortcut = widget_get_prop_str(win, prop, NULL);\n\n  if (shortcut != NULL) {\n    return shortcut_fast_match(shortcut, e);\n  }\n\n  return FALSE;\n}\n\nstatic bool_t widget_is_move_focus_prev_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_PREV_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_next_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_NEXT_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_up_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_UP_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_down_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_DOWN_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_left_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_LEFT_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_right_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_RIGHT_KEY, e);\n}\n\nbool_t widget_is_change_focus_key(widget_t* widget, key_event_t* e) {\n  return widget_is_move_focus_prev_key(widget, e) || widget_is_move_focus_next_key(widget, e) ||\n         widget_is_move_focus_up_key(widget, e) || widget_is_move_focus_down_key(widget, e) ||\n         widget_is_move_focus_left_key(widget, e) || widget_is_move_focus_right_key(widget, e);\n}\n\nstatic ret_t widget_on_keydown_general(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  if (!widget_is_window_manager(widget)) {\n    if (widget_is_activate_key(widget, e)) {\n      ret = RET_STOP;\n      widget_set_state(widget, WIDGET_STATE_PRESSED);\n    } else if (widget_is_move_focus_next_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_next(widget);\n      } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n        ret = RET_STOP;\n        widget_focus_first(widget);\n      }\n    } else if (widget_is_move_focus_prev_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_prev(widget);\n      } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n        ret = RET_STOP;\n        widget_focus_first(widget);\n      }\n    } else if (widget_is_move_focus_up_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_up(widget);\n      }\n    } else if (widget_is_move_focus_down_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_down(widget);\n      }\n    } else if (widget_is_move_focus_left_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_left(widget);\n      }\n    } else if (widget_is_move_focus_right_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_right(widget);\n      }\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_impl(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_keydown_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keydown_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keydown_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_keydown(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  uint32_t key = e->key;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  widget_map_key(widget, e);\n  if (e->e.type == EVT_KEY_DOWN) {\n    ret = widget_on_keydown_impl(widget, e);\n    if (widget->feedback) {\n      ui_feedback_request(widget, (event_t*)e);\n    }\n\n    e->key = key;\n    if (ret != RET_STOP) {\n      ret = widget_on_keydown_general(widget, e);\n    }\n  } else if (e->e.type == EVT_KEY_LONG_PRESS) {\n    return_value_if_equal(widget_on_keydown_children(widget, e), RET_STOP);\n    ret = widget_on_keydown_after_children(widget, e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_before_children(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    key_event_t before = *e;\n    before.e.type = EVT_KEY_UP_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_keyup_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_keyup(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_after_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_keyup) {\n    ret = widget->vt->on_keyup(widget, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_impl(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_keyup_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keyup_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keyup_after_children(widget, e), RET_STOP);\n\n  if (widget_is_activate_key(widget, e)) {\n    pointer_event_t click;\n    if (widget_is_focusable(widget)) {\n      widget_set_state(widget, WIDGET_STATE_FOCUSED);\n    } else {\n      widget_set_state(widget, WIDGET_STATE_NORMAL);\n    }\n    widget_dispatch_async(widget, pointer_event_init(&click, EVT_CLICK, widget, 0, 0));\n\n    ret = RET_STOP;\n  } else if (widget_is_move_focus_next_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_prev_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_up_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_down_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_left_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_right_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_on_keyup(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  uint32_t key = e->key;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  widget_map_key(widget, e);\n  ret = widget_on_keyup_impl(widget, e);\n  if (widget->feedback) {\n    ui_feedback_request(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  e->key = key;\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_before_children(widget_t* widget, wheel_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    wheel_event_t before = *e;\n    before.e.type = EVT_WHEEL_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_wheel_children(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_wheel(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_after_children(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_wheel) {\n    ret = widget->vt->on_wheel(widget, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_impl(widget_t* widget, wheel_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_wheel_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_wheel_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_wheel_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_wheel(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_wheel_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}\n\nret_t widget_on_multi_gesture(widget_t* widget, multi_gesture_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\n    ret = widget_dispatch(target, (event_t*)e);\n  }\n\n  if (ret != RET_STOP) {\n    ret = widget_dispatch(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_dispatch_leave_event(widget_t* widget, pointer_event_t* e) {\n  widget_t* target = widget;\n\n  while (target != NULL) {\n    widget_t* curr = target;\n    pointer_event_t leave = *e;\n    leave.e.type = EVT_POINTER_LEAVE;\n\n    widget_dispatch(target, (event_t*)(&leave));\n    target = curr->target;\n    curr->target = NULL;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_dispatch_blur_event(widget_t* widget) {\n  widget_t* target = widget;\n  widget_t* temp;\n\n  while (target != NULL) {\n    widget_ref(target);\n    if (target->focused) {\n      target->focused = FALSE;\n      event_t e = event_init(EVT_BLUR, target);\n      widget_dispatch(target, &e);\n      widget_set_need_update_style(target);\n    }\n\n    if (target->parent && target->parent->key_target == target) {\n      target->parent->key_target = NULL;\n    }\n\n    temp = target->key_target;\n    widget_unref(target);\n    target = temp;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_dispatch_event_to_target_recursive(widget_t* widget, event_t* e) {\n  widget_t* target = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  target = widget->grab_widget ? widget->grab_widget : widget->target;\n  while (target != NULL) {\n    widget_dispatch(target, e);\n    target = target->target != NULL ? target->target : target->key_target;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_on_pointer_down_before_children(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    pointer_event_t before = *e;\n    before.e.type = EVT_POINTER_DOWN_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nret_t widget_on_pointer_down_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n\n  if (target != NULL && target->enable && target->sensitive) {\n    if (!(widget_is_keyboard(target))) {\n      if (widget_is_focusable(target) || !widget_is_strongly_focus(widget)) {\n        if (!target->focused) {\n          widget_set_focused_internal(target, TRUE);\n        } else {\n          widget->key_target = target;\n        }\n      }\n    }\n  } else if (widget->key_target && !widget_is_strongly_focus(widget)) {\n    widget_set_focused_internal(widget->key_target, FALSE);\n  }\n  return_value_if_equal(ret, RET_STOP);\n\n  if (widget->target != target) {\n    if (widget->target != NULL) {\n      widget_dispatch_leave_event(widget->target, e);\n    }\n    widget->target = target;\n  }\n\n  if (widget->target != NULL) {\n    ret = widget_on_pointer_down(widget->target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_down_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_pointer_down) {\n    return_value_if_equal(ret = widget->vt->on_pointer_down(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_down_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  widget->grab_widget = NULL;\n  widget->grab_widget_count = 0;\n  return_value_if_equal(widget_on_pointer_down_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_pointer_down_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_pointer_down_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_pointer_down(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_pointer_down_impl(widget, e);\n  if (widget->feedback) {\n    ui_feedback_request(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_move_before_children(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    pointer_event_t before = *e;\n    before.e.type = EVT_POINTER_MOVE_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nret_t widget_on_pointer_move_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n\n  if (target != widget->target) {\n    if (widget->target != NULL) {\n      widget_dispatch_leave_event(widget->target, e);\n    }\n\n    if (target != NULL) {\n      pointer_event_t enter = *e;\n      enter.e.type = EVT_POINTER_ENTER;\n      ret = widget_dispatch(target, (event_t*)(&enter));\n      widget_update_pointer_cursor(target);\n    } else {\n      widget_update_pointer_cursor(widget);\n    }\n\n    widget->target = target;\n  }\n  return_value_if_equal(ret, RET_STOP);\n\n  if (widget->target != NULL) {\n    ret = widget_on_pointer_move(widget->target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_move_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_pointer_move) {\n    return_value_if_equal(ret = widget->vt->on_pointer_move(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_move_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_pointer_move_before_children(widget, e), RET_STOP);\n  if (widget_on_pointer_move_children(widget, e) == RET_STOP) {\n    if (e->pressed) {\n      pointer_event_t abort;\n      pointer_event_init(&abort, EVT_POINTER_DOWN_ABORT, widget, e->x, e->y);\n      return_value_if_equal(widget_on_pointer_move_after_children(widget, &abort), RET_STOP);\n    }\n\n    return RET_STOP;\n  } else {\n    return widget_on_pointer_move_after_children(widget, e);\n  }\n}\n\nret_t widget_on_pointer_move(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_pointer_move_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_up_before_children(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    pointer_event_t before = *e;\n    before.e.type = EVT_POINTER_UP_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nret_t widget_on_pointer_up_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\n    ret = widget_on_pointer_up(target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_up_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_pointer_up) {\n    return_value_if_equal(ret = widget->vt->on_pointer_up(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_up_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_pointer_up_before_children(widget, e), RET_STOP);\n  if (widget_on_pointer_up_children(widget, e) == RET_STOP) {\n    if (e->pressed) {\n      pointer_event_t abort;\n      pointer_event_init(&abort, EVT_POINTER_DOWN_ABORT, widget, e->x, e->y);\n      return_value_if_equal(widget_on_pointer_up_after_children(widget, &abort), RET_STOP);\n    }\n\n    return RET_STOP;\n  } else {\n    return widget_on_pointer_up_after_children(widget, e);\n  }\n}\n\nret_t widget_on_pointer_up(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_pointer_up_impl(widget, e);\n  if (widget->feedback) {\n    ui_feedback_request(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_context_menu_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\n    ret = widget_on_context_menu(target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_context_menu_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_context_menu) {\n    return_value_if_equal(ret = widget->vt->on_context_menu(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_context_menu_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget_on_context_menu_children(widget, e) == RET_STOP) {\n    return RET_STOP;\n  } else {\n    return widget_on_context_menu_after_children(widget, e);\n  }\n}\n\nret_t widget_on_context_menu(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_context_menu_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}\n\nret_t widget_grab(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->grab_widget == NULL || widget->grab_widget == child, RET_BAD_PARAMS);\n\n  if (widget->grab_widget == NULL) {\n    widget->grab_widget = child;\n    widget->grab_widget_count = 1;\n  } else {\n    widget->grab_widget_count++;\n  }\n\n  if (widget->parent) {\n    widget_grab(widget->parent, widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_ungrab(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->grab_widget == child) {\n    if (widget->grab_widget->grab_widget_count < widget->grab_widget_count) {\n      widget->grab_widget_count--;\n      if (widget->grab_widget_count <= 0) {\n        widget->grab_widget = NULL;\n        widget->grab_widget_count = 0;\n      }\n\n      if (widget->parent) {\n        widget_ungrab(widget->parent, widget);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_foreach(widget_t* widget, tk_visit_t visit, void* ctx) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && visit != NULL, RET_BAD_PARAMS);\n\n  ret = visit(ctx, widget);\n  if (ret != RET_OK) {\n    return ret;\n  }\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  ret = widget_foreach(iter, visit, ctx);\n  if (ret == RET_STOP || ret == RET_DONE) {\n    return ret;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return RET_OK;\n}\n\nwidget_t* widget_get_window(widget_t* widget) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, NULL);\n\n  while (iter) {\n    if (widget_is_window(iter)) {\n      return iter;\n    }\n    iter = iter->parent;\n  }\n\n  return NULL;\n}\n\nstatic widget_t* widget_get_window_or_keyboard(widget_t* widget) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, NULL);\n\n  while (iter) {\n    if (widget_is_window(iter) || widget_is_keyboard(iter)) {\n      return iter;\n    }\n    iter = iter->parent;\n  }\n\n  return NULL;\n}\n\nwidget_t* widget_get_window_manager(widget_t* widget) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, NULL);\n\n  while (iter) {\n    if (widget_is_window_manager(iter)) {\n      return iter;\n    }\n    iter = iter->parent;\n  }\n\n  return window_manager();\n}\n\nuint32_t widget_add_timer(widget_t* widget, timer_func_t on_timer, uint32_t duration_ms) {\n  return_value_if_fail(widget != NULL && on_timer != NULL, TK_INVALID_ID);\n  return timer_add_with_type(on_timer, widget, duration_ms, TIMER_INFO_WIDGET_ADD);\n}\n\nret_t widget_remove_timer(widget_t* widget, uint32_t timer_id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return timer_remove(timer_id);\n}\n\nuint32_t widget_add_idle(widget_t* widget, idle_func_t on_idle) {\n  return_value_if_fail(widget != NULL && on_idle != NULL, TK_INVALID_ID);\n  return idle_add_with_type(on_idle, widget, IDLE_INFO_WIDGET_ADD);\n}\n\nret_t widget_remove_idle(widget_t* widget, uint32_t idle_id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return idle_remove(idle_id);\n}\n\nret_t widget_destroy_sync(widget_t* widget) {\n  event_t e = event_init(EVT_DESTROY, widget);\n  return_value_if_fail(widget != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n\n#ifndef WITHOUT_WIDGET_ANIMATORS\n  widget_destroy_animator(widget, NULL);\n#endif /*WITHOUT_WIDGET_ANIMATORS*/\n\n  widget->destroying = TRUE;\n  idle_remove_all_by_ctx_and_type(IDLE_INFO_WIDGET_ADD, widget);\n  timer_remove_all_by_ctx_and_type(TIMER_INFO_WIDGET_ADD, widget);\n\n  if (widget->emitter != NULL) {\n    widget_dispatch(widget, &e);\n    emitter_destroy(widget->emitter);\n    widget->emitter = NULL;\n  }\n\n  if (widget->children != NULL) {\n    widget_destroy_children(widget);\n    darray_destroy(widget->children);\n    widget->children = NULL;\n  }\n\n  if (widget->children_layout != NULL) {\n    children_layouter_destroy(widget->children_layout);\n    widget->children_layout = NULL;\n  }\n\n  if (widget->self_layout != NULL) {\n    self_layouter_destroy(widget->self_layout);\n    widget->self_layout = NULL;\n  }\n\n  widget->destroying = FALSE;\n\n  return widget_real_destroy(widget);\n}\n\nwidget_t* widget_create(widget_t* parent, const widget_vtable_t* vt, xy_t x, xy_t y, wh_t w,\n                        wh_t h) {\n  return_value_if_fail(vt != NULL, NULL);\n\n  return widget_init(widget_real_create(vt), parent, vt, x, y, w, h);\n}\n\nret_t widget_destroy(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->ref_count > 0 && widget->vt != NULL,\n                       RET_BAD_PARAMS);\n\n  if (widget->parent != NULL) {\n    widget_remove_child(widget->parent, widget);\n  }\n\n  return widget_unref_async(widget);\n}\n\nstatic ret_t widget_destroy_on_idle(const idle_info_t* info) {\n  widget_destroy(WIDGET(info->ctx));\n\n  return RET_REMOVE;\n}\n\nret_t widget_destroy_async(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->ref_count > 0 && widget->vt != NULL,\n                       RET_BAD_PARAMS);\n\n  return_value_if_fail(idle_add(widget_destroy_on_idle, widget) != TK_INVALID_ID, RET_FAIL);\n\n  return RET_OK;\n}\n\nstatic ret_t widget_set_parent_not_dirty(widget_t* widget) {\n  widget_t* iter = widget->parent;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    iter->dirty = FALSE;\n    if (iter->vt->is_window) {\n      break;\n    }\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_invalidate(widget_t* widget, const rect_t* r) {\n  rect_t rself;\n  return_value_if_fail(widget != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->dirty) {\n    return RET_OK;\n  }\n\n  if (r == NULL) {\n    rself = rect_init(0, 0, widget->w, widget->h);\n    r = &rself;\n  }\n\n  widget->dirty = TRUE;\n  widget_set_parent_not_dirty(widget);\n\n  if (widget->vt && widget->vt->invalidate) {\n    return widget->vt->invalidate(widget, r);\n  } else {\n    return widget_invalidate_default(widget, r);\n  }\n}\n\nret_t widget_invalidate_force(widget_t* widget, const rect_t* r) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->dirty = FALSE;\n  return widget_invalidate(widget, r);\n}\n\nwidget_t* widget_init(widget_t* widget, widget_t* parent, const widget_vtable_t* vt, xy_t x, xy_t y,\n                      wh_t w, wh_t h) {\n  return_value_if_fail(widget != NULL && vt != NULL, NULL);\n\n  widget->x = x;\n  widget->y = y;\n  widget->w = w;\n  widget->h = h;\n  widget->vt = vt;\n  widget->dirty = TRUE;\n  widget->ref_count = 1;\n  widget->opacity = 0xff;\n  widget->enable = TRUE;\n  widget->visible = TRUE;\n  widget->feedback = FALSE;\n  widget->auto_adjust_size = FALSE;\n  widget->sensitive = TRUE;\n  widget->emitter = NULL;\n  widget->children = NULL;\n  widget->initializing = TRUE;\n  widget->state = tk_strdup(WIDGET_STATE_NORMAL);\n  widget->target = NULL;\n  widget->key_target = NULL;\n  widget->grab_widget = NULL;\n  widget->grab_widget_count = 0;\n  widget->focused = FALSE;\n  widget->focusable = FALSE;\n  widget->with_focus_state = FALSE;\n  widget->dirty_rect_tolerance = 4;\n  widget->need_update_style = TRUE;\n\n  if (parent) {\n    widget_add_child(parent, widget);\n  }\n\n  wstr_init(&(widget->text), 0);\n  if (!widget->vt) {\n    widget->vt = widget_vtable_default();\n  }\n\n  if (widget->astyle == NULL &&\n      (widget_is_window_manager(widget) || widget_get_window(widget) != NULL)) {\n    widget->astyle = style_factory_create_style(style_factory(), widget_get_style_type(widget));\n    ENSURE(widget->astyle != NULL);\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  }\n\n  widget_invalidate_force(widget, NULL);\n\n  widget->initializing = FALSE;\n\n  return widget;\n}\n\nret_t widget_get_prop_default_value(widget_t* widget, const char* name, value_t* v) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    value_set_int32(v, 0xff);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    value_set_int(v, 4);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n    value_set_wstr(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSED)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    value_set_bool(v, FALSE);\n  } else {\n    if (widget->vt->get_prop_default_value) {\n      ret = widget->vt->get_prop_default_value(widget, name, v);\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_get_offset(widget_t* widget, xy_t* out_x, xy_t* out_y) {\n  return_value_if_fail(widget != NULL && out_x != NULL && out_y != NULL, RET_BAD_PARAMS);\n  *out_x = 0;\n  *out_y = 0;\n  if (widget->vt != NULL && widget->vt->get_offset != NULL) {\n    return widget->vt->get_offset(widget, out_x, out_y);\n  }\n  return RET_OK;\n}\n\nret_t widget_to_screen_ex(widget_t* widget, widget_t* parent, point_t* p) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL && p != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL && iter != parent) {\n    xy_t offset_x, offset_y;\n    if (widget_get_offset(iter, &offset_x, &offset_y) == RET_OK) {\n      p->x -= offset_x;\n      p->y -= offset_y;\n    }\n\n    p->x += iter->x;\n    p->y += iter->y;\n\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_to_screen(widget_t* widget, point_t* p) {\n  return widget_to_screen_ex(widget, NULL, p);\n}\n\nret_t widget_to_local(widget_t* widget, point_t* p) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL && p != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    xy_t offset_x = 0;\n    xy_t offset_y = 0;\n    if (widget_get_offset(iter, &offset_x, &offset_y) == RET_OK) {\n      p->x += offset_x;\n      p->y += offset_y;\n    }\n\n    p->x -= iter->x;\n    p->y -= iter->y;\n\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_to_global(widget_t* widget, point_t* p) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL && p != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    p->x += iter->x;\n    p->y += iter->y;\n\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nint32_t widget_count_children(widget_t* widget) {\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget->children != NULL ? widget->children->size : 0;\n}\n\nwidget_t* widget_get_child(widget_t* widget, int32_t index) {\n  return_value_if_fail(widget != NULL, NULL);\n  if (widget->children == NULL || index >= widget->children->size) {\n    return NULL;\n  }\n\n  return WIDGET(widget->children->elms[index]);\n}\n\nint32_t widget_index_of(widget_t* widget) {\n  widget_t* parent = NULL;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, -1);\n\n  parent = widget->parent;\n  WIDGET_FOR_EACH_CHILD_BEGIN(parent, iter, i)\n  if (iter == widget) {\n    return i;\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return -1;\n}\n\nret_t widget_prepare_text_style_ex(widget_t* widget, canvas_t* c, color_t default_trans,\n                                   const char* default_font, uint16_t default_font_size,\n                                   align_h_t default_align_h, align_v_t default_align_v) {\n  style_t* style = widget->astyle;\n  color_t tc = style_get_color(style, STYLE_ID_TEXT_COLOR, default_trans);\n  const char* font_name = style_get_str(style, STYLE_ID_FONT_NAME, default_font);\n  uint16_t font_size = style_get_int(style, STYLE_ID_FONT_SIZE, default_font_size);\n  align_h_t align_h = (align_h_t)style_get_int(style, STYLE_ID_TEXT_ALIGN_H, default_align_h);\n  align_v_t align_v = (align_v_t)style_get_int(style, STYLE_ID_TEXT_ALIGN_V, default_align_v);\n\n  canvas_set_text_color(c, tc);\n  canvas_set_font(c, font_name, font_size);\n  canvas_set_text_align(c, align_h, align_v);\n\n  return RET_OK;\n}\n\nret_t widget_prepare_text_style(widget_t* widget, canvas_t* c) {\n  color_t trans = color_init(0, 0, 0, 0);\n  return widget_prepare_text_style_ex(widget, c, trans, NULL, TK_DEFAULT_FONT_SIZE, ALIGN_H_CENTER,\n                                      ALIGN_V_MIDDLE);\n}\n\nstatic ret_t widget_copy_style(widget_t* clone, widget_t* widget) {\n  if (style_is_mutable(widget->astyle) && style_mutable_cast(widget->astyle) != NULL) {\n    if (!style_is_mutable(clone->astyle)) {\n      widget_ensure_style_mutable(clone);\n    }\n\n    if (style_mutable_cast(clone->astyle) != NULL) {\n      style_mutable_copy(clone->astyle, widget->astyle);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic const char* const s_widget_persistent_props[] = {WIDGET_PROP_NAME,\n                                                        WIDGET_PROP_STYLE,\n                                                        WIDGET_PROP_TR_TEXT,\n                                                        WIDGET_PROP_TEXT,\n                                                        WIDGET_PROP_ANIMATION,\n                                                        WIDGET_PROP_ENABLE,\n                                                        WIDGET_PROP_VISIBLE,\n                                                        WIDGET_PROP_FLOATING,\n                                                        WIDGET_PROP_CHILDREN_LAYOUT,\n                                                        WIDGET_PROP_SELF_LAYOUT,\n                                                        WIDGET_PROP_OPACITY,\n                                                        WIDGET_PROP_FOCUSED,\n                                                        WIDGET_PROP_FEEDBACK,\n                                                        WIDGET_PROP_AUTO_ADJUST_SIZE,\n                                                        WIDGET_PROP_FOCUSABLE,\n                                                        WIDGET_PROP_SENSITIVE,\n                                                        WIDGET_PROP_WITH_FOCUS_STATE,\n                                                        NULL};\n\nconst char* const* widget_get_persistent_props(void) {\n  return s_widget_persistent_props;\n}\n\nstatic ret_t widget_copy_base_props(widget_t* widget, widget_t* other) {\n  widget->state = tk_str_copy(widget->state, other->state);\n  widget->name = tk_str_copy(widget->name, other->name);\n  widget->style = tk_str_copy(widget->style, other->style);\n\n  if (other->text.str != NULL) {\n    widget_set_text(widget, other->text.str);\n  }\n\n  if (other->tr_text != NULL) {\n    widget_set_tr_text(widget, other->tr_text);\n  }\n\n  widget->enable = other->enable;\n  widget->visible = other->visible;\n  widget->floating = other->floating;\n  widget->opacity = other->opacity;\n  widget->feedback = other->feedback;\n  widget->auto_adjust_size = other->auto_adjust_size;\n  widget->focusable = other->focusable;\n  widget->sensitive = other->sensitive;\n  widget->auto_created = other->auto_created;\n  widget->with_focus_state = other->with_focus_state;\n  widget->dirty_rect_tolerance = other->dirty_rect_tolerance;\n\n  if (other->animation != NULL && *(other->animation)) {\n    widget_set_animation(widget, other->animation);\n  }\n\n  if (other->self_layout != NULL) {\n    widget->self_layout = self_layouter_clone(other->self_layout);\n  }\n\n  if (other->children_layout != NULL) {\n    widget->children_layout = children_layouter_clone(other->children_layout);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_copy(widget_t* widget, widget_t* other) {\n  return_value_if_fail(widget != NULL && other != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt == other->vt, RET_BAD_PARAMS);\n\n  widget_copy_style(widget, other);\n  widget_copy_base_props(widget, other);\n\n  if (other->custom_props) {\n    widget->custom_props = object_default_clone(OBJECT_DEFAULT(other->custom_props));\n  }\n\n  if (widget->vt->on_copy != NULL) {\n    widget->vt->on_copy(widget, other);\n  } else {\n    widget_on_copy_default(widget, other);\n  }\n\n  widget_set_need_update_style(widget);\n\n  return RET_OK;\n}\n\nwidget_t* widget_clone(widget_t* widget, widget_t* parent) {\n  widget_t* clone = NULL;\n  return_value_if_fail(widget != NULL && widget->vt != NULL && widget->vt->create != NULL, NULL);\n\n  clone = widget->vt->create(parent, widget->x, widget->y, widget->w, widget->h);\n  return_value_if_fail(clone != NULL, NULL);\n\n  widget_copy(clone, widget);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_clone(iter, clone);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return clone;\n}\n\n#define PROP_EQ(prop) (widget->prop == other->prop)\nbool_t widget_equal(widget_t* widget, widget_t* other) {\n  bool_t ret = FALSE;\n  const char* const* properties = NULL;\n  return_value_if_fail(widget != NULL && other != NULL, FALSE);\n\n  ret = PROP_EQ(opacity) && PROP_EQ(enable) && PROP_EQ(visible) && PROP_EQ(vt) && PROP_EQ(x) &&\n        PROP_EQ(y) && PROP_EQ(w) && PROP_EQ(h) && PROP_EQ(floating);\n  if (widget->name != NULL || other->name != NULL) {\n    ret = ret && (tk_str_eq(widget->name, other->name) || PROP_EQ(name));\n  }\n\n  if (widget->style != NULL || other->style != NULL) {\n    ret = ret && tk_str_eq(widget->style, other->style);\n  }\n\n  if (!ret) {\n    return ret;\n  }\n\n  ret = ret && wstr_equal(&(widget->text), &(other->text));\n\n  if (widget->tr_text != NULL || other->tr_text != NULL) {\n    ret = ret && (tk_str_eq(widget->tr_text, other->tr_text) || PROP_EQ(tr_text));\n  }\n\n  if (!ret) {\n    return ret;\n  }\n\n  properties = widget->vt->clone_properties;\n  if (properties != NULL) {\n    value_t v1;\n    value_t v2;\n    uint32_t i = 0;\n    for (i = 0; properties[i] != NULL; i++) {\n      const char* prop = properties[i];\n      if (widget_get_prop(widget, prop, &v1) != RET_OK) {\n        continue;\n      }\n\n      if (widget_get_prop(other, prop, &v2) != RET_OK) {\n        return FALSE;\n      }\n\n      if (!value_equal(&v1, &v2)) {\n        log_debug(\"prop %s not equal\\n\", prop);\n        return FALSE;\n      }\n    }\n  }\n\n  if (widget->children_layout != other->children_layout) {\n    const char* str1 = children_layouter_to_string(widget->children_layout);\n    const char* str2 = children_layouter_to_string(other->children_layout);\n    if (!tk_str_eq(str1, str2)) {\n      return FALSE;\n    }\n  }\n\n  if (widget->self_layout != other->self_layout) {\nconst char* str1 = ",
    "raw_res": "",
    "prompt_res": "self_layouter_to_string(widget->self_layout);",
    "gt": "self_layouter_to_string(widget->self_layout);"
  },
  {
    "id": 2501,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/widget.c",
    "input": "﻿/**\n * File:   widget.c\n * Author: AWTK Develop Team\n * Brief:  basic class of all widget\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-13 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/fscript.h\"\n#include \"tkc/tokenizer.h\"\n#include \"tkc/color_parser.h\"\n#include \"tkc/object_default.h\"\n\n#include \"base/keys.h\"\n#include \"base/enums.h\"\n#include \"base/theme.h\"\n#include \"tkc/time_now.h\"\n#include \"base/idle.h\"\n#include \"base/widget.h\"\n#include \"base/layout.h\"\n#include \"native_window.h\"\n#include \"base/main_loop.h\"\n#include \"base/ui_feedback.h\"\n#include \"base/system_info.h\"\n#include \"base/window_manager.h\"\n#include \"base/widget_vtable.h\"\n#include \"base/style_mutable.h\"\n#include \"base/style_factory.h\"\n#include \"base/widget_animator_manager.h\"\n#include \"base/widget_animator_factory.h\"\n#include \"base/window_base.h\"\n#include \"blend/image_g2d.h\"\n\nret_t widget_focus_up(widget_t* widget);\nret_t widget_focus_down(widget_t* widget);\nret_t widget_focus_left(widget_t* widget);\nret_t widget_focus_right(widget_t* widget);\nstatic ret_t widget_unref_async(widget_t* widget);\nstatic ret_t widget_ensure_style_mutable(widget_t* widget);\nstatic ret_t widget_dispatch_blur_event(widget_t* widget);\n/*虚函数的包装*/\nstatic ret_t widget_on_paint_done(widget_t* widget, canvas_t* c);\nstatic ret_t widget_on_paint_begin(widget_t* widget, canvas_t* c);\nstatic ret_t widget_on_paint_end(widget_t* widget, canvas_t* c);\n\ntypedef widget_t* (*widget_find_wanted_focus_widget_t)(widget_t* widget, darray_t* all_focusable);\nstatic ret_t widget_move_focus(widget_t* widget, widget_find_wanted_focus_widget_t find);\n\n#define widget_set_xywh(widget, val, update_layout, invalidate)    \\\n  do {                                                             \\\n    if (widget->val != val) {                                      \\\n      if (invalidate) widget_invalidate_force(widget, NULL);       \\\n      widget->val = val;                                           \\\n      if (invalidate) widget_invalidate_force(widget, NULL);       \\\n    }                                                              \\\n    if (update_layout && widget->self_layout != NULL) {            \\\n      self_layouter_set_param_str(widget->self_layout, #val, \"n\"); \\\n    }                                                              \\\n  } while (0)\n\nstatic ret_t widget_set_x(widget_t* widget, xy_t x, bool_t update_layout) {\n  widget_set_xywh(widget, x, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_y(widget_t* widget, xy_t y, bool_t update_layout) {\n  widget_set_xywh(widget, y, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_w(widget_t* widget, wh_t w, bool_t update_layout) {\n  widget_set_xywh(widget, w, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_h(widget_t* widget, xy_t h, bool_t update_layout) {\n  widget_set_xywh(widget, h, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic bool_t widget_is_strongly_focus(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n  if (win != NULL) {\n    return WINDOW_BASE(win)->strongly_focus;\n  } else {\n    return FALSE;\n  }\n}\n\nret_t widget_set_need_update_style(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (!widget->need_update_style) {\n    widget_invalidate_force(widget, NULL);\n  }\n\n  widget->need_update_style = TRUE;\n\n  return RET_OK;\n}\n\nret_t widget_update_style_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_update_style(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_update_style_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_set_need_update_style_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_need_update_style(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_set_need_update_style_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_update_style(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->astyle != NULL, RET_BAD_PARAMS);\n\n  if (widget->need_update_style) {\n    widget->need_update_style = FALSE;\n    return style_notify_widget_state_changed(widget->astyle, widget);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_real_destroy(widget_t* widget) {\n  ENSURE(widget->ref_count == 1);\n\n  if (widget->vt->on_destroy) {\n    widget->vt->on_destroy(widget);\n  }\n\n  TKMEM_FREE(widget->name);\n  TKMEM_FREE(widget->state);\n  TKMEM_FREE(widget->style);\n  TKMEM_FREE(widget->tr_text);\n  TKMEM_FREE(widget->animation);\n  TKMEM_FREE(widget->pointer_cursor);\n  TK_OBJECT_UNREF(widget->custom_props);\n  wstr_reset(&(widget->text));\n  style_destroy(widget->astyle);\n\n  memset(widget, 0x00, sizeof(widget_t));\n  TKMEM_FREE(widget);\n\n  return RET_OK;\n}\n\nstatic widget_t* widget_real_create(const widget_vtable_t* vt) {\n  widget_t* widget = TKMEM_ALLOC(vt->size);\n  return_value_if_fail(widget != NULL, NULL);\n\n  memset(widget, 0x00, vt->size);\n  widget->vt = vt;\n\n  return widget;\n}\n\nstatic bool_t widget_is_scrollable(widget_t* widget) {\n  return widget != NULL && widget->vt != NULL && widget->vt->scrollable;\n}\n\nstatic bool_t widget_with_focus_state(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n  value_set_bool(&v, FALSE);\n  widget_get_prop(widget, WIDGET_PROP_WITH_FOCUS_STATE, &v);\n\n  return value_bool(&v);\n}\n\nbool_t widget_is_focusable(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  if (!widget->visible || !widget->sensitive || !widget->enable) {\n    return FALSE;\n  }\n\n  return widget->focusable || widget->vt->focusable;\n}\n\nret_t widget_move(widget_t* widget, xy_t x, xy_t y) {\n  event_t e = event_init(EVT_WILL_MOVE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->x != x || widget->y != y) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, x, TRUE, FALSE);\n    widget_set_xywh(widget, y, TRUE, FALSE);\n    widget_invalidate_force(widget, NULL);\n\n    e.type = EVT_MOVE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_to_center(widget_t* widget) {\n  int32_t x = 0;\n  int32_t y = 0;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, RET_BAD_PARAMS);\n\n  x = (widget->parent->w - widget->w) / 2;\n  y = (widget->parent->h - widget->h) / 2;\n\n  return widget_move(widget, x, y);\n}\n\nret_t widget_resize(widget_t* widget, wh_t w, wh_t h) {\n  event_t e = event_init(EVT_WILL_RESIZE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->w != w || widget->h != h) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, w, TRUE, FALSE);\n    widget_set_xywh(widget, h, TRUE, FALSE);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget);\n\n    e.type = EVT_RESIZE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_resize_ex(widget_t* widget, xy_t x, xy_t y, wh_t w, wh_t h,\n                            bool_t update_layout) {\n  event_t e = event_init(EVT_WILL_MOVE_RESIZE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->x != x || widget->y != y || widget->w != w || widget->h != h) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, x, update_layout, FALSE);\n    widget_set_xywh(widget, y, update_layout, FALSE);\n    widget_set_xywh(widget, w, update_layout, FALSE);\n    widget_set_xywh(widget, h, update_layout, FALSE);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget);\n\n    e.type = EVT_MOVE_RESIZE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_resize(widget_t* widget, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return widget_move_resize_ex(widget, x, y, w, h, TRUE);\n}\n\nfloat_t widget_get_value(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_VALUE, &v) == RET_OK ? value_float32(&v) : 0.0f;\n}\n\nret_t widget_set_value(widget_t* widget, float_t value) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_VALUE, value_set_float32(&v, value));\n}\n\nret_t widget_add_value(widget_t* widget, float_t delta) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_value(widget, widget_get_value(widget) + delta);\n}\n\nint32_t widget_get_value_int(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_VALUE, &v) == RET_OK ? value_int(&v) : 0;\n}\n\nret_t widget_set_value_int(widget_t* widget, int32_t value) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_VALUE, value_set_int(&v, value));\n}\n\nret_t widget_add_value_int(widget_t* widget, int32_t delta) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_value_int(widget, widget_get_value_int(widget) + delta);\n}\n\nstatic ret_t widget_animate_prop_float_to(widget_t* widget, const char* name, float_t value,\n                                          uint32_t duration) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL, RET_BAD_PARAMS);\n  if (duration == 0) {\n    ret = widget_set_prop_float(widget, name, value);\n  } else {\n    float_t prev_value = widget_get_prop_float(widget, name, 0.0f);\n    widget_destroy_animator(widget, name);\n\n    if (prev_value != value) {\n      char params[128] = {0};\n      tk_snprintf(params, sizeof(params) - 1, \"%s(from=%f,to=%f,duration=%d)\", name, prev_value,\n                  value, duration);\n      ret = widget_create_animator(widget, params);\n    }\n  }\n  return ret;\n}\n\nret_t widget_animate_value_to(widget_t* widget, float_t value, uint32_t duration) {\n  return widget_animate_prop_float_to(widget, WIDGET_PROP_VALUE, value, duration);\n}\n\nbool_t widget_is_window_opened(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n    return WINDOW_STAGE_OPENED == stage || WINDOW_STAGE_SUSPEND == stage;\n  } else {\n    return FALSE;\n  }\n}\n\nbool_t widget_is_window_created(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n    return WINDOW_STAGE_OPENED == stage || WINDOW_STAGE_SUSPEND == stage ||\n           WINDOW_STAGE_LOADED == stage || WINDOW_STAGE_CREATED == stage;\n  } else {\n    return FALSE;\n  }\n}\n\nret_t widget_get_window_theme(widget_t* widget, theme_t** win_theme, theme_t** default_theme) {\n  value_t v;\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    if (widget_get_prop(win, WIDGET_PROP_THEME_OBJ, &v) == RET_OK) {\n      *win_theme = (theme_t*)value_pointer(&v);\n    }\n\n    if (widget_get_prop(win, WIDGET_PROP_DEFAULT_THEME_OBJ, &v) == RET_OK) {\n      *default_theme = (theme_t*)value_pointer(&v);\n    }\n  }\n  return RET_OK;\n}\n\nbool_t widget_is_style_exist(widget_t* widget, const char* style_name, const char* state_name) {\n  const void* data = NULL;\n  const char* style = NULL;\n  const char* state = NULL;\n  theme_t* win_theme = NULL;\n  theme_t* default_theme = NULL;\n  const char* type = widget_get_type(widget);\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(widget != NULL && win != NULL, FALSE);\n\n  if (style_name == NULL || *style_name == 0) {\n    style = TK_DEFAULT_STYLE;\n  } else {\n    style = style_name;\n  }\n\n  if (state_name == NULL || *state_name == 0) {\n    state = WIDGET_STATE_NORMAL;\n  } else {\n    state = state_name;\n  }\n\n  return_value_if_fail(widget_get_window_theme(widget, &win_theme, &default_theme) == RET_OK,\n                       FALSE);\n\n  if (win_theme != NULL) {\n    data = theme_find_style(win_theme, type, style, state);\n  }\n\n  if (data == NULL && default_theme != NULL) {\n    data = theme_find_style(default_theme, type, style, state);\n  }\n\n  return data != NULL;\n}\n\nret_t widget_use_style(widget_t* widget, const char* value) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_need_update_style(widget);\n  widget->style = tk_str_copy(widget->style, value);\n\n  if (widget_is_window_opened(widget)) {\n    widget_update_style(widget);\n    return widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_text(widget_t* widget, const wchar_t* text) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_wstr(&v, text));\n}\n\nret_t widget_set_text_utf8(widget_t* widget, const char* text) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_str(&v, text));\n}\n\nret_t widget_get_text_utf8(widget_t* widget, char* text, uint32_t size) {\n  value_t v;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && text != NULL && size > 0, RET_BAD_PARAMS);\n\n  value_set_str(&v, NULL);\n  memset(text, 0x00, size);\n  if (widget_get_prop(widget, WIDGET_PROP_TEXT, &v) == RET_OK) {\n    if (v.type == VALUE_TYPE_STRING) {\n      tk_strncpy(text, value_str(&v), size - 1);\n      ret = RET_OK;\n    } else if (v.type == VALUE_TYPE_WSTRING) {\n      tk_utf8_from_utf16(value_wstr(&v), text, size);\n      ret = RET_OK;\n    }\n  }\n\n  return ret;\n}\n\nimage_manager_t* widget_get_image_manager(widget_t* widget) {\n  image_manager_t* ret = image_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = image_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_IMAGE_MANAGER, &v) == RET_OK) {\n      ret = (image_manager_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nlocale_info_t* widget_get_locale_info(widget_t* widget) {\n  locale_info_t* ret = locale_info();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = locale_info();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_LOCALE_INFO, &v) == RET_OK) {\n      ret = (locale_info_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nassets_manager_t* widget_get_assets_manager(widget_t* widget) {\n  assets_manager_t* am = assets_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, am);\n\n  if (widget->assets_manager != NULL) {\n    return widget->assets_manager;\n  }\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    am = assets_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_ASSETS_MANAGER, &v) == RET_OK) {\n      am = (assets_manager_t*)value_pointer(&v);\n    }\n  }\n  widget->assets_manager = am;\n\n  return am;\n}\n\nfont_manager_t* widget_get_font_manager(widget_t* widget) {\n  font_manager_t* ret = font_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = font_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_FONT_MANAGER, &v) == RET_OK) {\n      ret = (font_manager_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_apply_tr_text_before_paint(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  if (widget->tr_text != NULL) {\n    const char* text = locale_info_tr(widget_get_locale_info(widget), widget->tr_text);\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n  }\n\n  return RET_REMOVE;\n}\n\nret_t widget_set_tr_text(widget_t* widget, const char* text) {\n  const char* tr_text = NULL;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(widget != NULL, RET_OK);\n\n  if (text == NULL || *text == '\\0') {\n    if (widget->tr_text != NULL) {\n      TKMEM_FREE(widget->tr_text);\n      widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n    }\n\n    return RET_OK;\n  }\n\n  widget->tr_text = tk_str_copy(widget->tr_text, text);\n  if (win != NULL) {\n    tr_text = locale_info_tr(widget_get_locale_info(widget), text);\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, tr_text);\n  } else {\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n    widget_on(widget, EVT_BEFORE_PAINT, widget_apply_tr_text_before_paint, widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_re_translate_text(widget_t* widget) {\n  if (widget->vt->on_re_translate != NULL) {\n    widget->vt->on_re_translate(widget);\n  }\n  if (widget->tr_text != NULL) {\n    value_t v;\n    const char* tr_text = locale_info_tr(widget_get_locale_info(widget), widget->tr_text);\n    widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_str(&v, tr_text));\n    widget_invalidate(widget, NULL);\n  }\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_re_translate_text(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nconst wchar_t* widget_get_text(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_TEXT, &v) == RET_OK ? value_wstr(&v) : 0;\n}\n\nret_t widget_set_name(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (name != NULL) {\n    widget->name = tk_str_copy(widget->name, name);\n  } else {\n    TKMEM_FREE(widget->name);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_theme(widget_t* widget, const char* name) {\n  theme_change_event_t will_event;\n  event_t* will_evt = theme_change_event_init(&will_event, EVT_THEME_WILL_CHANGE, name);\n  widget_dispatch(window_manager(), will_evt);\n#ifdef WITH_FS_RES\n  const asset_info_t* info = NULL;\n  theme_change_event_t event;\n  event_t* evt = theme_change_event_init(&event, EVT_THEME_CHANGED, name);\n  widget_t* wm = widget_get_window_manager(widget);\n  font_manager_t* fm = widget_get_font_manager(widget);\n  image_manager_t* imm = widget_get_image_manager(widget);\n  assets_manager_t* am = widget_get_assets_manager(widget);\n  locale_info_t* locale_info = widget_get_locale_info(widget);\n  return_value_if_fail(am != NULL && name != NULL, RET_BAD_PARAMS);\n\n  font_manager_unload_all(fm);\n  image_manager_unload_all(imm);\n  locale_info_reload(locale_info);\n  assets_manager_set_theme(am, name);\n  widget_reset_canvas(widget);\n\n  info = assets_manager_ref(am, ASSET_TYPE_STYLE, \"default\");\n  if (info != NULL) {\n    theme_set(theme_load_from_data(info->name, info->data, info->size));\n    assets_manager_unref(assets_manager(), info);\n  }\n\n  widget_dispatch(wm, evt);\n  widget_invalidate_force(wm, NULL);\n\n  log_debug(\"theme changed: %s\\n\", name);\n#endif\n\n  return RET_OK;\n}\n\nret_t widget_set_pointer_cursor(widget_t* widget, const char* cursor) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (!tk_str_eq(widget->pointer_cursor, cursor)) {\n    widget->pointer_cursor = tk_str_copy(widget->pointer_cursor, cursor);\n    widget_update_pointer_cursor(widget);\n  }\n\n  return RET_OK;\n}\n\n#ifndef WITHOUT_WIDGET_ANIMATORS\nret_t widget_set_animation(widget_t* widget, const char* animation) {\n  return_value_if_fail(widget != NULL && animation != NULL, RET_BAD_PARAMS);\n\n  widget->animation = tk_str_copy(widget->animation, animation);\n\n  return widget_create_animator(widget, animation);\n}\n\nret_t widget_create_animator(widget_t* widget, const char* animation) {\n  tokenizer_t t;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && animation != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(tokenizer_init(&t, animation, strlen(animation), \";\") != NULL, RET_OOM);\n\n  while (tokenizer_has_more(&t)) {\n    const char* params = tokenizer_next(&t);\n    if (widget_animator_create(widget, params) == NULL) {\n      ret = RET_BAD_PARAMS;\n      break;\n    }\n  }\n  tokenizer_deinit(&t);\n  widget_invalidate(widget, NULL);\n\n  return ret;\n}\n\nret_t widget_start_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_start(widget_animator_manager(), widget, name);\n}\n\nret_t widget_set_animator_time_scale(widget_t* widget, const char* name, float_t time_scale) {\n  return widget_animator_manager_set_time_scale(widget_animator_manager(), widget, name,\n                                                time_scale);\n}\n\nret_t widget_pause_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_pause(widget_animator_manager(), widget, name);\n}\n\nwidget_animator_t* widget_find_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_find(widget_animator_manager(), widget, name);\n}\n\nret_t widget_stop_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_stop(widget_animator_manager(), widget, name);\n}\n\nret_t widget_destroy_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_remove_all(widget_animator_manager(), widget, name);\n}\n#else\nret_t widget_start_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nret_t widget_create_animator(widget_t* widget, const char* animation) {\n  return RET_OK;\n}\nret_t widget_set_animation(widget_t* widget, const char* animation) {\n  return RET_OK;\n}\nret_t widget_set_animator_time_scale(widget_t* widget, const char* name, float_t time_scale) {\n  return RET_OK;\n}\nret_t widget_pause_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nwidget_animator_t* widget_find_animator(widget_t* widget, const char* name) {\n  return NULL;\n}\nret_t widget_stop_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nret_t widget_destroy_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\n#endif /*WITHOUT_WIDGET_ANIMATORS*/\n\nret_t widget_set_enable(widget_t* widget, bool_t enable) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->enable != enable) {\n    widget->enable = enable;\n    widget_set_need_update_style_recursive(widget);\n    widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_feedback(widget_t* widget, bool_t feedback) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->feedback = feedback;\n\n  return RET_OK;\n}\n\nret_t widget_set_auto_adjust_size(widget_t* widget, bool_t auto_adjust_size) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->auto_adjust_size = auto_adjust_size;\n  widget_set_need_relayout(widget);\n\n  return RET_OK;\n}\n\nret_t widget_set_floating(widget_t* widget, bool_t floating) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->floating = floating;\n\n  return RET_OK;\n}\n\nret_t widget_set_focused_internal(widget_t* widget, bool_t focused) {\n  widget_t* win = widget_get_window(widget);\n  int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (WINDOW_STAGE_SUSPEND == stage) {\n    log_debug(\"You can not set focus of a widget when window is in background\");\n    return RET_FAIL;\n  }\n\n  if (widget->focused != focused) {\n    widget->focused = focused;\n    widget_set_need_update_style(widget);\n\n    if (focused) {\n      event_t e = event_init(EVT_FOCUS, widget);\n      widget_set_as_key_target(widget);\n\n      widget_dispatch(widget, &e);\n    } else {\n      event_t e = event_init(EVT_BLUR, widget);\n      widget_dispatch(widget, &e);\n      widget_dispatch_blur_event(widget);\n    }\n\n    widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_focused(widget_t* widget, bool_t focused) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_focused_internal(widget, focused);\n  if (focused) {\n    widget_ensure_visible_in_viewport(widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_focusable(widget_t* widget, bool_t focusable) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->focusable = focusable;\n\n  return RET_OK;\n}\n\nret_t widget_set_state(widget_t* widget, const char* state) {\n  return_value_if_fail(widget != NULL && state != NULL, RET_BAD_PARAMS);\n\n  if (!tk_str_eq(widget->state, state)) {\n    widget_invalidate_force(widget, NULL);\n    widget->state = tk_str_copy(widget->state, state);\n    widget_set_need_update_style(widget);\n    widget_invalidate_force(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_state_for_style(widget_t* widget, bool_t active, bool_t checked) {\n  const char* state = WIDGET_STATE_NORMAL;\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, state);\n\n  state = (const char*)(widget->state);\n\n  while (iter != NULL) {\n    if (!iter->enable) {\n      if (active) return WIDGET_STATE_DISABLE_OF_ACTIVE;\n      if (checked) return WIDGET_STATE_DISABLE_OF_CHECKED;\n      return WIDGET_STATE_DISABLE;\n    }\n    iter = iter->parent;\n  }\n\n  if (widget_is_focusable(widget) || widget_with_focus_state(widget)) {\n    if (widget->focused) {\n      if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n        state = WIDGET_STATE_FOCUSED;\n      }\n    } else {\n      if (tk_str_eq(state, WIDGET_STATE_FOCUSED)) {\n        state = WIDGET_STATE_NORMAL;\n      }\n    }\n  }\n\n  if (active) {\n    if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n      state = WIDGET_STATE_NORMAL_OF_ACTIVE;\n    } else if (tk_str_eq(state, WIDGET_STATE_PRESSED)) {\n      state = WIDGET_STATE_PRESSED_OF_ACTIVE;\n    } else if (tk_str_eq(state, WIDGET_STATE_OVER)) {\n      state = WIDGET_STATE_OVER_OF_ACTIVE;\n    } else if (widget_is_focusable(widget) && widget->focused) {\n      state = WIDGET_STATE_FOCUSED_OF_ACTIVE;\n    }\n  } else if (checked) {\n    if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n      state = WIDGET_STATE_NORMAL_OF_CHECKED;\n    } else if (tk_str_eq(state, WIDGET_STATE_PRESSED)) {\n      state = WIDGET_STATE_PRESSED_OF_CHECKED;\n    } else if (tk_str_eq(state, WIDGET_STATE_OVER)) {\n      state = WIDGET_STATE_OVER_OF_CHECKED;\n    } else if (widget_is_focusable(widget) && widget->focused) {\n      state = WIDGET_STATE_FOCUSED_OF_CHECKED;\n    }\n  }\n\n  return state;\n}\n\nret_t widget_set_opacity(widget_t* widget, uint8_t opacity) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->opacity = opacity;\n  widget_invalidate(widget, NULL);\n\n  return RET_OK;\n}\n\nret_t widget_set_dirty_rect_tolerance(widget_t* widget, uint16_t dirty_rect_tolerance) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->dirty_rect_tolerance = dirty_rect_tolerance;\n  widget_invalidate(widget, NULL);\n\n  return RET_OK;\n}\n\nret_t widget_destroy_children(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->children != NULL) {\n    WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n\n    widget_remove_child_prepare(widget, iter);\n    widget_unref(iter);\n\n    widget->children->elms[i] = NULL;\n\n    WIDGET_FOR_EACH_CHILD_END();\n    widget->children->size = 0;\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_style_type(widget_t* widget) {\n  theme_t* win_theme = NULL;\n  theme_t* default_theme = NULL;\n  const char* style_type = THEME_DEFAULT_STYLE_TYPE;\n\n  if (widget_get_window_theme(widget, &win_theme, &default_theme) == RET_OK) {\n    theme_t* t = win_theme != NULL ? win_theme : (default_theme != NULL ? default_theme : theme());\n    if (t != NULL) {\n      style_type = theme_get_style_type(t);\n    }\n  }\n\n  return style_type;\n}\n\nstatic ret_t widget_update_style_object(widget_t* widget) {\n  const char* style_type = widget_get_style_type(widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  if (widget->astyle == NULL) {\n    widget->astyle = style_factory_create_style(style_factory(), style_type);\n    ENSURE(widget->astyle != NULL);\n\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  } else if (widget->astyle != NULL &&\n             !tk_str_eq(style_get_style_type(widget->astyle), style_type)) {\n    style_t* style = style_factory_create_style(style_factory(), style_type);\n    ENSURE(style != NULL);\n    if (style_is_mutable(widget->astyle)) {\n      style_mutable_set_default_style(widget->astyle, style);\n    } else {\n      style_destroy(widget->astyle);\n      widget->astyle = style;\n    }\n\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  }\n  return RET_OK;\n}\n\nstatic ret_t widget_update_style_object_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_update_style_object(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_update_style_object_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_add_child(widget_t* widget, widget_t* child) {\n  event_t e = event_init(EVT_WIDGET_ADD_CHILD, widget);\n  return_value_if_fail(widget != NULL && child != NULL && child->parent == NULL, RET_BAD_PARAMS);\n\n  child->parent = widget;\n\n  if (widget->children == NULL) {\n    widget->children = darray_create(4, NULL, NULL);\n  }\n\n  if (widget->vt->on_add_child) {\n    if (widget->vt->on_add_child(widget, child) == RET_OK) {\n      return RET_OK;\n    }\n  }\n\n  if (child->vt->on_attach_parent) {\n    child->vt->on_attach_parent(child, widget);\n  }\n\n  ENSURE(darray_push(widget->children, child) == RET_OK);\n\n  if (!widget_is_window_manager(widget)) {\n    widget_set_need_relayout_children(widget);\n  }\n\n  if (!(child->initializing) && widget_get_window(child) != NULL) {\n    widget_set_need_update_style_recursive(child);\n    widget_update_style_object_recursive(child);\n  }\n\n  widget_dispatch(widget, &e);\n\n  return RET_OK;\n}\n\nret_t widget_remove_child_prepare(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n\n  if (!widget_is_window_manager(widget)) {\n    widget_set_need_relayout_children(widget);\n  }\n\n  widget_invalidate_force(child, NULL);\n  if (widget->target == child) {\n    widget->target = NULL;\n  }\n\n  if (widget->grab_widget == child) {\n    widget->grab_widget = NULL;\n    widget->grab_widget_count = 0;\n  }\n\n  if (widget->key_target == child) {\n    widget_dispatch_blur_event(widget->key_target);\n    widget->key_target = NULL;\n  }\n\n  if (widget->vt->on_remove_child) {\n    if (widget->vt->on_remove_child(widget, child) == RET_OK) {\n      return RET_OK;\n    }\n  }\n\n  if (child->vt->on_detach_parent) {\n    child->vt->on_detach_parent(child, widget);\n  }\n  child->parent = NULL;\n\n  return RET_OK;\n}\n\nret_t widget_remove_child(widget_t* widget, widget_t* child) {\n  ret_t ret = RET_OK;\n  event_t e = event_init(EVT_WIDGET_REMOVE_CHILD, widget);\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n\n  widget_remove_child_prepare(widget, child);\n  ret = darray_remove(widget->children, child);\n\n  if (ret == RET_OK) {\n    widget_dispatch(widget, &e);\n  }\n\n  return ret;\n}\n\nret_t widget_insert_child(widget_t* widget, uint32_t index, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget_add_child(widget, child) == RET_OK, RET_FAIL);\n\n  return widget_restack(child, index);\n}\n\nret_t widget_restack(widget_t* widget, uint32_t index) {\n  uint32_t i = 0;\n  uint32_t nr = 0;\n  int32_t old_index = 0;\n  widget_t** children = NULL;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, RET_BAD_PARAMS);\n\n  old_index = widget_index_of(widget);\n  nr = widget_count_children(widget->parent);\n  return_value_if_fail(old_index >= 0 && nr > 0, RET_BAD_PARAMS);\n\n  if (index >= nr) {\n    index = nr - 1;\n  }\n\n  if (index == old_index || nr == 1) {\n    return RET_OK;\n  }\n\n  children = (widget_t**)(widget->parent->children->elms);\n  if (index < old_index) {\n    for (i = old_index; i > index; i--) {\n      children[i] = children[i - 1];\n    }\n  } else {\n    for (i = old_index; i < index; i++) {\n      children[i] = children[i + 1];\n    }\n  }\n  children[index] = widget;\n\n  return RET_OK;\n}\n\nstatic widget_t* widget_lookup_child(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL && name != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (iter->name != NULL && tk_str_eq(iter->name, name)) {\n    return iter;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return NULL;\n}\n\nwidget_t* widget_child(widget_t* widget, const char* path) {\n  return widget_lookup_child(widget, path);\n}\n\nwidget_t* widget_get_focused_widget(widget_t* widget) {\n  widget_t* iter = NULL;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(win != NULL, NULL);\n\n  iter = win->key_target;\n  for (iter = win->key_target; iter != NULL; iter = iter->key_target) {\n    if (iter->focusable && iter->focused) {\n      return iter;\n    }\n\n    if (iter->key_target == NULL) {\n      return iter;\n    }\n  }\n\n  return NULL;\n}\n\nstatic widget_t* widget_lookup_all(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL && name != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (iter->name != NULL && tk_str_eq(iter->name, name)) {\n    return iter;\n  } else {\n    iter = widget_lookup_all(iter, name);\n    if (iter != NULL) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nwidget_t* widget_lookup(widget_t* widget, const char* name, bool_t recursive) {\n  if (recursive) {\n    return widget_lookup_all(widget, name);\n  } else {\n    return widget_lookup_child(widget, name);\n  }\n}\n\nstatic widget_t* widget_lookup_by_type_child(widget_t* widget, const char* type) {\n  return_value_if_fail(widget != NULL && type != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (tk_str_eq(iter->vt->type, type)) {\n    return iter;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return NULL;\n}\n\nstatic widget_t* widget_lookup_by_type_all(widget_t* widget, const char* type) {\n  return_value_if_fail(widget != NULL && type != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (tk_str_eq(iter->vt->type, type)) {\n    return iter;\n  } else {\n    iter = widget_lookup_by_type_all(iter, type);\n    if (iter != NULL) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nwidget_t* widget_lookup_by_type(widget_t* widget, const char* type, bool_t recursive) {\n  if (recursive) {\n    return widget_lookup_by_type_all(widget, type);\n  } else {\n    return widget_lookup_by_type_child(widget, type);\n  }\n}\n\nstatic ret_t widget_set_visible_self(widget_t* widget, bool_t visible) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->visible != visible) {\n    widget_invalidate_force(widget, NULL);\n    widget->visible = visible;\n    widget_set_need_update_style(widget);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget->parent);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_sensitive(widget_t* widget, bool_t sensitive) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->sensitive = sensitive;\n\n  return RET_OK;\n}\n\nret_t widget_set_visible_only(widget_t* widget, bool_t visible) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->visible = visible;\n\n  return RET_OK;\n}\n\nret_t widget_set_visible(widget_t* widget, bool_t visible, ...) {\n  return widget_set_visible_self(widget, visible);\n}\n\nwidget_t* widget_find_target(widget_t* widget, xy_t x, xy_t y) {\n  widget_t* ret = NULL;\n  return_value_if_fail(widget != NULL, NULL);\n\n  if (widget->vt && widget->vt->find_target) {\n    ret = widget->vt->find_target(widget, x, y);\n  } else {\n    ret = widget_find_target_default(widget, x, y);\n  }\n\n  return ret;\n}\n\nret_t widget_on_event_before_children(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt && widget->vt->on_event_before_children) {\n    ret = widget->vt->on_event_before_children(widget, e);\n  }\n\n  return ret;\n}\n\nstatic const char* widget_get_pointer_cursor(widget_t* widget) {\n  if (widget->pointer_cursor != NULL) {\n    return widget->pointer_cursor;\n  } else if (widget->vt->pointer_cursor != NULL) {\n    return widget->vt->pointer_cursor;\n  }\n\n  return WIDGET_CURSOR_DEFAULT;\n}\n\nret_t widget_update_pointer_cursor(widget_t* widget) {\n  widget_t* wm = widget_get_window_manager(widget);\n  return_value_if_fail(wm != NULL, RET_BAD_PARAMS);\n\n  return window_manager_set_cursor(wm, widget_get_pointer_cursor(widget));\n}\n\nret_t widget_dispatch(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  if (e->target == NULL) {\n    e->target = widget;\n  }\n\n  if (widget->vt && widget->vt->on_event) {\n    ret = widget->vt->on_event(widget, e);\n  } else {\n    ret = widget_on_event_default(widget, e);\n  }\n\n  if (ret != RET_STOP) {\n    if (widget->emitter != NULL) {\n      void* saved_target = e->target;\n\n      e->target = widget;\n      ret = emitter_dispatch(widget->emitter, e);\n      e->target = saved_target;\n    }\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t dispatch_in_idle(const idle_info_t* info) {\n  event_t* e = (event_t*)(info->ctx);\n  widget_t* widget = WIDGET(e->target);\n\n  widget_dispatch(widget, e);\n  widget_unref(widget);\n  event_destroy(e);\n\n  return RET_REMOVE;\n}\n\nret_t widget_dispatch_async(widget_t* widget, event_t* e) {\n  event_t* evt = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(e->target == widget, RET_BAD_PARAMS);\n\n  evt = event_clone(e);\n  return_value_if_fail(evt != NULL, RET_OOM);\n\n  widget_ref(widget);\n  idle_add(dispatch_in_idle, evt);\n\n  return RET_OK;\n}\n\nstatic ret_t widget_dispatch_callback(void* ctx, const void* data) {\n  widget_t* widget = WIDGET(data);\n\n  return widget_dispatch(widget, (event_t*)ctx);\n}\n\nret_t widget_dispatch_recursive(widget_t* widget, event_t* e) {\n  return widget_foreach(widget, widget_dispatch_callback, e);\n}\n\nuint32_t widget_on_with_tag(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx,\n                            uint32_t tag) {\n  return_value_if_fail(widget != NULL && on_event != NULL, RET_BAD_PARAMS);\n  if (widget->emitter == NULL) {\n    widget->emitter = emitter_create();\n  }\n\n  return emitter_on_with_tag(widget->emitter, type, on_event, ctx, tag);\n}\n\nuint32_t widget_on(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx) {\n  return widget_on_with_tag(widget, type, on_event, ctx, 0);\n}\n\nuint32_t widget_child_on(widget_t* widget, const char* name, uint32_t type, event_func_t on_event,\n                         void* ctx) {\n  return widget_on(widget_lookup(widget, name, TRUE), type, on_event, ctx);\n}\n\nret_t widget_off(widget_t* widget, uint32_t id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->emitter != NULL, RET_BAD_PARAMS);\n\n  return emitter_off(widget->emitter, id);\n}\n\nret_t widget_off_by_tag(widget_t* widget, uint32_t tag) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_tag(widget->emitter, tag);\n}\n\nret_t widget_off_by_ctx(widget_t* widget, void* ctx) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_ctx(widget->emitter, ctx);\n}\n\nret_t widget_off_by_func(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx) {\n  return_value_if_fail(widget != NULL && on_event != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_func(widget->emitter, type, on_event, ctx);\n}\n\nret_t widget_calc_icon_text_rect(const rect_t* ir, int32_t font_size, float_t text_size,\n                                 int32_t icon_at, uint32_t img_w, uint32_t img_h, int32_t spacer,\n                                 rect_t* r_text, rect_t* r_icon) {\n  return_value_if_fail(ir != NULL && (r_text != NULL || r_icon != NULL), RET_BAD_PARAMS);\n\n  if (r_icon == NULL) {\n    *r_text = *ir;\n\n    return RET_OK;\n  }\n\n  if (r_text == NULL) {\n    *r_icon = *ir;\n\n    return RET_OK;\n  }\n\n  return_value_if_fail(spacer < ir->h && spacer < ir->w, RET_BAD_PARAMS);\n  switch (icon_at) {\n    case ICON_AT_CENTRE: {\n      int32_t w = ir->w - spacer - text_size - img_w;\n      int32_t icon_h = ir->h - img_h;\n      *r_text = rect_init(ir->x + img_w + spacer + w / 2, ir->y, text_size, ir->h);\n      *r_icon = rect_init(ir->x + w / 2, ir->y + icon_h / 2, img_w, img_h);\n      break;\n    }\n    case ICON_AT_RIGHT: {\n      uint32_t w = img_w;\n      float_t ratio = system_info()->device_pixel_ratio;\n      if (ratio > 1) {\n        w = img_w / ratio;\n      }\n      w = tk_min(tk_max(w, ir->h), ir->w);\n      *r_icon = rect_init(ir->x + ir->w - w, ir->y, w, ir->h);\n      *r_text = rect_init(ir->x, ir->y, ir->w - ir->h - spacer, ir->h);\n      break;\n    }\n    case ICON_AT_TOP: {\n      int32_t icon_h = ir->h - font_size - spacer;\n      *r_icon = rect_init(ir->x, ir->y, ir->w, icon_h);\n      *r_text = rect_init(ir->x, icon_h + spacer, ir->w, font_size);\n      break;\n    }\n    case ICON_AT_BOTTOM: {\n      int32_t icon_h = ir->h - font_size - spacer;\n      *r_icon = rect_init(ir->x, ir->y + ir->h - icon_h, ir->w, icon_h);\n      *r_text = rect_init(ir->x, ir->y, ir->w, font_size);\n      break;\n    }\n    case ICON_AT_LEFT:\n    default: {\n      *r_icon = rect_init(ir->x, ir->y, ir->h, ir->h);\n      *r_text = rect_init(ir->x + ir->h + spacer, ir->y, ir->w - ir->h - spacer, ir->h);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_bidi(widget_t* widget) {\n  value_t v;\n  if (widget_get_prop(widget, WIDGET_PROP_BIDI, &v) == RET_OK) {\n    return value_str(&v);\n  }\n\n  return NULL;\n}\n\nret_t widget_draw_icon_text(widget_t* widget, canvas_t* c, const char* icon, wstr_t* text) {\n  rect_t ir;\n  wh_t w = 0;\n  wh_t h = 0;\n  bitmap_t img;\n  rect_t r_icon;\n  rect_t r_text;\n  int32_t margin = 0;\n  int32_t spacer = 0;\n  int32_t icon_at = 0;\n  uint16_t font_size = 0;\n  float_t text_size = 0.0f;\n  int32_t margin_left = 0;\n  int32_t margin_right = 0;\n  int32_t margin_top = 0;\n  int32_t margin_bottom = 0;\n  style_t* style = widget->astyle;\n  int32_t align_h = ALIGN_H_LEFT;\n  int32_t align_v = ALIGN_V_MIDDLE;\n  return_value_if_fail(widget->astyle != NULL, RET_BAD_PARAMS);\n\n  spacer = style_get_int(style, STYLE_ID_SPACER, 2);\n  margin = style_get_int(style, STYLE_ID_MARGIN, 0);\n  margin_top = style_get_int(style, STYLE_ID_MARGIN_TOP, margin);\n  margin_left = style_get_int(style, STYLE_ID_MARGIN_LEFT, margin);\n  margin_right = style_get_int(style, STYLE_ID_MARGIN_RIGHT, margin);\n  margin_bottom = style_get_int(style, STYLE_ID_MARGIN_BOTTOM, margin);\n  icon_at = style_get_int(style, STYLE_ID_ICON_AT, ICON_AT_AUTO);\n\n  w = widget->w - margin_left - margin_right;\n  h = widget->h - margin_top - margin_bottom;\n  ir = rect_init(margin_left, margin_top, w, h);\n\n  if (text == NULL) {\n    text = &(widget->text);\n  }\n\n  if (icon == NULL) {\n    icon = style_get_str(style, STYLE_ID_ICON, NULL);\n  }\n\n  widget_prepare_text_style(widget, c);\n\n  font_size = c->font_size;\n  text_size = text->str ? canvas_measure_text(c, text->str, text->size) : 0;\n  if (icon_at == ICON_AT_RIGHT || icon_at == ICON_AT_LEFT) {\n    align_v = style_get_int(style, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    align_h = style_get_int(style, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_LEFT);\n  } else {\n    align_v = style_get_int(style, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    align_h = style_get_int(style, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_CENTER);\n  }\n  canvas_set_text_align(c, (align_h_t)align_h, (align_v_t)align_v);\n\n  if (icon != NULL && widget_load_image(widget, icon, &img) == RET_OK) {\n    float_t dpr = system_info()->device_pixel_ratio;\n\n    if (text->size > 0) {\n      if ((h > (img.h / dpr + font_size) && icon_at == ICON_AT_AUTO)) {\n        icon_at = ICON_AT_TOP;\n      }\n\n      widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer, &r_text,\n                                 &r_icon);\n\n      canvas_draw_icon_in_rect(c, &img, &r_icon);\n      widget_draw_text_in_rect(widget, c, text->str, text->size, &r_text, FALSE);\n    } else {\n      if (icon_at == ICON_AT_AUTO) {\n        widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer, NULL,\n                                   &r_icon);\n      } else {\n        widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer,\n                                   &r_text, &r_icon);\n      }\n      canvas_draw_icon_in_rect(c, &img, &r_icon);\n    }\n  } else if (text != NULL && text->size > 0) {\n    widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, 0, 0, spacer, &r_text, NULL);\n    widget_draw_text_in_rect(widget, c, text->str, text->size, &r_text, FALSE);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_fill_rect(widget_t* widget, canvas_t* c, const rect_t* r, bool_t bg,\n                       image_draw_type_t draw_type) {\n  bitmap_t img;\n  ret_t ret = RET_OK;\n  gradient_t agradient;\n  style_t* style = widget->astyle;\n  uint32_t radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  const char* color_key = bg ? STYLE_ID_BG_COLOR : STYLE_ID_FG_COLOR;\n  const char* image_key = bg ? STYLE_ID_BG_IMAGE : STYLE_ID_FG_IMAGE;\n  rect_t bg_r = rect_init(widget->x, widget->y, widget->w, widget->h);\n  uint32_t radius_tl = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_LEFT, radius);\n  uint32_t radius_tr = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_RIGHT, radius);\n  uint32_t radius_bl = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_LEFT, radius);\n  uint32_t radius_br = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_RIGHT, radius);\n  uint32_t clear_bg = style_get_uint(style, STYLE_ID_CLEAR_BG, 0);\n  const char* draw_type_key = bg ? STYLE_ID_BG_IMAGE_DRAW_TYPE : STYLE_ID_FG_IMAGE_DRAW_TYPE;\n  gradient_t* gradient = style_get_gradient(style, color_key, &agradient);\n  const char* image_name = style_get_str(style, image_key, NULL);\n\n  if (gradient != NULL && r->w > 0 && r->h > 0) {\n    color_t color = gradient_get_first_color(gradient);\n    canvas_set_fill_color(c, color);\n    if (gradient->nr > 1 || color.rgba.a) {\n      if (radius_tl > 3 || radius_tr > 3 || radius_bl > 3 || radius_br > 3) {\n        /*TODO: support gradient*/\n        if (bg) {\n          ret = canvas_fill_rounded_rect_gradient_ex(c, r, NULL, gradient, radius_tl, radius_tr,\n                                                     radius_bl, radius_br);\n        } else {\n          ret = canvas_fill_rounded_rect_gradient_ex(c, r, &bg_r, gradient, radius_tl, radius_tr,\n                                                     radius_bl, radius_br);\n        }\n        if (ret == RET_FAIL) {\n          canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n        }\n      } else if (gradient->nr > 1) {\n        canvas_fill_rect_gradient(c, r->x, r->y, r->w, r->h, gradient);\n      } else {\n        if (clear_bg) {\n          canvas_clear_rect(c, r->x, r->y, r->w, r->h);\n        } else {\n          canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n        }\n      }\n    } else if (clear_bg) {\n      canvas_clear_rect(c, r->x, r->y, r->w, r->h);\n    }\n  }\n\n  if (image_name != NULL && *image_name && r->w > 0 && r->h > 0) {\n    char name[MAX_PATH + 1];\n    const char* region = strrchr(image_name, '#');\n    if (region != NULL) {\n      memset(name, 0x00, sizeof(name));\n      tk_strncpy(name, image_name, region - image_name);\n      image_name = name;\n    }\n\n    if (widget_load_image(widget, image_name, &img) == RET_OK) {\n      draw_type = (image_draw_type_t)style_get_int(style, draw_type_key, draw_type);\n\n      if (region == NULL) {\n        canvas_draw_image_ex(c, &img, draw_type, r);\n      } else {\n        rect_t src;\n        rect_t dst = *r;\n        if (tk_str_eq(region, \"#\")) {\n          src = rect_init(widget->x, widget->y, widget->w, widget->h);\n        } else if (tk_str_eq(region, \"#g\")) {\n          point_t p = {widget->x, widget->y};\n          widget_to_global(widget, &p);\n          src = rect_init(p.x, p.y, widget->w, widget->h);\n        } else {\n          image_region_parse(img.w, img.h, region, &src);\n        }\n\n        canvas_draw_image_ex2(c, &img, draw_type, &src, &dst);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_stroke_border_rect_for_border_type(canvas_t* c, const rect_t* r, color_t bd,\n                                                int32_t border, uint32_t border_width) {\n  wh_t w = r->w;\n  wh_t h = r->h;\n  xy_t x = r->x + 0.5;\n  xy_t y = r->y + 0.5;\n  xy_t y1 = y;\n  wh_t h1 = h;\n  bool_t draw_top = FALSE;\n  bool_t draw_bottom = FALSE;\n  canvas_set_fill_color(c, bd);\n  if (border & BORDER_TOP) {\n    draw_top = TRUE;\n    canvas_fill_rect(c, x, y, w, border_width);\n  }\n  if (border & BORDER_BOTTOM) {\n    draw_bottom = TRUE;\n    canvas_fill_rect(c, x, y + h - border_width, w, border_width);\n  }\n  /* 减少重复绘制的部分，可以修复有透明的时候重叠区域显示不正常为问题 */\n  if (draw_top) {\n    y1 += border_width;\n    h1 -= border_width;\n  }\n  if (draw_bottom) {\n    h1 -= border_width;\n  }\n  if (border & BORDER_LEFT) {\n    canvas_fill_rect(c, x, y1, border_width, h1);\n  }\n  if (border & BORDER_RIGHT) {\n    canvas_fill_rect(c, x + w - border_width, y1, border_width, h1);\n  }\n  return RET_OK;\n}\n\nret_t widget_stroke_border_rect(widget_t* widget, canvas_t* c, const rect_t* r) {\n  style_t* style = widget->astyle;\n  color_t trans = color_init(0, 0, 0, 0);\n  color_t bd = style_get_color(style, STYLE_ID_BORDER_COLOR, trans);\n  uint32_t radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  int32_t border = style_get_int(style, STYLE_ID_BORDER, BORDER_ALL);\n  uint32_t border_width = style_get_int(style, STYLE_ID_BORDER_WIDTH, 1);\n  uint32_t radius_tl = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_LEFT, radius);\n  uint32_t radius_tr = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_RIGHT, radius);\n  uint32_t radius_bl = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_LEFT, radius);\n  uint32_t radius_br = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_RIGHT, radius);\n\n  if (bd.rgba.a) {\n    canvas_set_stroke_color(c, bd);\n    if (radius_tl > 3 || radius_tr > 3 || radius_bl > 3 || radius_br > 3) {\n      if (canvas_stroke_rounded_rect_ex(c, r, NULL, &bd, radius_tl, radius_tr, radius_bl, radius_br,\n                                        border_width, border) != RET_OK) {\n        widget_stroke_border_rect_for_border_type(c, r, bd, border, border_width);\n      }\n    } else {\n      widget_stroke_border_rect_for_border_type(c, r, bd, border, border_width);\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_draw_background(widget_t* widget, canvas_t* c) {\n  rect_t r;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  r = rect_init(0, 0, widget->w, widget->h);\n\n  return widget_fill_rect(widget, c, &r, TRUE, IMAGE_DRAW_CENTER);\n}\n\nret_t widget_fill_bg_rect(widget_t* widget, canvas_t* c, const rect_t* r,\n                          image_draw_type_t draw_type) {\n  return widget_fill_rect(widget, c, r, TRUE, draw_type);\n}\n\nret_t widget_fill_fg_rect(widget_t* widget, canvas_t* c, const rect_t* r,\n                          image_draw_type_t draw_type) {\n  return widget_fill_rect(widget, c, r, FALSE, draw_type);\n}\n\nstatic ret_t widget_draw_border(widget_t* widget, canvas_t* c) {\n  rect_t r;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  r = rect_init(0, 0, widget->w, widget->h);\n  return widget_stroke_border_rect(widget, c, &r);\n}\n\nret_t widget_paint_helper(widget_t* widget, canvas_t* c, const char* icon, wstr_t* text) {\n  if (style_is_valid(widget->astyle)) {\n    widget_draw_icon_text(widget, c, icon, text);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_paint_impl(widget_t* widget, canvas_t* c) {\n  int32_t ox = widget->x;\n  int32_t oy = widget->y;\n  uint8_t save_alpha = c->global_alpha;\n\n  if (widget->opacity < TK_OPACITY_ALPHA) {\n    canvas_set_global_alpha(c, (widget->opacity * save_alpha) / 0xff);\n  }\n\n  if (widget->astyle != NULL) {\n    ox += style_get_int(widget->astyle, STYLE_ID_X_OFFSET, 0);\n    oy += style_get_int(widget->astyle, STYLE_ID_Y_OFFSET, 0);\n  }\n\n  canvas_translate(c, ox, oy);\n  widget_on_paint_begin(widget, c);\n  widget_on_paint_background(widget, c);\n  widget_on_paint_self(widget, c);\n  widget_on_paint_children(widget, c);\n  widget_on_paint_border(widget, c);\n  widget_on_paint_end(widget, c);\n\n  canvas_untranslate(c, ox, oy);\n  if (widget->opacity < TK_OPACITY_ALPHA) {\n    canvas_set_global_alpha(c, save_alpha);\n  }\n\n  widget_on_paint_done(widget, c);\n\n  return RET_OK;\n}\n\nret_t widget_paint(widget_t* widget, canvas_t* c) {\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  if (!widget->visible || widget->opacity <= 0x08 || widget->w <= 0 || widget->h <= 0) {\n    widget->dirty = FALSE;\n    return RET_OK;\n  }\n\n  if (widget->need_update_style) {\n    widget_update_style(widget);\n  }\n\n  canvas_save(c);\n  widget_paint_impl(widget, c);\n  canvas_restore(c);\n\n  widget->dirty = FALSE;\n\n  return RET_OK;\n}\n\nstatic const widget_cmd_t s_widget_cmds[] = {\n    {WIDGET_EXEC_START_ANIMATOR, widget_start_animator},\n    {WIDGET_EXEC_STOP_ANIMATOR, widget_stop_animator},\n    {WIDGET_EXEC_PAUSE_ANIMATOR, widget_pause_animator},\n    {WIDGET_EXEC_DESTROY_ANIMATOR, widget_destroy_animator}};\n\nstatic ret_t widget_do_exec(widget_t* widget, const char* cmd, const char* args) {\n  uint32_t i = 0;\n\n  for (i = 0; i < ARRAY_SIZE(s_widget_cmds); i++) {\n    const widget_cmd_t* iter = s_widget_cmds + i;\n    if (tk_str_eq(cmd, iter->name)) {\n      return iter->exec(widget, args);\n    }\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t widget_exec(widget_t* widget, const char* str) {\n  if (str != NULL) {\n    char cmd[TK_NAME_LEN + 1] = {0};\n    const char* args = strchr(str, ':');\n\n    if (args != NULL) {\n      return_value_if_fail((args - str) < TK_NAME_LEN, RET_BAD_PARAMS);\n      tk_strncpy(cmd, str, args - str);\n      args += 1;\n    } else {\n      return_value_if_fail(strlen(str) < TK_NAME_LEN, RET_BAD_PARAMS);\n      tk_strcpy(cmd, str);\n    }\n\n    return widget_do_exec(widget, cmd, args);\n  } else {\n    return RET_NOT_FOUND;\n  }\n}\n\nstatic widget_t* widget_get_top_widget_grab_key(widget_t* widget) {\n  return_value_if_fail(widget != NULL, NULL);\n  WIDGET_FOR_EACH_CHILD_BEGIN_R(widget, iter, i)\n  value_t v;\n  widget_t* widget_grab_key = widget_get_top_widget_grab_key(iter);\n  if (widget_grab_key == NULL && iter != NULL && iter->visible && iter->custom_props != NULL) {\n    ret_t ret = tk_object_get_prop(iter->custom_props, WIDGET_PROP_GRAB_KEYS, &v);\n    if (ret == RET_OK && value_bool(&v)) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nstatic ret_t widget_on_ungrab_keys(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  window_manager_t* wm = WINDOW_MANAGER(widget_get_window_manager(widget));\n\n  wm->widget_grab_key = widget_get_top_widget_grab_key(WIDGET(wm));\n\n  return RET_REMOVE;\n}\n\nstatic ret_t widget_exec_code(void* ctx, event_t* evt) {\n#ifndef WITHOUT_FSCRIPT\n  value_t v;\n  value_t result;\n  ret_t ret = RET_OK;\n  tk_object_t* obj = NULL;\n  widget_t* widget = WIDGET(evt->target);\n  const char* code = (const char*)ctx;\n  if (widget_get_prop(widget, STR_PROP_MODEL, &v) == RET_OK) {\n    obj = value_object(&v);\n  }\n  if (obj != NULL) {\n    TK_OBJECT_REF(obj);\n  } else {\n    obj = object_default_create();\n  }\n  return_value_if_fail(obj != NULL && code != NULL, RET_REMOVE);\n\n  tk_object_set_prop_pointer(obj, STR_PROP_SELF, widget);\n\n  switch (evt->type) {\n    case EVT_CLICK:\n    case EVT_POINTER_DOWN:\n    case EVT_POINTER_MOVE:\n    case EVT_POINTER_UP: {\n      pointer_event_t* e = pointer_event_cast(evt);\n      tk_object_set_prop_int(obj, \"x\", e->x);\n      tk_object_set_prop_int(obj, \"y\", e->y);\n      tk_object_set_prop_bool(obj, \"alt\", e->alt);\n      tk_object_set_prop_bool(obj, \"cmd\", e->cmd);\n      tk_object_set_prop_bool(obj, \"menu\", e->menu);\n      tk_object_set_prop_bool(obj, \"ctrl\", e->ctrl);\n      break;\n    }\n    case EVT_KEY_DOWN:\n    case EVT_KEY_LONG_PRESS:\n    case EVT_KEY_UP: {\n      key_event_t* e = key_event_cast(evt);\n      const key_type_value_t* kv = keys_type_find_by_value(e->key);\n      if (kv != NULL) {\n        tk_object_set_prop_str(obj, \"key\", kv->name);\n      } else {\n        tk_object_set_prop_str(obj, \"key\", \"unkown\");\n      }\n      tk_object_set_prop_bool(obj, \"alt\", e->alt);\n      tk_object_set_prop_bool(obj, \"cmd\", e->cmd);\n      tk_object_set_prop_bool(obj, \"menu\", e->menu);\n      tk_object_set_prop_bool(obj, \"ctrl\", e->ctrl);\n      break;\n    }\n    default:\n      break;\n  }\n\n  value_set_int(&result, 0);\n  fscript_eval(obj, code, &result);\n  if (tk_object_get_prop_bool(obj, \"RET_STOP\", FALSE)) {\n    ret = RET_STOP;\n  }\n  if (tk_object_get_prop_bool(obj, \"RET_REMOVE\", FALSE)) {\n    ret = RET_REMOVE;\n  }\n  value_reset(&result);\n  TK_OBJECT_UNREF(obj);\n\n  return ret;\n#else\n  return RET_OK;\n#endif\n}\n\nstatic ret_t widget_free_code(void* ctx, event_t* evt) {\n  widget_t* widget = WIDGET(evt->target);\n  widget_off_by_ctx(widget, ctx);\n  TKMEM_FREE(ctx);\n\n  return RET_REMOVE;\n}\n\n#define STR_ANIMATE_PREFIX \"animate:\"\n#define TK_ANIMATING_TIME 500 /* 单位：毫秒（ms） */\nret_t widget_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  ret_t ret = RET_OK;\n  prop_change_event_t e;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_EXEC)) {\n    ret = widget_exec(widget, value_str(v));\n    if (ret != RET_NOT_FOUND) {\n      return ret;\n    }\n  }\n\n  e.value = v;\n  e.name = name;\n  e.e = event_init(EVT_PROP_WILL_CHANGE, widget);\n  widget_dispatch(widget, (event_t*)&e);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    widget_set_x(widget, (xy_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    widget_set_y(widget, (xy_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    widget_set_w(widget, (wh_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    widget_set_h(widget, (wh_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    widget->opacity = (uint8_t)value_int(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    widget_set_visible(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    widget->sensitive = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    widget->floating = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    widget->focusable = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    widget->with_focus_state = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    widget->dirty_rect_tolerance = value_int(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    const char* name = value_str(v);\n    return widget_use_style(widget, name);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    widget_set_enable(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    widget->feedback = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    widget_set_auto_adjust_size(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    widget_set_name(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_TR_TEXT)) {\n    widget_set_tr_text(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    widget_set_animation(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    widget_set_self_layout(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_LAYOUT) || tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    widget_set_children_layout(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_POINTER_CURSOR)) {\n    widget_set_pointer_cursor(widget, value_str(v));\n  } else {\n    ret = RET_NOT_FOUND;\n  }\n\n  if (widget->vt->set_prop) {\n    if (tk_str_start_with(name, STR_ANIMATE_PREFIX)) {\n      return widget_animate_prop_float_to(widget, name + strlen(STR_ANIMATE_PREFIX),\n                                          value_float32(v), TK_ANIMATING_TIME);\n    } else {\n      ret_t ret1 = widget->vt->set_prop(widget, name, v);\n      if (ret == RET_NOT_FOUND) {\n        ret = ret1;\n      }\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_FOCUSED) || tk_str_eq(name, WIDGET_PROP_FOCUS)) {\n      widget_set_focused(widget, value_bool(v));\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n      wstr_from_value(&(widget->text), v);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_EXEC)) {\n      ret = RET_NOT_FOUND;\n    } else if (tk_str_start_with(name, \"style:\") || tk_str_start_with(name, \"style.\")) {\n      return widget_set_style(widget, name + 6, v);\n    } else {\n      if (widget->custom_props == NULL) {\n        widget->custom_props = object_default_create();\n      }\n\n      if (tk_str_eq(name, WIDGET_PROP_GRAB_KEYS)) {\n        window_manager_t* wm = WINDOW_MANAGER(widget_get_window_manager(widget));\n\n        if (value_bool(v)) {\n          widget_on(widget, EVT_DESTROY, widget_on_ungrab_keys, widget);\n          wm->widget_grab_key = widget;\n        }\n      }\n\n      if (strncmp(name, STR_ON_EVENT_PREFIX, sizeof(STR_ON_EVENT_PREFIX) - 1) == 0) {\n        int32_t etype = event_from_name(name + sizeof(STR_ON_EVENT_PREFIX) - 1);\n        if (etype != EVT_NONE) {\n          char* code = tk_strdup(value_str(v));\n          if (code != NULL) {\n            name += sizeof(STR_ON_EVENT_PREFIX) - 1;\n            if (strncmp(name, STR_GLOBAL_EVENT_PREFIX, sizeof(STR_GLOBAL_EVENT_PREFIX) - 1) == 0) {\n              widget_t* wm = window_manager();\n              widget_on(wm, etype, widget_exec_code, code);\n              widget_on(wm, EVT_DESTROY, widget_free_code, code);\n            } else {\n              widget_on(widget, etype, widget_exec_code, code);\n              widget_on(widget, EVT_DESTROY, widget_free_code, code);\n            }\n            ret = RET_OK;\n          }\n        } else {\n          log_debug(\"not found event %s\\n\", name);\n        }\n      } else {\n        ret = tk_object_set_prop(widget->custom_props, name, v);\n      }\n    }\n  }\n\n  if (ret != RET_NOT_FOUND) {\n    e.e.type = EVT_PROP_CHANGED;\n    widget_dispatch(widget, (event_t*)&e);\n    widget_invalidate(widget, NULL);\n  }\n\n  return ret;\n}\n\nret_t widget_get_prop(widget_t* widget, const char* name, value_t* v) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    value_set_int32(v, widget->x);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    value_set_int32(v, widget->y);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    value_set_int32(v, widget->w);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    value_set_int32(v, widget->h);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    value_set_int32(v, widget->opacity);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    value_set_bool(v, widget->visible);\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    value_set_bool(v, widget->sensitive);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    value_set_bool(v, widget->floating);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    value_set_bool(v, widget_is_focusable(widget));\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSED)) {\n    value_set_bool(v, widget->focused);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    value_set_bool(v, widget->with_focus_state);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    value_set_int(v, widget->dirty_rect_tolerance);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    value_set_str(v, widget->style);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    value_set_bool(v, widget->enable);\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    value_set_bool(v, widget->feedback);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    value_set_bool(v, widget->auto_adjust_size);\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    value_set_str(v, widget->name);\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    value_set_str(v, widget->animation);\n  } else if (tk_str_eq(name, WIDGET_PROP_POINTER_CURSOR)) {\n    value_set_str(v, widget->pointer_cursor);\n  } else if (tk_str_eq(name, WIDGET_PROP_LOADING)) {\n    value_set_bool(v, widget->loading);\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    if (widget->self_layout != NULL) {\n      value_set_str(v, self_layouter_to_string(widget->self_layout));\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  } else if (tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    if (widget->children_layout != NULL) {\n      value_set_str(v, children_layouter_to_string(widget->children_layout));\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  } else {\n    if (widget->vt->get_prop) {\n      ret = widget->vt->get_prop(widget, name, v);\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  }\n\n  /*default*/\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_LAYOUT_W)) {\n      value_set_int32(v, widget->w);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_LAYOUT_H)) {\n      value_set_int32(v, widget->h);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n      wchar_t* text = widget->text.str;\n      if (text != NULL) {\n        text[widget->text.size] = 0;\n      }\n      value_set_wstr(v, text);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_STATE_FOR_STYLE)) {\n      value_set_str(v, widget_get_state_for_style(widget, FALSE, FALSE));\n      ret = RET_OK;\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (widget->custom_props != NULL) {\n      ret = tk_object_get_prop(widget->custom_props, name, v);\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_TYPE)) {\n      value_set_str(v, widget->vt->type);\n      ret = RET_OK;\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_set_prop_str(widget_t* widget, const char* name, const char* str) {\n  value_t v;\n  value_set_str(&v, str);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nconst char* widget_get_prop_str(widget_t* widget, const char* name, const char* defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_str(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_pointer(widget_t* widget, const char* name, void* pointer) {\n  value_t v;\n  value_set_pointer(&v, pointer);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nvoid* widget_get_prop_pointer(widget_t* widget, const char* name) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_pointer(&v);\n  } else {\n    return NULL;\n  }\n}\n\nret_t widget_set_prop_float(widget_t* widget, const char* name, float_t num) {\n  value_t v;\n  value_set_float32(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nfloat_t widget_get_prop_float(widget_t* widget, const char* name, float_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_float32(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_int(widget_t* widget, const char* name, int32_t num) {\n  value_t v;\n  value_set_int(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nint32_t widget_get_prop_int(widget_t* widget, const char* name, int32_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_int(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_bool(widget_t* widget, const char* name, bool_t num) {\n  value_t v;\n  value_set_bool(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nbool_t widget_get_prop_bool(widget_t* widget, const char* name, bool_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_bool(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_on_paint_background(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_background) {\n    ret = widget->vt->on_paint_background(widget, c);\n  } else {\n    if (style_is_valid(widget->astyle)) {\n      widget_draw_background(widget, c);\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_self(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_self) {\n    ret = widget->vt->on_paint_self(widget, c);\n  } else {\n    paint_event_t e;\n    widget_dispatch(widget, paint_event_init(&e, EVT_PAINT, widget, c));\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_children(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_children) {\n    ret = widget->vt->on_paint_children(widget, c);\n  } else {\n    ret = widget_on_paint_children_default(widget, c);\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_border(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_border) {\n    ret = widget->vt->on_paint_border(widget, c);\n  } else {\n    if (style_is_valid(widget->astyle)) {\n      ret = widget_draw_border(widget, c);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_begin(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_begin) {\n    ret = widget->vt->on_paint_begin(widget, c);\n  }\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_BEFORE_PAINT, widget, c));\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_done(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_PAINT_DONE, widget, c));\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_end(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_end) {\n    ret = widget->vt->on_paint_end(widget, c);\n  }\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_AFTER_PAINT, widget, c));\n\n  return ret;\n}\n\nret_t widget_dispatch_to_target(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  e->target = widget;\n  widget_dispatch(widget, e);\n\n  if (widget->target) {\n    ret = widget_dispatch_to_target(widget->target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_map_key(widget_t* widget, key_event_t* e) {\n  value_t v;\n  const key_type_value_t* kv = NULL;\n\n  if (widget->custom_props != NULL) {\n    kv = keys_type_find_by_value(e->key);\n    if (kv != NULL) {\n      const char* to = NULL;\n      char from[TK_NAME_LEN + 1] = {0};\n      char fixed_name[TK_NAME_LEN + 1];\n\n      tk_snprintf(from, sizeof(from), \"map_key:%s\", kv->name);\n      if (tk_object_get_prop(widget->custom_props, from, &v) == RET_OK) {\n        to = value_str(&v);\n      } else if (strlen(kv->name) > 1) {\n        tk_strcpy(fixed_name, kv->name);\n        tk_str_tolower(fixed_name);\n        tk_snprintf(from, sizeof(from), \"map_key:%s\", fixed_name);\n        if (tk_object_get_prop(widget->custom_props, from, &v) == RET_OK) {\n          to = value_str(&v);\n        }\n      }\n\n      if (to != NULL) {\n        kv = keys_type_find(to);\n        if (kv != NULL) {\n          e->key = kv->value;\n          log_debug(\"map key %s to %s\\n\", from, to);\n        }\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_dispatch_to_key_target(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  e->target = widget;\n  widget_dispatch(widget, e);\n\n  if (widget->key_target) {\n    ret = widget_dispatch_to_target(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_before_children(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    key_event_t before = *e;\n    before.e.type = EVT_KEY_DOWN_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_keydown_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_keydown(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_after_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_keydown) {\n    ret = widget->vt->on_keydown(widget, e);\n  }\n\n  return ret;\n}\n\nbool_t widget_is_activate_key(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL && e != NULL, FALSE);\n\n  return (widget->vt->space_key_to_activate && e->key == TK_KEY_SPACE) ||\n         (widget->vt->return_key_to_activate && key_code_is_enter(e->key));\n}\n\nstatic bool_t shortcut_fast_match(const char* shortcut, key_event_t* e) {\n  uint32_t key = e->key;\n  const char* kname = strrchr(shortcut, '+');\n  bool_t cmd = strstr(shortcut, \"cmd\") != NULL;\n  bool_t ctrl = strstr(shortcut, \"ctrl\") != NULL;\n  bool_t shift = strstr(shortcut, \"shift\") != NULL;\n  const key_type_value_t* kv = keys_type_find_by_value(key);\n\n  if (kv != NULL) {\n    if (kname == NULL) {\n      kname = shortcut;\n    } else {\n      kname++;\n    }\n\n    if (tk_str_ieq(kname, kv->name) && cmd == e->cmd && ctrl == e->ctrl && shift == e->shift) {\n      return TRUE;\n    }\n  }\n\n  return FALSE;\n}\n\nstatic bool_t widget_match_key(widget_t* widget, const char* prop, key_event_t* e) {\n  const char* shortcut = NULL;\n  widget_t* win = widget_get_window(widget);\n\n  if (widget_is_window_manager(widget)) {\n    return FALSE;\n  }\n\n  return_value_if_fail(win != NULL, FALSE);\n  shortcut = widget_get_prop_str(win, prop, NULL);\n\n  if (shortcut != NULL) {\n    return shortcut_fast_match(shortcut, e);\n  }\n\n  return FALSE;\n}\n\nstatic bool_t widget_is_move_focus_prev_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_PREV_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_next_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_NEXT_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_up_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_UP_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_down_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_DOWN_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_left_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_LEFT_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_right_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_RIGHT_KEY, e);\n}\n\nbool_t widget_is_change_focus_key(widget_t* widget, key_event_t* e) {\n  return widget_is_move_focus_prev_key(widget, e) || widget_is_move_focus_next_key(widget, e) ||\n         widget_is_move_focus_up_key(widget, e) || widget_is_move_focus_down_key(widget, e) ||\n         widget_is_move_focus_left_key(widget, e) || widget_is_move_focus_right_key(widget, e);\n}\n\nstatic ret_t widget_on_keydown_general(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  if (!widget_is_window_manager(widget)) {\n    if (widget_is_activate_key(widget, e)) {\n      ret = RET_STOP;\n      widget_set_state(widget, WIDGET_STATE_PRESSED);\n    } else if (widget_is_move_focus_next_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_next(widget);\n      } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n        ret = RET_STOP;\n        widget_focus_first(widget);\n      }\n    } else if (widget_is_move_focus_prev_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_prev(widget);\n      } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n        ret = RET_STOP;\n        widget_focus_first(widget);\n      }\n    } else if (widget_is_move_focus_up_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_up(widget);\n      }\n    } else if (widget_is_move_focus_down_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_down(widget);\n      }\n    } else if (widget_is_move_focus_left_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_left(widget);\n      }\n    } else if (widget_is_move_focus_right_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_right(widget);\n      }\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_impl(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_keydown_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keydown_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keydown_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_keydown(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  uint32_t key = e->key;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  widget_map_key(widget, e);\n  if (e->e.type == EVT_KEY_DOWN) {\n    ret = widget_on_keydown_impl(widget, e);\n    if (widget->feedback) {\n      ui_feedback_request(widget, (event_t*)e);\n    }\n\n    e->key = key;\n    if (ret != RET_STOP) {\n      ret = widget_on_keydown_general(widget, e);\n    }\n  } else if (e->e.type == EVT_KEY_LONG_PRESS) {\n    return_value_if_equal(widget_on_keydown_children(widget, e), RET_STOP);\n    ret = widget_on_keydown_after_children(widget, e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_before_children(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    key_event_t before = *e;\n    before.e.type = EVT_KEY_UP_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_keyup_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_keyup(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_after_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_keyup) {\n    ret = widget->vt->on_keyup(widget, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_impl(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_keyup_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keyup_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keyup_after_children(widget, e), RET_STOP);\n\n  if (widget_is_activate_key(widget, e)) {\n    pointer_event_t click;\n    if (widget_is_focusable(widget)) {\n      widget_set_state(widget, WIDGET_STATE_FOCUSED);\n    } else {\n      widget_set_state(widget, WIDGET_STATE_NORMAL);\n    }\n    widget_dispatch_async(widget, pointer_event_init(&click, EVT_CLICK, widget, 0, 0));\n\n    ret = RET_STOP;\n  } else if (widget_is_move_focus_next_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_prev_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_up_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_down_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_left_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_right_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_on_keyup(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  uint32_t key = e->key;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  widget_map_key(widget, e);\n  ret = widget_on_keyup_impl(widget, e);\n  if (widget->feedback) {\n    ui_feedback_request(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  e->key = key;\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_before_children(widget_t* widget, wheel_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    wheel_event_t before = *e;\n    before.e.type = EVT_WHEEL_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_wheel_children(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_wheel(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_after_children(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_wheel) {\n    ret = widget->vt->on_wheel(widget, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_impl(widget_t* widget, wheel_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_wheel_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_wheel_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_wheel_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_wheel(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_wheel_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}\n\nret_t widget_on_multi_gesture(widget_t* widget, multi_gesture_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\n    ret = widget_dispatch(target, (event_t*)e);\n  }\n\n  if (ret != RET_STOP) {\n    ret = widget_dispatch(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_dispatch_leave_event(widget_t* widget, pointer_event_t* e) {\n  widget_t* target = widget;\n\n  while (target != NULL) {\n    widget_t* curr = target;\n    pointer_event_t leave = *e;\n    leave.e.type = EVT_POINTER_LEAVE;\n\n    widget_dispatch(target, (event_t*)(&leave));\n    target = curr->target;\n    curr->target = NULL;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_dispatch_blur_event(widget_t* widget) {\n  widget_t* target = widget;\n  widget_t* temp;\n\n  while (target != NULL) {\n    widget_ref(target);\n    if (target->focused) {\n      target->focused = FALSE;\n      event_t e = event_init(EVT_BLUR, target);\n      widget_dispatch(target, &e);\n      widget_set_need_update_style(target);\n    }\n\n    if (target->parent && target->parent->key_target == target) {\n      target->parent->key_target = NULL;\n    }\n\n    temp = target->key_target;\n    widget_unref(target);\n    target = temp;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_dispatch_event_to_target_recursive(widget_t* widget, event_t* e) {\n  widget_t* target = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  target = widget->grab_widget ? widget->grab_widget : widget->target;\n  while (target != NULL) {\n    widget_dispatch(target, e);\n    target = target->target != NULL ? target->target : target->key_target;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_on_pointer_down_before_children(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    pointer_event_t before = *e;\n    before.e.type = EVT_POINTER_DOWN_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nret_t widget_on_pointer_down_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n\n  if (target != NULL && target->enable && target->sensitive) {\n    if (!(widget_is_keyboard(target))) {\n      if (widget_is_focusable(target) || !widget_is_strongly_focus(widget)) {\n        if (!target->focused) {\n          widget_set_focused_internal(target, TRUE);\n        } else {\n          widget->key_target = target;\n        }\n      }\n    }\n  } else if (widget->key_target && !widget_is_strongly_focus(widget)) {\n    widget_set_focused_internal(widget->key_target, FALSE);\n  }\n  return_value_if_equal(ret, RET_STOP);\n\n  if (widget->target != target) {\n    if (widget->target != NULL) {\n      widget_dispatch_leave_event(widget->target, e);\n    }\n    widget->target = target;\n  }\n\n  if (widget->target != NULL) {\n    ret = widget_on_pointer_down(widget->target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_down_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_pointer_down) {\n    return_value_if_equal(ret = widget->vt->on_pointer_down(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_down_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  widget->grab_widget = NULL;\n  widget->grab_widget_count = 0;\n  return_value_if_equal(widget_on_pointer_down_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_pointer_down_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_pointer_down_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_pointer_down(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_pointer_down_impl(widget, e);\n  if (widget->feedback) {\n    ui_feedback_request(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_move_before_children(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    pointer_event_t before = *e;\n    before.e.type = EVT_POINTER_MOVE_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nret_t widget_on_pointer_move_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n\n  if (target != widget->target) {\n    if (widget->target != NULL) {\n      widget_dispatch_leave_event(widget->target, e);\n    }\n\n    if (target != NULL) {\n      pointer_event_t enter = *e;\n      enter.e.type = EVT_POINTER_ENTER;\n      ret = widget_dispatch(target, (event_t*)(&enter));\n      widget_update_pointer_cursor(target);\n    } else {\n      widget_update_pointer_cursor(widget);\n    }\n\n    widget->target = target;\n  }\n  return_value_if_equal(ret, RET_STOP);\n\n  if (widget->target != NULL) {\n    ret = widget_on_pointer_move(widget->target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_move_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_pointer_move) {\n    return_value_if_equal(ret = widget->vt->on_pointer_move(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_move_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_pointer_move_before_children(widget, e), RET_STOP);\n  if (widget_on_pointer_move_children(widget, e) == RET_STOP) {\n    if (e->pressed) {\n      pointer_event_t abort;\n      pointer_event_init(&abort, EVT_POINTER_DOWN_ABORT, widget, e->x, e->y);\n      return_value_if_equal(widget_on_pointer_move_after_children(widget, &abort), RET_STOP);\n    }\n\n    return RET_STOP;\n  } else {\n    return widget_on_pointer_move_after_children(widget, e);\n  }\n}\n\nret_t widget_on_pointer_move(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_pointer_move_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_up_before_children(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    pointer_event_t before = *e;\n    before.e.type = EVT_POINTER_UP_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nret_t widget_on_pointer_up_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\n    ret = widget_on_pointer_up(target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_up_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_pointer_up) {\n    return_value_if_equal(ret = widget->vt->on_pointer_up(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_up_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_pointer_up_before_children(widget, e), RET_STOP);\n  if (widget_on_pointer_up_children(widget, e) == RET_STOP) {\n    if (e->pressed) {\n      pointer_event_t abort;\n      pointer_event_init(&abort, EVT_POINTER_DOWN_ABORT, widget, e->x, e->y);\n      return_value_if_equal(widget_on_pointer_up_after_children(widget, &abort), RET_STOP);\n    }\n\n    return RET_STOP;\n  } else {\n    return widget_on_pointer_up_after_children(widget, e);\n  }\n}\n\nret_t widget_on_pointer_up(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_pointer_up_impl(widget, e);\n  if (widget->feedback) {\n    ui_feedback_request(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_context_menu_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\n    ret = widget_on_context_menu(target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_context_menu_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_context_menu) {\n    return_value_if_equal(ret = widget->vt->on_context_menu(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_context_menu_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget_on_context_menu_children(widget, e) == RET_STOP) {\n    return RET_STOP;\n  } else {\n    return widget_on_context_menu_after_children(widget, e);\n  }\n}\n\nret_t widget_on_context_menu(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_context_menu_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}\n\nret_t widget_grab(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->grab_widget == NULL || widget->grab_widget == child, RET_BAD_PARAMS);\n\n  if (widget->grab_widget == NULL) {\n    widget->grab_widget = child;\n    widget->grab_widget_count = 1;\n  } else {\n    widget->grab_widget_count++;\n  }\n\n  if (widget->parent) {\n    widget_grab(widget->parent, widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_ungrab(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->grab_widget == child) {\n    if (widget->grab_widget->grab_widget_count < widget->grab_widget_count) {\n      widget->grab_widget_count--;\n      if (widget->grab_widget_count <= 0) {\n        widget->grab_widget = NULL;\n        widget->grab_widget_count = 0;\n      }\n\n      if (widget->parent) {\n        widget_ungrab(widget->parent, widget);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_foreach(widget_t* widget, tk_visit_t visit, void* ctx) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && visit != NULL, RET_BAD_PARAMS);\n\n  ret = visit(ctx, widget);\n  if (ret != RET_OK) {\n    return ret;\n  }\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  ret = widget_foreach(iter, visit, ctx);\n  if (ret == RET_STOP || ret == RET_DONE) {\n    return ret;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return RET_OK;\n}\n\nwidget_t* widget_get_window(widget_t* widget) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, NULL);\n\n  while (iter) {\n    if (widget_is_window(iter)) {\n      return iter;\n    }\n    iter = iter->parent;\n  }\n\n  return NULL;\n}\n\nstatic widget_t* widget_get_window_or_keyboard(widget_t* widget) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, NULL);\n\n  while (iter) {\n    if (widget_is_window(iter) || widget_is_keyboard(iter)) {\n      return iter;\n    }\n    iter = iter->parent;\n  }\n\n  return NULL;\n}\n\nwidget_t* widget_get_window_manager(widget_t* widget) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, NULL);\n\n  while (iter) {\n    if (widget_is_window_manager(iter)) {\n      return iter;\n    }\n    iter = iter->parent;\n  }\n\n  return window_manager();\n}\n\nuint32_t widget_add_timer(widget_t* widget, timer_func_t on_timer, uint32_t duration_ms) {\n  return_value_if_fail(widget != NULL && on_timer != NULL, TK_INVALID_ID);\n  return timer_add_with_type(on_timer, widget, duration_ms, TIMER_INFO_WIDGET_ADD);\n}\n\nret_t widget_remove_timer(widget_t* widget, uint32_t timer_id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return timer_remove(timer_id);\n}\n\nuint32_t widget_add_idle(widget_t* widget, idle_func_t on_idle) {\n  return_value_if_fail(widget != NULL && on_idle != NULL, TK_INVALID_ID);\n  return idle_add_with_type(on_idle, widget, IDLE_INFO_WIDGET_ADD);\n}\n\nret_t widget_remove_idle(widget_t* widget, uint32_t idle_id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return idle_remove(idle_id);\n}\n\nret_t widget_destroy_sync(widget_t* widget) {\n  event_t e = event_init(EVT_DESTROY, widget);\n  return_value_if_fail(widget != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n\n#ifndef WITHOUT_WIDGET_ANIMATORS\n  widget_destroy_animator(widget, NULL);\n#endif /*WITHOUT_WIDGET_ANIMATORS*/\n\n  widget->destroying = TRUE;\n  idle_remove_all_by_ctx_and_type(IDLE_INFO_WIDGET_ADD, widget);\n  timer_remove_all_by_ctx_and_type(TIMER_INFO_WIDGET_ADD, widget);\n\n  if (widget->emitter != NULL) {\n    widget_dispatch(widget, &e);\n    emitter_destroy(widget->emitter);\n    widget->emitter = NULL;\n  }\n\n  if (widget->children != NULL) {\n    widget_destroy_children(widget);\n    darray_destroy(widget->children);\n    widget->children = NULL;\n  }\n\n  if (widget->children_layout != NULL) {\n    children_layouter_destroy(widget->children_layout);\n    widget->children_layout = NULL;\n  }\n\n  if (widget->self_layout != NULL) {\n    self_layouter_destroy(widget->self_layout);\n    widget->self_layout = NULL;\n  }\n\n  widget->destroying = FALSE;\n\n  return widget_real_destroy(widget);\n}\n\nwidget_t* widget_create(widget_t* parent, const widget_vtable_t* vt, xy_t x, xy_t y, wh_t w,\n                        wh_t h) {\n  return_value_if_fail(vt != NULL, NULL);\n\n  return widget_init(widget_real_create(vt), parent, vt, x, y, w, h);\n}\n\nret_t widget_destroy(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->ref_count > 0 && widget->vt != NULL,\n                       RET_BAD_PARAMS);\n\n  if (widget->parent != NULL) {\n    widget_remove_child(widget->parent, widget);\n  }\n\n  return widget_unref_async(widget);\n}\n\nstatic ret_t widget_destroy_on_idle(const idle_info_t* info) {\n  widget_destroy(WIDGET(info->ctx));\n\n  return RET_REMOVE;\n}\n\nret_t widget_destroy_async(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->ref_count > 0 && widget->vt != NULL,\n                       RET_BAD_PARAMS);\n\n  return_value_if_fail(idle_add(widget_destroy_on_idle, widget) != TK_INVALID_ID, RET_FAIL);\n\n  return RET_OK;\n}\n\nstatic ret_t widget_set_parent_not_dirty(widget_t* widget) {\n  widget_t* iter = widget->parent;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    iter->dirty = FALSE;\n    if (iter->vt->is_window) {\n      break;\n    }\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_invalidate(widget_t* widget, const rect_t* r) {\n  rect_t rself;\n  return_value_if_fail(widget != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->dirty) {\n    return RET_OK;\n  }\n\n  if (r == NULL) {\n    rself = rect_init(0, 0, widget->w, widget->h);\n    r = &rself;\n  }\n\n  widget->dirty = TRUE;\n  widget_set_parent_not_dirty(widget);\n\n  if (widget->vt && widget->vt->invalidate) {\n    return widget->vt->invalidate(widget, r);\n  } else {\n    return widget_invalidate_default(widget, r);\n  }\n}\n\nret_t widget_invalidate_force(widget_t* widget, const rect_t* r) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->dirty = FALSE;\n  return widget_invalidate(widget, r);\n}\n\nwidget_t* widget_init(widget_t* widget, widget_t* parent, const widget_vtable_t* vt, xy_t x, xy_t y,\n                      wh_t w, wh_t h) {\n  return_value_if_fail(widget != NULL && vt != NULL, NULL);\n\n  widget->x = x;\n  widget->y = y;\n  widget->w = w;\n  widget->h = h;\n  widget->vt = vt;\n  widget->dirty = TRUE;\n  widget->ref_count = 1;\n  widget->opacity = 0xff;\n  widget->enable = TRUE;\n  widget->visible = TRUE;\n  widget->feedback = FALSE;\n  widget->auto_adjust_size = FALSE;\n  widget->sensitive = TRUE;\n  widget->emitter = NULL;\n  widget->children = NULL;\n  widget->initializing = TRUE;\n  widget->state = tk_strdup(WIDGET_STATE_NORMAL);\n  widget->target = NULL;\n  widget->key_target = NULL;\n  widget->grab_widget = NULL;\n  widget->grab_widget_count = 0;\n  widget->focused = FALSE;\n  widget->focusable = FALSE;\n  widget->with_focus_state = FALSE;\n  widget->dirty_rect_tolerance = 4;\n  widget->need_update_style = TRUE;\n\n  if (parent) {\n    widget_add_child(parent, widget);\n  }\n\n  wstr_init(&(widget->text), 0);\n  if (!widget->vt) {\n    widget->vt = widget_vtable_default();\n  }\n\n  if (widget->astyle == NULL &&\n      (widget_is_window_manager(widget) || widget_get_window(widget) != NULL)) {\n    widget->astyle = style_factory_create_style(style_factory(), widget_get_style_type(widget));\n    ENSURE(widget->astyle != NULL);\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  }\n\n  widget_invalidate_force(widget, NULL);\n\n  widget->initializing = FALSE;\n\n  return widget;\n}\n\nret_t widget_get_prop_default_value(widget_t* widget, const char* name, value_t* v) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    value_set_int32(v, 0xff);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    value_set_int(v, 4);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n    value_set_wstr(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSED)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    value_set_bool(v, FALSE);\n  } else {\n    if (widget->vt->get_prop_default_value) {\n      ret = widget->vt->get_prop_default_value(widget, name, v);\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_get_offset(widget_t* widget, xy_t* out_x, xy_t* out_y) {\n  return_value_if_fail(widget != NULL && out_x != NULL && out_y != NULL, RET_BAD_PARAMS);\n  *out_x = 0;\n  *out_y = 0;\n  if (widget->vt != NULL && widget->vt->get_offset != NULL) {\n    return widget->vt->get_offset(widget, out_x, out_y);\n  }\n  return RET_OK;\n}\n\nret_t widget_to_screen_ex(widget_t* widget, widget_t* parent, point_t* p) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL && p != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL && iter != parent) {\n    xy_t offset_x, offset_y;\n    if (widget_get_offset(iter, &offset_x, &offset_y) == RET_OK) {\n      p->x -= offset_x;\n      p->y -= offset_y;\n    }\n\n    p->x += iter->x;\n    p->y += iter->y;\n\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_to_screen(widget_t* widget, point_t* p) {\n  return widget_to_screen_ex(widget, NULL, p);\n}\n\nret_t widget_to_local(widget_t* widget, point_t* p) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL && p != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    xy_t offset_x = 0;\n    xy_t offset_y = 0;\n    if (widget_get_offset(iter, &offset_x, &offset_y) == RET_OK) {\n      p->x += offset_x;\n      p->y += offset_y;\n    }\n\n    p->x -= iter->x;\n    p->y -= iter->y;\n\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_to_global(widget_t* widget, point_t* p) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL && p != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    p->x += iter->x;\n    p->y += iter->y;\n\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nint32_t widget_count_children(widget_t* widget) {\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget->children != NULL ? widget->children->size : 0;\n}\n\nwidget_t* widget_get_child(widget_t* widget, int32_t index) {\n  return_value_if_fail(widget != NULL, NULL);\n  if (widget->children == NULL || index >= widget->children->size) {\n    return NULL;\n  }\n\n  return WIDGET(widget->children->elms[index]);\n}\n\nint32_t widget_index_of(widget_t* widget) {\n  widget_t* parent = NULL;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, -1);\n\n  parent = widget->parent;\n  WIDGET_FOR_EACH_CHILD_BEGIN(parent, iter, i)\n  if (iter == widget) {\n    return i;\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return -1;\n}\n\nret_t widget_prepare_text_style_ex(widget_t* widget, canvas_t* c, color_t default_trans,\n                                   const char* default_font, uint16_t default_font_size,\n                                   align_h_t default_align_h, align_v_t default_align_v) {\n  style_t* style = widget->astyle;\n  color_t tc = style_get_color(style, STYLE_ID_TEXT_COLOR, default_trans);\n  const char* font_name = style_get_str(style, STYLE_ID_FONT_NAME, default_font);\n  uint16_t font_size = style_get_int(style, STYLE_ID_FONT_SIZE, default_font_size);\n  align_h_t align_h = (align_h_t)style_get_int(style, STYLE_ID_TEXT_ALIGN_H, default_align_h);\n  align_v_t align_v = (align_v_t)style_get_int(style, STYLE_ID_TEXT_ALIGN_V, default_align_v);\n\n  canvas_set_text_color(c, tc);\n  canvas_set_font(c, font_name, font_size);\n  canvas_set_text_align(c, align_h, align_v);\n\n  return RET_OK;\n}\n\nret_t widget_prepare_text_style(widget_t* widget, canvas_t* c) {\n  color_t trans = color_init(0, 0, 0, 0);\n  return widget_prepare_text_style_ex(widget, c, trans, NULL, TK_DEFAULT_FONT_SIZE, ALIGN_H_CENTER,\n                                      ALIGN_V_MIDDLE);\n}\n\nstatic ret_t widget_copy_style(widget_t* clone, widget_t* widget) {\n  if (style_is_mutable(widget->astyle) && style_mutable_cast(widget->astyle) != NULL) {\n    if (!style_is_mutable(clone->astyle)) {\n      widget_ensure_style_mutable(clone);\n    }\n\n    if (style_mutable_cast(clone->astyle) != NULL) {\n      style_mutable_copy(clone->astyle, widget->astyle);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic const char* const s_widget_persistent_props[] = {WIDGET_PROP_NAME,\n                                                        WIDGET_PROP_STYLE,\n                                                        WIDGET_PROP_TR_TEXT,\n                                                        WIDGET_PROP_TEXT,\n                                                        WIDGET_PROP_ANIMATION,\n                                                        WIDGET_PROP_ENABLE,\n                                                        WIDGET_PROP_VISIBLE,\n                                                        WIDGET_PROP_FLOATING,\n                                                        WIDGET_PROP_CHILDREN_LAYOUT,\n                                                        WIDGET_PROP_SELF_LAYOUT,\n                                                        WIDGET_PROP_OPACITY,\n                                                        WIDGET_PROP_FOCUSED,\n                                                        WIDGET_PROP_FEEDBACK,\n                                                        WIDGET_PROP_AUTO_ADJUST_SIZE,\n                                                        WIDGET_PROP_FOCUSABLE,\n                                                        WIDGET_PROP_SENSITIVE,\n                                                        WIDGET_PROP_WITH_FOCUS_STATE,\n                                                        NULL};\n\nconst char* const* widget_get_persistent_props(void) {\n  return s_widget_persistent_props;\n}\n\nstatic ret_t widget_copy_base_props(widget_t* widget, widget_t* other) {\n  widget->state = tk_str_copy(widget->state, other->state);\n  widget->name = tk_str_copy(widget->name, other->name);\n  widget->style = tk_str_copy(widget->style, other->style);\n\n  if (other->text.str != NULL) {\n    widget_set_text(widget, other->text.str);\n  }\n\n  if (other->tr_text != NULL) {\n    widget_set_tr_text(widget, other->tr_text);\n  }\n\n  widget->enable = other->enable;\n  widget->visible = other->visible;\n  widget->floating = other->floating;\n  widget->opacity = other->opacity;\n  widget->feedback = other->feedback;\n  widget->auto_adjust_size = other->auto_adjust_size;\n  widget->focusable = other->focusable;\n  widget->sensitive = other->sensitive;\n  widget->auto_created = other->auto_created;\n  widget->with_focus_state = other->with_focus_state;\n  widget->dirty_rect_tolerance = other->dirty_rect_tolerance;\n\n  if (other->animation != NULL && *(other->animation)) {\n    widget_set_animation(widget, other->animation);\n  }\n\n  if (other->self_layout != NULL) {\n    widget->self_layout = self_layouter_clone(other->self_layout);\n  }\n\n  if (other->children_layout != NULL) {\n    widget->children_layout = children_layouter_clone(other->children_layout);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_copy(widget_t* widget, widget_t* other) {\n  return_value_if_fail(widget != NULL && other != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt == other->vt, RET_BAD_PARAMS);\n\n  widget_copy_style(widget, other);\n  widget_copy_base_props(widget, other);\n\n  if (other->custom_props) {\n    widget->custom_props = object_default_clone(OBJECT_DEFAULT(other->custom_props));\n  }\n\n  if (widget->vt->on_copy != NULL) {\n    widget->vt->on_copy(widget, other);\n  } else {\n    widget_on_copy_default(widget, other);\n  }\n\n  widget_set_need_update_style(widget);\n\n  return RET_OK;\n}\n\nwidget_t* widget_clone(widget_t* widget, widget_t* parent) {\n  widget_t* clone = NULL;\n  return_value_if_fail(widget != NULL && widget->vt != NULL && widget->vt->create != NULL, NULL);\n\n  clone = widget->vt->create(parent, widget->x, widget->y, widget->w, widget->h);\n  return_value_if_fail(clone != NULL, NULL);\n\n  widget_copy(clone, widget);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_clone(iter, clone);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return clone;\n}\n\n#define PROP_EQ(prop) (widget->prop == other->prop)\nbool_t widget_equal(widget_t* widget, widget_t* other) {\n  bool_t ret = FALSE;\n  const char* const* properties = NULL;\n  return_value_if_fail(widget != NULL && other != NULL, FALSE);\n\n  ret = PROP_EQ(opacity) && PROP_EQ(enable) && PROP_EQ(visible) && PROP_EQ(vt) && PROP_EQ(x) &&\n        PROP_EQ(y) && PROP_EQ(w) && PROP_EQ(h) && PROP_EQ(floating);\n  if (widget->name != NULL || other->name != NULL) {\n    ret = ret && (tk_str_eq(widget->name, other->name) || PROP_EQ(name));\n  }\n\n  if (widget->style != NULL || other->style != NULL) {\n    ret = ret && tk_str_eq(widget->style, other->style);\n  }\n\n  if (!ret) {\n    return ret;\n  }\n\n  ret = ret && wstr_equal(&(widget->text), &(other->text));\n\n  if (widget->tr_text != NULL || other->tr_text != NULL) {\n    ret = ret && (tk_str_eq(widget->tr_text, other->tr_text) || PROP_EQ(tr_text));\n  }\n\n  if (!ret) {\n    return ret;\n  }\n\n  properties = widget->vt->clone_properties;\n  if (properties != NULL) {\n    value_t v1;\n    value_t v2;\n    uint32_t i = 0;\n    for (i = 0; properties[i] != NULL; i++) {\n      const char* prop = properties[i];\n      if (widget_get_prop(widget, prop, &v1) != RET_OK) {\n        continue;\n      }\n\n      if (widget_get_prop(other, prop, &v2) != RET_OK) {\n        return FALSE;\n      }\n\n      if (!value_equal(&v1, &v2)) {\n        log_debug(\"prop %s not equal\\n\", prop);\n        return FALSE;\n      }\n    }\n  }\n\n  if (widget->children_layout != other->children_layout) {\n    const char* str1 = children_layouter_to_string(widget->children_layout);\n    const char* str2 = children_layouter_to_string(other->children_layout);\n    if (!tk_str_eq(str1, str2)) {\n      return FALSE;\n    }\n  }\n\n  if (widget->self_layout != other->self_layout) {\n    const char* str1 = self_layouter_to_string(widget->self_layout);\n    const char* str2 = self_layouter_to_string(other->self_layout);\n    if (!tk_str_eq(str1, str2)) {\n      return FALSE;\n    }\n  }\n\n  if (!ret) {\n    return ret;\n  }\n\n  if (widget->children == other->children) {\n    return TRUE;\n  }\n\n  if (widget->children == NULL || other->children == NULL) {\n    return FALSE;\n  }\n\n  if (widget->children->size != other->children->size) {\n    return FALSE;\n  }\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_t* iter_other = WIDGET(other->children->elms[i]);\n  if (!widget_equal(iter, iter_other)) {\n    return FALSE;\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return TRUE;\n}\n\nfloat_t widget_measure_text(widget_t* widget, const wchar_t* text) {\n  canvas_t* c = widget_get_canvas(widget);\n  return_value_if_fail(widget != NULL && text != NULL && c != NULL, 0);\n\n  widget_prepare_text_style(widget, c);\n\n  return canvas_measure_text(c, (wchar_t*)text, wcslen(text));\n}\n\nret_t widget_load_image(widget_t* widget, const char* name, bitmap_t* bitmap) {\n  image_manager_t* imm = widget_get_image_manager(widget);\n\n  return_value_if_fail(imm != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget != NULL && name != NULL && bitmap != NULL, RET_BAD_PARAMS);\n\n  return image_manager_get_bitmap(imm, name, bitmap);\n}\n\nret_t widget_unload_image(widget_t* widget, bitmap_t* bitmap) {\n  image_manager_t* imm = widget_get_image_manager(widget);\n\n  return_value_if_fail(imm != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget != NULL && bitmap != NULL, RET_BAD_PARAMS);\n\n  return image_manager_unload_bitmap(imm, bitmap);\n}\n\nconst asset_info_t* widget_load_asset(widget_t* widget, asset_type_t type, const char* name) {\n  return widget_load_asset_ex(widget, type, 0, name);\n}\n\nconst asset_info_t* widget_load_asset_ex(widget_t* widget, asset_type_t type, uint16_t subtype,\n                                         const char* name) {\n  assets_manager_t* am = widget_get_assets_manager(widget);\n  return_value_if_fail(widget != NULL && name != NULL && am != NULL, NULL);\n\n  return assets_manager_ref_ex(am, type, subtype, name);\n}\n\nret_t widget_unload_asset(widget_t* widget, const asset_info_t* asset) {\n  assets_manager_t* am = widget_get_assets_manager(widget);\n  return_value_if_fail(widget != NULL && asset != NULL && am != NULL, RET_BAD_PARAMS);\n\n  return assets_manager_unref(am, asset);\n}\n\nbool_t widget_is_point_in(widget_t* widget, xy_t x, xy_t y, bool_t is_local) {\n  point_t p = {x, y};\n  return_value_if_fail(widget != NULL, FALSE);\n\n  if (!is_local) {\n    widget_to_local(widget, &p);\n  }\n\n  if (widget->vt->is_point_in != NULL) {\n    return widget->vt->is_point_in(widget, p.x, p.y);\n  } else {\n    return (p.x >= 0 && p.y >= 0 && p.x < widget->w && p.y < widget->h);\n  }\n}\n\nconst char* widget_get_type(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, NULL);\n\n  return widget_get_prop_str(widget, WIDGET_PROP_TYPE, NULL);\n}\n\nwidget_t* widget_cast(widget_t* widget) {\n  return widget;\n}\n\nbool_t widget_is_instance_of(widget_t* widget, const widget_vtable_t* vt) {\n  const widget_vtable_t* iter = NULL;\n  return_value_if_fail(widget != NULL && vt != NULL, FALSE);\n\n  iter = widget->vt;\n  while (iter != NULL) {\n    if (iter == vt) {\n      return TRUE;\n    }\n\n    iter = iter->parent;\n  }\n#ifdef WITH_WIDGET_TYPE_CHECK\n  if (vt == widget_vtable_default()) {\n    return TRUE;\n  } else {\n    return FALSE;\n  }\n#else\n  return TRUE;\n#endif /*WITH_WIDGET_TYPE_CHECK*/\n}\n\nstatic ret_t widget_ensure_visible_in_scroll_view(widget_t* scroll_view, widget_t* widget) {\n  rect_t r;\n  point_t p;\n  int32_t ox = 0;\n  int32_t oy = 0;\n  int32_t old_ox = 0;\n  int32_t old_oy = 0;\n  return_value_if_fail(widget != NULL && scroll_view != NULL, RET_BAD_PARAMS);\n\n  memset(&p, 0x0, sizeof(point_t));\n  widget_to_screen_ex(widget, scroll_view, &p);\n  r = rect_init(p.x, p.y, widget->w, widget->h);\n\n  ox = widget_get_prop_int(scroll_view, WIDGET_PROP_XOFFSET, 0);\n  oy = widget_get_prop_int(scroll_view, WIDGET_PROP_YOFFSET, 0);\n  old_ox = ox;\n  old_oy = oy;\n\n  if (oy > r.y) {\n    oy = r.y;\n  }\n\n  if (ox > r.x) {\n    ox = r.x;\n  }\n\n  if ((r.y + r.h) > (oy + scroll_view->h)) {\n    oy = r.y + r.h - scroll_view->h;\n  }\n\n  if ((r.x + r.w) > (ox + scroll_view->w)) {\n    ox = r.x + r.w - scroll_view->w;\n  }\n\n  if (ox != old_ox) {\n    widget_set_prop_int(scroll_view, WIDGET_PROP_XOFFSET, ox);\n  }\n\n  if (oy != old_oy) {\n    widget_set_prop_int(scroll_view, WIDGET_PROP_YOFFSET, oy);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_ensure_visible_in_viewport(widget_t* widget) {\n  widget_t* parent = NULL;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  parent = widget->parent;\n  while (parent != NULL) {\n    if (widget_is_scrollable(parent)) {\n      widget_ensure_visible_in_scroll_view(parent, widget);\n      break;\n    }\n\n    parent = parent->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_as_key_target(widget_t* widget) {\n  if (widget_is_keyboard(widget)) {\n    return RET_OK;\n  }\n\n  if (widget != NULL) {\n    widget_t* parent = widget->parent;\n\n    if (parent != NULL) {\n      if (!(parent->focused)) {\n        parent->focused = TRUE;\n        event_t e = event_init(EVT_FOCUS, NULL);\n        widget_dispatch(parent, &e);\n        widget_set_need_update_style(parent);\n      }\n\n      if (parent->key_target != NULL && parent->key_target != widget) {\n        widget_set_focused_internal(widget->parent->key_target, FALSE);\n      }\n\n      if (parent->key_target != widget) {\n        parent->key_target = widget;\n      }\n      widget_set_as_key_target(parent);\n      if (!widget->focused) {\n        widget_set_need_update_style(widget);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nbool_t widget_is_keyboard(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  if (widget->vt->is_keyboard) {\n    return TRUE;\n  }\n\n  if (widget_get_prop(widget, WIDGET_PROP_IS_KEYBOARD, &v) == RET_OK) {\n    return value_bool(&v);\n  }\n\n  return FALSE;\n}\n\nstatic ret_t widget_on_visit_focusable(void* ctx, const void* data) {\n  widget_t* widget = WIDGET(data);\n  darray_t* all_focusable = (darray_t*)ctx;\n\n  if (!(widget->sensitive) || !(widget->visible) || !(widget->enable)) {\n    return RET_SKIP;\n  }\n\n  if (widget->vt->only_active_child_visible) {\n    widget_t* child = widget_find_target(widget, 1, 1);\n    widget_foreach(child, widget_on_visit_focusable, all_focusable);\n\n    return RET_SKIP;\n  }\n\n  if (widget_is_focusable(widget)) {\n    darray_push(all_focusable, widget);\n  }\n\n  if (widget->vt->disallow_children_focusable) {\n    return RET_SKIP;\n  }\n  return RET_OK;\n}\n\nstatic ret_t widget_get_all_focusable_widgets_in_window(widget_t* widget, darray_t* all_focusable) {\n  widget_t* win = widget_get_window_or_keyboard(widget);\n  return_value_if_fail(win != NULL, RET_BAD_PARAMS);\n\n  widget_foreach(win, widget_on_visit_focusable, all_focusable);\n\n  return RET_OK;\n}\n\nstatic widget_t* widget_get_first_focusable_widget_in_window(widget_t* widget) {\n  widget_t* first = NULL;\n  darray_t all_focusable;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(win != NULL, first);\n\n  darray_init(&all_focusable, 10, NULL, NULL);\n  widget_foreach(win, widget_on_visit_focusable, &all_focusable);\n  if (all_focusable.size > 0) {\n    first = WIDGET(all_focusable.elms[0]);\n  }\n  darray_deinit(&all_focusable);\n\n  return first;\n}\n\nbool_t widget_has_focused_widget_in_window(widget_t* widget) {\n  widget_t* iter = NULL;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(win != NULL, FALSE);\n\n  iter = win->key_target;\n  while (iter != NULL) {\n    if (widget_is_focusable(iter) && iter->focused) {\n      return TRUE;\n    }\n\n    iter = iter->key_target;\n  }\n\n  return FALSE;\n}\n\nret_t widget_focus_first(widget_t* widget) {\n  widget_t* first = widget_get_first_focusable_widget_in_window(widget);\n\n  if (first != NULL) {\n    widget_set_prop_bool(first, WIDGET_PROP_FOCUSED, TRUE);\n  }\n\n  return RET_OK;\n}\n\nstatic widget_t* widget_find_prev_focus_widget(widget_t* widget, darray_t* all_focusable) {\n  uint32_t i = 0;\n  for (i = 0; i < all_focusable->size; i++) {\n    widget_t* iter = WIDGET(all_focusable->elms[i]);\n\n    if (iter == widget) {\n      uint32_t focus = (i == 0) ? (all_focusable->size - 1) : (i - 1);\n\n      return WIDGET(all_focusable->elms[focus]);\n    }\n  }\n\n  return NULL;\n}\n\nstatic widget_t* widget_find_next_focus_widget(widget_t* widget, darray_t* all_focusable) {\n  uint32_t i = 0;\n  for (i = 0; i < all_focusable->size; i++) {\n    widget_t* iter = WIDGET(all_focusable->elms[i]);\n\n    if (iter == widget) {\n      uint32_t focus = ((i + 1) == all_focusable->size) ? (0) : (i + 1);\n\n      return WIDGET(all_focusable->elms[focus]);\n    }\n  }\n\n  return NULL;\n}\n\nstatic bool_t is_same_row(const rect_t* r1, const rect_t* r2) {\n  int32_t cy1 = r1->y + r1->h / 2;\n  int32_t cy2 = r2->y + r2->h / 2;\n\n  return (cy2 >= r1->y && cy2 < (r1->y + r1->h)) || (cy1 >= r2->y && cy1 < (r2->y + r2->h));\n}\n\nstatic bool_t is_same_col(const rect_t* r1, const rect_t* r2) {\n  int32_t cx1 = r1->x + r1->w / 2;\n  int32_t cx2 = r2->x + r2->w / 2;\n\n  return (cx2 >= r1->x && cx2 < (r1->x + r1->w)) || (cx1 >= r2->x && cx1 < (r2->x + r2->w));\n}\n\nstatic uint32_t distance2(const rect_t* r1, const rect_t* r2) {\n  uint32_t dx = (r1->x + r1->w / 2) - (r2->x + r2->w / 2);\n  uint32_t dy = (r1->y + r1->h / 2) - (r2->y + r2->h / 2);\n\n  return dx * dx + dy * dy;\n}\n\nstatic bool_t match_up(const rect_t* widget, const rect_t* last_matched, const rect_t* iter) {\n  if ((iter->y + iter->h / 2) > widget->y) {\n    return FALSE;\n  }\n\n  if (last_matched == NULL) {\n    return TRUE;\n  }\n\n  if (is_same_col(widget, iter)) {\n    if (!is_same_col(widget, last_matched)) {\n      return TRUE;\n    } else {\n      return (iter->y + iter->h) > (last_matched->y + last_matched->h);\n    }\n  } else if (is_same_col(widget, last_matched)) {\n    return FALSE;\n  } else {\n    return distance2(widget, iter) < distance2(widget, last_matched);\n  }\n}\n\nstatic bool_t match_down(const rect_t* widget, const rect_t* last_matched, const rect_t* iter) {\n  if ((iter->y + iter->h / 2) < (widget->y + widget->h)) {\n    return FALSE;\n  }\n\n  if (last_matched == NULL) {\n    return TRUE;\n  }\n\n  if (is_same_col(widget, iter)) {\n    if (!is_same_col(widget, last_matched)) {\n      return TRUE;\n    } else {\n      return iter->y < last_matched->y;\n    }\n  } else if (is_same_col(widget, last_matched)) {\n    return FALSE;\n  } else {\n    return distance2(widget, iter) < distance2(widget, last_matched);\n  }\n}\n\nstatic bool_t match_left(const rect_t* widget, const rect_t* last_matched, const rect_t* iter) {\n  if ((iter->x + iter->w / 2) > widget->x) {\n    return FALSE;\n  }\n\n  if (last_matched == NULL) {\n    return TRUE;\n  }\n\n  if (is_same_row(widget, iter)) {\n    if (!is_same_row(widget, last_matched)) {\n      return TRUE;\n    } else {\n      return (iter->x + iter->w) > (last_matched->x + last_matched->w);\n    }\n  } else if (is_same_row(widget, last_matched)) {\n    return FALSE;\n  } else {\n    return distance2(widget, iter) < distance2(widget, last_matched);\n  }\n}\n\nstatic bool_t match_right(const rect_t* widget, const rect_t* last_matched, const rect_t* iter) {\n  if ((iter->x + iter->w / 2) < (widget->x + widget->w)) {\n    return FALSE;\n  }\n\n  if (last_matched == NULL) {\n    return TRUE;\n  }\n\n  if (is_same_row(widget, iter)) {\n    if (!is_same_row(widget, last_matched)) {\n      return TRUE;\n    } else {\n      return iter->x < last_matched->x;\n    }\n  } else if (is_same_row(widget, last_matched)) {\n    return FALSE;\n  } else {\n    return distance2(widget, iter) < distance2(widget, last_matched);\n  }\n}\n\ntypedef bool_t (*match_focus_widget_t)(const rect_t* widget, const rect_t* last_matched,\n                                       const rect_t* iter);\n\nstatic widget_t* widget_find_matched_focus_widget(widget_t* widget, darray_t* all_focusable,\n                                                  match_focus_widget_t match) {\n  uint32_t i = 0;\n  point_t p = {0, 0};\n  widget_t* matched = NULL;\n  rect_t riter = {0, 0, 0, 0};\n  rect_t rwidget = {0, 0, 0, 0};\n  rect_t rmatched = {0, 0, 0, 0};\n\n  widget_to_global(widget, &p);\n  rwidget = rect_init(p.x, p.y, widget->w, widget->h);\n\n  for (i = 0; i < all_focusable->size; i++) {\n    widget_t* iter = WIDGET(all_focusable->elms[i]);\n    if (iter == widget) {\n      continue;\n    }\n\n    p.x = 0;\n    p.y = 0;\n    widget_to_global(iter, &p);\n\n    riter = rect_init(p.x, p.y, iter->w, iter->h);\n    if (match(&rwidget, (matched != NULL ? &rmatched : NULL), &riter)) {\n      matched = iter;\n      rmatched = riter;\n    }\n  }\n\n  return matched;\n}\n\nstatic widget_t* widget_find_up_focus_widget(widget_t* widget, darray_t* all_focusable) {\n  return widget_find_matched_focus_widget(widget, all_focusable, match_up);\n}\n\nstatic widget_t* widget_find_down_focus_widget(widget_t* widget, darray_t* all_focusable) {\n  return widget_find_matched_focus_widget(widget, all_focusable, match_down);\n}\n\nstatic widget_t* widget_find_left_focus_widget(widget_t* widget, darray_t* all_focusable) {\n  return widget_find_matched_focus_widget(widget, all_focusable, match_left);\n}\n\nstatic widget_t* widget_find_right_focus_widget(widget_t* widget, darray_t* all_focusable) {\n  return widget_find_matched_focus_widget(widget, all_focusable, match_right);\n}\n\nret_t widget_move_focus(widget_t* widget, widget_find_wanted_focus_widget_t find) {\n  ret_t ret = RET_FAIL;\n  darray_t all_focusable;\n\n  if (widget == NULL || !widget->focused) {\n    return RET_FAIL;\n  }\n\n  return_value_if_fail(find != NULL, RET_FAIL);\n  return_value_if_fail(darray_init(&all_focusable, 10, NULL, NULL) != NULL, RET_OOM);\n\n  widget_get_all_focusable_widgets_in_window(widget, &all_focusable);\n  if (all_focusable.size > 1) {\n    widget_t* focus = find(widget, &all_focusable);\n\n    if (focus != NULL && focus != widget) {\n      widget_set_prop_bool(widget, WIDGET_PROP_FOCUSED, FALSE);\n      widget_set_prop_bool(focus, WIDGET_PROP_FOCUSED, TRUE);\n      ret = RET_OK;\n    }\n  }\n  darray_deinit(&all_focusable);\n\n  return ret;\n}\n\nret_t widget_focus_prev(widget_t* widget) {\n  return widget_move_focus(widget, widget_find_prev_focus_widget);\n}\n\nret_t widget_focus_next(widget_t* widget) {\n  return widget_move_focus(widget, widget_find_next_focus_widget);\n}\n\nret_t widget_focus_up(widget_t* widget) {\n  return widget_move_focus(widget, widget_find_up_focus_widget);\n}\n\nret_t widget_focus_down(widget_t* widget) {\n  return widget_move_focus(widget, widget_find_down_focus_widget);\n}\n\nret_t widget_focus_left(widget_t* widget) {\n  if (widget_move_focus(widget, widget_find_left_focus_widget) == RET_OK) {\n    return RET_OK;\n  } else {\n    return widget_focus_up(widget);\n  }\n}\n\nret_t widget_focus_right(widget_t* widget) {\n  if (widget_move_focus(widget, widget_find_right_focus_widget) == RET_OK) {\n    return RET_OK;\n  } else {\n    return widget_focus_down(widget);\n  }\n}\n\nbool_t widget_is_window(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  return widget->vt->is_window;\n}\n\nbool_t widget_is_designing_window(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  return widget->vt->is_designing_window;\n}\n\nbool_t widget_is_window_manager(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  return widget->vt->is_window_manager;\n}\n\nret_t widget_set_need_relayout(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n  if (win != NULL) {\n    return window_base_set_need_relayout(win, TRUE);\n  }\n  return RET_OK;\n}\n\nret_t widget_set_need_relayout_children(widget_t* widget) {\n  if (widget_count_children(widget) > 0) {\n    return widget_set_need_relayout(widget);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_ensure_style_mutable(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->astyle == NULL) {\n    widget->astyle = style_mutable_create(NULL);\n    return_value_if_fail(widget->astyle != NULL, RET_OOM);\n  } else if (!style_is_mutable(widget->astyle)) {\nwidget->astyle = ",
    "raw_res": "style_mutable_clone(widget->astyle);",
    "prompt_res": "style_mutable_create(widget->astyle);",
    "gt": "style_mutable_create(widget->astyle);"
  },
  {
    "id": 2511,
    "pkg": "YPS-Instrument3",
    "fpath": "3rd/awtk/3036/src/base/widget.c",
    "input": "﻿/**\n * File:   widget.c\n * Author: AWTK Develop Team\n * Brief:  basic class of all widget\n *\n * Copyright (c) 2018 - 2022  Guangzhou ZHIYUAN Electronics Co.,Ltd.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * License file for more details.\n *\n */\n\n/**\n * History:\n * ================================================================\n * 2018-01-13 Li XianJing <xianjimli@hotmail.com> created\n *\n */\n\n#include \"tkc/mem.h\"\n#include \"tkc/utf8.h\"\n#include \"tkc/utils.h\"\n#include \"tkc/fscript.h\"\n#include \"tkc/tokenizer.h\"\n#include \"tkc/color_parser.h\"\n#include \"tkc/object_default.h\"\n\n#include \"base/keys.h\"\n#include \"base/enums.h\"\n#include \"base/theme.h\"\n#include \"tkc/time_now.h\"\n#include \"base/idle.h\"\n#include \"base/widget.h\"\n#include \"base/layout.h\"\n#include \"native_window.h\"\n#include \"base/main_loop.h\"\n#include \"base/ui_feedback.h\"\n#include \"base/system_info.h\"\n#include \"base/window_manager.h\"\n#include \"base/widget_vtable.h\"\n#include \"base/style_mutable.h\"\n#include \"base/style_factory.h\"\n#include \"base/widget_animator_manager.h\"\n#include \"base/widget_animator_factory.h\"\n#include \"base/window_base.h\"\n#include \"blend/image_g2d.h\"\n\nret_t widget_focus_up(widget_t* widget);\nret_t widget_focus_down(widget_t* widget);\nret_t widget_focus_left(widget_t* widget);\nret_t widget_focus_right(widget_t* widget);\nstatic ret_t widget_unref_async(widget_t* widget);\nstatic ret_t widget_ensure_style_mutable(widget_t* widget);\nstatic ret_t widget_dispatch_blur_event(widget_t* widget);\n/*虚函数的包装*/\nstatic ret_t widget_on_paint_done(widget_t* widget, canvas_t* c);\nstatic ret_t widget_on_paint_begin(widget_t* widget, canvas_t* c);\nstatic ret_t widget_on_paint_end(widget_t* widget, canvas_t* c);\n\ntypedef widget_t* (*widget_find_wanted_focus_widget_t)(widget_t* widget, darray_t* all_focusable);\nstatic ret_t widget_move_focus(widget_t* widget, widget_find_wanted_focus_widget_t find);\n\n#define widget_set_xywh(widget, val, update_layout, invalidate)    \\\n  do {                                                             \\\n    if (widget->val != val) {                                      \\\n      if (invalidate) widget_invalidate_force(widget, NULL);       \\\n      widget->val = val;                                           \\\n      if (invalidate) widget_invalidate_force(widget, NULL);       \\\n    }                                                              \\\n    if (update_layout && widget->self_layout != NULL) {            \\\n      self_layouter_set_param_str(widget->self_layout, #val, \"n\"); \\\n    }                                                              \\\n  } while (0)\n\nstatic ret_t widget_set_x(widget_t* widget, xy_t x, bool_t update_layout) {\n  widget_set_xywh(widget, x, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_y(widget_t* widget, xy_t y, bool_t update_layout) {\n  widget_set_xywh(widget, y, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_w(widget_t* widget, wh_t w, bool_t update_layout) {\n  widget_set_xywh(widget, w, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic ret_t widget_set_h(widget_t* widget, xy_t h, bool_t update_layout) {\n  widget_set_xywh(widget, h, update_layout, TRUE);\n  return RET_OK;\n}\n\nstatic bool_t widget_is_strongly_focus(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n  if (win != NULL) {\n    return WINDOW_BASE(win)->strongly_focus;\n  } else {\n    return FALSE;\n  }\n}\n\nret_t widget_set_need_update_style(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (!widget->need_update_style) {\n    widget_invalidate_force(widget, NULL);\n  }\n\n  widget->need_update_style = TRUE;\n\n  return RET_OK;\n}\n\nret_t widget_update_style_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_update_style(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_update_style_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_set_need_update_style_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_need_update_style(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_set_need_update_style_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_update_style(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->astyle != NULL, RET_BAD_PARAMS);\n\n  if (widget->need_update_style) {\n    widget->need_update_style = FALSE;\n    return style_notify_widget_state_changed(widget->astyle, widget);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_real_destroy(widget_t* widget) {\n  ENSURE(widget->ref_count == 1);\n\n  if (widget->vt->on_destroy) {\n    widget->vt->on_destroy(widget);\n  }\n\n  TKMEM_FREE(widget->name);\n  TKMEM_FREE(widget->state);\n  TKMEM_FREE(widget->style);\n  TKMEM_FREE(widget->tr_text);\n  TKMEM_FREE(widget->animation);\n  TKMEM_FREE(widget->pointer_cursor);\n  TK_OBJECT_UNREF(widget->custom_props);\n  wstr_reset(&(widget->text));\n  style_destroy(widget->astyle);\n\n  memset(widget, 0x00, sizeof(widget_t));\n  TKMEM_FREE(widget);\n\n  return RET_OK;\n}\n\nstatic widget_t* widget_real_create(const widget_vtable_t* vt) {\n  widget_t* widget = TKMEM_ALLOC(vt->size);\n  return_value_if_fail(widget != NULL, NULL);\n\n  memset(widget, 0x00, vt->size);\n  widget->vt = vt;\n\n  return widget;\n}\n\nstatic bool_t widget_is_scrollable(widget_t* widget) {\n  return widget != NULL && widget->vt != NULL && widget->vt->scrollable;\n}\n\nstatic bool_t widget_with_focus_state(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n  value_set_bool(&v, FALSE);\n  widget_get_prop(widget, WIDGET_PROP_WITH_FOCUS_STATE, &v);\n\n  return value_bool(&v);\n}\n\nbool_t widget_is_focusable(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  if (!widget->visible || !widget->sensitive || !widget->enable) {\n    return FALSE;\n  }\n\n  return widget->focusable || widget->vt->focusable;\n}\n\nret_t widget_move(widget_t* widget, xy_t x, xy_t y) {\n  event_t e = event_init(EVT_WILL_MOVE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->x != x || widget->y != y) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, x, TRUE, FALSE);\n    widget_set_xywh(widget, y, TRUE, FALSE);\n    widget_invalidate_force(widget, NULL);\n\n    e.type = EVT_MOVE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_to_center(widget_t* widget) {\n  int32_t x = 0;\n  int32_t y = 0;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, RET_BAD_PARAMS);\n\n  x = (widget->parent->w - widget->w) / 2;\n  y = (widget->parent->h - widget->h) / 2;\n\n  return widget_move(widget, x, y);\n}\n\nret_t widget_resize(widget_t* widget, wh_t w, wh_t h) {\n  event_t e = event_init(EVT_WILL_RESIZE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->w != w || widget->h != h) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, w, TRUE, FALSE);\n    widget_set_xywh(widget, h, TRUE, FALSE);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget);\n\n    e.type = EVT_RESIZE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_resize_ex(widget_t* widget, xy_t x, xy_t y, wh_t w, wh_t h,\n                            bool_t update_layout) {\n  event_t e = event_init(EVT_WILL_MOVE_RESIZE, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->x != x || widget->y != y || widget->w != w || widget->h != h) {\n    widget_dispatch(widget, &e);\n\n    widget_invalidate_force(widget, NULL);\n    widget_set_xywh(widget, x, update_layout, FALSE);\n    widget_set_xywh(widget, y, update_layout, FALSE);\n    widget_set_xywh(widget, w, update_layout, FALSE);\n    widget_set_xywh(widget, h, update_layout, FALSE);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget);\n\n    e.type = EVT_MOVE_RESIZE;\n    widget_dispatch(widget, &e);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_move_resize(widget_t* widget, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return widget_move_resize_ex(widget, x, y, w, h, TRUE);\n}\n\nfloat_t widget_get_value(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_VALUE, &v) == RET_OK ? value_float32(&v) : 0.0f;\n}\n\nret_t widget_set_value(widget_t* widget, float_t value) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_VALUE, value_set_float32(&v, value));\n}\n\nret_t widget_add_value(widget_t* widget, float_t delta) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_value(widget, widget_get_value(widget) + delta);\n}\n\nint32_t widget_get_value_int(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_VALUE, &v) == RET_OK ? value_int(&v) : 0;\n}\n\nret_t widget_set_value_int(widget_t* widget, int32_t value) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_VALUE, value_set_int(&v, value));\n}\n\nret_t widget_add_value_int(widget_t* widget, int32_t delta) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_value_int(widget, widget_get_value_int(widget) + delta);\n}\n\nstatic ret_t widget_animate_prop_float_to(widget_t* widget, const char* name, float_t value,\n                                          uint32_t duration) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL, RET_BAD_PARAMS);\n  if (duration == 0) {\n    ret = widget_set_prop_float(widget, name, value);\n  } else {\n    float_t prev_value = widget_get_prop_float(widget, name, 0.0f);\n    widget_destroy_animator(widget, name);\n\n    if (prev_value != value) {\n      char params[128] = {0};\n      tk_snprintf(params, sizeof(params) - 1, \"%s(from=%f,to=%f,duration=%d)\", name, prev_value,\n                  value, duration);\n      ret = widget_create_animator(widget, params);\n    }\n  }\n  return ret;\n}\n\nret_t widget_animate_value_to(widget_t* widget, float_t value, uint32_t duration) {\n  return widget_animate_prop_float_to(widget, WIDGET_PROP_VALUE, value, duration);\n}\n\nbool_t widget_is_window_opened(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n    return WINDOW_STAGE_OPENED == stage || WINDOW_STAGE_SUSPEND == stage;\n  } else {\n    return FALSE;\n  }\n}\n\nbool_t widget_is_window_created(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n    return WINDOW_STAGE_OPENED == stage || WINDOW_STAGE_SUSPEND == stage ||\n           WINDOW_STAGE_LOADED == stage || WINDOW_STAGE_CREATED == stage;\n  } else {\n    return FALSE;\n  }\n}\n\nret_t widget_get_window_theme(widget_t* widget, theme_t** win_theme, theme_t** default_theme) {\n  value_t v;\n  widget_t* win = widget_get_window(widget);\n\n  if (win != NULL) {\n    if (widget_get_prop(win, WIDGET_PROP_THEME_OBJ, &v) == RET_OK) {\n      *win_theme = (theme_t*)value_pointer(&v);\n    }\n\n    if (widget_get_prop(win, WIDGET_PROP_DEFAULT_THEME_OBJ, &v) == RET_OK) {\n      *default_theme = (theme_t*)value_pointer(&v);\n    }\n  }\n  return RET_OK;\n}\n\nbool_t widget_is_style_exist(widget_t* widget, const char* style_name, const char* state_name) {\n  const void* data = NULL;\n  const char* style = NULL;\n  const char* state = NULL;\n  theme_t* win_theme = NULL;\n  theme_t* default_theme = NULL;\n  const char* type = widget_get_type(widget);\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(widget != NULL && win != NULL, FALSE);\n\n  if (style_name == NULL || *style_name == 0) {\n    style = TK_DEFAULT_STYLE;\n  } else {\n    style = style_name;\n  }\n\n  if (state_name == NULL || *state_name == 0) {\n    state = WIDGET_STATE_NORMAL;\n  } else {\n    state = state_name;\n  }\n\n  return_value_if_fail(widget_get_window_theme(widget, &win_theme, &default_theme) == RET_OK,\n                       FALSE);\n\n  if (win_theme != NULL) {\n    data = theme_find_style(win_theme, type, style, state);\n  }\n\n  if (data == NULL && default_theme != NULL) {\n    data = theme_find_style(default_theme, type, style, state);\n  }\n\n  return data != NULL;\n}\n\nret_t widget_use_style(widget_t* widget, const char* value) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_need_update_style(widget);\n  widget->style = tk_str_copy(widget->style, value);\n\n  if (widget_is_window_opened(widget)) {\n    widget_update_style(widget);\n    return widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_text(widget_t* widget, const wchar_t* text) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_wstr(&v, text));\n}\n\nret_t widget_set_text_utf8(widget_t* widget, const char* text) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_str(&v, text));\n}\n\nret_t widget_get_text_utf8(widget_t* widget, char* text, uint32_t size) {\n  value_t v;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && text != NULL && size > 0, RET_BAD_PARAMS);\n\n  value_set_str(&v, NULL);\n  memset(text, 0x00, size);\n  if (widget_get_prop(widget, WIDGET_PROP_TEXT, &v) == RET_OK) {\n    if (v.type == VALUE_TYPE_STRING) {\n      tk_strncpy(text, value_str(&v), size - 1);\n      ret = RET_OK;\n    } else if (v.type == VALUE_TYPE_WSTRING) {\n      tk_utf8_from_utf16(value_wstr(&v), text, size);\n      ret = RET_OK;\n    }\n  }\n\n  return ret;\n}\n\nimage_manager_t* widget_get_image_manager(widget_t* widget) {\n  image_manager_t* ret = image_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = image_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_IMAGE_MANAGER, &v) == RET_OK) {\n      ret = (image_manager_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nlocale_info_t* widget_get_locale_info(widget_t* widget) {\n  locale_info_t* ret = locale_info();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = locale_info();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_LOCALE_INFO, &v) == RET_OK) {\n      ret = (locale_info_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nassets_manager_t* widget_get_assets_manager(widget_t* widget) {\n  assets_manager_t* am = assets_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, am);\n\n  if (widget->assets_manager != NULL) {\n    return widget->assets_manager;\n  }\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    am = assets_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_ASSETS_MANAGER, &v) == RET_OK) {\n      am = (assets_manager_t*)value_pointer(&v);\n    }\n  }\n  widget->assets_manager = am;\n\n  return am;\n}\n\nfont_manager_t* widget_get_font_manager(widget_t* widget) {\n  font_manager_t* ret = font_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = font_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_FONT_MANAGER, &v) == RET_OK) {\n      ret = (font_manager_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_apply_tr_text_before_paint(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  if (widget->tr_text != NULL) {\n    const char* text = locale_info_tr(widget_get_locale_info(widget), widget->tr_text);\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n  }\n\n  return RET_REMOVE;\n}\n\nret_t widget_set_tr_text(widget_t* widget, const char* text) {\n  const char* tr_text = NULL;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(widget != NULL, RET_OK);\n\n  if (text == NULL || *text == '\\0') {\n    if (widget->tr_text != NULL) {\n      TKMEM_FREE(widget->tr_text);\n      widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n    }\n\n    return RET_OK;\n  }\n\n  widget->tr_text = tk_str_copy(widget->tr_text, text);\n  if (win != NULL) {\n    tr_text = locale_info_tr(widget_get_locale_info(widget), text);\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, tr_text);\n  } else {\n    widget_set_prop_str(widget, WIDGET_PROP_TEXT, text);\n    widget_on(widget, EVT_BEFORE_PAINT, widget_apply_tr_text_before_paint, widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_re_translate_text(widget_t* widget) {\n  if (widget->vt->on_re_translate != NULL) {\n    widget->vt->on_re_translate(widget);\n  }\n  if (widget->tr_text != NULL) {\n    value_t v;\n    const char* tr_text = locale_info_tr(widget_get_locale_info(widget), widget->tr_text);\n    widget_set_prop(widget, WIDGET_PROP_TEXT, value_set_str(&v, tr_text));\n    widget_invalidate(widget, NULL);\n  }\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_re_translate_text(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nconst wchar_t* widget_get_text(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget_get_prop(widget, WIDGET_PROP_TEXT, &v) == RET_OK ? value_wstr(&v) : 0;\n}\n\nret_t widget_set_name(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (name != NULL) {\n    widget->name = tk_str_copy(widget->name, name);\n  } else {\n    TKMEM_FREE(widget->name);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_theme(widget_t* widget, const char* name) {\n  theme_change_event_t will_event;\n  event_t* will_evt = theme_change_event_init(&will_event, EVT_THEME_WILL_CHANGE, name);\n  widget_dispatch(window_manager(), will_evt);\n#ifdef WITH_FS_RES\n  const asset_info_t* info = NULL;\n  theme_change_event_t event;\n  event_t* evt = theme_change_event_init(&event, EVT_THEME_CHANGED, name);\n  widget_t* wm = widget_get_window_manager(widget);\n  font_manager_t* fm = widget_get_font_manager(widget);\n  image_manager_t* imm = widget_get_image_manager(widget);\n  assets_manager_t* am = widget_get_assets_manager(widget);\n  locale_info_t* locale_info = widget_get_locale_info(widget);\n  return_value_if_fail(am != NULL && name != NULL, RET_BAD_PARAMS);\n\n  font_manager_unload_all(fm);\n  image_manager_unload_all(imm);\n  locale_info_reload(locale_info);\n  assets_manager_set_theme(am, name);\n  widget_reset_canvas(widget);\n\n  info = assets_manager_ref(am, ASSET_TYPE_STYLE, \"default\");\n  if (info != NULL) {\n    theme_set(theme_load_from_data(info->name, info->data, info->size));\n    assets_manager_unref(assets_manager(), info);\n  }\n\n  widget_dispatch(wm, evt);\n  widget_invalidate_force(wm, NULL);\n\n  log_debug(\"theme changed: %s\\n\", name);\n#endif\n\n  return RET_OK;\n}\n\nret_t widget_set_pointer_cursor(widget_t* widget, const char* cursor) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (!tk_str_eq(widget->pointer_cursor, cursor)) {\n    widget->pointer_cursor = tk_str_copy(widget->pointer_cursor, cursor);\n    widget_update_pointer_cursor(widget);\n  }\n\n  return RET_OK;\n}\n\n#ifndef WITHOUT_WIDGET_ANIMATORS\nret_t widget_set_animation(widget_t* widget, const char* animation) {\n  return_value_if_fail(widget != NULL && animation != NULL, RET_BAD_PARAMS);\n\n  widget->animation = tk_str_copy(widget->animation, animation);\n\n  return widget_create_animator(widget, animation);\n}\n\nret_t widget_create_animator(widget_t* widget, const char* animation) {\n  tokenizer_t t;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && animation != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(tokenizer_init(&t, animation, strlen(animation), \";\") != NULL, RET_OOM);\n\n  while (tokenizer_has_more(&t)) {\n    const char* params = tokenizer_next(&t);\n    if (widget_animator_create(widget, params) == NULL) {\n      ret = RET_BAD_PARAMS;\n      break;\n    }\n  }\n  tokenizer_deinit(&t);\n  widget_invalidate(widget, NULL);\n\n  return ret;\n}\n\nret_t widget_start_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_start(widget_animator_manager(), widget, name);\n}\n\nret_t widget_set_animator_time_scale(widget_t* widget, const char* name, float_t time_scale) {\n  return widget_animator_manager_set_time_scale(widget_animator_manager(), widget, name,\n                                                time_scale);\n}\n\nret_t widget_pause_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_pause(widget_animator_manager(), widget, name);\n}\n\nwidget_animator_t* widget_find_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_find(widget_animator_manager(), widget, name);\n}\n\nret_t widget_stop_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_stop(widget_animator_manager(), widget, name);\n}\n\nret_t widget_destroy_animator(widget_t* widget, const char* name) {\n  return widget_animator_manager_remove_all(widget_animator_manager(), widget, name);\n}\n#else\nret_t widget_start_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nret_t widget_create_animator(widget_t* widget, const char* animation) {\n  return RET_OK;\n}\nret_t widget_set_animation(widget_t* widget, const char* animation) {\n  return RET_OK;\n}\nret_t widget_set_animator_time_scale(widget_t* widget, const char* name, float_t time_scale) {\n  return RET_OK;\n}\nret_t widget_pause_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nwidget_animator_t* widget_find_animator(widget_t* widget, const char* name) {\n  return NULL;\n}\nret_t widget_stop_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\nret_t widget_destroy_animator(widget_t* widget, const char* name) {\n  return RET_OK;\n}\n#endif /*WITHOUT_WIDGET_ANIMATORS*/\n\nret_t widget_set_enable(widget_t* widget, bool_t enable) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->enable != enable) {\n    widget->enable = enable;\n    widget_set_need_update_style_recursive(widget);\n    widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_feedback(widget_t* widget, bool_t feedback) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->feedback = feedback;\n\n  return RET_OK;\n}\n\nret_t widget_set_auto_adjust_size(widget_t* widget, bool_t auto_adjust_size) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->auto_adjust_size = auto_adjust_size;\n  widget_set_need_relayout(widget);\n\n  return RET_OK;\n}\n\nret_t widget_set_floating(widget_t* widget, bool_t floating) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->floating = floating;\n\n  return RET_OK;\n}\n\nret_t widget_set_focused_internal(widget_t* widget, bool_t focused) {\n  widget_t* win = widget_get_window(widget);\n  int32_t stage = widget_get_prop_int(win, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (WINDOW_STAGE_SUSPEND == stage) {\n    log_debug(\"You can not set focus of a widget when window is in background\");\n    return RET_FAIL;\n  }\n\n  if (widget->focused != focused) {\n    widget->focused = focused;\n    widget_set_need_update_style(widget);\n\n    if (focused) {\n      event_t e = event_init(EVT_FOCUS, widget);\n      widget_set_as_key_target(widget);\n\n      widget_dispatch(widget, &e);\n    } else {\n      event_t e = event_init(EVT_BLUR, widget);\n      widget_dispatch(widget, &e);\n      widget_dispatch_blur_event(widget);\n    }\n\n    widget_invalidate(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_focused(widget_t* widget, bool_t focused) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_set_focused_internal(widget, focused);\n  if (focused) {\n    widget_ensure_visible_in_viewport(widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_focusable(widget_t* widget, bool_t focusable) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->focusable = focusable;\n\n  return RET_OK;\n}\n\nret_t widget_set_state(widget_t* widget, const char* state) {\n  return_value_if_fail(widget != NULL && state != NULL, RET_BAD_PARAMS);\n\n  if (!tk_str_eq(widget->state, state)) {\n    widget_invalidate_force(widget, NULL);\n    widget->state = tk_str_copy(widget->state, state);\n    widget_set_need_update_style(widget);\n    widget_invalidate_force(widget, NULL);\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_state_for_style(widget_t* widget, bool_t active, bool_t checked) {\n  const char* state = WIDGET_STATE_NORMAL;\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, state);\n\n  state = (const char*)(widget->state);\n\n  while (iter != NULL) {\n    if (!iter->enable) {\n      if (active) return WIDGET_STATE_DISABLE_OF_ACTIVE;\n      if (checked) return WIDGET_STATE_DISABLE_OF_CHECKED;\n      return WIDGET_STATE_DISABLE;\n    }\n    iter = iter->parent;\n  }\n\n  if (widget_is_focusable(widget) || widget_with_focus_state(widget)) {\n    if (widget->focused) {\n      if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n        state = WIDGET_STATE_FOCUSED;\n      }\n    } else {\n      if (tk_str_eq(state, WIDGET_STATE_FOCUSED)) {\n        state = WIDGET_STATE_NORMAL;\n      }\n    }\n  }\n\n  if (active) {\n    if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n      state = WIDGET_STATE_NORMAL_OF_ACTIVE;\n    } else if (tk_str_eq(state, WIDGET_STATE_PRESSED)) {\n      state = WIDGET_STATE_PRESSED_OF_ACTIVE;\n    } else if (tk_str_eq(state, WIDGET_STATE_OVER)) {\n      state = WIDGET_STATE_OVER_OF_ACTIVE;\n    } else if (widget_is_focusable(widget) && widget->focused) {\n      state = WIDGET_STATE_FOCUSED_OF_ACTIVE;\n    }\n  } else if (checked) {\n    if (tk_str_eq(state, WIDGET_STATE_NORMAL)) {\n      state = WIDGET_STATE_NORMAL_OF_CHECKED;\n    } else if (tk_str_eq(state, WIDGET_STATE_PRESSED)) {\n      state = WIDGET_STATE_PRESSED_OF_CHECKED;\n    } else if (tk_str_eq(state, WIDGET_STATE_OVER)) {\n      state = WIDGET_STATE_OVER_OF_CHECKED;\n    } else if (widget_is_focusable(widget) && widget->focused) {\n      state = WIDGET_STATE_FOCUSED_OF_CHECKED;\n    }\n  }\n\n  return state;\n}\n\nret_t widget_set_opacity(widget_t* widget, uint8_t opacity) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->opacity = opacity;\n  widget_invalidate(widget, NULL);\n\n  return RET_OK;\n}\n\nret_t widget_set_dirty_rect_tolerance(widget_t* widget, uint16_t dirty_rect_tolerance) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->dirty_rect_tolerance = dirty_rect_tolerance;\n  widget_invalidate(widget, NULL);\n\n  return RET_OK;\n}\n\nret_t widget_destroy_children(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->children != NULL) {\n    WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n\n    widget_remove_child_prepare(widget, iter);\n    widget_unref(iter);\n\n    widget->children->elms[i] = NULL;\n\n    WIDGET_FOR_EACH_CHILD_END();\n    widget->children->size = 0;\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_style_type(widget_t* widget) {\n  theme_t* win_theme = NULL;\n  theme_t* default_theme = NULL;\n  const char* style_type = THEME_DEFAULT_STYLE_TYPE;\n\n  if (widget_get_window_theme(widget, &win_theme, &default_theme) == RET_OK) {\n    theme_t* t = win_theme != NULL ? win_theme : (default_theme != NULL ? default_theme : theme());\n    if (t != NULL) {\n      style_type = theme_get_style_type(t);\n    }\n  }\n\n  return style_type;\n}\n\nstatic ret_t widget_update_style_object(widget_t* widget) {\n  const char* style_type = widget_get_style_type(widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  if (widget->astyle == NULL) {\n    widget->astyle = style_factory_create_style(style_factory(), style_type);\n    ENSURE(widget->astyle != NULL);\n\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  } else if (widget->astyle != NULL &&\n             !tk_str_eq(style_get_style_type(widget->astyle), style_type)) {\n    style_t* style = style_factory_create_style(style_factory(), style_type);\n    ENSURE(style != NULL);\n    if (style_is_mutable(widget->astyle)) {\n      style_mutable_set_default_style(widget->astyle, style);\n    } else {\n      style_destroy(widget->astyle);\n      widget->astyle = style;\n    }\n\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  }\n  return RET_OK;\n}\n\nstatic ret_t widget_update_style_object_recursive(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget_update_style_object(widget);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_update_style_object_recursive(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}\n\nret_t widget_add_child(widget_t* widget, widget_t* child) {\n  event_t e = event_init(EVT_WIDGET_ADD_CHILD, widget);\n  return_value_if_fail(widget != NULL && child != NULL && child->parent == NULL, RET_BAD_PARAMS);\n\n  child->parent = widget;\n\n  if (widget->children == NULL) {\n    widget->children = darray_create(4, NULL, NULL);\n  }\n\n  if (widget->vt->on_add_child) {\n    if (widget->vt->on_add_child(widget, child) == RET_OK) {\n      return RET_OK;\n    }\n  }\n\n  if (child->vt->on_attach_parent) {\n    child->vt->on_attach_parent(child, widget);\n  }\n\n  ENSURE(darray_push(widget->children, child) == RET_OK);\n\n  if (!widget_is_window_manager(widget)) {\n    widget_set_need_relayout_children(widget);\n  }\n\n  if (!(child->initializing) && widget_get_window(child) != NULL) {\n    widget_set_need_update_style_recursive(child);\n    widget_update_style_object_recursive(child);\n  }\n\n  widget_dispatch(widget, &e);\n\n  return RET_OK;\n}\n\nret_t widget_remove_child_prepare(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n\n  if (!widget_is_window_manager(widget)) {\n    widget_set_need_relayout_children(widget);\n  }\n\n  widget_invalidate_force(child, NULL);\n  if (widget->target == child) {\n    widget->target = NULL;\n  }\n\n  if (widget->grab_widget == child) {\n    widget->grab_widget = NULL;\n    widget->grab_widget_count = 0;\n  }\n\n  if (widget->key_target == child) {\n    widget_dispatch_blur_event(widget->key_target);\n    widget->key_target = NULL;\n  }\n\n  if (widget->vt->on_remove_child) {\n    if (widget->vt->on_remove_child(widget, child) == RET_OK) {\n      return RET_OK;\n    }\n  }\n\n  if (child->vt->on_detach_parent) {\n    child->vt->on_detach_parent(child, widget);\n  }\n  child->parent = NULL;\n\n  return RET_OK;\n}\n\nret_t widget_remove_child(widget_t* widget, widget_t* child) {\n  ret_t ret = RET_OK;\n  event_t e = event_init(EVT_WIDGET_REMOVE_CHILD, widget);\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n\n  widget_remove_child_prepare(widget, child);\n  ret = darray_remove(widget->children, child);\n\n  if (ret == RET_OK) {\n    widget_dispatch(widget, &e);\n  }\n\n  return ret;\n}\n\nret_t widget_insert_child(widget_t* widget, uint32_t index, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget_add_child(widget, child) == RET_OK, RET_FAIL);\n\n  return widget_restack(child, index);\n}\n\nret_t widget_restack(widget_t* widget, uint32_t index) {\n  uint32_t i = 0;\n  uint32_t nr = 0;\n  int32_t old_index = 0;\n  widget_t** children = NULL;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, RET_BAD_PARAMS);\n\n  old_index = widget_index_of(widget);\n  nr = widget_count_children(widget->parent);\n  return_value_if_fail(old_index >= 0 && nr > 0, RET_BAD_PARAMS);\n\n  if (index >= nr) {\n    index = nr - 1;\n  }\n\n  if (index == old_index || nr == 1) {\n    return RET_OK;\n  }\n\n  children = (widget_t**)(widget->parent->children->elms);\n  if (index < old_index) {\n    for (i = old_index; i > index; i--) {\n      children[i] = children[i - 1];\n    }\n  } else {\n    for (i = old_index; i < index; i++) {\n      children[i] = children[i + 1];\n    }\n  }\n  children[index] = widget;\n\n  return RET_OK;\n}\n\nstatic widget_t* widget_lookup_child(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL && name != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (iter->name != NULL && tk_str_eq(iter->name, name)) {\n    return iter;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return NULL;\n}\n\nwidget_t* widget_child(widget_t* widget, const char* path) {\n  return widget_lookup_child(widget, path);\n}\n\nwidget_t* widget_get_focused_widget(widget_t* widget) {\n  widget_t* iter = NULL;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(win != NULL, NULL);\n\n  iter = win->key_target;\n  for (iter = win->key_target; iter != NULL; iter = iter->key_target) {\n    if (iter->focusable && iter->focused) {\n      return iter;\n    }\n\n    if (iter->key_target == NULL) {\n      return iter;\n    }\n  }\n\n  return NULL;\n}\n\nstatic widget_t* widget_lookup_all(widget_t* widget, const char* name) {\n  return_value_if_fail(widget != NULL && name != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (iter->name != NULL && tk_str_eq(iter->name, name)) {\n    return iter;\n  } else {\n    iter = widget_lookup_all(iter, name);\n    if (iter != NULL) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nwidget_t* widget_lookup(widget_t* widget, const char* name, bool_t recursive) {\n  if (recursive) {\n    return widget_lookup_all(widget, name);\n  } else {\n    return widget_lookup_child(widget, name);\n  }\n}\n\nstatic widget_t* widget_lookup_by_type_child(widget_t* widget, const char* type) {\n  return_value_if_fail(widget != NULL && type != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (tk_str_eq(iter->vt->type, type)) {\n    return iter;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return NULL;\n}\n\nstatic widget_t* widget_lookup_by_type_all(widget_t* widget, const char* type) {\n  return_value_if_fail(widget != NULL && type != NULL, NULL);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (tk_str_eq(iter->vt->type, type)) {\n    return iter;\n  } else {\n    iter = widget_lookup_by_type_all(iter, type);\n    if (iter != NULL) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nwidget_t* widget_lookup_by_type(widget_t* widget, const char* type, bool_t recursive) {\n  if (recursive) {\n    return widget_lookup_by_type_all(widget, type);\n  } else {\n    return widget_lookup_by_type_child(widget, type);\n  }\n}\n\nstatic ret_t widget_set_visible_self(widget_t* widget, bool_t visible) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->visible != visible) {\n    widget_invalidate_force(widget, NULL);\n    widget->visible = visible;\n    widget_set_need_update_style(widget);\n    widget_invalidate_force(widget, NULL);\n    widget_set_need_relayout_children(widget->parent);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_sensitive(widget_t* widget, bool_t sensitive) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->sensitive = sensitive;\n\n  return RET_OK;\n}\n\nret_t widget_set_visible_only(widget_t* widget, bool_t visible) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->visible = visible;\n\n  return RET_OK;\n}\n\nret_t widget_set_visible(widget_t* widget, bool_t visible, ...) {\n  return widget_set_visible_self(widget, visible);\n}\n\nwidget_t* widget_find_target(widget_t* widget, xy_t x, xy_t y) {\n  widget_t* ret = NULL;\n  return_value_if_fail(widget != NULL, NULL);\n\n  if (widget->vt && widget->vt->find_target) {\n    ret = widget->vt->find_target(widget, x, y);\n  } else {\n    ret = widget_find_target_default(widget, x, y);\n  }\n\n  return ret;\n}\n\nret_t widget_on_event_before_children(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt && widget->vt->on_event_before_children) {\n    ret = widget->vt->on_event_before_children(widget, e);\n  }\n\n  return ret;\n}\n\nstatic const char* widget_get_pointer_cursor(widget_t* widget) {\n  if (widget->pointer_cursor != NULL) {\n    return widget->pointer_cursor;\n  } else if (widget->vt->pointer_cursor != NULL) {\n    return widget->vt->pointer_cursor;\n  }\n\n  return WIDGET_CURSOR_DEFAULT;\n}\n\nret_t widget_update_pointer_cursor(widget_t* widget) {\n  widget_t* wm = widget_get_window_manager(widget);\n  return_value_if_fail(wm != NULL, RET_BAD_PARAMS);\n\n  return window_manager_set_cursor(wm, widget_get_pointer_cursor(widget));\n}\n\nret_t widget_dispatch(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  if (e->target == NULL) {\n    e->target = widget;\n  }\n\n  if (widget->vt && widget->vt->on_event) {\n    ret = widget->vt->on_event(widget, e);\n  } else {\n    ret = widget_on_event_default(widget, e);\n  }\n\n  if (ret != RET_STOP) {\n    if (widget->emitter != NULL) {\n      void* saved_target = e->target;\n\n      e->target = widget;\n      ret = emitter_dispatch(widget->emitter, e);\n      e->target = saved_target;\n    }\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t dispatch_in_idle(const idle_info_t* info) {\n  event_t* e = (event_t*)(info->ctx);\n  widget_t* widget = WIDGET(e->target);\n\n  widget_dispatch(widget, e);\n  widget_unref(widget);\n  event_destroy(e);\n\n  return RET_REMOVE;\n}\n\nret_t widget_dispatch_async(widget_t* widget, event_t* e) {\n  event_t* evt = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(e->target == widget, RET_BAD_PARAMS);\n\n  evt = event_clone(e);\n  return_value_if_fail(evt != NULL, RET_OOM);\n\n  widget_ref(widget);\n  idle_add(dispatch_in_idle, evt);\n\n  return RET_OK;\n}\n\nstatic ret_t widget_dispatch_callback(void* ctx, const void* data) {\n  widget_t* widget = WIDGET(data);\n\n  return widget_dispatch(widget, (event_t*)ctx);\n}\n\nret_t widget_dispatch_recursive(widget_t* widget, event_t* e) {\n  return widget_foreach(widget, widget_dispatch_callback, e);\n}\n\nuint32_t widget_on_with_tag(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx,\n                            uint32_t tag) {\n  return_value_if_fail(widget != NULL && on_event != NULL, RET_BAD_PARAMS);\n  if (widget->emitter == NULL) {\n    widget->emitter = emitter_create();\n  }\n\n  return emitter_on_with_tag(widget->emitter, type, on_event, ctx, tag);\n}\n\nuint32_t widget_on(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx) {\n  return widget_on_with_tag(widget, type, on_event, ctx, 0);\n}\n\nuint32_t widget_child_on(widget_t* widget, const char* name, uint32_t type, event_func_t on_event,\n                         void* ctx) {\n  return widget_on(widget_lookup(widget, name, TRUE), type, on_event, ctx);\n}\n\nret_t widget_off(widget_t* widget, uint32_t id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->emitter != NULL, RET_BAD_PARAMS);\n\n  return emitter_off(widget->emitter, id);\n}\n\nret_t widget_off_by_tag(widget_t* widget, uint32_t tag) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_tag(widget->emitter, tag);\n}\n\nret_t widget_off_by_ctx(widget_t* widget, void* ctx) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_ctx(widget->emitter, ctx);\n}\n\nret_t widget_off_by_func(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx) {\n  return_value_if_fail(widget != NULL && on_event != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_func(widget->emitter, type, on_event, ctx);\n}\n\nret_t widget_calc_icon_text_rect(const rect_t* ir, int32_t font_size, float_t text_size,\n                                 int32_t icon_at, uint32_t img_w, uint32_t img_h, int32_t spacer,\n                                 rect_t* r_text, rect_t* r_icon) {\n  return_value_if_fail(ir != NULL && (r_text != NULL || r_icon != NULL), RET_BAD_PARAMS);\n\n  if (r_icon == NULL) {\n    *r_text = *ir;\n\n    return RET_OK;\n  }\n\n  if (r_text == NULL) {\n    *r_icon = *ir;\n\n    return RET_OK;\n  }\n\n  return_value_if_fail(spacer < ir->h && spacer < ir->w, RET_BAD_PARAMS);\n  switch (icon_at) {\n    case ICON_AT_CENTRE: {\n      int32_t w = ir->w - spacer - text_size - img_w;\n      int32_t icon_h = ir->h - img_h;\n      *r_text = rect_init(ir->x + img_w + spacer + w / 2, ir->y, text_size, ir->h);\n      *r_icon = rect_init(ir->x + w / 2, ir->y + icon_h / 2, img_w, img_h);\n      break;\n    }\n    case ICON_AT_RIGHT: {\n      uint32_t w = img_w;\n      float_t ratio = system_info()->device_pixel_ratio;\n      if (ratio > 1) {\n        w = img_w / ratio;\n      }\n      w = tk_min(tk_max(w, ir->h), ir->w);\n      *r_icon = rect_init(ir->x + ir->w - w, ir->y, w, ir->h);\n      *r_text = rect_init(ir->x, ir->y, ir->w - ir->h - spacer, ir->h);\n      break;\n    }\n    case ICON_AT_TOP: {\n      int32_t icon_h = ir->h - font_size - spacer;\n      *r_icon = rect_init(ir->x, ir->y, ir->w, icon_h);\n      *r_text = rect_init(ir->x, icon_h + spacer, ir->w, font_size);\n      break;\n    }\n    case ICON_AT_BOTTOM: {\n      int32_t icon_h = ir->h - font_size - spacer;\n      *r_icon = rect_init(ir->x, ir->y + ir->h - icon_h, ir->w, icon_h);\n      *r_text = rect_init(ir->x, ir->y, ir->w, font_size);\n      break;\n    }\n    case ICON_AT_LEFT:\n    default: {\n      *r_icon = rect_init(ir->x, ir->y, ir->h, ir->h);\n      *r_text = rect_init(ir->x + ir->h + spacer, ir->y, ir->w - ir->h - spacer, ir->h);\n      break;\n    }\n  }\n\n  return RET_OK;\n}\n\nconst char* widget_get_bidi(widget_t* widget) {\n  value_t v;\n  if (widget_get_prop(widget, WIDGET_PROP_BIDI, &v) == RET_OK) {\n    return value_str(&v);\n  }\n\n  return NULL;\n}\n\nret_t widget_draw_icon_text(widget_t* widget, canvas_t* c, const char* icon, wstr_t* text) {\n  rect_t ir;\n  wh_t w = 0;\n  wh_t h = 0;\n  bitmap_t img;\n  rect_t r_icon;\n  rect_t r_text;\n  int32_t margin = 0;\n  int32_t spacer = 0;\n  int32_t icon_at = 0;\n  uint16_t font_size = 0;\n  float_t text_size = 0.0f;\n  int32_t margin_left = 0;\n  int32_t margin_right = 0;\n  int32_t margin_top = 0;\n  int32_t margin_bottom = 0;\n  style_t* style = widget->astyle;\n  int32_t align_h = ALIGN_H_LEFT;\n  int32_t align_v = ALIGN_V_MIDDLE;\n  return_value_if_fail(widget->astyle != NULL, RET_BAD_PARAMS);\n\n  spacer = style_get_int(style, STYLE_ID_SPACER, 2);\n  margin = style_get_int(style, STYLE_ID_MARGIN, 0);\n  margin_top = style_get_int(style, STYLE_ID_MARGIN_TOP, margin);\n  margin_left = style_get_int(style, STYLE_ID_MARGIN_LEFT, margin);\n  margin_right = style_get_int(style, STYLE_ID_MARGIN_RIGHT, margin);\n  margin_bottom = style_get_int(style, STYLE_ID_MARGIN_BOTTOM, margin);\n  icon_at = style_get_int(style, STYLE_ID_ICON_AT, ICON_AT_AUTO);\n\n  w = widget->w - margin_left - margin_right;\n  h = widget->h - margin_top - margin_bottom;\n  ir = rect_init(margin_left, margin_top, w, h);\n\n  if (text == NULL) {\n    text = &(widget->text);\n  }\n\n  if (icon == NULL) {\n    icon = style_get_str(style, STYLE_ID_ICON, NULL);\n  }\n\n  widget_prepare_text_style(widget, c);\n\n  font_size = c->font_size;\n  text_size = text->str ? canvas_measure_text(c, text->str, text->size) : 0;\n  if (icon_at == ICON_AT_RIGHT || icon_at == ICON_AT_LEFT) {\n    align_v = style_get_int(style, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    align_h = style_get_int(style, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_LEFT);\n  } else {\n    align_v = style_get_int(style, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    align_h = style_get_int(style, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_CENTER);\n  }\n  canvas_set_text_align(c, (align_h_t)align_h, (align_v_t)align_v);\n\n  if (icon != NULL && widget_load_image(widget, icon, &img) == RET_OK) {\n    float_t dpr = system_info()->device_pixel_ratio;\n\n    if (text->size > 0) {\n      if ((h > (img.h / dpr + font_size) && icon_at == ICON_AT_AUTO)) {\n        icon_at = ICON_AT_TOP;\n      }\n\n      widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer, &r_text,\n                                 &r_icon);\n\n      canvas_draw_icon_in_rect(c, &img, &r_icon);\n      widget_draw_text_in_rect(widget, c, text->str, text->size, &r_text, FALSE);\n    } else {\n      if (icon_at == ICON_AT_AUTO) {\n        widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer, NULL,\n                                   &r_icon);\n      } else {\n        widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, img.w, img.h, spacer,\n                                   &r_text, &r_icon);\n      }\n      canvas_draw_icon_in_rect(c, &img, &r_icon);\n    }\n  } else if (text != NULL && text->size > 0) {\n    widget_calc_icon_text_rect(&ir, font_size, text_size, icon_at, 0, 0, spacer, &r_text, NULL);\n    widget_draw_text_in_rect(widget, c, text->str, text->size, &r_text, FALSE);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_fill_rect(widget_t* widget, canvas_t* c, const rect_t* r, bool_t bg,\n                       image_draw_type_t draw_type) {\n  bitmap_t img;\n  ret_t ret = RET_OK;\n  gradient_t agradient;\n  style_t* style = widget->astyle;\n  uint32_t radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  const char* color_key = bg ? STYLE_ID_BG_COLOR : STYLE_ID_FG_COLOR;\n  const char* image_key = bg ? STYLE_ID_BG_IMAGE : STYLE_ID_FG_IMAGE;\n  rect_t bg_r = rect_init(widget->x, widget->y, widget->w, widget->h);\n  uint32_t radius_tl = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_LEFT, radius);\n  uint32_t radius_tr = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_RIGHT, radius);\n  uint32_t radius_bl = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_LEFT, radius);\n  uint32_t radius_br = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_RIGHT, radius);\n  uint32_t clear_bg = style_get_uint(style, STYLE_ID_CLEAR_BG, 0);\n  const char* draw_type_key = bg ? STYLE_ID_BG_IMAGE_DRAW_TYPE : STYLE_ID_FG_IMAGE_DRAW_TYPE;\n  gradient_t* gradient = style_get_gradient(style, color_key, &agradient);\n  const char* image_name = style_get_str(style, image_key, NULL);\n\n  if (gradient != NULL && r->w > 0 && r->h > 0) {\n    color_t color = gradient_get_first_color(gradient);\n    canvas_set_fill_color(c, color);\n    if (gradient->nr > 1 || color.rgba.a) {\n      if (radius_tl > 3 || radius_tr > 3 || radius_bl > 3 || radius_br > 3) {\n        /*TODO: support gradient*/\n        if (bg) {\n          ret = canvas_fill_rounded_rect_gradient_ex(c, r, NULL, gradient, radius_tl, radius_tr,\n                                                     radius_bl, radius_br);\n        } else {\n          ret = canvas_fill_rounded_rect_gradient_ex(c, r, &bg_r, gradient, radius_tl, radius_tr,\n                                                     radius_bl, radius_br);\n        }\n        if (ret == RET_FAIL) {\n          canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n        }\n      } else if (gradient->nr > 1) {\n        canvas_fill_rect_gradient(c, r->x, r->y, r->w, r->h, gradient);\n      } else {\n        if (clear_bg) {\n          canvas_clear_rect(c, r->x, r->y, r->w, r->h);\n        } else {\n          canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n        }\n      }\n    } else if (clear_bg) {\n      canvas_clear_rect(c, r->x, r->y, r->w, r->h);\n    }\n  }\n\n  if (image_name != NULL && *image_name && r->w > 0 && r->h > 0) {\n    char name[MAX_PATH + 1];\n    const char* region = strrchr(image_name, '#');\n    if (region != NULL) {\n      memset(name, 0x00, sizeof(name));\n      tk_strncpy(name, image_name, region - image_name);\n      image_name = name;\n    }\n\n    if (widget_load_image(widget, image_name, &img) == RET_OK) {\n      draw_type = (image_draw_type_t)style_get_int(style, draw_type_key, draw_type);\n\n      if (region == NULL) {\n        canvas_draw_image_ex(c, &img, draw_type, r);\n      } else {\n        rect_t src;\n        rect_t dst = *r;\n        if (tk_str_eq(region, \"#\")) {\n          src = rect_init(widget->x, widget->y, widget->w, widget->h);\n        } else if (tk_str_eq(region, \"#g\")) {\n          point_t p = {widget->x, widget->y};\n          widget_to_global(widget, &p);\n          src = rect_init(p.x, p.y, widget->w, widget->h);\n        } else {\n          image_region_parse(img.w, img.h, region, &src);\n        }\n\n        canvas_draw_image_ex2(c, &img, draw_type, &src, &dst);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_stroke_border_rect_for_border_type(canvas_t* c, const rect_t* r, color_t bd,\n                                                int32_t border, uint32_t border_width) {\n  wh_t w = r->w;\n  wh_t h = r->h;\n  xy_t x = r->x + 0.5;\n  xy_t y = r->y + 0.5;\n  xy_t y1 = y;\n  wh_t h1 = h;\n  bool_t draw_top = FALSE;\n  bool_t draw_bottom = FALSE;\n  canvas_set_fill_color(c, bd);\n  if (border & BORDER_TOP) {\n    draw_top = TRUE;\n    canvas_fill_rect(c, x, y, w, border_width);\n  }\n  if (border & BORDER_BOTTOM) {\n    draw_bottom = TRUE;\n    canvas_fill_rect(c, x, y + h - border_width, w, border_width);\n  }\n  /* 减少重复绘制的部分，可以修复有透明的时候重叠区域显示不正常为问题 */\n  if (draw_top) {\n    y1 += border_width;\n    h1 -= border_width;\n  }\n  if (draw_bottom) {\n    h1 -= border_width;\n  }\n  if (border & BORDER_LEFT) {\n    canvas_fill_rect(c, x, y1, border_width, h1);\n  }\n  if (border & BORDER_RIGHT) {\n    canvas_fill_rect(c, x + w - border_width, y1, border_width, h1);\n  }\n  return RET_OK;\n}\n\nret_t widget_stroke_border_rect(widget_t* widget, canvas_t* c, const rect_t* r) {\n  style_t* style = widget->astyle;\n  color_t trans = color_init(0, 0, 0, 0);\n  color_t bd = style_get_color(style, STYLE_ID_BORDER_COLOR, trans);\n  uint32_t radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  int32_t border = style_get_int(style, STYLE_ID_BORDER, BORDER_ALL);\n  uint32_t border_width = style_get_int(style, STYLE_ID_BORDER_WIDTH, 1);\n  uint32_t radius_tl = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_LEFT, radius);\n  uint32_t radius_tr = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_RIGHT, radius);\n  uint32_t radius_bl = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_LEFT, radius);\n  uint32_t radius_br = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_RIGHT, radius);\n\n  if (bd.rgba.a) {\n    canvas_set_stroke_color(c, bd);\n    if (radius_tl > 3 || radius_tr > 3 || radius_bl > 3 || radius_br > 3) {\n      if (canvas_stroke_rounded_rect_ex(c, r, NULL, &bd, radius_tl, radius_tr, radius_bl, radius_br,\n                                        border_width, border) != RET_OK) {\n        widget_stroke_border_rect_for_border_type(c, r, bd, border, border_width);\n      }\n    } else {\n      widget_stroke_border_rect_for_border_type(c, r, bd, border, border_width);\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_draw_background(widget_t* widget, canvas_t* c) {\n  rect_t r;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  r = rect_init(0, 0, widget->w, widget->h);\n\n  return widget_fill_rect(widget, c, &r, TRUE, IMAGE_DRAW_CENTER);\n}\n\nret_t widget_fill_bg_rect(widget_t* widget, canvas_t* c, const rect_t* r,\n                          image_draw_type_t draw_type) {\n  return widget_fill_rect(widget, c, r, TRUE, draw_type);\n}\n\nret_t widget_fill_fg_rect(widget_t* widget, canvas_t* c, const rect_t* r,\n                          image_draw_type_t draw_type) {\n  return widget_fill_rect(widget, c, r, FALSE, draw_type);\n}\n\nstatic ret_t widget_draw_border(widget_t* widget, canvas_t* c) {\n  rect_t r;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  r = rect_init(0, 0, widget->w, widget->h);\n  return widget_stroke_border_rect(widget, c, &r);\n}\n\nret_t widget_paint_helper(widget_t* widget, canvas_t* c, const char* icon, wstr_t* text) {\n  if (style_is_valid(widget->astyle)) {\n    widget_draw_icon_text(widget, c, icon, text);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_paint_impl(widget_t* widget, canvas_t* c) {\n  int32_t ox = widget->x;\n  int32_t oy = widget->y;\n  uint8_t save_alpha = c->global_alpha;\n\n  if (widget->opacity < TK_OPACITY_ALPHA) {\n    canvas_set_global_alpha(c, (widget->opacity * save_alpha) / 0xff);\n  }\n\n  if (widget->astyle != NULL) {\n    ox += style_get_int(widget->astyle, STYLE_ID_X_OFFSET, 0);\n    oy += style_get_int(widget->astyle, STYLE_ID_Y_OFFSET, 0);\n  }\n\n  canvas_translate(c, ox, oy);\n  widget_on_paint_begin(widget, c);\n  widget_on_paint_background(widget, c);\n  widget_on_paint_self(widget, c);\n  widget_on_paint_children(widget, c);\n  widget_on_paint_border(widget, c);\n  widget_on_paint_end(widget, c);\n\n  canvas_untranslate(c, ox, oy);\n  if (widget->opacity < TK_OPACITY_ALPHA) {\n    canvas_set_global_alpha(c, save_alpha);\n  }\n\n  widget_on_paint_done(widget, c);\n\n  return RET_OK;\n}\n\nret_t widget_paint(widget_t* widget, canvas_t* c) {\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n\n  if (!widget->visible || widget->opacity <= 0x08 || widget->w <= 0 || widget->h <= 0) {\n    widget->dirty = FALSE;\n    return RET_OK;\n  }\n\n  if (widget->need_update_style) {\n    widget_update_style(widget);\n  }\n\n  canvas_save(c);\n  widget_paint_impl(widget, c);\n  canvas_restore(c);\n\n  widget->dirty = FALSE;\n\n  return RET_OK;\n}\n\nstatic const widget_cmd_t s_widget_cmds[] = {\n    {WIDGET_EXEC_START_ANIMATOR, widget_start_animator},\n    {WIDGET_EXEC_STOP_ANIMATOR, widget_stop_animator},\n    {WIDGET_EXEC_PAUSE_ANIMATOR, widget_pause_animator},\n    {WIDGET_EXEC_DESTROY_ANIMATOR, widget_destroy_animator}};\n\nstatic ret_t widget_do_exec(widget_t* widget, const char* cmd, const char* args) {\n  uint32_t i = 0;\n\n  for (i = 0; i < ARRAY_SIZE(s_widget_cmds); i++) {\n    const widget_cmd_t* iter = s_widget_cmds + i;\n    if (tk_str_eq(cmd, iter->name)) {\n      return iter->exec(widget, args);\n    }\n  }\n\n  return RET_NOT_FOUND;\n}\n\nstatic ret_t widget_exec(widget_t* widget, const char* str) {\n  if (str != NULL) {\n    char cmd[TK_NAME_LEN + 1] = {0};\n    const char* args = strchr(str, ':');\n\n    if (args != NULL) {\n      return_value_if_fail((args - str) < TK_NAME_LEN, RET_BAD_PARAMS);\n      tk_strncpy(cmd, str, args - str);\n      args += 1;\n    } else {\n      return_value_if_fail(strlen(str) < TK_NAME_LEN, RET_BAD_PARAMS);\n      tk_strcpy(cmd, str);\n    }\n\n    return widget_do_exec(widget, cmd, args);\n  } else {\n    return RET_NOT_FOUND;\n  }\n}\n\nstatic widget_t* widget_get_top_widget_grab_key(widget_t* widget) {\n  return_value_if_fail(widget != NULL, NULL);\n  WIDGET_FOR_EACH_CHILD_BEGIN_R(widget, iter, i)\n  value_t v;\n  widget_t* widget_grab_key = widget_get_top_widget_grab_key(iter);\n  if (widget_grab_key == NULL && iter != NULL && iter->visible && iter->custom_props != NULL) {\n    ret_t ret = tk_object_get_prop(iter->custom_props, WIDGET_PROP_GRAB_KEYS, &v);\n    if (ret == RET_OK && value_bool(&v)) {\n      return iter;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}\n\nstatic ret_t widget_on_ungrab_keys(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  window_manager_t* wm = WINDOW_MANAGER(widget_get_window_manager(widget));\n\n  wm->widget_grab_key = widget_get_top_widget_grab_key(WIDGET(wm));\n\n  return RET_REMOVE;\n}\n\nstatic ret_t widget_exec_code(void* ctx, event_t* evt) {\n#ifndef WITHOUT_FSCRIPT\n  value_t v;\n  value_t result;\n  ret_t ret = RET_OK;\n  tk_object_t* obj = NULL;\n  widget_t* widget = WIDGET(evt->target);\n  const char* code = (const char*)ctx;\n  if (widget_get_prop(widget, STR_PROP_MODEL, &v) == RET_OK) {\n    obj = value_object(&v);\n  }\n  if (obj != NULL) {\n    TK_OBJECT_REF(obj);\n  } else {\n    obj = object_default_create();\n  }\n  return_value_if_fail(obj != NULL && code != NULL, RET_REMOVE);\n\n  tk_object_set_prop_pointer(obj, STR_PROP_SELF, widget);\n\n  switch (evt->type) {\n    case EVT_CLICK:\n    case EVT_POINTER_DOWN:\n    case EVT_POINTER_MOVE:\n    case EVT_POINTER_UP: {\n      pointer_event_t* e = pointer_event_cast(evt);\n      tk_object_set_prop_int(obj, \"x\", e->x);\n      tk_object_set_prop_int(obj, \"y\", e->y);\n      tk_object_set_prop_bool(obj, \"alt\", e->alt);\n      tk_object_set_prop_bool(obj, \"cmd\", e->cmd);\n      tk_object_set_prop_bool(obj, \"menu\", e->menu);\n      tk_object_set_prop_bool(obj, \"ctrl\", e->ctrl);\n      break;\n    }\n    case EVT_KEY_DOWN:\n    case EVT_KEY_LONG_PRESS:\n    case EVT_KEY_UP: {\n      key_event_t* e = key_event_cast(evt);\n      const key_type_value_t* kv = keys_type_find_by_value(e->key);\n      if (kv != NULL) {\n        tk_object_set_prop_str(obj, \"key\", kv->name);\n      } else {\n        tk_object_set_prop_str(obj, \"key\", \"unkown\");\n      }\n      tk_object_set_prop_bool(obj, \"alt\", e->alt);\n      tk_object_set_prop_bool(obj, \"cmd\", e->cmd);\n      tk_object_set_prop_bool(obj, \"menu\", e->menu);\n      tk_object_set_prop_bool(obj, \"ctrl\", e->ctrl);\n      break;\n    }\n    default:\n      break;\n  }\n\n  value_set_int(&result, 0);\n  fscript_eval(obj, code, &result);\n  if (tk_object_get_prop_bool(obj, \"RET_STOP\", FALSE)) {\n    ret = RET_STOP;\n  }\n  if (tk_object_get_prop_bool(obj, \"RET_REMOVE\", FALSE)) {\n    ret = RET_REMOVE;\n  }\n  value_reset(&result);\n  TK_OBJECT_UNREF(obj);\n\n  return ret;\n#else\n  return RET_OK;\n#endif\n}\n\nstatic ret_t widget_free_code(void* ctx, event_t* evt) {\n  widget_t* widget = WIDGET(evt->target);\n  widget_off_by_ctx(widget, ctx);\n  TKMEM_FREE(ctx);\n\n  return RET_REMOVE;\n}\n\n#define STR_ANIMATE_PREFIX \"animate:\"\n#define TK_ANIMATING_TIME 500 /* 单位：毫秒（ms） */\nret_t widget_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  ret_t ret = RET_OK;\n  prop_change_event_t e;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_EXEC)) {\n    ret = widget_exec(widget, value_str(v));\n    if (ret != RET_NOT_FOUND) {\n      return ret;\n    }\n  }\n\n  e.value = v;\n  e.name = name;\n  e.e = event_init(EVT_PROP_WILL_CHANGE, widget);\n  widget_dispatch(widget, (event_t*)&e);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    widget_set_x(widget, (xy_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    widget_set_y(widget, (xy_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    widget_set_w(widget, (wh_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    widget_set_h(widget, (wh_t)value_int(v), TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    widget->opacity = (uint8_t)value_int(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    widget_set_visible(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    widget->sensitive = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    widget->floating = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    widget->focusable = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    widget->with_focus_state = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    widget->dirty_rect_tolerance = value_int(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    const char* name = value_str(v);\n    return widget_use_style(widget, name);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    widget_set_enable(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    widget->feedback = value_bool(v);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    widget_set_auto_adjust_size(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    widget_set_name(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_TR_TEXT)) {\n    widget_set_tr_text(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    widget_set_animation(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    widget_set_self_layout(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_LAYOUT) || tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    widget_set_children_layout(widget, value_str(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_POINTER_CURSOR)) {\n    widget_set_pointer_cursor(widget, value_str(v));\n  } else {\n    ret = RET_NOT_FOUND;\n  }\n\n  if (widget->vt->set_prop) {\n    if (tk_str_start_with(name, STR_ANIMATE_PREFIX)) {\n      return widget_animate_prop_float_to(widget, name + strlen(STR_ANIMATE_PREFIX),\n                                          value_float32(v), TK_ANIMATING_TIME);\n    } else {\n      ret_t ret1 = widget->vt->set_prop(widget, name, v);\n      if (ret == RET_NOT_FOUND) {\n        ret = ret1;\n      }\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_FOCUSED) || tk_str_eq(name, WIDGET_PROP_FOCUS)) {\n      widget_set_focused(widget, value_bool(v));\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n      wstr_from_value(&(widget->text), v);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_EXEC)) {\n      ret = RET_NOT_FOUND;\n    } else if (tk_str_start_with(name, \"style:\") || tk_str_start_with(name, \"style.\")) {\n      return widget_set_style(widget, name + 6, v);\n    } else {\n      if (widget->custom_props == NULL) {\n        widget->custom_props = object_default_create();\n      }\n\n      if (tk_str_eq(name, WIDGET_PROP_GRAB_KEYS)) {\n        window_manager_t* wm = WINDOW_MANAGER(widget_get_window_manager(widget));\n\n        if (value_bool(v)) {\n          widget_on(widget, EVT_DESTROY, widget_on_ungrab_keys, widget);\n          wm->widget_grab_key = widget;\n        }\n      }\n\n      if (strncmp(name, STR_ON_EVENT_PREFIX, sizeof(STR_ON_EVENT_PREFIX) - 1) == 0) {\n        int32_t etype = event_from_name(name + sizeof(STR_ON_EVENT_PREFIX) - 1);\n        if (etype != EVT_NONE) {\n          char* code = tk_strdup(value_str(v));\n          if (code != NULL) {\n            name += sizeof(STR_ON_EVENT_PREFIX) - 1;\n            if (strncmp(name, STR_GLOBAL_EVENT_PREFIX, sizeof(STR_GLOBAL_EVENT_PREFIX) - 1) == 0) {\n              widget_t* wm = window_manager();\n              widget_on(wm, etype, widget_exec_code, code);\n              widget_on(wm, EVT_DESTROY, widget_free_code, code);\n            } else {\n              widget_on(widget, etype, widget_exec_code, code);\n              widget_on(widget, EVT_DESTROY, widget_free_code, code);\n            }\n            ret = RET_OK;\n          }\n        } else {\n          log_debug(\"not found event %s\\n\", name);\n        }\n      } else {\n        ret = tk_object_set_prop(widget->custom_props, name, v);\n      }\n    }\n  }\n\n  if (ret != RET_NOT_FOUND) {\n    e.e.type = EVT_PROP_CHANGED;\n    widget_dispatch(widget, (event_t*)&e);\n    widget_invalidate(widget, NULL);\n  }\n\n  return ret;\n}\n\nret_t widget_get_prop(widget_t* widget, const char* name, value_t* v) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    value_set_int32(v, widget->x);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    value_set_int32(v, widget->y);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    value_set_int32(v, widget->w);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    value_set_int32(v, widget->h);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    value_set_int32(v, widget->opacity);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    value_set_bool(v, widget->visible);\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    value_set_bool(v, widget->sensitive);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    value_set_bool(v, widget->floating);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    value_set_bool(v, widget_is_focusable(widget));\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSED)) {\n    value_set_bool(v, widget->focused);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    value_set_bool(v, widget->with_focus_state);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    value_set_int(v, widget->dirty_rect_tolerance);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    value_set_str(v, widget->style);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    value_set_bool(v, widget->enable);\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    value_set_bool(v, widget->feedback);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    value_set_bool(v, widget->auto_adjust_size);\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    value_set_str(v, widget->name);\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    value_set_str(v, widget->animation);\n  } else if (tk_str_eq(name, WIDGET_PROP_POINTER_CURSOR)) {\n    value_set_str(v, widget->pointer_cursor);\n  } else if (tk_str_eq(name, WIDGET_PROP_LOADING)) {\n    value_set_bool(v, widget->loading);\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    if (widget->self_layout != NULL) {\n      value_set_str(v, self_layouter_to_string(widget->self_layout));\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  } else if (tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    if (widget->children_layout != NULL) {\n      value_set_str(v, children_layouter_to_string(widget->children_layout));\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  } else {\n    if (widget->vt->get_prop) {\n      ret = widget->vt->get_prop(widget, name, v);\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  }\n\n  /*default*/\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_LAYOUT_W)) {\n      value_set_int32(v, widget->w);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_LAYOUT_H)) {\n      value_set_int32(v, widget->h);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n      wchar_t* text = widget->text.str;\n      if (text != NULL) {\n        text[widget->text.size] = 0;\n      }\n      value_set_wstr(v, text);\n      ret = RET_OK;\n    } else if (tk_str_eq(name, WIDGET_PROP_STATE_FOR_STYLE)) {\n      value_set_str(v, widget_get_state_for_style(widget, FALSE, FALSE));\n      ret = RET_OK;\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (widget->custom_props != NULL) {\n      ret = tk_object_get_prop(widget->custom_props, name, v);\n    }\n  }\n\n  if (ret == RET_NOT_FOUND) {\n    if (tk_str_eq(name, WIDGET_PROP_TYPE)) {\n      value_set_str(v, widget->vt->type);\n      ret = RET_OK;\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_set_prop_str(widget_t* widget, const char* name, const char* str) {\n  value_t v;\n  value_set_str(&v, str);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nconst char* widget_get_prop_str(widget_t* widget, const char* name, const char* defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_str(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_pointer(widget_t* widget, const char* name, void* pointer) {\n  value_t v;\n  value_set_pointer(&v, pointer);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nvoid* widget_get_prop_pointer(widget_t* widget, const char* name) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_pointer(&v);\n  } else {\n    return NULL;\n  }\n}\n\nret_t widget_set_prop_float(widget_t* widget, const char* name, float_t num) {\n  value_t v;\n  value_set_float32(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nfloat_t widget_get_prop_float(widget_t* widget, const char* name, float_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_float32(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_int(widget_t* widget, const char* name, int32_t num) {\n  value_t v;\n  value_set_int(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nint32_t widget_get_prop_int(widget_t* widget, const char* name, int32_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_int(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_set_prop_bool(widget_t* widget, const char* name, bool_t num) {\n  value_t v;\n  value_set_bool(&v, num);\n\n  return widget_set_prop(widget, name, &v);\n}\n\nbool_t widget_get_prop_bool(widget_t* widget, const char* name, bool_t defval) {\n  value_t v;\n  if (widget_get_prop(widget, name, &v) == RET_OK) {\n    return value_bool(&v);\n  } else {\n    return defval;\n  }\n}\n\nret_t widget_on_paint_background(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_background) {\n    ret = widget->vt->on_paint_background(widget, c);\n  } else {\n    if (style_is_valid(widget->astyle)) {\n      widget_draw_background(widget, c);\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_self(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_self) {\n    ret = widget->vt->on_paint_self(widget, c);\n  } else {\n    paint_event_t e;\n    widget_dispatch(widget, paint_event_init(&e, EVT_PAINT, widget, c));\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_children(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_children) {\n    ret = widget->vt->on_paint_children(widget, c);\n  } else {\n    ret = widget_on_paint_children_default(widget, c);\n  }\n\n  return ret;\n}\n\nret_t widget_on_paint_border(widget_t* widget, canvas_t* c) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_border) {\n    ret = widget->vt->on_paint_border(widget, c);\n  } else {\n    if (style_is_valid(widget->astyle)) {\n      ret = widget_draw_border(widget, c);\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_begin(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_begin) {\n    ret = widget->vt->on_paint_begin(widget, c);\n  }\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_BEFORE_PAINT, widget, c));\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_done(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_PAINT_DONE, widget, c));\n\n  return ret;\n}\n\nstatic ret_t widget_on_paint_end(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->vt->on_paint_end) {\n    ret = widget->vt->on_paint_end(widget, c);\n  }\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_AFTER_PAINT, widget, c));\n\n  return ret;\n}\n\nret_t widget_dispatch_to_target(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  e->target = widget;\n  widget_dispatch(widget, e);\n\n  if (widget->target) {\n    ret = widget_dispatch_to_target(widget->target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_map_key(widget_t* widget, key_event_t* e) {\n  value_t v;\n  const key_type_value_t* kv = NULL;\n\n  if (widget->custom_props != NULL) {\n    kv = keys_type_find_by_value(e->key);\n    if (kv != NULL) {\n      const char* to = NULL;\n      char from[TK_NAME_LEN + 1] = {0};\n      char fixed_name[TK_NAME_LEN + 1];\n\n      tk_snprintf(from, sizeof(from), \"map_key:%s\", kv->name);\n      if (tk_object_get_prop(widget->custom_props, from, &v) == RET_OK) {\n        to = value_str(&v);\n      } else if (strlen(kv->name) > 1) {\n        tk_strcpy(fixed_name, kv->name);\n        tk_str_tolower(fixed_name);\n        tk_snprintf(from, sizeof(from), \"map_key:%s\", fixed_name);\n        if (tk_object_get_prop(widget->custom_props, from, &v) == RET_OK) {\n          to = value_str(&v);\n        }\n      }\n\n      if (to != NULL) {\n        kv = keys_type_find(to);\n        if (kv != NULL) {\n          e->key = kv->value;\n          log_debug(\"map key %s to %s\\n\", from, to);\n        }\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_dispatch_to_key_target(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  e->target = widget;\n  widget_dispatch(widget, e);\n\n  if (widget->key_target) {\n    ret = widget_dispatch_to_target(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_before_children(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    key_event_t before = *e;\n    before.e.type = EVT_KEY_DOWN_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_keydown_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_keydown(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_after_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_keydown) {\n    ret = widget->vt->on_keydown(widget, e);\n  }\n\n  return ret;\n}\n\nbool_t widget_is_activate_key(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL && e != NULL, FALSE);\n\n  return (widget->vt->space_key_to_activate && e->key == TK_KEY_SPACE) ||\n         (widget->vt->return_key_to_activate && key_code_is_enter(e->key));\n}\n\nstatic bool_t shortcut_fast_match(const char* shortcut, key_event_t* e) {\n  uint32_t key = e->key;\n  const char* kname = strrchr(shortcut, '+');\n  bool_t cmd = strstr(shortcut, \"cmd\") != NULL;\n  bool_t ctrl = strstr(shortcut, \"ctrl\") != NULL;\n  bool_t shift = strstr(shortcut, \"shift\") != NULL;\n  const key_type_value_t* kv = keys_type_find_by_value(key);\n\n  if (kv != NULL) {\n    if (kname == NULL) {\n      kname = shortcut;\n    } else {\n      kname++;\n    }\n\n    if (tk_str_ieq(kname, kv->name) && cmd == e->cmd && ctrl == e->ctrl && shift == e->shift) {\n      return TRUE;\n    }\n  }\n\n  return FALSE;\n}\n\nstatic bool_t widget_match_key(widget_t* widget, const char* prop, key_event_t* e) {\n  const char* shortcut = NULL;\n  widget_t* win = widget_get_window(widget);\n\n  if (widget_is_window_manager(widget)) {\n    return FALSE;\n  }\n\n  return_value_if_fail(win != NULL, FALSE);\n  shortcut = widget_get_prop_str(win, prop, NULL);\n\n  if (shortcut != NULL) {\n    return shortcut_fast_match(shortcut, e);\n  }\n\n  return FALSE;\n}\n\nstatic bool_t widget_is_move_focus_prev_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_PREV_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_next_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_NEXT_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_up_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_UP_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_down_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_DOWN_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_left_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_LEFT_KEY, e);\n}\n\nstatic bool_t widget_is_move_focus_right_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_RIGHT_KEY, e);\n}\n\nbool_t widget_is_change_focus_key(widget_t* widget, key_event_t* e) {\n  return widget_is_move_focus_prev_key(widget, e) || widget_is_move_focus_next_key(widget, e) ||\n         widget_is_move_focus_up_key(widget, e) || widget_is_move_focus_down_key(widget, e) ||\n         widget_is_move_focus_left_key(widget, e) || widget_is_move_focus_right_key(widget, e);\n}\n\nstatic ret_t widget_on_keydown_general(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  if (!widget_is_window_manager(widget)) {\n    if (widget_is_activate_key(widget, e)) {\n      ret = RET_STOP;\n      widget_set_state(widget, WIDGET_STATE_PRESSED);\n    } else if (widget_is_move_focus_next_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_next(widget);\n      } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n        ret = RET_STOP;\n        widget_focus_first(widget);\n      }\n    } else if (widget_is_move_focus_prev_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_prev(widget);\n      } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n        ret = RET_STOP;\n        widget_focus_first(widget);\n      }\n    } else if (widget_is_move_focus_up_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_up(widget);\n      }\n    } else if (widget_is_move_focus_down_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_down(widget);\n      }\n    } else if (widget_is_move_focus_left_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_left(widget);\n      }\n    } else if (widget_is_move_focus_right_key(widget, e)) {\n      if (widget_is_focusable(widget)) {\n        ret = RET_STOP;\n        widget_focus_right(widget);\n      }\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keydown_impl(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_keydown_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keydown_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keydown_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_keydown(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  uint32_t key = e->key;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  widget_map_key(widget, e);\n  if (e->e.type == EVT_KEY_DOWN) {\n    ret = widget_on_keydown_impl(widget, e);\n    if (widget->feedback) {\n      ui_feedback_request(widget, (event_t*)e);\n    }\n\n    e->key = key;\n    if (ret != RET_STOP) {\n      ret = widget_on_keydown_general(widget, e);\n    }\n  } else if (e->e.type == EVT_KEY_LONG_PRESS) {\n    return_value_if_equal(widget_on_keydown_children(widget, e), RET_STOP);\n    ret = widget_on_keydown_after_children(widget, e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_before_children(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    key_event_t before = *e;\n    before.e.type = EVT_KEY_UP_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_keyup_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_keyup(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_after_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_keyup) {\n    ret = widget->vt->on_keyup(widget, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_keyup_impl(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_keyup_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keyup_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_keyup_after_children(widget, e), RET_STOP);\n\n  if (widget_is_activate_key(widget, e)) {\n    pointer_event_t click;\n    if (widget_is_focusable(widget)) {\n      widget_set_state(widget, WIDGET_STATE_FOCUSED);\n    } else {\n      widget_set_state(widget, WIDGET_STATE_NORMAL);\n    }\n    widget_dispatch_async(widget, pointer_event_init(&click, EVT_CLICK, widget, 0, 0));\n\n    ret = RET_STOP;\n  } else if (widget_is_move_focus_next_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_prev_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    } else if (widget_is_window(widget) && !widget_has_focused_widget_in_window(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_up_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_down_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_left_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  } else if (widget_is_move_focus_right_key(widget, e)) {\n    if (widget_is_focusable(widget)) {\n      ret = RET_STOP;\n    }\n  }\n\n  return ret;\n}\n\nret_t widget_on_keyup(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n  uint32_t key = e->key;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  widget_map_key(widget, e);\n  ret = widget_on_keyup_impl(widget, e);\n  if (widget->feedback) {\n    ui_feedback_request(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  e->key = key;\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_before_children(widget_t* widget, wheel_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    wheel_event_t before = *e;\n    before.e.type = EVT_WHEEL_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nstatic ret_t widget_on_wheel_children(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n\n  if (widget->key_target != NULL) {\n    ret = widget_on_wheel(widget->key_target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_after_children(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_wheel) {\n    ret = widget->vt->on_wheel(widget, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_wheel_impl(widget_t* widget, wheel_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_wheel_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_wheel_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_wheel_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_wheel(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_wheel_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}\n\nret_t widget_on_multi_gesture(widget_t* widget, multi_gesture_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\n    ret = widget_dispatch(target, (event_t*)e);\n  }\n\n  if (ret != RET_STOP) {\n    ret = widget_dispatch(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_dispatch_leave_event(widget_t* widget, pointer_event_t* e) {\n  widget_t* target = widget;\n\n  while (target != NULL) {\n    widget_t* curr = target;\n    pointer_event_t leave = *e;\n    leave.e.type = EVT_POINTER_LEAVE;\n\n    widget_dispatch(target, (event_t*)(&leave));\n    target = curr->target;\n    curr->target = NULL;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_dispatch_blur_event(widget_t* widget) {\n  widget_t* target = widget;\n  widget_t* temp;\n\n  while (target != NULL) {\n    widget_ref(target);\n    if (target->focused) {\n      target->focused = FALSE;\n      event_t e = event_init(EVT_BLUR, target);\n      widget_dispatch(target, &e);\n      widget_set_need_update_style(target);\n    }\n\n    if (target->parent && target->parent->key_target == target) {\n      target->parent->key_target = NULL;\n    }\n\n    temp = target->key_target;\n    widget_unref(target);\n    target = temp;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_dispatch_event_to_target_recursive(widget_t* widget, event_t* e) {\n  widget_t* target = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  target = widget->grab_widget ? widget->grab_widget : widget->target;\n  while (target != NULL) {\n    widget_dispatch(target, e);\n    target = target->target != NULL ? target->target : target->key_target;\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_on_pointer_down_before_children(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    pointer_event_t before = *e;\n    before.e.type = EVT_POINTER_DOWN_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nret_t widget_on_pointer_down_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n\n  if (target != NULL && target->enable && target->sensitive) {\n    if (!(widget_is_keyboard(target))) {\n      if (widget_is_focusable(target) || !widget_is_strongly_focus(widget)) {\n        if (!target->focused) {\n          widget_set_focused_internal(target, TRUE);\n        } else {\n          widget->key_target = target;\n        }\n      }\n    }\n  } else if (widget->key_target && !widget_is_strongly_focus(widget)) {\n    widget_set_focused_internal(widget->key_target, FALSE);\n  }\n  return_value_if_equal(ret, RET_STOP);\n\n  if (widget->target != target) {\n    if (widget->target != NULL) {\n      widget_dispatch_leave_event(widget->target, e);\n    }\n    widget->target = target;\n  }\n\n  if (widget->target != NULL) {\n    ret = widget_on_pointer_down(widget->target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_down_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_pointer_down) {\n    return_value_if_equal(ret = widget->vt->on_pointer_down(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_down_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  widget->grab_widget = NULL;\n  widget->grab_widget_count = 0;\n  return_value_if_equal(widget_on_pointer_down_before_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_pointer_down_children(widget, e), RET_STOP);\n  return_value_if_equal(widget_on_pointer_down_after_children(widget, e), RET_STOP);\n\n  return RET_OK;\n}\n\nret_t widget_on_pointer_down(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_pointer_down_impl(widget, e);\n  if (widget->feedback) {\n    ui_feedback_request(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_move_before_children(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    pointer_event_t before = *e;\n    before.e.type = EVT_POINTER_MOVE_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nret_t widget_on_pointer_move_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n\n  if (target != widget->target) {\n    if (widget->target != NULL) {\n      widget_dispatch_leave_event(widget->target, e);\n    }\n\n    if (target != NULL) {\n      pointer_event_t enter = *e;\n      enter.e.type = EVT_POINTER_ENTER;\n      ret = widget_dispatch(target, (event_t*)(&enter));\n      widget_update_pointer_cursor(target);\n    } else {\n      widget_update_pointer_cursor(widget);\n    }\n\n    widget->target = target;\n  }\n  return_value_if_equal(ret, RET_STOP);\n\n  if (widget->target != NULL) {\n    ret = widget_on_pointer_move(widget->target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_move_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_pointer_move) {\n    return_value_if_equal(ret = widget->vt->on_pointer_move(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_move_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_pointer_move_before_children(widget, e), RET_STOP);\n  if (widget_on_pointer_move_children(widget, e) == RET_STOP) {\n    if (e->pressed) {\n      pointer_event_t abort;\n      pointer_event_init(&abort, EVT_POINTER_DOWN_ABORT, widget, e->x, e->y);\n      return_value_if_equal(widget_on_pointer_move_after_children(widget, &abort), RET_STOP);\n    }\n\n    return RET_STOP;\n  } else {\n    return widget_on_pointer_move_after_children(widget, e);\n  }\n}\n\nret_t widget_on_pointer_move(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_pointer_move_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_up_before_children(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    pointer_event_t before = *e;\n    before.e.type = EVT_POINTER_UP_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}\n\nret_t widget_on_pointer_up_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\n    ret = widget_on_pointer_up(target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_up_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_pointer_up) {\n    return_value_if_equal(ret = widget->vt->on_pointer_up(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_pointer_up_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_equal(widget_on_pointer_up_before_children(widget, e), RET_STOP);\n  if (widget_on_pointer_up_children(widget, e) == RET_STOP) {\n    if (e->pressed) {\n      pointer_event_t abort;\n      pointer_event_init(&abort, EVT_POINTER_DOWN_ABORT, widget, e->x, e->y);\n      return_value_if_equal(widget_on_pointer_up_after_children(widget, &abort), RET_STOP);\n    }\n\n    return RET_STOP;\n  } else {\n    return widget_on_pointer_up_after_children(widget, e);\n  }\n}\n\nret_t widget_on_pointer_up(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_pointer_up_impl(widget, e);\n  if (widget->feedback) {\n    ui_feedback_request(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}\n\nstatic ret_t widget_on_context_menu_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  widget_t* target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\n    ret = widget_on_context_menu(target, e);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_context_menu_after_children(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_context_menu) {\n    return_value_if_equal(ret = widget->vt->on_context_menu(widget, e), RET_STOP);\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_on_context_menu_impl(widget_t* widget, pointer_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget_on_context_menu_children(widget, e) == RET_STOP) {\n    return RET_STOP;\n  } else {\n    return widget_on_context_menu_after_children(widget, e);\n  }\n}\n\nret_t widget_on_context_menu(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_context_menu_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}\n\nret_t widget_grab(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->grab_widget == NULL || widget->grab_widget == child, RET_BAD_PARAMS);\n\n  if (widget->grab_widget == NULL) {\n    widget->grab_widget = child;\n    widget->grab_widget_count = 1;\n  } else {\n    widget->grab_widget_count++;\n  }\n\n  if (widget->parent) {\n    widget_grab(widget->parent, widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_ungrab(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->grab_widget == child) {\n    if (widget->grab_widget->grab_widget_count < widget->grab_widget_count) {\n      widget->grab_widget_count--;\n      if (widget->grab_widget_count <= 0) {\n        widget->grab_widget = NULL;\n        widget->grab_widget_count = 0;\n      }\n\n      if (widget->parent) {\n        widget_ungrab(widget->parent, widget);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nret_t widget_foreach(widget_t* widget, tk_visit_t visit, void* ctx) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && visit != NULL, RET_BAD_PARAMS);\n\n  ret = visit(ctx, widget);\n  if (ret != RET_OK) {\n    return ret;\n  }\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  ret = widget_foreach(iter, visit, ctx);\n  if (ret == RET_STOP || ret == RET_DONE) {\n    return ret;\n  }\n  WIDGET_FOR_EACH_CHILD_END()\n\n  return RET_OK;\n}\n\nwidget_t* widget_get_window(widget_t* widget) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, NULL);\n\n  while (iter) {\n    if (widget_is_window(iter)) {\n      return iter;\n    }\n    iter = iter->parent;\n  }\n\n  return NULL;\n}\n\nstatic widget_t* widget_get_window_or_keyboard(widget_t* widget) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, NULL);\n\n  while (iter) {\n    if (widget_is_window(iter) || widget_is_keyboard(iter)) {\n      return iter;\n    }\n    iter = iter->parent;\n  }\n\n  return NULL;\n}\n\nwidget_t* widget_get_window_manager(widget_t* widget) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL, NULL);\n\n  while (iter) {\n    if (widget_is_window_manager(iter)) {\n      return iter;\n    }\n    iter = iter->parent;\n  }\n\n  return window_manager();\n}\n\nuint32_t widget_add_timer(widget_t* widget, timer_func_t on_timer, uint32_t duration_ms) {\n  return_value_if_fail(widget != NULL && on_timer != NULL, TK_INVALID_ID);\n  return timer_add_with_type(on_timer, widget, duration_ms, TIMER_INFO_WIDGET_ADD);\n}\n\nret_t widget_remove_timer(widget_t* widget, uint32_t timer_id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return timer_remove(timer_id);\n}\n\nuint32_t widget_add_idle(widget_t* widget, idle_func_t on_idle) {\n  return_value_if_fail(widget != NULL && on_idle != NULL, TK_INVALID_ID);\n  return idle_add_with_type(on_idle, widget, IDLE_INFO_WIDGET_ADD);\n}\n\nret_t widget_remove_idle(widget_t* widget, uint32_t idle_id) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  return idle_remove(idle_id);\n}\n\nret_t widget_destroy_sync(widget_t* widget) {\n  event_t e = event_init(EVT_DESTROY, widget);\n  return_value_if_fail(widget != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n\n#ifndef WITHOUT_WIDGET_ANIMATORS\n  widget_destroy_animator(widget, NULL);\n#endif /*WITHOUT_WIDGET_ANIMATORS*/\n\n  widget->destroying = TRUE;\n  idle_remove_all_by_ctx_and_type(IDLE_INFO_WIDGET_ADD, widget);\n  timer_remove_all_by_ctx_and_type(TIMER_INFO_WIDGET_ADD, widget);\n\n  if (widget->emitter != NULL) {\n    widget_dispatch(widget, &e);\n    emitter_destroy(widget->emitter);\n    widget->emitter = NULL;\n  }\n\n  if (widget->children != NULL) {\n    widget_destroy_children(widget);\n    darray_destroy(widget->children);\n    widget->children = NULL;\n  }\n\n  if (widget->children_layout != NULL) {\n    children_layouter_destroy(widget->children_layout);\n    widget->children_layout = NULL;\n  }\n\n  if (widget->self_layout != NULL) {\n    self_layouter_destroy(widget->self_layout);\n    widget->self_layout = NULL;\n  }\n\n  widget->destroying = FALSE;\n\n  return widget_real_destroy(widget);\n}\n\nwidget_t* widget_create(widget_t* parent, const widget_vtable_t* vt, xy_t x, xy_t y, wh_t w,\n                        wh_t h) {\n  return_value_if_fail(vt != NULL, NULL);\n\n  return widget_init(widget_real_create(vt), parent, vt, x, y, w, h);\n}\n\nret_t widget_destroy(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->ref_count > 0 && widget->vt != NULL,\n                       RET_BAD_PARAMS);\n\n  if (widget->parent != NULL) {\n    widget_remove_child(widget->parent, widget);\n  }\n\n  return widget_unref_async(widget);\n}\n\nstatic ret_t widget_destroy_on_idle(const idle_info_t* info) {\n  widget_destroy(WIDGET(info->ctx));\n\n  return RET_REMOVE;\n}\n\nret_t widget_destroy_async(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->ref_count > 0 && widget->vt != NULL,\n                       RET_BAD_PARAMS);\n\n  return_value_if_fail(idle_add(widget_destroy_on_idle, widget) != TK_INVALID_ID, RET_FAIL);\n\n  return RET_OK;\n}\n\nstatic ret_t widget_set_parent_not_dirty(widget_t* widget) {\n  widget_t* iter = widget->parent;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    iter->dirty = FALSE;\n    if (iter->vt->is_window) {\n      break;\n    }\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_invalidate(widget_t* widget, const rect_t* r) {\n  rect_t rself;\n  return_value_if_fail(widget != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->dirty) {\n    return RET_OK;\n  }\n\n  if (r == NULL) {\n    rself = rect_init(0, 0, widget->w, widget->h);\n    r = &rself;\n  }\n\n  widget->dirty = TRUE;\n  widget_set_parent_not_dirty(widget);\n\n  if (widget->vt && widget->vt->invalidate) {\n    return widget->vt->invalidate(widget, r);\n  } else {\n    return widget_invalidate_default(widget, r);\n  }\n}\n\nret_t widget_invalidate_force(widget_t* widget, const rect_t* r) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->dirty = FALSE;\n  return widget_invalidate(widget, r);\n}\n\nwidget_t* widget_init(widget_t* widget, widget_t* parent, const widget_vtable_t* vt, xy_t x, xy_t y,\n                      wh_t w, wh_t h) {\n  return_value_if_fail(widget != NULL && vt != NULL, NULL);\n\n  widget->x = x;\n  widget->y = y;\n  widget->w = w;\n  widget->h = h;\n  widget->vt = vt;\n  widget->dirty = TRUE;\n  widget->ref_count = 1;\n  widget->opacity = 0xff;\n  widget->enable = TRUE;\n  widget->visible = TRUE;\n  widget->feedback = FALSE;\n  widget->auto_adjust_size = FALSE;\n  widget->sensitive = TRUE;\n  widget->emitter = NULL;\n  widget->children = NULL;\n  widget->initializing = TRUE;\n  widget->state = tk_strdup(WIDGET_STATE_NORMAL);\n  widget->target = NULL;\n  widget->key_target = NULL;\n  widget->grab_widget = NULL;\n  widget->grab_widget_count = 0;\n  widget->focused = FALSE;\n  widget->focusable = FALSE;\n  widget->with_focus_state = FALSE;\n  widget->dirty_rect_tolerance = 4;\n  widget->need_update_style = TRUE;\n\n  if (parent) {\n    widget_add_child(parent, widget);\n  }\n\n  wstr_init(&(widget->text), 0);\n  if (!widget->vt) {\n    widget->vt = widget_vtable_default();\n  }\n\n  if (widget->astyle == NULL &&\n      (widget_is_window_manager(widget) || widget_get_window(widget) != NULL)) {\n    widget->astyle = style_factory_create_style(style_factory(), widget_get_style_type(widget));\n    ENSURE(widget->astyle != NULL);\n    if (widget_is_window_opened(widget)) {\n      widget_set_need_update_style(widget);\n    }\n  }\n\n  widget_invalidate_force(widget, NULL);\n\n  widget->initializing = FALSE;\n\n  return widget;\n}\n\nret_t widget_get_prop_default_value(widget_t* widget, const char* name, value_t* v) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    value_set_int32(v, 0xff);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    value_set_int(v, 4);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n    value_set_wstr(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSED)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    value_set_bool(v, FALSE);\n  } else {\n    if (widget->vt->get_prop_default_value) {\n      ret = widget->vt->get_prop_default_value(widget, name, v);\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  }\n\n  return ret;\n}\n\nstatic ret_t widget_get_offset(widget_t* widget, xy_t* out_x, xy_t* out_y) {\n  return_value_if_fail(widget != NULL && out_x != NULL && out_y != NULL, RET_BAD_PARAMS);\n  *out_x = 0;\n  *out_y = 0;\n  if (widget->vt != NULL && widget->vt->get_offset != NULL) {\n    return widget->vt->get_offset(widget, out_x, out_y);\n  }\n  return RET_OK;\n}\n\nret_t widget_to_screen_ex(widget_t* widget, widget_t* parent, point_t* p) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL && p != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL && iter != parent) {\n    xy_t offset_x, offset_y;\n    if (widget_get_offset(iter, &offset_x, &offset_y) == RET_OK) {\n      p->x -= offset_x;\n      p->y -= offset_y;\n    }\n\n    p->x += iter->x;\n    p->y += iter->y;\n\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_to_screen(widget_t* widget, point_t* p) {\n  return widget_to_screen_ex(widget, NULL, p);\n}\n\nret_t widget_to_local(widget_t* widget, point_t* p) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL && p != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    xy_t offset_x = 0;\n    xy_t offset_y = 0;\n    if (widget_get_offset(iter, &offset_x, &offset_y) == RET_OK) {\n      p->x += offset_x;\n      p->y += offset_y;\n    }\n\n    p->x -= iter->x;\n    p->y -= iter->y;\n\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_to_global(widget_t* widget, point_t* p) {\n  widget_t* iter = widget;\n  return_value_if_fail(widget != NULL && p != NULL, RET_BAD_PARAMS);\n\n  while (iter != NULL) {\n    p->x += iter->x;\n    p->y += iter->y;\n\n    iter = iter->parent;\n  }\n\n  return RET_OK;\n}\n\nint32_t widget_count_children(widget_t* widget) {\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget->children != NULL ? widget->children->size : 0;\n}\n\nwidget_t* widget_get_child(widget_t* widget, int32_t index) {\n  return_value_if_fail(widget != NULL, NULL);\n  if (widget->children == NULL || index >= widget->children->size) {\n    return NULL;\n  }\n\n  return WIDGET(widget->children->elms[index]);\n}\n\nint32_t widget_index_of(widget_t* widget) {\n  widget_t* parent = NULL;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, -1);\n\n  parent = widget->parent;\n  WIDGET_FOR_EACH_CHILD_BEGIN(parent, iter, i)\n  if (iter == widget) {\n    return i;\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return -1;\n}\n\nret_t widget_prepare_text_style_ex(widget_t* widget, canvas_t* c, color_t default_trans,\n                                   const char* default_font, uint16_t default_font_size,\n                                   align_h_t default_align_h, align_v_t default_align_v) {\n  style_t* style = widget->astyle;\n  color_t tc = style_get_color(style, STYLE_ID_TEXT_COLOR, default_trans);\n  const char* font_name = style_get_str(style, STYLE_ID_FONT_NAME, default_font);\n  uint16_t font_size = style_get_int(style, STYLE_ID_FONT_SIZE, default_font_size);\n  align_h_t align_h = (align_h_t)style_get_int(style, STYLE_ID_TEXT_ALIGN_H, default_align_h);\n  align_v_t align_v = (align_v_t)style_get_int(style, STYLE_ID_TEXT_ALIGN_V, default_align_v);\n\n  canvas_set_text_color(c, tc);\n  canvas_set_font(c, font_name, font_size);\n  canvas_set_text_align(c, align_h, align_v);\n\n  return RET_OK;\n}\n\nret_t widget_prepare_text_style(widget_t* widget, canvas_t* c) {\n  color_t trans = color_init(0, 0, 0, 0);\n  return widget_prepare_text_style_ex(widget, c, trans, NULL, TK_DEFAULT_FONT_SIZE, ALIGN_H_CENTER,\n                                      ALIGN_V_MIDDLE);\n}\n\nstatic ret_t widget_copy_style(widget_t* clone, widget_t* widget) {\n  if (style_is_mutable(widget->astyle) && style_mutable_cast(widget->astyle) != NULL) {\n    if (!style_is_mutable(clone->astyle)) {\n      widget_ensure_style_mutable(clone);\n    }\n\n    if (style_mutable_cast(clone->astyle) != NULL) {\n      style_mutable_copy(clone->astyle, widget->astyle);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic const char* const s_widget_persistent_props[] = {WIDGET_PROP_NAME,\n                                                        WIDGET_PROP_STYLE,\n                                                        WIDGET_PROP_TR_TEXT,\n                                                        WIDGET_PROP_TEXT,\n                                                        WIDGET_PROP_ANIMATION,\n                                                        WIDGET_PROP_ENABLE,\n                                                        WIDGET_PROP_VISIBLE,\n                                                        WIDGET_PROP_FLOATING,\n                                                        WIDGET_PROP_CHILDREN_LAYOUT,\n                                                        WIDGET_PROP_SELF_LAYOUT,\n                                                        WIDGET_PROP_OPACITY,\n                                                        WIDGET_PROP_FOCUSED,\n                                                        WIDGET_PROP_FEEDBACK,\n                                                        WIDGET_PROP_AUTO_ADJUST_SIZE,\n                                                        WIDGET_PROP_FOCUSABLE,\n                                                        WIDGET_PROP_SENSITIVE,\n                                                        WIDGET_PROP_WITH_FOCUS_STATE,\n                                                        NULL};\n\nconst char* const* widget_get_persistent_props(void) {\n  return s_widget_persistent_props;\n}\n\nstatic ret_t widget_copy_base_props(widget_t* widget, widget_t* other) {\n  widget->state = tk_str_copy(widget->state, other->state);\n  widget->name = tk_str_copy(widget->name, other->name);\n  widget->style = tk_str_copy(widget->style, other->style);\n\n  if (other->text.str != NULL) {\n    widget_set_text(widget, other->text.str);\n  }\n\n  if (other->tr_text != NULL) {\n    widget_set_tr_text(widget, other->tr_text);\n  }\n\n  widget->enable = other->enable;\n  widget->visible = other->visible;\n  widget->floating = other->floating;\n  widget->opacity = other->opacity;\n  widget->feedback = other->feedback;\n  widget->auto_adjust_size = other->auto_adjust_size;\n  widget->focusable = other->focusable;\n  widget->sensitive = other->sensitive;\n  widget->auto_created = other->auto_created;\n  widget->with_focus_state = other->with_focus_state;\n  widget->dirty_rect_tolerance = other->dirty_rect_tolerance;\n\n  if (other->animation != NULL && *(other->animation)) {\n    widget_set_animation(widget, other->animation);\n  }\n\n  if (other->self_layout != NULL) {\n    widget->self_layout = self_layouter_clone(other->self_layout);\n  }\n\n  if (other->children_layout != NULL) {\n    widget->children_layout = children_layouter_clone(other->children_layout);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_copy(widget_t* widget, widget_t* other) {\n  return_value_if_fail(widget != NULL && other != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt == other->vt, RET_BAD_PARAMS);\n\n  widget_copy_style(widget, other);\n  widget_copy_base_props(widget, other);\n\n  if (other->custom_props) {\n    widget->custom_props = object_default_clone(OBJECT_DEFAULT(other->custom_props));\n  }\n\n  if (widget->vt->on_copy != NULL) {\n    widget->vt->on_copy(widget, other);\n  } else {\n    widget_on_copy_default(widget, other);\n  }\n\n  widget_set_need_update_style(widget);\n\n  return RET_OK;\n}\n\nwidget_t* widget_clone(widget_t* widget, widget_t* parent) {\n  widget_t* clone = NULL;\n  return_value_if_fail(widget != NULL && widget->vt != NULL && widget->vt->create != NULL, NULL);\n\n  clone = widget->vt->create(parent, widget->x, widget->y, widget->w, widget->h);\n  return_value_if_fail(clone != NULL, NULL);\n\n  widget_copy(clone, widget);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_clone(iter, clone);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return clone;\n}\n\n#define PROP_EQ(prop) (widget->prop == other->prop)\nbool_t widget_equal(widget_t* widget, widget_t* other) {\n  bool_t ret = FALSE;\n  const char* const* properties = NULL;\n  return_value_if_fail(widget != NULL && other != NULL, FALSE);\n\n  ret = PROP_EQ(opacity) && PROP_EQ(enable) && PROP_EQ(visible) && PROP_EQ(vt) && PROP_EQ(x) &&\n        PROP_EQ(y) && PROP_EQ(w) && PROP_EQ(h) && PROP_EQ(floating);\n  if (widget->name != NULL || other->name != NULL) {\n    ret = ret && (tk_str_eq(widget->name, other->name) || PROP_EQ(name));\n  }\n\n  if (widget->style != NULL || other->style != NULL) {\n    ret = ret && tk_str_eq(widget->style, other->style);\n  }\n\n  if (!ret) {\n    return ret;\n  }\n\n  ret = ret && wstr_equal(&(widget->text), &(other->text));\n\n  if (widget->tr_text != NULL || other->tr_text != NULL) {\n    ret = ret && (tk_str_eq(widget->tr_text, other->tr_text) || PROP_EQ(tr_text));\n  }\n\n  if (!ret) {\n    return ret;\n  }\n\n  properties = widget->vt->clone_properties;\n  if (properties != NULL) {\n    value_t v1;\n    value_t v2;\n    uint32_t i = 0;\n    for (i = 0; properties[i] != NULL; i++) {\n      const char* prop = properties[i];\n      if (widget_get_prop(widget, prop, &v1) != RET_OK) {\n        continue;\n      }\n\n      if (widget_get_prop(other, prop, &v2) != RET_OK) {\n        return FALSE;\n      }\n\n      if (!value_equal(&v1, &v2)) {\n        log_debug(\"prop %s not equal\\n\", prop);\n        return FALSE;\n      }\n    }\n  }\n\n  if (widget->children_layout != other->children_layout) {\n    const char* str1 = children_layouter_to_string(widget->children_layout);\n    const char* str2 = children_layouter_to_string(other->children_layout);\n    if (!tk_str_eq(str1, str2)) {\n      return FALSE;\n    }\n  }\n\n  if (widget->self_layout != other->self_layout) {\n    const char* str1 = self_layouter_to_string(widget->self_layout);\n    const char* str2 = self_layouter_to_string(other->self_layout);\n    if (!tk_str_eq(str1, str2)) {\n      return FALSE;\n    }\n  }\n\n  if (!ret) {\n    return ret;\n  }\n\n  if (widget->children == other->children) {\n    return TRUE;\n  }\n\n  if (widget->children == NULL || other->children == NULL) {\n    return FALSE;\n  }\n\n  if (widget->children->size != other->children->size) {\n    return FALSE;\n  }\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  widget_t* iter_other = WIDGET(other->children->elms[i]);\n  if (!widget_equal(iter, iter_other)) {\n    return FALSE;\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return TRUE;\n}\n\nfloat_t widget_measure_text(widget_t* widget, const wchar_t* text) {\n  canvas_t* c = widget_get_canvas(widget);\n  return_value_if_fail(widget != NULL && text != NULL && c != NULL, 0);\n\n  widget_prepare_text_style(widget, c);\n\n  return canvas_measure_text(c, (wchar_t*)text, wcslen(text));\n}\n\nret_t widget_load_image(widget_t* widget, const char* name, bitmap_t* bitmap) {\n  image_manager_t* imm = widget_get_image_manager(widget);\n\n  return_value_if_fail(imm != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget != NULL && name != NULL && bitmap != NULL, RET_BAD_PARAMS);\n\n  return image_manager_get_bitmap(imm, name, bitmap);\n}\n\nret_t widget_unload_image(widget_t* widget, bitmap_t* bitmap) {\n  image_manager_t* imm = widget_get_image_manager(widget);\n\n  return_value_if_fail(imm != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget != NULL && bitmap != NULL, RET_BAD_PARAMS);\n\n  return image_manager_unload_bitmap(imm, bitmap);\n}\n\nconst asset_info_t* widget_load_asset(widget_t* widget, asset_type_t type, const char* name) {\n  return widget_load_asset_ex(widget, type, 0, name);\n}\n\nconst asset_info_t* widget_load_asset_ex(widget_t* widget, asset_type_t type, uint16_t subtype,\n                                         const char* name) {\n  assets_manager_t* am = widget_get_assets_manager(widget);\n  return_value_if_fail(widget != NULL && name != NULL && am != NULL, NULL);\n\n  return assets_manager_ref_ex(am, type, subtype, name);\n}\n\nret_t widget_unload_asset(widget_t* widget, const asset_info_t* asset) {\n  assets_manager_t* am = widget_get_assets_manager(widget);\n  return_value_if_fail(widget != NULL && asset != NULL && am != NULL, RET_BAD_PARAMS);\n\n  return assets_manager_unref(am, asset);\n}\n\nbool_t widget_is_point_in(widget_t* widget, xy_t x, xy_t y, bool_t is_local) {\n  point_t p = {x, y};\n  return_value_if_fail(widget != NULL, FALSE);\n\n  if (!is_local) {\n    widget_to_local(widget, &p);\n  }\n\n  if (widget->vt->is_point_in != NULL) {\n    return widget->vt->is_point_in(widget, p.x, p.y);\n  } else {\n    return (p.x >= 0 && p.y >= 0 && p.x < widget->w && p.y < widget->h);\n  }\n}\n\nconst char* widget_get_type(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, NULL);\n\n  return widget_get_prop_str(widget, WIDGET_PROP_TYPE, NULL);\n}\n\nwidget_t* widget_cast(widget_t* widget) {\n  return widget;\n}\n\nbool_t widget_is_instance_of(widget_t* widget, const widget_vtable_t* vt) {\n  const widget_vtable_t* iter = NULL;\n  return_value_if_fail(widget != NULL && vt != NULL, FALSE);\n\n  iter = widget->vt;\n  while (iter != NULL) {\n    if (iter == vt) {\n      return TRUE;\n    }\n\n    iter = iter->parent;\n  }\n#ifdef WITH_WIDGET_TYPE_CHECK\n  if (vt == widget_vtable_default()) {\n    return TRUE;\n  } else {\n    return FALSE;\n  }\n#else\n  return TRUE;\n#endif /*WITH_WIDGET_TYPE_CHECK*/\n}\n\nstatic ret_t widget_ensure_visible_in_scroll_view(widget_t* scroll_view, widget_t* widget) {\n  rect_t r;\n  point_t p;\n  int32_t ox = 0;\n  int32_t oy = 0;\n  int32_t old_ox = 0;\n  int32_t old_oy = 0;\n  return_value_if_fail(widget != NULL && scroll_view != NULL, RET_BAD_PARAMS);\n\n  memset(&p, 0x0, sizeof(point_t));\n  widget_to_screen_ex(widget, scroll_view, &p);\n  r = rect_init(p.x, p.y, widget->w, widget->h);\n\n  ox = widget_get_prop_int(scroll_view, WIDGET_PROP_XOFFSET, 0);\n  oy = widget_get_prop_int(scroll_view, WIDGET_PROP_YOFFSET, 0);\n  old_ox = ox;\n  old_oy = oy;\n\n  if (oy > r.y) {\n    oy = r.y;\n  }\n\n  if (ox > r.x) {\n    ox = r.x;\n  }\n\n  if ((r.y + r.h) > (oy + scroll_view->h)) {\n    oy = r.y + r.h - scroll_view->h;\n  }\n\n  if ((r.x + r.w) > (ox + scroll_view->w)) {\n    ox = r.x + r.w - scroll_view->w;\n  }\n\n  if (ox != old_ox) {\n    widget_set_prop_int(scroll_view, WIDGET_PROP_XOFFSET, ox);\n  }\n\n  if (oy != old_oy) {\n    widget_set_prop_int(scroll_view, WIDGET_PROP_YOFFSET, oy);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_ensure_visible_in_viewport(widget_t* widget) {\n  widget_t* parent = NULL;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  parent = widget->parent;\n  while (parent != NULL) {\n    if (widget_is_scrollable(parent)) {\n      widget_ensure_visible_in_scroll_view(parent, widget);\n      break;\n    }\n\n    parent = parent->parent;\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_as_key_target(widget_t* widget) {\n  if (widget_is_keyboard(widget)) {\n    return RET_OK;\n  }\n\n  if (widget != NULL) {\n    widget_t* parent = widget->parent;\n\n    if (parent != NULL) {\n      if (!(parent->focused)) {\n        parent->focused = TRUE;\n        event_t e = event_init(EVT_FOCUS, NULL);\n        widget_dispatch(parent, &e);\n        widget_set_need_update_style(parent);\n      }\n\n      if (parent->key_target != NULL && parent->key_target != widget) {\n        widget_set_focused_internal(widget->parent->key_target, FALSE);\n      }\n\n      if (parent->key_target != widget) {\n        parent->key_target = widget;\n      }\n      widget_set_as_key_target(parent);\n      if (!widget->focused) {\n        widget_set_need_update_style(widget);\n      }\n    }\n  }\n\n  return RET_OK;\n}\n\nbool_t widget_is_keyboard(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  if (widget->vt->is_keyboard) {\n    return TRUE;\n  }\n\n  if (widget_get_prop(widget, WIDGET_PROP_IS_KEYBOARD, &v) == RET_OK) {\n    return value_bool(&v);\n  }\n\n  return FALSE;\n}\n\nstatic ret_t widget_on_visit_focusable(void* ctx, const void* data) {\n  widget_t* widget = WIDGET(data);\n  darray_t* all_focusable = (darray_t*)ctx;\n\n  if (!(widget->sensitive) || !(widget->visible) || !(widget->enable)) {\n    return RET_SKIP;\n  }\n\n  if (widget->vt->only_active_child_visible) {\n    widget_t* child = widget_find_target(widget, 1, 1);\n    widget_foreach(child, widget_on_visit_focusable, all_focusable);\n\n    return RET_SKIP;\n  }\n\n  if (widget_is_focusable(widget)) {\n    darray_push(all_focusable, widget);\n  }\n\n  if (widget->vt->disallow_children_focusable) {\n    return RET_SKIP;\n  }\n  return RET_OK;\n}\n\nstatic ret_t widget_get_all_focusable_widgets_in_window(widget_t* widget, darray_t* all_focusable) {\n  widget_t* win = widget_get_window_or_keyboard(widget);\n  return_value_if_fail(win != NULL, RET_BAD_PARAMS);\n\n  widget_foreach(win, widget_on_visit_focusable, all_focusable);\n\n  return RET_OK;\n}\n\nstatic widget_t* widget_get_first_focusable_widget_in_window(widget_t* widget) {\n  widget_t* first = NULL;\n  darray_t all_focusable;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(win != NULL, first);\n\n  darray_init(&all_focusable, 10, NULL, NULL);\n  widget_foreach(win, widget_on_visit_focusable, &all_focusable);\n  if (all_focusable.size > 0) {\n    first = WIDGET(all_focusable.elms[0]);\n  }\n  darray_deinit(&all_focusable);\n\n  return first;\n}\n\nbool_t widget_has_focused_widget_in_window(widget_t* widget) {\n  widget_t* iter = NULL;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(win != NULL, FALSE);\n\n  iter = win->key_target;\n  while (iter != NULL) {\n    if (widget_is_focusable(iter) && iter->focused) {\n      return TRUE;\n    }\n\n    iter = iter->key_target;\n  }\n\n  return FALSE;\n}\n\nret_t widget_focus_first(widget_t* widget) {\n  widget_t* first = widget_get_first_focusable_widget_in_window(widget);\n\n  if (first != NULL) {\n    widget_set_prop_bool(first, WIDGET_PROP_FOCUSED, TRUE);\n  }\n\n  return RET_OK;\n}\n\nstatic widget_t* widget_find_prev_focus_widget(widget_t* widget, darray_t* all_focusable) {\n  uint32_t i = 0;\n  for (i = 0; i < all_focusable->size; i++) {\n    widget_t* iter = WIDGET(all_focusable->elms[i]);\n\n    if (iter == widget) {\n      uint32_t focus = (i == 0) ? (all_focusable->size - 1) : (i - 1);\n\n      return WIDGET(all_focusable->elms[focus]);\n    }\n  }\n\n  return NULL;\n}\n\nstatic widget_t* widget_find_next_focus_widget(widget_t* widget, darray_t* all_focusable) {\n  uint32_t i = 0;\n  for (i = 0; i < all_focusable->size; i++) {\n    widget_t* iter = WIDGET(all_focusable->elms[i]);\n\n    if (iter == widget) {\n      uint32_t focus = ((i + 1) == all_focusable->size) ? (0) : (i + 1);\n\n      return WIDGET(all_focusable->elms[focus]);\n    }\n  }\n\n  return NULL;\n}\n\nstatic bool_t is_same_row(const rect_t* r1, const rect_t* r2) {\n  int32_t cy1 = r1->y + r1->h / 2;\n  int32_t cy2 = r2->y + r2->h / 2;\n\n  return (cy2 >= r1->y && cy2 < (r1->y + r1->h)) || (cy1 >= r2->y && cy1 < (r2->y + r2->h));\n}\n\nstatic bool_t is_same_col(const rect_t* r1, const rect_t* r2) {\n  int32_t cx1 = r1->x + r1->w / 2;\n  int32_t cx2 = r2->x + r2->w / 2;\n\n  return (cx2 >= r1->x && cx2 < (r1->x + r1->w)) || (cx1 >= r2->x && cx1 < (r2->x + r2->w));\n}\n\nstatic uint32_t distance2(const rect_t* r1, const rect_t* r2) {\n  uint32_t dx = (r1->x + r1->w / 2) - (r2->x + r2->w / 2);\n  uint32_t dy = (r1->y + r1->h / 2) - (r2->y + r2->h / 2);\n\n  return dx * dx + dy * dy;\n}\n\nstatic bool_t match_up(const rect_t* widget, const rect_t* last_matched, const rect_t* iter) {\n  if ((iter->y + iter->h / 2) > widget->y) {\n    return FALSE;\n  }\n\n  if (last_matched == NULL) {\n    return TRUE;\n  }\n\n  if (is_same_col(widget, iter)) {\n    if (!is_same_col(widget, last_matched)) {\n      return TRUE;\n    } else {\n      return (iter->y + iter->h) > (last_matched->y + last_matched->h);\n    }\n  } else if (is_same_col(widget, last_matched)) {\n    return FALSE;\n  } else {\n    return distance2(widget, iter) < distance2(widget, last_matched);\n  }\n}\n\nstatic bool_t match_down(const rect_t* widget, const rect_t* last_matched, const rect_t* iter) {\n  if ((iter->y + iter->h / 2) < (widget->y + widget->h)) {\n    return FALSE;\n  }\n\n  if (last_matched == NULL) {\n    return TRUE;\n  }\n\n  if (is_same_col(widget, iter)) {\n    if (!is_same_col(widget, last_matched)) {\n      return TRUE;\n    } else {\n      return iter->y < last_matched->y;\n    }\n  } else if (is_same_col(widget, last_matched)) {\n    return FALSE;\n  } else {\n    return distance2(widget, iter) < distance2(widget, last_matched);\n  }\n}\n\nstatic bool_t match_left(const rect_t* widget, const rect_t* last_matched, const rect_t* iter) {\n  if ((iter->x + iter->w / 2) > widget->x) {\n    return FALSE;\n  }\n\n  if (last_matched == NULL) {\n    return TRUE;\n  }\n\n  if (is_same_row(widget, iter)) {\n    if (!is_same_row(widget, last_matched)) {\n      return TRUE;\n    } else {\n      return (iter->x + iter->w) > (last_matched->x + last_matched->w);\n    }\n  } else if (is_same_row(widget, last_matched)) {\n    return FALSE;\n  } else {\n    return distance2(widget, iter) < distance2(widget, last_matched);\n  }\n}\n\nstatic bool_t match_right(const rect_t* widget, const rect_t* last_matched, const rect_t* iter) {\n  if ((iter->x + iter->w / 2) < (widget->x + widget->w)) {\n    return FALSE;\n  }\n\n  if (last_matched == NULL) {\n    return TRUE;\n  }\n\n  if (is_same_row(widget, iter)) {\n    if (!is_same_row(widget, last_matched)) {\n      return TRUE;\n    } else {\n      return iter->x < last_matched->x;\n    }\n  } else if (is_same_row(widget, last_matched)) {\n    return FALSE;\n  } else {\n    return distance2(widget, iter) < distance2(widget, last_matched);\n  }\n}\n\ntypedef bool_t (*match_focus_widget_t)(const rect_t* widget, const rect_t* last_matched,\n                                       const rect_t* iter);\n\nstatic widget_t* widget_find_matched_focus_widget(widget_t* widget, darray_t* all_focusable,\n                                                  match_focus_widget_t match) {\n  uint32_t i = 0;\n  point_t p = {0, 0};\n  widget_t* matched = NULL;\n  rect_t riter = {0, 0, 0, 0};\n  rect_t rwidget = {0, 0, 0, 0};\n  rect_t rmatched = {0, 0, 0, 0};\n\n  widget_to_global(widget, &p);\n  rwidget = rect_init(p.x, p.y, widget->w, widget->h);\n\n  for (i = 0; i < all_focusable->size; i++) {\n    widget_t* iter = WIDGET(all_focusable->elms[i]);\n    if (iter == widget) {\n      continue;\n    }\n\n    p.x = 0;\n    p.y = 0;\n    widget_to_global(iter, &p);\n\n    riter = rect_init(p.x, p.y, iter->w, iter->h);\n    if (match(&rwidget, (matched != NULL ? &rmatched : NULL), &riter)) {\n      matched = iter;\n      rmatched = riter;\n    }\n  }\n\n  return matched;\n}\n\nstatic widget_t* widget_find_up_focus_widget(widget_t* widget, darray_t* all_focusable) {\n  return widget_find_matched_focus_widget(widget, all_focusable, match_up);\n}\n\nstatic widget_t* widget_find_down_focus_widget(widget_t* widget, darray_t* all_focusable) {\n  return widget_find_matched_focus_widget(widget, all_focusable, match_down);\n}\n\nstatic widget_t* widget_find_left_focus_widget(widget_t* widget, darray_t* all_focusable) {\n  return widget_find_matched_focus_widget(widget, all_focusable, match_left);\n}\n\nstatic widget_t* widget_find_right_focus_widget(widget_t* widget, darray_t* all_focusable) {\n  return widget_find_matched_focus_widget(widget, all_focusable, match_right);\n}\n\nret_t widget_move_focus(widget_t* widget, widget_find_wanted_focus_widget_t find) {\n  ret_t ret = RET_FAIL;\n  darray_t all_focusable;\n\n  if (widget == NULL || !widget->focused) {\n    return RET_FAIL;\n  }\n\n  return_value_if_fail(find != NULL, RET_FAIL);\n  return_value_if_fail(darray_init(&all_focusable, 10, NULL, NULL) != NULL, RET_OOM);\n\n  widget_get_all_focusable_widgets_in_window(widget, &all_focusable);\n  if (all_focusable.size > 1) {\n    widget_t* focus = find(widget, &all_focusable);\n\n    if (focus != NULL && focus != widget) {\n      widget_set_prop_bool(widget, WIDGET_PROP_FOCUSED, FALSE);\n      widget_set_prop_bool(focus, WIDGET_PROP_FOCUSED, TRUE);\n      ret = RET_OK;\n    }\n  }\n  darray_deinit(&all_focusable);\n\n  return ret;\n}\n\nret_t widget_focus_prev(widget_t* widget) {\n  return widget_move_focus(widget, widget_find_prev_focus_widget);\n}\n\nret_t widget_focus_next(widget_t* widget) {\n  return widget_move_focus(widget, widget_find_next_focus_widget);\n}\n\nret_t widget_focus_up(widget_t* widget) {\n  return widget_move_focus(widget, widget_find_up_focus_widget);\n}\n\nret_t widget_focus_down(widget_t* widget) {\n  return widget_move_focus(widget, widget_find_down_focus_widget);\n}\n\nret_t widget_focus_left(widget_t* widget) {\n  if (widget_move_focus(widget, widget_find_left_focus_widget) == RET_OK) {\n    return RET_OK;\n  } else {\n    return widget_focus_up(widget);\n  }\n}\n\nret_t widget_focus_right(widget_t* widget) {\n  if (widget_move_focus(widget, widget_find_right_focus_widget) == RET_OK) {\n    return RET_OK;\n  } else {\n    return widget_focus_down(widget);\n  }\n}\n\nbool_t widget_is_window(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  return widget->vt->is_window;\n}\n\nbool_t widget_is_designing_window(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  return widget->vt->is_designing_window;\n}\n\nbool_t widget_is_window_manager(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  return widget->vt->is_window_manager;\n}\n\nret_t widget_set_need_relayout(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n  if (win != NULL) {\n    return window_base_set_need_relayout(win, TRUE);\n  }\n  return RET_OK;\n}\n\nret_t widget_set_need_relayout_children(widget_t* widget) {\n  if (widget_count_children(widget) > 0) {\n    return widget_set_need_relayout(widget);\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_ensure_style_mutable(widget_t* widget) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (widget->astyle == NULL) {\n    widget->astyle = style_mutable_create(NULL);\n    return_value_if_fail(widget->astyle != NULL, RET_OOM);\n  } else if (!style_is_mutable(widget->astyle)) {\n    widget->astyle = style_mutable_create(widget->astyle);\n    return_value_if_fail(widget->astyle != NULL, RET_OOM);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_set_style(widget_t* widget, const char* state_and_name, const value_t* value) {\n  char str[256];\n  uint32_t len = 0;\n  char* name = NULL;\n  char* state = NULL;\n  return_value_if_fail(widget != NULL && state_and_name != NULL && value != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget_ensure_style_mutable(widget) == RET_OK, RET_BAD_PARAMS);\n\n  len = strlen(state_and_name);\n  return_value_if_fail(len < sizeof(str), RET_BAD_PARAMS);\n\n  memcpy(str, state_and_name, len);\n  str[len] = '\\0';\n\n  name = strchr(str, ':');\n  if (name == NULL) {\n    name = strchr(str, '.');\n  }\n\n  if (name != NULL) {\n    *name++ = '\\0';\n    state = str;\n  } else {\n    name = str;\n    state = WIDGET_STATE_NORMAL;\n  }\n\n  widget_invalidate(widget, NULL);\n\n  return style_set(widget->astyle, state, name, value);\n}\n\nret_t widget_set_style_int(widget_t* widget, const char* state_and_name, int32_t value) {\n  value_t v;\n  return_value_if_fail(widget != NULL && state_and_name != NULL, RET_BAD_PARAMS);\n\n  value_set_int(&v, value);\n  return widget_set_style(widget, state_and_name, &v);\n}\n\nret_t widget_set_style_color(widget_t* widget, const char* state_and_name, uint32_t value) {\n  value_t v;\n  return_value_if_fail(widget != NULL && state_and_name != NULL, RET_BAD_PARAMS);\n\n  value_set_int(&v, value);\n  return widget_set_style(widget, state_and_name, &v);\n}\n\nret_t widget_set_style_str(widget_t* widget, const char* state_and_name, const char* value) {\n  value_t v;\n  return_value_if_fail(widget != NULL && state_and_name != NULL && value != NULL, RET_BAD_PARAMS);\n\n  value_set_str(&v, value);\n  return widget_set_style(widget, state_and_name, &v);\n}\n\ncanvas_t* widget_get_canvas(widget_t* widget) {\n  canvas_t* c = NULL;\n  widget_t* wm = window_manager();\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(widget != NULL, NULL);\n\n  if (win == NULL) {\n    win = window_manager_get_top_window(wm);\n  }\n\n  if (win != NULL) {\n    c = (canvas_t*)widget_get_prop_pointer(win, WIDGET_PROP_CANVAS);\n  }\n\n  if (c == NULL) {\n    c = (canvas_t*)widget_get_prop_pointer(wm, WIDGET_PROP_CANVAS);\n  }\n\n  return c;\n}\n\nbool_t widget_is_system_bar(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  return widget->vt->is_window && (tk_str_eq(widget->vt->type, WIDGET_TYPE_SYSTEM_BAR) ||\n                                   tk_str_eq(widget->vt->type, WIDGET_TYPE_SYSTEM_BAR_BOTTOM));\n}\n\nbool_t widget_is_normal_window(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  return widget->vt->is_window && tk_str_eq(widget->vt->type, WIDGET_TYPE_NORMAL_WINDOW);\n}\n\nbool_t widget_is_dialog(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  return widget->vt->is_window && tk_str_eq(widget->vt->type, WIDGET_TYPE_DIALOG);\n}\n\nbool_t widget_is_popup(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  return widget->vt->is_window && tk_str_eq(widget->vt->type, WIDGET_TYPE_POPUP);\n}\n\nbool_t widget_is_overlay(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  return widget->vt->is_window && tk_str_eq(widget->vt->type, WIDGET_TYPE_OVERLAY);\n}\n\nbool_t widget_is_opened_dialog(widget_t* widget) {\n  int32_t stage = widget_get_prop_int(widget, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n  return tk_str_eq(widget->vt->type, WIDGET_TYPE_DIALOG) && stage == WINDOW_STAGE_OPENED;\n}\n\nbool_t widget_is_opened_popup(widget_t* widget) {\n  int32_t stage = widget_get_prop_int(widget, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n  return tk_str_eq(widget->vt->type, WIDGET_TYPE_POPUP) && stage == WINDOW_STAGE_OPENED;\n}\n\nret_t widget_reset_canvas(widget_t* widget) {\n#ifndef AWTK_WEB\n  rect_t rect;\n  canvas_t* c = widget_get_canvas(widget);\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  rect = rect_init(0, 0, canvas_get_width(c), canvas_get_height(c));\n  canvas_set_clip_rect(c, &rect);\n  canvas_reset_font(c);\n\n  return vgcanvas_reset(canvas_get_vgcanvas(c));\n#else\n  (void)widget;\n  return RET_OK;\n#endif /*AWTK_WEB*/\n}\n\nwidget_t* widget_ref(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->ref_count > 0 && widget->vt != NULL, NULL);\n\n  widget->ref_count++;\n\n  return widget;\n}\n\nstatic ret_t widget_unref_in_idle(const idle_info_t* info) {\n  widget_t* widget = WIDGET(info->ctx);\n  return_value_if_fail(widget != NULL && widget->ref_count > 0 && widget->vt != NULL, RET_REMOVE);\n\n  if (widget->ref_count > 1) {\n    return RET_REPEAT;\n  }\n\n  widget_destroy_sync(widget);\n  return RET_REMOVE;\n}\n\nret_t widget_unref(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->ref_count > 0 && widget->vt != NULL,\n                       RET_BAD_PARAMS);\n\n  if (widget->ref_count > 1) {\n    widget->ref_count--;\n  } else if (widget->ref_count == 1) {\n    if (!idle_exist(widget_unref_in_idle, widget)) {\n      widget_destroy_sync(widget);\n    }\n  }\n\n  return RET_OK;\n}\n\nstatic ret_t widget_unref_async(widget_t* widget) {\n  if (!idle_exist(widget_unref_in_idle, widget)) {\n    idle_add(widget_unref_in_idle, widget);\n  }\n\n  return RET_OK;\n}\n\nret_t widget_close_window(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(win != NULL, RET_BAD_PARAMS);\n\n  return window_manager_close_window(win->parent, win);\n}\n\nret_t widget_close_window_force(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(win != NULL, RET_BAD_PARAMS);\n\n  return window_manager_close_window_force(win->parent, win);\n}\n\nret_t widget_back(widget_t* widget) {\n  widget_t* wm = widget_get_window_manager(widget);\n  return_value_if_fail(wm != NULL, RET_BAD_PARAMS);\n\n  return window_manager_back(wm);\n}\n\nret_t widget_back_to_home(widget_t* widget) {\n  widget_t* wm = widget_get_window_manager(widget);\n  return_value_if_fail(wm != NULL, RET_BAD_PARAMS);\n\n  return window_manager_back_to_home(wm);\n}\n\n#if defined(FRAGMENT_FRAME_BUFFER_SIZE)\nbitmap_t* widget_take_snapshot_rect(widget_t* widget, const rect_t* r) {\n  log_warn(\"not supported yet\\n\");\n  return NULL;\n}\n\n#elif defined(WITH_GPU)\n\nbitmap_t* widget_take_snapshot_rect(widget_t* widget, const rect_t* r) {\n  bitmap_t* img;\n  uint32_t w = 0;\n  uint32_t h = 0;\n  canvas_t* c = NULL;\n  vgcanvas_t* vg = NULL;\n  framebuffer_object_t fbo;\n\n  native_window_t* native_window =\n      (native_window_t*)widget_get_prop_pointer(window_manager(), WIDGET_PROP_NATIVE_WINDOW);\n  return_value_if_fail(native_window != NULL, NULL);\n\n  c = native_window_get_canvas(native_window);\n  vg = lcd_get_vgcanvas(c->lcd);\n  return_value_if_fail(c != NULL && vg != NULL, NULL);\n\n  vgcanvas_create_fbo(vg, vg->w, vg->h, FALSE, &fbo);\n  vgcanvas_bind_fbo(vg, &fbo);\n  canvas_set_clip_rect(c, r);\n  widget_paint(widget, c);\n  vgcanvas_unbind_fbo(vg, &fbo);\n\n  if (r != NULL) {\n    w = r->w;\n    h = r->h;\n  } else {\n    w = fbo.w;\n    h = fbo.h;\n  }\n\n  img = bitmap_create_ex(w * fbo.ratio, h * fbo.ratio, 0, BITMAP_FMT_RGBA8888);\n  vgcanvas_fbo_to_bitmap(vg, &fbo, img, r);\n\n  vgcanvas_destroy_fbo(vg, &fbo);\n\n  return img;\n}\n\n#else\n#include \"lcd/lcd_mem_rgba8888.h\"\nbitmap_t* widget_take_snapshot_rect(widget_t* widget, const rect_t* r) {\n  wh_t w = 0;\n  wh_t h = 0;\n  canvas_t canvas;\n  lcd_t* lcd = NULL;\n  canvas_t* c = NULL;\n  uint8_t* buff = NULL;\n  bitmap_t* bitmap = NULL;\n  bitmap_t* bitmap_clip = NULL;\n  native_window_t* native_window = NULL;\n  return_value_if_fail(widget != NULL && widget->vt != NULL, NULL);\n\n  native_window =\n      (native_window_t*)widget_get_prop_pointer(window_manager(), WIDGET_PROP_NATIVE_WINDOW);\n  return_value_if_fail(native_window != NULL, NULL);\n\n  c = native_window_get_canvas(native_window);\n  return_value_if_fail(c != NULL, NULL);\n\n  w = widget->w;\n  h = widget->h;\n\n  bitmap = bitmap_create_ex(w, h, w * 4, BITMAP_FMT_RGBA8888);\n  return_value_if_fail(bitmap != NULL, NULL);\n\n  buff = bitmap_lock_buffer_for_write(bitmap);\n  lcd = lcd_mem_rgba8888_create_single_fb(w, h, buff);\n  if (lcd != NULL) {\n    canvas_init(&canvas, lcd, font_manager());\n    canvas_begin_frame(&canvas, NULL, LCD_DRAW_OFFLINE);\n    widget_paint_with_clip(widget, (rect_t*)r, &canvas, widget_paint);\n    canvas_end_frame(&canvas);\n    canvas_reset(&canvas);\n    lcd_destroy(lcd);\n  }\n\n  bitmap_unlock_buffer(bitmap);\n\n  if (r != NULL) {\n    rect_t widget_rect = rect_init(0, 0, widget->w, widget->h);\nrect_t clip_r = ",
    "raw_res": "{r->x, r->y, r->w, r->h};",
    "prompt_res": "rect_intersect(&widget_rect, r);",
    "gt": "rect_intersect(&widget_rect, r);"
  },
  {
    "id": 2555,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/widgets/win/lv_win.c",
    "input": "/**\n * @file lv_win.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n#include \"lv_win.h\"\n#if LV_USE_WIN\n\n\n/*********************\n *      DEFINES\n *********************/\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic void lv_win_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\nconst lv_obj_class_t lv_win_class = {\n    .constructor_cb = lv_win_constructor,\n    .width_def = LV_PCT(100),\n    .height_def = LV_PCT(100),\n    .base_class = &lv_obj_class,\n    .instance_size = sizeof(lv_win_t)\n};\nstatic lv_coord_t create_header_height;\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\nlv_obj_t * lv_win_create(lv_obj_t * parent, lv_coord_t header_height)\n{\n    LV_LOG_INFO(\"begin\");\n    create_header_height = header_height;\n\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_win_class, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}\n\nlv_obj_t * lv_win_add_title(lv_obj_t * win, const char * txt)\n{\n    lv_obj_t * header = lv_win_get_header(win);\n    lv_obj_t * title = lv_label_create(header);\n    lv_label_set_long_mode(title, LV_LABEL_LONG_DOT);\n    lv_label_set_text(title, txt);\n    lv_obj_set_flex_grow(title, 1);\n    return title;\n}\n\nlv_obj_t * lv_win_add_btn(lv_obj_t * win, const void * icon, lv_coord_t btn_w)\n{\n    lv_obj_t * header = lv_win_get_header(win);\n    lv_obj_t * btn = lv_btn_create(header);\n    lv_obj_set_size(btn, btn_w, LV_PCT(100));\n\n    lv_obj_t * img = lv_img_create(btn);\n    lv_img_set_src(img, icon);\n    lv_obj_align(img, LV_ALIGN_CENTER, 0, 0);\n\n    return btn;\n}\n\nlv_obj_t * lv_win_get_header(lv_obj_t * win)\n{\n    return lv_obj_get_child(win, 0);\n}\n\nlv_obj_t * lv_win_get_content(lv_obj_t * win)\n{\n    return lv_obj_get_child(win, 1);\n}\n\n/**********************\n *   STATIC FUNCTIONS\n **********************/\n\nstatic void lv_win_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)\n{\n    LV_UNUSED(class_p);\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    lv_obj_set_size(obj, lv_obj_get_width(parent), lv_obj_get_height(parent));\n    lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_COLUMN);\n\nlv_obj_t * header = ",
    "raw_res": "lv_win_get_header(obj);",
    "prompt_res": "lv_obj_create(obj);",
    "gt": "lv_obj_create(obj);"
  },
  {
    "id": 2621,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/widgets/imgbtn/lv_imgbtn.c",
    "input": "/**\n * @file lv_imgbtn.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n\n#include \"lv_imgbtn.h\"\n\n#if LV_USE_IMGBTN != 0\n\n/*********************\n *      DEFINES\n *********************/\n#define MY_CLASS &lv_imgbtn_class\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic void lv_imgbtn_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void draw_main(lv_event_t * e);\nstatic void lv_imgbtn_event(const lv_obj_class_t * class_p, lv_event_t * e);\nstatic void refr_img(lv_obj_t * imgbtn);\nstatic lv_imgbtn_state_t suggest_state(lv_obj_t * imgbtn, lv_imgbtn_state_t state);\nlv_imgbtn_state_t get_state(const lv_obj_t * imgbtn);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\nconst lv_obj_class_t lv_imgbtn_class = {\n    .base_class = &lv_obj_class,\n    .instance_size = sizeof(lv_imgbtn_t),\n    .constructor_cb = lv_imgbtn_constructor,\n    .event_cb = lv_imgbtn_event,\n};\n\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\n/**\n * Create a image button object\n * @param par pointer to an object, it will be the parent of the new image button\n * @return pointer to the created image button\n */\nlv_obj_t * lv_imgbtn_create(lv_obj_t * parent)\n{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}\n\n/*=====================\n * Setter functions\n *====================*/\n\n/**\n * Set images for a state of the image button\n * @param imgbtn pointer to an image button object\n * @param state for which state set the new image\n * @param src_left pointer to an image source for the left side of the button (a C array or path to\n * a file)\n * @param src_mid pointer to an image source for the middle of the button (ideally 1px wide) (a C\n * array or path to a file)\n * @param src_right pointer to an image source for the right side of the button (a C array or path\n * to a file)\n */\nvoid lv_imgbtn_set_src(lv_obj_t * obj, lv_imgbtn_state_t state, const void * src_left, const void * src_mid,\n                       const void * src_right)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_imgbtn_t * imgbtn = (lv_imgbtn_t *)obj;\n\n    imgbtn->img_src_left[state] = src_left;\n    imgbtn->img_src_mid[state] = src_mid;\n    imgbtn->img_src_right[state] = src_right;\n\n    refr_img(obj);\n}\n\nvoid lv_imgbtn_set_state(lv_obj_t * obj, lv_imgbtn_state_t state)\n{\n\tLV_ASSERT_OBJ(obj, MY_CLASS);\n\n\tlv_state_t obj_state = LV_STATE_DEFAULT;\n\tif(state == LV_IMGBTN_STATE_PRESSED || state == LV_IMGBTN_STATE_CHECKED_PRESSED) obj_state |= LV_STATE_PRESSED;\n\tif(state == LV_IMGBTN_STATE_DISABLED || state == LV_IMGBTN_STATE_CHECKED_DISABLED) obj_state |= LV_STATE_DISABLED;\n\tif(state == LV_IMGBTN_STATE_CHECKED_DISABLED || state == LV_IMGBTN_STATE_CHECKED_PRESSED || state == LV_IMGBTN_STATE_CHECKED_RELEASED) {\n\t\tobj_state |= LV_STATE_CHECKED;\n\t}\n\n\tlv_obj_clear_state(obj, LV_STATE_CHECKED | LV_STATE_PRESSED | LV_STATE_DISABLED);\n\tlv_obj_add_state(obj, obj_state);\n\n\trefr_img(obj);\n}\n\n/*=====================\n * Getter functions\n *====================*/\n\n\n/**\n * Get the left image in a given state\n * @param imgbtn pointer to an image button object\n * @param state the state where to get the image (from `lv_btn_state_t`) `\n * @return pointer to the left image source (a C array or path to a file)\n */\nconst void * lv_imgbtn_get_src_left(lv_obj_t * obj, lv_imgbtn_state_t state)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_imgbtn_t * imgbtn = (lv_imgbtn_t *)obj;\n\n    return imgbtn->img_src_left[state];\n}\n\n/**\n * Get the middle image in a given state\n * @param imgbtn pointer to an image button object\n * @param state the state where to get the image (from `lv_btn_state_t`) `\n * @return pointer to the middle image source (a C array or path to a file)\n */\nconst void * lv_imgbtn_get_src_middle(lv_obj_t * obj, lv_imgbtn_state_t state)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_imgbtn_t * imgbtn = (lv_imgbtn_t *)obj;\n\n    return imgbtn->img_src_mid[state];\n}\n\n/**\n * Get the right image in a given state\n * @param imgbtn pointer to an image button object\n * @param state the state where to get the image (from `lv_btn_state_t`) `\n * @return pointer to the left image source (a C array or path to a file)\n */\nconst void * lv_imgbtn_get_src_right(lv_obj_t * obj, lv_imgbtn_state_t state)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_imgbtn_t * imgbtn = (lv_imgbtn_t *)obj;\n\n    return imgbtn->img_src_right[state];\n}\n\n\n/**********************\n *   STATIC FUNCTIONS\n **********************/\n\nstatic void lv_imgbtn_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)\n{\n    LV_UNUSED(class_p);\n    lv_imgbtn_t * imgbtn = (lv_imgbtn_t *)obj;\n    /*Initialize the allocated 'ext'*/\n    lv_memset_00((void *)imgbtn->img_src_mid, sizeof(imgbtn->img_src_mid));\n    lv_memset_00(imgbtn->img_src_left, sizeof(imgbtn->img_src_left));\n    lv_memset_00(imgbtn->img_src_right, sizeof(imgbtn->img_src_right));\n\n    imgbtn->act_cf = LV_IMG_CF_UNKNOWN;\n}\n\n\nstatic void lv_imgbtn_event(const lv_obj_class_t * class_p, lv_event_t * e)\n{\n    LV_UNUSED(class_p);\n\n    lv_res_t res = lv_obj_event_base(&lv_imgbtn_class, e);\n    if(res != LV_RES_OK) return;\n\nlv_event_code_t code = ",
    "raw_res": "e->code;",
    "prompt_res": "lv_event_get_code(e);",
    "gt": "lv_event_get_code(e);"
  },
  {
    "id": 2668,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/widgets/tabview/lv_tabview.c",
    "input": "/**\n * @file lv_tabview.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n#include \"lv_tabview.h\"\n#if LV_USE_TABVIEW\n\n#include \"../../../misc/lv_assert.h\"\n\n/*********************\n *      DEFINES\n *********************/\n#define MY_CLASS    &lv_tabview_class\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic void lv_tabview_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void lv_tabview_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void lv_tabview_event(const lv_obj_class_t * class_p, lv_event_t * e);\nstatic void btns_value_changed_event_cb(lv_event_t * e);\nstatic void cont_scroll_end_event_cb(lv_event_t * e);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\nconst lv_obj_class_t lv_tabview_class = {\n    .constructor_cb = lv_tabview_constructor,\n    .destructor_cb = lv_tabview_destructor,\n    .event_cb = lv_tabview_event,\n    .width_def = LV_PCT(100),\n    .height_def = LV_PCT(100),\n    .base_class = &lv_obj_class,\n    .instance_size = sizeof(lv_tabview_t)\n};\n\nstatic lv_dir_t tabpos_create;\nstatic lv_coord_t tabsize_create;\n\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\nlv_obj_t * lv_tabview_create(lv_obj_t * parent, lv_dir_t tab_pos, lv_coord_t tab_size)\n{\n    LV_LOG_INFO(\"begin\");\n    tabpos_create = tab_pos;\n    tabsize_create = tab_size;\n\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_tabview_class, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}\n\nlv_obj_t * lv_tabview_add_tab(lv_obj_t * obj, const char * name)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_tabview_t * tabview = (lv_tabview_t *)obj;\n    lv_obj_t * cont = lv_tabview_get_content(obj);\n\n    lv_obj_t * page = lv_obj_create(cont);\n    lv_obj_set_size(page, LV_PCT(100), LV_PCT(100));\n    lv_obj_clear_flag(page, LV_OBJ_FLAG_CLICK_FOCUSABLE);\n    uint32_t tab_id = lv_obj_get_child_cnt(cont);\n\n    lv_obj_t * btns = lv_tabview_get_tab_btns(obj);\n\n    char ** old_map = tabview->map;\n    char ** new_map;\n\n    /*top or bottom dir*/\n    if(tabview->tab_pos & LV_DIR_VER) {\n        new_map = lv_mem_alloc((tab_id + 1) * sizeof(const char *));\n        lv_memcpy_small(new_map, old_map, sizeof(const char *) * (tab_id - 1));\n        new_map[tab_id - 1] = lv_mem_alloc(strlen(name) + 1);\n        strcpy((char *)new_map[tab_id - 1], name);\n        new_map[tab_id] = \"\";\n    }\n    /*left or right dir*/\n    else {\n        new_map = lv_mem_alloc((tab_id * 2) * sizeof(const char *));\n        lv_memcpy_small(new_map, old_map, sizeof(const char *) * (tab_id - 1) * 2);\n        if(tabview->tab_cnt == 0) {\n            new_map[0] = lv_mem_alloc(strlen(name) + 1);\n            strcpy((char *)new_map[0], name);\n            new_map[1] = \"\";\n        }\n        else {\n            new_map[tab_id * 2 - 3] = \"\\n\";\n            new_map[tab_id * 2 - 2] = lv_mem_alloc(strlen(name) + 1);\n            new_map[tab_id * 2 - 1] = \"\";\n            strcpy((char *)new_map[(tab_id * 2) - 2], name);\n        }\n    }\n    tabview->map = new_map;\n    lv_btnmatrix_set_map(btns, (const char **)new_map);\n    lv_mem_free(old_map);\n\n    lv_btnmatrix_set_btn_ctrl_all(btns, LV_BTNMATRIX_CTRL_CHECKABLE | LV_BTNMATRIX_CTRL_CLICK_TRIG |\n                                  LV_BTNMATRIX_CTRL_NO_REPEAT);\n\n    tabview->tab_cnt++;\n    if(tabview->tab_cnt == 1) {\n        lv_tabview_set_act(obj, 0, LV_ANIM_OFF);\n    }\n\n    lv_btnmatrix_set_btn_ctrl(btns, tabview->tab_cur, LV_BTNMATRIX_CTRL_CHECKED);\n\n    return page;\n}\n\nvoid lv_tabview_set_act(lv_obj_t * obj, uint32_t id, lv_anim_enable_t anim_en)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_tabview_t * tabview = (lv_tabview_t *)obj;\n\n    if(id >= tabview->tab_cnt) {\n        id = tabview->tab_cnt - 1;\n    }\n\n    /*To be sure lv_obj_get_content_width will return valid value*/\n    lv_obj_update_layout(obj);\n\n    lv_obj_t * cont = lv_tabview_get_content(obj);\n    if(cont == NULL) return;\n    lv_coord_t gap = lv_obj_get_style_pad_column(cont, LV_PART_MAIN);\n    lv_coord_t w = lv_obj_get_content_width(cont);\n    if(lv_obj_get_style_base_dir(obj, LV_PART_MAIN) != LV_BASE_DIR_RTL) {\n        lv_obj_scroll_to_x(cont, id * (gap + w), anim_en);\n    }\n    else {\n        int32_t id_rtl = -(int32_t)id;\n        lv_obj_scroll_to_x(cont, (gap + w) * id_rtl, anim_en);\n    }\n\n    lv_obj_t * btns = lv_tabview_get_tab_btns(obj);\n    lv_btnmatrix_set_btn_ctrl(btns, id, LV_BTNMATRIX_CTRL_CHECKED);\n    tabview->tab_cur = id;\n}\n\nuint16_t lv_tabview_get_tab_act(lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_tabview_t * tabview = (lv_tabview_t *)obj;\n    return tabview->tab_cur;\n}\n\nlv_obj_t * lv_tabview_get_content(lv_obj_t * tv)\n{\n    return lv_obj_get_child(tv, 1);\n}\n\nlv_obj_t * lv_tabview_get_tab_btns(lv_obj_t * tv)\n{\n    return lv_obj_get_child(tv, 0);\n}\n\n/**********************\n *   STATIC FUNCTIONS\n **********************/\n\nstatic void lv_tabview_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)\n{\n    LV_UNUSED(class_p);\n    lv_tabview_t * tabview = (lv_tabview_t *)obj;\n\n    tabview->tab_pos = tabpos_create;\n\n    switch(tabview->tab_pos) {\n        case LV_DIR_TOP:\n            lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_COLUMN);\n            break;\n        case LV_DIR_BOTTOM:\n            lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_COLUMN_REVERSE);\n            break;\n        case LV_DIR_LEFT:\n            lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_ROW);\n            break;\n        case LV_DIR_RIGHT:\n            lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_ROW_REVERSE);\n            break;\n    }\n\n    lv_obj_set_size(obj, LV_PCT(100), LV_PCT(100));\n\n    lv_obj_t * btnm;\n    lv_obj_t * cont;\n\n    btnm = lv_btnmatrix_create(obj);\n    cont = lv_obj_create(obj);\n\n    lv_btnmatrix_set_one_checked(btnm, true);\n    tabview->map = lv_mem_alloc(sizeof(const char *));\n    tabview->map[0] = \"\";\n    lv_btnmatrix_set_map(btnm, (const char **)tabview->map);\n    lv_obj_add_event_cb(btnm, btns_value_changed_event_cb, LV_EVENT_VALUE_CHANGED, NULL);\n    lv_obj_add_flag(btnm, LV_OBJ_FLAG_EVENT_BUBBLE);\n\n    lv_obj_add_event_cb(cont, cont_scroll_end_event_cb, LV_EVENT_ALL, NULL);\n    lv_obj_set_scrollbar_mode(cont, LV_SCROLLBAR_MODE_OFF);\n\n    switch(tabview->tab_pos) {\n        case LV_DIR_TOP:\n        case LV_DIR_BOTTOM:\n            lv_obj_set_size(btnm, LV_PCT(100), tabsize_create);\n            lv_obj_set_width(cont, LV_PCT(100));\n            lv_obj_set_flex_grow(cont, 1);\n            break;\n        case LV_DIR_LEFT:\n        case LV_DIR_RIGHT:\n            lv_obj_set_size(btnm, tabsize_create, LV_PCT(100));\n            lv_obj_set_height(cont, LV_PCT(100));\n            lv_obj_set_flex_grow(cont, 1);\n            break;\n    }\n\n    lv_group_t * g = lv_group_get_default();\n    if(g) lv_group_add_obj(g, btnm);\n\n    lv_obj_set_flex_flow(cont, LV_FLEX_FLOW_ROW);\n    lv_obj_set_scroll_snap_x(cont, LV_SCROLL_SNAP_CENTER);\n    lv_obj_add_flag(cont, LV_OBJ_FLAG_SCROLL_ONE);\n    lv_obj_clear_flag(cont, LV_OBJ_FLAG_SCROLL_ON_FOCUS);\n}\n\nstatic void lv_tabview_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)\n{\n    LV_UNUSED(class_p);\n    lv_tabview_t * tabview = (lv_tabview_t *)obj;\n\n    uint32_t i;\n    if(tabview->tab_pos & LV_DIR_VER) {\n        for(i = 0; i < tabview->tab_cnt; i++) {\n            lv_mem_free(tabview->map[i]);\n            tabview->map[i] = NULL;\n        }\n    }\n    if(tabview->tab_pos & LV_DIR_HOR) {\n        for(i = 0; i < tabview->tab_cnt; i++) {\n            lv_mem_free(tabview->map[i * 2]);\n            tabview->map[i * 2] = NULL;\n        }\n    }\n\n\n    lv_mem_free(tabview->map);\n    tabview->map = NULL;\n}\n\nstatic void lv_tabview_event(const lv_obj_class_t * class_p, lv_event_t * e)\n{\n    LV_UNUSED(class_p);\n    lv_res_t res = lv_obj_event_base(&lv_tabview_class, e);\n    if(res != LV_RES_OK) return;\n\nlv_event_code_t code = ",
    "raw_res": "e->code;",
    "prompt_res": "lv_event_get_code(e);",
    "gt": "lv_event_get_code(e);"
  },
  {
    "id": 2690,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/widgets/meter/lv_meter.c",
    "input": "/**\n * @file lv_meter.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n#include \"lv_meter.h\"\n#if LV_USE_METER != 0\n\n#include \"../../../misc/lv_assert.h\"\n\n/*********************\n *      DEFINES\n *********************/\n#define MY_CLASS &lv_meter_class\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic void lv_meter_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void lv_meter_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void lv_meter_event(const lv_obj_class_t * class_p, lv_event_t * e);\nstatic void draw_arcs(lv_obj_t * obj, const lv_area_t * clip_area, const lv_area_t * scale_area);\nstatic void draw_ticks_and_labels(lv_obj_t * obj, const lv_area_t * clip_area, const lv_area_t * scale_area);\nstatic void draw_needles(lv_obj_t * obj, const lv_area_t * clip_area, const lv_area_t * scale_area);\nstatic void inv_arc(lv_obj_t * obj, lv_meter_indicator_t * indic, int32_t old_value, int32_t new_value);\nstatic void inv_line(lv_obj_t * obj, lv_meter_indicator_t * indic, int32_t value);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\nconst lv_obj_class_t lv_meter_class = {\n    .constructor_cb = lv_meter_constructor,\n    .destructor_cb = lv_meter_destructor,\n    .event_cb = lv_meter_event,\n    .instance_size = sizeof(lv_meter_t),\n    .base_class = &lv_obj_class\n};\n\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\nlv_obj_t * lv_meter_create(lv_obj_t * parent)\n{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}\n\n/*=====================\n * Add scale\n *====================*/\n\nlv_meter_scale_t * lv_meter_add_scale(lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_meter_t * meter = (lv_meter_t *)obj;\n\n    lv_meter_scale_t * scale = _lv_ll_ins_head(&meter->scale_ll);\n    LV_ASSERT_MALLOC(scale);\n    lv_memset_00(scale, sizeof(lv_meter_scale_t));\n\n    scale->angle_range = 270;\n    scale->rotation = 90 + (360 - scale->angle_range) / 2;\n    scale->min = 0;\n    scale->max = 100;\n    scale->tick_cnt = 6;\n    scale->tick_length = 8;\n    scale->tick_width = 2;\n    scale->label_gap = 2;\n\n    return scale;\n}\n\nvoid lv_meter_set_scale_ticks(lv_obj_t * obj, lv_meter_scale_t * scale, uint16_t cnt, uint16_t width, uint16_t len,\n                              lv_color_t color)\n{\n    scale->tick_cnt = cnt;\n    scale->tick_width = width;\n    scale->tick_length = len;\n    scale->tick_color = color;\n    lv_obj_invalidate(obj);\n}\n\nvoid lv_meter_set_scale_major_ticks(lv_obj_t * obj, lv_meter_scale_t * scale, uint16_t nth, uint16_t width,\n                                    uint16_t len, lv_color_t color, int16_t label_gap)\n{\n    scale->tick_major_nth = nth;\n    scale->tick_major_width = width;\n    scale->tick_major_length = len;\n    scale->tick_major_color = color;\n    scale->label_gap = label_gap;\n    lv_obj_invalidate(obj);\n}\n\nvoid lv_meter_set_scale_range(lv_obj_t * obj, lv_meter_scale_t * scale, int32_t min, int32_t max, uint32_t angle_range,\n                              uint32_t rotation)\n{\n    scale->min = min;\n    scale->max = max;\n    scale->angle_range = angle_range;\n    scale->rotation = rotation;\n    lv_obj_invalidate(obj);\n}\n\n/*=====================\n * Add indicator\n *====================*/\n\nlv_meter_indicator_t * lv_meter_add_needle_line(lv_obj_t * obj, lv_meter_scale_t * scale, uint16_t width,\n                                                lv_color_t color, int16_t r_mod)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_meter_t * meter = (lv_meter_t *)obj;\n    lv_meter_indicator_t * indic = _lv_ll_ins_head(&meter->indicator_ll);\n    LV_ASSERT_MALLOC(indic);\n    lv_memset_00(indic, sizeof(lv_meter_indicator_t));\n    indic->scale = scale;\n    indic->opa = LV_OPA_COVER;\n\n    indic->type = LV_METER_INDICATOR_TYPE_NEEDLE_LINE;\n    indic->type_data.needle_line.width = width;\n    indic->type_data.needle_line.color = color;\n    indic->type_data.needle_line.r_mod = r_mod;\n    lv_obj_invalidate(obj);\n\n    return indic;\n}\n\nlv_meter_indicator_t * lv_meter_add_needle_img(lv_obj_t * obj, lv_meter_scale_t * scale, const void * src,\n                                               lv_coord_t pivot_x, lv_coord_t pivot_y)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_meter_t * meter = (lv_meter_t *)obj;\n    lv_meter_indicator_t * indic = _lv_ll_ins_head(&meter->indicator_ll);\n    LV_ASSERT_MALLOC(indic);\n    lv_memset_00(indic, sizeof(lv_meter_indicator_t));\n    indic->scale = scale;\n    indic->opa = LV_OPA_COVER;\n\n    indic->type = LV_METER_INDICATOR_TYPE_NEEDLE_IMG;\n    indic->type_data.needle_img.src = src;\n    indic->type_data.needle_img.pivot.x = pivot_x;\n    indic->type_data.needle_img.pivot.y = pivot_y;\n    lv_obj_invalidate(obj);\n\n    return indic;\n}\n\nlv_meter_indicator_t * lv_meter_add_arc(lv_obj_t * obj, lv_meter_scale_t * scale, uint16_t width, lv_color_t color,\n                                        int16_t r_mod)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_meter_t * meter = (lv_meter_t *)obj;\n    lv_meter_indicator_t * indic = _lv_ll_ins_head(&meter->indicator_ll);\n    LV_ASSERT_MALLOC(indic);\n    lv_memset_00(indic, sizeof(lv_meter_indicator_t));\n    indic->scale = scale;\n    indic->opa = LV_OPA_COVER;\n\n    indic->type = LV_METER_INDICATOR_TYPE_ARC;\n    indic->type_data.arc.width = width;\n    indic->type_data.arc.color = color;\n    indic->type_data.arc.r_mod = r_mod;\n\n    lv_obj_invalidate(obj);\n    return indic;\n}\n\nlv_meter_indicator_t * lv_meter_add_scale_lines(lv_obj_t * obj, lv_meter_scale_t * scale, lv_color_t color_start,\n                                                lv_color_t color_end, bool local, int16_t width_mod)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_meter_t * meter = (lv_meter_t *)obj;\n    lv_meter_indicator_t * indic = _lv_ll_ins_head(&meter->indicator_ll);\n    LV_ASSERT_MALLOC(indic);\n    lv_memset_00(indic, sizeof(lv_meter_indicator_t));\n    indic->scale = scale;\n    indic->opa = LV_OPA_COVER;\n\n    indic->type = LV_METER_INDICATOR_TYPE_SCALE_LINES;\n    indic->type_data.scale_lines.color_start = color_start;\n    indic->type_data.scale_lines.color_end = color_end;\n    indic->type_data.scale_lines.local_grad = local;\n    indic->type_data.scale_lines.width_mod = width_mod;\n\n    lv_obj_invalidate(obj);\n    return indic;\n}\n\n/*=====================\n * Set indicator value\n *====================*/\n\nvoid lv_meter_set_indicator_value(lv_obj_t * obj, lv_meter_indicator_t * indic, int32_t value)\n{\n    int32_t old_start = indic->start_value;\n    int32_t old_end = indic->end_value;\n    indic->start_value = value;\n    indic->end_value = value;\n\n    if(indic->type == LV_METER_INDICATOR_TYPE_ARC) {\n        inv_arc(obj, indic, old_start, value);\n        inv_arc(obj, indic, old_end, value);\n    }\n    else if(indic->type == LV_METER_INDICATOR_TYPE_NEEDLE_IMG || indic->type == LV_METER_INDICATOR_TYPE_NEEDLE_LINE) {\n        inv_line(obj, indic, old_start);\n        inv_line(obj, indic, old_end);\n        inv_line(obj, indic, value);\n    }\n    else {\n        lv_obj_invalidate(obj);\n    }\n}\n\nvoid lv_meter_set_indicator_start_value(lv_obj_t * obj, lv_meter_indicator_t * indic, int32_t value)\n{\n    int32_t old_value = indic->start_value;\n    indic->start_value = value;\n\n    if(indic->type == LV_METER_INDICATOR_TYPE_ARC) {\n        inv_arc(obj, indic, old_value, value);\n    }\n    else if(indic->type == LV_METER_INDICATOR_TYPE_NEEDLE_IMG || indic->type == LV_METER_INDICATOR_TYPE_NEEDLE_LINE) {\n        inv_line(obj, indic, old_value);\n        inv_line(obj, indic, value);\n    }\n    else {\n        lv_obj_invalidate(obj);\n    }\n}\n\nvoid lv_meter_set_indicator_end_value(lv_obj_t * obj, lv_meter_indicator_t * indic, int32_t value)\n{\n    int32_t old_value = indic->end_value;\n    indic->end_value = value;\n\n    if(indic->type == LV_METER_INDICATOR_TYPE_ARC) {\n        inv_arc(obj, indic, old_value, value);\n    }\n    else if(indic->type == LV_METER_INDICATOR_TYPE_NEEDLE_IMG || indic->type == LV_METER_INDICATOR_TYPE_NEEDLE_LINE) {\n        inv_line(obj, indic, old_value);\n        inv_line(obj, indic, value);\n    }\n    else {\n        lv_obj_invalidate(obj);\n    }\n}\n\n/**********************\n *   STATIC FUNCTIONS\n **********************/\n\nstatic void lv_meter_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)\n{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_meter_t * meter = (lv_meter_t *)obj;\n\n    _lv_ll_init(&meter->scale_ll, sizeof(lv_meter_scale_t));\n    _lv_ll_init(&meter->indicator_ll, sizeof(lv_meter_indicator_t));\n\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}\n\nstatic void lv_meter_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)\n{\n    LV_UNUSED(class_p);\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_meter_t * meter = (lv_meter_t *)obj;\n    _lv_ll_clear(&meter->indicator_ll);\n    _lv_ll_clear(&meter->scale_ll);\n\n}\n\nstatic void lv_meter_event(const lv_obj_class_t * class_p, lv_event_t * e)\n{\n    LV_UNUSED(class_p);\n\n    lv_res_t res = lv_obj_event_base(MY_CLASS, e);\n    if(res != LV_RES_OK) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n    if(code == LV_EVENT_DRAW_MAIN) {\n        const lv_area_t * clip_area = lv_event_get_param(e);\n        lv_area_t scale_area;\n        lv_obj_get_content_coords(obj, &scale_area);\n\n        draw_arcs(obj, clip_area, &scale_area);\n        draw_ticks_and_labels(obj, clip_area, &scale_area);\n        draw_needles(obj, clip_area, &scale_area);\n\n        lv_coord_t r_edge = lv_area_get_width(&scale_area) / 2;\n        lv_point_t scale_center;\n        scale_center.x = scale_area.x1 + r_edge;\n        scale_center.y = scale_area.y1 + r_edge;\n\n        lv_draw_rect_dsc_t mid_dsc;\n        lv_draw_rect_dsc_init(&mid_dsc);\n        lv_obj_init_draw_rect_dsc(obj, LV_PART_INDICATOR, &mid_dsc);\n        lv_coord_t w = lv_obj_get_style_width(obj, LV_PART_INDICATOR) / 2;\n        lv_coord_t h = lv_obj_get_style_height(obj, LV_PART_INDICATOR) / 2;\n        lv_area_t nm_cord;\n        nm_cord.x1 = scale_center.x - w;\n        nm_cord.y1 = scale_center.y - h;\n        nm_cord.x2 = scale_center.x + w;\n        nm_cord.y2 = scale_center.y + h;\n        lv_draw_rect(&nm_cord, clip_area, &mid_dsc);\n    }\n}\n\nstatic void draw_arcs(lv_obj_t * obj, const lv_area_t * clip_area, const lv_area_t * scale_area)\n{\n    lv_meter_t * meter = (lv_meter_t *)obj;\n\n    lv_draw_arc_dsc_t arc_dsc;\n    lv_draw_arc_dsc_init(&arc_dsc);\n    arc_dsc.rounded = lv_obj_get_style_arc_rounded(obj, LV_PART_ITEMS);\n\n    lv_coord_t r_out = lv_area_get_width(scale_area) / 2 ;\n    lv_point_t scale_center;\n    scale_center.x = scale_area->x1 + r_out;\n    scale_center.y = scale_area->y1 + r_out;\n\n    lv_opa_t opa_main = lv_obj_get_style_opa(obj, LV_PART_MAIN);\n    lv_meter_indicator_t * indic;\n\n    lv_obj_draw_part_dsc_t part_draw_dsc;\n    lv_obj_draw_dsc_init(&part_draw_dsc, clip_area);\n    part_draw_dsc.arc_dsc = &arc_dsc;\n    part_draw_dsc.part = LV_PART_INDICATOR;\n    part_draw_dsc.class_p = MY_CLASS;\n    part_draw_dsc.type = LV_METER_DRAW_PART_ARC;\n\n    _LV_LL_READ_BACK(&meter->indicator_ll, indic) {\n        if(indic->type != LV_METER_INDICATOR_TYPE_ARC) continue;\n\n        arc_dsc.color = indic->type_data.arc.color;\n        arc_dsc.width = indic->type_data.arc.width;\n        arc_dsc.opa = indic->opa > LV_OPA_MAX ? opa_main : (opa_main * indic->opa) >> 8;\n\n        lv_meter_scale_t * scale = indic->scale;\n\n        int32_t start_angle = lv_map(indic->start_value, scale->min, scale->max, scale->rotation,\n                                     scale->rotation + scale->angle_range);\n        int32_t end_angle = lv_map(indic->end_value, scale->min, scale->max, scale->rotation,\n                                   scale->rotation + scale->angle_range);\n\n        part_draw_dsc.radius = r_out + indic->type_data.arc.r_mod;\n        part_draw_dsc.sub_part_ptr = indic;\n        part_draw_dsc.p1 = &scale_center;\n\n        lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n        lv_draw_arc(scale_center.x, scale_center.y, part_draw_dsc.radius, start_angle, end_angle, clip_area, &arc_dsc);\n        lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n    }\n}\n\nstatic void draw_ticks_and_labels(lv_obj_t * obj, const lv_area_t * clip_area, const lv_area_t * scale_area)\n{\n    lv_meter_t * meter    = (lv_meter_t *)obj;\n\n    lv_point_t p_center;\n    lv_coord_t r_edge = LV_MIN(lv_area_get_width(scale_area) / 2, lv_area_get_height(scale_area) / 2);\n    p_center.x = scale_area->x1 + r_edge;\n    p_center.y = scale_area->y1 + r_edge;\n\n    uint8_t i;\n\n    lv_draw_line_dsc_t line_dsc;\n    lv_draw_line_dsc_init(&line_dsc);\n    lv_obj_init_draw_line_dsc(obj, LV_PART_TICKS, &line_dsc);\n    line_dsc.raw_end = 1;\n\n    lv_draw_label_dsc_t label_dsc;\n    lv_draw_label_dsc_init(&label_dsc);\n    lv_obj_init_draw_label_dsc(obj, LV_PART_TICKS, &label_dsc);\n\n    lv_meter_scale_t * scale;\n\n    lv_draw_mask_radius_param_t inner_minor_mask;\n    lv_draw_mask_radius_param_t inner_major_mask;\n    lv_draw_mask_radius_param_t outer_mask;\n\n    lv_obj_draw_part_dsc_t part_draw_dsc;\n    lv_obj_draw_dsc_init(&part_draw_dsc, clip_area);\n    part_draw_dsc.class_p = MY_CLASS;\n    part_draw_dsc.part = LV_PART_TICKS;\n    part_draw_dsc.type = LV_METER_DRAW_PART_TICK;\n    part_draw_dsc.line_dsc = &line_dsc;\n\n    _LV_LL_READ_BACK(&meter->scale_ll, scale) {\n        part_draw_dsc.sub_part_ptr = scale;\n\n        lv_coord_t r_out = r_edge + scale->r_mod;\n        lv_coord_t r_in_minor = r_out - scale->tick_length;\n        lv_coord_t r_in_major = r_out - scale->tick_major_length;\n\n        lv_area_t area_inner_minor;\n        area_inner_minor.x1 = p_center.x - r_in_minor;\n        area_inner_minor.y1 = p_center.y - r_in_minor;\n        area_inner_minor.x2 = p_center.x + r_in_minor;\n        area_inner_minor.y2 = p_center.y + r_in_minor;\n        lv_draw_mask_radius_init(&inner_minor_mask, &area_inner_minor, LV_RADIUS_CIRCLE, true);\n\n        lv_area_t area_inner_major;\n        area_inner_major.x1 = p_center.x - r_in_major;\n        area_inner_major.y1 = p_center.y - r_in_major;\n        area_inner_major.x2 = p_center.x + r_in_major - 1;\n        area_inner_major.y2 = p_center.y + r_in_major - 1;\n        lv_draw_mask_radius_init(&inner_major_mask, &area_inner_major, LV_RADIUS_CIRCLE, true);\n\n        lv_area_t area_outer;\n        area_outer.x1 = p_center.x - r_out;\n        area_outer.y1 = p_center.y - r_out;\n        area_outer.x2 = p_center.x + r_out - 1;\n        area_outer.y2 = p_center.y + r_out - 1;\n        lv_draw_mask_radius_init(&outer_mask, &area_outer, LV_RADIUS_CIRCLE, false);\n        int16_t outer_mask_id = lv_draw_mask_add(&outer_mask, NULL);\n\n        int16_t inner_act_mask_id = LV_MASK_ID_INV; /*Will be added later*/\n\n        uint32_t minor_cnt = scale->tick_major_nth ? scale->tick_major_nth - 1 : 0xFFFF;\n        for(i = 0; i < scale->tick_cnt; i++) {\n            minor_cnt++;\n            bool major = false;\n            if(minor_cnt == scale->tick_major_nth) {\n                minor_cnt = 0;\n                major = true;\n            }\n\n            int32_t value_of_line = lv_map(i, 0, scale->tick_cnt - 1, scale->min, scale->max);\n            part_draw_dsc.value = value_of_line;\n\n            lv_color_t line_color = major ? scale->tick_major_color : scale->tick_color;\n            lv_color_t line_color_ori = line_color;\n\n            lv_coord_t line_width_ori = major ? scale->tick_major_width : scale->tick_width;\n            lv_coord_t line_width = line_width_ori;\n\n            lv_meter_indicator_t * indic;\n            _LV_LL_READ_BACK(&meter->indicator_ll, indic) {\n                if(indic->type != LV_METER_INDICATOR_TYPE_SCALE_LINES) continue;\n                if(value_of_line >= indic->start_value && value_of_line <= indic->end_value) {\n                    line_width += indic->type_data.scale_lines.width_mod;\n\n                    if(indic->type_data.scale_lines.color_start.full == indic->type_data.scale_lines.color_end.full) {\n                        line_color = indic->type_data.scale_lines.color_start;\n                    }\n                    else {\n                        lv_opa_t ratio;\n                        if(indic->type_data.scale_lines.local_grad) {\n                            ratio = lv_map(value_of_line, indic->start_value, indic->end_value, LV_OPA_TRANSP, LV_OPA_COVER);\n                        }\n                        else {\nratio = ",
    "raw_res": "0;",
    "prompt_res": "lv_map(value_of_line, scale->min, scale->max, LV_OPA_TRANSP, LV_OPA_COVER);",
    "gt": "lv_map(value_of_line, scale->min, scale->max, LV_OPA_TRANSP, LV_OPA_COVER);"
  },
  {
    "id": 2722,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/widgets/chart/lv_chart.c",
    "input": "/**\n * @file lv_chart.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n#include \"lv_chart.h\"\n#if LV_USE_CHART != 0\n\n#include \"../../../misc/lv_assert.h\"\n\n/*********************\n *      DEFINES\n *********************/\n#define MY_CLASS &lv_chart_class\n\n#define LV_CHART_HDIV_DEF 3\n#define LV_CHART_VDIV_DEF 5\n#define LV_CHART_POINT_CNT_DEF 10\n#define LV_CHART_LABEL_MAX_TEXT_LENGTH 16\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic void lv_chart_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void lv_chart_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void lv_chart_event(const lv_obj_class_t * class_p, lv_event_t * e);\n\nstatic void draw_div_lines(lv_obj_t * obj, const lv_area_t * mask);\nstatic void draw_series_line(lv_obj_t * obj, const lv_area_t * clip_area);\nstatic void draw_series_bar(lv_obj_t * obj, const lv_area_t * clip_area);\nstatic void draw_series_scatter(lv_obj_t * obj, const lv_area_t * clip_area);\nstatic void draw_cursors(lv_obj_t * obj, const lv_area_t * clip_area);\nstatic void draw_axes(lv_obj_t * obj, const lv_area_t * mask);\nstatic uint32_t get_index_from_x(lv_obj_t * obj, lv_coord_t x);\nstatic void invalidate_point(lv_obj_t * obj, uint16_t i);\nstatic void new_points_alloc(lv_obj_t * obj, lv_chart_series_t * ser, uint32_t cnt, lv_coord_t ** a);\nlv_chart_tick_dsc_t * get_tick_gsc(lv_obj_t * obj, lv_chart_axis_t axis);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\nconst lv_obj_class_t lv_chart_class = {\n    .constructor_cb = lv_chart_constructor,\n    .destructor_cb = lv_chart_destructor,\n    .event_cb = lv_chart_event,\n    .width_def = LV_PCT(100),\n    .height_def = LV_DPI_DEF * 2,\n    .instance_size = sizeof(lv_chart_t),\n    .base_class = &lv_obj_class\n};\n\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\nlv_obj_t * lv_chart_create(lv_obj_t * parent)\n{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}\n\nvoid lv_chart_set_type(lv_obj_t * obj, lv_chart_type_t type)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(chart->type == type) return;\n\n    if(chart->type == LV_CHART_TYPE_SCATTER) {\n        lv_chart_series_t * ser;\n        _LV_LL_READ_BACK(&chart->series_ll, ser) {\n            lv_mem_free(ser->x_points);\n            ser->x_points = NULL;\n        }\n    }\n\n    if(type == LV_CHART_TYPE_SCATTER) {\n        lv_chart_series_t * ser;\n        _LV_LL_READ_BACK(&chart->series_ll, ser) {\n            ser->x_points = lv_mem_alloc(sizeof(lv_point_t) * chart->point_cnt);\n            LV_ASSERT_MALLOC(ser->x_points);\n            if(ser->x_points == NULL) return;\n        }\n    }\n\n    chart->type = type;\n\n    lv_chart_refresh(obj);\n}\n\nvoid lv_chart_set_point_count(lv_obj_t * obj, uint16_t cnt)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(chart->point_cnt == cnt) return;\n\n    lv_chart_series_t * ser;\n\n    if(cnt < 1) cnt = 1;\n\n    _LV_LL_READ_BACK(&chart->series_ll, ser) {\n        if(chart->type == LV_CHART_TYPE_SCATTER) {\n            if(!ser->x_ext_buf_assigned) new_points_alloc(obj, ser, cnt, &ser->x_points);\n        }\n        if(!ser->y_ext_buf_assigned) new_points_alloc(obj, ser, cnt, &ser->y_points);\n        ser->start_point = 0;\n    }\n\n    chart->point_cnt = cnt;\n\n    lv_chart_refresh(obj);\n}\n\nvoid lv_chart_set_range(lv_obj_t * obj, lv_chart_axis_t axis, lv_coord_t min, lv_coord_t max)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    max = max == min ? max + 1 : max;\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    switch(axis) {\n        case LV_CHART_AXIS_PRIMARY_Y:\n            chart->ymin[0] = min;\n            chart->ymax[0] = max;\n            break;\n        case LV_CHART_AXIS_SECONDARY_Y:\n            chart->ymin[1] = min;\n            chart->ymax[1] = max;\n            break;\n        case LV_CHART_AXIS_PRIMARY_X:\n            chart->xmin[0] = min;\n            chart->xmax[0] = max;\n            break;\n        case LV_CHART_AXIS_SECONDARY_X:\n            chart->xmin[1] = min;\n            chart->xmax[1] = max;\n            break;\n        default:\n            LV_LOG_WARN(\"Invalid axis: %d\", axis);\n            return;\n    }\n\n    lv_chart_refresh(obj);\n}\n\nvoid lv_chart_set_update_mode(lv_obj_t * obj, lv_chart_update_mode_t update_mode)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(chart->update_mode == update_mode) return;\n\n    chart->update_mode = update_mode;\n    lv_obj_invalidate(obj);\n}\n\nvoid lv_chart_set_div_line_count(lv_obj_t * obj, uint8_t hdiv, uint8_t vdiv)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(chart->hdiv_cnt == hdiv && chart->vdiv_cnt == vdiv) return;\n\n    chart->hdiv_cnt = hdiv;\n    chart->vdiv_cnt = vdiv;\n\n    lv_obj_invalidate(obj);\n}\n\n\nvoid lv_chart_set_zoom_x(lv_obj_t * obj, uint16_t zoom_x)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(chart->zoom_x == zoom_x) return;\n\n    chart->zoom_x = zoom_x;\n    lv_obj_refresh_self_size(obj);\n    /*Be the chart doesn't remain scrolled out*/\n    lv_obj_readjust_scroll(obj, LV_ANIM_OFF);\n    lv_obj_invalidate(obj);\n}\n\nvoid lv_chart_set_zoom_y(lv_obj_t * obj, uint16_t zoom_y)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(chart->zoom_y == zoom_y) return;\n\n    chart->zoom_y = zoom_y;\n    lv_obj_refresh_self_size(obj);\n    /*Be the chart doesn't remain scrolled out*/\n    lv_obj_readjust_scroll(obj, LV_ANIM_OFF);\n    lv_obj_invalidate(obj);\n}\n\nuint16_t lv_chart_get_zoom_x(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    return chart->zoom_x;\n}\n\nuint16_t lv_chart_get_zoom_y(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    return chart->zoom_y;\n}\n\nvoid lv_chart_set_axis_tick(lv_obj_t * obj, lv_chart_axis_t axis, lv_coord_t major_len, lv_coord_t minor_len,\n                            lv_coord_t major_cnt, lv_coord_t minor_cnt, bool label_en, lv_coord_t draw_size)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_tick_dsc_t * t = get_tick_gsc(obj, axis);\n    t->major_len = major_len;\n    t->minor_len = minor_len;\n    t->minor_cnt = minor_cnt;\n    t->major_cnt = major_cnt;\n    t->label_en = label_en;\n    t->draw_size = draw_size;\n\n    lv_obj_refresh_ext_draw_size(obj);\n    lv_obj_invalidate(obj);\n}\n\nlv_chart_type_t lv_chart_get_type(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    return chart->type;\n}\n\nuint16_t lv_chart_get_point_count(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    return chart->point_cnt;\n}\n\nuint16_t lv_chart_get_x_start_point(const lv_obj_t * obj, lv_chart_series_t * ser)\n{\n    LV_UNUSED(obj);\n    LV_ASSERT_NULL(ser);\n\n    return ser->start_point;\n}\n\nvoid lv_chart_get_point_pos_by_id(lv_obj_t * obj, lv_chart_series_t * ser, uint16_t id, lv_point_t * p_out)\n{\n    LV_ASSERT_NULL(obj);\n    LV_ASSERT_NULL(ser);\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(id >= chart->point_cnt) {\n        LV_LOG_WARN(\"Invalid index: %d\", id);\n        p_out->x = 0;\n        p_out->y = 0;\n        return;\n    }\n\n    lv_coord_t w = ((int32_t)lv_obj_get_content_width(obj) * chart->zoom_x) >> 8;\n    lv_coord_t h = ((int32_t)lv_obj_get_content_height(obj) * chart->zoom_y) >> 8;\n\n    if(chart->type == LV_CHART_TYPE_LINE) {\n        p_out->x = (w * id) / (chart->point_cnt - 1);\n    }\n    else if(chart->type == LV_CHART_TYPE_SCATTER) {\n        p_out->x = lv_map(ser->x_points[id], chart->xmin[ser->x_axis_sec], chart->xmax[ser->x_axis_sec], 0, w);\n    }\n    else if(chart->type == LV_CHART_TYPE_BAR) {\n        uint32_t ser_cnt = _lv_ll_get_len(&chart->series_ll);\n        int32_t ser_gap = ((int32_t)lv_obj_get_style_pad_column(obj,\n                                                                LV_PART_ITEMS) * chart->zoom_x) >> 8; /*Gap between the column on the ~same X*/\n        int32_t block_gap = ((int32_t)lv_obj_get_style_pad_column(obj,\n                                                                  LV_PART_MAIN) * chart->zoom_x) >> 8;  /*Gap between the column on ~adjacent X*/\n        lv_coord_t block_w = (w - ((chart->point_cnt - 1) * block_gap)) / chart->point_cnt;\n        lv_coord_t col_w = block_w / ser_cnt;\n\n        p_out->x = (int32_t)((int32_t)w * id) / chart->point_cnt;\n\n        lv_chart_series_t * ser_i = NULL;\n        _LV_LL_READ_BACK(&chart->series_ll, ser_i) {\n            if(ser_i == ser) break;\n            p_out->x += col_w;\n        }\n\n        p_out->x += (col_w - ser_gap) / 2;\n    }\n\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n    p_out->x += lv_obj_get_style_pad_left(obj, LV_PART_MAIN) + border_width;\n    p_out->x -= lv_obj_get_scroll_left(obj);\n\n    int32_t temp_y = 0;\n    temp_y = (int32_t)((int32_t)ser->y_points[id] - chart->ymin[ser->y_axis_sec]) * h;\n    temp_y = temp_y / (chart->ymax[ser->y_axis_sec] - chart->ymin[ser->y_axis_sec]);\n    p_out->y = h - temp_y;\n    p_out->y += lv_obj_get_style_pad_top(obj, LV_PART_MAIN) + border_width;\n    p_out->y -= lv_obj_get_scroll_top(obj);\n}\n\nvoid lv_chart_refresh(lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_obj_invalidate(obj);\n}\n\n/*======================\n * Series\n *=====================*/\n\nlv_chart_series_t * lv_chart_add_series(lv_obj_t * obj, lv_color_t color, lv_chart_axis_t axis)\n{\n    LV_LOG_INFO(\"begin\");\n\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart    = (lv_chart_t *)obj;\n    lv_chart_series_t * ser = _lv_ll_ins_head(&chart->series_ll);\n    LV_ASSERT_MALLOC(ser);\n    if(ser == NULL) return NULL;\n\n    lv_coord_t def = LV_CHART_POINT_NONE;\n\n    ser->color  = color;\n    ser->y_points = lv_mem_alloc(sizeof(lv_coord_t) * chart->point_cnt);\n    LV_ASSERT_MALLOC(ser->y_points);\n\n    if(chart->type == LV_CHART_TYPE_SCATTER) {\n        ser->x_points = lv_mem_alloc(sizeof(lv_coord_t) * chart->point_cnt);\n        LV_ASSERT_MALLOC(ser->x_points);\n    }\n    if(ser->y_points == NULL) {\n        _lv_ll_remove(&chart->series_ll, ser);\n        lv_mem_free(ser);\n        return NULL;\n    }\n\n    ser->start_point = 0;\n    ser->y_ext_buf_assigned = false;\n    ser->hidden = 0;\n    ser->x_axis_sec = axis & LV_CHART_AXIS_SECONDARY_X ? 1 : 0;\n    ser->y_axis_sec = axis & LV_CHART_AXIS_SECONDARY_Y ? 1 : 0;\n\n    uint16_t i;\n    lv_coord_t * p_tmp = ser->y_points;\n    for(i = 0; i < chart->point_cnt; i++) {\n        *p_tmp = def;\n        p_tmp++;\n    }\n\n    return ser;\n}\n\nvoid lv_chart_remove_series(lv_obj_t * obj, lv_chart_series_t * series)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(series);\n\n    lv_chart_t * chart    = (lv_chart_t *)obj;\n    if(!series->y_ext_buf_assigned && series->y_points) lv_mem_free(series->y_points);\n\n    _lv_ll_remove(&chart->series_ll, series);\n    lv_mem_free(series);\n\n    return;\n}\n\nvoid lv_chart_hide_series(lv_obj_t * chart, lv_chart_series_t * series, bool hide)\n{\n    LV_ASSERT_OBJ(chart, MY_CLASS);\n    LV_ASSERT_NULL(series);\n\n    series->hidden = hide ? 1 : 0;\n    lv_chart_refresh(chart);\n}\n\n\nvoid lv_chart_set_series_color(lv_obj_t * chart, lv_chart_series_t * series, lv_color_t color)\n{\n    LV_ASSERT_OBJ(chart, MY_CLASS);\n    LV_ASSERT_NULL(series);\n\n    series->color = color;\n    lv_chart_refresh(chart);\n}\n\nvoid lv_chart_set_x_start_point(lv_obj_t * obj, lv_chart_series_t * ser, uint16_t id)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(ser);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(id >= chart->point_cnt) return;\n    ser->start_point = id;\n}\n\nlv_chart_series_t * lv_chart_get_series_next(const lv_obj_t * obj, const lv_chart_series_t * ser)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(ser == NULL) return _lv_ll_get_head(&chart->series_ll);\n    else return _lv_ll_get_next(&chart->series_ll, ser);\n}\n\n/*=====================\n * Cursor\n *====================*/\n\n/**\n * Add a cursor with a given color\n * @param chart     pointer to chart object\n * @param color     color of the cursor\n * @param dir       direction of the cursor. `LV_DIR_RIGHT/LEFT/TOP/DOWN/HOR/VER/ALL`. OR-ed values are possible\n * @return          pointer to the created cursor\n */\nlv_chart_cursor_t  * lv_chart_add_cursor(lv_obj_t * obj, lv_color_t color, lv_dir_t dir)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    lv_chart_cursor_t * cursor = _lv_ll_ins_head(&chart->cursor_ll);\n    LV_ASSERT_MALLOC(cursor);\n    if(cursor == NULL) return NULL;\n\n    cursor->pos.x = LV_CHART_POINT_NONE;\n    cursor->pos.y = LV_CHART_POINT_NONE;\n    cursor->point_id = LV_CHART_POINT_NONE;\n    cursor->pos_set = 0;\n    cursor->color = color;\n    cursor->dir = dir;\n\n    return cursor;\n}\n\n/**\n * Set the coordinate of the cursor with respect\n * to the origin of series area of the chart.\n * @param chart pointer to a chart object.\n * @param cursor pointer to the cursor.\n * @param pos the new coordinate of cursor relative to the series area\n */\nvoid lv_chart_set_cursor_pos(lv_obj_t * chart, lv_chart_cursor_t * cursor, lv_point_t * pos)\n{\n    LV_ASSERT_NULL(cursor);\n    LV_UNUSED(chart);\n\n    cursor->pos.x = pos->x;\n    cursor->pos.y = pos->y;\n    cursor->pos_set = 1;\n    lv_chart_refresh(chart);\n}\n\n\n/**\n * Set the coordinate of the cursor with respect\n * to the origin of series area of the chart.\n * @param chart pointer to a chart object.\n * @param cursor pointer to the cursor.\n * @param pos the new coordinate of cursor relative to the series area\n */\nvoid lv_chart_set_cursor_point(lv_obj_t * chart, lv_chart_cursor_t * cursor, lv_chart_series_t * ser, uint16_t point_id)\n{\n    LV_ASSERT_NULL(cursor);\n    LV_UNUSED(chart);\n\n    cursor->point_id = point_id;\n    cursor->pos_set = 0;\n    if(ser == NULL) ser = lv_chart_get_series_next(chart, NULL);\n    cursor->ser = ser;\n    lv_chart_refresh(chart);\n}\n/**\n * Get the coordinate of the cursor with respect\n * to the origin of series area of the chart.\n * @param chart pointer to a chart object\n * @param cursor pointer to cursor\n * @return coordinate of the cursor as lv_point_t\n */\nlv_point_t lv_chart_get_cursor_point(lv_obj_t * chart, lv_chart_cursor_t * cursor)\n{\n    LV_ASSERT_NULL(cursor);\n    LV_UNUSED(chart);\n\n    return cursor->pos;\n}\n\n/*=====================\n * Set/Get value(s)\n *====================*/\n\n\nvoid lv_chart_set_all_value(lv_obj_t * obj, lv_chart_series_t * ser, lv_coord_t value)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(ser);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    uint16_t i;\n    for(i = 0; i < chart->point_cnt; i++) {\n        ser->y_points[i] = value;\n    }\n    ser->start_point = 0;\n    lv_chart_refresh(obj);\n}\n\nvoid lv_chart_set_next_value(lv_obj_t * obj, lv_chart_series_t * ser, lv_coord_t value)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(ser);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    ser->y_points[ser->start_point] = value;\n    invalidate_point(obj, ser->start_point);\n    ser->start_point = (ser->start_point + 1) % chart->point_cnt;\n    invalidate_point(obj, ser->start_point);\n}\n\nvoid lv_chart_set_next_value2(lv_obj_t * obj, lv_chart_series_t * ser, lv_coord_t x_value, lv_coord_t y_value)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(ser);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n\n    if(chart->type != LV_CHART_TYPE_SCATTER) {\n        LV_LOG_WARN(\"Type must be LV_CHART_TYPE_SCATTER\");\n        return;\n    }\n\n    ser->x_points[ser->start_point] = x_value;\n    ser->y_points[ser->start_point] = y_value;\n    invalidate_point(obj, ser->start_point);\n    ser->start_point = (ser->start_point + 1) % chart->point_cnt;\n    invalidate_point(obj, ser->start_point);\n    lv_chart_refresh(obj);\n\n}\n\nvoid lv_chart_set_value_by_id(lv_obj_t * obj, lv_chart_series_t * ser, uint16_t id, lv_coord_t value)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(ser);\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n\n    if(id >= chart->point_cnt) return;\n    ser->y_points[id] = value;\n}\n\nvoid lv_chart_set_value_by_id2(lv_obj_t * obj, lv_chart_series_t * ser, uint16_t id, lv_coord_t x_value,\n                               lv_coord_t y_value)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(ser);\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n\n    if(chart->type != LV_CHART_TYPE_SCATTER) {\n        LV_LOG_WARN(\"Type must be LV_CHART_TYPE_SCATTER\");\n        return;\n    }\n\n    if(id >= chart->point_cnt) return;\n    ser->x_points[id] = x_value;\n    ser->y_points[id] = y_value;\n}\n\nvoid lv_chart_set_ext_y_array(lv_obj_t * obj, lv_chart_series_t * ser, lv_coord_t array[])\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(ser);\n\n    if(!ser->y_ext_buf_assigned && ser->y_points) lv_mem_free(ser->y_points);\n    ser->y_ext_buf_assigned = true;\n    ser->y_points = array;\n    lv_obj_invalidate(obj);\n}\n\nvoid lv_chart_set_ext_x_array(lv_obj_t * obj, lv_chart_series_t * ser, lv_coord_t array[])\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(ser);\n\n    if(!ser->x_ext_buf_assigned && ser->x_points) lv_mem_free(ser->x_points);\n    ser->x_ext_buf_assigned = true;\n    ser->x_points = array;\n    lv_obj_invalidate(obj);\n}\n\nlv_coord_t * lv_chart_get_y_array(const lv_obj_t * obj, lv_chart_series_t * ser)\n{\n    LV_UNUSED(obj);\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(ser);\n    return ser->y_points;\n}\n\nlv_coord_t * lv_chart_get_x_array(const lv_obj_t * obj, lv_chart_series_t * ser)\n{\n    LV_UNUSED(obj);\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(ser);\n    return ser->x_points;\n}\n\nuint32_t lv_chart_get_pressed_point(const lv_obj_t * obj)\n{\n    lv_chart_t * chart = (lv_chart_t *)obj;\n    return chart->pressed_point_id;\n}\n\n/**********************\n *   STATIC FUNCTIONS\n **********************/\n\nstatic void lv_chart_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)\n{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_chart_t * chart = (lv_chart_t *)obj;\n\n    _lv_ll_init(&chart->series_ll, sizeof(lv_chart_series_t));\n    _lv_ll_init(&chart->cursor_ll, sizeof(lv_chart_cursor_t));\n\n    chart->ymin[0] = 0;\n    chart->xmin[0] = 0;\n    chart->ymin[1] = 0;\n    chart->xmin[1] = 0;\n    chart->ymax[0] = 100;\n    chart->xmax[0] = 100;\n    chart->ymax[1] = 100;\n    chart->xmax[1] = 100;\n\n    chart->hdiv_cnt    = LV_CHART_HDIV_DEF;\n    chart->vdiv_cnt    = LV_CHART_VDIV_DEF;\n    chart->point_cnt   = LV_CHART_POINT_CNT_DEF;\n    chart->pressed_point_id  = LV_CHART_POINT_NONE;\n    chart->type        = LV_CHART_TYPE_LINE;\n    chart->update_mode = LV_CHART_UPDATE_MODE_SHIFT;\n    chart->zoom_x      = LV_IMG_ZOOM_NONE;\n    chart->zoom_y      = LV_IMG_ZOOM_NONE;\n\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}\n\nstatic void lv_chart_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)\n{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_chart_t * chart = (lv_chart_t *)obj;\n    lv_chart_series_t * ser;\n    while(chart->series_ll.head) {\n        ser = _lv_ll_get_head(&chart->series_ll);\n\n        if(!ser->y_ext_buf_assigned) lv_mem_free(ser->y_points);\n\n        _lv_ll_remove(&chart->series_ll, ser);\n        lv_mem_free(ser);\n    }\n    _lv_ll_clear(&chart->series_ll);\n\n    lv_chart_cursor_t * cur;\n    while(chart->cursor_ll.head) {\n        cur = _lv_ll_get_head(&chart->cursor_ll);\n        _lv_ll_remove(&chart->cursor_ll, cur);\n        lv_mem_free(cur);\n    }\n    _lv_ll_clear(&chart->cursor_ll);\n\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}\n\nstatic void lv_chart_event(const lv_obj_class_t * class_p, lv_event_t * e)\n{\n    LV_UNUSED(class_p);\n\n    /*Call the ancestor's event handler*/\n    lv_res_t res;\n\n    res = lv_obj_event_base(MY_CLASS, e);\n    if(res != LV_RES_OK) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(code == LV_EVENT_PRESSED) {\n        lv_indev_t * indev = lv_indev_get_act();\n        lv_point_t p;\n        lv_indev_get_point(indev, &p);\n\n        p.x -= obj->coords.x1;\n        uint32_t id = get_index_from_x(obj, p.x + lv_obj_get_scroll_left(obj));\n        if(id != chart->pressed_point_id) {\n            invalidate_point(obj, id);\n            invalidate_point(obj, chart->pressed_point_id);\n            chart->pressed_point_id = id;\n            lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n        }\n    }\n    else if(code == LV_EVENT_RELEASED) {\n        invalidate_point(obj, chart->pressed_point_id);\n        chart->pressed_point_id = LV_CHART_POINT_NONE;\n    }\n    else if(code == LV_EVENT_SIZE_CHANGED) {\n        lv_obj_refresh_self_size(obj);\n    }\n    else if(code == LV_EVENT_REFR_EXT_DRAW_SIZE) {\n        lv_event_set_ext_draw_size(e, LV_MAX4(chart->tick[0].draw_size, chart->tick[1].draw_size, chart->tick[2].draw_size,\n                                              chart->tick[3].draw_size));\n    }\n    else if(code == LV_EVENT_GET_SELF_SIZE) {\n        lv_point_t * p = lv_event_get_param(e);\n        p->x = ((int32_t)lv_obj_get_content_width(obj) * chart->zoom_x) >> 8;\n        p->y = ((int32_t)lv_obj_get_content_height(obj) * chart->zoom_y) >> 8;\n    }\n    else if(code == LV_EVENT_DRAW_MAIN) {\n        const lv_area_t * clip_area = lv_event_get_param(e);\n        draw_div_lines(obj, clip_area);\n        draw_axes(obj, clip_area);\n\n        if(_lv_ll_is_empty(&chart->series_ll) == false) {\n            if(chart->type == LV_CHART_TYPE_LINE) draw_series_line(obj, clip_area);\n            else if(chart->type == LV_CHART_TYPE_BAR) draw_series_bar(obj, clip_area);\n            else if(chart->type == LV_CHART_TYPE_SCATTER) draw_series_scatter(obj, clip_area);\n        }\n\n        draw_cursors(obj, clip_area);\n    }\n}\n\nstatic void draw_div_lines(lv_obj_t * obj, const lv_area_t * clip_area)\n{\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n\n    lv_area_t series_mask;\n    bool mask_ret = _lv_area_intersect(&series_mask, &obj->coords, clip_area);\n    if(mask_ret == false) return;\n\n    int16_t i;\n    int16_t i_start;\n    int16_t i_end;\n    lv_point_t p1;\n    lv_point_t p2;\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n    lv_coord_t pad_left = lv_obj_get_style_pad_left(obj, LV_PART_MAIN) + border_width;\n    lv_coord_t pad_top = lv_obj_get_style_pad_top(obj, LV_PART_MAIN) + border_width;\n    lv_coord_t w     = ((int32_t)lv_obj_get_content_width(obj) * chart->zoom_x) >> 8;\n    lv_coord_t h     = ((int32_t)lv_obj_get_content_height(obj) * chart->zoom_y) >> 8;\n\n    lv_draw_line_dsc_t line_dsc;\n    lv_draw_line_dsc_init(&line_dsc);\n    lv_obj_init_draw_line_dsc(obj, LV_PART_MAIN, &line_dsc);\n\n    lv_obj_draw_part_dsc_t part_draw_dsc;\n    lv_obj_draw_dsc_init(&part_draw_dsc, clip_area);\n    part_draw_dsc.part = LV_PART_MAIN;\n    part_draw_dsc.class_p = MY_CLASS;\n    part_draw_dsc.type = LV_CHART_DRAW_PART_DIV_LINE_INIT;\n    part_draw_dsc.line_dsc = &line_dsc;\n    part_draw_dsc.id = 0xFFFFFFFF;\n    part_draw_dsc.p1 = NULL;\n    part_draw_dsc.p2 = NULL;\n    lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n\n    lv_opa_t border_opa = lv_obj_get_style_border_opa(obj, LV_PART_MAIN);\n    lv_coord_t border_w = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n    lv_border_side_t border_side = lv_obj_get_style_border_side(obj, LV_PART_MAIN);\n\n    lv_coord_t scroll_left = lv_obj_get_scroll_left(obj);\n    lv_coord_t scroll_top = lv_obj_get_scroll_top(obj);\n    if(chart->hdiv_cnt != 0) {\n        lv_coord_t y_ofs = obj->coords.y1 + pad_top - scroll_top;\n        p1.x = obj->coords.x1;\n        p2.x = obj->coords.x2;\n\n        i_start = 0;\n        i_end = chart->hdiv_cnt;\n        if(border_opa > LV_OPA_MIN && border_w > 0) {\n            if((border_side & LV_BORDER_SIDE_TOP) && (lv_obj_get_style_pad_top(obj, LV_PART_MAIN) == 0)) i_start++;\n            if((border_side & LV_BORDER_SIDE_BOTTOM) && (lv_obj_get_style_pad_bottom(obj, LV_PART_MAIN) == 0)) i_end--;\n        }\n\n        for(i = i_start; i < i_end; i++) {\n            p1.y = (int32_t)((int32_t)h * i) / (chart->hdiv_cnt - 1);\n            p1.y += y_ofs;\n            p2.y = p1.y;\n\n            part_draw_dsc.class_p = MY_CLASS;\n            part_draw_dsc.type = LV_CHART_DRAW_PART_DIV_LINE_HOR;\n            part_draw_dsc.p1 = &p1;\n            part_draw_dsc.p2 = &p2;\n            part_draw_dsc.id = i;\n\n            lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n            lv_draw_line(&p1, &p2, &series_mask, &line_dsc);\n            lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n        }\n    }\n\n    if(chart->vdiv_cnt != 0) {\n        lv_coord_t x_ofs = obj->coords.x1 + pad_left - scroll_left;\n        p1.y = obj->coords.y1;\n        p2.y = obj->coords.y2;\n        i_start = 0;\n        i_end = chart->vdiv_cnt;\n        if(border_opa > LV_OPA_MIN && border_w > 0) {\n            if((border_side & LV_BORDER_SIDE_LEFT) && (lv_obj_get_style_pad_left(obj, LV_PART_MAIN) == 0)) i_start++;\n            if((border_side & LV_BORDER_SIDE_RIGHT) && (lv_obj_get_style_pad_right(obj, LV_PART_MAIN) == 0)) i_end--;\n        }\n\n        for(i = i_start; i < i_end; i++) {\n            p1.x = (int32_t)((int32_t)w * i) / (chart->vdiv_cnt - 1);\n            p1.x += x_ofs;\n            p2.x = p1.x;\n\n            part_draw_dsc.class_p = MY_CLASS;\n            part_draw_dsc.type = LV_CHART_DRAW_PART_DIV_LINE_VER;\n            part_draw_dsc.p1 = &p1;\n            part_draw_dsc.p2 = &p2;\n            part_draw_dsc.id = i;\n\n            lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n            lv_draw_line(&p1, &p2, &series_mask, &line_dsc);\n            lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n        }\n    }\n\n    part_draw_dsc.id = 0xFFFFFFFF;\n    part_draw_dsc.p1 = NULL;\n    part_draw_dsc.p2 = NULL;\n    lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n\n}\n\nstatic void draw_series_line(lv_obj_t * obj, const lv_area_t * clip_area)\n{\n    lv_area_t com_area;\n    if(_lv_area_intersect(&com_area, &obj->coords, clip_area) == false) return;\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(chart->point_cnt < 2) return;\n\n    uint16_t i;\n    lv_point_t p1;\n    lv_point_t p2;\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n    lv_coord_t pad_left = lv_obj_get_style_pad_left(obj, LV_PART_MAIN) + border_width;\n    lv_coord_t pad_top = lv_obj_get_style_pad_top(obj, LV_PART_MAIN) + border_width;\n    lv_coord_t w     = ((int32_t)lv_obj_get_content_width(obj) * chart->zoom_x) >> 8;\n    lv_coord_t h     = ((int32_t)lv_obj_get_content_height(obj) * chart->zoom_y) >> 8;\n    lv_coord_t x_ofs = obj->coords.x1 + pad_left - lv_obj_get_scroll_left(obj);\n    lv_coord_t y_ofs = obj->coords.y1 + pad_top - lv_obj_get_scroll_top(obj);\n    lv_chart_series_t * ser;\n\n    lv_area_t series_mask;\n    bool mask_ret = _lv_area_intersect(&series_mask, &obj->coords, clip_area);\n    if(mask_ret == false) return;\n\n    lv_draw_line_dsc_t line_dsc_default;\n    lv_draw_line_dsc_init(&line_dsc_default);\n    lv_obj_init_draw_line_dsc(obj, LV_PART_ITEMS, &line_dsc_default);\n\n    lv_draw_rect_dsc_t point_dsc_default;\n    lv_draw_rect_dsc_init(&point_dsc_default);\n    lv_obj_init_draw_rect_dsc(obj, LV_PART_INDICATOR, &point_dsc_default);\n\n    lv_coord_t point_w = lv_obj_get_style_width(obj, LV_PART_INDICATOR) / 2;\n    lv_coord_t point_h = lv_obj_get_style_height(obj, LV_PART_INDICATOR) / 2;\n\n    /*Do not bother with line ending is the point will over it*/\n    if(LV_MIN(point_w, point_h) > line_dsc_default.width / 2) line_dsc_default.raw_end = 1;\n    if(line_dsc_default.width == 1) line_dsc_default.raw_end = 1;\n\n    /*If there are mire points than pixels draw only vertical lines*/\n    bool crowded_mode = chart->point_cnt >= w ? true : false;\n\n    /*Go through all data lines*/\n    _LV_LL_READ_BACK(&chart->series_ll, ser) {\n        if(ser->hidden) continue;\n        line_dsc_default.color = ser->color;\n        point_dsc_default.bg_color = ser->color;\n\n        lv_coord_t start_point = chart->update_mode == LV_CHART_UPDATE_MODE_SHIFT ? ser->start_point : 0;\n\n        p1.x = x_ofs;\n        p2.x = x_ofs;\n\n        lv_coord_t p_act = start_point;\n        lv_coord_t p_prev = start_point;\n        int32_t y_tmp = (int32_t)((int32_t)ser->y_points[p_prev] - chart->ymin[ser->y_axis_sec]) * h;\n        y_tmp  = y_tmp / (chart->ymax[ser->y_axis_sec] - chart->ymin[ser->y_axis_sec]);\n        p2.y   = h - y_tmp + y_ofs;\n\n        lv_obj_draw_part_dsc_t part_draw_dsc;\n        lv_obj_draw_dsc_init(&part_draw_dsc, clip_area);\n        part_draw_dsc.class_p = MY_CLASS;\n        part_draw_dsc.type = LV_CHART_DRAW_PART_LINE_AND_POINT;\n        part_draw_dsc.part = LV_PART_ITEMS;\n        part_draw_dsc.line_dsc = &line_dsc_default;\n        part_draw_dsc.rect_dsc = &point_dsc_default;\n        part_draw_dsc.sub_part_ptr = ser;\n\n        lv_coord_t y_min = p2.y;\n        lv_coord_t y_max = p2.y;\n\n        for(i = 0; i < chart->point_cnt; i++) {\n            p1.x = p2.x;\n            p1.y = p2.y;\n\n            if(p1.x > clip_area->x2 + point_w + 1) break;\n            p2.x = ((w * i) / (chart->point_cnt - 1)) + x_ofs;\n\n            p_act = (start_point + i) % chart->point_cnt;\n\n            y_tmp = (int32_t)((int32_t)ser->y_points[p_act] - chart->ymin[ser->y_axis_sec]) * h;\n            y_tmp = y_tmp / (chart->ymax[ser->y_axis_sec] - chart->ymin[ser->y_axis_sec]);\n            p2.y  = h - y_tmp + y_ofs;\n\n            if(p2.x < clip_area->x1 - point_w - 1) {\n                p_prev = p_act;\n                continue;\n            }\n\n            /*Don't draw the first point. A second point is also required to draw the line*/\n            if(i != 0) {\n                if(crowded_mode) {\n                    if(ser->y_points[p_prev] != LV_CHART_POINT_NONE && ser->y_points[p_act] != LV_CHART_POINT_NONE) {\n                        /*Draw only one vertical line between the min and max y-values on the same x-value*/\n                        y_max = LV_MAX(y_max, p2.y);\n                        y_min = LV_MIN(y_min, p2.y);\n                        if(p1.x != p2.x) {\n                            lv_coord_t y_cur = p2.y;\n                            p2.x--;         /*It's already on the next x value*/\n                            p1.x = p2.x;\n                            p1.y = y_min;\n                            p2.y = y_max;\n                            if(p1.y == p2.y) p2.y++;    /*If they are the same no line will be drawn*/\n                            lv_draw_line(&p1, &p2, &series_mask, &line_dsc_default);\n                            p2.x++;         /*Compensate the previous x--*/\n                            y_min = y_cur;  /*Start the line of the next x from the current last y*/\n                            y_max = y_cur;\n                        }\n                    }\n                }\n                else {\n                    lv_area_t point_area;\n                    point_area.x1 = p1.x - point_w;\n                    point_area.x2 = p1.x + point_w;\n                    point_area.y1 = p1.y - point_h;\n                    point_area.y2 = p1.y + point_h;\n\n                    part_draw_dsc.id = i - 1;\n                    part_draw_dsc.p1 = ser->y_points[p_prev] != LV_CHART_POINT_NONE ? &p1 : NULL;\n                    part_draw_dsc.p2 = ser->y_points[p_act] != LV_CHART_POINT_NONE ? &p2 : NULL;\n                    part_draw_dsc.draw_area = &point_area;\n                    part_draw_dsc.value = ser->y_points[p_prev];\n\n                    lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n\n                    if(ser->y_points[p_prev] != LV_CHART_POINT_NONE && ser->y_points[p_act] != LV_CHART_POINT_NONE) {\n                        lv_draw_line(&p1, &p2, &series_mask, &line_dsc_default);\n                    }\n\n                    if(point_w && point_h && ser->y_points[p_prev] != LV_CHART_POINT_NONE) {\n                        lv_draw_rect(&point_area, &series_mask, &point_dsc_default);\n                    }\n\n                    lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n                }\n\n            }\n            p_prev = p_act;\n        }\n\n        /*Draw the last point*/\n        if(!crowded_mode && i == chart->point_cnt) {\n\n            if(ser->y_points[p_act] != LV_CHART_POINT_NONE) {\n                lv_area_t point_area;\n                point_area.x1 = p2.x - point_w;\n                point_area.x2 = p2.x + point_w;\n                point_area.y1 = p2.y - point_h;\n                point_area.y2 = p2.y + point_h;\n\n                part_draw_dsc.id = i - 1;\n                part_draw_dsc.p1 = NULL;\n                part_draw_dsc.p2 = NULL;\n                part_draw_dsc.draw_area = &point_area;\n                part_draw_dsc.value = ser->y_points[p_act];\n                lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n                lv_draw_rect(&point_area, &series_mask, &point_dsc_default);\n                lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n            }\n        }\n    }\n}\n\nstatic void draw_series_scatter(lv_obj_t * obj, const lv_area_t * clip_area)\n{\n\n    lv_area_t com_area;\n    if(_lv_area_intersect(&com_area, &obj->coords, clip_area) == false) return;\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n\n    uint16_t i;\n    lv_point_t p1;\n    lv_point_t p2;\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\nlv_coord_t pad_left = ",
    "raw_res": "lv_obj_get_style_pad_left(obj, LV_PART_MAIN) + border_width;",
    "prompt_res": "lv_obj_get_style_pad_left(obj, LV_PART_MAIN);",
    "gt": "lv_obj_get_style_pad_left(obj, LV_PART_MAIN);"
  },
  {
    "id": 2744,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/widgets/msgbox/lv_msgbox.c",
    "input": "/**\n * @file lv_msgbox.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n#include \"lv_msgbox.h\"\n#if LV_USE_MSGBOX\n\n#include \"../../../misc/lv_assert.h\"\n\n/*********************\n *      DEFINES\n *********************/\n#define LV_MSGBOX_FLAG_AUTO_PARENT  LV_OBJ_FLAG_WIDGET_1        /*Mark that the parent was automatically created*/\n#define MY_CLASS    &lv_msgbox_class\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic void msgbox_close_click_event_cb(lv_event_t * e);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\nconst lv_obj_class_t lv_msgbox_class = {\n        .base_class = &lv_obj_class,\n        .width_def = LV_DPI_DEF * 2,\n        .height_def = LV_SIZE_CONTENT,\n        .instance_size = sizeof(lv_msgbox_t)\n};\n\nconst lv_obj_class_t lv_msgbox_content_class = {\n        .base_class = &lv_obj_class,\n        .width_def = LV_PCT(100),\n        .height_def = LV_SIZE_CONTENT,\n        .instance_size = sizeof(lv_obj_t)\n};\n\nconst lv_obj_class_t lv_msgbox_backdrop_class = {\n        .base_class = &lv_obj_class,\n        .width_def = LV_PCT(100),\n        .height_def = LV_PCT(100),\n        .instance_size = sizeof(lv_obj_t)\n};\n\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\nlv_obj_t * lv_msgbox_create(lv_obj_t * parent, const char * title, const char * txt, const char * btn_txts[],\n                            bool add_close_btn)\n{\n    LV_LOG_INFO(\"begin\");\n    bool auto_parent = false;\n    if(parent == NULL) {\n        auto_parent = true;\n        parent = lv_obj_class_create_obj(&lv_msgbox_backdrop_class, lv_layer_top());\n        LV_ASSERT_MALLOC(parent);\n        lv_obj_class_init_obj(parent);\n        lv_obj_clear_flag(parent, LV_OBJ_FLAG_IGNORE_LAYOUT);\n        lv_obj_set_size(parent, LV_PCT(100), LV_PCT(100));\n    }\n\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_msgbox_class, parent);\n    LV_ASSERT_MALLOC(obj);\n    lv_obj_class_init_obj(obj);\n    if(obj == NULL) return NULL;\n    lv_msgbox_t * mbox = (lv_msgbox_t *)obj;\n\n    if(auto_parent) lv_obj_add_flag(obj, LV_MSGBOX_FLAG_AUTO_PARENT);\n\n    lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_ROW_WRAP);\n\n    bool has_title = title && strlen(title) > 0;\n\n    /*When a close button is required, we need the empty label as spacer to push the button to the right*/\n    if (add_close_btn || has_title) {\n        mbox->title = lv_label_create(obj);\n        lv_label_set_text(mbox->title, has_title ? title : \"\");\n        lv_label_set_long_mode(mbox->title, LV_LABEL_LONG_SCROLL_CIRCULAR);\n        if(add_close_btn) lv_obj_set_flex_grow(mbox->title, 1);\n        else lv_obj_set_width(mbox->title, LV_PCT(100));\n    }\n\n    if(add_close_btn) {\n        mbox->close_btn = lv_btn_create(obj);\n        lv_obj_set_ext_click_area(mbox->close_btn, LV_DPX(10));\n        lv_obj_add_event_cb(mbox->close_btn, msgbox_close_click_event_cb, LV_EVENT_CLICKED, NULL);\n        lv_obj_t * label = lv_label_create(mbox->close_btn);\n        lv_label_set_text(label, LV_SYMBOL_CLOSE);\n        const lv_font_t * font = lv_obj_get_style_text_font(mbox->close_btn, LV_PART_MAIN);\n        lv_coord_t close_btn_size = lv_font_get_line_height(font) + LV_DPX(10);\n        lv_obj_set_size(mbox->close_btn, close_btn_size, close_btn_size);\n        lv_obj_align(label, LV_ALIGN_CENTER, 0, 0);\n    }\n\n    mbox->content = lv_obj_class_create_obj(&lv_msgbox_content_class, obj);\n\n    bool has_txt = txt && strlen(txt) > 0;\n    if (has_txt) {\n        mbox->text = lv_label_create(mbox->content);\n        lv_label_set_text(mbox->text, txt);\n        lv_label_set_long_mode(mbox->text, LV_LABEL_LONG_WRAP);\n        lv_obj_set_width(mbox->text, lv_pct(100));\n    }\n\n    if(btn_txts) {\nmbox->btns = ",
    "raw_res": "lv_btnm_create(obj);",
    "prompt_res": "lv_btnmatrix_create(obj);",
    "gt": "lv_btnmatrix_create(obj);"
  },
  {
    "id": 2758,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar_header_dropdown.c",
    "input": "/**\n * @file lv_calendar_obj_dropdown.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n#include \"lv_calendar_header_dropdown.h\"\n#if LV_USE_CALENDAR_HEADER_DROPDOWN\n\n#include \"lv_calendar.h\"\n#include \"../../../widgets/lv_dropdown.h\"\n#include \"../../layouts/flex/lv_flex.h\"\n\n/*********************\n *      DEFINES\n *********************/\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic void my_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void year_event_cb(lv_event_t * e);\nstatic void month_event_cb(lv_event_t * e);\nstatic void value_changed_event_cb(lv_event_t * e);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\nconst lv_obj_class_t lv_calendar_header_dropdown_class = {\n    .base_class = &lv_obj_class,\n    .width_def = LV_PCT(100),\n    .height_def = LV_SIZE_CONTENT,\n    .constructor_cb = my_constructor\n};\n\nstatic const char * month_list = \"01\\n02\\n03\\n04\\n05\\n06\\n07\\n08\\n09\\n10\\n11\\n12\";\nstatic const char * year_list = {\n    \"2023\\n2022\\n2021\\n\"\n    \"2020\\n2019\\n2018\\n2017\\n2016\\n2015\\n2014\\n2013\\n2012\\n2011\\n2010\\n2009\\n2008\\n2007\\n2006\\n2005\\n2004\\n2003\\n2002\\n2001\\n\"\n    \"2000\\n1999\\n1998\\n1997\\n1996\\n1995\\n1994\\n1993\\n1992\\n1991\\n1990\\n1989\\n1988\\n1987\\n1986\\n1985\\n1984\\n1983\\n1982\\n1981\\n\"\n    \"1980\\n1979\\n1978\\n1977\\n1976\\n1975\\n1974\\n1973\\n1972\\n1971\\n1970\\n1969\\n1968\\n1967\\n1966\\n1965\\n1964\\n1963\\n1962\\n1961\\n\"\n    \"1960\\n1959\\n1958\\n1957\\n1956\\n1955\\n1954\\n1953\\n1952\\n1951\\n1950\\n1949\\n1948\\n1947\\n1946\\n1945\\n1944\\n1943\\n1942\\n1941\\n\"\n    \"1940\\n1939\\n1938\\n1937\\n1936\\n1935\\n1934\\n1933\\n1932\\n1931\\n1930\\n1929\\n1928\\n1927\\n1926\\n1925\\n1924\\n1923\\n1922\\n1921\\n\"\n    \"1920\\n1919\\n1918\\n1917\\n1916\\n1915\\n1914\\n1913\\n1912\\n1911\\n1910\\n1909\\n1908\\n1907\\n1906\\n1905\\n1904\\n1903\\n1902\\n1901\"\n};\n\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\nlv_obj_t * lv_calendar_header_dropdown_create(lv_obj_t * parent)\n{\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_calendar_header_dropdown_class, parent);\n    lv_obj_class_init_obj(obj);\n\n    return obj;\n}\n\n/**********************\n *  STATIC FUNCTIONS\n **********************/\n\nstatic void my_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)\n{\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    LV_UNUSED(class_p);\n\n    lv_obj_t * calendar = lv_obj_get_parent(obj);\n    lv_obj_move_to_index(obj, 0);\n    lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_ROW);\n\n    lv_obj_t * year_dd = lv_dropdown_create(obj);\n    lv_dropdown_set_options(year_dd, year_list);\n    lv_obj_add_event_cb(year_dd, year_event_cb, LV_EVENT_VALUE_CHANGED, calendar);\n    lv_obj_set_flex_grow(year_dd, 1);\n\n    lv_obj_t * month_dd = lv_dropdown_create(obj);\n    lv_dropdown_set_options(month_dd, month_list);\n    lv_obj_add_event_cb(month_dd, month_event_cb, LV_EVENT_VALUE_CHANGED, calendar);\n    lv_obj_set_flex_grow(month_dd, 1);\n\n    lv_obj_add_event_cb(obj, value_changed_event_cb, LV_EVENT_VALUE_CHANGED, NULL);\n    /*Refresh the drop downs*/\n    lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n}\n\nstatic void month_event_cb(lv_event_t * e)\n{\n    lv_obj_t * dropdown = lv_event_get_target(e);\n    lv_obj_t * calendar = lv_event_get_user_data(e);\n\n    uint16_t sel = lv_dropdown_get_selected(dropdown);\n\n    const lv_calendar_date_t * d;\n    d = lv_calendar_get_showed_date(calendar);\n    lv_calendar_date_t newd = *d;\n    newd.month = sel + 1;\n\n    lv_calendar_set_showed_date(calendar, newd.year, newd.month);\n}\n\nstatic void year_event_cb(lv_event_t * e)\n{\n    lv_obj_t * dropdown = lv_event_get_target(e);\n    lv_obj_t * calendar = lv_event_get_user_data(e);\n\n    uint16_t sel = lv_dropdown_get_selected(dropdown);\n\n    const lv_calendar_date_t * d;\n    d = lv_calendar_get_showed_date(calendar);\n    lv_calendar_date_t newd = *d;\n    newd.year = 2023 - sel;\n\n    lv_calendar_set_showed_date(calendar, newd.year, newd.month);\n}\n\nstatic void value_changed_event_cb(lv_event_t * e)\n{\n    lv_obj_t * header = lv_event_get_target(e);\n    lv_obj_t * calendar = lv_obj_get_parent(header);\n    const lv_calendar_date_t * cur_date = lv_calendar_get_showed_date(calendar);\n\nlv_obj_t * year_dd = ",
    "raw_res": "lv_dropdown_get_ddobj(header, 0);",
    "prompt_res": "lv_obj_get_child(header, 0);",
    "gt": "lv_obj_get_child(header, 0);"
  },
  {
    "id": 2765,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar_header_arrow.c",
    "input": "/**\n * @file lv_calendar_header_arrow.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n#include \"lv_calendar_header_arrow.h\"\n#if LV_USE_CALENDAR_HEADER_ARROW\n\n#include \"lv_calendar.h\"\n#include \"../../../widgets/lv_btn.h\"\n#include \"../../../widgets/lv_label.h\"\n#include \"../../layouts/flex/lv_flex.h\"\n\n/*********************\n *      DEFINES\n *********************/\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic void my_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void month_event_cb(lv_event_t * e);\nstatic void value_changed_event_cb(lv_event_t * e);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\nconst lv_obj_class_t lv_calendar_header_arrow_class = {\n    .base_class = &lv_obj_class,\n    .constructor_cb = my_constructor,\n    .width_def = LV_PCT(100),\n    .height_def = LV_DPI_DEF / 3\n};\n\nstatic const char * month_names_def[12] = LV_CALENDAR_DEFAULT_MONTH_NAMES;\n\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\nlv_obj_t * lv_calendar_header_arrow_create(lv_obj_t * parent)\n{\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_calendar_header_arrow_class, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}\n\n/**********************\n *  STATIC FUNCTIONS\n **********************/\n\nstatic void my_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)\n{\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    LV_UNUSED(class_p);\n\n    lv_obj_move_to_index(obj, 0);\n\n    lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_ROW);\n    lv_obj_set_flex_align(obj, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_START);\n\n    lv_obj_t * mo_prev = lv_btn_create(obj);\n    lv_obj_set_style_bg_img_src(mo_prev, LV_SYMBOL_LEFT, 0);\n    lv_obj_set_height(mo_prev, lv_pct(100));\n    lv_obj_update_layout(mo_prev);\n    lv_coord_t btn_size = lv_obj_get_height(mo_prev);\n    lv_obj_set_width(mo_prev, btn_size);\n\n    lv_obj_add_event_cb(mo_prev, month_event_cb, LV_EVENT_CLICKED, NULL);\n    lv_obj_clear_flag(mo_prev, LV_OBJ_FLAG_CLICK_FOCUSABLE);\n\n    lv_obj_t * label = lv_label_create(obj);\n    lv_label_set_long_mode(label, LV_LABEL_LONG_SCROLL_CIRCULAR);\n    lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_CENTER, 0);\n    lv_obj_set_flex_grow(label, 1);\n\n    lv_obj_t * mo_next = lv_btn_create(obj);\n    lv_obj_set_style_bg_img_src(mo_next, LV_SYMBOL_RIGHT, 0);\n    lv_obj_set_size(mo_next, btn_size, btn_size);\n\n    lv_obj_add_event_cb(mo_next, month_event_cb, LV_EVENT_CLICKED, NULL);\n    lv_obj_clear_flag(mo_next, LV_OBJ_FLAG_CLICK_FOCUSABLE);\n\n    lv_obj_add_event_cb(obj, value_changed_event_cb, LV_EVENT_VALUE_CHANGED, NULL);\n    /*Refresh the drop downs*/\n    lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n}\n\nstatic void month_event_cb(lv_event_t * e)\n{\n    lv_obj_t * btn = lv_event_get_target(e);\n\nlv_obj_t * header = ",
    "raw_res": "lv_event_get_user_data(e);",
    "prompt_res": "lv_obj_get_parent(btn);",
    "gt": "lv_obj_get_parent(btn);"
  },
  {
    "id": 2795,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/widgets/led/lv_led.c",
    "input": "/**\n * @file lv_led.c\n *\n */\n\n/*********************\n *      INCLUDES\n *********************/\n#include \"lv_led.h\"\n#if LV_USE_LED\n\n#include \"../../../misc/lv_assert.h\"\n\n/*********************\n *      DEFINES\n *********************/\n#define MY_CLASS &lv_led_class\n\n/**********************\n *      TYPEDEFS\n **********************/\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic void lv_led_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj);\nstatic void lv_led_event(const lv_obj_class_t * class_p, lv_event_t * e);\n\n/**********************\n *  STATIC VARIABLES\n **********************/\nconst lv_obj_class_t lv_led_class  = {\n    .base_class = &lv_obj_class,\n    .constructor_cb = lv_led_constructor,\n    .width_def = LV_DPI_DEF / 5,\n    .height_def = LV_DPI_DEF / 5,\n    .event_cb = lv_led_event,\n    .instance_size = sizeof(lv_led_t),\n};\n\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\n\n/**\n * Create a led objects\n * @param par pointer to an object, it will be the parent of the new led\n * @return pointer to the created led\n */\nlv_obj_t * lv_led_create(lv_obj_t * parent)\n{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}\n\n/*=====================\n * Setter functions\n *====================*/\n\n/**\n * Set the color of the LED\n * @param led       pointer to a LED object\n * @param color     the color of the the LED\n */\nvoid lv_led_set_color(lv_obj_t * obj, lv_color_t color)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_led_t * led = (lv_led_t *)obj;\n    led->color = color;\n    lv_obj_invalidate(obj);\n}\n\n/**\n * Set the brightness of a LED object\n * @param led pointer to a LED object\n * @param bright LV_LED_BRIGHT_MIN (max. dark) ... LV_LED_BRIGHT_MAX (max. light)\n */\nvoid lv_led_set_brightness(lv_obj_t * obj, uint8_t bright)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_led_t * led = (lv_led_t *)obj;\n    if(led->bright == bright) return;\n\n    led->bright = LV_CLAMP(LV_LED_BRIGHT_MIN, bright, LV_LED_BRIGHT_MAX);\n\n    /*Invalidate the object there fore it will be redrawn*/\n    lv_obj_invalidate(obj);\n}\n\n/**\n * Light on a LED\n * @param led pointer to a LED object\n */\nvoid lv_led_on(lv_obj_t * led)\n{\n    lv_led_set_brightness(led, LV_LED_BRIGHT_MAX);\n}\n\n/**\n * Light off a LED\n * @param led pointer to a LED object\n */\nvoid lv_led_off(lv_obj_t * led)\n{\n    lv_led_set_brightness(led, LV_LED_BRIGHT_MIN);\n}\n\n/**\n * Toggle the state of a LED\n * @param led pointer to a LED object\n */\nvoid lv_led_toggle(lv_obj_t * obj)\n{\n    uint8_t bright = lv_led_get_brightness(obj);\n    if(bright > (LV_LED_BRIGHT_MIN + LV_LED_BRIGHT_MAX) >> 1)\n        lv_led_off(obj);\n    else\n        lv_led_on(obj);\n}\n\n/*=====================\n * Getter functions\n *====================*/\n\n/**\n * Get the brightness of a LEd object\n * @param led pointer to LED object\n * @return bright 0 (max. dark) ... 255 (max. light)\n */\nuint8_t lv_led_get_brightness(const lv_obj_t * obj)\n{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_led_t * led = (lv_led_t *)obj;\n    return led->bright;\n}\n\n/**********************\n *   STATIC FUNCTIONS\n **********************/\n\nstatic void lv_led_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)\n{\n    LV_UNUSED(class_p);\n    lv_led_t * led = (lv_led_t *)obj;\n    led->color = lv_theme_get_color_primary(obj);\n    led->bright = LV_LED_BRIGHT_MAX;\n}\n\nstatic void lv_led_event(const lv_obj_class_t * class_p, lv_event_t * e)\n{\n    LV_UNUSED(class_p);\n\n    lv_res_t res;\n\n    /* Call the ancestor's event handler */\n    lv_event_code_t code = lv_event_get_code(e);\n    if(code != LV_EVENT_DRAW_MAIN && code != LV_EVENT_DRAW_MAIN_END) {\n        res = lv_obj_event_base(MY_CLASS, e);\n        if(res != LV_RES_OK) return;\n    }\n\n    lv_obj_t * obj = lv_event_get_target(e);\n    if(code == LV_EVENT_DRAW_MAIN) {\n        /*Make darker colors in a temporary style according to the brightness*/\n        lv_led_t * led = (lv_led_t *)obj;\n\n        lv_draw_rect_dsc_t rect_dsc;\n        lv_draw_rect_dsc_init(&rect_dsc);\n        lv_obj_init_draw_rect_dsc(obj, LV_PART_MAIN, &rect_dsc);\n\n        /*Use the original colors brightness to modify color->led*/\n        rect_dsc.bg_color = lv_color_mix(led->color, lv_color_black(), lv_color_brightness(rect_dsc.bg_color));\n        rect_dsc.bg_grad_color = lv_color_mix(led->color, lv_color_black(), lv_color_brightness(rect_dsc.bg_grad_color));\n        rect_dsc.shadow_color = lv_color_mix(led->color, lv_color_black(), lv_color_brightness(rect_dsc.shadow_color));\n        rect_dsc.border_color = lv_color_mix(led->color, lv_color_black(), lv_color_brightness(rect_dsc.border_color));\n        rect_dsc.outline_color = lv_color_mix(led->color, lv_color_black(), lv_color_brightness(rect_dsc.outline_color));\n\n        /*Mix. the color with black proportionally with brightness*/\n        rect_dsc.bg_color   = lv_color_mix(rect_dsc.bg_color, lv_color_black(), led->bright);\n        rect_dsc.bg_grad_color   = lv_color_mix(rect_dsc.bg_grad_color, lv_color_black(), led->bright);\n        rect_dsc.border_color = lv_color_mix(rect_dsc.border_color, lv_color_black(), led->bright);\n        rect_dsc.shadow_color = lv_color_mix(rect_dsc.shadow_color, lv_color_black(), led->bright);\n        rect_dsc.outline_color = lv_color_mix(rect_dsc.outline_color, lv_color_black(), led->bright);\n\n        /*Set the current shadow width according to brightness proportionally between LV_LED_BRIGHT_OFF\n         * and LV_LED_BRIGHT_ON*/\n        rect_dsc.shadow_width = ((led->bright - LV_LED_BRIGHT_MIN) * rect_dsc.shadow_width) /\n                                (LV_LED_BRIGHT_MAX - LV_LED_BRIGHT_MIN);\n        rect_dsc.shadow_spread = ((led->bright - LV_LED_BRIGHT_MIN) * rect_dsc.shadow_spread) /\n                                 (LV_LED_BRIGHT_MAX - LV_LED_BRIGHT_MIN);\n\nconst lv_area_t * clip_area = ",
    "raw_res": "lv_event_get_clip_area(e);",
    "prompt_res": "lv_event_get_param(e);",
    "gt": "lv_event_get_param(e);"
  },
  {
    "id": 2861,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/libs/qrcode/qrcodegen.c",
    "input": "/* \n * QR Code generator library (C)\n * \n * Copyright (c) Project Nayuki. (MIT License)\n * https://www.nayuki.io/page/qr-code-generator-library\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided \"as is\", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n */\n\n#include <assert.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"qrcodegen.h\"\n\n#ifndef QRCODEGEN_TEST\n\t#define testable static  // Keep functions private\n#else\n\t#define testable  // Expose private functions\n#endif\n\n\n/*---- Forward declarations for private functions ----*/\n\n// Regarding all public and private functions defined in this source file:\n// - They require all pointer/array arguments to be not null unless the array length is zero.\n// - They only read input scalar/array arguments, write to output pointer/array\n//   arguments, and return scalar values; they are \"pure\" functions.\n// - They don't read mutable global variables or write to any global variables.\n// - They don't perform I/O, read the clock, print to console, etc.\n// - They allocate a small and constant amount of stack memory.\n// - They don't allocate or free any memory on the heap.\n// - They don't recurse or mutually recurse. All the code\n//   could be inlined into the top-level public functions.\n// - They run in at most quadratic time with respect to input arguments.\n//   Most functions run in linear time, and some in constant time.\n//   There are no unbounded loops or non-obvious termination conditions.\n// - They are completely thread-safe if the caller does not give the\n//   same writable buffer to concurrent calls to these functions.\n\ntestable void appendBitsToBuffer(unsigned int val, int numBits, uint8_t buffer[], int *bitLen);\n\ntestable void addEccAndInterleave(uint8_t data[], int version, enum qrcodegen_Ecc ecl, uint8_t result[]);\ntestable int getNumDataCodewords(int version, enum qrcodegen_Ecc ecl);\ntestable int getNumRawDataModules(int ver);\n\ntestable void calcReedSolomonGenerator(int degree, uint8_t result[]);\ntestable void calcReedSolomonRemainder(const uint8_t data[], int dataLen,\n\tconst uint8_t generator[], int degree, uint8_t result[]);\ntestable uint8_t finiteFieldMultiply(uint8_t x, uint8_t y);\n\ntestable void initializeFunctionModules(int version, uint8_t qrcode[]);\nstatic void drawWhiteFunctionModules(uint8_t qrcode[], int version);\nstatic void drawFormatBits(enum qrcodegen_Ecc ecl, enum qrcodegen_Mask mask, uint8_t qrcode[]);\ntestable int getAlignmentPatternPositions(int version, uint8_t result[7]);\nstatic void fillRectangle(int left, int top, int width, int height, uint8_t qrcode[]);\n\nstatic void drawCodewords(const uint8_t data[], int dataLen, uint8_t qrcode[]);\nstatic void applyMask(const uint8_t functionModules[], uint8_t qrcode[], enum qrcodegen_Mask mask);\nstatic long getPenaltyScore(const uint8_t qrcode[]);\nstatic void addRunToHistory(unsigned char run, unsigned char history[7]);\nstatic bool hasFinderLikePattern(const unsigned char runHistory[7]);\n\ntestable bool getModule(const uint8_t qrcode[], int x, int y);\ntestable void setModule(uint8_t qrcode[], int x, int y, bool isBlack);\ntestable void setModuleBounded(uint8_t qrcode[], int x, int y, bool isBlack);\nstatic bool getBit(int x, int i);\n\ntestable int calcSegmentBitLength(enum qrcodegen_Mode mode, size_t numChars);\ntestable int getTotalBits(const struct qrcodegen_Segment segs[], size_t len, int version);\nstatic int numCharCountBits(enum qrcodegen_Mode mode, int version);\n\n\n\n/*---- Private tables of constants ----*/\n\n// The set of all legal characters in alphanumeric mode, where each character\n// value maps to the index in the string. For checking text and encoding segments.\nstatic const char *ALPHANUMERIC_CHARSET = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\";\n\n// For generating error correction codes.\ntestable const int8_t ECC_CODEWORDS_PER_BLOCK[4][41] = {\n\t// Version: (note that index 0 is for padding, and is set to an illegal value)\n\t//0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n\t{-1,  7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // Low\n\t{-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28},  // Medium\n\t{-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // Quartile\n\t{-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // High\n};\n\n#define qrcodegen_REED_SOLOMON_DEGREE_MAX 30  // Based on the table above\n\n// For generating error correction codes.\ntestable const int8_t NUM_ERROR_CORRECTION_BLOCKS[4][41] = {\n\t// Version: (note that index 0 is for padding, and is set to an illegal value)\n\t//0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n\t{-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4,  4,  4,  4,  4,  6,  6,  6,  6,  7,  8,  8,  9,  9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25},  // Low\n\t{-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5,  5,  8,  9,  9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49},  // Medium\n\t{-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8,  8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68},  // Quartile\n\t{-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81},  // High\n};\n\n// For automatic mask pattern selection.\nstatic const int PENALTY_N1 =  3;\nstatic const int PENALTY_N2 =  3;\nstatic const int PENALTY_N3 = 40;\nstatic const int PENALTY_N4 = 10;\n\n\n\n/*---- High-level QR Code encoding functions ----*/\n\n// Public function - see documentation comment in header file.\nbool qrcodegen_encodeText(const char *text, uint8_t tempBuffer[], uint8_t qrcode[],\n\t\tenum qrcodegen_Ecc ecl, int minVersion, int maxVersion, enum qrcodegen_Mask mask, bool boostEcl) {\n\t\n\tsize_t textLen = strlen(text);\n\tif (textLen == 0)\n\t\treturn qrcodegen_encodeSegmentsAdvanced(NULL, 0, ecl, minVersion, maxVersion, mask, boostEcl, tempBuffer, qrcode);\n\tsize_t bufLen = qrcodegen_BUFFER_LEN_FOR_VERSION(maxVersion);\n\t\n\tstruct qrcodegen_Segment seg;\n\tif (qrcodegen_isNumeric(text)) {\n\t\tif (qrcodegen_calcSegmentBufferSize(qrcodegen_Mode_NUMERIC, textLen) > bufLen)\n\t\t\tgoto fail;\nseg = ",
    "raw_res": "0;",
    "prompt_res": "qrcodegen_makeNumeric(text, tempBuffer);",
    "gt": "qrcodegen_makeNumeric(text, tempBuffer);"
  },
  {
    "id": 2891,
    "pkg": "t113-system-prj",
    "fpath": "carbit_updater/lvgl/src/extra/libs/sjpg/lv_sjpg.c",
    "input": "/**\n * @file lv_sjpg.c\n *\n */\n\n/*----------------------------------------------------------------------------------------------------------------------------------\n/    Added normal JPG support [7/10/2020]\n/    ----------\n/    SJPEG is a custom created modified JPEG file format for small embedded platforms.\n/    It will contain multiple JPEG fragments all embedded into a single file with a custom header.\n/    This makes JPEG decoding easier using any JPEG library. Overall file size will be almost\n/    similar to the parent jpeg file. We can generate sjpeg from any jpeg using a python script\n/    provided along with this project.\n/                                                                                     (by vinodstanur | 2020 )\n/    SJPEG FILE STRUCTURE\n/    --------------------------------------------------------------------------------------------------------------------------------\n/    Bytes                       |   Value                                                                                           |\n/    --------------------------------------------------------------------------------------------------------------------------------\n/\n/    0 - 7                       |   \"_SJPG__\" followed by '\\0'\n/\n/    8 - 13                      |   \"V1.00\" followed by '\\0'       [VERSION OF SJPG FILE for future compatibiliby]\n/\n/    14 - 15                     |   X_RESOLUTION (width)            [little endian]\n/\n/    16 - 17                     |   Y_RESOLUTION (height)           [little endian]\n/\n/    18 - 19                     |   TOTAL_FRAMES inside sjpeg       [little endian]\n/\n/    20 - 21                     |   JPEG BLOCK WIDTH (16 normally)  [little endian]\n/\n/    22 - [(TOTAL_FRAMES*2 )]    |   SIZE OF EACH JPEG SPLIT FRAGMENTS   (FRAME_INFO_ARRAY)\n/\n/   SJPEG data                   |   Each JPEG frame can be extracted from SJPEG data by parsing the FRAME_INFO_ARRAY one time.\n/\n/----------------------------------------------------------------------------------------------------------------------------------\n/                   JPEG DECODER\n/                   ------------\n/\tWe are using TJpgDec - Tiny JPEG Decompressor library from ELM-CHAN for decoding each split-jpeg fragments.\n/\tThe tjpgd.c and tjpgd.h is not modified and those are used as it is. So if any update comes for the tiny-jpeg,\n/\tjust replace those files with updated files.\n/---------------------------------------------------------------------------------------------------------------------------------*/\n\n/*********************\n *      INCLUDES\n *********************/\n\n#include \"../../../lvgl.h\"\n#if LV_USE_SJPG\n\n#include \"tjpgd.h\"\n#include \"lv_sjpg.h\"\n#include \"../../../misc/lv_fs.h\"\n\n/*********************\n *      DEFINES\n *********************/\n#define TJPGD_WORKBUFF_SIZE             4096    //Recommended by TJPGD libray\n\n//NEVER EDIT THESE OFFSET VALUES\n#define SJPEG_VERSION_OFFSET            8\n#define SJPEG_X_RES_OFFSET              14\n#define SJPEG_y_RES_OFFSET              16\n#define SJPEG_TOTAL_FRAMES_OFFSET       18\n#define SJPEG_BLOCK_WIDTH_OFFSET        20\n#define SJPEG_FRAME_INFO_ARRAY_OFFSET   22\n\n/**********************\n *      TYPEDEFS\n **********************/\n\nenum io_source_type {\n    SJPEG_IO_SOURCE_C_ARRAY,\n    SJPEG_IO_SOURCE_DISK,\n};\n\ntypedef struct {\n    enum io_source_type type;\n    lv_fs_file_t lv_file;\n    uint8_t* img_cache_buff;\n    int img_cache_x_res;\n    int img_cache_y_res;\n    uint8_t *raw_sjpg_data;               //Used when type==SJPEG_IO_SOURCE_C_ARRAY.\n    uint32_t raw_sjpg_data_size;          //Num bytes pointed to by raw_sjpg_data.\n    uint32_t raw_sjpg_data_next_read_pos; //Used for all types.\n} io_source_t;\n\n\ntypedef struct {\n    uint8_t *sjpeg_data;\n    uint32_t sjpeg_data_size;\n    int sjpeg_x_res;\n    int sjpeg_y_res;\n    int sjpeg_total_frames;\n    int sjpeg_single_frame_height;\n    int sjpeg_cache_frame_index;\n    uint8_t **frame_base_array;         //to save base address of each split frames upto sjpeg_total_frames.\n    int *frame_base_offset;             //to save base offset for fseek\n    uint8_t *frame_cache;\n    uint8_t* workb;                     //JPG work buffer for jpeg library\n    JDEC *tjpeg_jd;\n    io_source_t io;\n} SJPEG;\n\n/**********************\n *  STATIC PROTOTYPES\n **********************/\nstatic lv_res_t decoder_info( lv_img_decoder_t * decoder, const void * src, lv_img_header_t * header );\nstatic lv_res_t decoder_open( lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc );\nstatic lv_res_t decoder_read_line( lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc, lv_coord_t x,lv_coord_t y, lv_coord_t len, uint8_t * buf );\nstatic void decoder_close( lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc );\nstatic size_t input_func ( JDEC* jd, uint8_t* buff, size_t ndata );\nstatic int is_jpg( const uint8_t *raw_data );\nstatic void lv_sjpg_cleanup( SJPEG* sjpeg );\nstatic void lv_sjpg_free( SJPEG* sjpeg );\n\n/**********************\n *  STATIC VARIABLES\n **********************/\n\n/**********************\n *      MACROS\n **********************/\n\n/**********************\n *   GLOBAL FUNCTIONS\n **********************/\nvoid lv_split_jpeg_init( void )\n{\n    lv_img_decoder_t* dec = lv_img_decoder_create( );\n    lv_img_decoder_set_info_cb( dec, decoder_info );\n    lv_img_decoder_set_open_cb( dec, decoder_open );\n    lv_img_decoder_set_close_cb( dec, decoder_close );\n    lv_img_decoder_set_read_line_cb( dec, decoder_read_line );\n}\n\n/**********************\n *   STATIC FUNCTIONS\n **********************/\n/**\n * Get info about an SJPG / JPG image\n * @param decoder pointer to the decoder where this function belongs\n * @param src can be file name or pointer to a C array\n * @param header store the info here\n * @return LV_RES_OK: no error; LV_RES_INV: can't get the info\n */\nstatic lv_res_t decoder_info( lv_img_decoder_t * decoder, const void * src, lv_img_header_t * header )\n{\n    LV_UNUSED(decoder);\n\n    /*Check whether the type `src` is known by the decoder*/\n    /* Read the SJPG/JPG header and find `width` and `height` */\n\n    lv_img_src_t src_type = lv_img_src_get_type(src);          /*Get the source type*/\n\n    lv_res_t ret = LV_RES_OK;\n\n    if(src_type == LV_IMG_SRC_VARIABLE) {\n        uint8_t *raw_sjpeg_data = (uint8_t *)((lv_img_dsc_t * )src)->data;\n        const uint32_t raw_sjpeg_data_size = ((lv_img_dsc_t *)src)->data_size;\n\n        if(!strncmp((char *)raw_sjpeg_data, \"_SJPG__\", strlen(\"_SJPG__\") )) {\n\n            raw_sjpeg_data += 14; //seek to res info ... refer sjpeg format\n            header->always_zero = 0;\n            header->cf = LV_IMG_CF_RAW;\n\n            header->w = *raw_sjpeg_data++;\n            header->w |= *raw_sjpeg_data++ << 8;\n\n            header->h = *raw_sjpeg_data++;\n            header->h |= *raw_sjpeg_data++ << 8;\n\n            return ret;\n\n        } else if( is_jpg( raw_sjpeg_data ) == true ) {\n            header->always_zero = 0;\n            header->cf = LV_IMG_CF_RAW;\n\n            uint8_t *workb_temp = lv_mem_alloc( TJPGD_WORKBUFF_SIZE );\n            if(!workb_temp) return LV_RES_INV;\n\n            io_source_t io_source_temp;\n            io_source_temp.type = SJPEG_IO_SOURCE_C_ARRAY;\n            io_source_temp.raw_sjpg_data = raw_sjpeg_data;\n            io_source_temp.raw_sjpg_data_size = raw_sjpeg_data_size;\n            io_source_temp.raw_sjpg_data_next_read_pos = 0;\n\n            JDEC jd_tmp;\n\n            JRESULT rc = jd_prepare( &jd_tmp, input_func, workb_temp, (size_t)TJPGD_WORKBUFF_SIZE, &io_source_temp);\n            if(rc == JDR_OK ) {\n                header->w = jd_tmp.width;\n                header->h = jd_tmp.height;\n\n            } else {\n                ret = LV_RES_INV;\n                goto end;\n            }\n\n            end:\n            lv_mem_free(workb_temp);\n\n            return ret;\n\n        }\n    }\n    else if( src_type == LV_IMG_SRC_FILE ) {\n        const char * fn = src;\n        if(!strcmp(&fn[strlen(fn) - 5], \".sjpg\")) {\n\n            uint8_t buff[22];\n            memset(buff, 0, sizeof(buff));\n\n            lv_fs_file_t file;\n            lv_fs_res_t res = lv_fs_open(&file , fn, LV_FS_MODE_RD);\n            if(res != LV_FS_RES_OK) return 78;\n\n            uint32_t rn;\n            res = lv_fs_read(&file, buff, 8, &rn);\n            if(res != LV_FS_RES_OK || rn != 8) {\n                lv_fs_close(&file);\n                return LV_RES_INV;\n            }\n\n            if(strcmp((char *)buff, \"_SJPG__\") == 0 ) {\n                lv_fs_seek(&file, 14, LV_FS_SEEK_SET);\n                res = lv_fs_read(&file, buff, 4, &rn);\n                if(res != LV_FS_RES_OK || rn != 4 ) {\n                    lv_fs_close(&file);\n                    return LV_RES_INV;\n                }\n                header->always_zero = 0;\n                header->cf = LV_IMG_CF_RAW;\n                uint8_t *raw_sjpeg_data = buff;\n                header->w = *raw_sjpeg_data++;\n                header->w |= *raw_sjpeg_data++ << 8;\n                header->h = *raw_sjpeg_data++;\n                header->h |= *raw_sjpeg_data++ << 8;\n                lv_fs_close(&file);\n                return LV_RES_OK;\n\n            }\n        } else if(!strcmp(&fn[strlen(fn) - 4], \".jpg\")) {\n            lv_fs_file_t file;\n            lv_fs_res_t res = lv_fs_open(&file , fn, LV_FS_MODE_RD);\n            if(res != LV_FS_RES_OK) return 78;\n\n            uint8_t *workb_temp = lv_mem_alloc( TJPGD_WORKBUFF_SIZE );\n            if(!workb_temp) {\n                lv_fs_close(&file);\n                return LV_RES_INV;\n            }\n\n            io_source_t io_source_temp;\n            io_source_temp.type = SJPEG_IO_SOURCE_DISK;\n            io_source_temp.raw_sjpg_data_next_read_pos = 0;\n            io_source_temp.img_cache_buff = NULL;\n            io_source_temp.lv_file = file;\n            JDEC jd_tmp;\n\n            JRESULT rc = jd_prepare( &jd_tmp, input_func, workb_temp, (size_t)TJPGD_WORKBUFF_SIZE, &io_source_temp);\n            lv_mem_free(workb_temp);\n            lv_fs_close(&file);\n\n            if(rc == JDR_OK ) {\n                header->always_zero = 0;\n                header->cf = LV_IMG_CF_RAW;\n                header->w = jd_tmp.width;\n                header->h = jd_tmp.height;\n                return LV_RES_OK;\n            }\n        }\n    }\n    return LV_RES_INV;\n}\n\nstatic int img_data_cb( JDEC* jd, void* data, JRECT* rect )\n{\n    io_source_t *io = jd->device;\n    uint8_t *cache = io->img_cache_buff;\n    const int xres = io->img_cache_x_res;\n    uint8_t *buf = data;\n    const int INPUT_PIXEL_SIZE = 3;\n    const int row_width = rect->right - rect->left + 1; // Row width in pixels.\n    const int row_size = row_width * INPUT_PIXEL_SIZE;  // Row size (bytes).\n\n    for( int y = rect->top; y <= rect->bottom; y++ ) {\n        int row_offset = y * xres * INPUT_PIXEL_SIZE + rect->left * INPUT_PIXEL_SIZE;\n        memcpy( cache + row_offset, buf, row_size );\n        buf += row_size;\n    }\n\n    return 1;\n}\n\nstatic size_t input_func ( JDEC* jd, uint8_t* buff, size_t ndata )\n{\n    io_source_t *io = jd->device;\n\n    if(!io) return 0;\n\n    if(io->type == SJPEG_IO_SOURCE_C_ARRAY) {\n        const uint32_t bytes_left = io->raw_sjpg_data_size - io->raw_sjpg_data_next_read_pos;\n        const uint32_t to_read = ndata <= bytes_left ? (uint32_t)ndata : bytes_left;\n        if (to_read == 0)\n            return 0;\n        if(buff) {\n            memcpy(buff, io->raw_sjpg_data + io->raw_sjpg_data_next_read_pos, to_read);\n        }\n        io->raw_sjpg_data_next_read_pos += to_read;\n        return to_read;\n    }\n    else if(io->type == SJPEG_IO_SOURCE_DISK) {\n\n        lv_fs_file_t* lv_file_p = &(io->lv_file);\n\n        if( buff ) {\n            uint32_t rn = 0;\n            lv_fs_read(lv_file_p, buff, (uint32_t)ndata, &rn);\n            return rn;\n        } else {\n            uint32_t pos;\n            lv_fs_tell(lv_file_p, &pos);\n            lv_fs_seek(lv_file_p, (uint32_t)(ndata + pos),  LV_FS_SEEK_SET);\n            return ndata;\n        }\n    }\n    return 0;\n}\n\n/**\n * Open SJPG image and return the decided image\n * @param decoder pointer to the decoder where this function belongs\n * @param dsc pointer to a descriptor which describes this decoding session\n * @return LV_RES_OK: no error; LV_RES_INV: can't get the info\n */\nstatic lv_res_t decoder_open( lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc )\n{\n    LV_UNUSED(decoder);\n    lv_res_t lv_ret = LV_RES_OK;\n\n    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {\n        uint8_t *data;\n        SJPEG* sjpeg = ( SJPEG* ) dsc->user_data;\n        if( sjpeg == NULL ) {\n            sjpeg =  lv_mem_alloc( sizeof( SJPEG ) );\n            if( !sjpeg ) return LV_RES_INV;\n\n            memset(sjpeg, 0, sizeof(SJPEG));\n\n            dsc->user_data = sjpeg;\n            sjpeg->sjpeg_data = (uint8_t *)( ( lv_img_dsc_t* )(dsc->src) )->data;\n            sjpeg->sjpeg_data_size = ( ( lv_img_dsc_t* )(dsc->src) )->data_size;\n        }\n\n        if( !strncmp( ( char * ) sjpeg->sjpeg_data, \"_SJPG__\", strlen(\"_SJPG__\") ) ) {\n\n            data = sjpeg->sjpeg_data;\n            data += 14;\n\n            sjpeg->sjpeg_x_res = *data++;\n            sjpeg->sjpeg_x_res |= *data++ << 8;\n\n            sjpeg->sjpeg_y_res = *data++;\n            sjpeg->sjpeg_y_res |= *data++ << 8;\n\n            sjpeg->sjpeg_total_frames = *data++;\n            sjpeg->sjpeg_total_frames |= *data++ << 8;\n\n            sjpeg->sjpeg_single_frame_height = *data++;\n            sjpeg->sjpeg_single_frame_height |= *data++ << 8;\n\n            sjpeg->frame_base_array = lv_mem_alloc( sizeof(uint8_t *) * sjpeg->sjpeg_total_frames );\n            if( ! sjpeg->frame_base_array ) {\n                lv_sjpg_cleanup( sjpeg );\n                sjpeg = NULL;\n                return LV_RES_INV;\n            }\n\n            sjpeg->frame_base_offset = NULL;\n\n            uint8_t *img_frame_base = data +  sjpeg->sjpeg_total_frames *2;\n            sjpeg->frame_base_array[0] = img_frame_base;\n\n            for( int i = 1; i <  sjpeg->sjpeg_total_frames; i++ ) {\n                int offset = *data++;\n                offset |= *data++ <<8;\n                sjpeg->frame_base_array[i] = sjpeg->frame_base_array[i-1] + offset;\n            }\n            sjpeg->sjpeg_cache_frame_index = -1;\n            sjpeg->frame_cache = (void *)lv_mem_alloc( sjpeg->sjpeg_x_res * sjpeg->sjpeg_single_frame_height * 3/*2*/ );\n            if( ! sjpeg->frame_cache ) {\n                lv_sjpg_cleanup( sjpeg );\n                sjpeg = NULL;\n                return LV_RES_INV;\n            }\n            sjpeg->io.img_cache_buff = sjpeg->frame_cache;\n            sjpeg->io.img_cache_x_res = sjpeg->sjpeg_x_res;\n            sjpeg->workb =   lv_mem_alloc( TJPGD_WORKBUFF_SIZE );\n            if( ! sjpeg->workb ) {\n                lv_sjpg_cleanup( sjpeg );\n                sjpeg = NULL;\n                return LV_RES_INV;\n            }\n\n            sjpeg->tjpeg_jd =   lv_mem_alloc( sizeof( JDEC ) );\n            if( ! sjpeg->tjpeg_jd ) {\n                lv_sjpg_cleanup( sjpeg );\n                sjpeg = NULL;\n                return LV_RES_INV;\n            }\n            sjpeg->io.type = SJPEG_IO_SOURCE_C_ARRAY;\n            sjpeg->io.lv_file.file_d = NULL;\n            dsc->img_data = NULL;\n            return lv_ret;\n        }\n\n        else if( is_jpg( sjpeg->sjpeg_data ) == true ) {\n\n            uint8_t *workb_temp = lv_mem_alloc( TJPGD_WORKBUFF_SIZE );\n            if( ! workb_temp ) {\n                lv_sjpg_cleanup( sjpeg );\n                sjpeg = NULL;\n                return LV_RES_INV;\n            }\n            io_source_t io_source_temp;\n            io_source_temp.type = SJPEG_IO_SOURCE_C_ARRAY;\n            io_source_temp.raw_sjpg_data =  sjpeg->sjpeg_data;\n            io_source_temp.raw_sjpg_data_size = sjpeg->sjpeg_data_size;\n            io_source_temp.raw_sjpg_data_next_read_pos = 0;\n\n            JDEC jd_tmp;\n            JRESULT rc = jd_prepare( &jd_tmp, input_func, workb_temp, (size_t)TJPGD_WORKBUFF_SIZE, &io_source_temp);\n            lv_mem_free(workb_temp);\n\n\n            if(rc == JDR_OK ) {\n                sjpeg->sjpeg_x_res = jd_tmp.width;\n                sjpeg->sjpeg_y_res = jd_tmp.height;\n                sjpeg->sjpeg_total_frames = 1;\n                sjpeg->sjpeg_single_frame_height = jd_tmp.height;\n\n                sjpeg->frame_base_array = lv_mem_alloc( sizeof(uint8_t *) * sjpeg->sjpeg_total_frames );\n                if( ! sjpeg->frame_base_array ) {\n                    lv_sjpg_cleanup( sjpeg );\n                    sjpeg = NULL;\n                    return LV_RES_INV;\n                }\n                sjpeg->frame_base_offset = NULL;\n\n                uint8_t *img_frame_base = sjpeg->sjpeg_data;\n                sjpeg->frame_base_array[0] = img_frame_base;\n\n                sjpeg->sjpeg_cache_frame_index = -1;\n                sjpeg->frame_cache = (void *)lv_mem_alloc( sjpeg->sjpeg_x_res * sjpeg->sjpeg_single_frame_height * 3 );\n                if( ! sjpeg->frame_cache ) {\n                    lv_sjpg_cleanup( sjpeg );\n                    sjpeg = NULL;\n                    return LV_RES_INV;\n                }\n\n                sjpeg->io.img_cache_buff = sjpeg->frame_cache;\n                sjpeg->io.img_cache_x_res = sjpeg->sjpeg_x_res;\n                sjpeg->workb =   lv_mem_alloc( TJPGD_WORKBUFF_SIZE );\n                if( ! sjpeg->workb ) {\n                    lv_sjpg_cleanup( sjpeg );\n                    sjpeg = NULL;\n                    return LV_RES_INV;\n                }\n\n                sjpeg->tjpeg_jd =   lv_mem_alloc( sizeof( JDEC ) );\n                if( ! sjpeg->tjpeg_jd ) {\n                    lv_sjpg_cleanup( sjpeg );\n                    sjpeg = NULL;\n                    return LV_RES_INV;\n                }\n\n                sjpeg->io.type = SJPEG_IO_SOURCE_C_ARRAY;\n                sjpeg->io.lv_file.file_d = NULL;\n                dsc->img_data = NULL;\n                return lv_ret;\n            } else {\n                lv_ret = LV_RES_INV;\n                goto end;\n            }\n\n            end:\n            lv_mem_free(workb_temp);\n\n            return lv_ret;\n        }\n    }\n    else if(dsc->src_type == LV_IMG_SRC_FILE) {\n        /* If all fine, then the file will be kept open */\n        const char * fn = dsc->src;\n        uint8_t *data;\n\n        if(!strcmp(&fn[strlen(fn) - 5], \".sjpg\")) {\n\n            uint8_t buff[22];\n            memset(buff, 0, sizeof(buff));\n\n\n            lv_fs_file_t lv_file;\n            lv_fs_res_t res = lv_fs_open(&lv_file , fn, LV_FS_MODE_RD);\n            if(res != LV_FS_RES_OK) {\n                return 78;\n            }\n\n\n            uint32_t rn;\nres = ",
    "raw_res": "lv_fs_read(&lv_file, buff, 8, &rn);",
    "prompt_res": "lv_fs_read(&lv_file, buff, 22, &rn);",
    "gt": "lv_fs_read(&lv_file, buff, 22, &rn);"
  }
]