{"carbit_updater/lvgl/src/draw/lv_draw_line.h": {"lv_draw_blend": {"type": "Variable", "def": "#include lv_draw_blend.h", "sline": 16, "include": ["carbit_updater/lvgl/src/draw/lv_draw_blend.h", null]}, "lv_draw_line_dsc_t.color": {"type": "Variable", "def": "lv_color_t color", "sline": 26, "in_struct": "lv_draw_line_dsc_t"}, "lv_draw_line_dsc_t.width": {"type": "Variable", "def": "lv_coord_t width", "sline": 27, "in_struct": "lv_draw_line_dsc_t"}, "lv_draw_line_dsc_t.dash_width": {"type": "Variable", "def": "lv_coord_t dash_width", "sline": 28, "in_struct": "lv_draw_line_dsc_t"}, "lv_draw_line_dsc_t.dash_gap": {"type": "Variable", "def": "lv_coord_t dash_gap", "sline": 29, "in_struct": "lv_draw_line_dsc_t"}, "lv_draw_line_dsc_t.opa": {"type": "Variable", "def": "lv_opa_t opa", "sline": 30, "in_struct": "lv_draw_line_dsc_t"}, "lv_draw_line_dsc_t.blend_mode": {"type": "Variable", "def": "lv_blend_mode_t blend_mode  : 2", "sline": 31, "in_struct": "lv_draw_line_dsc_t"}, "lv_draw_line_dsc_t.round_start": {"type": "Variable", "def": "uint8_t round_start : 1", "sline": 32, "in_struct": "lv_draw_line_dsc_t"}, "lv_draw_line_dsc_t.round_end": {"type": "Variable", "def": "uint8_t round_end   : 1", "sline": 33, "in_struct": "lv_draw_line_dsc_t"}, "lv_draw_line_dsc_t.raw_end": {"type": "Variable", "def": "uint8_t raw_end     : 1", "sline": 34, "in_struct": "lv_draw_line_dsc_t"}, "lv_draw_line_dsc_t": {"type": "Variable", "def": "typedef struct {\n    lv_color_t color;\n    lv_coord_t width;\n    lv_coord_t dash_width;\n    lv_coord_t dash_gap;\n    lv_opa_t opa;\n    lv_blend_mode_t blend_mode  : 2;\n    uint8_t round_start : 1;\n    uint8_t round_end   : 1;\n    uint8_t raw_end     : 1;    /*Do not bother with perpendicular line ending if it's not visible for any reason*/\n} lv_draw_line_dsc_t", "sline": 35, "docstring": "/**********************"}, "lv_draw_line": {"type": "Function", "def": "void lv_draw_line(const lv_point_t * point1, const lv_point_t * point2, const lv_area_t * clip,\n                                        const lv_draw_line_dsc_t * dsc)", "sline": 49}, "lv_draw_line_dsc_init": {"type": "Function", "def": "void lv_draw_line_dsc_init(lv_draw_line_dsc_t * dsc)", "sline": 52}, "carbit_updater/lvgl/src/draw/lv_draw_line.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_draw_line.h"}}, "carbit_updater/lvgl/src/extra/widgets/tileview/lv_tileview.c": {"lv_tileview": {"type": "Variable", "def": "#include lv_tileview.h", "sline": 9, "include": ["carbit_updater/lvgl/src/extra/widgets/tileview/lv_tileview.h", null]}, "lv_tileview_constructor": {"type": "Function", "def": "static void lv_tileview_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 122, "body": "{\n    LV_UNUSED(class_p);\n    lv_obj_set_size(obj, LV_PCT(100), LV_PCT(100));\n    lv_obj_add_event_cb(obj, tileview_event_cb, LV_EVENT_ALL, NULL);\n    lv_obj_add_flag(obj, LV_OBJ_FLAG_SCROLL_ONE);\n    lv_obj_set_scroll_snap_x(obj, LV_SCROLL_SNAP_CENTER);\n    lv_obj_set_scroll_snap_y(obj, LV_SCROLL_SNAP_CENTER);\n\n}"}, "lv_tileview_tile_constructor": {"type": "Function", "def": "static void lv_tileview_tile_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 133, "body": "{\n\n    LV_UNUSED(class_p);\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    lv_obj_set_size(obj, LV_PCT(100), LV_PCT(100));\n    lv_obj_update_layout(obj);  /*Be sure the size is correct*/\n    lv_obj_set_pos(obj, create_col_id * lv_obj_get_content_width(parent),\n                   create_row_id * lv_obj_get_content_height(parent));\n\n    lv_tileview_tile_t * tile = (lv_tileview_tile_t *)obj;\n    tile->dir = create_dir;\n\n    if(create_col_id == 0 && create_row_id == 0) {\n        lv_obj_set_scroll_dir(parent, create_dir);\n    }\n}"}, "tileview_event_cb": {"type": "Function", "def": "static void tileview_event_cb(lv_event_t * e)", "sline": 151, "body": "{\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_tileview_t * tv = (lv_tileview_t *) obj;\n\n    if(code == LV_EVENT_SCROLL_END) {\n        lv_coord_t w = lv_obj_get_content_width(obj);\n        lv_coord_t h = lv_obj_get_content_height(obj);\n\n        lv_point_t scroll_end;\n        lv_obj_get_scroll_end(obj, &scroll_end);\n        lv_coord_t left = scroll_end.x;\n        lv_coord_t top = scroll_end.y;\n\n        lv_coord_t tx = ((left + (w / 2)) / w) * w;\n        lv_coord_t ty = ((top + (h / 2)) / h) * h;\n\n        lv_dir_t dir = LV_DIR_ALL;\n        uint32_t i;\n        for(i = 0; i < lv_obj_get_child_cnt(obj); i++) {\n            lv_obj_t * tile_obj = lv_obj_get_child(obj, i);\n            lv_coord_t x = lv_obj_get_x(tile_obj);\n            lv_coord_t y = lv_obj_get_y(tile_obj);\n            if(x == tx && y == ty) {\n                lv_tileview_tile_t * tile = (lv_tileview_tile_t *)tile_obj;\n                tv->tile_act = (lv_obj_t *)tile;\n                dir = tile->dir;\n                lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n                break;\n            }\n        }\n        lv_obj_set_scroll_dir(obj, dir);\n    }\n}"}, "lv_tileview_class": {"type": "Variable", "def": "const lv_obj_class_t lv_tileview_class = {.constructor_cb = lv_tileview_constructor,\n                                          .base_class = &lv_obj_class,\n                                          .instance_size = sizeof(lv_tileview_t)\n                                         }", "sline": 31}, "lv_tileview_tile_class": {"type": "Variable", "def": "const lv_obj_class_t lv_tileview_tile_class = {.constructor_cb = lv_tileview_tile_constructor,\n                                               .base_class = &lv_obj_class,\n                                               .instance_size = sizeof(lv_tileview_tile_t)\n                                              }", "sline": 36}, "create_dir": {"type": "Variable", "def": "static lv_dir_t create_dir", "sline": 41}, "create_col_id": {"type": "Variable", "def": "static uint32_t create_col_id", "sline": 42}, "create_row_id": {"type": "Variable", "def": "static uint32_t create_row_id", "sline": 43}, "lv_tileview_create": {"type": "Function", "def": "lv_obj_t * lv_tileview_create(lv_obj_t * parent)", "sline": 53, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_tileview_class, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_tileview_add_tile": {"type": "Function", "def": "lv_obj_t * lv_tileview_add_tile(lv_obj_t * tv, uint8_t col_id, uint8_t row_id, lv_dir_t dir)", "sline": 65, "body": "{\n    LV_LOG_INFO(\"begin\");\n    create_dir = dir;\n    create_col_id = col_id;\n    create_row_id = row_id;\n\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_tileview_tile_class, tv);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_obj_set_tile": {"type": "Function", "def": "void lv_obj_set_tile(lv_obj_t * obj, lv_obj_t * tile_obj, lv_anim_enable_t anim_en)", "sline": 77, "body": "{\n    lv_coord_t tx = lv_obj_get_x(tile_obj);\n    lv_coord_t ty = lv_obj_get_y(tile_obj);\n\n    lv_tileview_tile_t * tile = (lv_tileview_tile_t *)tile_obj;\n    lv_tileview_t * tv = (lv_tileview_t *) obj;\n    tv->tile_act = (lv_obj_t *)tile;\n\n    lv_obj_set_scroll_dir(obj, tile->dir);\n    lv_obj_scroll_to(obj, tx, ty, anim_en);\n}"}, "lv_obj_set_tile_id": {"type": "Function", "def": "void lv_obj_set_tile_id(lv_obj_t * tv, uint32_t col_id, uint32_t row_id, lv_anim_enable_t anim_en)", "sline": 90, "body": "{\n    lv_coord_t w = lv_obj_get_content_width(tv);\n    lv_coord_t h = lv_obj_get_content_height(tv);\n\n    lv_coord_t tx = col_id * w;\n    lv_coord_t ty = row_id * h;\n\n    uint32_t i;\n    for(i = 0; i < lv_obj_get_child_cnt(tv); i++) {\n        lv_obj_t * tile_obj = lv_obj_get_child(tv, i);\n        lv_coord_t x = lv_obj_get_x(tile_obj);\n        lv_coord_t y = lv_obj_get_y(tile_obj);\n        if(x == tx && y == ty) {\n            lv_obj_set_tile(tv, tile_obj, anim_en);\n            return;\n        }\n    }\n\n    LV_LOG_WARN(\"No tile found with at (%d,%d) index\", (int)col_id, (int)row_id);\n}"}, "lv_tileview_get_tile_act": {"type": "Function", "def": "lv_obj_t * lv_tileview_get_tile_act(lv_obj_t * obj)", "sline": 112, "body": "{\n    lv_tileview_t * tv = (lv_tileview_t *) obj;\n    return tv->tile_act;\n}"}, "carbit_updater/lvgl/src/extra/widgets/tileview/lv_tileview.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/tileview/lv_tileview.c"}}, "carbit_updater/lvgl/src/core/lv_refr.c": {"stddef": {"type": "Variable", "def": "#include stddef.h", "sline": 9}, "lv_refr": {"type": "Variable", "def": "#include lv_refr.h", "sline": 10, "include": ["carbit_updater/lvgl/src/core/lv_refr.h", null]}, "lv_disp": {"type": "Variable", "def": "#include lv_disp.h", "sline": 11, "include": ["carbit_updater/lvgl/src/core/lv_disp.h", null]}, "lv_hal_tick": {"type": "Variable", "def": "#include ../hal/lv_hal_tick.h", "sline": 12}, "lv_hal_disp": {"type": "Variable", "def": "#include ../hal/lv_hal_disp.h", "sline": 13}, "lv_timer": {"type": "Variable", "def": "#include ../misc/lv_timer.h", "sline": 14}, "lv_mem": {"type": "Variable", "def": "#include ../misc/lv_mem.h", "sline": 15}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 16}, "lv_gc": {"type": "Variable", "def": "#include ../misc/lv_gc.h", "sline": 17}, "lv_draw": {"type": "Variable", "def": "#include ../draw/lv_draw.h", "sline": 18}, "lv_font_fmt_txt": {"type": "Variable", "def": "#include ../font/lv_font_fmt_txt.h", "sline": 19}, "lv_refr_join_area": {"type": "Function", "def": "static void lv_refr_join_area(void)", "sline": 333, "docstring": "/**", "body": "{\n    uint32_t join_from;\n    uint32_t join_in;\n    lv_area_t joined_area;\n    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {\n        if(disp_refr->inv_area_joined[join_in] != 0) continue;\n\n        /*Check all areas to join them in 'join_in'*/\n        for(join_from = 0; join_from < disp_refr->inv_p; join_from++) {\n            /*Handle only unjoined areas and ignore itself*/\n            if(disp_refr->inv_area_joined[join_from] != 0 || join_in == join_from) {\n                continue;\n            }\n\n            /*Check if the areas are on each other*/\n            if(_lv_area_is_on(&disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]) == false) {\n                continue;\n            }\n\n            _lv_area_join(&joined_area, &disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]);\n\n            /*Join two area only if the joined area size is smaller*/\n            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +\n                                                 lv_area_get_size(&disp_refr->inv_areas[join_from]))) {\n                lv_area_copy(&disp_refr->inv_areas[join_in], &joined_area);\n\n                /*Mark 'join_form' is joined into 'join_in'*/\n                disp_refr->inv_area_joined[join_from] = 1;\n            }\n        }\n    }\n}"}, "lv_refr_areas": {"type": "Function", "def": "static void lv_refr_areas(void)", "sline": 370, "docstring": "/**", "body": "{\n    px_num = 0;\n\n    if(disp_refr->inv_p == 0) return;\n\n    /*Find the last area which will be drawn*/\n    int32_t i;\n    int32_t last_i = 0;\n    for(i = disp_refr->inv_p - 1; i >= 0; i--) {\n        if(disp_refr->inv_area_joined[i] == 0) {\n            last_i = i;\n            break;\n        }\n    }\n\n    disp_refr->driver->draw_buf->last_area = 0;\n    disp_refr->driver->draw_buf->last_part = 0;\n\n    for(i = 0; i < disp_refr->inv_p; i++) {\n        /*Refresh the unjoined areas*/\n        if(disp_refr->inv_area_joined[i] == 0) {\n\n            if(i == last_i) disp_refr->driver->draw_buf->last_area = 1;\n            disp_refr->driver->draw_buf->last_part = 0;\n            lv_refr_area(&disp_refr->inv_areas[i]);\n\n            px_num += lv_area_get_size(&disp_refr->inv_areas[i]);\n        }\n    }\n}"}, "lv_refr_area": {"type": "Function", "def": "static void lv_refr_area(const lv_area_t * area_p)", "sline": 406, "body": "{\n    /*With full refresh just redraw directly into the buffer*/\n    if(disp_refr->driver->full_refresh) {\n        lv_disp_draw_buf_t * draw_buf = lv_disp_get_draw_buf(disp_refr);\n        draw_buf->area.x1        = 0;\n        draw_buf->area.x2        = lv_disp_get_hor_res(disp_refr) - 1;\n        draw_buf->area.y1        = 0;\n        draw_buf->area.y2        = lv_disp_get_ver_res(disp_refr) - 1;\n        disp_refr->driver->draw_buf->last_part = 1;\n        lv_refr_area_part(area_p);\n        return;\n    }\n\n    /*Normal refresh: draw the area in parts*/\n    lv_disp_draw_buf_t * draw_buf = lv_disp_get_draw_buf(disp_refr);\n    /*Calculate the max row num*/\n    lv_coord_t w = lv_area_get_width(area_p);\n    lv_coord_t h = lv_area_get_height(area_p);\n    lv_coord_t y2 = area_p->y2 >= lv_disp_get_ver_res(disp_refr) ?\n                    lv_disp_get_ver_res(disp_refr) - 1 : area_p->y2;\n\n    int32_t max_row = (uint32_t)draw_buf->size / w;\n\n    if(max_row > h) max_row = h;\n\n    /*Round down the lines of draw_buf if rounding is added*/\n    if(disp_refr->driver->rounder_cb) {\n        lv_area_t tmp;\n        tmp.x1 = 0;\n        tmp.x2 = 0;\n        tmp.y1 = 0;\n\n        lv_coord_t h_tmp = max_row;\n        do {\n            tmp.y2 = h_tmp - 1;\n            disp_refr->driver->rounder_cb(disp_refr->driver, &tmp);\n\n            /*If this height fits into `max_row` then fine*/\n            if(lv_area_get_height(&tmp) <= max_row) break;\n\n            /*Decrement the height of the area until it fits into `max_row` after rounding*/\n            h_tmp--;\n        } while(h_tmp > 0);\n\n        if(h_tmp <= 0) {\n            LV_LOG_WARN(\"Can't set draw_buf height using the round function. (Wrong round_cb or to \"\n                        \"small draw_buf)\");\n            return;\n        }\n        else {\n            max_row = tmp.y2 + 1;\n        }\n    }\n\n    /*In direct mode draw directly on the absolute coordinates of the buffer*/\n    if(disp_refr->driver->direct_mode) {\n        draw_buf->area.x1 = 0;\n        draw_buf->area.x2 = lv_disp_get_hor_res(disp_refr) - 1;\n        draw_buf->area.y1 = 0;\n        draw_buf->area.y2 = lv_disp_get_ver_res(disp_refr) - 1;\n        disp_refr->driver->draw_buf->last_part = disp_refr->driver->draw_buf->last_area;\n        lv_refr_area_part(area_p);\n    }\n    /*Else assume the buffer starts at the given area*/\n    else {\n        /*Always use the full row*/\n        lv_coord_t row;\n        lv_coord_t row_last = 0;\n        for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {\n            /*Calc. the next y coordinates of draw_buf*/\n            draw_buf->area.x1 = area_p->x1;\n            draw_buf->area.x2 = area_p->x2;\n            draw_buf->area.y1 = row;\n            draw_buf->area.y2 = row + max_row - 1;\n            if(draw_buf->area.y2 > y2) draw_buf->area.y2 = y2;\n            row_last = draw_buf->area.y2;\n            if(y2 == row_last) disp_refr->driver->draw_buf->last_part = 1;\n            lv_refr_area_part(area_p);\n        }\n\n        /*If the last y coordinates are not handled yet ...*/\n        if(y2 != row_last) {\n            /*Calc. the next y coordinates of draw_buf*/\n            draw_buf->area.x1 = area_p->x1;\n            draw_buf->area.x2 = area_p->x2;\n            draw_buf->area.y1 = row;\n            draw_buf->area.y2 = y2;\n\n            disp_refr->driver->draw_buf->last_part = 1;\n            lv_refr_area_part(area_p);\n        }\n    }\n}"}, "lv_refr_area_part": {"type": "Function", "def": "static void lv_refr_area_part(const lv_area_t * area_p)", "sline": 505, "body": "{\n    lv_disp_draw_buf_t * draw_buf = lv_disp_get_draw_buf(disp_refr);\n\n    /* Below the `area_p` area will be redrawn into the draw buffer.\n     * In single buffered mode wait here until the buffer is freed.*/\n    if(draw_buf->buf1 && !draw_buf->buf2) {\n        while(draw_buf->flushing) {\n            if(disp_refr->driver->wait_cb) disp_refr->driver->wait_cb(disp_refr->driver);\n        }\n    }\n\n    lv_obj_t * top_act_scr = NULL;\n    lv_obj_t * top_prev_scr = NULL;\n\n    /*Get the new mask from the original area and the act. draw_buf\n     It will be a part of 'area_p'*/\n    lv_area_t start_mask;\n    _lv_area_intersect(&start_mask, area_p, &draw_buf->area);\n\n    /*Get the most top object which is not covered by others*/\n    top_act_scr = lv_refr_get_top_obj(&start_mask, lv_disp_get_scr_act(disp_refr));\n    if(disp_refr->prev_scr) {\n        top_prev_scr = lv_refr_get_top_obj(&start_mask, disp_refr->prev_scr);\n    }\n\n    /*Draw a display background if there is no top object*/\n    if(top_act_scr == NULL && top_prev_scr == NULL) {\n        if(disp_refr->bg_fn) {\n            disp_refr->bg_fn(&start_mask);\n        } else if(disp_refr->bg_img) {\n            lv_draw_img_dsc_t dsc;\n            lv_draw_img_dsc_init(&dsc);\n            dsc.opa = disp_refr->bg_opa;\n            lv_img_header_t header;\n            lv_res_t res;\n            res = lv_img_decoder_get_info(disp_refr->bg_img, &header);\n            if(res == LV_RES_OK) {\n                lv_area_t a;\n                lv_area_set(&a, 0, 0, header.w - 1, header.h - 1);\n                lv_draw_img(&a, &start_mask, disp_refr->bg_img, &dsc);\n            }\n            else {\n                LV_LOG_WARN(\"Can't draw the background image\");\n            }\n        }\n        else {\n            lv_draw_rect_dsc_t dsc;\n            lv_draw_rect_dsc_init(&dsc);\n            dsc.bg_color = disp_refr->bg_color;\n            dsc.bg_opa = disp_refr->bg_opa;\n            lv_draw_rect(&start_mask, &start_mask, &dsc);\n\n        }\n    }\n    /*Refresh the previous screen if any*/\n    if(disp_refr->prev_scr) {\n        /*Get the most top object which is not covered by others*/\n        if(top_prev_scr == NULL) {\n            top_prev_scr = disp_refr->prev_scr;\n        }\n        /*Do the refreshing from the top object*/\n        lv_refr_obj_and_children(top_prev_scr, &start_mask);\n\n    }\n\n    if(top_act_scr == NULL) {\n        top_act_scr = disp_refr->act_scr;\n    }\n    /*Do the refreshing from the top object*/\n    lv_refr_obj_and_children(top_act_scr, &start_mask);\n\n    /*Also refresh top and sys layer unconditionally*/\n    lv_refr_obj_and_children(lv_disp_get_layer_top(disp_refr), &start_mask);\n    lv_refr_obj_and_children(lv_disp_get_layer_sys(disp_refr), &start_mask);\n\n    /*In true double buffered mode flush only once when all areas were rendered.\n     *In normal mode flush after every area*/\n    if(disp_refr->driver->full_refresh == false) {\n        draw_buf_flush();\n    }\n}"}, "lv_refr_get_top_obj": {"type": "Function", "def": "static lv_obj_t * lv_refr_get_top_obj(const lv_area_t * area_p, lv_obj_t * obj)", "sline": 594, "body": "{\n    lv_obj_t * found_p = NULL;\n\n    /*If this object is fully cover the draw area check the children too*/\n    if(_lv_area_is_in(area_p, &obj->coords, 0) && lv_obj_has_flag(obj, LV_OBJ_FLAG_HIDDEN) == false) {\n        lv_cover_check_info_t info;\n        info.res = LV_COVER_RES_COVER;\n        info.area = area_p;\n        lv_event_send(obj, LV_EVENT_COVER_CHECK, &info);\n        if(info.res == LV_COVER_RES_MASKED) return NULL;\n\n        uint32_t i;\n        uint32_t child_cnt = lv_obj_get_child_cnt(obj);\n        for(i = 0; i < child_cnt; i++) {\n            lv_obj_t * child = obj->spec_attr->children[i];\n            found_p = lv_refr_get_top_obj(area_p, child);\n\n            /*If a children is ok then break*/\n            if(found_p != NULL) {\n                break;\n            }\n        }\n\n        /*If no better children use this object*/\n        if(found_p == NULL) {\n            if(info.res == LV_COVER_RES_COVER) {\n                found_p = obj;\n            }\n        }\n    }\n\n    return found_p;\n}"}, "lv_refr_obj_and_children": {"type": "Function", "def": "static void lv_refr_obj_and_children(lv_obj_t * top_p, const lv_area_t * mask_p)", "sline": 634, "body": "{\n    /*Normally always will be a top_obj (at least the screen)\n     *but in special cases (e.g. if the screen has alpha) it won't.\n     *In this case use the screen directly*/\n    if(top_p == NULL) top_p = lv_disp_get_scr_act(disp_refr);\n    if(top_p == NULL) return;  /*Shouldn't happen*/\n\n    /*Refresh the top object and its children*/\n    lv_refr_obj(top_p, mask_p);\n\n    /*Draw the 'younger' sibling objects because they can be on top_obj*/\n    lv_obj_t * par;\n    lv_obj_t * border_p = top_p;\n\n    par = lv_obj_get_parent(top_p);\n\n    /*Do until not reach the screen*/\n    while(par != NULL) {\n        bool go = false;\n        uint32_t i;\n        uint32_t child_cnt = lv_obj_get_child_cnt(par);\n        for(i = 0; i < child_cnt; i++) {\n            lv_obj_t * child = par->spec_attr->children[i];\n            if(!go) {\n                if(child == border_p) go = true;\n            }\n            else {\n                /*Refresh the objects*/\n                lv_refr_obj(child, mask_p);\n            }\n        }\n\n        /*Call the post draw draw function of the parents of the to object*/\n        lv_event_send(par, LV_EVENT_DRAW_POST_BEGIN, (void *)mask_p);\n        lv_event_send(par, LV_EVENT_DRAW_POST, (void *)mask_p);\n        lv_event_send(par, LV_EVENT_DRAW_POST_END, (void *)mask_p);\n\n        /*The new border will be the last parents,\n         *so the 'younger' brothers of parent will be refreshed*/\n        border_p = par;\n        /*Go a level deeper*/\n        par = lv_obj_get_parent(par);\n    }\n}"}, "lv_refr_obj": {"type": "Function", "def": "static void lv_refr_obj(lv_obj_t * obj, const lv_area_t * mask_ori_p)", "sline": 685, "body": "{\n    /*Do not refresh hidden objects*/\n    if(lv_obj_has_flag(obj, LV_OBJ_FLAG_HIDDEN)) return;\n\n    bool union_ok; /*Store the return value of area_union*/\n    /*Truncate the original mask to the coordinates of the parent\n     *because the parent and its children are visible only here*/\n    lv_area_t obj_mask;\n    lv_area_t obj_ext_mask;\n    lv_area_t obj_area;\n    lv_coord_t ext_size = _lv_obj_get_ext_draw_size(obj);\n    lv_obj_get_coords(obj, &obj_area);\n    obj_area.x1 -= ext_size;\n    obj_area.y1 -= ext_size;\n    obj_area.x2 += ext_size;\n    obj_area.y2 += ext_size;\n    union_ok = _lv_area_intersect(&obj_ext_mask, mask_ori_p, &obj_area);\n\n    /*Draw the parent and its children only if they ore on 'mask_parent'*/\n    if(union_ok != false) {\n        /*Redraw the object*/\n        lv_event_send(obj, LV_EVENT_DRAW_MAIN_BEGIN, &obj_ext_mask);\n        lv_event_send(obj, LV_EVENT_DRAW_MAIN, &obj_ext_mask);\n        lv_event_send(obj, LV_EVENT_DRAW_MAIN_END, &obj_ext_mask);\n\n#if LV_USE_REFR_DEBUG\n        lv_color_t debug_color = lv_color_make(lv_rand(0, 0xFF), lv_rand(0, 0xFF), lv_rand(0, 0xFF));\n        lv_draw_rect_dsc_t draw_dsc;\n        lv_draw_rect_dsc_init(&draw_dsc);\n        draw_dsc.bg_color.full = debug_color.full;\n        draw_dsc.bg_opa = LV_OPA_20;\n        draw_dsc.border_width = 1;\n        draw_dsc.border_opa = LV_OPA_30;\n        draw_dsc.border_color = debug_color;\n        lv_draw_rect(&obj_ext_mask, &obj_ext_mask, &draw_dsc);\n#endif\n        /*Create a new 'obj_mask' without 'ext_size' because the children can't be visible there*/\n        lv_obj_get_coords(obj, &obj_area);\n        union_ok = _lv_area_intersect(&obj_mask, mask_ori_p, &obj_area);\n        if(union_ok != false) {\n            lv_area_t mask_child; /*Mask from obj and its child*/\n            lv_area_t child_area;\n            uint32_t i;\n            uint32_t child_cnt = lv_obj_get_child_cnt(obj);\n            for(i = 0; i < child_cnt; i++) {\n                lv_obj_t * child = obj->spec_attr->children[i];\n                lv_obj_get_coords(child, &child_area);\n                ext_size = _lv_obj_get_ext_draw_size(child);\n                child_area.x1 -= ext_size;\n                child_area.y1 -= ext_size;\n                child_area.x2 += ext_size;\n                child_area.y2 += ext_size;\n                /*Get the union (common parts) of original mask (from obj)\n                 *and its child*/\n                union_ok = _lv_area_intersect(&mask_child, &obj_mask, &child_area);\n\n                /*If the parent and the child has common area then refresh the child*/\n                if(union_ok) {\n                    /*Refresh the next children*/\n                    lv_refr_obj(child, &mask_child);\n                }\n            }\n        }\n\n        /*If all the children are redrawn make 'post draw' draw*/\n        lv_event_send(obj, LV_EVENT_DRAW_POST_BEGIN, &obj_ext_mask);\n        lv_event_send(obj, LV_EVENT_DRAW_POST, &obj_ext_mask);\n        lv_event_send(obj, LV_EVENT_DRAW_POST_END, &obj_ext_mask);\n    }\n}"}, "draw_buf_flush": {"type": "Function", "def": "static void draw_buf_flush(void)", "sline": 937, "docstring": "/**", "body": "{\n    lv_disp_draw_buf_t * draw_buf = lv_disp_get_draw_buf(disp_refr);\n    lv_color_t * color_p = draw_buf->buf_act;\n\n    /*Flush the rendered content to the display*/\n    lv_disp_t * disp = _lv_refr_get_disp_refreshing();\n    if(disp->driver->gpu_wait_cb) disp->driver->gpu_wait_cb(disp->driver);\n\n    /* In double buffered mode wait until the other buffer is freed\n     * and driver is ready to receive the new buffer */\n    if(draw_buf->buf1 && draw_buf->buf2) {\n        while(draw_buf->flushing) {\n            if(disp_refr->driver->wait_cb) disp_refr->driver->wait_cb(disp_refr->driver);\n        }\n    }\n\n    draw_buf->flushing = 1;\n\n    if(disp_refr->driver->draw_buf->last_area && disp_refr->driver->draw_buf->last_part) draw_buf->flushing_last = 1;\n    else draw_buf->flushing_last = 0;\n\n    if(disp->driver->flush_cb) {\n        /*Rotate the buffer to the display's native orientation if necessary*/\n        if(disp->driver->rotated != LV_DISP_ROT_NONE && disp->driver->sw_rotate) {\n            draw_buf_rotate(&draw_buf->area, draw_buf->buf_act);\n        }\n        else {\n            call_flush_cb(disp->driver, &draw_buf->area, color_p);\n        }\n    }\n    if(draw_buf->buf1 && draw_buf->buf2) {\n        if(draw_buf->buf_act == draw_buf->buf1)\n            draw_buf->buf_act = draw_buf->buf2;\n        else\n            draw_buf->buf_act = draw_buf->buf1;\n    }\n}"}, "call_flush_cb": {"type": "Function", "def": "static void call_flush_cb(lv_disp_drv_t * drv, const lv_area_t * area, lv_color_t * color_p)", "sline": 976, "body": "{\n    REFR_TRACE(\"Calling flush_cb on (%d;%d)(%d;%d) area with %p image pointer\", area->x1, area->y1, area->x2, area->y2,\n               (void *)color_p);\n\n    lv_area_t offset_area = {\n        .x1 = area->x1 + drv->offset_x,\n        .y1 = area->y1 + drv->offset_y,\n        .x2 = area->x2 + drv->offset_x,\n        .y2 = area->y2 + drv->offset_y\n    };\n\n    drv->flush_cb(drv, &offset_area, color_p);\n}"}, "px_num": {"type": "Variable", "def": "static uint32_t px_num", "sline": 49}, "disp_refr": {"type": "Variable", "def": "static lv_disp_t * disp_refr", "sline": 50}, "_lv_refr_init": {"type": "Function", "def": "void _lv_refr_init(void)", "sline": 72, "docstring": "/**", "body": "{\n    /*Nothing to do*/\n}"}, "lv_refr_now": {"type": "Function", "def": "void lv_refr_now(lv_disp_t * disp)", "sline": 84, "body": "{\n    lv_anim_refr_now();\n\n    if(disp) {\n        _lv_disp_refr_timer(disp->refr_timer);\n    }\n    else {\n        lv_disp_t * d;\n        d = lv_disp_get_next(NULL);\n        while(d) {\n            _lv_disp_refr_timer(d->refr_timer);\n            d = lv_disp_get_next(d);\n        }\n    }\n}"}, "_lv_inv_area": {"type": "Function", "def": "void _lv_inv_area(lv_disp_t * disp, const lv_area_t * area_p)", "sline": 107, "body": "{\n    if(!disp) disp = lv_disp_get_default();\n    if(!disp) return;\n\n    /*Clear the invalidate buffer if the parameter is NULL*/\n    if(area_p == NULL) {\n        disp->inv_p = 0;\n        return;\n    }\n\n    lv_area_t scr_area;\n    scr_area.x1 = 0;\n    scr_area.y1 = 0;\n    scr_area.x2 = lv_disp_get_hor_res(disp) - 1;\n    scr_area.y2 = lv_disp_get_ver_res(disp) - 1;\n\n    lv_area_t com_area;\n    bool suc;\n\n    suc = _lv_area_intersect(&com_area, area_p, &scr_area);\n    if(suc == false)  return; /*Out of the screen*/\n\n    /*If there were at least 1 invalid area in full refresh mode, redraw the whole screen*/\n    if(disp->driver->full_refresh) {\n        disp->inv_areas[0] = scr_area;\n        disp->inv_p = 1;\n        lv_timer_resume(disp->refr_timer);\n        return;\n    }\n\n    if(disp->driver->rounder_cb) disp->driver->rounder_cb(disp->driver, &com_area);\n\n    /*Save only if this area is not in one of the saved areas*/\n    uint16_t i;\n    for(i = 0; i < disp->inv_p; i++) {\n        if(_lv_area_is_in(&com_area, &disp->inv_areas[i], 0) != false) return;\n    }\n\n    /*Save the area*/\n    if(disp->inv_p < LV_INV_BUF_SIZE) {\n        lv_area_copy(&disp->inv_areas[disp->inv_p], &com_area);\n    }\n    else {   /*If no place for the area add the screen*/\n        disp->inv_p = 0;\n        lv_area_copy(&disp->inv_areas[disp->inv_p], &scr_area);\n    }\n    disp->inv_p++;\n    lv_timer_resume(disp->refr_timer);\n}"}, "_lv_refr_get_disp_refreshing": {"type": "Function", "def": "lv_disp_t * _lv_refr_get_disp_refreshing(void)", "sline": 162, "body": "{\n    return disp_refr;\n}"}, "_lv_refr_set_disp_refreshing": {"type": "Function", "def": "void _lv_refr_set_disp_refreshing(lv_disp_t * disp)", "sline": 173, "body": "{\n    disp_refr = disp;\n}"}, "_lv_disp_refr_timer": {"type": "Function", "def": "void _lv_disp_refr_timer(lv_timer_t * tmr)", "sline": 182, "body": "{\n    REFR_TRACE(\"begin\");\n\n    uint32_t start = lv_tick_get();\n    volatile uint32_t elaps = 0;\n\n    disp_refr = tmr->user_data;\n\n#if LV_USE_PERF_MONITOR == 0 && LV_USE_MEM_MONITOR == 0\n    /**\n     * Ensure the timer does not run again automatically.\n     * This is done before refreshing in case refreshing invalidates something else.\n     */\n    lv_timer_pause(tmr);\n#endif\n\n    /*Refresh the screen's layout if required*/\n    lv_obj_update_layout(disp_refr->act_scr);\n    if(disp_refr->prev_scr) lv_obj_update_layout(disp_refr->prev_scr);\n\n    lv_obj_update_layout(disp_refr->top_layer);\n    lv_obj_update_layout(disp_refr->sys_layer);\n\n    /*Do nothing if there is no active screen*/\n    if(disp_refr->act_scr == NULL) {\n        disp_refr->inv_p = 0;\n        LV_LOG_WARN(\"there is no active screen\");\n        REFR_TRACE(\"finished\");\n        return;\n    }\n\n    lv_refr_join_area();\n\n    lv_refr_areas();\n\n    /*If refresh happened ...*/\n    if(disp_refr->inv_p != 0) {\n        if(disp_refr->driver->full_refresh) {\n            draw_buf_flush();\n        }\n\n        /*Clean up*/\n        lv_memset_00(disp_refr->inv_areas, sizeof(disp_refr->inv_areas));\n        lv_memset_00(disp_refr->inv_area_joined, sizeof(disp_refr->inv_area_joined));\n        disp_refr->inv_p = 0;\n\n        elaps = lv_tick_elaps(start);\n        /*Call monitor cb if present*/\n        if(disp_refr->driver->monitor_cb) {\n            disp_refr->driver->monitor_cb(disp_refr->driver, elaps, px_num);\n        }\n    }\n\n    lv_mem_buf_free_all();\n    _lv_font_clean_up_fmt_txt();\n\n#if LV_DRAW_COMPLEX\n    _lv_draw_mask_cleanup();\n#endif\n\n#if LV_USE_PERF_MONITOR && LV_USE_LABEL\n    static lv_obj_t * perf_label = NULL;\n    if(perf_label == NULL) {\n        perf_label = lv_label_create(lv_layer_sys());\n        lv_obj_set_style_bg_opa(perf_label, LV_OPA_50, 0);\n        lv_obj_set_style_bg_color(perf_label, lv_color_black(), 0);\n        lv_obj_set_style_text_color(perf_label, lv_color_white(), 0);\n        lv_obj_set_style_pad_top(perf_label, 3, 0);\n        lv_obj_set_style_pad_bottom(perf_label, 3, 0);\n        lv_obj_set_style_pad_left(perf_label, 3, 0);\n        lv_obj_set_style_pad_right(perf_label, 3, 0);\n        lv_obj_set_style_text_align(perf_label, LV_TEXT_ALIGN_RIGHT, 0);\n        lv_label_set_text(perf_label, \"?\");\n        lv_obj_align(perf_label, LV_USE_PERF_MONITOR_POS, 0, 0);\n    }\n\n    static uint32_t perf_last_time = 0;\n    static uint32_t elaps_sum = 0;\n    static uint32_t frame_cnt = 0;\n    if(lv_tick_elaps(perf_last_time) < 300) {\n        if(px_num > 5000) {\n            elaps_sum += elaps;\n            frame_cnt ++;\n        }\n    }\n    else {\n        perf_last_time = lv_tick_get();\n        uint32_t fps_limit = 1000 / disp_refr->refr_timer->period;\n        unsigned int fps;\n\n        if(elaps_sum == 0) elaps_sum = 1;\n        if(frame_cnt == 0) fps = fps_limit;\n        else fps = (1000 * frame_cnt) / elaps_sum;\n        elaps_sum = 0;\n        frame_cnt = 0;\n        if(fps > fps_limit) fps = fps_limit;\n\n        fps_sum_all += fps;\n        fps_sum_cnt ++;\n        unsigned int cpu = 100 - lv_timer_get_idle();\n        lv_label_set_text_fmt(perf_label, \"%u FPS\\n%u%% CPU\", fps, cpu);\n    }\n#endif\n\n#if LV_USE_MEM_MONITOR && LV_MEM_CUSTOM == 0 && LV_USE_LABEL\n    static lv_obj_t * mem_label = NULL;\n    if(mem_label == NULL) {\n        mem_label = lv_label_create(lv_layer_sys());\n        lv_obj_set_style_bg_opa(mem_label, LV_OPA_50, 0);\n        lv_obj_set_style_bg_color(mem_label, lv_color_black(), 0);\n        lv_obj_set_style_text_color(mem_label, lv_color_white(), 0);\n        lv_obj_set_style_pad_top(mem_label, 3, 0);\n        lv_obj_set_style_pad_bottom(mem_label, 3, 0);\n        lv_obj_set_style_pad_left(mem_label, 3, 0);\n        lv_obj_set_style_pad_right(mem_label, 3, 0);\n        lv_label_set_text(mem_label, \"?\");\n        lv_obj_align(mem_label, LV_USE_MEM_MONITOR_POS, 0, 0);\n    }\n\n    static uint32_t mem_last_time = 0;\n    if(lv_tick_elaps(mem_last_time) > 300) {\n        mem_last_time = lv_tick_get();\n        lv_mem_monitor_t mon;\n        lv_mem_monitor(&mon);\n        uint32_t used_size = mon.total_size - mon.free_size;;\n        uint32_t used_kb = used_size / 1024;\n        uint32_t used_kb_tenth = (used_size - (used_kb * 1024)) / 102;\n        lv_label_set_text_fmt(mem_label, \"%\" LV_PRIu32 \".%\" LV_PRIu32 \" kB used (%d %%)\\n\" \\\n                              \"%d%% frag.\", used_kb, used_kb_tenth, mon.used_pct,\n                              mon.frag_pct);\n    }\n#endif\n\n    REFR_TRACE(\"finished\");\n}"}, "draw_buf_rotate_180": {"type": "Function", "def": "static void draw_buf_rotate_180(lv_disp_drv_t * drv, lv_area_t * area, lv_color_t * color_p)", "sline": 757, "body": "{\n    lv_coord_t area_w = lv_area_get_width(area);\n    lv_coord_t area_h = lv_area_get_height(area);\n    uint32_t total = area_w * area_h;\n    /*Swap the beginning and end values*/\n    lv_color_t tmp;\n    uint32_t i = total - 1, j = 0;\n    while(i > j) {\n        tmp = color_p[i];\n        color_p[i] = color_p[j];\n        color_p[j] = tmp;\n        i--;\n        j++;\n    }\n    lv_coord_t tmp_coord;\n    tmp_coord = area->y2;\n    area->y2 = drv->ver_res - area->y1 - 1;\n    area->y1 = drv->ver_res - tmp_coord - 1;\n    tmp_coord = area->x2;\n    area->x2 = drv->hor_res - area->x1 - 1;\n    area->x1 = drv->hor_res - tmp_coord - 1;\n}"}, "draw_buf_rotate_90": {"type": "Function", "def": "static LV_ATTRIBUTE_FAST_MEM void draw_buf_rotate_90(bool invert_i, lv_coord_t area_w, lv_coord_t area_h,\n                                                     lv_color_t * orig_color_p, lv_color_t * rot_buf)", "sline": 781, "body": "{\n\n    uint32_t invert = (area_w * area_h) - 1;\n    uint32_t initial_i = ((area_w - 1) * area_h);\n    for(lv_coord_t y = 0; y < area_h; y++) {\n        uint32_t i = initial_i + y;\n        if(invert_i)\n            i = invert - i;\n        for(lv_coord_t x = 0; x < area_w; x++) {\n            rot_buf[i] = *(orig_color_p++);\n            if(invert_i)\n                i += area_h;\n            else\n                i -= area_h;\n        }\n    }\n}"}, "draw_buf_rotate4": {"type": "Function", "def": "static inline void draw_buf_rotate4(lv_color_t * a, lv_color_t * b, lv_color_t * c, lv_color_t * d)", "sline": 804, "docstring": "/**", "body": "{\n    lv_color_t tmp;\n    tmp = *a;\n    *a = *b;\n    *b = *c;\n    *c = *d;\n    *d = tmp;\n}"}, "draw_buf_rotate_90_sqr": {"type": "Function", "def": "static void draw_buf_rotate_90_sqr(bool is_270, lv_coord_t w, lv_color_t * color_p)", "sline": 818, "body": "{\n    for(lv_coord_t i = 0; i < w / 2; i++) {\n        for(lv_coord_t j = 0; j < (w + 1) / 2; j++) {\n            lv_coord_t inv_i = (w - 1) - i;\n            lv_coord_t inv_j = (w - 1) - j;\n            if(is_270) {\n                draw_buf_rotate4(\n                    &color_p[i * w + j],\n                    &color_p[inv_j * w + i],\n                    &color_p[inv_i * w + inv_j],\n                    &color_p[j * w + inv_i]\n                );\n            }\n            else {\n                draw_buf_rotate4(\n                    &color_p[i * w + j],\n                    &color_p[j * w + inv_i],\n                    &color_p[inv_i * w + inv_j],\n                    &color_p[inv_j * w + i]\n                );\n            }\n\n        }\n    }\n}"}, "draw_buf_rotate": {"type": "Function", "def": "static void draw_buf_rotate(lv_area_t * area, lv_color_t * color_p)", "sline": 848, "docstring": "/**", "body": "{\n    lv_disp_drv_t * drv = disp_refr->driver;\n    if(disp_refr->driver->full_refresh && drv->sw_rotate) {\n        LV_LOG_ERROR(\"cannot rotate a full refreshed display!\");\n        return;\n    }\n    if(drv->rotated == LV_DISP_ROT_180) {\n        draw_buf_rotate_180(drv, area, color_p);\n        call_flush_cb(drv, area, color_p);\n    }\n    else if(drv->rotated == LV_DISP_ROT_90 || drv->rotated == LV_DISP_ROT_270) {\n        /*Allocate a temporary buffer to store rotated image*/\n        lv_color_t * rot_buf = NULL;\n        lv_disp_draw_buf_t * draw_buf = lv_disp_get_draw_buf(disp_refr);\n        lv_coord_t area_w = lv_area_get_width(area);\n        lv_coord_t area_h = lv_area_get_height(area);\n        /*Determine the maximum number of rows that can be rotated at a time*/\n        lv_coord_t max_row = LV_MIN((lv_coord_t)((LV_DISP_ROT_MAX_BUF / sizeof(lv_color_t)) / area_w), area_h);\n        lv_coord_t init_y_off;\n        init_y_off = area->y1;\n        if(drv->rotated == LV_DISP_ROT_90) {\n            area->y2 = drv->ver_res - area->x1 - 1;\n            area->y1 = area->y2 - area_w + 1;\n        }\n        else {\n            area->y1 = area->x1;\n            area->y2 = area->y1 + area_w - 1;\n        }\n\n        /*Rotate the screen in chunks, flushing after each one*/\n        lv_coord_t row = 0;\n        while(row < area_h) {\n            lv_coord_t height = LV_MIN(max_row, area_h - row);\n            draw_buf->flushing = 1;\n            if((row == 0) && (area_h >= area_w)) {\n                /*Rotate the initial area as a square*/\n                height = area_w;\n                draw_buf_rotate_90_sqr(drv->rotated == LV_DISP_ROT_270, area_w, color_p);\n                if(drv->rotated == LV_DISP_ROT_90) {\n                    area->x1 = init_y_off;\n                    area->x2 = init_y_off + area_w - 1;\n                }\n                else {\n                    area->x2 = drv->hor_res - 1 - init_y_off;\n                    area->x1 = area->x2 - area_w + 1;\n                }\n            }\n            else {\n                /*Rotate other areas using a maximum buffer size*/\n                if(rot_buf == NULL) rot_buf = lv_mem_buf_get(LV_DISP_ROT_MAX_BUF);\n                draw_buf_rotate_90(drv->rotated == LV_DISP_ROT_270, area_w, height, color_p, rot_buf);\n\n                if(drv->rotated == LV_DISP_ROT_90) {\n                    area->x1 = init_y_off + row;\n                    area->x2 = init_y_off + row + height - 1;\n                }\n                else {\n                    area->x2 = drv->hor_res - 1 - init_y_off - row;\n                    area->x1 = area->x2 - height + 1;\n                }\n            }\n\n            /* The original part (chunk of the current area) were split into more parts here.\n             * Set the original last_part flag on the last part of rotation. */\n            if(row + height >= area_h && draw_buf->last_area && draw_buf->last_part) {\n                draw_buf->flushing_last = 1;\n            }\n            else {\n                draw_buf->flushing_last = 0;\n            }\n\n            /*Flush the completed area to the display*/\n            call_flush_cb(drv, area, rot_buf == NULL ? color_p : rot_buf);\n            /*FIXME: Rotation forces legacy behavior where rendering and flushing are done serially*/\n            while(draw_buf->flushing) {\n                if(drv->wait_cb) drv->wait_cb(drv);\n            }\n            color_p += area_w * height;\n            row += height;\n        }\n        /*Free the allocated buffer at the end if necessary*/\n        if(rot_buf != NULL) lv_mem_buf_release(rot_buf);\n    }\n}"}, "carbit_updater/lvgl/src/core/lv_refr.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_refr.c"}}, "carbit_updater/lv_drivers/display/ST7565.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 20}, "carbit_updater/lv_drivers/display/ST7565.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/ST7565.h"}}, "carbit_updater/lvgl/src/extra/libs/png/lodepng.h": {"string": {"type": "Variable", "def": "#include string.h", "sline": 29}, "lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 31}, "carbit_updater/lvgl/src/extra/libs/png/lodepng.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/png/lodepng.h"}}, "carbit_updater/lvgl/src/extra/libs/qrcode/qrcodegen.h": {"stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 26}, "stddef": {"type": "Variable", "def": "#include stddef.h", "sline": 27}, "stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 28}, "qrcodegen_Ecc": {"type": "Enum", "def": "enum qrcodegen_Ecc {\n\t// Must be declared in ascending order of error protection\n\t// so that an internal qrcodegen function works properly\n\tqrcodegen_Ecc_LOW = 0 ,  // The QR Code can tolerate about  7% erroneous codewords\n\tqrcodegen_Ecc_MEDIUM  ,  // The QR Code can tolerate about 15% erroneous codewords\n\tqrcodegen_Ecc_QUARTILE,  // The QR Code can tolerate about 25% erroneous codewords\n\tqrcodegen_Ecc_HIGH    ,  // The QR Code can tolerate about 30% erroneous codewords\n}", "sline": 57, "docstring": "/*"}, "qrcodegen_Mask": {"type": "Enum", "def": "enum qrcodegen_Mask {\n\t// A special value to tell the QR Code encoder to\n\t// automatically select an appropriate mask pattern\n\tqrcodegen_Mask_AUTO = -1,\n\t// The eight actual mask patterns\n\tqrcodegen_Mask_0 = 0,\n\tqrcodegen_Mask_1,\n\tqrcodegen_Mask_2,\n\tqrcodegen_Mask_3,\n\tqrcodegen_Mask_4,\n\tqrcodegen_Mask_5,\n\tqrcodegen_Mask_6,\n\tqrcodegen_Mask_7,\n}", "sline": 70, "docstring": "/*"}, "qrcodegen_Mode": {"type": "Enum", "def": "enum qrcodegen_Mode {\n\tqrcodegen_Mode_NUMERIC      = 0x1,\n\tqrcodegen_Mode_ALPHANUMERIC = 0x2,\n\tqrcodegen_Mode_BYTE         = 0x4,\n\tqrcodegen_Mode_KANJI        = 0x8,\n\tqrcodegen_Mode_ECI          = 0x7,\n}", "sline": 89, "docstring": "/*"}, "qrcodegen_Segment.mode": {"type": "Variable", "def": "enum qrcodegen_Mode mode", "sline": 111, "in_struct": "qrcodegen_Segment"}, "qrcodegen_Segment.numChars": {"type": "Variable", "def": "int numChars", "sline": 116, "in_struct": "qrcodegen_Segment"}, "qrcodegen_Segment.data": {"type": "Variable", "def": "uint8_t *data", "sline": 120, "in_struct": "qrcodegen_Segment"}, "qrcodegen_Segment.bitLength": {"type": "Variable", "def": "int bitLength", "sline": 125, "in_struct": "qrcodegen_Segment"}, "qrcodegen_Segment": {"type": "Struct", "def": "struct qrcodegen_Segment {\n\t// The mode indicator of this segment.\n\tenum qrcodegen_Mode mode;\n\t\n\t// The length of this segment's unencoded data. Measured in characters for\n\t// numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode.\n\t// Always zero or positive. Not the same as the data's bit length.\n\tint numChars;\n\t\n\t// The data bits of this segment, packed in bitwise big endian.\n\t// Can be null if the bit length is zero.\n\tuint8_t *data;\n\t\n\t// The number of valid data bits used in the buffer. Requires\n\t// 0 <= bitLength <= 32767, and bitLength <= (capacity of data array) * 8.\n\t// The character count (numChars) must agree with the mode and the bit buffer length.\n\tint bitLength;\n}", "sline": 109, "body": "enum qrcodegen_Mode mode\nint numChars\nuint8_t *data\nint bitLength\n"}, "qrcodegen_encodeText": {"type": "Function", "def": "bool qrcodegen_encodeText(const char *text, uint8_t tempBuffer[], uint8_t qrcode[],\n\tenum qrcodegen_Ecc ecl, int minVersion, int maxVersion, enum qrcodegen_Mask mask, bool boostEcl)", "sline": 169}, "qrcodegen_encodeBinary": {"type": "Function", "def": "bool qrcodegen_encodeBinary(uint8_t dataAndTemp[], size_t dataLen, uint8_t qrcode[],\n\tenum qrcodegen_Ecc ecl, int minVersion, int maxVersion, enum qrcodegen_Mask mask, bool boostEcl)", "sline": 191}, "qrcodegen_encodeSegments": {"type": "Function", "def": "bool qrcodegen_encodeSegments(const struct qrcodegen_Segment segs[], size_t len,\n\tenum qrcodegen_Ecc ecl, uint8_t tempBuffer[], uint8_t qrcode[])", "sline": 209}, "qrcodegen_encodeSegmentsAdvanced": {"type": "Function", "def": "bool qrcodegen_encodeSegmentsAdvanced(const struct qrcodegen_Segment segs[], size_t len, enum qrcodegen_Ecc ecl,\n\tint minVersion, int maxVersion, int mask, bool boostEcl, uint8_t tempBuffer[], uint8_t qrcode[])", "sline": 228}, "qrcodegen_isAlphanumeric": {"type": "Function", "def": "bool qrcodegen_isAlphanumeric(const char *text)", "sline": 237}, "qrcodegen_isNumeric": {"type": "Function", "def": "bool qrcodegen_isNumeric(const char *text)", "sline": 244}, "qrcodegen_calcSegmentBufferSize": {"type": "Function", "def": "size_t qrcodegen_calcSegmentBufferSize(enum qrcodegen_Mode mode, size_t numChars)", "sline": 258}, "qrcodegen_makeBytes": {"type": "Function", "def": "struct qrcodegen_Segment qrcodegen_makeBytes(const uint8_t data[], size_t len, uint8_t buf[])", "sline": 266}, "qrcodegen_makeNumeric": {"type": "Function", "def": "struct qrcodegen_Segment qrcodegen_makeNumeric(const char *digits, uint8_t buf[])", "sline": 272}, "qrcodegen_makeAlphanumeric": {"type": "Function", "def": "struct qrcodegen_Segment qrcodegen_makeAlphanumeric(const char *text, uint8_t buf[])", "sline": 280}, "qrcodegen_makeEci": {"type": "Function", "def": "struct qrcodegen_Segment qrcodegen_makeEci(long assignVal, uint8_t buf[])", "sline": 287}, "qrcodegen_getSize": {"type": "Function", "def": "int qrcodegen_getSize(const uint8_t qrcode[])", "sline": 298}, "qrcodegen_getModule": {"type": "Function", "def": "bool qrcodegen_getModule(const uint8_t qrcode[], int x, int y)", "sline": 306}, "carbit_updater/lvgl/src/extra/libs/qrcode/qrcodegen.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/qrcode/qrcodegen.h"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_16.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "glyph_bitmap": {"type": "Variable", "def": "static LV_ATTRIBUTE_LARGE_CONST const uint8_t glyph_bitmap[] = {\n    /* U+0020 \" \" */\n\n    /* U+0021 \"!\" */\n    0xbf, 0xb, 0xf0, 0xaf, 0xa, 0xe0, 0x9e, 0x8,\n    0xd0, 0x8c, 0x7, 0xc0, 0x0, 0x0, 0x10, 0xbf,\n    0x1a, 0xe0,\n\n    /* U+0022 \"\\\"\" */\n    0xf5, 0x1f, 0x3f, 0x51, 0xf3, 0xe4, 0xf, 0x3e,\n    0x40, 0xf2, 0x72, 0x8, 0x10,\n\n    /* U+0023 \"#\" */\n    0x0, 0x5, 0xc0, 0x3, 0xe0, 0x0, 0x0, 0x7a,\n    0x0, 0x5c, 0x0, 0x0, 0x9, 0x80, 0x7, 0xa0,\n    0x1, 0xff, 0xff, 0xff, 0xff, 0xfd, 0x3, 0x3e,\n    0x73, 0x3c, 0x83, 0x30, 0x0, 0xf2, 0x0, 0xc5,\n    0x0, 0x0, 0xf, 0x10, 0xe, 0x30, 0x0, 0x2,\n    0xf0, 0x0, 0xf2, 0x0, 0x9f, 0xff, 0xff, 0xff,\n    0xff, 0x41, 0x38, 0xc3, 0x36, 0xe3, 0x30, 0x0,\n    0x89, 0x0, 0x5c, 0x0, 0x0, 0xa, 0x70, 0x7,\n    0xa0, 0x0,\n\n    /* U+0024 \"$\" */\n    0x0, 0x0, 0x79, 0x0, 0x0, 0x0, 0x0, 0x79,\n    0x0, 0x0, 0x0, 0x5c, 0xff, 0xe9, 0x20, 0x6,\n    0xfc, 0xbc, 0x9e, 0x90, 0xe, 0xb0, 0x79, 0x0,\n    0x10, 0xf, 0x80, 0x79, 0x0, 0x0, 0xd, 0xf5,\n    0x79, 0x0, 0x0, 0x3, 0xef, 0xfd, 0x50, 0x0,\n    0x0, 0x6, 0xcf, 0xfe, 0x40, 0x0, 0x0, 0x79,\n    0x5e, 0xf1, 0x0, 0x0, 0x79, 0x5, 0xf3, 0x7,\n    0x0, 0x79, 0x7, 0xf1, 0x2f, 0xe9, 0xbc, 0xaf,\n    0xa0, 0x3, 0xae, 0xff, 0xd7, 0x0, 0x0, 0x0,\n    0x79, 0x0, 0x0, 0x0, 0x0, 0x79, 0x0, 0x0,\n\n    /* U+0025 \"%\" */\n    0x3, 0xde, 0x80, 0x0, 0x5, 0xd0, 0x0, 0xe4,\n    0xc, 0x50, 0x1, 0xe3, 0x0, 0x4c, 0x0, 0x5a,\n    0x0, 0xa9, 0x0, 0x6, 0xa0, 0x4, 0xc0, 0x4e,\n    0x0, 0x0, 0x4c, 0x0, 0x5a, 0xd, 0x50, 0x0,\n    0x0, 0xe4, 0x1c, 0x58, 0xa0, 0x0, 0x0, 0x3,\n    0xce, 0x73, 0xe1, 0x3c, 0xe9, 0x0, 0x0, 0x0,\n    0xd6, 0xe, 0x40, 0xa8, 0x0, 0x0, 0x7c, 0x3,\n    0xc0, 0x3, 0xd0, 0x0, 0x2e, 0x20, 0x3c, 0x0,\n    0x3d, 0x0, 0xb, 0x70, 0x0, 0xe2, 0x9, 0x80,\n    0x6, 0xd0, 0x0, 0x4, 0xdd, 0xa0,\n\n    /* U+0026 \"&\" */\n    0x0, 0x9, 0xef, 0xb1, 0x0, 0x0, 0x9, 0xe4,\n    0x3c, 0xa0, 0x0, 0x0, 0xd9, 0x0, 0x7d, 0x0,\n    0x0, 0xc, 0xc0, 0x1c, 0xa0, 0x0, 0x0, 0x3f,\n    0xae, 0xc1, 0x0, 0x0, 0x1, 0xdf, 0xc0, 0x0,\n    0x0, 0x3, 0xeb, 0x8f, 0x70, 0x18, 0x0, 0xdb,\n    0x0, 0x7f, 0x65, 0xf0, 0x3f, 0x40, 0x0, 0x8f,\n    0xea, 0x3, 0xf7, 0x0, 0x0, 0xcf, 0x70, 0xb,\n    0xf9, 0x66, 0xcf, 0xbf, 0x40, 0x8, 0xdf, 0xea,\n    0x30, 0xa5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+0027 \"'\" */\n    0xf5, 0xf5, 0xe4, 0xe4, 0x72,\n\n    /* U+0028 \"(\" */\n    0x0, 0xda, 0x5, 0xf2, 0xb, 0xc0, 0xf, 0x70,\n    0x3f, 0x40, 0x5f, 0x20, 0x6f, 0x10, 0x7f, 0x0,\n    0x6f, 0x10, 0x5f, 0x20, 0x3f, 0x40, 0xf, 0x70,\n    0xb, 0xc0, 0x5, 0xf2, 0x0, 0xda,\n\n    /* U+0029 \")\" */\n    0x3f, 0x30, 0xc, 0xb0, 0x6, 0xf1, 0x1, 0xf6,\n    0x0, 0xe9, 0x0, 0xbc, 0x0, 0xad, 0x0, 0xae,\n    0x0, 0xad, 0x0, 0xbc, 0x0, 0xe9, 0x1, 0xf6,\n    0x6, 0xf1, 0xc, 0xb0, 0x3f, 0x30,\n\n    /* U+002A \"*\" */\n    0x0, 0x4a, 0x0, 0x6, 0x74, 0xa4, 0xa0, 0x2b,\n    0xff, 0xe5, 0x0, 0x7f, 0xfb, 0x20, 0x7b, 0x6b,\n    0x8d, 0x0, 0x4, 0xa0, 0x0, 0x0, 0x13, 0x0,\n    0x0,\n\n    /* U+002B \"+\" */\n    0x0, 0x5, 0x10, 0x0, 0x0, 0xf, 0x50, 0x0,\n    0x0, 0xf, 0x50, 0x0, 0x1, 0x1f, 0x51, 0x10,\n    0xef, 0xff, 0xff, 0xf3, 0x34, 0x4f, 0x74, 0x40,\n    0x0, 0xf, 0x50, 0x0, 0x0, 0xf, 0x50, 0x0,\n\n    /* U+002C \",\" */\n    0x9, 0x52, 0xfd, 0xb, 0xa0, 0xc5, 0xf, 0x0,\n\n    /* U+002D \"-\" */\n    0x1, 0x11, 0x10, 0x1f, 0xff, 0xf3, 0x4, 0x44,\n    0x40,\n\n    /* U+002E \".\" */\n    0x3, 0x12, 0xfc, 0x1e, 0x90,\n\n    /* U+002F \"/\" */\n    0x0, 0x0, 0x5, 0xf1, 0x0, 0x0, 0xa, 0xb0,\n    0x0, 0x0, 0xf, 0x60, 0x0, 0x0, 0x5f, 0x10,\n    0x0, 0x0, 0xab, 0x0, 0x0, 0x0, 0xf6, 0x0,\n    0x0, 0x5, 0xf1, 0x0, 0x0, 0xa, 0xb0, 0x0,\n    0x0, 0xf, 0x60, 0x0, 0x0, 0x4f, 0x10, 0x0,\n    0x0, 0xac, 0x0, 0x0, 0x0, 0xf6, 0x0, 0x0,\n    0x4, 0xf1, 0x0, 0x0, 0xa, 0xc0, 0x0, 0x0,\n    0xe, 0x60, 0x0, 0x0, 0x4f, 0x10, 0x0, 0x0,\n\n    /* U+0030 \"0\" */\n    0x0, 0x8, 0xef, 0xc5, 0x0, 0x0, 0xcf, 0xa8,\n    0xcf, 0x70, 0x7, 0xf5, 0x0, 0xa, 0xf2, 0xd,\n    0xc0, 0x0, 0x1, 0xf8, 0x1f, 0x80, 0x0, 0x0,\n    0xdc, 0x3f, 0x60, 0x0, 0x0, 0xbd, 0x3f, 0x60,\n    0x0, 0x0, 0xbd, 0x1f, 0x80, 0x0, 0x0, 0xdc,\n    0xd, 0xc0, 0x0, 0x1, 0xf8, 0x7, 0xf5, 0x0,\n    0xa, 0xf2, 0x0, 0xcf, 0xa8, 0xcf, 0x70, 0x0,\n    0x8, 0xef, 0xc5, 0x0,\n\n    /* U+0031 \"1\" */\n    0xef, 0xff, 0x36, 0x7a, 0xf3, 0x0, 0x5f, 0x30,\n    0x5, 0xf3, 0x0, 0x5f, 0x30, 0x5, 0xf3, 0x0,\n    0x5f, 0x30, 0x5, 0xf3, 0x0, 0x5f, 0x30, 0x5,\n    0xf3, 0x0, 0x5f, 0x30, 0x5, 0xf3,\n\n    /* U+0032 \"2\" */\n    0x4, 0xbe, 0xfd, 0x70, 0x7, 0xfd, 0x98, 0xcf,\n    0x90, 0x28, 0x0, 0x0, 0xbf, 0x0, 0x0, 0x0,\n    0x7, 0xf2, 0x0, 0x0, 0x0, 0xaf, 0x0, 0x0,\n    0x0, 0x4f, 0x80, 0x0, 0x0, 0x3f, 0xc0, 0x0,\n    0x0, 0x3e, 0xc1, 0x0, 0x0, 0x2e, 0xc1, 0x0,\n    0x0, 0x2e, 0xd1, 0x0, 0x0, 0x2e, 0xf8, 0x77,\n    0x77, 0x46, 0xff, 0xff, 0xff, 0xfa,\n\n    /* U+0033 \"3\" */\n    0x6f, 0xff, 0xff, 0xff, 0x2, 0x77, 0x77, 0x9f,\n    0xb0, 0x0, 0x0, 0xc, 0xe1, 0x0, 0x0, 0x9,\n    0xf3, 0x0, 0x0, 0x5, 0xf6, 0x0, 0x0, 0x0,\n    0xdf, 0xe9, 0x10, 0x0, 0x4, 0x59, 0xfd, 0x0,\n    0x0, 0x0, 0x6, 0xf4, 0x0, 0x0, 0x0, 0x3f,\n    0x64, 0x40, 0x0, 0x8, 0xf3, 0xbf, 0xc9, 0x8c,\n    0xfb, 0x0, 0x7c, 0xff, 0xd7, 0x0,\n\n    /* U+0034 \"4\" */\n    0x0, 0x0, 0x1, 0xeb, 0x0, 0x0, 0x0, 0x0,\n    0xbe, 0x10, 0x0, 0x0, 0x0, 0x6f, 0x50, 0x0,\n    0x0, 0x0, 0x2f, 0x90, 0x0, 0x0, 0x0, 0xc,\n    0xd0, 0x0, 0x0, 0x0, 0x8, 0xf3, 0x1, 0xd5,\n    0x0, 0x3, 0xf8, 0x0, 0x2f, 0x60, 0x0, 0xed,\n    0x22, 0x23, 0xf7, 0x21, 0x6f, 0xff, 0xff, 0xff,\n    0xff, 0x81, 0x55, 0x55, 0x56, 0xf9, 0x52, 0x0,\n    0x0, 0x0, 0x2f, 0x60, 0x0, 0x0, 0x0, 0x2,\n    0xf6, 0x0,\n\n    /* U+0035 \"5\" */\n    0x5, 0xff, 0xff, 0xff, 0x0, 0x7f, 0x77, 0x77,\n    0x70, 0x8, 0xe0, 0x0, 0x0, 0x0, 0xad, 0x0,\n    0x0, 0x0, 0xb, 0xc2, 0x10, 0x0, 0x0, 0xdf,\n    0xff, 0xfb, 0x30, 0x4, 0x55, 0x68, 0xff, 0x20,\n    0x0, 0x0, 0x4, 0xf8, 0x0, 0x0, 0x0, 0xf,\n    0x92, 0x50, 0x0, 0x5, 0xf6, 0x8f, 0xd9, 0x8a,\n    0xfd, 0x10, 0x5b, 0xef, 0xe9, 0x10,\n\n    /* U+0036 \"6\" */\n    0x0, 0x5, 0xce, 0xfc, 0x60, 0x0, 0x9f, 0xc8,\n    0x8b, 0x70, 0x5, 0xf8, 0x0, 0x0, 0x0, 0xc,\n    0xd0, 0x0, 0x0, 0x0, 0x1f, 0x80, 0x0, 0x0,\n    0x0, 0x2f, 0x68, 0xef, 0xfa, 0x10, 0x3f, 0xee,\n    0x64, 0x8f, 0xd0, 0x2f, 0xf1, 0x0, 0x6, 0xf4,\n    0xe, 0xc0, 0x0, 0x2, 0xf6, 0x9, 0xf1, 0x0,\n    0x6, 0xf3, 0x1, 0xde, 0x86, 0x9f, 0xb0, 0x0,\n    0x19, 0xef, 0xd8, 0x0,\n\n    /* U+0037 \"7\" */\n    0x8f, 0xff, 0xff, 0xff, 0xe8, 0xf7, 0x77, 0x77,\n    0xfc, 0x8f, 0x0, 0x0, 0x4f, 0x55, 0x90, 0x0,\n    0xb, 0xe0, 0x0, 0x0, 0x2, 0xf8, 0x0, 0x0,\n    0x0, 0x9f, 0x10, 0x0, 0x0, 0xf, 0xb0, 0x0,\n    0x0, 0x6, 0xf4, 0x0, 0x0, 0x0, 0xdd, 0x0,\n    0x0, 0x0, 0x3f, 0x70, 0x0, 0x0, 0xa, 0xf1,\n    0x0, 0x0, 0x1, 0xf9, 0x0, 0x0,\n\n    /* U+0038 \"8\" */\n    0x0, 0x5c, 0xff, 0xd7, 0x0, 0x6, 0xfc, 0x76,\n    0xaf, 0xa0, 0xc, 0xd0, 0x0, 0x9, 0xf1, 0xd,\n    0xc0, 0x0, 0x7, 0xf2, 0x7, 0xf7, 0x11, 0x5e,\n    0xc0, 0x0, 0xbf, 0xff, 0xfe, 0x10, 0x9, 0xf9,\n    0x54, 0x7e, 0xd0, 0x2f, 0x80, 0x0, 0x4, 0xf6,\n    0x4f, 0x50, 0x0, 0x0, 0xf8, 0x1f, 0xa0, 0x0,\n    0x5, 0xf6, 0x9, 0xfb, 0x76, 0xaf, 0xd0, 0x0,\n    0x6c, 0xff, 0xd8, 0x10,\n\n    /* U+0039 \"9\" */\n    0x0, 0x8e, 0xfd, 0x80, 0x0, 0xc, 0xf8, 0x68,\n    0xfc, 0x0, 0x5f, 0x50, 0x0, 0x3f, 0x70, 0x8f,\n    0x0, 0x0, 0xe, 0xc0, 0x7f, 0x30, 0x0, 0x1f,\n    0xf0, 0x1f, 0xd4, 0x13, 0xcf, 0xf1, 0x4, 0xef,\n    0xff, 0xa9, 0xf0, 0x0, 0x2, 0x31, 0xa, 0xf0,\n    0x0, 0x0, 0x0, 0xe, 0xa0, 0x0, 0x0, 0x0,\n    0x9f, 0x30, 0x9, 0xa7, 0x8d, 0xf7, 0x0, 0x7,\n    0xdf, 0xeb, 0x40, 0x0,\n\n    /* U+003A \":\" */\n    0x1e, 0x92, 0xfc, 0x3, 0x10, 0x0, 0x0, 0x0,\n    0x0, 0x3, 0x12, 0xfc, 0x1e, 0x90,\n\n    /* U+003B \";\" */\n    0x1e, 0x92, 0xfc, 0x3, 0x10, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x1, 0xe9, 0x1f, 0xd0, 0xa8, 0xe,\n    0x30, 0xa0,\n\n    /* U+003C \"<\" */\n    0x0, 0x0, 0x0, 0x42, 0x0, 0x1, 0x7d, 0xf3,\n    0x3, 0x9f, 0xe8, 0x10, 0xbf, 0xb5, 0x0, 0x0,\n    0xee, 0x81, 0x0, 0x0, 0x17, 0xdf, 0xb4, 0x0,\n    0x0, 0x4, 0xaf, 0xd2, 0x0, 0x0, 0x1, 0x82,\n\n    /* U+003D \"=\" */\n    0xef, 0xff, 0xff, 0xf3, 0x45, 0x55, 0x55, 0x51,\n    0x0, 0x0, 0x0, 0x0, 0x1, 0x11, 0x11, 0x10,\n    0xef, 0xff, 0xff, 0xf3, 0x34, 0x44, 0x44, 0x40,\n\n    /* U+003E \">\" */\n    0x50, 0x0, 0x0, 0x0, 0xef, 0x92, 0x0, 0x0,\n    0x6, 0xcf, 0xb5, 0x0, 0x0, 0x3, 0x9f, 0xe2,\n    0x0, 0x0, 0x6c, 0xf3, 0x2, 0x9e, 0xe9, 0x20,\n    0xbf, 0xc6, 0x0, 0x0, 0x93, 0x0, 0x0, 0x0,\n\n    /* U+003F \"?\" */\n    0x4, 0xbe, 0xfd, 0x70, 0x7, 0xfc, 0x77, 0xbf,\n    0xa0, 0x27, 0x0, 0x0, 0xcf, 0x0, 0x0, 0x0,\n    0x9, 0xf0, 0x0, 0x0, 0x1, 0xea, 0x0, 0x0,\n    0x1, 0xdd, 0x10, 0x0, 0x0, 0xce, 0x10, 0x0,\n    0x0, 0x3f, 0x60, 0x0, 0x0, 0x1, 0x30, 0x0,\n    0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x6, 0xf5,\n    0x0, 0x0, 0x0, 0x5f, 0x40, 0x0,\n\n    /* U+0040 \"@\" */\n    0x0, 0x0, 0x17, 0xce, 0xfd, 0xb5, 0x0, 0x0,\n    0x0, 0x5, 0xfb, 0x53, 0x23, 0x7d, 0xc2, 0x0,\n    0x0, 0x6e, 0x40, 0x0, 0x0, 0x0, 0x8e, 0x10,\n    0x2, 0xf4, 0x1, 0xae, 0xfa, 0x3f, 0x49, 0xb0,\n    0xa, 0x90, 0x1e, 0xe6, 0x5b, 0xef, 0x40, 0xe3,\n    0xf, 0x30, 0x8f, 0x10, 0x0, 0xaf, 0x40, 0x98,\n    0x1f, 0x0, 0xd9, 0x0, 0x0, 0x3f, 0x40, 0x6a,\n    0x3f, 0x0, 0xe8, 0x0, 0x0, 0x1f, 0x40, 0x5c,\n    0x1f, 0x0, 0xd9, 0x0, 0x0, 0x3f, 0x40, 0x6a,\n    0xf, 0x30, 0x8f, 0x10, 0x0, 0xaf, 0x40, 0x98,\n    0xa, 0x90, 0x1e, 0xd6, 0x5a, 0xde, 0xa6, 0xf2,\n    0x3, 0xf3, 0x1, 0xaf, 0xfa, 0x16, 0xee, 0x50,\n    0x0, 0x6e, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x6, 0xfb, 0x53, 0x23, 0x75, 0x0, 0x0,\n    0x0, 0x0, 0x17, 0xce, 0xfd, 0xa3, 0x0, 0x0,\n\n    /* U+0041 \"A\" */\n    0x0, 0x0, 0x2, 0xfd, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x9f, 0xf4, 0x0, 0x0, 0x0, 0x0, 0xf,\n    0x9e, 0xb0, 0x0, 0x0, 0x0, 0x6, 0xf2, 0x7f,\n    0x20, 0x0, 0x0, 0x0, 0xdc, 0x1, 0xf8, 0x0,\n    0x0, 0x0, 0x4f, 0x60, 0xb, 0xe0, 0x0, 0x0,\n    0xb, 0xf0, 0x0, 0x4f, 0x60, 0x0, 0x1, 0xfa,\n    0x11, 0x11, 0xed, 0x0, 0x0, 0x8f, 0xff, 0xff,\n    0xff, 0xf3, 0x0, 0xe, 0xc4, 0x44, 0x44, 0x4f,\n    0xa0, 0x6, 0xf4, 0x0, 0x0, 0x0, 0xaf, 0x10,\n    0xcd, 0x0, 0x0, 0x0, 0x2, 0xf8,\n\n    /* U+0042 \"B\" */\n    0x5f, 0xff, 0xff, 0xeb, 0x40, 0x5, 0xf8, 0x55,\n    0x57, 0xdf, 0x40, 0x5f, 0x40, 0x0, 0x1, 0xfa,\n    0x5, 0xf4, 0x0, 0x0, 0xf, 0xa0, 0x5f, 0x51,\n    0x11, 0x3a, 0xf4, 0x5, 0xff, 0xff, 0xff, 0xfa,\n    0x0, 0x5f, 0x74, 0x44, 0x59, 0xfa, 0x5, 0xf4,\n    0x0, 0x0, 0x8, 0xf2, 0x5f, 0x40, 0x0, 0x0,\n    0x5f, 0x45, 0xf4, 0x0, 0x0, 0x9, 0xf2, 0x5f,\n    0x85, 0x55, 0x6a, 0xfb, 0x5, 0xff, 0xff, 0xff,\n    0xd7, 0x0,\n\n    /* U+0043 \"C\" */\n    0x0, 0x2, 0x8d, 0xfe, 0xb4, 0x0, 0x4, 0xff,\n    0xb8, 0x9d, 0xf9, 0x2, 0xfd, 0x20, 0x0, 0x8,\n    0x50, 0xbf, 0x20, 0x0, 0x0, 0x0, 0xf, 0xa0,\n    0x0, 0x0, 0x0, 0x2, 0xf6, 0x0, 0x0, 0x0,\n    0x0, 0x2f, 0x60, 0x0, 0x0, 0x0, 0x0, 0xfa,\n    0x0, 0x0, 0x0, 0x0, 0xb, 0xf2, 0x0, 0x0,\n    0x0, 0x0, 0x2f, 0xd2, 0x0, 0x0, 0x85, 0x0,\n    0x5f, 0xfb, 0x89, 0xdf, 0x80, 0x0, 0x29, 0xdf,\n    0xeb, 0x40,\n\n    /* U+0044 \"D\" */\n    0x5f, 0xff, 0xff, 0xea, 0x30, 0x0, 0x5f, 0x97,\n    0x77, 0x9e, 0xf8, 0x0, 0x5f, 0x40, 0x0, 0x0,\n    0xaf, 0x60, 0x5f, 0x40, 0x0, 0x0, 0xd, 0xe0,\n    0x5f, 0x40, 0x0, 0x0, 0x6, 0xf4, 0x5f, 0x40,\n    0x0, 0x0, 0x3, 0xf6, 0x5f, 0x40, 0x0, 0x0,\n    0x3, 0xf6, 0x5f, 0x40, 0x0, 0x0, 0x6, 0xf4,\n    0x5f, 0x40, 0x0, 0x0, 0xd, 0xe0, 0x5f, 0x40,\n    0x0, 0x0, 0xaf, 0x60, 0x5f, 0x97, 0x77, 0x9e,\n    0xf8, 0x0, 0x5f, 0xff, 0xff, 0xea, 0x30, 0x0,\n\n    /* U+0045 \"E\" */\n    0x5f, 0xff, 0xff, 0xff, 0x95, 0xf9, 0x77, 0x77,\n    0x74, 0x5f, 0x40, 0x0, 0x0, 0x5, 0xf4, 0x0,\n    0x0, 0x0, 0x5f, 0x51, 0x11, 0x11, 0x5, 0xff,\n    0xff, 0xff, 0xe0, 0x5f, 0x74, 0x44, 0x44, 0x5,\n    0xf4, 0x0, 0x0, 0x0, 0x5f, 0x40, 0x0, 0x0,\n    0x5, 0xf4, 0x0, 0x0, 0x0, 0x5f, 0x97, 0x77,\n    0x77, 0x65, 0xff, 0xff, 0xff, 0xfd,\n\n    /* U+0046 \"F\" */\n    0x5f, 0xff, 0xff, 0xff, 0x95, 0xf9, 0x77, 0x77,\n    0x74, 0x5f, 0x40, 0x0, 0x0, 0x5, 0xf4, 0x0,\n    0x0, 0x0, 0x5f, 0x40, 0x0, 0x0, 0x5, 0xf5,\n    0x22, 0x22, 0x10, 0x5f, 0xff, 0xff, 0xfe, 0x5,\n    0xf8, 0x55, 0x55, 0x40, 0x5f, 0x40, 0x0, 0x0,\n    0x5, 0xf4, 0x0, 0x0, 0x0, 0x5f, 0x40, 0x0,\n    0x0, 0x5, 0xf4, 0x0, 0x0, 0x0,\n\n    /* U+0047 \"G\" */\n    0x0, 0x1, 0x8d, 0xfe, 0xb5, 0x0, 0x0, 0x4f,\n    0xfb, 0x89, 0xdf, 0xb0, 0x2, 0xfd, 0x20, 0x0,\n    0x6, 0x60, 0xb, 0xf2, 0x0, 0x0, 0x0, 0x0,\n    0xf, 0xa0, 0x0, 0x0, 0x0, 0x0, 0x2f, 0x60,\n    0x0, 0x0, 0x0, 0x0, 0x2f, 0x60, 0x0, 0x0,\n    0x9, 0xf0, 0xf, 0xa0, 0x0, 0x0, 0x9, 0xf0,\n    0xb, 0xf2, 0x0, 0x0, 0x9, 0xf0, 0x2, 0xfd,\n    0x20, 0x0, 0xa, 0xf0, 0x0, 0x4f, 0xfb, 0x89,\n    0xdf, 0xc0, 0x0, 0x2, 0x8d, 0xfe, 0xc6, 0x0,\n\n    /* U+0048 \"H\" */\n    0x5f, 0x40, 0x0, 0x0, 0x4f, 0x55, 0xf4, 0x0,\n    0x0, 0x4, 0xf5, 0x5f, 0x40, 0x0, 0x0, 0x4f,\n    0x55, 0xf4, 0x0, 0x0, 0x4, 0xf5, 0x5f, 0x52,\n    0x22, 0x22, 0x5f, 0x55, 0xff, 0xff, 0xff, 0xff,\n    0xf5, 0x5f, 0x85, 0x55, 0x55, 0x8f, 0x55, 0xf4,\n    0x0, 0x0, 0x4, 0xf5, 0x5f, 0x40, 0x0, 0x0,\n    0x4f, 0x55, 0xf4, 0x0, 0x0, 0x4, 0xf5, 0x5f,\n    0x40, 0x0, 0x0, 0x4f, 0x55, 0xf4, 0x0, 0x0,\n    0x4, 0xf5,\n\n    /* U+0049 \"I\" */\n    0x5f, 0x45, 0xf4, 0x5f, 0x45, 0xf4, 0x5f, 0x45,\n    0xf4, 0x5f, 0x45, 0xf4, 0x5f, 0x45, 0xf4, 0x5f,\n    0x45, 0xf4,\n\n    /* U+004A \"J\" */\n    0x0, 0xff, 0xff, 0xfa, 0x0, 0x77, 0x77, 0xfa,\n    0x0, 0x0, 0x0, 0xfa, 0x0, 0x0, 0x0, 0xfa,\n    0x0, 0x0, 0x0, 0xfa, 0x0, 0x0, 0x0, 0xfa,\n    0x0, 0x0, 0x0, 0xfa, 0x0, 0x0, 0x0, 0xfa,\n    0x0, 0x0, 0x0, 0xf9, 0x7, 0x20, 0x3, 0xf6,\n    0xd, 0xe9, 0x8e, 0xf1, 0x1, 0xae, 0xfb, 0x30,\n\n    /* U+004B \"K\" */\n    0x5f, 0x40, 0x0, 0x2, 0xeb, 0x5, 0xf4, 0x0,\n    0x1, 0xec, 0x0, 0x5f, 0x40, 0x1, 0xde, 0x10,\n    0x5, 0xf4, 0x0, 0xce, 0x20, 0x0, 0x5f, 0x40,\n    0xbf, 0x30, 0x0, 0x5, 0xf4, 0x9f, 0x90, 0x0,\n    0x0, 0x5f, 0xcf, 0xef, 0x40, 0x0, 0x5, 0xff,\n    0x91, 0xee, 0x10, 0x0, 0x5f, 0xa0, 0x3, 0xfc,\n    0x0, 0x5, 0xf4, 0x0, 0x6, 0xf8, 0x0, 0x5f,\n    0x40, 0x0, 0x9, 0xf5, 0x5, 0xf4, 0x0, 0x0,\n    0xc, 0xf2,\n\n    /* U+004C \"L\" */\n    0x5f, 0x40, 0x0, 0x0, 0x5, 0xf4, 0x0, 0x0,\n    0x0, 0x5f, 0x40, 0x0, 0x0, 0x5, 0xf4, 0x0,\n    0x0, 0x0, 0x5f, 0x40, 0x0, 0x0, 0x5, 0xf4,\n    0x0, 0x0, 0x0, 0x5f, 0x40, 0x0, 0x0, 0x5,\n    0xf4, 0x0, 0x0, 0x0, 0x5f, 0x40, 0x0, 0x0,\n    0x5, 0xf4, 0x0, 0x0, 0x0, 0x5f, 0x97, 0x77,\n    0x77, 0x25, 0xff, 0xff, 0xff, 0xf5,\n\n    /* U+004D \"M\" */\n    0x5f, 0x40, 0x0, 0x0, 0x0, 0x1e, 0x95, 0xfc,\n    0x0, 0x0, 0x0, 0x8, 0xf9, 0x5f, 0xf5, 0x0,\n    0x0, 0x2, 0xff, 0x95, 0xfd, 0xe0, 0x0, 0x0,\n    0xae, 0xf9, 0x5f, 0x5f, 0x70, 0x0, 0x3f, 0x5f,\n    0x95, 0xf3, 0x8f, 0x10, 0xb, 0xc0, 0xf9, 0x5f,\n    0x31, 0xe9, 0x4, 0xf3, 0xf, 0x95, 0xf3, 0x7,\n    0xf2, 0xdb, 0x0, 0xf9, 0x5f, 0x30, 0xd, 0xef,\n    0x20, 0xf, 0x95, 0xf3, 0x0, 0x5f, 0x90, 0x0,\n    0xf9, 0x5f, 0x30, 0x0, 0x71, 0x0, 0xf, 0x95,\n    0xf3, 0x0, 0x0, 0x0, 0x0, 0xf9,\n\n    /* U+004E \"N\" */\n    0x5f, 0x50, 0x0, 0x0, 0x4f, 0x55, 0xff, 0x20,\n    0x0, 0x4, 0xf5, 0x5f, 0xfd, 0x0, 0x0, 0x4f,\n    0x55, 0xfa, 0xf9, 0x0, 0x4, 0xf5, 0x5f, 0x4a,\n    0xf5, 0x0, 0x4f, 0x55, 0xf4, 0xd, 0xf2, 0x4,\n    0xf5, 0x5f, 0x40, 0x2f, 0xd0, 0x4f, 0x55, 0xf4,\n    0x0, 0x6f, 0x94, 0xf5, 0x5f, 0x40, 0x0, 0xaf,\n    0xaf, 0x55, 0xf4, 0x0, 0x0, 0xdf, 0xf5, 0x5f,\n    0x40, 0x0, 0x2, 0xff, 0x55, 0xf4, 0x0, 0x0,\n    0x6, 0xf5,\n\n    /* U+004F \"O\" */\n    0x0, 0x1, 0x8d, 0xfe, 0xb5, 0x0, 0x0, 0x4,\n    0xff, 0xb8, 0x9e, 0xfa, 0x0, 0x2, 0xfd, 0x20,\n    0x0, 0x8, 0xf9, 0x0, 0xbf, 0x20, 0x0, 0x0,\n    0xa, 0xf2, 0xf, 0xa0, 0x0, 0x0, 0x0, 0x3f,\n    0x72, 0xf6, 0x0, 0x0, 0x0, 0x0, 0xf9, 0x2f,\n    0x60, 0x0, 0x0, 0x0, 0xf, 0x90, 0xfa, 0x0,\n    0x0, 0x0, 0x3, 0xf7, 0xb, 0xf2, 0x0, 0x0,\n    0x0, 0xaf, 0x20, 0x2f, 0xd2, 0x0, 0x0, 0x8f,\n    0x90, 0x0, 0x4f, 0xfb, 0x89, 0xef, 0xa0, 0x0,\n    0x0, 0x28, 0xdf, 0xeb, 0x50, 0x0,\n\n    /* U+0050 \"P\" */\n    0x5f, 0xff, 0xff, 0xd7, 0x0, 0x5f, 0x97, 0x78,\n    0xbf, 0xc0, 0x5f, 0x40, 0x0, 0x7, 0xf6, 0x5f,\n    0x40, 0x0, 0x0, 0xfa, 0x5f, 0x40, 0x0, 0x0,\n    0xfa, 0x5f, 0x40, 0x0, 0x3, 0xf8, 0x5f, 0x62,\n    0x23, 0x6e, 0xf1, 0x5f, 0xff, 0xff, 0xfd, 0x30,\n    0x5f, 0x85, 0x54, 0x20, 0x0, 0x5f, 0x40, 0x0,\n    0x0, 0x0, 0x5f, 0x40, 0x0, 0x0, 0x0, 0x5f,\n    0x40, 0x0, 0x0, 0x0,\n\n    /* U+0051 \"Q\" */\n    0x0, 0x1, 0x8d, 0xfe, 0xb5, 0x0, 0x0, 0x0,\n    0x4e, 0xfb, 0x89, 0xef, 0xa0, 0x0, 0x2, 0xfd,\n    0x20, 0x0, 0x8, 0xf9, 0x0, 0xa, 0xf2, 0x0,\n    0x0, 0x0, 0xaf, 0x20, 0xf, 0xa0, 0x0, 0x0,\n    0x0, 0x3f, 0x70, 0x2f, 0x60, 0x0, 0x0, 0x0,\n    0xf, 0x90, 0x2f, 0x60, 0x0, 0x0, 0x0, 0xf,\n    0x90, 0x1f, 0x90, 0x0, 0x0, 0x0, 0x2f, 0x70,\n    0xb, 0xf1, 0x0, 0x0, 0x0, 0xaf, 0x20, 0x3,\n    0xfc, 0x10, 0x0, 0x7, 0xf9, 0x0, 0x0, 0x6f,\n    0xfa, 0x78, 0xdf, 0xb0, 0x0, 0x0, 0x3, 0xae,\n    0xff, 0xc5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e,\n    0xd4, 0x15, 0xb0, 0x0, 0x0, 0x0, 0x2, 0xbf,\n    0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x1, 0x31,\n    0x0,\n\n    /* U+0052 \"R\" */\n    0x5f, 0xff, 0xff, 0xd7, 0x0, 0x5f, 0x97, 0x78,\n    0xbf, 0xc0, 0x5f, 0x40, 0x0, 0x7, 0xf6, 0x5f,\n    0x40, 0x0, 0x0, 0xfa, 0x5f, 0x40, 0x0, 0x0,\n    0xfa, 0x5f, 0x40, 0x0, 0x3, 0xf8, 0x5f, 0x52,\n    0x23, 0x6e, 0xe1, 0x5f, 0xff, 0xff, 0xfc, 0x30,\n    0x5f, 0x85, 0x55, 0xf9, 0x0, 0x5f, 0x40, 0x0,\n    0x7f, 0x40, 0x5f, 0x40, 0x0, 0xc, 0xe0, 0x5f,\n    0x40, 0x0, 0x2, 0xf9,\n\n    /* U+0053 \"S\" */\n    0x0, 0x5c, 0xef, 0xd9, 0x20, 0x7, 0xfc, 0x87,\n    0xaf, 0x90, 0xe, 0xc0, 0x0, 0x1, 0x10, 0xf,\n    0x80, 0x0, 0x0, 0x0, 0xd, 0xf5, 0x0, 0x0,\n    0x0, 0x3, 0xef, 0xea, 0x50, 0x0, 0x0, 0x5,\n    0xae, 0xfe, 0x40, 0x0, 0x0, 0x0, 0x4e, 0xf1,\n    0x0, 0x0, 0x0, 0x5, 0xf3, 0x8, 0x0, 0x0,\n    0x8, 0xf2, 0x2f, 0xfa, 0x77, 0xbf, 0xa0, 0x2,\n    0x9d, 0xff, 0xc7, 0x0,\n\n    /* U+0054 \"T\" */\n    0xff, 0xff, 0xff, 0xff, 0xf5, 0x67, 0x78, 0xfb,\n    0x77, 0x72, 0x0, 0x1, 0xf7, 0x0, 0x0, 0x0,\n    0x1, 0xf7, 0x0, 0x0, 0x0, 0x1, 0xf7, 0x0,\n    0x0, 0x0, 0x1, 0xf7, 0x0, 0x0, 0x0, 0x1,\n    0xf7, 0x0, 0x0, 0x0, 0x1, 0xf7, 0x0, 0x0,\n    0x0, 0x1, 0xf7, 0x0, 0x0, 0x0, 0x1, 0xf7,\n    0x0, 0x0, 0x0, 0x1, 0xf7, 0x0, 0x0, 0x0,\n    0x1, 0xf7, 0x0, 0x0,\n\n    /* U+0055 \"U\" */\n    0x6f, 0x30, 0x0, 0x0, 0x8f, 0x16, 0xf3, 0x0,\n    0x0, 0x8, 0xf1, 0x6f, 0x30, 0x0, 0x0, 0x8f,\n    0x16, 0xf3, 0x0, 0x0, 0x8, 0xf1, 0x6f, 0x30,\n    0x0, 0x0, 0x8f, 0x16, 0xf3, 0x0, 0x0, 0x8,\n    0xf1, 0x6f, 0x30, 0x0, 0x0, 0x8f, 0x5, 0xf4,\n    0x0, 0x0, 0x9, 0xf0, 0x3f, 0x70, 0x0, 0x0,\n    0xcd, 0x0, 0xde, 0x20, 0x0, 0x5f, 0x80, 0x4,\n    0xff, 0xa8, 0xbf, 0xd0, 0x0, 0x3, 0xbe, 0xfd,\n    0x81, 0x0,\n\n    /* U+0056 \"V\" */\n    0xc, 0xe0, 0x0, 0x0, 0x0, 0x6f, 0x30, 0x6f,\n    0x50, 0x0, 0x0, 0xc, 0xc0, 0x0, 0xfb, 0x0,\n    0x0, 0x3, 0xf6, 0x0, 0x9, 0xf2, 0x0, 0x0,\n    0xae, 0x0, 0x0, 0x2f, 0x80, 0x0, 0x1f, 0x90,\n    0x0, 0x0, 0xce, 0x0, 0x7, 0xf2, 0x0, 0x0,\n    0x5, 0xf6, 0x0, 0xdb, 0x0, 0x0, 0x0, 0xe,\n    0xc0, 0x4f, 0x50, 0x0, 0x0, 0x0, 0x8f, 0x3b,\n    0xe0, 0x0, 0x0, 0x0, 0x2, 0xfb, 0xf8, 0x0,\n    0x0, 0x0, 0x0, 0xb, 0xff, 0x10, 0x0, 0x0,\n    0x0, 0x0, 0x4f, 0xb0, 0x0, 0x0,\n\n    /* U+0057 \"W\" */\n    0x5f, 0x40, 0x0, 0x0, 0xdf, 0x0, 0x0, 0x2,\n    0xf5, 0xf, 0x90, 0x0, 0x2, 0xff, 0x40, 0x0,\n    0x7, 0xf0, 0xb, 0xe0, 0x0, 0x7, 0xfe, 0x90,\n    0x0, 0xc, 0xb0, 0x6, 0xf3, 0x0, 0xc, 0xaa,\n    0xe0, 0x0, 0x1f, 0x60, 0x1, 0xf8, 0x0, 0x1f,\n    0x54, 0xf3, 0x0, 0x6f, 0x10, 0x0, 0xcd, 0x0,\n    0x7f, 0x10, 0xf8, 0x0, 0xcc, 0x0, 0x0, 0x7f,\n    0x20, 0xcb, 0x0, 0xad, 0x1, 0xf7, 0x0, 0x0,\n    0x2f, 0x71, 0xf6, 0x0, 0x5f, 0x26, 0xf2, 0x0,\n    0x0, 0xd, 0xc6, 0xf1, 0x0, 0xf, 0x7b, 0xd0,\n    0x0, 0x0, 0x8, 0xfd, 0xc0, 0x0, 0xb, 0xdf,\n    0x80, 0x0, 0x0, 0x3, 0xff, 0x70, 0x0, 0x6,\n    0xff, 0x30, 0x0, 0x0, 0x0, 0xef, 0x20, 0x0,\n    0x1, 0xfe, 0x0, 0x0,\n\n    /* U+0058 \"X\" */\n    0x3f, 0x90, 0x0, 0x0, 0xcd, 0x0, 0x8f, 0x40,\n    0x0, 0x7f, 0x30, 0x0, 0xde, 0x10, 0x2f, 0x80,\n    0x0, 0x3, 0xfa, 0xc, 0xd0, 0x0, 0x0, 0x7,\n    0xfb, 0xf3, 0x0, 0x0, 0x0, 0xc, 0xf8, 0x0,\n    0x0, 0x0, 0x1, 0xef, 0xc0, 0x0, 0x0, 0x0,\n    0xbf, 0x7f, 0x70, 0x0, 0x0, 0x6f, 0x60, 0xaf,\n    0x20, 0x0, 0x2f, 0xb0, 0x1, 0xed, 0x0, 0xc,\n    0xf1, 0x0, 0x4, 0xf8, 0x7, 0xf6, 0x0, 0x0,\n    0x9, 0xf3,\n\n    /* U+0059 \"Y\" */\n    0xc, 0xe0, 0x0, 0x0, 0x7, 0xf2, 0x3, 0xf7,\n    0x0, 0x0, 0x1f, 0x90, 0x0, 0xaf, 0x10, 0x0,\n    0x9e, 0x10, 0x0, 0x1f, 0xa0, 0x2, 0xf6, 0x0,\n    0x0, 0x8, 0xf3, 0xb, 0xd0, 0x0, 0x0, 0x0,\n    0xec, 0x4f, 0x40, 0x0, 0x0, 0x0, 0x5f, 0xfb,\n    0x0, 0x0, 0x0, 0x0, 0xc, 0xf2, 0x0, 0x0,\n    0x0, 0x0, 0x9, 0xf0, 0x0, 0x0, 0x0, 0x0,\n    0x9, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x9, 0xf0,\n    0x0, 0x0, 0x0, 0x0, 0x9, 0xf0, 0x0, 0x0,\n\n    /* U+005A \"Z\" */\n    0x3f, 0xff, 0xff, 0xff, 0xfd, 0x1, 0x77, 0x77,\n    0x77, 0xbf, 0x90, 0x0, 0x0, 0x0, 0x1e, 0xc0,\n    0x0, 0x0, 0x0, 0xc, 0xf2, 0x0, 0x0, 0x0,\n    0x8, 0xf5, 0x0, 0x0, 0x0, 0x4, 0xf9, 0x0,\n    0x0, 0x0, 0x1, 0xec, 0x0, 0x0, 0x0, 0x0,\n    0xcf, 0x20, 0x0, 0x0, 0x0, 0x8f, 0x50, 0x0,\n    0x0, 0x0, 0x4f, 0x90, 0x0, 0x0, 0x0, 0x1e,\n    0xf8, 0x77, 0x77, 0x77, 0x5, 0xff, 0xff, 0xff,\n    0xff, 0xf0,\n\n    /* U+005B \"[\" */\n    0x5f, 0xff, 0x5, 0xf7, 0x50, 0x5f, 0x30, 0x5,\n    0xf3, 0x0, 0x5f, 0x30, 0x5, 0xf3, 0x0, 0x5f,\n    0x30, 0x5, 0xf3, 0x0, 0x5f, 0x30, 0x5, 0xf3,\n    0x0, 0x5f, 0x30, 0x5, 0xf3, 0x0, 0x5f, 0x30,\n    0x5, 0xf7, 0x50, 0x5f, 0xff, 0x0,\n\n    /* U+005C \"\\\\\" */\n    0x7e, 0x0, 0x0, 0x0, 0x1f, 0x40, 0x0, 0x0,\n    0xc, 0x90, 0x0, 0x0, 0x7, 0xe0, 0x0, 0x0,\n    0x2, 0xf4, 0x0, 0x0, 0x0, 0xc9, 0x0, 0x0,\n    0x0, 0x7e, 0x0, 0x0, 0x0, 0x2f, 0x40, 0x0,\n    0x0, 0xc, 0x90, 0x0, 0x0, 0x7, 0xe0, 0x0,\n    0x0, 0x2, 0xf3, 0x0, 0x0, 0x0, 0xd9, 0x0,\n    0x0, 0x0, 0x7e, 0x0, 0x0, 0x0, 0x2f, 0x30,\n    0x0, 0x0, 0xd, 0x90, 0x0, 0x0, 0x7, 0xe0,\n\n    /* U+005D \"]\" */\n    0xbf, 0xfa, 0x35, 0xea, 0x0, 0xea, 0x0, 0xea,\n    0x0, 0xea, 0x0, 0xea, 0x0, 0xea, 0x0, 0xea,\n    0x0, 0xea, 0x0, 0xea, 0x0, 0xea, 0x0, 0xea,\n    0x0, 0xea, 0x35, 0xea, 0xbf, 0xfa,\n\n    /* U+005E \"^\" */\n    0x0, 0x2f, 0x80, 0x0, 0x0, 0x9d, 0xe0, 0x0,\n    0x0, 0xf3, 0xd5, 0x0, 0x6, 0xd0, 0x7b, 0x0,\n    0xc, 0x60, 0x1f, 0x20, 0x3f, 0x10, 0xb, 0x80,\n    0x9a, 0x0, 0x4, 0xe0,\n\n    /* U+005F \"_\" */\n    0xff, 0xff, 0xff, 0xff, 0x11, 0x11, 0x11, 0x11,\n\n    /* U+0060 \"`\" */\n    0x7, 0xf6, 0x0, 0x3, 0xe7,\n\n    /* U+0061 \"a\" */\n    0x1, 0x9e, 0xfd, 0x80, 0x0, 0xce, 0x87, 0xaf,\n    0x90, 0x2, 0x0, 0x0, 0xaf, 0x0, 0x0, 0x0,\n    0x6, 0xf2, 0x2, 0xbe, 0xff, 0xff, 0x20, 0xec,\n    0x42, 0x27, 0xf2, 0x2f, 0x50, 0x0, 0x7f, 0x20,\n    0xec, 0x42, 0x7f, 0xf2, 0x2, 0xbf, 0xfb, 0x6f,\n    0x20,\n\n    /* U+0062 \"b\" */\n    0x8f, 0x0, 0x0, 0x0, 0x0, 0x8f, 0x0, 0x0,\n    0x0, 0x0, 0x8f, 0x0, 0x0, 0x0, 0x0, 0x8f,\n    0x2b, 0xfe, 0xb3, 0x0, 0x8f, 0xec, 0x78, 0xef,\n    0x30, 0x8f, 0xa0, 0x0, 0x1e, 0xc0, 0x8f, 0x20,\n    0x0, 0x7, 0xf1, 0x8f, 0x0, 0x0, 0x5, 0xf3,\n    0x8f, 0x20, 0x0, 0x7, 0xf1, 0x8f, 0xa0, 0x0,\n    0x1e, 0xd0, 0x8f, 0xec, 0x78, 0xef, 0x30, 0x8e,\n    0x2b, 0xfe, 0xb3, 0x0,\n\n    /* U+0063 \"c\" */\n    0x0, 0x3a, 0xef, 0xc4, 0x0, 0x4f, 0xd8, 0x7c,\n    0xf4, 0xd, 0xd0, 0x0, 0x7, 0x13, 0xf6, 0x0,\n    0x0, 0x0, 0x4f, 0x30, 0x0, 0x0, 0x3, 0xf6,\n    0x0, 0x0, 0x0, 0xd, 0xd0, 0x0, 0x6, 0x10,\n    0x4f, 0xd7, 0x7c, 0xf4, 0x0, 0x3a, 0xef, 0xc4,\n    0x0,\n\n    /* U+0064 \"d\" */\n    0x0, 0x0, 0x0, 0x1, 0xf7, 0x0, 0x0, 0x0,\n    0x1, 0xf7, 0x0, 0x0, 0x0, 0x1, 0xf7, 0x0,\n    0x3b, 0xff, 0xa3, 0xf7, 0x4, 0xfd, 0x87, 0xce,\n    0xf7, 0xe, 0xd0, 0x0, 0xb, 0xf7, 0x3f, 0x60,\n    0x0, 0x3, 0xf7, 0x4f, 0x30, 0x0, 0x1, 0xf7,\n    0x3f, 0x50, 0x0, 0x3, 0xf7, 0xe, 0xc0, 0x0,\n    0xa, 0xf7, 0x4, 0xfc, 0x65, 0xbe, 0xf7, 0x0,\n    0x3b, 0xff, 0xb2, 0xf7,\n\n    /* U+0065 \"e\" */\n    0x0, 0x3b, 0xfe, 0xa2, 0x0, 0x4, 0xfc, 0x67,\n    0xee, 0x20, 0xe, 0xc0, 0x0, 0x1e, 0xa0, 0x3f,\n    0x50, 0x0, 0x7, 0xf0, 0x4f, 0xff, 0xff, 0xff,\n    0xf1, 0x3f, 0x72, 0x22, 0x22, 0x20, 0xe, 0xc0,\n    0x0, 0x2, 0x0, 0x4, 0xfd, 0x87, 0xaf, 0x50,\n    0x0, 0x3a, 0xef, 0xd6, 0x0,\n\n    /* U+0066 \"f\" */\n    0x0, 0x5d, 0xfc, 0x0, 0x2f, 0xb5, 0x70, 0x4,\n    0xf3, 0x0, 0xc, 0xff, 0xff, 0xa0, 0x48, 0xf7,\n    0x53, 0x0, 0x5f, 0x30, 0x0, 0x5, 0xf3, 0x0,\n    0x0, 0x5f, 0x30, 0x0, 0x5, 0xf3, 0x0, 0x0,\n    0x5f, 0x30, 0x0, 0x5, 0xf3, 0x0, 0x0, 0x5f,\n    0x30, 0x0,\n\n    /* U+0067 \"g\" */\n    0x0, 0x3b, 0xff, 0xb2, 0xe9, 0x4, 0xfe, 0x87,\n    0xcf, 0xf9, 0xe, 0xd1, 0x0, 0xa, 0xf9, 0x3f,\n    0x60, 0x0, 0x1, 0xf9, 0x4f, 0x40, 0x0, 0x0,\n    0xf9, 0x3f, 0x60, 0x0, 0x1, 0xf9, 0xe, 0xd0,\n    0x0, 0x9, 0xf9, 0x4, 0xfd, 0x87, 0xcf, 0xf8,\n    0x0, 0x3b, 0xff, 0xb3, 0xf7, 0x0, 0x0, 0x0,\n    0x5, 0xf4, 0x9, 0xe9, 0x77, 0xaf, 0xb0, 0x1,\n    0x7c, 0xff, 0xd8, 0x0,\n\n    /* U+0068 \"h\" */\n    0x8f, 0x0, 0x0, 0x0, 0x8, 0xf0, 0x0, 0x0,\n    0x0, 0x8f, 0x0, 0x0, 0x0, 0x8, 0xf2, 0xbf,\n    0xea, 0x10, 0x8f, 0xfb, 0x89, 0xfd, 0x8, 0xf8,\n    0x0, 0x6, 0xf4, 0x8f, 0x10, 0x0, 0x1f, 0x78,\n    0xf0, 0x0, 0x0, 0xf8, 0x8f, 0x0, 0x0, 0xf,\n    0x88, 0xf0, 0x0, 0x0, 0xf8, 0x8f, 0x0, 0x0,\n    0xf, 0x88, 0xf0, 0x0, 0x0, 0xf8,\n\n    /* U+0069 \"i\" */\n    0x9e, 0x1a, 0xf2, 0x0, 0x8, 0xf0, 0x8f, 0x8,\n    0xf0, 0x8f, 0x8, 0xf0, 0x8f, 0x8, 0xf0, 0x8f,\n    0x8, 0xf0,\n\n    /* U+006A \"j\" */\n    0x0, 0x7, 0xe2, 0x0, 0x9, 0xf3, 0x0, 0x0,\n    0x0, 0x0, 0x7, 0xf1, 0x0, 0x7, 0xf1, 0x0,\n    0x7, 0xf1, 0x0, 0x7, 0xf1, 0x0, 0x7, 0xf1,\n    0x0, 0x7, 0xf1, 0x0, 0x7, 0xf1, 0x0, 0x7,\n    0xf1, 0x0, 0x7, 0xf1, 0x0, 0x8, 0xf0, 0x18,\n    0x6e, 0xc0, 0x3e, 0xfc, 0x20,\n\n    /* U+006B \"k\" */\n    0x8f, 0x0, 0x0, 0x0, 0x8, 0xf0, 0x0, 0x0,\n    0x0, 0x8f, 0x0, 0x0, 0x0, 0x8, 0xf0, 0x0,\n    0x1d, 0xd1, 0x8f, 0x0, 0x1d, 0xe2, 0x8, 0xf0,\n    0x1d, 0xe2, 0x0, 0x8f, 0x2d, 0xf3, 0x0, 0x8,\n    0xfe, 0xff, 0x70, 0x0, 0x8f, 0xe2, 0xbf, 0x30,\n    0x8, 0xf2, 0x1, 0xee, 0x10, 0x8f, 0x0, 0x3,\n    0xfb, 0x8, 0xf0, 0x0, 0x7, 0xf7,\n\n    /* U+006C \"l\" */\n    0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f,\n    0x8f, 0x8f, 0x8f, 0x8f,\n\n    /* U+006D \"m\" */\n    0x8e, 0x3c, 0xfe, 0x91, 0x3b, 0xfe, 0xa2, 0x8,\n    0xff, 0x96, 0x9f, 0xcf, 0xc6, 0x8f, 0xd0, 0x8f,\n    0x70, 0x0, 0x9f, 0xc0, 0x0, 0x5f, 0x58, 0xf1,\n    0x0, 0x5, 0xf6, 0x0, 0x1, 0xf7, 0x8f, 0x0,\n    0x0, 0x4f, 0x40, 0x0, 0xf, 0x88, 0xf0, 0x0,\n    0x4, 0xf4, 0x0, 0x0, 0xf8, 0x8f, 0x0, 0x0,\n    0x4f, 0x40, 0x0, 0xf, 0x88, 0xf0, 0x0, 0x4,\n    0xf4, 0x0, 0x0, 0xf8, 0x8f, 0x0, 0x0, 0x4f,\n    0x40, 0x0, 0xf, 0x80,\n\n    /* U+006E \"n\" */\n    0x8e, 0x3b, 0xfe, 0xa1, 0x8, 0xff, 0xa6, 0x8f,\n    0xd0, 0x8f, 0x80, 0x0, 0x6f, 0x48, 0xf1, 0x0,\n    0x1, 0xf7, 0x8f, 0x0, 0x0, 0xf, 0x88, 0xf0,\n    0x0, 0x0, 0xf8, 0x8f, 0x0, 0x0, 0xf, 0x88,\n    0xf0, 0x0, 0x0, 0xf8, 0x8f, 0x0, 0x0, 0xf,\n    0x80,\n\n    /* U+006F \"o\" */\n    0x0, 0x3b, 0xef, 0xc4, 0x0, 0x4, 0xfd, 0x87,\n    0xcf, 0x60, 0xe, 0xd0, 0x0, 0xb, 0xf1, 0x3f,\n    0x60, 0x0, 0x3, 0xf5, 0x4f, 0x30, 0x0, 0x1,\n    0xf7, 0x3f, 0x60, 0x0, 0x3, 0xf5, 0xe, 0xd0,\n    0x0, 0xb, 0xf1, 0x4, 0xfd, 0x77, 0xcf, 0x60,\n    0x0, 0x3b, 0xef, 0xc4, 0x0,\n\n    /* U+0070 \"p\" */\n    0x8e, 0x3b, 0xfe, 0xb3, 0x0, 0x8f, 0xfb, 0x57,\n    0xdf, 0x30, 0x8f, 0x90, 0x0, 0xd, 0xc0, 0x8f,\n    0x10, 0x0, 0x7, 0xf1, 0x8f, 0x0, 0x0, 0x5,\n    0xf3, 0x8f, 0x20, 0x0, 0x7, 0xf1, 0x8f, 0xa0,\n    0x0, 0x1e, 0xd0, 0x8f, 0xec, 0x78, 0xef, 0x30,\n    0x8f, 0x2b, 0xfe, 0xb3, 0x0, 0x8f, 0x0, 0x0,\n    0x0, 0x0, 0x8f, 0x0, 0x0, 0x0, 0x0, 0x8f,\n    0x0, 0x0, 0x0, 0x0,\n\n    /* U+0071 \"q\" */\n    0x0, 0x3b, 0xff, 0xa2, 0xf7, 0x4, 0xfd, 0x87,\n    0xde, 0xf7, 0xe, 0xd0, 0x0, 0xb, 0xf7, 0x3f,\n    0x60, 0x0, 0x3, 0xf7, 0x4f, 0x30, 0x0, 0x1,\n    0xf7, 0x3f, 0x60, 0x0, 0x3, 0xf7, 0xe, 0xd0,\n    0x0, 0xb, 0xf7, 0x4, 0xfd, 0x77, 0xce, 0xf7,\n    0x0, 0x3b, 0xff, 0xa3, 0xf7, 0x0, 0x0, 0x0,\n    0x1, 0xf7, 0x0, 0x0, 0x0, 0x1, 0xf7, 0x0,\n    0x0, 0x0, 0x1, 0xf7,\n\n    /* U+0072 \"r\" */\n    0x8e, 0x2b, 0xf0, 0x8f, 0xed, 0x90, 0x8f, 0xa0,\n    0x0, 0x8f, 0x20, 0x0, 0x8f, 0x0, 0x0, 0x8f,\n    0x0, 0x0, 0x8f, 0x0, 0x0, 0x8f, 0x0, 0x0,\n    0x8f, 0x0, 0x0,\n\n    /* U+0073 \"s\" */\n    0x2, 0xae, 0xfd, 0x91, 0x1e, 0xd7, 0x69, 0xd0,\n    0x4f, 0x30, 0x0, 0x0, 0x2f, 0xb4, 0x10, 0x0,\n    0x6, 0xef, 0xfd, 0x60, 0x0, 0x1, 0x5b, 0xf5,\n    0x1, 0x0, 0x0, 0xf7, 0x5f, 0xa7, 0x6b, 0xf3,\n    0x19, 0xdf, 0xec, 0x40,\n\n    /* U+0074 \"t\" */\n    0x5, 0xf3, 0x0, 0x0, 0x5f, 0x30, 0x0, 0xcf,\n    0xff, 0xfa, 0x4, 0x8f, 0x75, 0x30, 0x5, 0xf3,\n    0x0, 0x0, 0x5f, 0x30, 0x0, 0x5, 0xf3, 0x0,\n    0x0, 0x5f, 0x30, 0x0, 0x4, 0xf4, 0x0, 0x0,\n    0x1f, 0xc6, 0x80, 0x0, 0x5d, 0xfc, 0x10,\n\n    /* U+0075 \"u\" */\n    0xae, 0x0, 0x0, 0x2f, 0x5a, 0xe0, 0x0, 0x2,\n    0xf5, 0xae, 0x0, 0x0, 0x2f, 0x5a, 0xe0, 0x0,\n    0x2, 0xf5, 0xae, 0x0, 0x0, 0x2f, 0x59, 0xf0,\n    0x0, 0x4, 0xf5, 0x6f, 0x30, 0x0, 0xaf, 0x51,\n    0xee, 0x76, 0xbf, 0xf5, 0x2, 0xbe, 0xfb, 0x3f,\n    0x50,\n\n    /* U+0076 \"v\" */\n    0xd, 0xc0, 0x0, 0x0, 0xcb, 0x6, 0xf2, 0x0,\n    0x2, 0xf5, 0x0, 0xf9, 0x0, 0x9, 0xe0, 0x0,\n    0x9e, 0x0, 0xf, 0x80, 0x0, 0x2f, 0x60, 0x6f,\n    0x10, 0x0, 0xc, 0xc0, 0xcb, 0x0, 0x0, 0x5,\n    0xf6, 0xf4, 0x0, 0x0, 0x0, 0xef, 0xd0, 0x0,\n    0x0, 0x0, 0x8f, 0x70, 0x0,\n\n    /* U+0077 \"w\" */\n    0xbb, 0x0, 0x0, 0x9f, 0x10, 0x0, 0x4f, 0x16,\n    0xf1, 0x0, 0xe, 0xf6, 0x0, 0x9, 0xc0, 0xf,\n    0x60, 0x5, 0xfc, 0xb0, 0x0, 0xf6, 0x0, 0xac,\n    0x0, 0xab, 0x5f, 0x10, 0x5f, 0x10, 0x5, 0xf1,\n    0xf, 0x50, 0xf7, 0xa, 0xb0, 0x0, 0xf, 0x76,\n    0xf0, 0x9, 0xc0, 0xf5, 0x0, 0x0, 0xac, 0xba,\n    0x0, 0x4f, 0x8f, 0x0, 0x0, 0x4, 0xff, 0x40,\n    0x0, 0xef, 0xa0, 0x0, 0x0, 0xe, 0xe0, 0x0,\n    0x8, 0xf4, 0x0, 0x0,\n\n    /* U+0078 \"x\" */\n    0x4f, 0x70, 0x0, 0x9f, 0x20, 0x8f, 0x30, 0x5f,\n    0x50, 0x0, 0xcd, 0x2e, 0x90, 0x0, 0x2, 0xff,\n    0xd0, 0x0, 0x0, 0xa, 0xf6, 0x0, 0x0, 0x4,\n    0xfd, 0xe1, 0x0, 0x1, 0xeb, 0xd, 0xc0, 0x0,\n    0xbe, 0x10, 0x3f, 0x80, 0x6f, 0x40, 0x0, 0x7f,\n    0x40,\n\n    /* U+0079 \"y\" */\n    0xd, 0xc0, 0x0, 0x0, 0xcb, 0x6, 0xf3, 0x0,\n    0x2, 0xf4, 0x0, 0xea, 0x0, 0x9, 0xd0, 0x0,\n    0x8f, 0x10, 0x1f, 0x70, 0x0, 0x1f, 0x70, 0x7f,\n    0x10, 0x0, 0xa, 0xe0, 0xd9, 0x0, 0x0, 0x3,\n    0xf9, 0xf2, 0x0, 0x0, 0x0, 0xcf, 0xb0, 0x0,\n    0x0, 0x0, 0x6f, 0x40, 0x0, 0x0, 0x0, 0xad,\n    0x0, 0x0, 0x1c, 0x79, 0xf5, 0x0, 0x0, 0x1a,\n    0xee, 0x70, 0x0, 0x0,\n\n    /* U+007A \"z\" */\n    0x4f, 0xff, 0xff, 0xf9, 0x15, 0x55, 0x5b, 0xf4,\n    0x0, 0x0, 0x4f, 0x80, 0x0, 0x1, 0xec, 0x0,\n    0x0, 0xb, 0xe1, 0x0, 0x0, 0x8f, 0x40, 0x0,\n    0x4, 0xf7, 0x0, 0x0, 0x1e, 0xe5, 0x55, 0x53,\n    0x5f, 0xff, 0xff, 0xfc,\n\n    /* U+007B \"{\" */\n    0x0, 0x2c, 0xf5, 0x0, 0xaf, 0x61, 0x0, 0xcc,\n    0x0, 0x0, 0xdb, 0x0, 0x0, 0xdb, 0x0, 0x0,\n    0xdb, 0x0, 0x2, 0xea, 0x0, 0x1f, 0xf4, 0x0,\n    0x5, 0xfa, 0x0, 0x0, 0xdb, 0x0, 0x0, 0xdb,\n    0x0, 0x0, 0xdb, 0x0, 0x0, 0xcc, 0x0, 0x0,\n    0xaf, 0x61, 0x0, 0x2c, 0xf5,\n\n    /* U+007C \"|\" */\n    0x5f, 0x15, 0xf1, 0x5f, 0x15, 0xf1, 0x5f, 0x15,\n    0xf1, 0x5f, 0x15, 0xf1, 0x5f, 0x15, 0xf1, 0x5f,\n    0x15, 0xf1, 0x5f, 0x15, 0xf1, 0x5f, 0x10,\n\n    /* U+007D \"}\" */\n    0xbe, 0x80, 0x3, 0xaf, 0x40, 0x1, 0xf6, 0x0,\n    0x1f, 0x70, 0x1, 0xf7, 0x0, 0x1f, 0x70, 0x0,\n    0xf9, 0x0, 0xa, 0xfb, 0x0, 0xfb, 0x20, 0x1f,\n    0x70, 0x1, 0xf7, 0x0, 0x1f, 0x70, 0x1, 0xf6,\n    0x3, 0xaf, 0x40, 0xbe, 0x90, 0x0,\n\n    /* U+007E \"~\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x3d, 0xe4, 0x0,\n    0xb5, 0xc, 0x86, 0xf5, 0x1e, 0x20, 0xf0, 0x3,\n    0xef, 0x90, 0x2, 0x0, 0x0, 0x10, 0x0,\n\n    /* U+00B0 \"\u00b0\" */\n    0x2, 0xce, 0x90, 0xd, 0x40, 0x89, 0x3b, 0x0,\n    0xe, 0x3b, 0x0, 0xe, 0xd, 0x40, 0x89, 0x2,\n    0xce, 0x90,\n\n    /* U+2022 \"\u2022\" */\n    0x0, 0x8, 0xf8, 0xef, 0xe7, 0xf7,\n\n    /* U+F001 \"\uf001\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x49, 0xdc,\n    0x0, 0x0, 0x0, 0x0, 0x16, 0xbf, 0xff, 0xff,\n    0x0, 0x0, 0x3, 0x8d, 0xff, 0xff, 0xff, 0xff,\n    0x0, 0x0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xff,\n    0x0, 0x0, 0xff, 0xff, 0xea, 0x51, 0x0, 0xff,\n    0x0, 0x0, 0xff, 0x83, 0x0, 0x0, 0x0, 0xff,\n    0x0, 0x0, 0xff, 0x0, 0x0, 0x0, 0x0, 0xff,\n    0x0, 0x0, 0xff, 0x0, 0x0, 0x0, 0x0, 0xff,\n    0x0, 0x0, 0xff, 0x0, 0x0, 0x0, 0x0, 0xff,\n    0x0, 0x0, 0xff, 0x0, 0x0, 0x2b, 0xff, 0xff,\n    0x0, 0x0, 0xff, 0x0, 0x0, 0xdf, 0xff, 0xff,\n    0x2b, 0xff, 0xff, 0x0, 0x0, 0xdf, 0xff, 0xfd,\n    0xdf, 0xff, 0xff, 0x0, 0x0, 0x2b, 0xff, 0xb2,\n    0xdf, 0xff, 0xfd, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x2b, 0xff, 0xb2, 0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+F008 \"\uf008\" */\n    0xd0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xd,\n    0xff, 0xff, 0xc8, 0x88, 0x88, 0x8c, 0xff, 0xff,\n    0xf0, 0xf, 0x80, 0x0, 0x0, 0x8, 0xf0, 0xf,\n    0xf0, 0xf, 0x80, 0x0, 0x0, 0x8, 0xf0, 0xf,\n    0xff, 0xff, 0x80, 0x0, 0x0, 0x8, 0xff, 0xff,\n    0xf0, 0xf, 0xec, 0xcc, 0xcc, 0xce, 0xf0, 0xf,\n    0xf0, 0xf, 0xec, 0xcc, 0xcc, 0xce, 0xf0, 0xf,\n    0xff, 0xff, 0x80, 0x0, 0x0, 0x8, 0xff, 0xff,\n    0xf0, 0xf, 0x80, 0x0, 0x0, 0x8, 0xf0, 0xf,\n    0xf0, 0xf, 0x80, 0x0, 0x0, 0x8, 0xf0, 0xf,\n    0xff, 0xff, 0xc8, 0x88, 0x88, 0x8c, 0xff, 0xff,\n    0xd0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xd,\n\n    /* U+F00B \"\uf00b\" */\n    0xdf, 0xff, 0x73, 0xff, 0xff, 0xff, 0xff, 0xfd,\n    0xff, 0xff, 0xa5, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xa5, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xdf, 0xff, 0x73, 0xff, 0xff, 0xff, 0xff, 0xfd,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0xdf, 0xff, 0x73, 0xff, 0xff, 0xff, 0xff, 0xfd,\n    0xff, 0xff, 0xa5, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xa5, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xdf, 0xff, 0x73, 0xff, 0xff, 0xff, 0xff, 0xfd,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0xdf, 0xff, 0x73, 0xff, 0xff, 0xff, 0xff, 0xfd,\n    0xff, 0xff, 0xa5, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xa5, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xdf, 0xff, 0x73, 0xff, 0xff, 0xff, 0xff, 0xfd,\n\n    /* U+F00C \"\uf00c\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0xb1,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xbf, 0xfc,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xb, 0xff, 0xfb,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xbf, 0xff, 0xc0,\n    0x1b, 0xa0, 0x0, 0x0, 0xb, 0xff, 0xfc, 0x0,\n    0xcf, 0xfb, 0x0, 0x0, 0xbf, 0xff, 0xc0, 0x0,\n    0xbf, 0xff, 0xb0, 0xb, 0xff, 0xfc, 0x0, 0x0,\n    0xc, 0xff, 0xfb, 0xbf, 0xff, 0xc0, 0x0, 0x0,\n    0x0, 0xcf, 0xff, 0xff, 0xfb, 0x0, 0x0, 0x0,\n    0x0, 0xc, 0xff, 0xff, 0xb0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xbf, 0xfb, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xb, 0xb0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+F00D \"\uf00d\" */\n    0x3, 0x0, 0x0, 0x0, 0x3, 0x8, 0xfc, 0x10,\n    0x0, 0x1c, 0xf8, 0xff, 0xfc, 0x10, 0x1c, 0xff,\n    0xf5, 0xff, 0xfc, 0x2c, 0xff, 0xf5, 0x5, 0xff,\n    0xff, 0xff, 0xf5, 0x0, 0x5, 0xff, 0xff, 0xf5,\n    0x0, 0x0, 0x1d, 0xff, 0xfd, 0x10, 0x0, 0x1c,\n    0xff, 0xff, 0xfc, 0x10, 0x1c, 0xff, 0xf9, 0xff,\n    0xfc, 0x1c, 0xff, 0xf5, 0x5, 0xff, 0xfc, 0xdf,\n    0xf5, 0x0, 0x5, 0xff, 0xd1, 0xa4, 0x0, 0x0,\n    0x4, 0xa1,\n\n    /* U+F011 \"\uf011\" */\n    0x0, 0x0, 0x0, 0x4f, 0xe0, 0x0, 0x0, 0x0,\n    0x0, 0x2, 0x10, 0x6f, 0xf1, 0x3, 0x10, 0x0,\n    0x0, 0x5f, 0xd0, 0x6f, 0xf1, 0x3f, 0xd1, 0x0,\n    0x3, 0xff, 0xf1, 0x6f, 0xf1, 0x5f, 0xfd, 0x0,\n    0xd, 0xff, 0x40, 0x6f, 0xf1, 0x9, 0xff, 0x70,\n    0x4f, 0xf7, 0x0, 0x6f, 0xf1, 0x0, 0xcf, 0xe0,\n    0x9f, 0xf0, 0x0, 0x6f, 0xf1, 0x0, 0x5f, 0xf3,\n    0xbf, 0xc0, 0x0, 0x6f, 0xf1, 0x0, 0x2f, 0xf5,\n    0xbf, 0xc0, 0x0, 0x4f, 0xe0, 0x0, 0x1f, 0xf6,\n    0xaf, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x4f, 0xf4,\n    0x6f, 0xf4, 0x0, 0x0, 0x0, 0x0, 0xaf, 0xf0,\n    0xf, 0xfe, 0x10, 0x0, 0x0, 0x5, 0xff, 0xa0,\n    0x6, 0xff, 0xd3, 0x0, 0x0, 0x7f, 0xff, 0x20,\n    0x0, 0x9f, 0xff, 0xda, 0xbe, 0xff, 0xf4, 0x0,\n    0x0, 0x6, 0xff, 0xff, 0xff, 0xfd, 0x30, 0x0,\n    0x0, 0x0, 0x17, 0xbd, 0xca, 0x50, 0x0, 0x0,\n\n    /* U+F013 \"\uf013\" */\n    0x0, 0x0, 0x0, 0x8b, 0xb8, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0,\n    0x0, 0x30, 0x6, 0xff, 0xff, 0x60, 0x3, 0x0,\n    0x4, 0xfd, 0xdf, 0xff, 0xff, 0xfd, 0xef, 0x40,\n    0xd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd0,\n    0x4f, 0xff, 0xff, 0xf9, 0x9f, 0xff, 0xff, 0xf4,\n    0x8, 0xff, 0xff, 0x20, 0x2, 0xff, 0xff, 0x80,\n    0x0, 0xff, 0xf9, 0x0, 0x0, 0x9f, 0xff, 0x0,\n    0x0, 0xff, 0xf9, 0x0, 0x0, 0x9f, 0xff, 0x0,\n    0x8, 0xff, 0xff, 0x20, 0x2, 0xff, 0xff, 0x80,\n    0x4f, 0xff, 0xff, 0xf9, 0x9f, 0xff, 0xff, 0xf4,\n    0xd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd0,\n    0x4, 0xfe, 0xdf, 0xff, 0xff, 0xfd, 0xdf, 0x40,\n    0x0, 0x30, 0x6, 0xff, 0xff, 0x60, 0x3, 0x0,\n    0x0, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x8b, 0xb8, 0x0, 0x0, 0x0,\n\n    /* U+F015 \"\uf015\" */\n    0x0, 0x0, 0x0, 0x3, 0xdd, 0x30, 0x3f, 0xf3,\n    0x0, 0x0, 0x0, 0x0, 0x6f, 0xff, 0xf5, 0x4f,\n    0xf4, 0x0, 0x0, 0x0, 0x9, 0xff, 0x99, 0xff,\n    0xbf, 0xf4, 0x0, 0x0, 0x1, 0xbf, 0xf6, 0x22,\n    0x6f, 0xff, 0xf4, 0x0, 0x0, 0x2d, 0xfe, 0x35,\n    0xff, 0x53, 0xef, 0xf4, 0x0, 0x4, 0xff, 0xc1,\n    0x8f, 0xff, 0xf8, 0x2d, 0xfe, 0x40, 0x7f, 0xfa,\n    0x1a, 0xff, 0xff, 0xff, 0xa1, 0xaf, 0xf7, 0xcf,\n    0x82, 0xdf, 0xff, 0xff, 0xff, 0xfd, 0x28, 0xfc,\n    0x14, 0xe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,\n    0x41, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xf0, 0x0, 0x0, 0xf, 0xff, 0xf9, 0x0, 0x8f,\n    0xff, 0xf0, 0x0, 0x0, 0xf, 0xff, 0xf8, 0x0,\n    0x8f, 0xff, 0xf0, 0x0, 0x0, 0xf, 0xff, 0xf8,\n    0x0, 0x8f, 0xff, 0xf0, 0x0, 0x0, 0xe, 0xff,\n    0xf6, 0x0, 0x6f, 0xff, 0xe0, 0x0,\n\n    /* U+F019 \"\uf019\" */\n    0x0, 0x0, 0x0, 0xdf, 0xfd, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0,\n    0x0, 0x4f, 0xff, 0xff, 0xff, 0xff, 0xf4, 0x0,\n    0x0, 0xb, 0xff, 0xff, 0xff, 0xff, 0xb0, 0x0,\n    0x0, 0x0, 0xbf, 0xff, 0xff, 0xfb, 0x0, 0x0,\n    0x0, 0x0, 0xb, 0xff, 0xff, 0xb0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xbf, 0xfb, 0x0, 0x0, 0x0,\n    0xdf, 0xff, 0xfc, 0x1b, 0xb1, 0xcf, 0xff, 0xfd,\n    0xff, 0xff, 0xff, 0xc2, 0x2c, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xe0, 0xff,\n    0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd,\n\n    /* U+F01C \"\uf01c\" */\n    0x0, 0x4, 0xef, 0xff, 0xff, 0xff, 0xfe, 0x40,\n    0x0, 0x0, 0x1e, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xe1, 0x0, 0x0, 0xaf, 0xb0, 0x0, 0x0, 0x0,\n    0xb, 0xfa, 0x0, 0x5, 0xff, 0x10, 0x0, 0x0,\n    0x0, 0x1, 0xff, 0x50, 0x1e, 0xf6, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x6f, 0xe1, 0xaf, 0xb0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xb, 0xfa, 0xff, 0xff,\n    0xff, 0x80, 0x0, 0x8, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xf1, 0x0, 0x1f, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xf8,\n\n    /* U+F021 \"\uf021\" */\n    0x0, 0x0, 0x6, 0xbd, 0xda, 0x50, 0x2, 0xff,\n    0x0, 0x5, 0xef, 0xff, 0xff, 0xfe, 0x42, 0xff,\n    0x0, 0x7f, 0xff, 0xa7, 0x7b, 0xff, 0xf9, 0xff,\n    0x5, 0xff, 0xc1, 0x0, 0x0, 0x2c, 0xff, 0xff,\n    0xe, 0xfc, 0x0, 0x0, 0x2, 0x22, 0xdf, 0xff,\n    0x5f, 0xf2, 0x0, 0x0, 0xf, 0xff, 0xff, 0xff,\n    0x8f, 0xb0, 0x0, 0x0, 0xf, 0xff, 0xff, 0xff,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0xb, 0xf8,\n    0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x2f, 0xf4,\n    0xff, 0xfd, 0x22, 0x20, 0x0, 0x0, 0xcf, 0xe0,\n    0xff, 0xff, 0xc2, 0x0, 0x0, 0x2c, 0xff, 0x40,\n    0xff, 0x9f, 0xff, 0xb7, 0x6a, 0xff, 0xf7, 0x0,\n    0xff, 0x24, 0xdf, 0xff, 0xff, 0xfe, 0x50, 0x0,\n    0xff, 0x20, 0x5, 0xac, 0xdb, 0x60, 0x0, 0x0,\n\n    /* U+F026 \"\uf026\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8d,\n    0x0, 0x0, 0x8, 0xff, 0x0, 0x0, 0x8f, 0xff,\n    0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0xff, 0xff,\n    0x0, 0x0, 0x8f, 0xff, 0x0, 0x0, 0x8, 0xff,\n    0x0, 0x0, 0x0, 0x8d, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+F027 \"\uf027\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x8d, 0x0, 0x0, 0x0, 0x0, 0x8, 0xff,\n    0x0, 0x0, 0x0, 0x0, 0x8f, 0xff, 0x0, 0x0,\n    0xcf, 0xff, 0xff, 0xff, 0x1, 0x50, 0xff, 0xff,\n    0xff, 0xff, 0x6, 0xf7, 0xff, 0xff, 0xff, 0xff,\n    0x0, 0xbe, 0xff, 0xff, 0xff, 0xff, 0x0, 0xae,\n    0xff, 0xff, 0xff, 0xff, 0x5, 0xf8, 0xdf, 0xff,\n    0xff, 0xff, 0x2, 0x60, 0x0, 0x0, 0x9f, 0xff,\n    0x0, 0x0, 0x0, 0x0, 0x9, 0xff, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x9e, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0,\n\n    /* U+F028 \"\uf028\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x10,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f,\n    0xd2, 0x0, 0x0, 0x0, 0x0, 0x8d, 0x0, 0x0,\n    0x3, 0xee, 0x10, 0x0, 0x0, 0x8, 0xff, 0x0,\n    0xa, 0xb1, 0x2f, 0xb0, 0x0, 0x0, 0x8f, 0xff,\n    0x0, 0x5, 0xfc, 0x7, 0xf4, 0xdf, 0xff, 0xff,\n    0xff, 0x2, 0x50, 0x5f, 0x60, 0xf9, 0xff, 0xff,\n    0xff, 0xff, 0x6, 0xf7, 0xd, 0xc0, 0xbd, 0xff,\n    0xff, 0xff, 0xff, 0x0, 0xae, 0x9, 0xf0, 0x9f,\n    0xff, 0xff, 0xff, 0xff, 0x0, 0xae, 0x9, 0xf0,\n    0x8f, 0xff, 0xff, 0xff, 0xff, 0x6, 0xf7, 0xd,\n    0xc0, 0xad, 0xdf, 0xff, 0xff, 0xff, 0x2, 0x50,\n    0x5f, 0x60, 0xe9, 0x0, 0x0, 0x8f, 0xff, 0x0,\n    0x5, 0xfc, 0x6, 0xf4, 0x0, 0x0, 0x8, 0xff,\n    0x0, 0xa, 0xb1, 0x2f, 0xb0, 0x0, 0x0, 0x0,\n    0x8d, 0x0, 0x0, 0x2, 0xee, 0x10, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x1f, 0xd2, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x10, 0x0,\n\n    /* U+F03E \"\uf03e\" */\n    0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8,\n    0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0x20, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xfc, 0x0, 0xc, 0xff, 0xff, 0xee, 0xff, 0xff,\n    0xff, 0x20, 0x2f, 0xff, 0xfe, 0x22, 0xef, 0xff,\n    0xff, 0xfc, 0xff, 0xff, 0xe2, 0x0, 0x2e, 0xff,\n    0xff, 0xfe, 0x4e, 0xfe, 0x20, 0x0, 0x2, 0xff,\n    0xff, 0xe2, 0x2, 0xc2, 0x0, 0x0, 0x0, 0xff,\n    0xff, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff,\n    0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8,\n\n    /* U+F043 \"\uf043\" */\n    0x0, 0x0, 0x4e, 0x40, 0x0, 0x0, 0x0, 0xb,\n    0xfb, 0x0, 0x0, 0x0, 0x1, 0xff, 0xf1, 0x0,\n    0x0, 0x0, 0x9f, 0xff, 0x90, 0x0, 0x0, 0x2f,\n    0xff, 0xff, 0x30, 0x0, 0xc, 0xff, 0xff, 0xfc,\n    0x0, 0x7, 0xff, 0xff, 0xff, 0xf8, 0x2, 0xff,\n    0xff, 0xff, 0xff, 0xf2, 0x9f, 0xff, 0xff, 0xff,\n    0xff, 0x9e, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff,\n    0x2f, 0xff, 0xff, 0xff, 0xfe, 0xf2, 0xbf, 0xff,\n    0xff, 0xfe, 0x9f, 0xa1, 0xbf, 0xff, 0xff, 0x92,\n    0xff, 0xa2, 0x2f, 0xff, 0xf2, 0x4, 0xff, 0xff,\n    0xff, 0xf4, 0x0, 0x2, 0x9e, 0xfe, 0x92, 0x0,\n\n    /* U+F048 \"\uf048\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0x30, 0x0,\n    0x1, 0xcc, 0xff, 0x40, 0x0, 0x2d, 0xff, 0xff,\n    0x40, 0x3, 0xef, 0xff, 0xff, 0x40, 0x3f, 0xff,\n    0xff, 0xff, 0x44, 0xff, 0xff, 0xff, 0xff, 0x9f,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xaf, 0xff,\n    0xff, 0xff, 0xff, 0x45, 0xff, 0xff, 0xff, 0xff,\n    0x40, 0x4f, 0xff, 0xff, 0xff, 0x40, 0x3, 0xef,\n    0xff, 0xff, 0x40, 0x0, 0x2e, 0xff, 0xff, 0x30,\n    0x0, 0x1, 0xcc, 0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+F04B \"\uf04b\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8f,\n    0x91, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff,\n    0x70, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xfd,\n    0x40, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xfa,\n    0x10, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xf7,\n    0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd5,\n    0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb2,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xb2, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xd5, 0x0, 0xff, 0xff, 0xff, 0xff,\n    0xf7, 0x0, 0x0, 0xff, 0xff, 0xff, 0xfa, 0x10,\n    0x0, 0x0, 0xff, 0xff, 0xfd, 0x40, 0x0, 0x0,\n    0x0, 0xff, 0xff, 0x70, 0x0, 0x0, 0x0, 0x0,\n    0x8e, 0xa1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+F04C \"\uf04c\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8f,\n    0xff, 0xf8, 0x0, 0x8f, 0xff, 0xf8, 0xff, 0xff,\n    0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff,\n    0xff, 0xff, 0x7f, 0xff, 0xf7, 0x0, 0x7f, 0xff,\n    0xf7,\n\n    /* U+F04D \"\uf04d\" */\n    0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xf8,\n\n    /* U+F051 \"\uf051\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xcc, 0x10, 0x0,\n    0x3, 0xff, 0xff, 0xd2, 0x0, 0x4, 0xff, 0xff,\n    0xfe, 0x30, 0x4, 0xff, 0xff, 0xff, 0xf4, 0x4,\n    0xff, 0xff, 0xff, 0xff, 0x54, 0xff, 0xff, 0xff,\n    0xff, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xf9, 0xff, 0xff, 0xff, 0xff, 0x44, 0xff, 0xff,\n    0xff, 0xf3, 0x4, 0xff, 0xff, 0xfe, 0x30, 0x4,\n    0xff, 0xff, 0xd2, 0x0, 0x4, 0xff, 0xcc, 0x10,\n    0x0, 0x3, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+F052 \"\uf052\" */\n    0x0, 0x0, 0x0, 0x2d, 0xd2, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x1, 0xef, 0xfe, 0x10, 0x0, 0x0,\n    0x0, 0x0, 0x1d, 0xff, 0xff, 0xd1, 0x0, 0x0,\n    0x0, 0x0, 0xcf, 0xff, 0xff, 0xfc, 0x0, 0x0,\n    0x0, 0xb, 0xff, 0xff, 0xff, 0xff, 0xb0, 0x0,\n    0x0, 0xaf, 0xff, 0xff, 0xff, 0xff, 0xfa, 0x0,\n    0x9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x90,\n    0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,\n    0x8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0xc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,\n    0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,\n    0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,\n    0xc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,\n\n    /* U+F053 \"\uf053\" */\n    0x0, 0x0, 0x0, 0x1a, 0x40, 0x0, 0x0, 0x1,\n    0xdf, 0xf0, 0x0, 0x0, 0x1d, 0xff, 0xa0, 0x0,\n    0x1, 0xdf, 0xfa, 0x0, 0x0, 0x1d, 0xff, 0xa0,\n    0x0, 0x1, 0xdf, 0xfa, 0x0, 0x0, 0xc, 0xff,\n    0xa0, 0x0, 0x0, 0xd, 0xff, 0x80, 0x0, 0x0,\n    0x1, 0xdf, 0xf8, 0x0, 0x0, 0x0, 0x1d, 0xff,\n    0x80, 0x0, 0x0, 0x1, 0xdf, 0xf8, 0x0, 0x0,\n    0x0, 0x1d, 0xff, 0x80, 0x0, 0x0, 0x1, 0xdf,\n    0xf0, 0x0, 0x0, 0x0, 0x1b, 0x50,\n\n    /* U+F054 \"\uf054\" */\n    0x4, 0xa1, 0x0, 0x0, 0x0, 0xf, 0xfd, 0x10,\n    0x0, 0x0, 0xa, 0xff, 0xd1, 0x0, 0x0, 0x0,\n    0xaf, 0xfd, 0x10, 0x0, 0x0, 0xa, 0xff, 0xd1,\n    0x0, 0x0, 0x0, 0xaf, 0xfd, 0x10, 0x0, 0x0,\n    0xa, 0xff, 0xc0, 0x0, 0x0, 0x8, 0xff, 0xd0,\n    0x0, 0x0, 0x8f, 0xfd, 0x10, 0x0, 0x8, 0xff,\n    0xd1, 0x0, 0x0, 0x8f, 0xfd, 0x10, 0x0, 0x8,\n    0xff, 0xd1, 0x0, 0x0, 0xf, 0xfd, 0x10, 0x0,\n    0x0, 0x5, 0xb1, 0x0, 0x0, 0x0,\n\n    /* U+F067 \"\uf067\" */\n    0x0, 0x0, 0x4, 0xff, 0x40, 0x0, 0x0, 0x0,\n    0x0, 0x8, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0,\n    0x8, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x8,\n    0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x8, 0xff,\n    0x80, 0x0, 0x0, 0x48, 0x88, 0x8c, 0xff, 0xc8,\n    0x88, 0x84, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x48, 0x88, 0x8c, 0xff, 0xc8, 0x88, 0x84, 0x0,\n    0x0, 0x8, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0,\n    0x8, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x8,\n    0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x8, 0xff,\n    0x80, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0x40,\n    0x0, 0x0,\n\n    /* U+F068 \"\uf068\" */\n    0x14, 0x44, 0x44, 0x44, 0x44, 0x44, 0x41, 0xef,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0x7b, 0xbb, 0xbb,\n    0xbb, 0xbb, 0xbb, 0xb7,\n\n    /* U+F06E \"\uf06e\" */\n    0x0, 0x0, 0x5, 0xad, 0xff, 0xda, 0x50, 0x0,\n    0x0, 0x0, 0x4, 0xdf, 0xfc, 0x88, 0xcf, 0xfd,\n    0x40, 0x0, 0x0, 0x7f, 0xfe, 0x40, 0x0, 0x4,\n    0xef, 0xf7, 0x0, 0x7, 0xff, 0xf4, 0x0, 0x9e,\n    0x80, 0x4f, 0xff, 0x70, 0x4f, 0xff, 0xc0, 0x0,\n    0xaf, 0xf8, 0xc, 0xff, 0xf4, 0xdf, 0xff, 0x80,\n    0x9a, 0xff, 0xfe, 0x8, 0xff, 0xfd, 0xdf, 0xff,\n    0x80, 0xef, 0xff, 0xfe, 0x8, 0xff, 0xfd, 0x4f,\n    0xff, 0xc0, 0x8f, 0xff, 0xf8, 0xc, 0xff, 0xf4,\n    0x7, 0xff, 0xf4, 0x8, 0xee, 0x80, 0x4f, 0xff,\n    0x70, 0x0, 0x7f, 0xfe, 0x40, 0x0, 0x4, 0xef,\n    0xf8, 0x0, 0x0, 0x4, 0xdf, 0xfc, 0x88, 0xcf,\n    0xfd, 0x40, 0x0, 0x0, 0x0, 0x5, 0xad, 0xff,\n    0xda, 0x50, 0x0, 0x0,\n\n    /* U+F070 \"\uf070\" */\n    0x8c, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xdf, 0xe4, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x1b, 0xff, 0x80, 0x49,\n    0xdf, 0xfd, 0xa5, 0x0, 0x0, 0x0, 0x0, 0x7f,\n    0xff, 0xff, 0xd8, 0x8c, 0xff, 0xd4, 0x0, 0x0,\n    0x0, 0x4, 0xef, 0xf8, 0x0, 0x0, 0x4e, 0xff,\n    0x70, 0x0, 0x0, 0x0, 0x1c, 0xff, 0x69, 0xe8,\n    0x4, 0xff, 0xf7, 0x0, 0x4, 0xe3, 0x0, 0x9f,\n    0xfe, 0xff, 0x80, 0xcf, 0xff, 0x40, 0xd, 0xff,\n    0x70, 0x5, 0xff, 0xff, 0xe0, 0x8f, 0xff, 0xd0,\n    0xd, 0xff, 0xf7, 0x0, 0x2d, 0xff, 0xe0, 0x8f,\n    0xff, 0xd0, 0x4, 0xff, 0xfc, 0x0, 0x0, 0xaf,\n    0xf8, 0xcf, 0xff, 0x30, 0x0, 0x7f, 0xff, 0x40,\n    0x0, 0x6, 0xff, 0xff, 0xf7, 0x0, 0x0, 0x8,\n    0xff, 0xf4, 0x0, 0x0, 0x3e, 0xff, 0xa0, 0x0,\n    0x0, 0x0, 0x4d, 0xff, 0xc8, 0x82, 0x1, 0xbf,\n    0xf7, 0x0, 0x0, 0x0, 0x0, 0x5a, 0xdf, 0xfc,\n    0x10, 0x8, 0xff, 0xa0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x4e, 0xfd, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xc8,\n\n    /* U+F071 \"\uf071\" */\n    0x0, 0x0, 0x0, 0x0, 0x2d, 0xd2, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xbf, 0xfb,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5,\n    0xff, 0xff, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xd, 0xff, 0xff, 0xd0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xf7, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xd8, 0x8d,\n    0xff, 0x10, 0x0, 0x0, 0x0, 0x0, 0xa, 0xff,\n    0xa0, 0xa, 0xff, 0xa0, 0x0, 0x0, 0x0, 0x0,\n    0x3f, 0xff, 0xb0, 0xb, 0xff, 0xf3, 0x0, 0x0,\n    0x0, 0x0, 0xcf, 0xff, 0xc0, 0xc, 0xff, 0xfc,\n    0x0, 0x0, 0x0, 0x5, 0xff, 0xff, 0xd0, 0xd,\n    0xff, 0xff, 0x50, 0x0, 0x0, 0xe, 0xff, 0xff,\n    0xf9, 0x9f, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x8f,\n    0xff, 0xff, 0xe2, 0x2e, 0xff, 0xff, 0xf8, 0x0,\n    0x2, 0xff, 0xff, 0xff, 0x90, 0x9, 0xff, 0xff,\n    0xff, 0x10, 0xa, 0xff, 0xff, 0xff, 0xe3, 0x3e,\n    0xff, 0xff, 0xff, 0xa0, 0xf, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x8, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,\n\n    /* U+F074 \"\uf074\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xd8, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0x80,\n    0xff, 0xff, 0x70, 0x0, 0x7, 0xff, 0xff, 0xf8,\n    0xff, 0xff, 0xf6, 0x0, 0x6f, 0xff, 0xff, 0xfd,\n    0x78, 0x8e, 0xff, 0x15, 0xff, 0xe8, 0xff, 0xe2,\n    0x0, 0x2, 0xe5, 0x4f, 0xfe, 0x20, 0xfe, 0x20,\n    0x0, 0x0, 0x13, 0xff, 0xf3, 0x0, 0x52, 0x0,\n    0x0, 0x0, 0x3f, 0xff, 0x31, 0x0, 0x52, 0x0,\n    0x0, 0x2, 0xef, 0xf4, 0x5e, 0x20, 0xfe, 0x20,\n    0x78, 0x8e, 0xff, 0x51, 0xff, 0xe8, 0xff, 0xe2,\n    0xff, 0xff, 0xf6, 0x0, 0x6f, 0xff, 0xff, 0xfd,\n    0xff, 0xff, 0x70, 0x0, 0x7, 0xff, 0xff, 0xf8,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0x80,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xd8, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+F077 \"\uf077\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x1, 0xdd, 0x10, 0x0, 0x0, 0x0, 0x0,\n    0x1d, 0xff, 0xd1, 0x0, 0x0, 0x0, 0x1, 0xdf,\n    0xff, 0xfd, 0x10, 0x0, 0x0, 0x1d, 0xff, 0x99,\n    0xff, 0xd1, 0x0, 0x1, 0xdf, 0xf9, 0x0, 0x9f,\n    0xfd, 0x10, 0x1d, 0xff, 0x90, 0x0, 0x9, 0xff,\n    0xd1, 0xbf, 0xf9, 0x0, 0x0, 0x0, 0x9f, 0xfb,\n    0x5f, 0x90, 0x0, 0x0, 0x0, 0x9, 0xf5, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+F078 \"\uf078\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f,\n    0x90, 0x0, 0x0, 0x0, 0x9, 0xf5, 0xbf, 0xf9,\n    0x0, 0x0, 0x0, 0x9f, 0xfb, 0x1d, 0xff, 0x90,\n    0x0, 0x9, 0xff, 0xd1, 0x1, 0xdf, 0xf9, 0x0,\n    0x9f, 0xfd, 0x10, 0x0, 0x1d, 0xff, 0x99, 0xff,\n    0xd1, 0x0, 0x0, 0x1, 0xdf, 0xff, 0xfd, 0x10,\n    0x0, 0x0, 0x0, 0x1d, 0xff, 0xd1, 0x0, 0x0,\n    0x0, 0x0, 0x1, 0xdd, 0x10, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+F079 \"\uf079\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x1d, 0xd1, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x1, 0xdf, 0xfd, 0x10,\n    0xef, 0xff, 0xff, 0xff, 0xd0, 0x0, 0x1d, 0xff,\n    0xff, 0xd1, 0xaf, 0xff, 0xff, 0xff, 0xf0, 0x0,\n    0xcf, 0xcf, 0xfc, 0xfc, 0x0, 0x0, 0x0, 0xf,\n    0xf0, 0x0, 0x6b, 0x1f, 0xf1, 0xb6, 0x0, 0x0,\n    0x0, 0xf, 0xf0, 0x0, 0x0, 0xf, 0xf0, 0x0,\n    0x0, 0x0, 0x0, 0xf, 0xf0, 0x0, 0x0, 0xf,\n    0xf0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xf0, 0x0,\n    0x0, 0xf, 0xf0, 0x0, 0x0, 0x0, 0x6b, 0x1f,\n    0xf1, 0xb6, 0x0, 0xf, 0xf0, 0x0, 0x0, 0x0,\n    0xcf, 0xcf, 0xfc, 0xfc, 0x0, 0xf, 0xff, 0xff,\n    0xff, 0xfa, 0x1d, 0xff, 0xff, 0xd1, 0x0, 0xd,\n    0xff, 0xff, 0xff, 0xfe, 0x1, 0xdf, 0xfd, 0x10,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1d,\n    0xd1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0,\n\n    /* U+F07B \"\uf07b\" */\n    0x8f, 0xff, 0xff, 0xe2, 0x0, 0x0, 0x0, 0x0,\n    0xff, 0xff, 0xff, 0xfe, 0x20, 0x0, 0x0, 0x0,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8,\n\n    /* U+F093 \"\uf093\" */\n    0x0, 0x0, 0x0, 0xb, 0xb0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xbf, 0xfb, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xb, 0xff, 0xff, 0xb0, 0x0, 0x0,\n    0x0, 0x0, 0xbf, 0xff, 0xff, 0xfb, 0x0, 0x0,\n    0x0, 0xb, 0xff, 0xff, 0xff, 0xff, 0xb0, 0x0,\n    0x0, 0x4f, 0xff, 0xff, 0xff, 0xff, 0xf4, 0x0,\n    0x0, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0,\n    0xdf, 0xff, 0xf0, 0xdf, 0xfd, 0xf, 0xff, 0xfd,\n    0xff, 0xff, 0xf9, 0x0, 0x0, 0x9f, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xe0, 0xff,\n    0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd,\n\n    /* U+F095 \"\uf095\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0xea,\n    0x62, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff,\n    0xff, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9f,\n    0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf,\n    0xff, 0xff, 0xd0, 0x0, 0x0, 0x0, 0x0, 0x2,\n    0xff, 0xff, 0xfb, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x3, 0xef, 0xff, 0x70, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x4, 0xff, 0xf2, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xbf, 0xfb, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x6f, 0xff, 0x30, 0x0, 0x0, 0x2,\n    0x0, 0x0, 0x4f, 0xff, 0x90, 0x0, 0x2, 0x8f,\n    0xf3, 0x0, 0x6f, 0xff, 0xd0, 0x0, 0xa, 0xff,\n    0xff, 0xe4, 0xbf, 0xff, 0xd1, 0x0, 0x0, 0xef,\n    0xff, 0xff, 0xff, 0xff, 0xd1, 0x0, 0x0, 0xa,\n    0xff, 0xff, 0xff, 0xff, 0x90, 0x0, 0x0, 0x0,\n    0x6f, 0xff, 0xff, 0xfb, 0x30, 0x0, 0x0, 0x0,\n    0x2, 0xff, 0xdb, 0x72, 0x0, 0x0, 0x0, 0x0,\n    0x0,\n\n    /* U+F0C4 \"\uf0c4\" */\n    0x8, 0xee, 0x80, 0x0, 0x0, 0x6, 0x61, 0x8,\n    0xff, 0xff, 0x80, 0x0, 0x2d, 0xff, 0xd0, 0xef,\n    0x33, 0xfe, 0x0, 0x2e, 0xff, 0xf3, 0xe, 0xf3,\n    0x3f, 0xe0, 0x2e, 0xff, 0xf3, 0x0, 0x8f, 0xff,\n    0xff, 0x6e, 0xff, 0xf3, 0x0, 0x0, 0x8e, 0xff,\n    0xff, 0xff, 0xf3, 0x0, 0x0, 0x0, 0x2, 0xef,\n    0xff, 0xf3, 0x0, 0x0, 0x0, 0x0, 0x2e, 0xff,\n    0xff, 0x30, 0x0, 0x0, 0x8, 0xef, 0xff, 0xff,\n    0xff, 0x30, 0x0, 0x8, 0xff, 0xff, 0xf6, 0xef,\n    0xff, 0x30, 0x0, 0xef, 0x33, 0xfe, 0x2, 0xef,\n    0xff, 0x30, 0xe, 0xf3, 0x3f, 0xe0, 0x2, 0xef,\n    0xff, 0x30, 0x8f, 0xff, 0xf8, 0x0, 0x2, 0xdf,\n    0xfd, 0x0, 0x8e, 0xe8, 0x0, 0x0, 0x0, 0x66,\n    0x10,\n\n    /* U+F0C5 \"\uf0c5\" */\n    0x0, 0x0, 0xdf, 0xff, 0xff, 0xd, 0x20, 0x0,\n    0x0, 0xff, 0xff, 0xff, 0xf, 0xe2, 0x0, 0x0,\n    0xff, 0xff, 0xff, 0xf, 0xfd, 0xdf, 0xf0, 0xff,\n    0xff, 0xff, 0x20, 0x0, 0xff, 0xf0, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xdf, 0xff,\n    0xff, 0xff, 0xfd, 0xff, 0xf9, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,\n    0x0, 0xdf, 0xff, 0xff, 0xff, 0xfd, 0x0, 0x0,\n\n    /* U+F0C7 \"\uf0c7\" */\n    0x8f, 0xff, 0xff, 0xff, 0xff, 0xc2, 0x0, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xfe, 0x20, 0xff, 0x0,\n    0x0, 0x0, 0x1, 0xff, 0xe2, 0xff, 0x0, 0x0,\n    0x0, 0x0, 0xff, 0xfc, 0xff, 0x0, 0x0, 0x0,\n    0x0, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xfb, 0x11, 0xbf, 0xff, 0xff, 0xff,\n    0xff, 0xf1, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff,\n    0xf1, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xfb,\n    0x11, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xf8,\n\n    /* U+F0C9 \"\uf0c9\" */\n    0x12, 0x22, 0x22, 0x22, 0x22, 0x22, 0x21, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0x12, 0x22, 0x22,\n    0x22, 0x22, 0x22, 0x21, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x12, 0x22, 0x22, 0x22, 0x22,\n    0x22, 0x21, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x12, 0x22, 0x22, 0x22, 0x22, 0x22, 0x21, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x12, 0x22,\n    0x22, 0x22, 0x22, 0x22, 0x21, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x12, 0x22, 0x22, 0x22, 0x22,\n    0x22, 0x21,\n\n    /* U+F0E0 \"\uf0e0\" */\n    0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,\n    0x9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x90,\n    0xd2, 0x5f, 0xff, 0xff, 0xff, 0xff, 0xf5, 0x2d,\n    0xff, 0x62, 0xcf, 0xff, 0xff, 0xfc, 0x26, 0xff,\n    0xff, 0xfa, 0x18, 0xff, 0xff, 0x81, 0xaf, 0xff,\n    0xff, 0xff, 0xe3, 0x4d, 0xd4, 0x3e, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x81, 0x18, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8,\n\n    /* U+F0E7 \"\uf0e7\" */\n    0x0, 0xdf, 0xff, 0xfd, 0x0, 0x0, 0x1, 0xff,\n    0xff, 0xfc, 0x0, 0x0, 0x3, 0xff, 0xff, 0xf7,\n    0x0, 0x0, 0x6, 0xff, 0xff, 0xf2, 0x0, 0x0,\n    0x8, 0xff, 0xff, 0xd0, 0x0, 0x0, 0xa, 0xff,\n    0xff, 0xff, 0xff, 0xd0, 0xc, 0xff, 0xff, 0xff,\n    0xff, 0xa0, 0xe, 0xff, 0xff, 0xff, 0xff, 0x20,\n    0xd, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0,\n    0xa, 0xff, 0xe0, 0x0, 0x0, 0x0, 0xe, 0xff,\n    0x50, 0x0, 0x0, 0x0, 0x2f, 0xfc, 0x0, 0x0,\n    0x0, 0x0, 0x5f, 0xf3, 0x0, 0x0, 0x0, 0x0,\n    0x9f, 0xa0, 0x0, 0x0, 0x0, 0x0, 0xdf, 0x10,\n    0x0, 0x0, 0x0, 0x0, 0xd7, 0x0, 0x0, 0x0,\n\n    /* U+F0EA \"\uf0ea\" */\n    0x0, 0x4, 0xee, 0x40, 0x0, 0x0, 0x0, 0xdf,\n    0xff, 0x99, 0xff, 0xfd, 0x0, 0x0, 0xff, 0xff,\n    0x99, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x90, 0x0,\n    0x0, 0x0, 0x0, 0xff, 0xff, 0xd, 0xff, 0xff,\n    0xd, 0x20, 0xff, 0xff, 0xf, 0xff, 0xff, 0xf,\n    0xe2, 0xff, 0xff, 0xf, 0xff, 0xff, 0xf, 0xfd,\n    0xff, 0xff, 0xf, 0xff, 0xff, 0x20, 0x0, 0xff,\n    0xff, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf,\n    0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0xf, 0xff,\n    0xff, 0xff, 0xff, 0x0, 0x0, 0xf, 0xff, 0xff,\n    0xff, 0xff, 0x0, 0x0, 0xf, 0xff, 0xff, 0xff,\n    0xff, 0x0, 0x0, 0xd, 0xff, 0xff, 0xff, 0xfd,\n\n    /* U+F0F3 \"\uf0f3\" */\n    0x0, 0x0, 0x0, 0xcc, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x2, 0xff, 0x30, 0x0, 0x0, 0x0, 0x1,\n    0xbf, 0xff, 0xfc, 0x20, 0x0, 0x0, 0x1e, 0xff,\n    0xff, 0xff, 0xe1, 0x0, 0x0, 0x9f, 0xff, 0xff,\n    0xff, 0xf8, 0x0, 0x0, 0xef, 0xff, 0xff, 0xff,\n    0xfd, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,\n    0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0x30, 0x8,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x1e, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xe1, 0xcf, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xfc, 0xcf, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xe, 0xff, 0xe0, 0x0,\n    0x0, 0x0, 0x0, 0x4, 0xee, 0x40, 0x0, 0x0,\n\n    /* U+F11C \"\uf11c\" */\n    0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x0, 0xf0, 0xf, 0x0, 0xf0,\n    0xf, 0x0, 0xff, 0xff, 0x0, 0xf0, 0xf, 0x0,\n    0xf0, 0xf, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x8,\n    0x80, 0x88, 0x8, 0x80, 0x8f, 0xff, 0xff, 0xf8,\n    0x8, 0x80, 0x88, 0x8, 0x80, 0x8f, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0x0, 0xf0, 0x0, 0x0, 0x0, 0xf, 0x0,\n    0xff, 0xff, 0x0, 0xf0, 0x0, 0x0, 0x0, 0xf,\n    0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xf8,\n\n    /* U+F124 \"\uf124\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3,\n    0xaf, 0x70, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4,\n    0xcf, 0xff, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x6,\n    0xdf, 0xff, 0xff, 0xa0, 0x0, 0x0, 0x0, 0x17,\n    0xef, 0xff, 0xff, 0xff, 0x30, 0x0, 0x0, 0x18,\n    0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x2a,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xf4, 0x0, 0x8,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd0, 0x0,\n    0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x60,\n    0x0, 0x8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff,\n    0xf7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff,\n    0xff, 0xf1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xff, 0xff, 0x10, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xff, 0xfa, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xff, 0xf2, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x8f, 0x80, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0,\n\n    /* U+F15B \"\uf15b\" */\n    0xdf, 0xff, 0xff, 0xf0, 0xd2, 0x0, 0xff, 0xff,\n    0xff, 0xf0, 0xfe, 0x20, 0xff, 0xff, 0xff, 0xf0,\n    0xff, 0xe2, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xfd,\n    0xff, 0xff, 0xff, 0xf2, 0x0, 0x0, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xfd,\n\n    /* U+F1EB \"\uf1eb\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x4, 0x9c, 0xef, 0xfe,\n    0xc9, 0x40, 0x0, 0x0, 0x0, 0x7, 0xef, 0xff,\n    0xff, 0xff, 0xff, 0xfe, 0x70, 0x0, 0x4, 0xdf,\n    0xff, 0xfc, 0xa8, 0x8a, 0xcf, 0xff, 0xfd, 0x40,\n    0x6f, 0xff, 0xd5, 0x0, 0x0, 0x0, 0x0, 0x5d,\n    0xff, 0xf6, 0xcf, 0xf6, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x6f, 0xfc, 0x1a, 0x30, 0x0, 0x5a,\n    0xdf, 0xfd, 0xa5, 0x0, 0x3, 0xa1, 0x0, 0x0,\n    0x4d, 0xff, 0xff, 0xff, 0xff, 0xd4, 0x0, 0x0,\n    0x0, 0x5, 0xff, 0xfe, 0xa8, 0x8a, 0xef, 0xff,\n    0x50, 0x0, 0x0, 0x1, 0xdf, 0x70, 0x0, 0x0,\n    0x7, 0xfd, 0x10, 0x0, 0x0, 0x0, 0x12, 0x0,\n    0x0, 0x0, 0x0, 0x21, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x4e, 0xe4, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xef, 0xfe, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xef, 0xfe,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x4e, 0xe4, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+F240 \"\uf240\" */\n    0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xf0, 0xff, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xf, 0xfd, 0xff, 0xf,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf, 0xff,\n    0xff, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x0, 0xff, 0xff, 0xf, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0x0, 0xff, 0xff, 0xf, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xf, 0xff, 0xff, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xfd,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xf0, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x80,\n\n    /* U+F241 \"\uf241\" */\n    0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xf0, 0xff, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xf, 0xfd, 0xff, 0xf,\n    0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0xf, 0xff,\n    0xff, 0xf, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0,\n    0x0, 0xff, 0xff, 0xf, 0xff, 0xff, 0xff, 0xff,\n    0xf0, 0x0, 0x0, 0xff, 0xff, 0xf, 0xff, 0xff,\n    0xff, 0xff, 0xf0, 0x0, 0xf, 0xff, 0xff, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xfd,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xf0, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x80,\n\n    /* U+F242 \"\uf242\" */\n    0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xf0, 0xff, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xf, 0xfd, 0xff, 0xf,\n    0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0xf, 0xff,\n    0xff, 0xf, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0,\n    0x0, 0xff, 0xff, 0xf, 0xff, 0xff, 0xff, 0x0,\n    0x0, 0x0, 0x0, 0xff, 0xff, 0xf, 0xff, 0xff,\n    0xff, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xfd,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xf0, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x80,\n\n    /* U+F243 \"\uf243\" */\n    0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xf0, 0xff, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xf, 0xfd, 0xff, 0xf,\n    0xff, 0xf0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff,\n    0xff, 0xf, 0xff, 0xf0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xff, 0xff, 0xf, 0xff, 0xf0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xff, 0xff, 0xf, 0xff, 0xf0,\n    0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xfd,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xf0, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x80,\n\n    /* U+F244 \"\uf244\" */\n    0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xf0, 0xff, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xf, 0xfd, 0xff, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff,\n    0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xfd,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xf0, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x80,\n\n    /* U+F287 \"\uf287\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7,\n    0xfd, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x1, 0xcf, 0xff, 0xf5, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xb9, 0x29, 0xfe, 0x10, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x10, 0x2,\n    0x0, 0x0, 0x0, 0x0, 0x3, 0xdf, 0x80, 0xa,\n    0x90, 0x0, 0x0, 0x0, 0x3, 0x70, 0x0, 0xdf,\n    0xff, 0x77, 0xf7, 0x55, 0x55, 0x55, 0x55, 0x8f,\n    0xd3, 0xf, 0xff, 0xfd, 0xcc, 0xdf, 0xdc, 0xcc,\n    0xcc, 0xcd, 0xff, 0xb0, 0x8f, 0xfe, 0x10, 0x0,\n    0xaa, 0x0, 0x0, 0x0, 0x4d, 0x40, 0x0, 0x46,\n    0x10, 0x0, 0x1, 0xf2, 0x2, 0x33, 0x10, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x9, 0xb1, 0xcf,\n    0xf9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0xa, 0xff, 0xff, 0x90, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xbf, 0xf9, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x22,\n    0x0, 0x0, 0x0,\n\n    /* U+F293 \"\uf293\" */\n    0x0, 0x18, 0xdf, 0xfd, 0x92, 0x0, 0x2, 0xef,\n    0xfb, 0xef, 0xff, 0x30, 0xd, 0xff, 0xfa, 0x2e,\n    0xff, 0xe0, 0x4f, 0xff, 0xfa, 0x3, 0xff, 0xf5,\n    0x9f, 0xfa, 0xfa, 0x35, 0x4f, 0xfa, 0xcf, 0xc0,\n    0x8a, 0x3d, 0xb, 0xfd, 0xef, 0xfb, 0x3, 0x12,\n    0x8f, 0xfe, 0xff, 0xff, 0xb0, 0x6, 0xff, 0xff,\n    0xff, 0xff, 0xd1, 0x8, 0xff, 0xff, 0xef, 0xfd,\n    0x11, 0x10, 0x9f, 0xff, 0xdf, 0xd1, 0x59, 0x3b,\n    0xb, 0xfd, 0xaf, 0xd7, 0xfa, 0x38, 0x1d, 0xfb,\n    0x5f, 0xff, 0xfa, 0x1, 0xdf, 0xf7, 0xd, 0xff,\n    0xfa, 0x1d, 0xff, 0xf1, 0x3, 0xef, 0xfc, 0xdf,\n    0xff, 0x50, 0x0, 0x18, 0xdf, 0xfe, 0xa3, 0x0,\n\n    /* U+F2ED \"\uf2ed\" */\n    0x0, 0x0, 0x7f, 0xff, 0xf7, 0x0, 0x0, 0xef,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xef, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xf0, 0xf, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xf0, 0xf, 0xf9, 0x9f, 0x99, 0xf9, 0x9f,\n    0xf0, 0xf, 0xf8, 0x8f, 0x88, 0xf8, 0x8f, 0xf0,\n    0xf, 0xf8, 0x8f, 0x88, 0xf8, 0x8f, 0xf0, 0xf,\n    0xf8, 0x8f, 0x88, 0xf8, 0x8f, 0xf0, 0xf, 0xf8,\n    0x8f, 0x88, 0xf8, 0x8f, 0xf0, 0xf, 0xf8, 0x8f,\n    0x88, 0xf8, 0x8f, 0xf0, 0xf, 0xf8, 0x8f, 0x88,\n    0xf8, 0x8f, 0xf0, 0xf, 0xf9, 0x9f, 0x99, 0xf9,\n    0x9f, 0xf0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xf0, 0x8, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,\n\n    /* U+F304 \"\uf304\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xa0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8f, 0xff,\n    0xb0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xd, 0xff,\n    0xff, 0xa0, 0x0, 0x0, 0x0, 0x0, 0x8a, 0x1d,\n    0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x8f, 0xfa,\n    0x1d, 0xff, 0x70, 0x0, 0x0, 0x0, 0x8f, 0xff,\n    0xfa, 0x1d, 0x80, 0x0, 0x0, 0x0, 0x8f, 0xff,\n    0xff, 0xfa, 0x0, 0x0, 0x0, 0x0, 0x8f, 0xff,\n    0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x8f, 0xff,\n    0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x8f, 0xff,\n    0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x8f, 0xff,\n    0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x6f, 0xff,\n    0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0xb, 0xff,\n    0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0xdf,\n    0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0xe,\n    0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0xde, 0xdb, 0x60, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0,\n\n    /* U+F55A \"\uf55a\" */\n    0x0, 0x0, 0x1b, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xe4, 0x0, 0x1, 0xdf, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xfe, 0x0, 0x1d, 0xff, 0xff,\n    0xfa, 0xef, 0xfe, 0xaf, 0xff, 0xff, 0x1, 0xdf,\n    0xff, 0xff, 0xa0, 0x2e, 0xe2, 0xa, 0xff, 0xff,\n    0x1d, 0xff, 0xff, 0xff, 0xe2, 0x2, 0x20, 0x2e,\n    0xff, 0xff, 0xcf, 0xff, 0xff, 0xff, 0xfe, 0x20,\n    0x2, 0xef, 0xff, 0xff, 0xcf, 0xff, 0xff, 0xff,\n    0xfe, 0x20, 0x2, 0xef, 0xff, 0xff, 0x1d, 0xff,\n    0xff, 0xff, 0xe2, 0x2, 0x20, 0x2e, 0xff, 0xff,\n    0x1, 0xdf, 0xff, 0xff, 0xa0, 0x2e, 0xe2, 0xa,\n    0xff, 0xff, 0x0, 0x1d, 0xff, 0xff, 0xfa, 0xef,\n    0xfe, 0xaf, 0xff, 0xff, 0x0, 0x1, 0xdf, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0,\n    0x1b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe4,\n\n    /* U+F7C2 \"\uf7c2\" */\n    0x0, 0x8, 0xff, 0xff, 0xff, 0xe4, 0x0, 0x8f,\n    0xff, 0xff, 0xff, 0xfe, 0x8, 0xf8, 0xf, 0xb,\n    0x40, 0xff, 0x8f, 0xf8, 0xf, 0xb, 0x40, 0xff,\n    0xff, 0xf8, 0xf, 0xb, 0x40, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xef, 0xff, 0xff, 0xff,\n    0xff, 0xfe, 0x4e, 0xff, 0xff, 0xff, 0xff, 0xe4,\n\n    /* U+F8A2 \"\uf8a2\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3,\n    0xe0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x2,\n    0xef, 0x10, 0x0, 0xbf, 0x0, 0x0, 0x0, 0x0,\n    0x7f, 0xf1, 0x0, 0xcf, 0xf1, 0x0, 0x0, 0x0,\n    0x7, 0xff, 0x11, 0xcf, 0xff, 0x77, 0x77, 0x77,\n    0x77, 0xbf, 0xf1, 0xcf, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x17, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xe0, 0x7, 0xff, 0xf1, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0xff, 0x10,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5, 0xa0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0\n}", "sline": 24}, "glyph_dsc": {"type": "Variable", "def": "static const lv_font_fmt_txt_glyph_dsc_t glyph_dsc[] = {\n    {.bitmap_index = 0, .adv_w = 0, .box_w = 0, .box_h = 0, .ofs_x = 0, .ofs_y = 0} /* id = 0 reserved */,\n    {.bitmap_index = 0, .adv_w = 69, .box_w = 0, .box_h = 0, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 0, .adv_w = 69, .box_w = 3, .box_h = 12, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 18, .adv_w = 100, .box_w = 5, .box_h = 5, .ofs_x = 1, .ofs_y = 7},\n    {.bitmap_index = 31, .adv_w = 180, .box_w = 11, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 97, .adv_w = 159, .box_w = 10, .box_h = 16, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 177, .adv_w = 216, .box_w = 13, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 255, .adv_w = 176, .box_w = 11, .box_h = 13, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 327, .adv_w = 54, .box_w = 2, .box_h = 5, .ofs_x = 1, .ofs_y = 7},\n    {.bitmap_index = 332, .adv_w = 86, .box_w = 4, .box_h = 15, .ofs_x = 1, .ofs_y = -3},\n    {.bitmap_index = 362, .adv_w = 87, .box_w = 4, .box_h = 15, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 392, .adv_w = 102, .box_w = 7, .box_h = 7, .ofs_x = 0, .ofs_y = 5},\n    {.bitmap_index = 417, .adv_w = 149, .box_w = 8, .box_h = 8, .ofs_x = 1, .ofs_y = 2},\n    {.bitmap_index = 449, .adv_w = 58, .box_w = 3, .box_h = 5, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 457, .adv_w = 98, .box_w = 6, .box_h = 3, .ofs_x = 0, .ofs_y = 3},\n    {.bitmap_index = 466, .adv_w = 58, .box_w = 3, .box_h = 3, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 471, .adv_w = 90, .box_w = 8, .box_h = 16, .ofs_x = -1, .ofs_y = -2},\n    {.bitmap_index = 535, .adv_w = 171, .box_w = 10, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 595, .adv_w = 95, .box_w = 5, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 625, .adv_w = 147, .box_w = 9, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 679, .adv_w = 146, .box_w = 9, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 733, .adv_w = 171, .box_w = 11, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 799, .adv_w = 147, .box_w = 9, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 853, .adv_w = 158, .box_w = 10, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 913, .adv_w = 153, .box_w = 9, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 967, .adv_w = 165, .box_w = 10, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 1027, .adv_w = 158, .box_w = 10, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 1087, .adv_w = 58, .box_w = 3, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 1101, .adv_w = 58, .box_w = 3, .box_h = 12, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 1119, .adv_w = 149, .box_w = 8, .box_h = 8, .ofs_x = 1, .ofs_y = 2},\n    {.bitmap_index = 1151, .adv_w = 149, .box_w = 8, .box_h = 6, .ofs_x = 1, .ofs_y = 3},\n    {.bitmap_index = 1175, .adv_w = 149, .box_w = 8, .box_h = 8, .ofs_x = 1, .ofs_y = 2},\n    {.bitmap_index = 1207, .adv_w = 147, .box_w = 9, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 1261, .adv_w = 265, .box_w = 16, .box_h = 15, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 1381, .adv_w = 187, .box_w = 13, .box_h = 12, .ofs_x = -1, .ofs_y = 0},\n    {.bitmap_index = 1459, .adv_w = 194, .box_w = 11, .box_h = 12, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1525, .adv_w = 185, .box_w = 11, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 1591, .adv_w = 211, .box_w = 12, .box_h = 12, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1663, .adv_w = 172, .box_w = 9, .box_h = 12, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1717, .adv_w = 163, .box_w = 9, .box_h = 12, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1771, .adv_w = 198, .box_w = 12, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 1843, .adv_w = 208, .box_w = 11, .box_h = 12, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1909, .adv_w = 79, .box_w = 3, .box_h = 12, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1927, .adv_w = 131, .box_w = 8, .box_h = 12, .ofs_x = -1, .ofs_y = 0},\n    {.bitmap_index = 1975, .adv_w = 184, .box_w = 11, .box_h = 12, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2041, .adv_w = 152, .box_w = 9, .box_h = 12, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2095, .adv_w = 244, .box_w = 13, .box_h = 12, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2173, .adv_w = 208, .box_w = 11, .box_h = 12, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2239, .adv_w = 215, .box_w = 13, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2317, .adv_w = 185, .box_w = 10, .box_h = 12, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2377, .adv_w = 215, .box_w = 14, .box_h = 15, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 2482, .adv_w = 186, .box_w = 10, .box_h = 12, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2542, .adv_w = 159, .box_w = 10, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2602, .adv_w = 150, .box_w = 10, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2662, .adv_w = 202, .box_w = 11, .box_h = 12, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2728, .adv_w = 182, .box_w = 13, .box_h = 12, .ofs_x = -1, .ofs_y = 0},\n    {.bitmap_index = 2806, .adv_w = 288, .box_w = 18, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2914, .adv_w = 172, .box_w = 11, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2980, .adv_w = 166, .box_w = 12, .box_h = 12, .ofs_x = -1, .ofs_y = 0},\n    {.bitmap_index = 3052, .adv_w = 168, .box_w = 11, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 3118, .adv_w = 85, .box_w = 5, .box_h = 15, .ofs_x = 1, .ofs_y = -3},\n    {.bitmap_index = 3156, .adv_w = 90, .box_w = 8, .box_h = 16, .ofs_x = -1, .ofs_y = -2},\n    {.bitmap_index = 3220, .adv_w = 85, .box_w = 4, .box_h = 15, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 3250, .adv_w = 149, .box_w = 8, .box_h = 7, .ofs_x = 1, .ofs_y = 2},\n    {.bitmap_index = 3278, .adv_w = 128, .box_w = 8, .box_h = 2, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 3286, .adv_w = 154, .box_w = 5, .box_h = 2, .ofs_x = 1, .ofs_y = 10},\n    {.bitmap_index = 3291, .adv_w = 153, .box_w = 9, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 3332, .adv_w = 175, .box_w = 10, .box_h = 12, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 3392, .adv_w = 146, .box_w = 9, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 3433, .adv_w = 175, .box_w = 10, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 3493, .adv_w = 157, .box_w = 10, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 3538, .adv_w = 90, .box_w = 7, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 3580, .adv_w = 177, .box_w = 10, .box_h = 12, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 3640, .adv_w = 174, .box_w = 9, .box_h = 12, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 3694, .adv_w = 71, .box_w = 3, .box_h = 12, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 3712, .adv_w = 73, .box_w = 6, .box_h = 15, .ofs_x = -2, .ofs_y = -3},\n    {.bitmap_index = 3757, .adv_w = 158, .box_w = 9, .box_h = 12, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 3811, .adv_w = 71, .box_w = 2, .box_h = 12, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 3823, .adv_w = 271, .box_w = 15, .box_h = 9, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 3891, .adv_w = 174, .box_w = 9, .box_h = 9, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 3932, .adv_w = 163, .box_w = 10, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 3977, .adv_w = 175, .box_w = 10, .box_h = 12, .ofs_x = 1, .ofs_y = -3},\n    {.bitmap_index = 4037, .adv_w = 175, .box_w = 10, .box_h = 12, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 4097, .adv_w = 105, .box_w = 6, .box_h = 9, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 4124, .adv_w = 128, .box_w = 8, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 4160, .adv_w = 106, .box_w = 7, .box_h = 11, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 4199, .adv_w = 173, .box_w = 9, .box_h = 9, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 4240, .adv_w = 143, .box_w = 10, .box_h = 9, .ofs_x = -1, .ofs_y = 0},\n    {.bitmap_index = 4285, .adv_w = 230, .box_w = 15, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 4353, .adv_w = 141, .box_w = 9, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 4394, .adv_w = 143, .box_w = 10, .box_h = 12, .ofs_x = -1, .ofs_y = -3},\n    {.bitmap_index = 4454, .adv_w = 133, .box_w = 8, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 4490, .adv_w = 90, .box_w = 6, .box_h = 15, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 4535, .adv_w = 77, .box_w = 3, .box_h = 15, .ofs_x = 1, .ofs_y = -3},\n    {.bitmap_index = 4558, .adv_w = 90, .box_w = 5, .box_h = 15, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 4596, .adv_w = 149, .box_w = 9, .box_h = 5, .ofs_x = 0, .ofs_y = 4},\n    {.bitmap_index = 4619, .adv_w = 107, .box_w = 6, .box_h = 6, .ofs_x = 0, .ofs_y = 6},\n    {.bitmap_index = 4637, .adv_w = 80, .box_w = 3, .box_h = 4, .ofs_x = 1, .ofs_y = 3},\n    {.bitmap_index = 4643, .adv_w = 256, .box_w = 16, .box_h = 17, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 4779, .adv_w = 256, .box_w = 16, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 4875, .adv_w = 256, .box_w = 16, .box_h = 14, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 4987, .adv_w = 256, .box_w = 16, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 5083, .adv_w = 176, .box_w = 11, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 5149, .adv_w = 256, .box_w = 16, .box_h = 16, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 5277, .adv_w = 256, .box_w = 16, .box_h = 16, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 5405, .adv_w = 288, .box_w = 18, .box_h = 14, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 5531, .adv_w = 256, .box_w = 16, .box_h = 16, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 5659, .adv_w = 288, .box_w = 18, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 5767, .adv_w = 256, .box_w = 16, .box_h = 16, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 5895, .adv_w = 128, .box_w = 8, .box_h = 14, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 5951, .adv_w = 192, .box_w = 12, .box_h = 14, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 6035, .adv_w = 288, .box_w = 18, .box_h = 16, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 6179, .adv_w = 256, .box_w = 16, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 6275, .adv_w = 176, .box_w = 11, .box_h = 16, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 6363, .adv_w = 224, .box_w = 10, .box_h = 16, .ofs_x = 2, .ofs_y = -2},\n    {.bitmap_index = 6443, .adv_w = 224, .box_w = 14, .box_h = 18, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 6569, .adv_w = 224, .box_w = 14, .box_h = 15, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 6674, .adv_w = 224, .box_w = 14, .box_h = 14, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 6772, .adv_w = 224, .box_w = 10, .box_h = 16, .ofs_x = 2, .ofs_y = -2},\n    {.bitmap_index = 6852, .adv_w = 224, .box_w = 16, .box_h = 14, .ofs_x = -1, .ofs_y = -1},\n    {.bitmap_index = 6964, .adv_w = 160, .box_w = 10, .box_h = 14, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 7034, .adv_w = 160, .box_w = 10, .box_h = 14, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 7104, .adv_w = 224, .box_w = 14, .box_h = 14, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 7202, .adv_w = 224, .box_w = 14, .box_h = 4, .ofs_x = 0, .ofs_y = 4},\n    {.bitmap_index = 7230, .adv_w = 288, .box_w = 18, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 7338, .adv_w = 320, .box_w = 20, .box_h = 16, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 7498, .adv_w = 288, .box_w = 20, .box_h = 16, .ofs_x = -1, .ofs_y = -2},\n    {.bitmap_index = 7658, .adv_w = 256, .box_w = 16, .box_h = 16, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 7786, .adv_w = 224, .box_w = 14, .box_h = 10, .ofs_x = 0, .ofs_y = 1},\n    {.bitmap_index = 7856, .adv_w = 224, .box_w = 14, .box_h = 10, .ofs_x = 0, .ofs_y = 1},\n    {.bitmap_index = 7926, .adv_w = 320, .box_w = 20, .box_h = 14, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 8066, .adv_w = 256, .box_w = 16, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 8162, .adv_w = 256, .box_w = 16, .box_h = 16, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 8290, .adv_w = 256, .box_w = 17, .box_h = 17, .ofs_x = -1, .ofs_y = -2},\n    {.bitmap_index = 8435, .adv_w = 224, .box_w = 15, .box_h = 14, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 8540, .adv_w = 224, .box_w = 14, .box_h = 16, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 8652, .adv_w = 224, .box_w = 14, .box_h = 14, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 8750, .adv_w = 224, .box_w = 14, .box_h = 14, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 8848, .adv_w = 256, .box_w = 16, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 8944, .adv_w = 160, .box_w = 12, .box_h = 16, .ofs_x = -1, .ofs_y = -2},\n    {.bitmap_index = 9040, .adv_w = 224, .box_w = 14, .box_h = 16, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 9152, .adv_w = 224, .box_w = 14, .box_h = 16, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 9264, .adv_w = 288, .box_w = 18, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 9372, .adv_w = 256, .box_w = 18, .box_h = 18, .ofs_x = -1, .ofs_y = -3},\n    {.bitmap_index = 9534, .adv_w = 192, .box_w = 12, .box_h = 16, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 9630, .adv_w = 320, .box_w = 20, .box_h = 15, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 9780, .adv_w = 320, .box_w = 20, .box_h = 10, .ofs_x = 0, .ofs_y = 1},\n    {.bitmap_index = 9880, .adv_w = 320, .box_w = 20, .box_h = 10, .ofs_x = 0, .ofs_y = 1},\n    {.bitmap_index = 9980, .adv_w = 320, .box_w = 20, .box_h = 10, .ofs_x = 0, .ofs_y = 1},\n    {.bitmap_index = 10080, .adv_w = 320, .box_w = 20, .box_h = 10, .ofs_x = 0, .ofs_y = 1},\n    {.bitmap_index = 10180, .adv_w = 320, .box_w = 20, .box_h = 10, .ofs_x = 0, .ofs_y = 1},\n    {.bitmap_index = 10280, .adv_w = 320, .box_w = 21, .box_h = 14, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 10427, .adv_w = 224, .box_w = 12, .box_h = 16, .ofs_x = 1, .ofs_y = -2},\n    {.bitmap_index = 10523, .adv_w = 224, .box_w = 14, .box_h = 16, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 10635, .adv_w = 256, .box_w = 17, .box_h = 17, .ofs_x = -1, .ofs_y = -3},\n    {.bitmap_index = 10780, .adv_w = 320, .box_w = 20, .box_h = 12, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 10900, .adv_w = 192, .box_w = 12, .box_h = 16, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 10996, .adv_w = 258, .box_w = 17, .box_h = 11, .ofs_x = 0, .ofs_y = 1}\n}", "sline": 1787}, "unicode_list_1": {"type": "Variable", "def": "static const uint16_t unicode_list_1[] = {\n    0x0, 0x1f72, 0xef51, 0xef58, 0xef5b, 0xef5c, 0xef5d, 0xef61,\n    0xef63, 0xef65, 0xef69, 0xef6c, 0xef71, 0xef76, 0xef77, 0xef78,\n    0xef8e, 0xef93, 0xef98, 0xef9b, 0xef9c, 0xef9d, 0xefa1, 0xefa2,\n    0xefa3, 0xefa4, 0xefb7, 0xefb8, 0xefbe, 0xefc0, 0xefc1, 0xefc4,\n    0xefc7, 0xefc8, 0xefc9, 0xefcb, 0xefe3, 0xefe5, 0xf014, 0xf015,\n    0xf017, 0xf019, 0xf030, 0xf037, 0xf03a, 0xf043, 0xf06c, 0xf074,\n    0xf0ab, 0xf13b, 0xf190, 0xf191, 0xf192, 0xf193, 0xf194, 0xf1d7,\n    0xf1e3, 0xf23d, 0xf254, 0xf4aa, 0xf712, 0xf7f2\n}", "sline": 1952}, "cmaps": {"type": "Variable", "def": "static const lv_font_fmt_txt_cmap_t cmaps[]", "sline": 1964}, "kern_left_class_mapping": {"type": "Variable", "def": "static const uint8_t kern_left_class_mapping[] =\n{\n    0, 0, 1, 2, 0, 3, 4, 5,\n    2, 6, 7, 8, 9, 10, 9, 10,\n    11, 12, 0, 13, 14, 15, 16, 17,\n    18, 19, 12, 20, 20, 0, 0, 0,\n    21, 22, 23, 24, 25, 22, 26, 27,\n    28, 29, 29, 30, 31, 32, 29, 29,\n    22, 33, 34, 35, 3, 36, 30, 37,\n    37, 38, 39, 40, 41, 42, 43, 0,\n    44, 0, 45, 46, 47, 48, 49, 50,\n    51, 45, 52, 52, 53, 48, 45, 45,\n    46, 46, 54, 55, 56, 57, 51, 58,\n    58, 59, 58, 60, 41, 0, 0, 9,\n    61, 9, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0\n}", "sline": 1982}, "kern_right_class_mapping": {"type": "Variable", "def": "static const uint8_t kern_right_class_mapping[] =\n{\n    0, 0, 1, 2, 0, 3, 4, 5,\n    2, 6, 7, 8, 9, 10, 9, 10,\n    11, 12, 13, 14, 15, 16, 17, 12,\n    18, 19, 20, 21, 21, 0, 0, 0,\n    22, 23, 24, 25, 23, 25, 25, 25,\n    23, 25, 25, 26, 25, 25, 25, 25,\n    23, 25, 23, 25, 3, 27, 28, 29,\n    29, 30, 31, 32, 33, 34, 35, 0,\n    36, 0, 37, 38, 39, 39, 39, 0,\n    39, 38, 40, 41, 38, 38, 42, 42,\n    39, 42, 39, 42, 43, 44, 45, 46,\n    46, 47, 46, 48, 0, 0, 35, 9,\n    49, 9, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0\n}", "sline": 2007}, "kern_class_values": {"type": "Variable", "def": "static const int8_t kern_class_values[] =\n{\n    0, 1, 0, 0, 0, 0, 0, 0,\n    0, 1, 0, 0, 3, 0, 0, 0,\n    0, 2, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 1, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 1, 12, 0, 7, -6, 0, 0,\n    0, 0, -14, -15, 2, 12, 6, 4,\n    -10, 2, 13, 1, 11, 3, 8, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 15, 2, -2, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 5, 0, -8, 0, 0, 0, 0,\n    0, -5, 4, 5, 0, 0, -3, 0,\n    -2, 3, 0, -3, 0, -3, -1, -5,\n    0, 0, 0, 0, -3, 0, 0, -3,\n    -4, 0, 0, -3, 0, -5, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, -3,\n    -3, 0, -4, 0, -7, 0, -31, 0,\n    0, -5, 0, 5, 8, 0, 0, -5,\n    3, 3, 8, 5, -4, 5, 0, 0,\n    -15, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -9, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, -7, -3, -13, 0, -10,\n    -2, 0, 0, 0, 0, 1, 10, 0,\n    -8, -2, -1, 1, 0, -4, 0, 0,\n    -2, -19, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -20, -2, 10,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -10, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 8,\n    0, 3, 0, 0, -5, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 10, 2,\n    1, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    -9, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 2,\n    5, 3, 8, -3, 0, 0, 5, -3,\n    -8, -35, 2, 7, 5, 1, -3, 0,\n    9, 0, 8, 0, 8, 0, -24, 0,\n    -3, 8, 0, 8, -3, 5, 3, 0,\n    0, 1, -3, 0, 0, -4, 20, 0,\n    20, 0, 8, 0, 11, 3, 4, 8,\n    0, 0, 0, -9, 0, 0, 0, 0,\n    1, -2, 0, 2, -5, -3, -5, 2,\n    0, -3, 0, 0, 0, -10, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, -17, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 1, -14, 0, -16, 0, 0, 0,\n    0, -2, 0, 25, -3, -3, 3, 3,\n    -2, 0, -3, 3, 0, 0, -14, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, -25, 0, 3, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, -16, 0, 15, 0, 0, -9, 0,\n    8, 0, -17, -25, -17, -5, 8, 0,\n    0, -17, 0, 3, -6, 0, -4, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 7, 8, -31, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 12, 0, 2, 0, 0, 0,\n    0, 0, 2, 2, -3, -5, 0, -1,\n    -1, -3, 0, 0, -2, 0, 0, 0,\n    -5, 0, -2, 0, -6, -5, 0, -6,\n    -8, -8, -5, 0, -5, 0, -5, 0,\n    0, 0, 0, -2, 0, 0, 3, 0,\n    2, -3, 0, 1, 0, 0, 0, 3,\n    -2, 0, 0, 0, -2, 3, 3, -1,\n    0, 0, 0, -5, 0, -1, 0, 0,\n    0, 0, 0, 1, 0, 3, -2, 0,\n    -3, 0, -4, 0, 0, -2, 0, 8,\n    0, 0, -3, 0, 0, 0, 0, 0,\n    -1, 1, -2, -2, 0, 0, -3, 0,\n    -3, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, -1, -1, 0, -3, -3, 0,\n    0, 0, 0, 0, 1, 0, 0, -2,\n    0, -3, -3, -3, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -2, 0, 0,\n    0, 0, -2, -3, 0, -4, 0, -8,\n    -2, -8, 5, 0, 0, -5, 3, 5,\n    7, 0, -6, -1, -3, 0, -1, -12,\n    3, -2, 2, -14, 3, 0, 0, 1,\n    -13, 0, -14, -2, -22, -2, 0, -13,\n    0, 5, 7, 0, 3, 0, 0, 0,\n    0, 1, 0, -5, -3, 0, -8, 0,\n    0, 0, -3, 0, 0, 0, -3, 0,\n    0, 0, 0, 0, -1, -1, 0, -1,\n    -3, 0, 0, 0, 0, 0, 0, 0,\n    -3, -3, 0, -2, -3, -2, 0, 0,\n    -3, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -2, -2, 0, -3,\n    0, -2, 0, -5, 3, 0, 0, -3,\n    1, 3, 3, 0, 0, 0, 0, 0,\n    0, -2, 0, 0, 0, 0, 0, 2,\n    0, 0, -3, 0, -3, -2, -3, 0,\n    0, 0, 0, 0, 0, 0, 2, 0,\n    -2, 0, 0, 0, 0, -3, -4, 0,\n    -5, 0, 8, -2, 1, -8, 0, 0,\n    7, -13, -13, -11, -5, 3, 0, -2,\n    -17, -5, 0, -5, 0, -5, 4, -5,\n    -16, 0, -7, 0, 0, 1, -1, 2,\n    -2, 0, 3, 0, -8, -10, 0, -13,\n    -6, -5, -6, -8, -3, -7, -1, -5,\n    -7, 2, 0, 1, 0, -3, 0, 0,\n    0, 2, 0, 3, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, -3,\n    0, -1, 0, -1, -3, 0, -4, -6,\n    -6, -1, 0, -8, 0, 0, 0, 0,\n    0, 0, -2, 0, 0, 0, 0, 1,\n    -2, 0, 0, 0, 3, 0, 0, 0,\n    0, 0, 0, 0, 0, 12, 0, 0,\n    0, 0, 0, 0, 2, 0, 0, 0,\n    -3, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -5, 0, 3, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -2, 0, 0, 0,\n    -5, 0, 0, 0, 0, -13, -8, 0,\n    0, 0, -4, -13, 0, 0, -3, 3,\n    0, -7, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -4, 0, 0, -5,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 3, 0, -5, 0,\n    0, 0, 0, 3, 0, 2, -5, -5,\n    0, -3, -3, -3, 0, 0, 0, 0,\n    0, 0, -8, 0, -3, 0, -4, -3,\n    0, -6, -6, -8, -2, 0, -5, 0,\n    -8, 0, 0, 0, 0, 20, 0, 0,\n    1, 0, 0, -3, 0, 3, 0, -11,\n    0, 0, 0, 0, 0, -24, -5, 8,\n    8, -2, -11, 0, 3, -4, 0, -13,\n    -1, -3, 3, -18, -3, 3, 0, 4,\n    -9, -4, -9, -8, -11, 0, 0, -15,\n    0, 15, 0, 0, -1, 0, 0, 0,\n    -1, -1, -3, -7, -8, -1, -24, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    1, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, -3, 0, -1, -3, -4, 0, 0,\n    -5, 0, -3, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, -1, 0, -5, 0, 0, 5,\n    -1, 3, 0, -6, 3, -2, -1, -7,\n    -3, 0, -3, -3, -2, 0, -4, -4,\n    0, 0, -2, -1, -2, -4, -3, 0,\n    0, -3, 0, 3, -2, 0, -6, 0,\n    0, 0, -5, 0, -4, 0, -4, -4,\n    3, 0, 0, 0, 0, 0, 0, 0,\n    0, -5, 3, 0, -4, 0, -2, -3,\n    -8, -2, -2, -2, -1, -2, -3, -1,\n    0, 0, 0, 0, 0, -3, -2, -2,\n    0, 0, 0, 0, 3, -2, 0, -2,\n    0, 0, 0, -2, -3, -2, -2, -3,\n    -2, 0, 2, 10, -1, 0, -7, 0,\n    -2, 5, 0, -3, -11, -3, 4, 0,\n    0, -12, -4, 3, -4, 2, 0, -2,\n    -2, -8, 0, -4, 1, 0, 0, -4,\n    0, 0, 0, 3, 3, -5, -5, 0,\n    -4, -3, -4, -3, -3, 0, -4, 1,\n    -5, -4, 8, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 3, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -4, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    -2, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, -2, -3,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -4, 0, 0, -3,\n    0, 0, -3, -3, 0, 0, 0, 0,\n    -3, 0, 0, 0, 0, -1, 0, 0,\n    0, 0, 0, -2, 0, 0, 0, 0,\n    -4, 0, -5, 0, 0, 0, -8, 0,\n    2, -6, 5, 1, -2, -12, 0, 0,\n    -6, -3, 0, -10, -6, -7, 0, 0,\n    -11, -3, -10, -10, -12, 0, -7, 0,\n    2, 17, -3, 0, -6, -3, -1, -3,\n    -4, -7, -5, -9, -10, -6, -3, 0,\n    0, -2, 0, 1, 0, 0, -18, -2,\n    8, 6, -6, -9, 0, 1, -8, 0,\n    -13, -2, -3, 5, -24, -3, 1, 0,\n    0, -17, -3, -13, -3, -19, 0, 0,\n    -18, 0, 15, 1, 0, -2, 0, 0,\n    0, 0, -1, -2, -10, -2, 0, -17,\n    0, 0, 0, 0, -8, 0, -2, 0,\n    -1, -7, -12, 0, 0, -1, -4, -8,\n    -3, 0, -2, 0, 0, 0, 0, -12,\n    -3, -8, -8, -2, -4, -6, -3, -4,\n    0, -5, -2, -8, -4, 0, -3, -5,\n    -3, -5, 0, 1, 0, -2, -8, 0,\n    5, 0, -5, 0, 0, 0, 0, 3,\n    0, 2, -5, 10, 0, -3, -3, -3,\n    0, 0, 0, 0, 0, 0, -8, 0,\n    -3, 0, -4, -3, 0, -6, -6, -8,\n    -2, 0, -5, 2, 10, 0, 0, 0,\n    0, 20, 0, 0, 1, 0, 0, -3,\n    0, 3, 0, 0, 0, 0, 0, 0,\n    0, 0, -1, 0, 0, 0, 0, 0,\n    -2, -5, 0, 0, 0, 0, 0, -1,\n    0, 0, 0, -3, -3, 0, 0, -5,\n    -3, 0, 0, -5, 0, 4, -1, 0,\n    0, 0, 0, 0, 0, 1, 0, 0,\n    0, 0, 4, 5, 2, -2, 0, -8,\n    -4, 0, 8, -8, -8, -5, -5, 10,\n    5, 3, -22, -2, 5, -3, 0, -3,\n    3, -3, -9, 0, -3, 3, -3, -2,\n    -8, -2, 0, 0, 8, 5, 0, -7,\n    0, -14, -3, 7, -3, -10, 1, -3,\n    -8, -8, -3, 10, 3, 0, -4, 0,\n    -7, 0, 2, 8, -6, -9, -10, -6,\n    8, 0, 1, -19, -2, 3, -4, -2,\n    -6, 0, -6, -9, -4, -4, -2, 0,\n    0, -6, -5, -3, 0, 8, 6, -3,\n    -14, 0, -14, -4, 0, -9, -15, -1,\n    -8, -4, -8, -7, 7, 0, 0, -3,\n    0, -5, -2, 0, -3, -5, 0, 4,\n    -8, 3, 0, 0, -14, 0, -3, -6,\n    -4, -2, -8, -6, -8, -6, 0, -8,\n    -3, -6, -5, -8, -3, 0, 0, 1,\n    12, -4, 0, -8, -3, 0, -3, -5,\n    -6, -7, -7, -10, -3, -5, 5, 0,\n    -4, 0, -13, -3, 2, 5, -8, -9,\n    -5, -8, 8, -3, 1, -24, -5, 5,\n    -6, -4, -9, 0, -8, -11, -3, -3,\n    -2, -3, -5, -8, -1, 0, 0, 8,\n    7, -2, -17, 0, -15, -6, 6, -10,\n    -17, -5, -9, -11, -13, -8, 5, 0,\n    0, 0, 0, -3, 0, 0, 3, -3,\n    5, 2, -5, 5, 0, 0, -8, -1,\n    0, -1, 0, 1, 1, -2, 0, 0,\n    0, 0, 0, 0, -3, 0, 0, 0,\n    0, 2, 8, 1, 0, -3, 0, 0,\n    0, 0, -2, -2, -3, 0, 0, 0,\n    1, 2, 0, 0, 0, 0, 2, 0,\n    -2, 0, 10, 0, 5, 1, 1, -3,\n    0, 5, 0, 0, 0, 2, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 8, 0, 7, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, -15, 0, -3, 4, 0, 8,\n    0, 0, 25, 3, -5, -5, 3, 3,\n    -2, 1, -13, 0, 0, 12, -15, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, -17, 10, 36, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, -15, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -4, 0, 0, -5,\n    -2, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -2, 0, -7, 0,\n    0, 1, 0, 0, 3, 33, -5, -2,\n    8, 7, -7, 3, 0, 0, 3, 3,\n    -3, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -33, 7, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, -7,\n    0, 0, 0, -7, 0, 0, 0, 0,\n    -6, -1, 0, 0, 0, -6, 0, -3,\n    0, -12, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -17, 0, 0,\n    0, 0, 1, 0, 0, 0, 0, 0,\n    0, -3, 0, 0, -5, 0, -4, 0,\n    -7, 0, 0, 0, -4, 3, -3, 0,\n    0, -7, -3, -6, 0, 0, -7, 0,\n    -3, 0, -12, 0, -3, 0, 0, -21,\n    -5, -10, -3, -9, 0, 0, -17, 0,\n    -7, -1, 0, 0, 0, 0, 0, 0,\n    0, 0, -4, -5, -2, -4, 0, 0,\n    0, 0, -6, 0, -6, 3, -3, 5,\n    0, -2, -6, -2, -4, -5, 0, -3,\n    -1, -2, 2, -7, -1, 0, 0, 0,\n    -23, -2, -4, 0, -6, 0, -2, -12,\n    -2, 0, 0, -2, -2, 0, 0, 0,\n    0, 2, 0, -2, -4, -2, 4, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 3, 0, 0, 0, 0, 0,\n    0, -6, 0, -2, 0, 0, 0, -5,\n    3, 0, 0, 0, -7, -3, -5, 0,\n    0, -7, 0, -3, 0, -12, 0, 0,\n    0, 0, -25, 0, -5, -9, -13, 0,\n    0, -17, 0, -2, -4, 0, 0, 0,\n    0, 0, 0, 0, 0, -3, -4, -1,\n    -4, 1, 0, 0, 4, -3, 0, 8,\n    13, -3, -3, -8, 3, 13, 4, 6,\n    -7, 3, 11, 3, 7, 6, 7, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 16, 12, -5, -3, 0, -2,\n    20, 11, 20, 0, 0, 0, 3, 0,\n    0, 9, 0, 0, -4, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, -2, 0,\n    0, 0, 0, 0, 0, 0, 0, 4,\n    0, 0, 0, 0, -22, -3, -2, -10,\n    -13, 0, 0, -17, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -4, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, -2,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    4, 0, 0, 0, 0, -22, -3, -2,\n    -10, -13, 0, 0, -10, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    -2, 0, 0, 0, -6, 3, 0, -3,\n    2, 5, 3, -8, 0, -1, -2, 3,\n    0, 2, 0, 0, 0, 0, -6, 0,\n    -2, -2, -5, 0, -2, -10, 0, 16,\n    -3, 0, -6, -2, 0, -2, -4, 0,\n    -3, -7, -5, -3, 0, 0, 0, -4,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, -2, 0, 0, 0, 0, 0, 0,\n    0, 0, 4, 0, 0, 0, 0, -22,\n    -3, -2, -10, -13, 0, 0, -17, 0,\n    0, 0, 0, 0, 0, 13, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    -4, 0, -8, -3, -2, 8, -2, -3,\n    -10, 1, -2, 1, -2, -7, 1, 6,\n    1, 2, 1, 2, -6, -10, -3, 0,\n    -10, -5, -7, -11, -10, 0, -4, -5,\n    -3, -3, -2, -2, -3, -2, 0, -2,\n    -1, 4, 0, 4, -2, 0, 8, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, -2, -3, -3, 0, 0,\n    -7, 0, -1, 0, -4, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    -15, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -3, -3, 0, -3,\n    0, 0, 0, 0, -2, 0, 0, -4,\n    -3, 3, 0, -4, -5, -2, 0, -7,\n    -2, -6, -2, -3, 0, -4, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, -17, 0, 8, 0, 0, -5, 0,\n    0, 0, 0, -3, 0, -3, 0, 0,\n    -1, 0, 0, -2, 0, -6, 0, 0,\n    11, -3, -8, -8, 2, 3, 3, -1,\n    -7, 2, 4, 2, 8, 2, 8, -2,\n    -7, 0, 0, -10, 0, 0, -8, -7,\n    0, 0, -5, 0, -3, -4, 0, -4,\n    0, -4, 0, -2, 4, 0, -2, -8,\n    -3, 9, 0, 0, -2, 0, -5, 0,\n    0, 3, -6, 0, 3, -3, 2, 0,\n    0, -8, 0, -2, -1, 0, -3, 3,\n    -2, 0, 0, 0, -10, -3, -6, 0,\n    -8, 0, 0, -12, 0, 9, -3, 0,\n    -5, 0, 2, 0, -3, 0, -3, -8,\n    0, -3, 3, 0, 0, 0, 0, -2,\n    0, 0, 3, -3, 1, 0, 0, -3,\n    -2, 0, -3, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -16, 0, 6, 0,\n    0, -2, 0, 0, 0, 0, 1, 0,\n    -3, -3, 0, 0, 0, 5, 0, 6,\n    0, 0, 0, 0, 0, -16, -15, 1,\n    11, 8, 4, -10, 2, 11, 0, 9,\n    0, 5, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 14, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0\n}", "sline": 2032}, "kern_classes": {"type": "Variable", "def": "static const lv_font_fmt_txt_kern_classes_t kern_classes =\n{\n    .class_pair_values   = kern_class_values,\n    .left_class_mapping  = kern_left_class_mapping,\n    .right_class_mapping = kern_right_class_mapping,\n    .left_class_cnt      = 61,\n    .right_class_cnt     = 49,\n}", "sline": 2412}, "cache": {"type": "Variable", "def": "static  lv_font_fmt_txt_glyph_cache_t cache", "sline": 2427}, "font_dsc": {"type": "Variable", "def": "static const lv_font_fmt_txt_dsc_t font_dsc = {\n#else\nstatic lv_font_fmt_txt_dsc_t font_dsc = {\n#endif\n    .glyph_bitmap = glyph_bitmap,\n    .glyph_dsc = glyph_dsc,\n    .cmaps = cmaps,\n    .kern_dsc = &kern_classes,\n    .kern_scale = 16,\n    .cmap_num = 2,\n    .bpp = 4,\n    .kern_classes = 1,\n    .bitmap_format = 0,\n#if LV_VERSION_CHECK(8, 0, 0)\n    .cache = &cache\n#endif\n}", "sline": 2428}, "lv_font_montserrat_16": {"type": "Variable", "def": "const lv_font_t lv_font_montserrat_16 = {\n#else\nlv_font_t lv_font_montserrat_16 = {\n#endif\n    .get_glyph_dsc = lv_font_get_glyph_dsc_fmt_txt,    /*Function pointer to get glyph's data*/\n    .get_glyph_bitmap = lv_font_get_bitmap_fmt_txt,    /*Function pointer to get glyph's bitmap*/\n    .line_height = 18,          /*The maximum line height required by the font*/\n    .base_line = 3,             /*Baseline measured from the bottom of the line*/\n#if !(LVGL_VERSION_MAJOR == 6 && LVGL_VERSION_MINOR == 0)\n    .subpx = LV_FONT_SUBPX_NONE,\n#endif\n#if LV_VERSION_CHECK(7, 4, 0)\n    .underline_position = -1,\n    .underline_thickness = 1,\n#endif\n    .dsc = &font_dsc           /*The custom font data. Will be accessed by `get_glyph_bitmap/dsc` */\n}", "sline": 2453}, "carbit_updater/lvgl/src/font/lv_font_montserrat_16.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_16.c"}}, "carbit_updater/lvgl/src/misc/lv_ll.h": {"stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 16}, "stddef": {"type": "Variable", "def": "#include stddef.h", "sline": 17}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 18}, "lv_ll_node_t": {"type": "Variable", "def": "typedef uint8_t lv_ll_node_t", "sline": 29, "docstring": "/** Dummy type to make handling easier*/"}, "lv_ll_t.n_size": {"type": "Variable", "def": "uint32_t n_size", "sline": 33, "in_struct": "lv_ll_t"}, "lv_ll_t.head": {"type": "Variable", "def": "lv_ll_node_t * head", "sline": 34, "in_struct": "lv_ll_t"}, "lv_ll_t.tail": {"type": "Variable", "def": "lv_ll_node_t * tail", "sline": 35, "in_struct": "lv_ll_t"}, "lv_ll_t": {"type": "Variable", "def": "typedef struct {\n    uint32_t n_size;\n    lv_ll_node_t * head;\n    lv_ll_node_t * tail;\n} lv_ll_t", "sline": 36, "docstring": "/** Description of a linked list*/"}, "_lv_ll_init": {"type": "Function", "def": "void _lv_ll_init(lv_ll_t * ll_p, uint32_t node_size)", "sline": 47}, "_lv_ll_ins_head": {"type": "Function", "def": "void * _lv_ll_ins_head(lv_ll_t * ll_p)", "sline": 54}, "_lv_ll_ins_prev": {"type": "Function", "def": "void * _lv_ll_ins_prev(lv_ll_t * ll_p, void * n_act)", "sline": 62}, "_lv_ll_ins_tail": {"type": "Function", "def": "void * _lv_ll_ins_tail(lv_ll_t * ll_p)", "sline": 69}, "_lv_ll_remove": {"type": "Function", "def": "void _lv_ll_remove(lv_ll_t * ll_p, void * node_p)", "sline": 77}, "_lv_ll_clear": {"type": "Function", "def": "void _lv_ll_clear(lv_ll_t * ll_p)", "sline": 83}, "_lv_ll_chg_list": {"type": "Function", "def": "void _lv_ll_chg_list(lv_ll_t * ll_ori_p, lv_ll_t * ll_new_p, void * node, bool head)", "sline": 93}, "_lv_ll_get_head": {"type": "Function", "def": "void * _lv_ll_get_head(const lv_ll_t * ll_p)", "sline": 100}, "_lv_ll_get_tail": {"type": "Function", "def": "void * _lv_ll_get_tail(const lv_ll_t * ll_p)", "sline": 107}, "_lv_ll_get_next": {"type": "Function", "def": "void * _lv_ll_get_next(const lv_ll_t * ll_p, const void * n_act)", "sline": 115}, "_lv_ll_get_prev": {"type": "Function", "def": "void * _lv_ll_get_prev(const lv_ll_t * ll_p, const void * n_act)", "sline": 123}, "_lv_ll_get_len": {"type": "Function", "def": "uint32_t _lv_ll_get_len(const lv_ll_t * ll_p)", "sline": 130}, "_lv_ll_move_before": {"type": "Function", "def": "void _lv_ll_move_before(lv_ll_t * ll_p, void * n_act, void * n_after)", "sline": 146}, "_lv_ll_is_empty": {"type": "Function", "def": "bool _lv_ll_is_empty(lv_ll_t * ll_p)", "sline": 153}, "carbit_updater/lvgl/src/misc/lv_ll.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_ll.h"}}, "carbit_updater/lvgl/src/widgets/lv_table.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "lv_obj": {"type": "Variable", "def": "#include ../core/lv_obj.h", "sline": 25}, "lv_label": {"type": "Variable", "def": "#include lv_label.h", "sline": 26, "include": ["carbit_updater/lvgl/src/widgets/lv_label.h", null]}, "_silence_gcc_warning": {"type": "Struct", "def": "LV_EXPORT_CONST_INT(LV_TABLE_CELL_NONE)", "sline": 32}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_table.h:38:1)": {"type": "Enum", "def": "enum {\n    LV_TABLE_CELL_CTRL_MERGE_RIGHT = 1 << 0,\n    LV_TABLE_CELL_CTRL_TEXT_CROP   = 1 << 1,\n    LV_TABLE_CELL_CTRL_CUSTOM_1    = 1 << 4,\n    LV_TABLE_CELL_CTRL_CUSTOM_2    = 1 << 5,\n    LV_TABLE_CELL_CTRL_CUSTOM_3    = 1 << 6,\n    LV_TABLE_CELL_CTRL_CUSTOM_4    = 1 << 7,\n}", "sline": 38}, "lv_table_cell_ctrl_t": {"type": "Variable", "def": "typedef uint8_t  lv_table_cell_ctrl_t", "sline": 47}, "lv_table_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 51, "in_struct": "lv_table_t"}, "lv_table_t.col_cnt": {"type": "Variable", "def": "uint16_t col_cnt", "sline": 52, "in_struct": "lv_table_t"}, "lv_table_t.row_cnt": {"type": "Variable", "def": "uint16_t row_cnt", "sline": 53, "in_struct": "lv_table_t"}, "lv_table_t.cell_data": {"type": "Variable", "def": "char ** cell_data", "sline": 54, "in_struct": "lv_table_t"}, "lv_table_t.row_h": {"type": "Variable", "def": "lv_coord_t * row_h", "sline": 55, "in_struct": "lv_table_t"}, "lv_table_t.col_w": {"type": "Variable", "def": "lv_coord_t * col_w", "sline": 56, "in_struct": "lv_table_t"}, "lv_table_t.col_act": {"type": "Variable", "def": "uint16_t col_act", "sline": 57, "in_struct": "lv_table_t"}, "lv_table_t.row_act": {"type": "Variable", "def": "uint16_t row_act", "sline": 58, "in_struct": "lv_table_t"}, "lv_table_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    uint16_t col_cnt;\n    uint16_t row_cnt;\n    char ** cell_data;\n    lv_coord_t * row_h;\n    lv_coord_t * col_w;\n    uint16_t col_act;\n    uint16_t row_act;\n} lv_table_t", "sline": 59, "docstring": "/*Data of table*/"}, "lv_table_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_table_class", "sline": 61}, "lv_table_draw_part_type_t": {"type": "Variable", "def": "typedef enum {\n    LV_TABLE_DRAW_PART_CELL,       /**< A cell*/\n} lv_table_draw_part_type_t", "sline": 69}, "lv_table_create": {"type": "Function", "def": "lv_obj_t * lv_table_create(lv_obj_t * parent)", "sline": 80}, "lv_table_set_cell_value": {"type": "Function", "def": "void lv_table_set_cell_value(lv_obj_t * obj, uint16_t row, uint16_t col, const char * txt)", "sline": 94}, "lv_table_set_cell_value_fmt": {"type": "Function", "def": "void lv_table_set_cell_value_fmt(lv_obj_t * obj, uint16_t row, uint16_t col, const char * fmt, ...)", "sline": 104}, "lv_table_set_row_cnt": {"type": "Function", "def": "void lv_table_set_row_cnt(lv_obj_t * obj, uint16_t row_cnt)", "sline": 111}, "lv_table_set_col_cnt": {"type": "Function", "def": "void lv_table_set_col_cnt(lv_obj_t * obj, uint16_t col_cnt)", "sline": 118}, "lv_table_set_col_width": {"type": "Function", "def": "void lv_table_set_col_width(lv_obj_t * obj, uint16_t col_id, lv_coord_t w)", "sline": 126}, "lv_table_add_cell_ctrl": {"type": "Function", "def": "void lv_table_add_cell_ctrl(lv_obj_t * obj, uint16_t row, uint16_t col, lv_table_cell_ctrl_t ctrl)", "sline": 135}, "lv_table_clear_cell_ctrl": {"type": "Function", "def": "void lv_table_clear_cell_ctrl(lv_obj_t * obj, uint16_t row, uint16_t col, lv_table_cell_ctrl_t ctrl)", "sline": 145}, "lv_table_get_cell_value": {"type": "Function", "def": "const char * lv_table_get_cell_value(lv_obj_t * obj, uint16_t row, uint16_t col)", "sline": 158}, "lv_table_get_row_cnt": {"type": "Function", "def": "uint16_t lv_table_get_row_cnt(lv_obj_t * obj)", "sline": 165}, "lv_table_get_col_cnt": {"type": "Function", "def": "uint16_t lv_table_get_col_cnt(lv_obj_t * obj)", "sline": 172}, "lv_table_get_col_width": {"type": "Function", "def": "lv_coord_t lv_table_get_col_width(lv_obj_t * obj, uint16_t col)", "sline": 180}, "lv_table_has_cell_ctrl": {"type": "Function", "def": "bool lv_table_has_cell_ctrl(lv_obj_t * obj, uint16_t row, uint16_t col, lv_table_cell_ctrl_t ctrl)", "sline": 190}, "lv_table_get_selected_cell": {"type": "Function", "def": "void lv_table_get_selected_cell(lv_obj_t * obj, uint16_t * row, uint16_t * col)", "sline": 198}, "carbit_updater/lvgl/src/widgets/lv_table.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_table.h"}}, "carbit_updater/lvgl/src/core/lv_indev_scroll.h": {"lv_obj": {"type": "Variable", "def": "#include lv_obj.h", "sline": 16, "include": ["carbit_updater/lvgl/src/core/lv_obj.h", null]}, "_lv_indev_scroll_handler": {"type": "Function", "def": "void _lv_indev_scroll_handler(_lv_indev_proc_t * proc)", "sline": 34}, "_lv_indev_scroll_throw_handler": {"type": "Function", "def": "void _lv_indev_scroll_throw_handler(_lv_indev_proc_t * proc)", "sline": 40}, "lv_indev_scroll_throw_predict": {"type": "Function", "def": "lv_coord_t lv_indev_scroll_throw_predict(lv_indev_t * indev, lv_dir_t dir)", "sline": 48}, "lv_indev_scroll_get_snap_dist": {"type": "Function", "def": "void lv_indev_scroll_get_snap_dist(lv_obj_t * obj, lv_point_t * p)", "sline": 55}, "carbit_updater/lvgl/src/core/lv_indev_scroll.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_indev_scroll.h"}}, "carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar.c": {"lv_calendar": {"type": "Variable", "def": "#include lv_calendar.h", "sline": 9, "include": ["carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar.h", null]}, "lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 10}, "lv_assert": {"type": "Variable", "def": "#include ../../../misc/lv_assert.h", "sline": 13}, "lv_calendar_constructor": {"type": "Function", "def": "static void lv_calendar_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 240, "body": "{\n    LV_UNUSED(class_p);\n    lv_calendar_t * calendar = (lv_calendar_t *)obj;\n\n    /*Initialize the allocated 'ext'*/\n    calendar->today.year  = 2020;\n    calendar->today.month = 1;\n    calendar->today.day   = 1;\n\n    calendar->showed_date.year  = 2020;\n    calendar->showed_date.month = 1;\n    calendar->showed_date.day   = 1;\n\n    calendar->highlighted_dates      = NULL;\n    calendar->highlighted_dates_num  = 0;\n\n    lv_memset_00(calendar->nums, sizeof(calendar->nums));\n    uint8_t i;\n    uint8_t j = 0;\n    for(i = 0; i < 8 * 7; i++) {\n        /*Every 8th string is \"\\n\"*/\n        if(i != 0 && (i + 1) % 8 == 0) {\n            calendar->map[i] = \"\\n\";\n        }\n        else if(i < 8) {\n            calendar->map[i] = day_names_def[i];\n        }\n        else {\n            calendar->nums[j][0] = 'x';\n            calendar->map[i] = calendar->nums[j];\n            j++;\n        }\n    }\n    calendar->map[8 * 7 - 1] = \"\";\n\n    calendar->btnm = lv_btnmatrix_create(obj);\n    lv_btnmatrix_set_map(calendar->btnm, calendar->map);\n    lv_btnmatrix_set_btn_ctrl_all(calendar->btnm, LV_BTNMATRIX_CTRL_CLICK_TRIG | LV_BTNMATRIX_CTRL_NO_REPEAT);\n    lv_obj_add_event_cb(calendar->btnm, draw_part_begin_event_cb, LV_EVENT_DRAW_PART_BEGIN, NULL);\n    lv_obj_set_width(calendar->btnm, lv_pct(100));\n\n    lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_COLUMN);\n    lv_obj_set_flex_grow(calendar->btnm, 1);\n\n    lv_calendar_set_showed_date(obj, calendar->showed_date.year, calendar->showed_date.month);\n    lv_calendar_set_today_date(obj, calendar->today.year, calendar->today.month, calendar->today.day);\n\n    lv_obj_add_flag(calendar->btnm, LV_OBJ_FLAG_EVENT_BUBBLE);\n}"}, "draw_part_begin_event_cb": {"type": "Function", "def": "static void draw_part_begin_event_cb(lv_event_t * e)", "sline": 291, "body": "{\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_obj_draw_part_dsc_t * dsc = lv_event_get_param(e);\n    if(dsc->part == LV_PART_ITEMS) {\n        /*Day name styles*/\n        if(dsc->id < 7) {\n            dsc->rect_dsc->bg_opa = LV_OPA_TRANSP;\n            dsc->rect_dsc->border_opa = LV_OPA_TRANSP;\n        }\n        else if(lv_btnmatrix_has_btn_ctrl(obj, dsc->id, LV_BTNMATRIX_CTRL_DISABLED)) {\n            dsc->rect_dsc->bg_opa = LV_OPA_TRANSP;\n            dsc->rect_dsc->border_opa = LV_OPA_TRANSP;\n            dsc->label_dsc->color = lv_palette_main(LV_PALETTE_GREY);\n        }\n\n        if(lv_btnmatrix_has_btn_ctrl(obj, dsc->id, LV_CALENDAR_CTRL_HIGHLIGHT)) {\n            dsc->rect_dsc->bg_opa = LV_OPA_40;\n            dsc->rect_dsc->bg_color = lv_theme_get_color_primary(obj);\n            if(lv_btnmatrix_get_selected_btn(obj) == dsc->id) {\n                dsc->rect_dsc->bg_opa = LV_OPA_70;\n            }\n        }\n\n        if(lv_btnmatrix_has_btn_ctrl(obj, dsc->id, LV_CALENDAR_CTRL_TODAY)) {\n            dsc->rect_dsc->border_opa = LV_OPA_COVER;\n            dsc->rect_dsc->border_color = lv_theme_get_color_primary(obj);\n            dsc->rect_dsc->border_width += 1;\n        }\n\n    }\n}"}, "get_day_of_week": {"type": "Function", "def": "static uint8_t get_day_of_week(uint32_t year, uint32_t month, uint32_t day)", "sline": 364, "body": "{\n    uint32_t a = month < 3 ? 1 : 0;\n    uint32_t b = year - a;\n\n#if LV_CALENDAR_WEEK_STARTS_MONDAY\n    uint32_t day_of_week = (day + (31 * (month - 2 + 12 * a) / 12) + b + (b / 4) - (b / 100) + (b / 400) - 1) % 7;\n#else\n    uint32_t day_of_week = (day + (31 * (month - 2 + 12 * a) / 12) + b + (b / 4) - (b / 100) + (b / 400)) % 7;\n#endif\n\n    return day_of_week  ;\n}"}, "get_month_length": {"type": "Function", "def": "static uint8_t get_month_length(int32_t year, int32_t month)", "sline": 331, "body": "{\n    month--;\n    if(month < 0) {\n        year--;             /*Already in the previous year (won't be less then -12 to skip a whole year)*/\n        month = 12 + month; /*`month` is negative, the result will be < 12*/\n    }\n    if(month >= 12) {\n        year++;\n        month -= 12;\n    }\n\n    /*month == 1 is february*/\n    return (month == 1) ? (28 + is_leap_year(year)) : 31 - month % 7 % 2;\n}"}, "is_leap_year": {"type": "Function", "def": "static uint8_t is_leap_year(uint32_t year)", "sline": 352, "body": "{\n    return (year % 4) || ((year % 100 == 0) && (year % 400)) ? 0 : 1;\n}"}, "highlight_update": {"type": "Function", "def": "static void highlight_update(lv_obj_t * obj)", "sline": 378, "body": "{\n    lv_calendar_t * calendar = (lv_calendar_t *)obj;\n    uint16_t i;\n\n    /*Clear all kind of selection*/\n    lv_btnmatrix_clear_btn_ctrl_all(calendar->btnm, LV_CALENDAR_CTRL_TODAY | LV_CALENDAR_CTRL_HIGHLIGHT);\n\n    uint8_t day_first = get_day_of_week(calendar->showed_date.year, calendar->showed_date.month, 1);\n    if(calendar->highlighted_dates) {\n        for(i = 0; i < calendar->highlighted_dates_num; i++) {\n            if(calendar->highlighted_dates[i].year == calendar->showed_date.year &&\n               calendar->highlighted_dates[i].month == calendar->showed_date.month) {\n                lv_btnmatrix_set_btn_ctrl(calendar->btnm, calendar->highlighted_dates[i].day - 1 + day_first + 7, LV_CALENDAR_CTRL_HIGHLIGHT);\n            }\n        }\n    }\n\n    if(calendar->showed_date.year == calendar->today.year && calendar->showed_date.month == calendar->today.month) {\n        lv_btnmatrix_set_btn_ctrl(calendar->btnm, calendar->today.day - 1 + day_first + 7, LV_CALENDAR_CTRL_TODAY);\n    }\n}"}, "lv_calendar_class": {"type": "Variable", "def": "const lv_obj_class_t lv_calendar_class = {\n    .constructor_cb = lv_calendar_constructor,\n    .width_def = (LV_DPI_DEF * 3) / 2,\n    .height_def = (LV_DPI_DEF * 3) / 2,\n    .group_def = LV_OBJ_CLASS_GROUP_DEF_TRUE,\n    .instance_size = sizeof(lv_calendar_t),\n    .base_class = &lv_obj_class\n}", "sline": 41}, "day_names_def": {"type": "Variable", "def": "static const char * day_names_def[7] = LV_CALENDAR_DEFAULT_DAY_NAMES", "sline": 50}, "lv_calendar_create": {"type": "Function", "def": "lv_obj_t * lv_calendar_create(lv_obj_t * parent)", "sline": 60, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_calendar_class, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_calendar_set_day_names": {"type": "Function", "def": "void lv_calendar_set_day_names(lv_obj_t * obj, const char * day_names[])", "sline": 72, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_calendar_t * calendar = (lv_calendar_t *)obj;\n\n    uint32_t i;\n    for(i = 0; i < 7; i++) {\n        calendar->map[i] = day_names[i];\n    }\n    lv_obj_invalidate(obj);\n}"}, "lv_calendar_set_today_date": {"type": "Function", "def": "void lv_calendar_set_today_date(lv_obj_t * obj, uint32_t year, uint32_t month, uint32_t day)", "sline": 84, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_calendar_t * calendar = (lv_calendar_t *)obj;\n\n    calendar->today.year         = year;\n    calendar->today.month        = month;\n    calendar->today.day          = day;\n\n    highlight_update(obj);\n}"}, "lv_calendar_set_highlighted_dates": {"type": "Function", "def": "void lv_calendar_set_highlighted_dates(lv_obj_t * obj, lv_calendar_date_t highlighted[], uint16_t date_num)", "sline": 96, "body": "{\n    LV_ASSERT_NULL(highlighted);\n\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_calendar_t * calendar = (lv_calendar_t *)obj;\n\n    calendar->highlighted_dates     = highlighted;\n    calendar->highlighted_dates_num = date_num;\n\n    highlight_update(obj);\n}"}, "lv_calendar_set_showed_date": {"type": "Function", "def": "void lv_calendar_set_showed_date(lv_obj_t * obj, uint32_t year, uint32_t month)", "sline": 109, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_calendar_t * calendar = (lv_calendar_t *)obj;\n\n    calendar->showed_date.year   = year;\n    calendar->showed_date.month  = month;\n    calendar->showed_date.day    = 1;\n\n    lv_calendar_date_t d;\n    d.year = calendar->showed_date.year;\n    d.month = calendar->showed_date.month;\n    d.day = calendar->showed_date.day;\n\n    uint8_t i;\n\n    /*Remove the disabled state but revert it for day names*/\n    lv_btnmatrix_clear_btn_ctrl_all(calendar->btnm, LV_BTNMATRIX_CTRL_DISABLED);\n    for(i = 0; i < 7; i++) {\n        lv_btnmatrix_set_btn_ctrl(calendar->btnm, i, LV_BTNMATRIX_CTRL_DISABLED);\n    }\n\n    uint8_t act_mo_len = get_month_length(d.year, d.month);\n    uint8_t day_first = get_day_of_week(d.year, d.month, 1);\n    uint8_t c;\n    for(i = day_first, c = 1; i < act_mo_len + day_first; i++, c++) {\n        lv_snprintf(calendar->nums[i], sizeof(calendar->nums[0]), \"%d\", c);\n    }\n\n    uint8_t prev_mo_len = get_month_length(d.year, d.month - 1);\n    for(i = 0, c = prev_mo_len - day_first + 1; i < day_first; i++, c++) {\n        lv_snprintf(calendar->nums[i], sizeof(calendar->nums[0]), \"%d\", c);\n        lv_btnmatrix_set_btn_ctrl(calendar->btnm, i + 7, LV_BTNMATRIX_CTRL_DISABLED);\n    }\n\n    for(i = day_first + act_mo_len, c = 1; i < 6 * 7; i++, c++) {\n        lv_snprintf(calendar->nums[i], sizeof(calendar->nums[0]), \"%d\", c);\n        lv_btnmatrix_set_btn_ctrl(calendar->btnm, i + 7, LV_BTNMATRIX_CTRL_DISABLED);\n    }\n\n    highlight_update(obj);\n\n    /*Reset the focused button if the days changes*/\n    if(lv_btnmatrix_get_selected_btn(calendar->btnm) != LV_BTNMATRIX_BTN_NONE) {\n        lv_btnmatrix_set_selected_btn(calendar->btnm, day_first + 7);\n    }\n\n    lv_obj_invalidate(obj);\n\n    /* The children of the calendar are probably headers.\n     * Notify them to let the headers updated to the new date*/\n    uint32_t child_cnt = lv_obj_get_child_cnt(obj);\n    for(i = 0; i < child_cnt; i++) {\n        lv_obj_t * child = lv_obj_get_child(obj, i);\n        if(child == calendar->btnm) continue;\n        lv_event_send(child, LV_EVENT_VALUE_CHANGED, obj);\n    }\n}"}, "lv_calendar_get_btnmatrix": {"type": "Function", "def": "lv_obj_t * lv_calendar_get_btnmatrix(const lv_obj_t * obj)", "sline": 172, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    const lv_calendar_t * calendar = (lv_calendar_t *)obj;\n    return calendar->btnm;\n}"}, "lv_calendar_get_today_date": {"type": "Function", "def": "const lv_calendar_date_t * lv_calendar_get_today_date(const lv_obj_t * obj)", "sline": 179, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    const lv_calendar_t * calendar = (lv_calendar_t *)obj;\n\n    return &calendar->today;\n}"}, "lv_calendar_get_showed_date": {"type": "Function", "def": "const lv_calendar_date_t * lv_calendar_get_showed_date(const lv_obj_t * obj)", "sline": 187, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    const lv_calendar_t * calendar = (lv_calendar_t *)obj;\n\n    return &calendar->showed_date;\n}"}, "lv_calendar_get_highlighted_dates": {"type": "Function", "def": "lv_calendar_date_t * lv_calendar_get_highlighted_dates(const lv_obj_t * obj)", "sline": 195, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_calendar_t * calendar = (lv_calendar_t *)obj;\n\n    return calendar->highlighted_dates;\n}"}, "lv_calendar_get_highlighted_dates_num": {"type": "Function", "def": "uint16_t lv_calendar_get_highlighted_dates_num(const lv_obj_t * obj)", "sline": 203, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_calendar_t * calendar = (lv_calendar_t *)obj;\n\n    return calendar->highlighted_dates_num;\n}"}, "lv_calendar_get_pressed_date": {"type": "Function", "def": "lv_res_t lv_calendar_get_pressed_date(const lv_obj_t * obj, lv_calendar_date_t * date)", "sline": 211, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_calendar_t * calendar = (lv_calendar_t *)obj;\n\n    uint16_t d = lv_btnmatrix_get_selected_btn(calendar->btnm);\n    if(d == LV_BTNMATRIX_BTN_NONE) {\n        date->year = 0;\n        date->month = 0;\n        date->day = 0;\n        return LV_RES_INV;\n    }\n\n    const char * txt = lv_btnmatrix_get_btn_text(calendar->btnm, lv_btnmatrix_get_selected_btn(calendar->btnm));\n\n    if(txt[1] == 0) date->day = txt[0] - '0';\n    else date->day = (txt[0] - '0') * 10 + (txt[1] - '0');\n\n    date->year = calendar->showed_date.year;\n    date->month = calendar->showed_date.month;\n\n    return LV_RES_OK;\n}"}, "carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar.c"}}, "carbit_updater/lvgl/src/misc/lv_ll.c": {"lv_ll": {"type": "Variable", "def": "#include lv_ll.h", "sline": 10, "include": ["carbit_updater/lvgl/src/misc/lv_ll.h", null]}, "lv_mem": {"type": "Variable", "def": "#include lv_mem.h", "sline": 11, "include": ["carbit_updater/lvgl/src/misc/lv_mem.h", null]}, "node_set_prev": {"type": "Function", "def": "static void node_set_prev(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * prev)", "sline": 378, "body": "{\n    if(act == NULL) return; /*Can't set the prev node of `NULL`*/\n\n    uint8_t * act8 = (uint8_t *)act;\n\n    act8 += LL_PREV_P_OFFSET(ll_p);\n\n    lv_ll_node_t ** act_node_p = (lv_ll_node_t **) act8;\n    lv_ll_node_t ** prev_node_p = (lv_ll_node_t **) &prev;\n\n    *act_node_p = *prev_node_p;\n}"}, "node_set_next": {"type": "Function", "def": "static void node_set_next(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * next)", "sline": 398, "body": "{\n    if(act == NULL) return; /*Can't set the next node of `NULL`*/\n    uint8_t * act8 = (uint8_t *)act;\n\n    act8 += LL_NEXT_P_OFFSET(ll_p);\n    lv_ll_node_t ** act_node_p = (lv_ll_node_t **) act8;\n    lv_ll_node_t ** next_node_p = (lv_ll_node_t **) &next;\n\n    *act_node_p = *next_node_p;\n}"}, "_lv_ll_init": {"type": "Function", "def": "void _lv_ll_init(lv_ll_t * ll_p, uint32_t node_size)", "sline": 47, "body": "{\n    ll_p->head = NULL;\n    ll_p->tail = NULL;\n#ifdef LV_ARCH_64\n    /*Round the size up to 8*/\n    node_size = (node_size + 7) & (~0x7);\n#else\n    /*Round the size up to 4*/\n    node_size = (node_size + 3) & (~0x3);\n#endif\n\n    ll_p->n_size = node_size;\n}"}, "_lv_ll_ins_head": {"type": "Function", "def": "void * _lv_ll_ins_head(lv_ll_t * ll_p)", "sline": 67, "body": "{\n    lv_ll_node_t * n_new;\n\n    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);\n\n    if(n_new != NULL) {\n        node_set_prev(ll_p, n_new, NULL);       /*No prev. before the new head*/\n        node_set_next(ll_p, n_new, ll_p->head); /*After new comes the old head*/\n\n        if(ll_p->head != NULL) { /*If there is old head then before it goes the new*/\n            node_set_prev(ll_p, ll_p->head, n_new);\n        }\n\n        ll_p->head = n_new;      /*Set the new head in the dsc.*/\n        if(ll_p->tail == NULL) { /*If there is no tail (1. node) set the tail too*/\n            ll_p->tail = n_new;\n        }\n    }\n\n    return n_new;\n}"}, "_lv_ll_ins_prev": {"type": "Function", "def": "void * _lv_ll_ins_prev(lv_ll_t * ll_p, void * n_act)", "sline": 96, "body": "{\n    lv_ll_node_t * n_new;\n\n    if(NULL == ll_p || NULL == n_act) return NULL;\n\n    if(_lv_ll_get_head(ll_p) == n_act) {\n        n_new = _lv_ll_ins_head(ll_p);\n        if(n_new == NULL) return NULL;\n    }\n    else {\n        n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);\n        if(n_new == NULL) return NULL;\n\n        lv_ll_node_t * n_prev;\n        n_prev = _lv_ll_get_prev(ll_p, n_act);\n        node_set_next(ll_p, n_prev, n_new);\n        node_set_prev(ll_p, n_new, n_prev);\n        node_set_prev(ll_p, n_act, n_new);\n        node_set_next(ll_p, n_new, n_act);\n    }\n\n    return n_new;\n}"}, "_lv_ll_ins_tail": {"type": "Function", "def": "void * _lv_ll_ins_tail(lv_ll_t * ll_p)", "sline": 126, "body": "{\n    lv_ll_node_t * n_new;\n\n    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);\n\n    if(n_new != NULL) {\n        node_set_next(ll_p, n_new, NULL);       /*No next after the new tail*/\n        node_set_prev(ll_p, n_new, ll_p->tail); /*The prev. before new is the old tail*/\n        if(ll_p->tail != NULL) {                /*If there is old tail then the new comes after it*/\n            node_set_next(ll_p, ll_p->tail, n_new);\n        }\n\n        ll_p->tail = n_new;      /*Set the new tail in the dsc.*/\n        if(ll_p->head == NULL) { /*If there is no head (1. node) set the head too*/\n            ll_p->head = n_new;\n        }\n    }\n\n    return n_new;\n}"}, "_lv_ll_remove": {"type": "Function", "def": "void _lv_ll_remove(lv_ll_t * ll_p, void * node_p)", "sline": 154, "body": "{\n    if(ll_p == NULL) return;\n\n    if(_lv_ll_get_head(ll_p) == node_p) {\n        /*The new head will be the node after 'n_act'*/\n        ll_p->head = _lv_ll_get_next(ll_p, node_p);\n        if(ll_p->head == NULL) {\n            ll_p->tail = NULL;\n        }\n        else {\n            node_set_prev(ll_p, ll_p->head, NULL);\n        }\n    }\n    else if(_lv_ll_get_tail(ll_p) == node_p) {\n        /*The new tail will be the node before 'n_act'*/\n        ll_p->tail = _lv_ll_get_prev(ll_p, node_p);\n        if(ll_p->tail == NULL) {\n            ll_p->head = NULL;\n        }\n        else {\n            node_set_next(ll_p, ll_p->tail, NULL);\n        }\n    }\n    else {\n        lv_ll_node_t * n_prev = _lv_ll_get_prev(ll_p, node_p);\n        lv_ll_node_t * n_next = _lv_ll_get_next(ll_p, node_p);\n\n        node_set_next(ll_p, n_prev, n_next);\n        node_set_prev(ll_p, n_next, n_prev);\n    }\n}"}, "_lv_ll_clear": {"type": "Function", "def": "void _lv_ll_clear(lv_ll_t * ll_p)", "sline": 191, "body": "{\n    void * i;\n    void * i_next;\n\n    i      = _lv_ll_get_head(ll_p);\n    i_next = NULL;\n\n    while(i != NULL) {\n        i_next = _lv_ll_get_next(ll_p, i);\n\n        _lv_ll_remove(ll_p, i);\n        lv_mem_free(i);\n\n        i = i_next;\n    }\n}"}, "_lv_ll_chg_list": {"type": "Function", "def": "void _lv_ll_chg_list(lv_ll_t * ll_ori_p, lv_ll_t * ll_new_p, void * node, bool head)", "sline": 217, "body": "{\n    _lv_ll_remove(ll_ori_p, node);\n\n    if(head) {\n        /*Set node as head*/\n        node_set_prev(ll_new_p, node, NULL);\n        node_set_next(ll_new_p, node, ll_new_p->head);\n\n        if(ll_new_p->head != NULL) { /*If there is old head then before it goes the new*/\n            node_set_prev(ll_new_p, ll_new_p->head, node);\n        }\n\n        ll_new_p->head = node;       /*Set the new head in the dsc.*/\n        if(ll_new_p->tail == NULL) { /*If there is no tail (first node) set the tail too*/\n            ll_new_p->tail = node;\n        }\n    }\n    else {\n        /*Set node as tail*/\n        node_set_prev(ll_new_p, node, ll_new_p->tail);\n        node_set_next(ll_new_p, node, NULL);\n\n        if(ll_new_p->tail != NULL) { /*If there is old tail then after it goes the new*/\n            node_set_next(ll_new_p, ll_new_p->tail, node);\n        }\n\n        ll_new_p->tail = node;       /*Set the new tail in the dsc.*/\n        if(ll_new_p->head == NULL) { /*If there is no head (first node) set the head too*/\n            ll_new_p->head = node;\n        }\n    }\n}"}, "_lv_ll_get_head": {"type": "Function", "def": "void * _lv_ll_get_head(const lv_ll_t * ll_p)", "sline": 256, "body": "{\n    if(ll_p == NULL) return NULL;\n    return ll_p->head;\n}"}, "_lv_ll_get_tail": {"type": "Function", "def": "void * _lv_ll_get_tail(const lv_ll_t * ll_p)", "sline": 267, "body": "{\n    if(ll_p == NULL) return NULL;\n    return ll_p->tail;\n}"}, "_lv_ll_get_next": {"type": "Function", "def": "void * _lv_ll_get_next(const lv_ll_t * ll_p, const void * n_act)", "sline": 279, "body": "{\n    /*Pointer to the next node is stored in the end of this node.\n     *Go there and return the address found there*/\n    const lv_ll_node_t * n_act_d = n_act;\n    n_act_d += LL_NEXT_P_OFFSET(ll_p);\n    return *((lv_ll_node_t **)n_act_d);\n}"}, "_lv_ll_get_prev": {"type": "Function", "def": "void * _lv_ll_get_prev(const lv_ll_t * ll_p, const void * n_act)", "sline": 294, "body": "{\n    /*Pointer to the prev. node is stored in the end of this node.\n     *Go there and return the address found there*/\n    const lv_ll_node_t * n_act_d = n_act;\n    n_act_d += LL_PREV_P_OFFSET(ll_p);\n    return *((lv_ll_node_t **)n_act_d);\n}"}, "_lv_ll_get_len": {"type": "Function", "def": "uint32_t _lv_ll_get_len(const lv_ll_t * ll_p)", "sline": 308, "body": "{\n    uint32_t len = 0;\n    void * node;\n\n    for(node = _lv_ll_get_head(ll_p); node != NULL; node = _lv_ll_get_next(ll_p, node)) {\n        len++;\n    }\n\n    return len;\n}"}, "_lv_ll_move_before": {"type": "Function", "def": "void _lv_ll_move_before(lv_ll_t * ll_p, void * n_act, void * n_after)", "sline": 326, "body": "{\n    if(n_act == n_after) return; /*Can't move before itself*/\n\n    void * n_before;\n    if(n_after != NULL)\n        n_before = _lv_ll_get_prev(ll_p, n_after);\n    else\n        n_before = _lv_ll_get_tail(ll_p); /*if `n_after` is NULL `n_act` should be the new tail*/\n\n    if(n_act == n_before) return; /*Already before `n_after`*/\n\n    /*It's much easier to remove from the list and add again*/\n    _lv_ll_remove(ll_p, n_act);\n\n    /*Add again by setting the prev. and next nodes*/\n    node_set_next(ll_p, n_before, n_act);\n    node_set_prev(ll_p, n_act, n_before);\n    node_set_prev(ll_p, n_after, n_act);\n    node_set_next(ll_p, n_act, n_after);\n\n    /*If `n_act` was moved before NULL then it become the new tail*/\n    if(n_after == NULL) ll_p->tail = n_act;\n\n    /*If `n_act` was moved before `NULL` then it's the new head*/\n    if(n_before == NULL) ll_p->head = n_act;\n}"}, "_lv_ll_is_empty": {"type": "Function", "def": "bool _lv_ll_is_empty(lv_ll_t * ll_p)", "sline": 359, "body": "{\n    if(ll_p == NULL) return true;\n\n    if(ll_p->head == NULL && ll_p->tail == NULL) return true;\n\n    return false;\n}"}, "carbit_updater/lvgl/src/misc/lv_ll.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_ll.c"}}, "carbit_updater/lv_drivers/wayland/wayland.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 20}, "carbit_updater/lv_drivers/wayland/wayland.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/wayland/wayland.h"}}, "carbit_updater/lv_drivers/display/UC1610.c": {"UC1610": {"type": "Variable", "def": "#include UC1610.h", "sline": 9, "include": ["carbit_updater/lv_drivers/display/UC1610.h", null]}, "carbit_updater/lv_drivers/display/UC1610.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/UC1610.c"}}, "carbit_updater/lv_drivers/display/fbdev.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 20}, "carbit_updater/lv_drivers/display/fbdev.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/fbdev.h"}}, "carbit_updater/lvgl/src/misc/lv_area.c": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 9}, "lv_area": {"type": "Variable", "def": "#include lv_area.h", "sline": 11, "include": ["carbit_updater/lvgl/src/misc/lv_area.h", null]}, "lv_math": {"type": "Variable", "def": "#include lv_math.h", "sline": 12, "include": ["carbit_updater/lvgl/src/misc/lv_math.h", null]}, "lv_point_within_circle": {"type": "Function", "def": "static bool lv_point_within_circle(const lv_area_t * area, const lv_point_t * p)", "sline": 458, "body": "{\n    lv_coord_t r = (area->x2 - area->x1) / 2;\n\n    /*Circle center*/\n    lv_coord_t cx = area->x1 + r;\n    lv_coord_t cy = area->y1 + r;\n\n    /*Simplify the code by moving everything to (0, 0)*/\n    lv_coord_t px = p->x - cx;\n    lv_coord_t py = p->y - cy;\n\n    uint32_t r_sqrd = r * r;\n    uint32_t dist = (px * px) + (py * py);\n\n    if(dist <= r_sqrd)\n        return true;\n    else\n        return false;\n}"}, "lv_area_set": {"type": "Function", "def": "void lv_area_set(lv_area_t * area_p, lv_coord_t x1, lv_coord_t y1, lv_coord_t x2, lv_coord_t y2)", "sline": 48, "body": "{\n    area_p->x1 = x1;\n    area_p->y1 = y1;\n    area_p->x2 = x2;\n    area_p->y2 = y2;\n}"}, "lv_area_set_width": {"type": "Function", "def": "void lv_area_set_width(lv_area_t * area_p, lv_coord_t w)", "sline": 61, "body": "{\n    area_p->x2 = area_p->x1 + w - 1;\n}"}, "lv_area_set_height": {"type": "Function", "def": "void lv_area_set_height(lv_area_t * area_p, lv_coord_t h)", "sline": 71, "body": "{\n    area_p->y2 = area_p->y1 + h - 1;\n}"}, "_lv_area_set_pos": {"type": "Function", "def": "void _lv_area_set_pos(lv_area_t * area_p, lv_coord_t x, lv_coord_t y)", "sline": 82, "body": "{\n    lv_coord_t w = lv_area_get_width(area_p);\n    lv_coord_t h = lv_area_get_height(area_p);\n    area_p->x1   = x;\n    area_p->y1   = y;\n    lv_area_set_width(area_p, w);\n    lv_area_set_height(area_p, h);\n}"}, "lv_area_get_size": {"type": "Function", "def": "uint32_t lv_area_get_size(const lv_area_t * area_p)", "sline": 97, "body": "{\n    uint32_t size;\n\n    size = (uint32_t)(area_p->x2 - area_p->x1 + 1) * (area_p->y2 - area_p->y1 + 1);\n\n    return size;\n}"}, "lv_area_increase": {"type": "Function", "def": "void lv_area_increase(lv_area_t * area, lv_coord_t w_extra, lv_coord_t h_extra)", "sline": 106, "body": "{\n    area->x1 -= w_extra;\n    area->x2 += w_extra;\n    area->y1 -= h_extra;\n    area->y2 += h_extra;\n}"}, "lv_area_move": {"type": "Function", "def": "void lv_area_move(lv_area_t * area, lv_coord_t x_ofs, lv_coord_t y_ofs)", "sline": 114, "body": "{\n    area->x1 += x_ofs;\n    area->x2 += x_ofs;\n    area->y1 += y_ofs;\n    area->y2 += y_ofs;\n}"}, "_lv_area_intersect": {"type": "Function", "def": "bool _lv_area_intersect(lv_area_t * res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)", "sline": 129, "body": "{\n    /*Get the smaller area from 'a1_p' and 'a2_p'*/\n    res_p->x1 = LV_MAX(a1_p->x1, a2_p->x1);\n    res_p->y1 = LV_MAX(a1_p->y1, a2_p->y1);\n    res_p->x2 = LV_MIN(a1_p->x2, a2_p->x2);\n    res_p->y2 = LV_MIN(a1_p->y2, a2_p->y2);\n\n    /*If x1 or y1 greater than x2 or y2 then the areas union is empty*/\n    bool union_ok = true;\n    if((res_p->x1 > res_p->x2) || (res_p->y1 > res_p->y2)) {\n        union_ok = false;\n    }\n\n    return union_ok;\n}"}, "_lv_area_join": {"type": "Function", "def": "void _lv_area_join(lv_area_t * a_res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)", "sline": 152, "body": "{\n    a_res_p->x1 = LV_MIN(a1_p->x1, a2_p->x1);\n    a_res_p->y1 = LV_MIN(a1_p->y1, a2_p->y1);\n    a_res_p->x2 = LV_MAX(a1_p->x2, a2_p->x2);\n    a_res_p->y2 = LV_MAX(a1_p->y2, a2_p->y2);\n}"}, "_lv_area_is_point_on": {"type": "Function", "def": "bool _lv_area_is_point_on(const lv_area_t * a_p, const lv_point_t * p_p, lv_coord_t radius)", "sline": 167, "body": "{\n    /*First check the basic area*/\n    bool is_on_rect = false;\n    if((p_p->x >= a_p->x1 && p_p->x <= a_p->x2) && ((p_p->y >= a_p->y1 && p_p->y <= a_p->y2))) {\n        is_on_rect = true;\n    }\n    if(!is_on_rect)\n        return false;\n    /*Now handle potential rounded rectangles*/\n    if(radius <= 0) {\n        /*No radius, it is within the rectangle*/\n        return true;\n    }\n    lv_coord_t w = lv_area_get_width(a_p) / 2;\n    lv_coord_t h = lv_area_get_height(a_p) / 2;\n    lv_coord_t max_radius = LV_MIN(w, h);\n    if(radius > max_radius)\n        radius = max_radius;\n\n    /*Check if it's in one of the corners*/\n    lv_area_t corner_area;\n    /*Top left*/\n    corner_area.x1 = a_p->x1;\n    corner_area.x2 = a_p->x1 + radius;\n    corner_area.y1 = a_p->y1;\n    corner_area.y2 = a_p->y1 + radius;\n    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {\n        corner_area.x2 += radius;\n        corner_area.y2 += radius;\n        return lv_point_within_circle(&corner_area, p_p);\n    }\n    /*Bottom left*/\n    corner_area.y1 = a_p->y2 - radius;\n    corner_area.y2 = a_p->y2;\n    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {\n        corner_area.x2 += radius;\n        corner_area.y1 -= radius;\n        return lv_point_within_circle(&corner_area, p_p);\n    }\n    /*Bottom right*/\n    corner_area.x1 = a_p->x2 - radius;\n    corner_area.x2 = a_p->x2;\n    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {\n        corner_area.x1 -= radius;\n        corner_area.y1 -= radius;\n        return lv_point_within_circle(&corner_area, p_p);\n    }\n    /*Top right*/\n    corner_area.y1 = a_p->y1;\n    corner_area.y2 = a_p->y1 + radius;\n    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {\n        corner_area.x1 -= radius;\n        corner_area.y2 += radius;\n        return lv_point_within_circle(&corner_area, p_p);\n    }\n    /*Not within corners*/\n    return true;\n}"}, "_lv_area_is_on": {"type": "Function", "def": "bool _lv_area_is_on(const lv_area_t * a1_p, const lv_area_t * a2_p)", "sline": 233, "body": "{\n    if((a1_p->x1 <= a2_p->x2) && (a1_p->x2 >= a2_p->x1) && (a1_p->y1 <= a2_p->y2) && (a1_p->y2 >= a2_p->y1)) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}"}, "_lv_area_is_in": {"type": "Function", "def": "bool _lv_area_is_in(const lv_area_t * ain_p, const lv_area_t * aholder_p, lv_coord_t radius)", "sline": 250, "body": "{\n    bool is_in = false;\n\n    if(ain_p->x1 >= aholder_p->x1 && ain_p->y1 >= aholder_p->y1 && ain_p->x2 <= aholder_p->x2 &&\n       ain_p->y2 <= aholder_p->y2) {\n        is_in = true;\n    }\n\n    if(!is_in) return false;\n    if(radius == 0) return true;\n\n    /*Check if the corner points are inside the radius or not*/\n    lv_point_t p;\n\n    p.x = ain_p->x1;\n    p.y = ain_p->y1;\n    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;\n\n    p.x = ain_p->x2;\n    p.y = ain_p->y1;\n    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;\n\n    p.x = ain_p->x1;\n    p.y = ain_p->y2;\n    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;\n\n    p.x = ain_p->x2;\n    p.y = ain_p->y2;\n    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;\n\n    return true;\n}"}, "_lv_area_is_out": {"type": "Function", "def": "bool _lv_area_is_out(const lv_area_t * aout_p, const lv_area_t * aholder_p, lv_coord_t radius)", "sline": 291, "body": "{\n    if(aout_p->x2 < aholder_p->x1 || aout_p->y2 < aholder_p->y1 || aout_p->x1 > aholder_p->x2 ||\n       aout_p->y1 > aholder_p->y2) {\n        return true;\n    }\n\n    if(radius == 0) return false;\n\n    /*Check if the corner points are outside the radius or not*/\n    lv_point_t p;\n\n    p.x = aout_p->x1;\n    p.y = aout_p->y1;\n    if(_lv_area_is_point_on(aholder_p, &p, radius)) return false;\n\n    p.x = aout_p->x2;\n    p.y = aout_p->y1;\n    if(_lv_area_is_point_on(aholder_p, &p, radius)) return false;\n\n    p.x = aout_p->x1;\n    p.y = aout_p->y2;\n    if(_lv_area_is_point_on(aholder_p, &p, radius)) return false;\n\n    p.x = aout_p->x2;\n    p.y = aout_p->y2;\n    if(_lv_area_is_point_on(aholder_p, &p, radius)) return false;\n\n    return true;\n}"}, "lv_area_align": {"type": "Function", "def": "void lv_area_align(const lv_area_t * base, lv_area_t * to_align, lv_align_t align, lv_coord_t ofs_x, lv_coord_t ofs_y)", "sline": 329, "body": "{\n\n    lv_coord_t x;\n    lv_coord_t y;\n    switch(align) {\n        case LV_ALIGN_CENTER:\n            x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;\n            y = lv_area_get_height(base) / 2 - lv_area_get_height(to_align) / 2;\n            break;\n\n        case LV_ALIGN_TOP_LEFT:\n            x = 0;\n            y = 0;\n            break;\n        case LV_ALIGN_TOP_MID:\n            x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;\n            y = 0;\n            break;\n\n        case LV_ALIGN_TOP_RIGHT:\n            x = lv_area_get_width(base) - lv_area_get_width(to_align);\n            y = 0;\n            break;\n\n        case LV_ALIGN_BOTTOM_LEFT:\n            x = 0;\n            y = lv_area_get_height(base) - lv_area_get_height(to_align);\n            break;\n        case LV_ALIGN_BOTTOM_MID:\n            x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;\n            y = lv_area_get_height(base) - lv_area_get_height(to_align);\n            break;\n\n        case LV_ALIGN_BOTTOM_RIGHT:\n            x = lv_area_get_width(base) - lv_area_get_width(to_align);\n            y = lv_area_get_height(base) - lv_area_get_height(to_align);\n            break;\n\n        case LV_ALIGN_LEFT_MID:\n            x = 0;\n            y = lv_area_get_height(base) / 2 - lv_area_get_height(to_align) / 2;\n            break;\n\n        case LV_ALIGN_RIGHT_MID:\n            x = lv_area_get_width(base) - lv_area_get_width(to_align);\n            y = lv_area_get_height(base) / 2 - lv_area_get_height(to_align) / 2;\n            break;\n\n        case LV_ALIGN_OUT_TOP_LEFT:\n            x = 0;\n            y = -lv_area_get_height(to_align);\n            break;\n\n        case LV_ALIGN_OUT_TOP_MID:\n            x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;\n            y = -lv_area_get_height(to_align);\n            break;\n\n        case LV_ALIGN_OUT_TOP_RIGHT:\n            x = lv_area_get_width(base) - lv_area_get_width(to_align);\n            y = -lv_area_get_height(to_align);\n            break;\n\n        case LV_ALIGN_OUT_BOTTOM_LEFT:\n            x = 0;\n            y = lv_area_get_height(base);\n            break;\n\n        case LV_ALIGN_OUT_BOTTOM_MID:\n            x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;\n            y = lv_area_get_height(base);\n            break;\n\n        case LV_ALIGN_OUT_BOTTOM_RIGHT:\n            x = lv_area_get_width(base) - lv_area_get_width(to_align);\n            y = lv_area_get_height(base);\n            break;\n\n        case LV_ALIGN_OUT_LEFT_TOP:\n            x = -lv_area_get_width(to_align);\n            y = 0;\n            break;\n\n        case LV_ALIGN_OUT_LEFT_MID:\n            x = -lv_area_get_width(to_align);\n            y = lv_area_get_height(base) / 2 - lv_area_get_height(to_align) / 2;\n            break;\n\n        case LV_ALIGN_OUT_LEFT_BOTTOM:\n            x = -lv_area_get_width(to_align);\n            y = lv_area_get_height(base) - lv_area_get_height(to_align);\n            break;\n\n        case LV_ALIGN_OUT_RIGHT_TOP:\n            x = lv_area_get_width(base);\n            y = 0;\n            break;\n\n        case LV_ALIGN_OUT_RIGHT_MID:\n            x = lv_area_get_width(base);\n            y = lv_area_get_height(base) / 2 - lv_area_get_height(to_align) / 2;\n            break;\n\n        case LV_ALIGN_OUT_RIGHT_BOTTOM:\n            x = lv_area_get_width(base);\n            y = lv_area_get_height(base) - lv_area_get_height(to_align);\n            break;\n        default:\n            x = 0;\n            y = 0;\n            break;\n    }\n\n    x += base->x1;\n    y += base->y1;\n\n    lv_coord_t w = lv_area_get_width(to_align);\n    lv_coord_t h = lv_area_get_height(to_align);\n    to_align->x1 = x + ofs_x;\n    to_align->y1 = y + ofs_y;\n    to_align->x2 = to_align->x1 + w - 1;\n    to_align->y2 = to_align->y1 + h - 1;\n}"}, "carbit_updater/lvgl/src/misc/lv_area.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_area.c"}}, "carbit_updater/lvgl/src/extra/themes/default/lv_theme_default.h": {"lv_obj": {"type": "Variable", "def": "#include ../../../core/lv_obj.h", "sline": 16}, "lv_theme_default_init": {"type": "Function", "def": "lv_theme_t * lv_theme_default_init(lv_disp_t * disp, lv_color_t color_primary, lv_color_t color_secondary, bool dark,\n                                   const lv_font_t * font)", "sline": 39}, "lv_theme_default_get": {"type": "Function", "def": "lv_theme_t * lv_theme_default_get(void)", "sline": 46}, "lv_theme_default_is_inited": {"type": "Function", "def": "bool lv_theme_default_is_inited(void)", "sline": 52}, "carbit_updater/lvgl/src/extra/themes/default/lv_theme_default.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/themes/default/lv_theme_default.h"}}, "carbit_updater/lv_drivers/win_drv.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../lv_drv_conf.h", "sline": 20}, "carbit_updater/lv_drivers/win_drv.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/win_drv.h"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_28.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_montserrat_28.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_28.c"}}, "carbit_updater/lvgl/src/extra/libs/rlottie/lv_rlottie.h": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 16}, "carbit_updater/lvgl/src/extra/libs/rlottie/lv_rlottie.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/rlottie/lv_rlottie.h"}}, "carbit_updater/lvgl/src/font/lv_font_dejavu_16_persian_hebrew.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_dejavu_16_persian_hebrew.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_dejavu_16_persian_hebrew.c"}}, "carbit_updater/lvgl/src/misc/lv_utils.h": {"stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 16}, "_lv_utils_bsearch": {"type": "Function", "def": "void * _lv_utils_bsearch(const void * key, const void * base, uint32_t n, uint32_t size,\n                         int32_t (*cmp)(const void * pRef, const void * pElement))", "sline": 47}, "carbit_updater/lvgl/src/misc/lv_utils.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_utils.h"}}, "carbit_updater/lvgl/src/draw/lv_draw_line.c": {"stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 9}, "lv_draw_mask": {"type": "Variable", "def": "#include lv_draw_mask.h", "sline": 10, "include": ["carbit_updater/lvgl/src/draw/lv_draw_mask.h", null]}, "lv_draw_blend": {"type": "Variable", "def": "#include lv_draw_blend.h", "sline": 11, "include": ["carbit_updater/lvgl/src/draw/lv_draw_blend.h", null]}, "lv_refr": {"type": "Variable", "def": "#include ../core/lv_refr.h", "sline": 12}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 13}, "draw_line_skew": {"type": "Function", "def": "static void draw_line_skew(const lv_point_t * point1, const lv_point_t * point2,\n                                                 const lv_area_t * clip,\n                                                 const lv_draw_line_dsc_t * dsc)", "sline": 317, "body": "{\n#if LV_DRAW_COMPLEX\n    /*Keep the great y in p1*/\n    lv_point_t p1;\n    lv_point_t p2;\n    if(point1->y < point2->y) {\n        p1.y = point1->y;\n        p2.y = point2->y;\n        p1.x = point1->x;\n        p2.x = point2->x;\n    }\n    else {\n        p1.y = point2->y;\n        p2.y = point1->y;\n        p1.x = point2->x;\n        p2.x = point1->x;\n    }\n\n    int32_t xdiff = p2.x - p1.x;\n    int32_t ydiff = p2.y - p1.y;\n    bool flat = LV_ABS(xdiff) > LV_ABS(ydiff) ? true : false;\n\n    static const uint8_t wcorr[] = {\n        128, 128, 128, 129, 129, 130, 130, 131,\n        132, 133, 134, 135, 137, 138, 140, 141,\n        143, 145, 147, 149, 151, 153, 155, 158,\n        160, 162, 165, 167, 170, 173, 175, 178,\n        181,\n    };\n\n    int32_t w = dsc->width;\n    int32_t wcorr_i = 0;\n    if(flat) wcorr_i = (LV_ABS(ydiff) << 5) / LV_ABS(xdiff);\n    else wcorr_i = (LV_ABS(xdiff) << 5) / LV_ABS(ydiff);\n\n    w = (w * wcorr[wcorr_i] + 63) >> 7;     /*+ 63 for rounding*/\n    int32_t w_half0 = w >> 1;\n    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/\n\n    lv_area_t draw_area;\n    draw_area.x1 = LV_MIN(p1.x, p2.x) - w;\n    draw_area.x2 = LV_MAX(p1.x, p2.x) + w;\n    draw_area.y1 = LV_MIN(p1.y, p2.y) - w;\n    draw_area.y2 = LV_MAX(p1.y, p2.y) + w;\n\n    /*Get the union of `coords` and `clip`*/\n    /*`clip` is already truncated to the `draw_buf` size\n     *in 'lv_refr_area' function*/\n    bool is_common = _lv_area_intersect(&draw_area, &draw_area, clip);\n    if(is_common == false) return;\n\n    lv_draw_mask_line_param_t mask_left_param;\n    lv_draw_mask_line_param_t mask_right_param;\n    lv_draw_mask_line_param_t mask_top_param;\n    lv_draw_mask_line_param_t mask_bottom_param;\n\n    if(flat) {\n        if(xdiff > 0) {\n            lv_draw_mask_line_points_init(&mask_left_param, p1.x, p1.y - w_half0, p2.x, p2.y - w_half0,\n                                          LV_DRAW_MASK_LINE_SIDE_LEFT);\n            lv_draw_mask_line_points_init(&mask_right_param, p1.x, p1.y + w_half1, p2.x, p2.y + w_half1,\n                                          LV_DRAW_MASK_LINE_SIDE_RIGHT);\n        }\n        else {\n            lv_draw_mask_line_points_init(&mask_left_param, p1.x, p1.y + w_half1, p2.x, p2.y + w_half1,\n                                          LV_DRAW_MASK_LINE_SIDE_LEFT);\n            lv_draw_mask_line_points_init(&mask_right_param, p1.x, p1.y - w_half0, p2.x, p2.y - w_half0,\n                                          LV_DRAW_MASK_LINE_SIDE_RIGHT);\n        }\n    }\n    else {\n        lv_draw_mask_line_points_init(&mask_left_param, p1.x + w_half1, p1.y, p2.x + w_half1, p2.y,\n                                      LV_DRAW_MASK_LINE_SIDE_LEFT);\n        lv_draw_mask_line_points_init(&mask_right_param, p1.x - w_half0, p1.y, p2.x - w_half0, p2.y,\n                                      LV_DRAW_MASK_LINE_SIDE_RIGHT);\n    }\n\n    /*Use the normal vector for the endings*/\n\n    int16_t mask_left_id = lv_draw_mask_add(&mask_left_param, NULL);\n    int16_t mask_right_id = lv_draw_mask_add(&mask_right_param, NULL);\n    int16_t mask_top_id = LV_MASK_ID_INV;\n    int16_t mask_bottom_id = LV_MASK_ID_INV;\n\n    if(!dsc->raw_end) {\n        lv_draw_mask_line_points_init(&mask_top_param, p1.x, p1.y, p1.x - ydiff, p1.y + xdiff, LV_DRAW_MASK_LINE_SIDE_BOTTOM);\n        lv_draw_mask_line_points_init(&mask_bottom_param, p2.x, p2.y, p2.x - ydiff, p2.y + xdiff,  LV_DRAW_MASK_LINE_SIDE_TOP);\n        mask_top_id = lv_draw_mask_add(&mask_top_param, NULL);\n        mask_bottom_id = lv_draw_mask_add(&mask_bottom_param, NULL);\n    }\n\n    lv_disp_t * disp = _lv_refr_get_disp_refreshing();\n    lv_disp_draw_buf_t * draw_buf = lv_disp_get_draw_buf(disp);\n\n    const lv_area_t * disp_area = &draw_buf->area;\n\n    /*Store the coordinates of the `draw_a` relative to the draw_buf*/\n    draw_area.x1 -= disp_area->x1;\n    draw_area.y1 -= disp_area->y1;\n    draw_area.x2 -= disp_area->x1;\n    draw_area.y2 -= disp_area->y1;\n\n    /*The real draw area is around the line.\n     *It's easy to calculate with steep lines, but the area can be very wide with very flat lines.\n     *So deal with it only with steep lines.*/\n    int32_t draw_area_w = lv_area_get_width(&draw_area);\n\n    /*Draw the background line by line*/\n    int32_t h;\n    uint32_t hor_res = (uint32_t)lv_disp_get_hor_res(disp);\n    size_t mask_buf_size = LV_MIN(lv_area_get_size(&draw_area), hor_res);\n    lv_opa_t * mask_buf = lv_mem_buf_get(mask_buf_size);\n\n    lv_area_t fill_area;\n    fill_area.x1 = draw_area.x1 + disp_area->x1;\n    fill_area.x2 = draw_area.x2 + disp_area->x1;\n    fill_area.y1 = draw_area.y1 + disp_area->y1;\n    fill_area.y2 = fill_area.y1;\n\n    int32_t x = draw_buf->area.x1 + draw_area.x1;\n\n    uint32_t mask_p = 0;\n\n    lv_memset_ff(mask_buf, mask_buf_size);\n    /*Fill the first row with 'color'*/\n    for(h = draw_area.y1 + disp_area->y1; h <= draw_area.y2 + disp_area->y1; h++) {\n\n        lv_draw_mask_res_t mask_res = lv_draw_mask_apply(&mask_buf[mask_p], x, h, draw_area_w);\n        if(mask_res == LV_DRAW_MASK_RES_TRANSP) {\n            lv_memset_00(&mask_buf[mask_p], draw_area_w);\n        }\n\n        mask_p += draw_area_w;\n        if((uint32_t) mask_p + draw_area_w < mask_buf_size) {\n            fill_area.y2 ++;\n        }\n        else {\n            _lv_blend_fill(&fill_area, clip,\n                           dsc->color, mask_buf, LV_DRAW_MASK_RES_CHANGED, dsc->opa,\n                           dsc->blend_mode);\n\n            fill_area.y1 = fill_area.y2 + 1;\n            fill_area.y2 = fill_area.y1;\n            mask_p = 0;\n            lv_memset_ff(mask_buf, mask_buf_size);\n        }\n    }\n\n    /*Flush the last part*/\n    if(fill_area.y1 != fill_area.y2) {\n        fill_area.y2--;\n        _lv_blend_fill(&fill_area, clip,\n                       dsc->color, mask_buf, LV_DRAW_MASK_RES_CHANGED, dsc->opa,\n                       dsc->blend_mode);\n\n    }\n\n    lv_mem_buf_release(mask_buf);\n\n    lv_draw_mask_free_param(&mask_left_param);\n    lv_draw_mask_free_param(&mask_right_param);\n    if(mask_top_id != LV_MASK_ID_INV) lv_draw_mask_free_param(&mask_top_param);\n    if(mask_bottom_id != LV_MASK_ID_INV) lv_draw_mask_free_param(&mask_bottom_param);\n    lv_draw_mask_remove_id(mask_left_id);\n    lv_draw_mask_remove_id(mask_right_id);\n    lv_draw_mask_remove_id(mask_top_id);\n    lv_draw_mask_remove_id(mask_bottom_id);\n#else\n    LV_UNUSED(point1);\n    LV_UNUSED(point2);\n    LV_UNUSED(clip);\n    LV_UNUSED(dsc);\n    LV_LOG_WARN(\"Can't draw skewed line with LV_DRAW_COMPLEX == 0\");\n#endif /*LV_DRAW_COMPLEX*/\n}"}, "draw_line_hor": {"type": "Function", "def": "static void draw_line_hor(const lv_point_t * point1, const lv_point_t * point2,\n                                                const lv_area_t * clip,\n                                                const lv_draw_line_dsc_t * dsc)", "sline": 120, "body": "{\n    lv_opa_t opa = dsc->opa;\n\n    int32_t w = dsc->width - 1;\n    int32_t w_half0 = w >> 1;\n    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/\n\n\n\n    lv_area_t draw_area;\n    draw_area.x1 = LV_MIN(point1->x, point2->x);\n    draw_area.x2 = LV_MAX(point1->x, point2->x)  - 1;\n    draw_area.y1 = point1->y - w_half1;\n    draw_area.y2 = point1->y + w_half0;\n\n    bool dashed = dsc->dash_gap && dsc->dash_width ? true : false;\n    bool simple_mode = true;\n    if(lv_draw_mask_is_any(&draw_area)) simple_mode = false;\n    else if(dashed) simple_mode = false;\n\n    /*If there is no mask then simply draw a rectangle*/\n    if(simple_mode) {\n        _lv_blend_fill(clip, &draw_area,\n                       dsc->color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa,\n                       dsc->blend_mode);\n    }\n#if LV_DRAW_COMPLEX\n    /*If there other mask apply it*/\n    else {\n        lv_disp_t * disp = _lv_refr_get_disp_refreshing();\n        lv_disp_draw_buf_t * draw_buf = lv_disp_get_draw_buf(disp);\n        const lv_area_t * disp_area = &draw_buf->area;\n        /*Get clipped fill area which is the real draw area.\n         *It is always the same or inside `fill_area`*/\n        bool is_common;\n        is_common = _lv_area_intersect(&draw_area, clip, &draw_area);\n        if(!is_common) return;\n\n        /*Now `draw_area` has absolute coordinates.\n         *Make it relative to `disp_area` to simplify draw to `disp_buf`*/\n        draw_area.x1 -= disp_area->x1;\n        draw_area.y1 -= disp_area->y1;\n        draw_area.x2 -= disp_area->x1;\n        draw_area.y2 -= disp_area->y1;\n\n        int32_t draw_area_w = lv_area_get_width(&draw_area);\n\n        lv_area_t fill_area;\n        fill_area.x1 = draw_area.x1 + disp_area->x1;\n        fill_area.x2 = draw_area.x2 + disp_area->x1;\n        fill_area.y1 = draw_area.y1 + disp_area->y1;\n        fill_area.y2 = fill_area.y1;\n\n        lv_coord_t dash_start = 0;\n        if(dashed) {\n            dash_start = (draw_buf->area.x1 + draw_area.x1) % (dsc->dash_gap + dsc->dash_width);\n        }\n\n        lv_opa_t * mask_buf = lv_mem_buf_get(draw_area_w);\n        int32_t h;\n        for(h = draw_area.y1; h <= draw_area.y2; h++) {\n            lv_memset_ff(mask_buf, draw_area_w);\n            lv_draw_mask_res_t mask_res = lv_draw_mask_apply(mask_buf, draw_buf->area.x1 + draw_area.x1, draw_buf->area.y1 + h,\n                                                             draw_area_w);\n\n            if(dashed) {\n                if(mask_res != LV_DRAW_MASK_RES_TRANSP) {\n                    lv_coord_t dash_cnt = dash_start;\n                    lv_coord_t i;\n                    for(i = 0; i < draw_area_w; i++, dash_cnt++) {\n                        if(dash_cnt <= dsc->dash_width) {\n                            int16_t diff = dsc->dash_width - dash_cnt;\n                            i += diff;\n                            dash_cnt += diff;\n                        }\n                        else if(dash_cnt >= dsc->dash_gap + dsc->dash_width) {\n                            dash_cnt = 0;\n                        }\n                        else {\n                            mask_buf[i] = 0x00;\n                        }\n                    }\n\n                    mask_res = LV_DRAW_MASK_RES_CHANGED;\n                }\n            }\n\n            _lv_blend_fill(clip, &fill_area,\n                           dsc->color, mask_buf, mask_res, dsc->opa,\n                           dsc->blend_mode);\n\n            fill_area.y1++;\n            fill_area.y2++;\n        }\n        lv_mem_buf_release(mask_buf);\n    }\n#endif /*LV_DRAW_COMPLEX*/\n}"}, "draw_line_ver": {"type": "Function", "def": "static void draw_line_ver(const lv_point_t * point1, const lv_point_t * point2,\n                                                const lv_area_t * clip,\n                                                const lv_draw_line_dsc_t * dsc)", "sline": 222, "body": "{\n    lv_opa_t opa = dsc->opa;\n\n    int32_t w = dsc->width - 1;\n    int32_t w_half0 = w >> 1;\n    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/\n\n    lv_area_t draw_area;\n    draw_area.x1 = point1->x - w_half1;\n    draw_area.x2 = point1->x + w_half0;\n    draw_area.y1 = LV_MIN(point1->y, point2->y);\n    draw_area.y2 = LV_MAX(point1->y, point2->y) - 1;\n\n    bool dashed = dsc->dash_gap && dsc->dash_width ? true : false;\n    bool simple_mode = true;\n    if(lv_draw_mask_is_any(&draw_area)) simple_mode = false;\n    else if(dashed) simple_mode = false;\n\n    /*If there is no mask then simply draw a rectangle*/\n    if(simple_mode) {\n        _lv_blend_fill(clip, &draw_area,\n                       dsc->color,  NULL, LV_DRAW_MASK_RES_FULL_COVER, opa,\n                       dsc->blend_mode);\n    }\n\n#if LV_DRAW_COMPLEX\n    /*If there other mask apply it*/\n    else {\n        lv_disp_t * disp = _lv_refr_get_disp_refreshing();\n        lv_disp_draw_buf_t * draw_buf = lv_disp_get_draw_buf(disp);\n        const lv_area_t * disp_area = &draw_buf->area;\n        /*Get clipped fill area which is the real draw area.\n         *It is always the same or inside `fill_area`*/\n        bool is_common;\n        is_common = _lv_area_intersect(&draw_area, clip, &draw_area);\n        if(!is_common) return;\n\n        /*Now `draw_area` has absolute coordinates.\n         *Make it relative to `disp_area` to simplify draw to `disp_buf`*/\n        draw_area.x1 -= draw_buf->area.x1;\n        draw_area.y1 -= draw_buf->area.y1;\n        draw_area.x2 -= draw_buf->area.x1;\n        draw_area.y2 -= draw_buf->area.y1;\n\n        int32_t draw_area_w = lv_area_get_width(&draw_area);\n\n        lv_area_t fill_area;\n        fill_area.x1 = draw_area.x1 + disp_area->x1;\n        fill_area.x2 = draw_area.x2 + disp_area->x1;\n        fill_area.y1 = draw_area.y1 + disp_area->y1;\n        fill_area.y2 = fill_area.y1;\n\n        lv_opa_t * mask_buf = lv_mem_buf_get(draw_area_w);\n\n        lv_coord_t dash_start = 0;\n        if(dashed) {\n            dash_start = (draw_buf->area.y1 + draw_area.y1) % (dsc->dash_gap + dsc->dash_width);\n        }\n\n        lv_coord_t dash_cnt = dash_start;\n\n        int32_t h;\n        for(h = draw_area.y1; h <= draw_area.y2; h++) {\n            lv_memset_ff(mask_buf, draw_area_w);\n            lv_draw_mask_res_t mask_res = lv_draw_mask_apply(mask_buf, draw_buf->area.x1 + draw_area.x1, draw_buf->area.y1 + h,\n                                                             draw_area_w);\n\n            if(dashed) {\n                if(mask_res != LV_DRAW_MASK_RES_TRANSP) {\n                    if(dash_cnt > dsc->dash_width) {\n                        mask_res = LV_DRAW_MASK_RES_TRANSP;\n                    }\n\n                    if(dash_cnt >= dsc->dash_gap + dsc->dash_width) {\n                        dash_cnt = 0;\n                    }\n                }\n                dash_cnt ++;\n            }\n\n            _lv_blend_fill(clip, &fill_area,\n                           dsc->color, mask_buf, mask_res, dsc->opa,\n                           LV_BLEND_MODE_NORMAL);\n\n            fill_area.y1++;\n            fill_area.y2++;\n        }\n        lv_mem_buf_release(mask_buf);\n    }\n#endif /*LV_DRAW_COMPLEX*/\n}"}, "lv_draw_line_dsc_init": {"type": "Function", "def": "void lv_draw_line_dsc_init(lv_draw_line_dsc_t * dsc)", "sline": 49, "body": "{\n    lv_memset_00(dsc, sizeof(lv_draw_line_dsc_t));\n    dsc->width = 1;\n    dsc->opa = LV_OPA_COVER;\n    dsc->color = lv_color_black();\n}"}, "lv_draw_line": {"type": "Function", "def": "void lv_draw_line(const lv_point_t * point1, const lv_point_t * point2, const lv_area_t * clip,\n                                        const lv_draw_line_dsc_t * dsc)", "sline": 64, "body": "{\n    if(dsc->width == 0) return;\n    if(dsc->opa <= LV_OPA_MIN) return;\n\n    if(point1->x == point2->x && point1->y == point2->y) return;\n\n    lv_area_t clip_line;\n    clip_line.x1 = LV_MIN(point1->x, point2->x) - dsc->width / 2;\n    clip_line.x2 = LV_MAX(point1->x, point2->x) + dsc->width / 2;\n    clip_line.y1 = LV_MIN(point1->y, point2->y) - dsc->width / 2;\n    clip_line.y2 = LV_MAX(point1->y, point2->y) + dsc->width / 2;\n\n    bool is_common;\n    is_common = _lv_area_intersect(&clip_line, &clip_line, clip);\n    if(!is_common) return;\n\n    if(point1->y == point2->y) draw_line_hor(point1, point2, &clip_line, dsc);\n    else if(point1->x == point2->x) draw_line_ver(point1, point2, &clip_line, dsc);\n    else draw_line_skew(point1, point2, &clip_line, dsc);\n\n    if(dsc->round_end || dsc->round_start) {\n        lv_draw_rect_dsc_t cir_dsc;\n        lv_draw_rect_dsc_init(&cir_dsc);\n        cir_dsc.bg_color = dsc->color;\n        cir_dsc.radius = LV_RADIUS_CIRCLE;\n        cir_dsc.bg_opa = dsc->opa;\n\n        int32_t r = (dsc->width >> 1);\n        int32_t r_corr = (dsc->width & 1) ? 0 : 1;\n        lv_area_t cir_area;\n\n        if(dsc->round_start) {\n            cir_area.x1 = point1->x - r;\n            cir_area.y1 = point1->y - r;\n            cir_area.x2 = point1->x + r - r_corr;\n            cir_area.y2 = point1->y + r - r_corr ;\n            lv_draw_rect(&cir_area, clip, &cir_dsc);\n        }\n\n        if(dsc->round_end) {\n            cir_area.x1 = point2->x - r;\n            cir_area.y1 = point2->y - r;\n            cir_area.x2 = point2->x + r - r_corr;\n            cir_area.y2 = point2->y + r - r_corr ;\n            lv_draw_rect(&cir_area, clip, &cir_dsc);\n        }\n    }\n}"}, "carbit_updater/lvgl/src/draw/lv_draw_line.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_draw_line.c"}}, "carbit_updater/lvgl/src/font/lv_font.c": {"lv_font": {"type": "Variable", "def": "#include lv_font.h", "sline": 10, "include": ["carbit_updater/lvgl/src/font/lv_font.h", null]}, "lv_utils": {"type": "Variable", "def": "#include ../misc/lv_utils.h", "sline": 11}, "lv_log": {"type": "Variable", "def": "#include ../misc/lv_log.h", "sline": 12}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 13}, "lv_font_get_glyph_bitmap": {"type": "Function", "def": "const uint8_t * lv_font_get_glyph_bitmap(const lv_font_t * font_p, uint32_t letter)", "sline": 49, "body": "{\n    LV_ASSERT_NULL(font_p);\n    return font_p->get_glyph_bitmap(font_p, letter);\n}"}, "lv_font_get_glyph_dsc": {"type": "Function", "def": "bool lv_font_get_glyph_dsc(const lv_font_t * font_p, lv_font_glyph_dsc_t * dsc_out, uint32_t letter,\n                           uint32_t letter_next)", "sline": 63, "body": "{\n    LV_ASSERT_NULL(font_p);\n    return font_p->get_glyph_dsc(font_p, dsc_out, letter, letter_next);\n}"}, "lv_font_get_glyph_width": {"type": "Function", "def": "uint16_t lv_font_get_glyph_width(const lv_font_t * font, uint32_t letter, uint32_t letter_next)", "sline": 77, "body": "{\n    LV_ASSERT_NULL(font);\n    lv_font_glyph_dsc_t g;\n    bool ret;\n    ret = lv_font_get_glyph_dsc(font, &g, letter, letter_next);\n    if(ret) return g.adv_w;\n    else return 0;\n}"}, "carbit_updater/lvgl/src/font/lv_font.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font.c"}}, "carbit_updater/lvgl/src/extra/libs/png/lv_png.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../../../lv_conf_internal.h", "sline": 16}, "carbit_updater/lvgl/src/extra/libs/png/lv_png.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/png/lv_png.h"}}, "carbit_updater/lvgl/src/misc/lv_fs.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 18}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 19}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_fs.h:34:1)": {"type": "Enum", "def": "enum {\n    LV_FS_RES_OK = 0,\n    LV_FS_RES_HW_ERR,     /*Low level hardware error*/\n    LV_FS_RES_FS_ERR,     /*Error in the file system structure*/\n    LV_FS_RES_NOT_EX,     /*Driver, file or directory is not exists*/\n    LV_FS_RES_FULL,       /*Disk full*/\n    LV_FS_RES_LOCKED,     /*The file is already opened*/\n    LV_FS_RES_DENIED,     /*Access denied. Check 'fs_open' modes and write protect*/\n    LV_FS_RES_BUSY,       /*The file system now can't handle it, try later*/\n    LV_FS_RES_TOUT,       /*Process time outed*/\n    LV_FS_RES_NOT_IMP,    /*Requested function is not implemented*/\n    LV_FS_RES_OUT_OF_MEM, /*Not enough memory for an internal operation*/\n    LV_FS_RES_INV_PARAM,  /*Invalid parameter among arguments*/\n    LV_FS_RES_UNKNOWN,    /*Other unknown error*/\n}", "sline": 34, "docstring": "/**"}, "lv_fs_res_t": {"type": "Variable", "def": "typedef uint8_t lv_fs_res_t", "sline": 49}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_fs.h:54:1)": {"type": "Enum", "def": "enum {\n    LV_FS_MODE_WR = 0x01,\n    LV_FS_MODE_RD = 0x02,\n}", "sline": 54, "docstring": "/**"}, "lv_fs_mode_t": {"type": "Variable", "def": "typedef uint8_t lv_fs_mode_t", "sline": 58}, "lv_fs_whence_t": {"type": "Variable", "def": "typedef enum {\n    LV_FS_SEEK_SET = 0x00,      /**< Set the position from absolutely (from the start of file)*/\n    LV_FS_SEEK_CUR = 0x01,      /**< Set the position from the current position*/\n    LV_FS_SEEK_END = 0x02,      /**< Set the position from the end of the file*/\n} lv_fs_whence_t", "sline": 68, "docstring": "/**"}, "_lv_fs_drv_t.letter": {"type": "Variable", "def": "char letter", "sline": 71, "in_struct": "_lv_fs_drv_t"}, "_lv_fs_drv_t.bool": {"type": "Variable", "def": "bool (*ready_cb)(struct _lv_fs_drv_t * drv)", "sline": 72, "in_struct": "_lv_fs_drv_t"}, "_lv_fs_drv_t.open_cb": {"type": "Variable", "def": "void * (*open_cb)(struct _lv_fs_drv_t * drv, const char * path, lv_fs_mode_t mode)", "sline": 74, "in_struct": "_lv_fs_drv_t"}, "_lv_fs_drv_t.close_cb": {"type": "Variable", "def": "lv_fs_res_t (*close_cb)(struct _lv_fs_drv_t * drv, void * file_p)", "sline": 75, "in_struct": "_lv_fs_drv_t"}, "_lv_fs_drv_t.read_cb": {"type": "Variable", "def": "lv_fs_res_t (*read_cb)(struct _lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br)", "sline": 76, "in_struct": "_lv_fs_drv_t"}, "_lv_fs_drv_t.write_cb": {"type": "Variable", "def": "lv_fs_res_t (*write_cb)(struct _lv_fs_drv_t * drv, void * file_p, const void * buf, uint32_t btw, uint32_t * bw)", "sline": 77, "in_struct": "_lv_fs_drv_t"}, "_lv_fs_drv_t.seek_cb": {"type": "Variable", "def": "lv_fs_res_t (*seek_cb)(struct _lv_fs_drv_t * drv, void * file_p, uint32_t pos, lv_fs_whence_t whence)", "sline": 78, "in_struct": "_lv_fs_drv_t"}, "_lv_fs_drv_t.tell_cb": {"type": "Variable", "def": "lv_fs_res_t (*tell_cb)(struct _lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p)", "sline": 79, "in_struct": "_lv_fs_drv_t"}, "_lv_fs_drv_t.dir_open_cb": {"type": "Variable", "def": "void * (*dir_open_cb)(struct _lv_fs_drv_t * drv, const char * path)", "sline": 81, "in_struct": "_lv_fs_drv_t"}, "_lv_fs_drv_t.dir_read_cb": {"type": "Variable", "def": "lv_fs_res_t (*dir_read_cb)(struct _lv_fs_drv_t * drv, void * rddir_p, char * fn)", "sline": 82, "in_struct": "_lv_fs_drv_t"}, "_lv_fs_drv_t.dir_close_cb": {"type": "Variable", "def": "lv_fs_res_t (*dir_close_cb)(struct _lv_fs_drv_t * drv, void * rddir_p)", "sline": 83, "in_struct": "_lv_fs_drv_t"}, "_lv_fs_drv_t.user_data": {"type": "Variable", "def": "void * user_data", "sline": 86, "in_struct": "_lv_fs_drv_t"}, "_lv_fs_drv_t": {"type": "Struct", "def": "struct _lv_fs_drv_t {\n    char letter;\n    bool (*ready_cb)(struct _lv_fs_drv_t * drv);\n\n    void * (*open_cb)(struct _lv_fs_drv_t * drv, const char * path, lv_fs_mode_t mode);\n    lv_fs_res_t (*close_cb)(struct _lv_fs_drv_t * drv, void * file_p);\n    lv_fs_res_t (*read_cb)(struct _lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br);\n    lv_fs_res_t (*write_cb)(struct _lv_fs_drv_t * drv, void * file_p, const void * buf, uint32_t btw, uint32_t * bw);\n    lv_fs_res_t (*seek_cb)(struct _lv_fs_drv_t * drv, void * file_p, uint32_t pos, lv_fs_whence_t whence);\n    lv_fs_res_t (*tell_cb)(struct _lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p);\n\n    void * (*dir_open_cb)(struct _lv_fs_drv_t * drv, const char * path);\n    lv_fs_res_t (*dir_read_cb)(struct _lv_fs_drv_t * drv, void * rddir_p, char * fn);\n    lv_fs_res_t (*dir_close_cb)(struct _lv_fs_drv_t * drv, void * rddir_p);\n\n#if LV_USE_USER_DATA\n    void * user_data; /**< Custom file user data*/\n#endif\n}", "sline": 70, "body": "char letter\nbool (*ready_cb)(struct _lv_fs_drv_t * drv)\nvoid * (*open_cb)(struct _lv_fs_drv_t * drv, const char * path, lv_fs_mode_t mode)\nlv_fs_res_t (*close_cb)(struct _lv_fs_drv_t * drv, void * file_p)\nlv_fs_res_t (*read_cb)(struct _lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br)\nlv_fs_res_t (*write_cb)(struct _lv_fs_drv_t * drv, void * file_p, const void * buf, uint32_t btw, uint32_t * bw)\nlv_fs_res_t (*seek_cb)(struct _lv_fs_drv_t * drv, void * file_p, uint32_t pos, lv_fs_whence_t whence)\nlv_fs_res_t (*tell_cb)(struct _lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p)\nvoid * (*dir_open_cb)(struct _lv_fs_drv_t * drv, const char * path)\nlv_fs_res_t (*dir_read_cb)(struct _lv_fs_drv_t * drv, void * rddir_p, char * fn)\nlv_fs_res_t (*dir_close_cb)(struct _lv_fs_drv_t * drv, void * rddir_p)\nvoid * user_data\n"}, "lv_fs_drv_t": {"type": "Variable", "def": "typedef struct _lv_fs_drv_t {\n    char letter;\n    bool (*ready_cb)(struct _lv_fs_drv_t * drv);\n\n    void * (*open_cb)(struct _lv_fs_drv_t * drv, const char * path, lv_fs_mode_t mode);\n    lv_fs_res_t (*close_cb)(struct _lv_fs_drv_t * drv, void * file_p);\n    lv_fs_res_t (*read_cb)(struct _lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br);\n    lv_fs_res_t (*write_cb)(struct _lv_fs_drv_t * drv, void * file_p, const void * buf, uint32_t btw, uint32_t * bw);\n    lv_fs_res_t (*seek_cb)(struct _lv_fs_drv_t * drv, void * file_p, uint32_t pos, lv_fs_whence_t whence);\n    lv_fs_res_t (*tell_cb)(struct _lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p);\n\n    void * (*dir_open_cb)(struct _lv_fs_drv_t * drv, const char * path);\n    lv_fs_res_t (*dir_read_cb)(struct _lv_fs_drv_t * drv, void * rddir_p, char * fn);\n    lv_fs_res_t (*dir_close_cb)(struct _lv_fs_drv_t * drv, void * rddir_p);\n\n#if LV_USE_USER_DATA\n    void * user_data; /**< Custom file user data*/\n#endif\n} lv_fs_drv_t", "sline": 88}, "lv_fs_file_t.file_d": {"type": "Variable", "def": "void * file_d", "sline": 91, "in_struct": "lv_fs_file_t"}, "lv_fs_file_t.drv": {"type": "Variable", "def": "lv_fs_drv_t * drv", "sline": 92, "in_struct": "lv_fs_file_t"}, "lv_fs_file_t": {"type": "Variable", "def": "typedef struct {\n    void * file_d;\n    lv_fs_drv_t * drv;\n} lv_fs_file_t", "sline": 93}, "lv_fs_dir_t.dir_d": {"type": "Variable", "def": "void * dir_d", "sline": 96, "in_struct": "lv_fs_dir_t"}, "lv_fs_dir_t.drv": {"type": "Variable", "def": "lv_fs_drv_t * drv", "sline": 97, "in_struct": "lv_fs_dir_t"}, "lv_fs_dir_t": {"type": "Variable", "def": "typedef struct {\n    void * dir_d;\n    lv_fs_drv_t * drv;\n} lv_fs_dir_t", "sline": 98}, "_lv_fs_init": {"type": "Function", "def": "void _lv_fs_init(void)", "sline": 107}, "lv_fs_drv_init": {"type": "Function", "def": "void lv_fs_drv_init(lv_fs_drv_t * drv)", "sline": 115}, "lv_fs_drv_register": {"type": "Function", "def": "void lv_fs_drv_register(lv_fs_drv_t * drv)", "sline": 123}, "lv_fs_get_drv": {"type": "Function", "def": "lv_fs_drv_t * lv_fs_get_drv(char letter)", "sline": 130}, "lv_fs_is_ready": {"type": "Function", "def": "bool lv_fs_is_ready(char letter)", "sline": 138}, "lv_fs_open": {"type": "Function", "def": "lv_fs_res_t lv_fs_open(lv_fs_file_t * file_p, const char * path, lv_fs_mode_t mode)", "sline": 147, "rels": [["lv_fs_res_t", null, "Typeof"]]}, "lv_fs_close": {"type": "Function", "def": "lv_fs_res_t lv_fs_close(lv_fs_file_t * file_p)", "sline": 154, "rels": [["lv_fs_res_t", null, "Typeof"]]}, "lv_fs_read": {"type": "Function", "def": "lv_fs_res_t lv_fs_read(lv_fs_file_t * file_p, void * buf, uint32_t btr, uint32_t * br)", "sline": 164, "rels": [["lv_fs_res_t", null, "Typeof"]]}, "lv_fs_write": {"type": "Function", "def": "lv_fs_res_t lv_fs_write(lv_fs_file_t * file_p, const void * buf, uint32_t btw, uint32_t * bw)", "sline": 174, "rels": [["lv_fs_res_t", null, "Typeof"]]}, "lv_fs_seek": {"type": "Function", "def": "lv_fs_res_t lv_fs_seek(lv_fs_file_t * file_p, uint32_t pos, lv_fs_whence_t whence)", "sline": 183, "rels": [["lv_fs_res_t", null, "Typeof"]]}, "lv_fs_tell": {"type": "Function", "def": "lv_fs_res_t lv_fs_tell(lv_fs_file_t * file_p, uint32_t * pos)", "sline": 191, "rels": [["lv_fs_res_t", null, "Typeof"]]}, "lv_fs_dir_open": {"type": "Function", "def": "lv_fs_res_t lv_fs_dir_open(lv_fs_dir_t * rddir_p, const char * path)", "sline": 199, "rels": [["lv_fs_res_t", null, "Typeof"]]}, "lv_fs_dir_read": {"type": "Function", "def": "lv_fs_res_t lv_fs_dir_read(lv_fs_dir_t * rddir_p, char * fn)", "sline": 208, "rels": [["lv_fs_res_t", null, "Typeof"]]}, "lv_fs_dir_close": {"type": "Function", "def": "lv_fs_res_t lv_fs_dir_close(lv_fs_dir_t * rddir_p)", "sline": 215, "rels": [["lv_fs_res_t", null, "Typeof"]]}, "lv_fs_get_letters": {"type": "Function", "def": "char * lv_fs_get_letters(char * buf)", "sline": 222}, "lv_fs_get_ext": {"type": "Function", "def": "const char * lv_fs_get_ext(const char * fn)", "sline": 229}, "lv_fs_up": {"type": "Function", "def": "char * lv_fs_up(char * path)", "sline": 236}, "lv_fs_get_last": {"type": "Function", "def": "const char * lv_fs_get_last(const char * path)", "sline": 243}, "carbit_updater/lvgl/src/misc/lv_fs.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_fs.h"}}, "carbit_updater/lvgl/src/extra/widgets/keyboard/lv_keyboard.c": {"lv_keyboard": {"type": "Variable", "def": "#include lv_keyboard.h", "sline": 10, "include": ["carbit_updater/lvgl/src/extra/widgets/keyboard/lv_keyboard.h", null]}, "lv_textarea": {"type": "Variable", "def": "#include ../../../widgets/lv_textarea.h", "sline": 13}, "lv_assert": {"type": "Variable", "def": "#include ../../../misc/lv_assert.h", "sline": 14}, "stdlib": {"type": "Variable", "def": "#include stdlib.h", "sline": 16}, "lv_keyboard_constructor": {"type": "Function", "def": "static void lv_keyboard_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 373, "body": "{\n    LV_UNUSED(class_p);\n    lv_obj_clear_flag(obj, LV_OBJ_FLAG_CLICK_FOCUSABLE);\n\n    lv_keyboard_t * keyboard = (lv_keyboard_t *)obj;\n    keyboard->ta         = NULL;\n    keyboard->mode       = LV_KEYBOARD_MODE_TEXT_LOWER;\n    keyboard->popovers   = 0;\n\n    lv_obj_align(obj, LV_ALIGN_BOTTOM_MID, 0, 0);\n    lv_obj_add_event_cb(obj, lv_keyboard_def_event_cb, LV_EVENT_VALUE_CHANGED, NULL);\n    lv_obj_set_style_base_dir(obj, LV_BASE_DIR_LTR, 0);\n\n    lv_keyboard_update_map(obj);\n}"}, "lv_keyboard_update_map": {"type": "Function", "def": "static void lv_keyboard_update_map(lv_obj_t * obj)", "sline": 394, "body": "{\n    lv_keyboard_t * keyboard = (lv_keyboard_t *)obj;\n    lv_btnmatrix_set_map(obj, kb_map[keyboard->mode]);\n    lv_keyboard_update_ctrl_map(obj);\n}"}, "lv_keyboard_update_ctrl_map": {"type": "Function", "def": "static void lv_keyboard_update_ctrl_map(lv_obj_t * obj)", "sline": 405, "body": "{\n    lv_keyboard_t * keyboard = (lv_keyboard_t *)obj;\n\n    if (keyboard->popovers) {\n        /*Apply the current control map (already includes LV_BTNMATRIX_CTRL_POPOVER flags)*/\n        lv_btnmatrix_set_ctrl_map(obj, kb_ctrl[keyboard->mode]);\n    } else {\n        /*Make a copy of the current control map*/\n        lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;\n        lv_btnmatrix_ctrl_t * ctrl_map = lv_mem_alloc(btnm->btn_cnt * sizeof(lv_btnmatrix_ctrl_t));\n        lv_memcpy(ctrl_map, kb_ctrl[keyboard->mode], sizeof(lv_btnmatrix_ctrl_t) * btnm->btn_cnt);\n\n        /*Remove all LV_BTNMATRIX_CTRL_POPOVER flags*/\n        for(uint16_t i = 0; i < btnm->btn_cnt; i++) {\n            ctrl_map[i] &= (~LV_BTNMATRIX_CTRL_POPOVER);\n        }\n\n        /*Apply new control map and clean up*/\n        lv_btnmatrix_set_ctrl_map(obj, ctrl_map);\n        lv_mem_free(ctrl_map);\n    }\n}"}, "lv_keyboard_class": {"type": "Variable", "def": "const lv_obj_class_t lv_keyboard_class = {\n    .constructor_cb = lv_keyboard_constructor,\n    .width_def = LV_PCT(100),\n    .height_def = LV_PCT(50),\n    .instance_size = sizeof(lv_keyboard_t),\n    .editable = 1,\n    .base_class = &lv_btnmatrix_class\n}", "sline": 40}, "default_kb_map_lc": {"type": "Variable", "def": "static const char * const default_kb_map_lc[] = {\"1#\", \"q\", \"w\", \"e\", \"r\", \"t\", \"y\", \"u\", \"i\", \"o\", \"p\", LV_SYMBOL_BACKSPACE, \"\\n\",\n                                                 \"ABC\", \"a\", \"s\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", LV_SYMBOL_NEW_LINE, \"\\n\",\n                                                 \"_\", \"-\", \"z\", \"x\", \"c\", \"v\", \"b\", \"n\", \"m\", \".\", \",\", \":\", \"\\n\",\n                                                 LV_SYMBOL_KEYBOARD, LV_SYMBOL_LEFT, \" \", LV_SYMBOL_RIGHT, LV_SYMBOL_OK, \"\"\n                                                }", "sline": 49}, "default_kb_ctrl_lc_map": {"type": "Variable", "def": "static const lv_btnmatrix_ctrl_t default_kb_ctrl_lc_map[] = {\n    LV_KEYBOARD_CTRL_BTN_FLAGS | 5, LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_BTNMATRIX_CTRL_CHECKED | 7,\n    LV_KEYBOARD_CTRL_BTN_FLAGS | 6, LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_BTNMATRIX_CTRL_CHECKED | 7,\n    LV_BTNMATRIX_CTRL_CHECKED | LV_KB_BTN(1), LV_BTNMATRIX_CTRL_CHECKED | LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_BTNMATRIX_CTRL_CHECKED | LV_KB_BTN(1), LV_BTNMATRIX_CTRL_CHECKED | LV_KB_BTN(1), LV_BTNMATRIX_CTRL_CHECKED | LV_KB_BTN(1),\n    LV_KEYBOARD_CTRL_BTN_FLAGS | 2, LV_BTNMATRIX_CTRL_CHECKED | 2, 6, LV_BTNMATRIX_CTRL_CHECKED | 2, LV_KEYBOARD_CTRL_BTN_FLAGS | 2\n}", "sline": 55}, "default_kb_map_uc": {"type": "Variable", "def": "static const char * const default_kb_map_uc[] = {\"1#\", \"Q\", \"W\", \"E\", \"R\", \"T\", \"Y\", \"U\", \"I\", \"O\", \"P\", LV_SYMBOL_BACKSPACE, \"\\n\",\n                                                 \"abc\", \"A\", \"S\", \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", LV_SYMBOL_NEW_LINE, \"\\n\",\n                                                 \"_\", \"-\", \"Z\", \"X\", \"C\", \"V\", \"B\", \"N\", \"M\", \".\", \",\", \":\", \"\\n\",\n                                                 LV_SYMBOL_KEYBOARD, LV_SYMBOL_LEFT, \" \", LV_SYMBOL_RIGHT, LV_SYMBOL_OK, \"\"\n                                                }", "sline": 62}, "default_kb_ctrl_uc_map": {"type": "Variable", "def": "static const lv_btnmatrix_ctrl_t default_kb_ctrl_uc_map[] = {\n    LV_KEYBOARD_CTRL_BTN_FLAGS | 5, LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_KB_BTN(4), LV_BTNMATRIX_CTRL_CHECKED | 7,\n    LV_KEYBOARD_CTRL_BTN_FLAGS | 6, LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_KB_BTN(3), LV_BTNMATRIX_CTRL_CHECKED | 7,\n    LV_BTNMATRIX_CTRL_CHECKED | LV_KB_BTN(1), LV_BTNMATRIX_CTRL_CHECKED | LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_BTNMATRIX_CTRL_CHECKED | LV_KB_BTN(1), LV_BTNMATRIX_CTRL_CHECKED | LV_KB_BTN(1), LV_BTNMATRIX_CTRL_CHECKED | LV_KB_BTN(1),\n    LV_KEYBOARD_CTRL_BTN_FLAGS | 2, LV_BTNMATRIX_CTRL_CHECKED | 2, 6, LV_BTNMATRIX_CTRL_CHECKED | 2, LV_KEYBOARD_CTRL_BTN_FLAGS | 2\n}", "sline": 68}, "default_kb_map_spec": {"type": "Variable", "def": "static const char * const default_kb_map_spec[] = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"0\", LV_SYMBOL_BACKSPACE, \"\\n\",\n                                                   \"abc\", \"+\", \"-\", \"/\", \"*\", \"=\", \"%\", \"!\", \"?\", \"#\", \"<\", \">\", \"\\n\",\n                                                   \"\\\\\",  \"@\", \"$\", \"(\", \")\", \"{\", \"}\", \"[\", \"]\", \";\", \"\\\"\", \"'\", \"\\n\",\n                                                   LV_SYMBOL_KEYBOARD, LV_SYMBOL_LEFT, \" \", LV_SYMBOL_RIGHT, LV_SYMBOL_OK, \"\"\n                                                  }", "sline": 75}, "default_kb_ctrl_spec_map": {"type": "Variable", "def": "static const lv_btnmatrix_ctrl_t default_kb_ctrl_spec_map[] = {\n    LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_BTNMATRIX_CTRL_CHECKED | 2,\n    LV_KEYBOARD_CTRL_BTN_FLAGS | 2, LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1),\n    LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1), LV_KB_BTN(1),\n    LV_KEYBOARD_CTRL_BTN_FLAGS | 2, LV_BTNMATRIX_CTRL_CHECKED | 2, 6, LV_BTNMATRIX_CTRL_CHECKED | 2, LV_KEYBOARD_CTRL_BTN_FLAGS | 2\n}", "sline": 81}, "default_kb_map_num": {"type": "Variable", "def": "static const char * const default_kb_map_num[] = {\"1\", \"2\", \"3\", LV_SYMBOL_KEYBOARD, \"\\n\",\n                                                  \"4\", \"5\", \"6\", LV_SYMBOL_OK, \"\\n\",\n                                                  \"7\", \"8\", \"9\", LV_SYMBOL_BACKSPACE, \"\\n\",\n                                                  \"+/-\", \"0\", \".\", LV_SYMBOL_LEFT, LV_SYMBOL_RIGHT, \"\"\n                                                 }", "sline": 88}, "default_kb_ctrl_num_map": {"type": "Variable", "def": "static const lv_btnmatrix_ctrl_t default_kb_ctrl_num_map[] = {\n    1, 1, 1, LV_KEYBOARD_CTRL_BTN_FLAGS | 2,\n    1, 1, 1, LV_KEYBOARD_CTRL_BTN_FLAGS | 2,\n    1, 1, 1, 2,\n    1, 1, 1, 1, 1\n}", "sline": 94}, "kb_map": {"type": "Variable", "def": "static const char * * kb_map[9]", "sline": 101}, "kb_ctrl": {"type": "Variable", "def": "static const lv_btnmatrix_ctrl_t * kb_ctrl[9]", "sline": 112}, "lv_keyboard_create": {"type": "Function", "def": "lv_obj_t * lv_keyboard_create(lv_obj_t * parent)", "sline": 137, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_keyboard_class, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_keyboard_set_textarea": {"type": "Function", "def": "void lv_keyboard_set_textarea(lv_obj_t * obj, lv_obj_t * ta)", "sline": 154, "body": "{\n    if(ta) {\n        LV_ASSERT_OBJ(ta, &lv_textarea_class);\n    }\n\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_keyboard_t * keyboard = (lv_keyboard_t *)obj;\n\n    /*Hide the cursor of the old Text area if cursor management is enabled*/\n    if(keyboard->ta) {\n        lv_obj_clear_state(obj, LV_STATE_FOCUSED);\n    }\n\n    keyboard->ta = ta;\n\n    /*Show the cursor of the new Text area if cursor management is enabled*/\n    if(keyboard->ta) {\n        lv_obj_add_flag(obj, LV_STATE_FOCUSED);\n    }\n}"}, "lv_keyboard_set_mode": {"type": "Function", "def": "void lv_keyboard_set_mode(lv_obj_t * obj, lv_keyboard_mode_t mode)", "sline": 181, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_keyboard_t * keyboard = (lv_keyboard_t *)obj;\n    if(keyboard->mode == mode) return;\n\n    keyboard->mode = mode;\n    lv_keyboard_update_map(obj);\n}"}, "lv_keyboard_set_popovers": {"type": "Function", "def": "void lv_keyboard_set_popovers(lv_obj_t * obj, bool en)", "sline": 196, "body": "{\n    lv_keyboard_t * keyboard = (lv_keyboard_t *)obj;\n\n    if (keyboard->popovers == en) {\n        return;\n    }\n\n    keyboard->popovers = en;\n    lv_keyboard_update_ctrl_map(obj);\n}"}, "lv_keyboard_set_map": {"type": "Function", "def": "void lv_keyboard_set_map(lv_obj_t * obj, lv_keyboard_mode_t mode, const char * map[],\n                         const lv_btnmatrix_ctrl_t ctrl_map[])", "sline": 215, "body": "{\n    kb_map[mode] = map;\n    kb_ctrl[mode] = ctrl_map;\n    lv_keyboard_update_map(obj);\n}"}, "lv_keyboard_get_textarea": {"type": "Function", "def": "lv_obj_t * lv_keyboard_get_textarea(const lv_obj_t * obj)", "sline": 232, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_keyboard_t * keyboard = (lv_keyboard_t *)obj;\n    return keyboard->ta;\n}"}, "lv_keyboard_get_mode": {"type": "Function", "def": "lv_keyboard_mode_t lv_keyboard_get_mode(const lv_obj_t * obj)", "sline": 244, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_keyboard_t * keyboard = (lv_keyboard_t *)obj;\n    return keyboard->mode;\n}"}, "lv_btnmatrix_get_popovers": {"type": "Function", "def": "bool lv_btnmatrix_get_popovers(const lv_obj_t * obj)", "sline": 256, "body": "{\n    lv_keyboard_t * keyboard = (lv_keyboard_t *)obj;\n    return keyboard->popovers;\n}"}, "lv_keyboard_def_event_cb": {"type": "Function", "def": "void lv_keyboard_def_event_cb(lv_event_t * e)", "sline": 273, "body": "{\n    lv_obj_t * obj = lv_event_get_target(e);\n\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_keyboard_t * keyboard = (lv_keyboard_t *)obj;\n    uint16_t btn_id   = lv_btnmatrix_get_selected_btn(obj);\n    if(btn_id == LV_BTNMATRIX_BTN_NONE) return;\n\n    const char * txt = lv_btnmatrix_get_btn_text(obj, lv_btnmatrix_get_selected_btn(obj));\n    if(txt == NULL) return;\n\n    if(strcmp(txt, \"abc\") == 0) {\n        keyboard->mode = LV_KEYBOARD_MODE_TEXT_LOWER;\n        lv_btnmatrix_set_map(obj, kb_map[LV_KEYBOARD_MODE_TEXT_LOWER]);\n        lv_btnmatrix_set_ctrl_map(obj, kb_ctrl[LV_KEYBOARD_MODE_TEXT_LOWER]);\n        return;\n    }\n    else if(strcmp(txt, \"ABC\") == 0) {\n        keyboard->mode = LV_KEYBOARD_MODE_TEXT_UPPER;\n        lv_btnmatrix_set_map(obj, kb_map[LV_KEYBOARD_MODE_TEXT_UPPER]);\n        lv_btnmatrix_set_ctrl_map(obj, kb_ctrl[LV_KEYBOARD_MODE_TEXT_UPPER]);\n        return;\n    }\n    else if(strcmp(txt, \"1#\") == 0) {\n        keyboard->mode = LV_KEYBOARD_MODE_SPECIAL;\n        lv_btnmatrix_set_map(obj, kb_map[LV_KEYBOARD_MODE_SPECIAL]);\n        lv_btnmatrix_set_ctrl_map(obj, kb_ctrl[LV_KEYBOARD_MODE_SPECIAL]);\n        return;\n    }\n    else if(strcmp(txt, LV_SYMBOL_CLOSE) == 0 || strcmp(txt, LV_SYMBOL_KEYBOARD) == 0) {\n        lv_res_t res = lv_event_send(obj, LV_EVENT_CANCEL, NULL);\n        if(res != LV_RES_OK) return;\n\n        if(keyboard->ta) {\n            res = lv_event_send(keyboard->ta, LV_EVENT_CANCEL, NULL);\n            if(res != LV_RES_OK) return;\n        }\n        return;\n    }\n    else if(strcmp(txt, LV_SYMBOL_OK) == 0) {\n        lv_res_t res = lv_event_send(obj, LV_EVENT_READY, NULL);\n        if(res != LV_RES_OK) return;\n\n        if(keyboard->ta) {\n            res = lv_event_send(keyboard->ta, LV_EVENT_READY, NULL);\n            if(res != LV_RES_OK) return;\n        }\n        return;\n    }\n\n    /*Add the characters to the text area if set*/\n    if(keyboard->ta == NULL) return;\n\n    if(strcmp(txt, \"Enter\") == 0 || strcmp(txt, LV_SYMBOL_NEW_LINE) == 0) {\n        lv_textarea_add_char(keyboard->ta, '\\n');\n        if(lv_textarea_get_one_line(keyboard->ta)) {\n            lv_res_t res = lv_event_send(keyboard->ta, LV_EVENT_READY, NULL);\n            if(res != LV_RES_OK) return;\n        }\n    }\n    else if(strcmp(txt, LV_SYMBOL_LEFT) == 0) {\n        lv_textarea_cursor_left(keyboard->ta);\n    }\n    else if(strcmp(txt, LV_SYMBOL_RIGHT) == 0) {\n        lv_textarea_cursor_right(keyboard->ta);\n    }\n    else if(strcmp(txt, LV_SYMBOL_BACKSPACE) == 0) {\n        lv_textarea_del_char(keyboard->ta);\n    }\n    else if(strcmp(txt, \"+/-\") == 0) {\n        uint16_t cur        = lv_textarea_get_cursor_pos(keyboard->ta);\n        const char * ta_txt = lv_textarea_get_text(keyboard->ta);\n        if(ta_txt[0] == '-') {\n            lv_textarea_set_cursor_pos(keyboard->ta, 1);\n            lv_textarea_del_char(keyboard->ta);\n            lv_textarea_add_char(keyboard->ta, '+');\n            lv_textarea_set_cursor_pos(keyboard->ta, cur);\n        }\n        else if(ta_txt[0] == '+') {\n            lv_textarea_set_cursor_pos(keyboard->ta, 1);\n            lv_textarea_del_char(keyboard->ta);\n            lv_textarea_add_char(keyboard->ta, '-');\n            lv_textarea_set_cursor_pos(keyboard->ta, cur);\n        }\n        else {\n            lv_textarea_set_cursor_pos(keyboard->ta, 0);\n            lv_textarea_add_char(keyboard->ta, '-');\n            lv_textarea_set_cursor_pos(keyboard->ta, cur + 1);\n        }\n    }\n    else {\n        lv_textarea_add_text(keyboard->ta, txt);\n    }\n}"}, "carbit_updater/lvgl/src/extra/widgets/keyboard/lv_keyboard.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/keyboard/lv_keyboard.c"}}, "carbit_updater/lvgl/src/misc/lv_bidi.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 18}, "stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 19}, "lv_txt": {"type": "Variable", "def": "#include lv_txt.h", "sline": 20, "include": ["carbit_updater/lvgl/src/misc/lv_txt.h", null]}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_bidi.h:33:1)": {"type": "Enum", "def": "enum {\n    LV_BASE_DIR_LTR      = 0x00,\n    LV_BASE_DIR_RTL      = 0x01,\n    LV_BASE_DIR_AUTO     = 0x02,\n\n    LV_BASE_DIR_NEUTRAL  = 0x20,\n    LV_BASE_DIR_WEAK     = 0x21,\n}", "sline": 33, "docstring": "/**********************"}, "lv_base_dir_t": {"type": "Variable", "def": "typedef uint8_t lv_base_dir_t", "sline": 42}, "lv_bidi_calculate_align": {"type": "Function", "def": "static inline void lv_bidi_calculate_align(lv_text_align_t * align, lv_base_dir_t * base_dir, const char * txt)", "sline": 129, "body": "{\n    LV_UNUSED(txt);\n    LV_UNUSED(base_dir);\n    if(*align == LV_TEXT_ALIGN_AUTO) * align = LV_TEXT_ALIGN_LEFT;\n}"}, "carbit_updater/lvgl/src/misc/lv_bidi.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_bidi.h"}}, "carbit_updater/lvgl/src/font/lv_font_loader.h": {"lv_font_load": {"type": "Function", "def": "lv_font_t * lv_font_load(const char * fontName)", "sline": 29}, "lv_font_free": {"type": "Function", "def": "void lv_font_free(lv_font_t * font)", "sline": 30}, "carbit_updater/lvgl/src/font/lv_font_loader.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_loader.h"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_44.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_montserrat_44.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_44.c"}}, "carbit_updater/lvgl/src/misc/lv_color.c": {"lv_color": {"type": "Variable", "def": "#include lv_color.h", "sline": 9, "include": ["carbit_updater/lvgl/src/misc/lv_color.h", null]}, "lv_log": {"type": "Variable", "def": "#include lv_log.h", "sline": 10, "include": ["carbit_updater/lvgl/src/misc/lv_log.h", null]}, "lv_color_fill": {"type": "Function", "def": "void lv_color_fill(lv_color_t * buf, lv_color_t color, uint32_t px_num)", "sline": 36, "body": "{\n#if LV_COLOR_DEPTH == 16\n    uintptr_t buf_int = (uintptr_t)buf;\n    if(buf_int & 0x3) {\n        *buf = color;\n        buf++;\n        px_num--;\n    }\n\n    uint32_t c32 = (uint32_t)color.full + ((uint32_t)color.full << 16);\n    uint32_t * buf32 = (uint32_t *)buf;\n\n    while(px_num > 16) {\n        *buf32 = c32;\n        buf32++;\n        *buf32 = c32;\n        buf32++;\n        *buf32 = c32;\n        buf32++;\n        *buf32 = c32;\n        buf32++;\n\n        *buf32 = c32;\n        buf32++;\n        *buf32 = c32;\n        buf32++;\n        *buf32 = c32;\n        buf32++;\n        *buf32 = c32;\n        buf32++;\n\n        px_num -= 16;\n    }\n\n    buf = (lv_color_t *)buf32;\n\n    while(px_num) {\n        *buf = color;\n        buf++;\n        px_num--;\n    }\n#else\n    while(px_num > 16) {\n        *buf = color;\n        buf++;\n        *buf = color;\n        buf++;\n        *buf = color;\n        buf++;\n        *buf = color;\n        buf++;\n\n        *buf = color;\n        buf++;\n        *buf = color;\n        buf++;\n        *buf = color;\n        buf++;\n        *buf = color;\n        buf++;\n\n        *buf = color;\n        buf++;\n        *buf = color;\n        buf++;\n        *buf = color;\n        buf++;\n        *buf = color;\n        buf++;\n\n        *buf = color;\n        buf++;\n        *buf = color;\n        buf++;\n        *buf = color;\n        buf++;\n        *buf = color;\n        buf++;\n\n        px_num -= 16;\n    }\n    while(px_num) {\n        *buf = color;\n        buf++;\n        px_num--;\n    }\n#endif\n}"}, "lv_color_lighten": {"type": "Function", "def": "lv_color_t lv_color_lighten(lv_color_t c, lv_opa_t lvl)", "sline": 126, "body": "{\n    return lv_color_mix(lv_color_white(), c, lvl);\n}"}, "lv_color_darken": {"type": "Function", "def": "lv_color_t lv_color_darken(lv_color_t c, lv_opa_t lvl)", "sline": 131, "body": "{\n    return lv_color_mix(lv_color_black(), c, lvl);\n}"}, "lv_color_change_lightness": {"type": "Function", "def": "lv_color_t lv_color_change_lightness(lv_color_t c, lv_opa_t lvl)", "sline": 136, "body": "{\n    /*It'd be better to convert the color to HSL, change L and convert back to RGB.*/\n    if(lvl == LV_OPA_50) return c;\n    else if(lvl < LV_OPA_50) return lv_color_darken(c, (LV_OPA_50 - lvl) * 2);\n    else return lv_color_lighten(c, (lvl - LV_OPA_50) * 2);\n}"}, "lv_color_hsv_to_rgb": {"type": "Function", "def": "lv_color_t lv_color_hsv_to_rgb(uint16_t h, uint8_t s, uint8_t v)", "sline": 151, "body": "{\n    h = (uint32_t)((uint32_t)h * 255) / 360;\n    s = (uint16_t)((uint16_t)s * 255) / 100;\n    v = (uint16_t)((uint16_t)v * 255) / 100;\n\n    uint8_t r, g, b;\n\n    uint8_t region, remainder, p, q, t;\n\n    if(s == 0) {\n        return lv_color_make(v, v, v);\n    }\n\n    region    = h / 43;\n    remainder = (h - (region * 43)) * 6;\n\n    p = (v * (255 - s)) >> 8;\n    q = (v * (255 - ((s * remainder) >> 8))) >> 8;\n    t = (v * (255 - ((s * (255 - remainder)) >> 8))) >> 8;\n\n    switch(region) {\n        case 0:\n            r = v;\n            g = t;\n            b = p;\n            break;\n        case 1:\n            r = q;\n            g = v;\n            b = p;\n            break;\n        case 2:\n            r = p;\n            g = v;\n            b = t;\n            break;\n        case 3:\n            r = p;\n            g = q;\n            b = v;\n            break;\n        case 4:\n            r = t;\n            g = p;\n            b = v;\n            break;\n        default:\n            r = v;\n            g = p;\n            b = q;\n            break;\n    }\n\n    lv_color_t result = lv_color_make(r, g, b);\n    return result;\n}"}, "lv_color_rgb_to_hsv": {"type": "Function", "def": "lv_color_hsv_t lv_color_rgb_to_hsv(uint8_t r8, uint8_t g8, uint8_t b8)", "sline": 216, "body": "{\n    uint16_t r = ((uint32_t)r8 << 10) / 255;\n    uint16_t g = ((uint32_t)g8 << 10) / 255;\n    uint16_t b = ((uint32_t)b8 << 10) / 255;\n\n    uint16_t rgbMin = r < g ? (r < b ? r : b) : (g < b ? g : b);\n    uint16_t rgbMax = r > g ? (r > b ? r : b) : (g > b ? g : b);\n\n    lv_color_hsv_t hsv;\n\n    // https://en.wikipedia.org/wiki/HSL_and_HSV#Lightness\n    hsv.v = (100 * rgbMax) >> 10;\n\n    int32_t delta = rgbMax - rgbMin;\n    if(delta < 3) {\n        hsv.h = 0;\n        hsv.s = 0;\n        return hsv;\n    }\n\n    // https://en.wikipedia.org/wiki/HSL_and_HSV#Saturation\n    hsv.s = 100 * delta / rgbMax;\n    if(hsv.s < 3) {\n        hsv.h = 0;\n        return hsv;\n    }\n\n    // https://en.wikipedia.org/wiki/HSL_and_HSV#Hue_and_chroma\n    int32_t h;\n    if(rgbMax == r)\n        h = (((g - b) << 10) / delta) + (g < b ? (6 << 10) : 0); // between yellow & magenta\n    else if(rgbMax == g)\n        h = (((b - r) << 10) / delta) + (2 << 10); // between cyan & yellow\n    else if(rgbMax == b)\n        h = (((r - g) << 10) / delta) + (4 << 10); // between magenta & cyan\n    else\n        h = 0;\n    h *= 60;\n    h >>= 10;\n    if(h < 0) h += 360;\n\n    hsv.h = h;\n    return hsv;\n}"}, "lv_color_to_hsv": {"type": "Function", "def": "lv_color_hsv_t lv_color_to_hsv(lv_color_t color)", "sline": 267, "body": "{\n    lv_color32_t color32;\n    color32.full = lv_color_to32(color);\n    return lv_color_rgb_to_hsv(color32.ch.red, color32.ch.green, color32.ch.blue);\n}"}, "lv_palette_main": {"type": "Function", "def": "lv_color_t lv_palette_main(lv_palette_t p)", "sline": 274, "body": "{\n    static const lv_color_t colors[] = {\n        LV_COLOR_MAKE(0xF4, 0x43, 0x36), LV_COLOR_MAKE(0xE9, 0x1E, 0x63), LV_COLOR_MAKE(0x9C, 0x27, 0xB0), LV_COLOR_MAKE(0x67, 0x3A, 0xB7),\n        LV_COLOR_MAKE(0x3F, 0x51, 0xB5), LV_COLOR_MAKE(0x21, 0x96, 0xF3), LV_COLOR_MAKE(0x03, 0xA9, 0xF4), LV_COLOR_MAKE(0x00, 0xBC, 0xD4),\n        LV_COLOR_MAKE(0x00, 0x96, 0x88), LV_COLOR_MAKE(0x4C, 0xAF, 0x50), LV_COLOR_MAKE(0x8B, 0xC3, 0x4A), LV_COLOR_MAKE(0xCD, 0xDC, 0x39),\n        LV_COLOR_MAKE(0xFF, 0xEB, 0x3B), LV_COLOR_MAKE(0xFF, 0xC1, 0x07), LV_COLOR_MAKE(0xFF, 0x98, 0x00), LV_COLOR_MAKE(0xFF, 0x57, 0x22),\n        LV_COLOR_MAKE(0x79, 0x55, 0x48), LV_COLOR_MAKE(0x60, 0x7D, 0x8B), LV_COLOR_MAKE(0x9E, 0x9E, 0x9E)\n    };\n\n    if(p >= _LV_PALETTE_LAST) {\n        LV_LOG_WARN(\"Invalid palette: %d\", p);\n        return lv_color_black();\n    }\n\n    return colors[p];\n\n}"}, "lv_palette_lighten": {"type": "Function", "def": "lv_color_t lv_palette_lighten(lv_palette_t p, uint8_t lvl)", "sline": 293, "body": "{\n    static const lv_color_t colors[][5] = {\n        {LV_COLOR_MAKE(0xEF, 0x53, 0x50), LV_COLOR_MAKE(0xE5, 0x73, 0x73), LV_COLOR_MAKE(0xEF, 0x9A, 0x9A), LV_COLOR_MAKE(0xFF, 0xCD, 0xD2), LV_COLOR_MAKE(0xFF, 0xEB, 0xEE)},\n        {LV_COLOR_MAKE(0xEC, 0x40, 0x7A), LV_COLOR_MAKE(0xF0, 0x62, 0x92), LV_COLOR_MAKE(0xF4, 0x8F, 0xB1), LV_COLOR_MAKE(0xF8, 0xBB, 0xD0), LV_COLOR_MAKE(0xFC, 0xE4, 0xEC)},\n        {LV_COLOR_MAKE(0xAB, 0x47, 0xBC), LV_COLOR_MAKE(0xBA, 0x68, 0xC8), LV_COLOR_MAKE(0xCE, 0x93, 0xD8), LV_COLOR_MAKE(0xE1, 0xBE, 0xE7), LV_COLOR_MAKE(0xF3, 0xE5, 0xF5)},\n        {LV_COLOR_MAKE(0x7E, 0x57, 0xC2), LV_COLOR_MAKE(0x95, 0x75, 0xCD), LV_COLOR_MAKE(0xB3, 0x9D, 0xDB), LV_COLOR_MAKE(0xD1, 0xC4, 0xE9), LV_COLOR_MAKE(0xED, 0xE7, 0xF6)},\n        {LV_COLOR_MAKE(0x5C, 0x6B, 0xC0), LV_COLOR_MAKE(0x79, 0x86, 0xCB), LV_COLOR_MAKE(0x9F, 0xA8, 0xDA), LV_COLOR_MAKE(0xC5, 0xCA, 0xE9), LV_COLOR_MAKE(0xE8, 0xEA, 0xF6)},\n        {LV_COLOR_MAKE(0x42, 0xA5, 0xF5), LV_COLOR_MAKE(0x64, 0xB5, 0xF6), LV_COLOR_MAKE(0x90, 0xCA, 0xF9), LV_COLOR_MAKE(0xBB, 0xDE, 0xFB), LV_COLOR_MAKE(0xE3, 0xF2, 0xFD)},\n        {LV_COLOR_MAKE(0x29, 0xB6, 0xF6), LV_COLOR_MAKE(0x4F, 0xC3, 0xF7), LV_COLOR_MAKE(0x81, 0xD4, 0xFA), LV_COLOR_MAKE(0xB3, 0xE5, 0xFC), LV_COLOR_MAKE(0xE1, 0xF5, 0xFE)},\n        {LV_COLOR_MAKE(0x26, 0xC6, 0xDA), LV_COLOR_MAKE(0x4D, 0xD0, 0xE1), LV_COLOR_MAKE(0x80, 0xDE, 0xEA), LV_COLOR_MAKE(0xB2, 0xEB, 0xF2), LV_COLOR_MAKE(0xE0, 0xF7, 0xFA)},\n        {LV_COLOR_MAKE(0x26, 0xA6, 0x9A), LV_COLOR_MAKE(0x4D, 0xB6, 0xAC), LV_COLOR_MAKE(0x80, 0xCB, 0xC4), LV_COLOR_MAKE(0xB2, 0xDF, 0xDB), LV_COLOR_MAKE(0xE0, 0xF2, 0xF1)},\n        {LV_COLOR_MAKE(0x66, 0xBB, 0x6A), LV_COLOR_MAKE(0x81, 0xC7, 0x84), LV_COLOR_MAKE(0xA5, 0xD6, 0xA7), LV_COLOR_MAKE(0xC8, 0xE6, 0xC9), LV_COLOR_MAKE(0xE8, 0xF5, 0xE9)},\n        {LV_COLOR_MAKE(0x9C, 0xCC, 0x65), LV_COLOR_MAKE(0xAE, 0xD5, 0x81), LV_COLOR_MAKE(0xC5, 0xE1, 0xA5), LV_COLOR_MAKE(0xDC, 0xED, 0xC8), LV_COLOR_MAKE(0xF1, 0xF8, 0xE9)},\n        {LV_COLOR_MAKE(0xD4, 0xE1, 0x57), LV_COLOR_MAKE(0xDC, 0xE7, 0x75), LV_COLOR_MAKE(0xE6, 0xEE, 0x9C), LV_COLOR_MAKE(0xF0, 0xF4, 0xC3), LV_COLOR_MAKE(0xF9, 0xFB, 0xE7)},\n        {LV_COLOR_MAKE(0xFF, 0xEE, 0x58), LV_COLOR_MAKE(0xFF, 0xF1, 0x76), LV_COLOR_MAKE(0xFF, 0xF5, 0x9D), LV_COLOR_MAKE(0xFF, 0xF9, 0xC4), LV_COLOR_MAKE(0xFF, 0xFD, 0xE7)},\n        {LV_COLOR_MAKE(0xFF, 0xCA, 0x28), LV_COLOR_MAKE(0xFF, 0xD5, 0x4F), LV_COLOR_MAKE(0xFF, 0xE0, 0x82), LV_COLOR_MAKE(0xFF, 0xEC, 0xB3), LV_COLOR_MAKE(0xFF, 0xF8, 0xE1)},\n        {LV_COLOR_MAKE(0xFF, 0xA7, 0x26), LV_COLOR_MAKE(0xFF, 0xB7, 0x4D), LV_COLOR_MAKE(0xFF, 0xCC, 0x80), LV_COLOR_MAKE(0xFF, 0xE0, 0xB2), LV_COLOR_MAKE(0xFF, 0xF3, 0xE0)},\n        {LV_COLOR_MAKE(0xFF, 0x70, 0x43), LV_COLOR_MAKE(0xFF, 0x8A, 0x65), LV_COLOR_MAKE(0xFF, 0xAB, 0x91), LV_COLOR_MAKE(0xFF, 0xCC, 0xBC), LV_COLOR_MAKE(0xFB, 0xE9, 0xE7)},\n        {LV_COLOR_MAKE(0x8D, 0x6E, 0x63), LV_COLOR_MAKE(0xA1, 0x88, 0x7F), LV_COLOR_MAKE(0xBC, 0xAA, 0xA4), LV_COLOR_MAKE(0xD7, 0xCC, 0xC8), LV_COLOR_MAKE(0xEF, 0xEB, 0xE9)},\n        {LV_COLOR_MAKE(0x78, 0x90, 0x9C), LV_COLOR_MAKE(0x90, 0xA4, 0xAE), LV_COLOR_MAKE(0xB0, 0xBE, 0xC5), LV_COLOR_MAKE(0xCF, 0xD8, 0xDC), LV_COLOR_MAKE(0xEC, 0xEF, 0xF1)},\n        {LV_COLOR_MAKE(0xBD, 0xBD, 0xBD), LV_COLOR_MAKE(0xE0, 0xE0, 0xE0), LV_COLOR_MAKE(0xEE, 0xEE, 0xEE), LV_COLOR_MAKE(0xF5, 0xF5, 0xF5), LV_COLOR_MAKE(0xFA, 0xFA, 0xFA)},\n    };\n\n    if(p >= _LV_PALETTE_LAST) {\n        LV_LOG_WARN(\"Invalid palette: %d\", p);\n        return lv_color_black();\n    }\n\n    if(lvl == 0 || lvl > 5) {\n        LV_LOG_WARN(\"Invalid level: %d. Must be 1..5\", lvl);\n        return lv_color_black();\n    }\n\n    lvl--;\n\n    return colors[p][lvl];\n}"}, "lv_palette_darken": {"type": "Function", "def": "lv_color_t lv_palette_darken(lv_palette_t p, uint8_t lvl)", "sline": 332, "body": "{\n    static const lv_color_t colors[][4] = {\n        {LV_COLOR_MAKE(0xE5, 0x39, 0x35), LV_COLOR_MAKE(0xD3, 0x2F, 0x2F), LV_COLOR_MAKE(0xC6, 0x28, 0x28), LV_COLOR_MAKE(0xB7, 0x1C, 0x1C)},\n        {LV_COLOR_MAKE(0xD8, 0x1B, 0x60), LV_COLOR_MAKE(0xC2, 0x18, 0x5B), LV_COLOR_MAKE(0xAD, 0x14, 0x57), LV_COLOR_MAKE(0x88, 0x0E, 0x4F)},\n        {LV_COLOR_MAKE(0x8E, 0x24, 0xAA), LV_COLOR_MAKE(0x7B, 0x1F, 0xA2), LV_COLOR_MAKE(0x6A, 0x1B, 0x9A), LV_COLOR_MAKE(0x4A, 0x14, 0x8C)},\n        {LV_COLOR_MAKE(0x5E, 0x35, 0xB1), LV_COLOR_MAKE(0x51, 0x2D, 0xA8), LV_COLOR_MAKE(0x45, 0x27, 0xA0), LV_COLOR_MAKE(0x31, 0x1B, 0x92)},\n        {LV_COLOR_MAKE(0x39, 0x49, 0xAB), LV_COLOR_MAKE(0x30, 0x3F, 0x9F), LV_COLOR_MAKE(0x28, 0x35, 0x93), LV_COLOR_MAKE(0x1A, 0x23, 0x7E)},\n        {LV_COLOR_MAKE(0x1E, 0x88, 0xE5), LV_COLOR_MAKE(0x19, 0x76, 0xD2), LV_COLOR_MAKE(0x15, 0x65, 0xC0), LV_COLOR_MAKE(0x0D, 0x47, 0xA1)},\n        {LV_COLOR_MAKE(0x03, 0x9B, 0xE5), LV_COLOR_MAKE(0x02, 0x88, 0xD1), LV_COLOR_MAKE(0x02, 0x77, 0xBD), LV_COLOR_MAKE(0x01, 0x57, 0x9B)},\n        {LV_COLOR_MAKE(0x00, 0xAC, 0xC1), LV_COLOR_MAKE(0x00, 0x97, 0xA7), LV_COLOR_MAKE(0x00, 0x83, 0x8F), LV_COLOR_MAKE(0x00, 0x60, 0x64)},\n        {LV_COLOR_MAKE(0x00, 0x89, 0x7B), LV_COLOR_MAKE(0x00, 0x79, 0x6B), LV_COLOR_MAKE(0x00, 0x69, 0x5C), LV_COLOR_MAKE(0x00, 0x4D, 0x40)},\n        {LV_COLOR_MAKE(0x43, 0xA0, 0x47), LV_COLOR_MAKE(0x38, 0x8E, 0x3C), LV_COLOR_MAKE(0x2E, 0x7D, 0x32), LV_COLOR_MAKE(0x1B, 0x5E, 0x20)},\n        {LV_COLOR_MAKE(0x7C, 0xB3, 0x42), LV_COLOR_MAKE(0x68, 0x9F, 0x38), LV_COLOR_MAKE(0x55, 0x8B, 0x2F), LV_COLOR_MAKE(0x33, 0x69, 0x1E)},\n        {LV_COLOR_MAKE(0xC0, 0xCA, 0x33), LV_COLOR_MAKE(0xAF, 0xB4, 0x2B), LV_COLOR_MAKE(0x9E, 0x9D, 0x24), LV_COLOR_MAKE(0x82, 0x77, 0x17)},\n        {LV_COLOR_MAKE(0xFD, 0xD8, 0x35), LV_COLOR_MAKE(0xFB, 0xC0, 0x2D), LV_COLOR_MAKE(0xF9, 0xA8, 0x25), LV_COLOR_MAKE(0xF5, 0x7F, 0x17)},\n        {LV_COLOR_MAKE(0xFF, 0xB3, 0x00), LV_COLOR_MAKE(0xFF, 0xA0, 0x00), LV_COLOR_MAKE(0xFF, 0x8F, 0x00), LV_COLOR_MAKE(0xFF, 0x6F, 0x00)},\n        {LV_COLOR_MAKE(0xFB, 0x8C, 0x00), LV_COLOR_MAKE(0xF5, 0x7C, 0x00), LV_COLOR_MAKE(0xEF, 0x6C, 0x00), LV_COLOR_MAKE(0xE6, 0x51, 0x00)},\n        {LV_COLOR_MAKE(0xF4, 0x51, 0x1E), LV_COLOR_MAKE(0xE6, 0x4A, 0x19), LV_COLOR_MAKE(0xD8, 0x43, 0x15), LV_COLOR_MAKE(0xBF, 0x36, 0x0C)},\n        {LV_COLOR_MAKE(0x6D, 0x4C, 0x41), LV_COLOR_MAKE(0x5D, 0x40, 0x37), LV_COLOR_MAKE(0x4E, 0x34, 0x2E), LV_COLOR_MAKE(0x3E, 0x27, 0x23)},\n        {LV_COLOR_MAKE(0x54, 0x6E, 0x7A), LV_COLOR_MAKE(0x45, 0x5A, 0x64), LV_COLOR_MAKE(0x37, 0x47, 0x4F), LV_COLOR_MAKE(0x26, 0x32, 0x38)},\n        {LV_COLOR_MAKE(0x75, 0x75, 0x75), LV_COLOR_MAKE(0x61, 0x61, 0x61), LV_COLOR_MAKE(0x42, 0x42, 0x42), LV_COLOR_MAKE(0x21, 0x21, 0x21)},\n    };\n\n    if(p >= _LV_PALETTE_LAST) {\n        LV_LOG_WARN(\"Invalid palette: %d\", p);\n        return lv_color_black();\n    }\n\n    if(lvl == 0 || lvl > 4) {\n        LV_LOG_WARN(\"Invalid level: %d. Must be 1..4\", lvl);\n        return lv_color_black();\n    }\n\n    lvl--;\n\n    return colors[p][lvl];\n}"}, "carbit_updater/lvgl/src/misc/lv_color.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_color.c"}}, "carbit_updater/lvgl/src/misc/lv_anim.c": {"lv_anim": {"type": "Variable", "def": "#include lv_anim.h", "sline": 9, "include": ["carbit_updater/lvgl/src/misc/lv_anim.h", null]}, "lv_hal_tick": {"type": "Variable", "def": "#include ../hal/lv_hal_tick.h", "sline": 11}, "lv_assert": {"type": "Variable", "def": "#include lv_assert.h", "sline": 12, "include": ["carbit_updater/lvgl/src/misc/lv_assert.h", null]}, "lv_timer": {"type": "Variable", "def": "#include lv_timer.h", "sline": 13, "include": ["carbit_updater/lvgl/src/misc/lv_timer.h", null]}, "lv_math": {"type": "Variable", "def": "#include lv_math.h", "sline": 14, "include": ["carbit_updater/lvgl/src/misc/lv_math.h", null]}, "lv_mem": {"type": "Variable", "def": "#include lv_mem.h", "sline": 15, "include": ["carbit_updater/lvgl/src/misc/lv_mem.h", null]}, "lv_gc": {"type": "Variable", "def": "#include lv_gc.h", "sline": 16, "include": ["carbit_updater/lvgl/src/misc/lv_gc.h", null]}, "anim_timer": {"type": "Function", "def": "static void anim_timer(lv_timer_t * param)", "sline": 344, "body": "{\n    LV_UNUSED(param);\n\n    uint32_t elaps = lv_tick_elaps(last_timer_run);\n\n    /*Flip the run round*/\n    anim_run_round = anim_run_round ? false : true;\n\n    lv_anim_t * a = _lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll));\n\n    while(a != NULL) {\n        /*It can be set by `lv_anim_del()` typically in `end_cb`. If set then an animation delete\n         * happened in `anim_ready_handler` which could make this linked list reading corrupt\n         * because the list is changed meanwhile\n         */\n        anim_list_changed = false;\n\n        if(a->run_round != anim_run_round) {\n            a->run_round = anim_run_round; /*The list readying might be reset so need to know which anim has run already*/\n\n            /*The animation will run now for the first time. Call `start_cb`*/\n            int32_t new_act_time = a->act_time + elaps;\n            if(!a->start_cb_called && a->act_time <= 0 && new_act_time >= 0) {\n                if(a->early_apply == 0 && a->get_value_cb) {\n                    int32_t v_ofs = a->get_value_cb(a);\n                    a->start_value += v_ofs;\n                    a->end_value += v_ofs;\n                }\n                if(a->start_cb) a->start_cb(a);\n                a->start_cb_called = 1;\n            }\n            a->act_time += elaps;\n            if(a->act_time >= 0) {\n                if(a->act_time > a->time) a->act_time = a->time;\n\n                int32_t new_value;\n                new_value = a->path_cb(a);\n\n                if(new_value != a->current_value) {\n                    a->current_value = new_value;\n                    /*Apply the calculated value*/\n                    if(a->exec_cb) a->exec_cb(a->var, new_value);\n                }\n\n                /*If the time is elapsed the animation is ready*/\n                if(a->act_time >= a->time) {\n                    anim_ready_handler(a);\n                }\n            }\n        }\n\n        /*If the linked list changed due to anim. delete then it's not safe to continue\n         *the reading of the list from here -> start from the head*/\n        if(anim_list_changed)\n            a = _lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll));\n        else\n            a = _lv_ll_get_next(&LV_GC_ROOT(_lv_anim_ll), a);\n    }\n\n    last_timer_run = lv_tick_get();\n}"}, "anim_mark_list_change": {"type": "Function", "def": "static void anim_mark_list_change(void)", "sline": 456, "body": "{\n    anim_list_changed = true;\n    if(_lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll)) == NULL)\n        lv_timer_pause(_lv_anim_tmr);\n    else\n        lv_timer_resume(_lv_anim_tmr);\n}"}, "anim_ready_handler": {"type": "Function", "def": "static void anim_ready_handler(lv_anim_t * a)", "sline": 412, "body": "{\n    /*In the end of a forward anim decrement repeat cnt.*/\n    if(a->playback_now == 0 && a->repeat_cnt > 0 && a->repeat_cnt != LV_ANIM_REPEAT_INFINITE) {\n        a->repeat_cnt--;\n    }\n\n    /*Delete the animation if\n     * - no repeat left and no play back (simple one shot animation)\n     * - no repeat, play back is enabled and play back is ready*/\n    if(a->repeat_cnt == 0 && (a->playback_time == 0 || a->playback_now == 1)) {\n\n        /*Delete the animation from the list.\n         * This way the `ready_cb` will see the animations like it's animation is ready deleted*/\n        _lv_ll_remove(&LV_GC_ROOT(_lv_anim_ll), a);\n        /*Flag that the list has changed*/\n        anim_mark_list_change();\n\n        /*Call the callback function at the end*/\n        if(a->ready_cb != NULL) a->ready_cb(a);\n        lv_mem_free(a);\n    }\n    /*If the animation is not deleted then restart it*/\n    else {\n        a->act_time = -(int32_t)(a->repeat_delay); /*Restart the animation*/\n        /*Swap the start and end values in play back mode*/\n        if(a->playback_time != 0) {\n            /*If now turning back use the 'playback_pause*/\n            if(a->playback_now == 0) a->act_time = -(int32_t)(a->playback_delay);\n\n            /*Toggle the play back state*/\n            a->playback_now = a->playback_now == 0 ? 1 : 0;\n            /*Swap the start and end values*/\n            int32_t tmp    = a->start_value;\n            a->start_value = a->end_value;\n            a->end_value   = tmp;\n            /*Swap the time and playback_time*/\n            tmp = a->time;\n            a->time = a->playback_time;\n            a->playback_time = tmp;\n        }\n    }\n}"}, "last_timer_run": {"type": "Variable", "def": "static uint32_t last_timer_run", "sline": 38}, "anim_list_changed": {"type": "Variable", "def": "static bool anim_list_changed", "sline": 39}, "anim_run_round": {"type": "Variable", "def": "static bool anim_run_round", "sline": 40}, "_lv_anim_tmr": {"type": "Variable", "def": "static lv_timer_t * _lv_anim_tmr", "sline": 41}, "_lv_anim_core_init": {"type": "Function", "def": "void _lv_anim_core_init(void)", "sline": 57, "body": "{\n    _lv_ll_init(&LV_GC_ROOT(_lv_anim_ll), sizeof(lv_anim_t));\n    _lv_anim_tmr = lv_timer_create(anim_timer, LV_DISP_DEF_REFR_PERIOD, NULL);\n    anim_mark_list_change(); /*Turn off the animation timer*/\n    anim_list_changed = false;\n}"}, "lv_anim_init": {"type": "Function", "def": "void lv_anim_init(lv_anim_t * a)", "sline": 65, "body": "{\n    lv_memset_00(a, sizeof(lv_anim_t));\n    a->time = 500;\n    a->start_value = 0;\n    a->end_value = 100;\n    a->repeat_cnt = 1;\n    a->path_cb = lv_anim_path_linear;\n    a->early_apply = 1;\n}"}, "lv_anim_start": {"type": "Function", "def": "lv_anim_t * lv_anim_start(const lv_anim_t * a)", "sline": 76, "body": "{\n    TRACE_ANIM(\"begin\");\n\n    /*Do not let two animations for the same 'var' with the same 'exec_cb'*/\n    if(a->exec_cb != NULL) lv_anim_del(a->var, a->exec_cb); /*exec_cb == NULL would delete all animations of var*/\n\n    /*If the list is empty the anim timer was suspended and it's last run measure is invalid*/\n    if(_lv_ll_is_empty(&LV_GC_ROOT(_lv_anim_ll))) {\n        last_timer_run = lv_tick_get();\n    }\n\n    /*Add the new animation to the animation linked list*/\n    lv_anim_t * new_anim = _lv_ll_ins_head(&LV_GC_ROOT(_lv_anim_ll));\n    LV_ASSERT_MALLOC(new_anim);\n    if(new_anim == NULL) return NULL;\n\n    /*Initialize the animation descriptor*/\n    lv_memcpy(new_anim, a, sizeof(lv_anim_t));\n    if(a->var == a) new_anim->var = new_anim;\n    new_anim->run_round = anim_run_round;\n\n    /*Set the start value*/\n    if(new_anim->early_apply) {\n        if(new_anim->get_value_cb) {\n            int32_t v_ofs = new_anim->get_value_cb(new_anim);\n            new_anim->start_value += v_ofs;\n            new_anim->end_value += v_ofs;\n        }\n\n        if(new_anim->exec_cb && new_anim->var) new_anim->exec_cb(new_anim->var, new_anim->start_value);\n    }\n\n    /*Creating an animation changed the linked list.\n     *It's important if it happens in a ready callback. (see `anim_timer`)*/\n    anim_mark_list_change();\n\n    TRACE_ANIM(\"finished\");\n    return new_anim;\n}"}, "lv_anim_get_playtime": {"type": "Function", "def": "uint32_t lv_anim_get_playtime(lv_anim_t * a)", "sline": 117, "body": "{\n    uint32_t playtime = LV_ANIM_PLAYTIME_INFINITE;\n\n    if(a->repeat_cnt == LV_ANIM_REPEAT_INFINITE)\n        return playtime;\n\n    playtime = a->time - a->act_time;\n    if(a->playback_now == 0)\n        playtime += a->playback_delay + a->playback_time;\n\n    if(a->repeat_cnt <= 1)\n        return playtime;\n\n    playtime += (a->repeat_delay + a->time +\n                 a->playback_delay + a->playback_time) *\n                (a->repeat_cnt - 1);\n\n    return playtime;\n}"}, "lv_anim_del": {"type": "Function", "def": "bool lv_anim_del(void * var, lv_anim_exec_xcb_t exec_cb)", "sline": 138, "body": "{\n    lv_anim_t * a;\n    lv_anim_t * a_next;\n    bool del = false;\n    a        = _lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll));\n    while(a != NULL) {\n        /*'a' might be deleted, so get the next object while 'a' is valid*/\n        a_next = _lv_ll_get_next(&LV_GC_ROOT(_lv_anim_ll), a);\n\n        if((a->var == var || var == NULL) && (a->exec_cb == exec_cb || exec_cb == NULL)) {\n            _lv_ll_remove(&LV_GC_ROOT(_lv_anim_ll), a);\n            lv_mem_free(a);\n            anim_mark_list_change(); /*Read by `anim_timer`. It need to know if a delete occurred in\n                                       the linked list*/\n            del = true;\n        }\n\n        a = a_next;\n    }\n\n    return del;\n}"}, "lv_anim_del_all": {"type": "Function", "def": "void lv_anim_del_all(void)", "sline": 162, "body": "{\n    _lv_ll_clear(&LV_GC_ROOT(_lv_anim_ll));\n    anim_mark_list_change();\n}"}, "lv_anim_get": {"type": "Function", "def": "lv_anim_t * lv_anim_get(void * var, lv_anim_exec_xcb_t exec_cb)", "sline": 168, "body": "{\n    lv_anim_t * a;\n    _LV_LL_READ(&LV_GC_ROOT(_lv_anim_ll), a) {\n        if(a->var == var && (a->exec_cb == exec_cb || exec_cb == NULL)) {\n            return a;\n        }\n    }\n\n    return NULL;\n}"}, "lv_anim_count_running": {"type": "Function", "def": "uint16_t lv_anim_count_running(void)", "sline": 180, "body": "{\n    uint16_t cnt = 0;\n    lv_anim_t * a;\n    _LV_LL_READ(&LV_GC_ROOT(_lv_anim_ll), a) cnt++;\n\n    return cnt;\n}"}, "lv_anim_speed_to_time": {"type": "Function", "def": "uint32_t lv_anim_speed_to_time(uint32_t speed, int32_t start, int32_t end)", "sline": 189, "body": "{\n    uint32_t d    = LV_ABS(start - end);\n    uint32_t time = (d * 1000) / speed;\n\n    if(time == 0) {\n        time++;\n    }\n\n    return time;\n}"}, "lv_anim_refr_now": {"type": "Function", "def": "void lv_anim_refr_now(void)", "sline": 201, "body": "{\n    anim_timer(NULL);\n}"}, "lv_anim_path_linear": {"type": "Function", "def": "int32_t lv_anim_path_linear(const lv_anim_t * a)", "sline": 206, "body": "{\n    /*Calculate the current step*/\n    int32_t step = lv_map(a->act_time, 0, a->time, 0, LV_ANIM_RESOLUTION);\n\n    /*Get the new value which will be proportional to `step`\n     *and the `start` and `end` values*/\n    int32_t new_value;\n    new_value = step * (a->end_value - a->start_value);\n    new_value = new_value >> LV_ANIM_RES_SHIFT;\n    new_value += a->start_value;\n\n    return new_value;\n}"}, "lv_anim_path_ease_in": {"type": "Function", "def": "int32_t lv_anim_path_ease_in(const lv_anim_t * a)", "sline": 221, "body": "{\n    /*Calculate the current step*/\n    uint32_t t = lv_map(a->act_time, 0, a->time, 0, LV_BEZIER_VAL_MAX);\n    int32_t step = lv_bezier3(t, 0, 50, 100, LV_BEZIER_VAL_MAX);\n\n    int32_t new_value;\n    new_value = step * (a->end_value - a->start_value);\n    new_value = new_value >> LV_BEZIER_VAL_SHIFT;\n    new_value += a->start_value;\n\n    return new_value;\n}"}, "lv_anim_path_ease_out": {"type": "Function", "def": "int32_t lv_anim_path_ease_out(const lv_anim_t * a)", "sline": 235, "body": "{\n    /*Calculate the current step*/\n    uint32_t t = lv_map(a->act_time, 0, a->time, 0, LV_BEZIER_VAL_MAX);\n    int32_t step = lv_bezier3(t, 0, 900, 950, LV_BEZIER_VAL_MAX);\n\n    int32_t new_value;\n    new_value = step * (a->end_value - a->start_value);\n    new_value = new_value >> LV_BEZIER_VAL_SHIFT;\n    new_value += a->start_value;\n\n    return new_value;\n}"}, "lv_anim_path_ease_in_out": {"type": "Function", "def": "int32_t lv_anim_path_ease_in_out(const lv_anim_t * a)", "sline": 249, "body": "{\n    /*Calculate the current step*/\n    uint32_t t = lv_map(a->act_time, 0, a->time, 0, LV_BEZIER_VAL_MAX);\n    int32_t step = lv_bezier3(t, 0, 50, 952, LV_BEZIER_VAL_MAX);\n\n    int32_t new_value;\n    new_value = step * (a->end_value - a->start_value);\n    new_value = new_value >> LV_BEZIER_VAL_SHIFT;\n    new_value += a->start_value;\n\n    return new_value;\n}"}, "lv_anim_path_overshoot": {"type": "Function", "def": "int32_t lv_anim_path_overshoot(const lv_anim_t * a)", "sline": 263, "body": "{\n    /*Calculate the current step*/\n    uint32_t t = lv_map(a->act_time, 0, a->time, 0, LV_BEZIER_VAL_MAX);\n    int32_t step = lv_bezier3(t, 0, 1000, 1300, LV_BEZIER_VAL_MAX);\n\n    int32_t new_value;\n    new_value = step * (a->end_value - a->start_value);\n    new_value = new_value >> LV_BEZIER_VAL_SHIFT;\n    new_value += a->start_value;\n\n    return new_value;\n}"}, "lv_anim_path_bounce": {"type": "Function", "def": "int32_t lv_anim_path_bounce(const lv_anim_t * a)", "sline": 277, "body": "{\n    /*Calculate the current step*/\n    int32_t t = lv_map(a->act_time, 0, a->time, 0, LV_BEZIER_VAL_MAX);\n    int32_t diff = (a->end_value - a->start_value);\n\n    /*3 bounces has 5 parts: 3 down and 2 up. One part is t / 5 long*/\n\n    if(t < 408) {\n        /*Go down*/\n        t = (t * 2500) >> LV_BEZIER_VAL_SHIFT; /*[0..1024] range*/\n    }\n    else if(t >= 408 && t < 614) {\n        /*First bounce back*/\n        t -= 408;\n        t    = t * 5; /*to [0..1024] range*/\n        t    = LV_BEZIER_VAL_MAX - t;\n        diff = diff / 20;\n    }\n    else if(t >= 614 && t < 819) {\n        /*Fall back*/\n        t -= 614;\n        t    = t * 5; /*to [0..1024] range*/\n        diff = diff / 20;\n    }\n    else if(t >= 819 && t < 921) {\n        /*Second bounce back*/\n        t -= 819;\n        t    = t * 10; /*to [0..1024] range*/\n        t    = LV_BEZIER_VAL_MAX - t;\n        diff = diff / 40;\n    }\n    else if(t >= 921 && t <= LV_BEZIER_VAL_MAX) {\n        /*Fall back*/\n        t -= 921;\n        t    = t * 10; /*to [0..1024] range*/\n        diff = diff / 40;\n    }\n\n    if(t > LV_BEZIER_VAL_MAX) t = LV_BEZIER_VAL_MAX;\n    if(t < 0) t = 0;\n    int32_t step = lv_bezier3(t, LV_BEZIER_VAL_MAX, 800, 500, 0);\n\n    int32_t new_value;\n    new_value = step * diff;\n    new_value = new_value >> LV_BEZIER_VAL_SHIFT;\n    new_value = a->end_value - new_value;\n\n    return new_value;\n}"}, "lv_anim_path_step": {"type": "Function", "def": "int32_t lv_anim_path_step(const lv_anim_t * a)", "sline": 328, "body": "{\n    if(a->act_time >= a->time)\n        return a->end_value;\n    else\n        return a->start_value;\n}"}, "carbit_updater/lvgl/src/misc/lv_anim.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_anim.c"}}, "carbit_updater/lvgl/src/extra/widgets/keyboard/lv_keyboard.h": {"lv_btnmatrix": {"type": "Variable", "def": "#include ../../../widgets/lv_btnmatrix.h", "sline": 16}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/keyboard/lv_keyboard.h:39:1)": {"type": "Enum", "def": "enum {\n    LV_KEYBOARD_MODE_TEXT_LOWER,\n    LV_KEYBOARD_MODE_TEXT_UPPER,\n    LV_KEYBOARD_MODE_SPECIAL,\n    LV_KEYBOARD_MODE_NUMBER,\n    LV_KEYBOARD_MODE_USER_1,\n    LV_KEYBOARD_MODE_USER_2,\n    LV_KEYBOARD_MODE_USER_3,\n    LV_KEYBOARD_MODE_USER_4,\n}", "sline": 39, "docstring": "/** Current keyboard mode.*/"}, "lv_keyboard_mode_t": {"type": "Variable", "def": "typedef uint8_t lv_keyboard_mode_t", "sline": 49}, "lv_keyboard_t.btnm": {"type": "Variable", "def": "lv_btnmatrix_t btnm", "sline": 53, "in_struct": "lv_keyboard_t"}, "lv_keyboard_t.ta": {"type": "Variable", "def": "lv_obj_t * ta", "sline": 54, "in_struct": "lv_keyboard_t"}, "lv_keyboard_t.mode": {"type": "Variable", "def": "lv_keyboard_mode_t mode", "sline": 55, "in_struct": "lv_keyboard_t", "rels": [["lv_keyboard_mode_t", null, "Typeof"]]}, "lv_keyboard_t.popovers": {"type": "Variable", "def": "uint8_t popovers : 1", "sline": 56, "in_struct": "lv_keyboard_t"}, "lv_keyboard_t": {"type": "Variable", "def": "typedef struct {\n    lv_btnmatrix_t btnm;\n    lv_obj_t * ta;              /*Pointer to the assigned text area*/\n    lv_keyboard_mode_t mode;    /*Key map type*/\n    uint8_t popovers : 1;       /*Show button titles in popovers on press*/\n} lv_keyboard_t", "sline": 57, "docstring": "/*Data of keyboard*/"}, "lv_keyboard_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_keyboard_class", "sline": 59}, "lv_keyboard_create": {"type": "Function", "def": "lv_obj_t * lv_keyboard_create(lv_obj_t * parent)", "sline": 70}, "lv_keyboard_set_textarea": {"type": "Function", "def": "void lv_keyboard_set_textarea(lv_obj_t * kb, lv_obj_t * ta)", "sline": 81}, "lv_keyboard_set_mode": {"type": "Function", "def": "void lv_keyboard_set_mode(lv_obj_t * kb, lv_keyboard_mode_t mode)", "sline": 88}, "lv_keyboard_set_popovers": {"type": "Function", "def": "void lv_keyboard_set_popovers(lv_obj_t * kb, bool en)", "sline": 95}, "lv_keyboard_set_map": {"type": "Function", "def": "void lv_keyboard_set_map(lv_obj_t * kb, lv_keyboard_mode_t mode, const char * map[],\n                         const lv_btnmatrix_ctrl_t ctrl_map[])", "sline": 104}, "lv_keyboard_get_textarea": {"type": "Function", "def": "lv_obj_t * lv_keyboard_get_textarea(const lv_obj_t * kb)", "sline": 116}, "lv_keyboard_get_mode": {"type": "Function", "def": "lv_keyboard_mode_t lv_keyboard_get_mode(const lv_obj_t * kb)", "sline": 123, "rels": [["lv_keyboard_mode_t", null, "Typeof"]]}, "lv_btnmatrix_get_popovers": {"type": "Function", "def": "bool lv_btnmatrix_get_popovers(const lv_obj_t * obj)", "sline": 130}, "lv_keyboard_get_map_array": {"type": "Function", "def": "static inline const char ** lv_keyboard_get_map_array(const lv_obj_t * kb)", "sline": 137, "body": "{\n    return lv_btnmatrix_get_map(kb);\n}"}, "lv_keyboard_def_event_cb": {"type": "Function", "def": "void lv_keyboard_def_event_cb(lv_event_t * e)", "sline": 153}, "carbit_updater/lvgl/src/extra/widgets/keyboard/lv_keyboard.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/keyboard/lv_keyboard.h"}}, "carbit_updater/lvgl/src/widgets/lv_slider.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "lv_obj": {"type": "Variable", "def": "#include ../core/lv_obj.h", "sline": 25}, "lv_bar": {"type": "Variable", "def": "#include lv_bar.h", "sline": 26, "include": ["carbit_updater/lvgl/src/widgets/lv_bar.h", null]}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_slider.h:36:1)": {"type": "Enum", "def": "enum {\n    LV_SLIDER_MODE_NORMAL = LV_BAR_MODE_NORMAL,\n    LV_SLIDER_MODE_SYMMETRICAL = LV_BAR_MODE_SYMMETRICAL,\n    LV_SLIDER_MODE_RANGE = LV_BAR_MODE_RANGE\n}", "sline": 36}, "lv_slider_mode_t": {"type": "Variable", "def": "typedef uint8_t lv_slider_mode_t", "sline": 41}, "lv_slider_t.bar": {"type": "Variable", "def": "lv_bar_t bar", "sline": 44, "in_struct": "lv_slider_t"}, "lv_slider_t.left_knob_area": {"type": "Variable", "def": "lv_area_t left_knob_area", "sline": 45, "in_struct": "lv_slider_t"}, "lv_slider_t.right_knob_area": {"type": "Variable", "def": "lv_area_t right_knob_area", "sline": 46, "in_struct": "lv_slider_t"}, "lv_slider_t.value_to_set": {"type": "Variable", "def": "int32_t * value_to_set", "sline": 47, "in_struct": "lv_slider_t"}, "lv_slider_t.dragging": {"type": "Variable", "def": "uint8_t dragging : 1", "sline": 48, "in_struct": "lv_slider_t"}, "lv_slider_t.left_knob_focus": {"type": "Variable", "def": "uint8_t left_knob_focus : 1", "sline": 49, "in_struct": "lv_slider_t"}, "lv_slider_t": {"type": "Variable", "def": "typedef struct {\n    lv_bar_t bar;       /*Add the ancestor's type first*/\n    lv_area_t left_knob_area;\n    lv_area_t right_knob_area;\n    int32_t * value_to_set; /*Which bar value to set*/\n    uint8_t dragging : 1;       /*1: the slider is being dragged*/\n    uint8_t left_knob_focus : 1; /*1: with encoder now the right knob can be adjusted*/\n} lv_slider_t", "sline": 50}, "lv_slider_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_slider_class", "sline": 52}, "lv_slider_draw_part_type_t": {"type": "Variable", "def": "typedef enum {\n    LV_SLIDER_DRAW_PART_KNOB,           /**< The main (right) knob's rectangle*/\n    LV_SLIDER_DRAW_PART_KNOB_LEFT,      /**< The left knob's rectangle*/\n} lv_slider_draw_part_type_t", "sline": 61}, "lv_slider_create": {"type": "Function", "def": "lv_obj_t * lv_slider_create(lv_obj_t * parent)", "sline": 72}, "lv_slider_set_value": {"type": "Function", "def": "static inline void lv_slider_set_value(lv_obj_t * obj, int32_t value, lv_anim_enable_t anim)", "sline": 84, "body": "{\n    lv_bar_set_value(obj, value, anim);\n}"}, "lv_slider_set_left_value": {"type": "Function", "def": "static inline void lv_slider_set_left_value(lv_obj_t * obj, int32_t value, lv_anim_enable_t anim)", "sline": 95, "body": "{\n    lv_bar_set_start_value(obj, value, anim);\n}"}, "lv_slider_set_range": {"type": "Function", "def": "static inline void lv_slider_set_range(lv_obj_t * obj, int32_t min, int32_t max)", "sline": 106, "body": "{\n    lv_bar_set_range(obj, min, max);\n}"}, "lv_slider_set_mode": {"type": "Function", "def": "static inline void lv_slider_set_mode(lv_obj_t * obj, lv_slider_mode_t mode)", "sline": 116, "body": "{\n    lv_bar_set_mode(obj, (lv_bar_mode_t)mode);\n}"}, "lv_slider_get_value": {"type": "Function", "def": "static inline int32_t lv_slider_get_value(const lv_obj_t * obj)", "sline": 130, "body": "{\n    return lv_bar_get_value(obj);\n}"}, "lv_slider_get_left_value": {"type": "Function", "def": "static inline int32_t lv_slider_get_left_value(const lv_obj_t * obj)", "sline": 140, "body": "{\n    return lv_bar_get_start_value(obj);\n}"}, "lv_slider_get_min_value": {"type": "Function", "def": "static inline int32_t lv_slider_get_min_value(const lv_obj_t * obj)", "sline": 150, "body": "{\n    return lv_bar_get_min_value(obj);\n}"}, "lv_slider_get_max_value": {"type": "Function", "def": "static inline int32_t lv_slider_get_max_value(const lv_obj_t * obj)", "sline": 160, "body": "{\n    return lv_bar_get_max_value(obj);\n}"}, "lv_slider_is_dragged": {"type": "Function", "def": "bool lv_slider_is_dragged(const lv_obj_t * obj)", "sline": 170}, "lv_slider_get_mode": {"type": "Function", "def": "static inline lv_slider_mode_t lv_slider_get_mode(lv_obj_t * slider)", "sline": 177, "body": "{\n    lv_bar_mode_t mode = lv_bar_get_mode(slider);\n    if(mode == LV_BAR_MODE_SYMMETRICAL) return LV_SLIDER_MODE_SYMMETRICAL;\n    else if(mode == LV_BAR_MODE_RANGE) return LV_SLIDER_MODE_RANGE;\n    else return LV_SLIDER_MODE_NORMAL;\n}", "rels": [["lv_slider_mode_t", null, "Typeof"]]}, "carbit_updater/lvgl/src/widgets/lv_slider.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_slider.h"}}, "carbit_updater/lvgl/src/extra/widgets/list/lv_list.h": {"lv_obj": {"type": "Variable", "def": "#include ../../../core/lv_obj.h", "sline": 16}, "lv_flex": {"type": "Variable", "def": "#include ../../layouts/flex/lv_flex.h", "sline": 17}, "lv_list_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_list_class", "sline": 29}, "lv_list_text_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_list_text_class", "sline": 30}, "lv_list_btn_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_list_btn_class", "sline": 31}, "lv_list_create": {"type": "Function", "def": "lv_obj_t * lv_list_create(lv_obj_t * parent)", "sline": 36}, "lv_list_add_text": {"type": "Function", "def": "lv_obj_t * lv_list_add_text(lv_obj_t * list, const char * txt)", "sline": 38}, "lv_list_add_btn": {"type": "Function", "def": "lv_obj_t * lv_list_add_btn(lv_obj_t * list, const char * icon, const char * txt)", "sline": 40}, "lv_list_get_btn_text": {"type": "Function", "def": "const char * lv_list_get_btn_text(lv_obj_t * list, lv_obj_t * btn)", "sline": 42}, "carbit_updater/lvgl/src/extra/widgets/list/lv_list.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/list/lv_list.h"}}, "carbit_updater/lvgl/src/draw/lv_img_decoder.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 18}, "lv_img_buf": {"type": "Variable", "def": "#include lv_img_buf.h", "sline": 19, "include": ["carbit_updater/lvgl/src/draw/lv_img_buf.h", null]}, "lv_fs": {"type": "Variable", "def": "#include ../misc/lv_fs.h", "sline": 20}, "lv_types": {"type": "Variable", "def": "#include ../misc/lv_types.h", "sline": 21}, "lv_area": {"type": "Variable", "def": "#include ../misc/lv_area.h", "sline": 22}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_img_decoder.h:34:1)": {"type": "Enum", "def": "enum {\n    LV_IMG_SRC_VARIABLE, /** Binary/C variable*/\n    LV_IMG_SRC_FILE, /** File in filesystem*/\n    LV_IMG_SRC_SYMBOL, /** Symbol (@ref lv_symbol_def.h)*/\n    LV_IMG_SRC_UNKNOWN, /** Unknown source*/\n}", "sline": 34, "docstring": "/**"}, "lv_img_src_t": {"type": "Variable", "def": "typedef uint8_t lv_img_src_t", "sline": 41}, "_lv_img_decoder_dsc_t": {"type": "Struct", "def": "struct _lv_img_decoder_dsc_t {\n    /**The decoder which was able to open the image source*/\n    lv_img_decoder_t * decoder;\n\n    /**The image source. A file path like \"S:my_img.png\" or pointer to an `lv_img_dsc_t` variable*/\n    const void * src;\n\n    /**Color to draw the image. USed when the image has alpha channel only*/\n    lv_color_t color;\n\n    /**Frame of the image, using with animated images*/\n    int32_t frame_id;\n\n    /**Type of the source: file or variable. Can be set in `open` function if required*/\n    lv_img_src_t src_type;\n\n    /**Info about the opened image: color format, size, etc. MUST be set in `open` function*/\n    lv_img_header_t header;\n\n    /** Pointer to a buffer where the image's data (pixels) are stored in a decoded, plain format.\n     *  MUST be set in `open` function*/\n    const uint8_t * img_data;\n\n    /** How much time did it take to open the image. [ms]\n     *  If not set `lv_img_cache` will measure and set the time to open*/\n    uint32_t time_to_open;\n\n    /**A text to display instead of the image when the image can't be opened.\n     * Can be set in `open` function or set NULL.*/\n    const char * error_msg;\n\n    /**Store any custom data here is required*/\n    void * user_data;\n}", "sline": 99, "docstring": "/**Describe an image decoding session. Stores data about the decoding*/", "body": "lv_img_decoder_t * decoder\nconst void * src\nlv_color_t color\nint32_t frame_id\nlv_img_src_t src_type\nlv_img_header_t header\nconst uint8_t * img_data\nuint32_t time_to_open\nconst char * error_msg\nvoid * user_data\n"}, "_lv_img_decoder_t": {"type": "Struct", "def": "struct _lv_img_decoder_t {\n    lv_img_decoder_info_f_t info_cb;\n    lv_img_decoder_open_f_t open_cb;\n    lv_img_decoder_read_line_f_t read_line_cb;\n    lv_img_decoder_close_f_t close_cb;\n\n#if LV_USE_USER_DATA\n    void * user_data;\n#endif\n}", "sline": 86, "body": "lv_img_decoder_info_f_t info_cb\nlv_img_decoder_open_f_t open_cb\nlv_img_decoder_read_line_f_t read_line_cb\nlv_img_decoder_close_f_t close_cb\nvoid * user_data\n"}, "lv_img_decoder_info_f_t": {"type": "Variable", "def": "typedef lv_res_t (*lv_img_decoder_info_f_t)(struct _lv_img_decoder_t * decoder, const void * src,\n                                            lv_img_header_t * header)", "sline": 54}, "lv_img_decoder_open_f_t": {"type": "Variable", "def": "typedef lv_res_t (*lv_img_decoder_open_f_t)(struct _lv_img_decoder_t * decoder, struct _lv_img_decoder_dsc_t * dsc)", "sline": 62}, "lv_img_decoder_read_line_f_t": {"type": "Variable", "def": "typedef lv_res_t (*lv_img_decoder_read_line_f_t)(struct _lv_img_decoder_t * decoder, struct _lv_img_decoder_dsc_t * dsc,\n                                                 lv_coord_t x, lv_coord_t y, lv_coord_t len, uint8_t * buf)", "sline": 75}, "lv_img_decoder_close_f_t": {"type": "Variable", "def": "typedef void (*lv_img_decoder_close_f_t)(struct _lv_img_decoder_t * decoder, struct _lv_img_decoder_dsc_t * dsc)", "sline": 83}, "_lv_img_decoder_t.info_cb": {"type": "Variable", "def": "lv_img_decoder_info_f_t info_cb", "sline": 87, "in_struct": "_lv_img_decoder_t", "rels": [["lv_img_decoder_info_f_t", null, "Typeof"]]}, "_lv_img_decoder_t.open_cb": {"type": "Variable", "def": "lv_img_decoder_open_f_t open_cb", "sline": 88, "in_struct": "_lv_img_decoder_t", "rels": [["lv_img_decoder_open_f_t", null, "Typeof"]]}, "_lv_img_decoder_t.read_line_cb": {"type": "Variable", "def": "lv_img_decoder_read_line_f_t read_line_cb", "sline": 89, "in_struct": "_lv_img_decoder_t", "rels": [["lv_img_decoder_read_line_f_t", null, "Typeof"]]}, "_lv_img_decoder_t.close_cb": {"type": "Variable", "def": "lv_img_decoder_close_f_t close_cb", "sline": 90, "in_struct": "_lv_img_decoder_t", "rels": [["lv_img_decoder_close_f_t", null, "Typeof"]]}, "_lv_img_decoder_t.user_data": {"type": "Variable", "def": "void * user_data", "sline": 93, "in_struct": "_lv_img_decoder_t"}, "lv_img_decoder_t": {"type": "Variable", "def": "typedef struct _lv_img_decoder_t {\n    lv_img_decoder_info_f_t info_cb;\n    lv_img_decoder_open_f_t open_cb;\n    lv_img_decoder_read_line_f_t read_line_cb;\n    lv_img_decoder_close_f_t close_cb;\n\n#if LV_USE_USER_DATA\n    void * user_data;\n#endif\n} lv_img_decoder_t", "sline": 95}, "_lv_img_decoder_dsc_t.decoder": {"type": "Variable", "def": "lv_img_decoder_t * decoder", "sline": 101, "in_struct": "_lv_img_decoder_dsc_t"}, "_lv_img_decoder_dsc_t.src": {"type": "Variable", "def": "const void * src", "sline": 104, "in_struct": "_lv_img_decoder_dsc_t"}, "_lv_img_decoder_dsc_t.color": {"type": "Variable", "def": "lv_color_t color", "sline": 107, "in_struct": "_lv_img_decoder_dsc_t"}, "_lv_img_decoder_dsc_t.frame_id": {"type": "Variable", "def": "int32_t frame_id", "sline": 110, "in_struct": "_lv_img_decoder_dsc_t"}, "_lv_img_decoder_dsc_t.src_type": {"type": "Variable", "def": "lv_img_src_t src_type", "sline": 113, "in_struct": "_lv_img_decoder_dsc_t", "rels": [["lv_img_src_t", null, "Typeof"]]}, "_lv_img_decoder_dsc_t.header": {"type": "Variable", "def": "lv_img_header_t header", "sline": 116, "in_struct": "_lv_img_decoder_dsc_t"}, "_lv_img_decoder_dsc_t.img_data": {"type": "Variable", "def": "const uint8_t * img_data", "sline": 120, "in_struct": "_lv_img_decoder_dsc_t"}, "_lv_img_decoder_dsc_t.time_to_open": {"type": "Variable", "def": "uint32_t time_to_open", "sline": 124, "in_struct": "_lv_img_decoder_dsc_t"}, "_lv_img_decoder_dsc_t.error_msg": {"type": "Variable", "def": "const char * error_msg", "sline": 128, "in_struct": "_lv_img_decoder_dsc_t"}, "_lv_img_decoder_dsc_t.user_data": {"type": "Variable", "def": "void * user_data", "sline": 131, "in_struct": "_lv_img_decoder_dsc_t"}, "lv_img_decoder_dsc_t": {"type": "Variable", "def": "typedef struct _lv_img_decoder_dsc_t {\n    /**The decoder which was able to open the image source*/\n    lv_img_decoder_t * decoder;\n\n    /**The image source. A file path like \"S:my_img.png\" or pointer to an `lv_img_dsc_t` variable*/\n    const void * src;\n\n    /**Color to draw the image. USed when the image has alpha channel only*/\n    lv_color_t color;\n\n    /**Frame of the image, using with animated images*/\n    int32_t frame_id;\n\n    /**Type of the source: file or variable. Can be set in `open` function if required*/\n    lv_img_src_t src_type;\n\n    /**Info about the opened image: color format, size, etc. MUST be set in `open` function*/\n    lv_img_header_t header;\n\n    /** Pointer to a buffer where the image's data (pixels) are stored in a decoded, plain format.\n     *  MUST be set in `open` function*/\n    const uint8_t * img_data;\n\n    /** How much time did it take to open the image. [ms]\n     *  If not set `lv_img_cache` will measure and set the time to open*/\n    uint32_t time_to_open;\n\n    /**A text to display instead of the image when the image can't be opened.\n     * Can be set in `open` function or set NULL.*/\n    const char * error_msg;\n\n    /**Store any custom data here is required*/\n    void * user_data;\n} lv_img_decoder_dsc_t", "sline": 132, "docstring": "/**Describe an image decoding session. Stores data about the decoding*/"}, "_lv_img_decoder_init": {"type": "Function", "def": "void _lv_img_decoder_init(void)", "sline": 141}, "lv_img_decoder_get_info": {"type": "Function", "def": "lv_res_t lv_img_decoder_get_info(const void * src, lv_img_header_t * header)", "sline": 153}, "lv_img_decoder_open": {"type": "Function", "def": "lv_res_t lv_img_decoder_open(lv_img_decoder_dsc_t * dsc, const void * src, lv_color_t color, int32_t frame_id)", "sline": 168}, "lv_img_decoder_read_line": {"type": "Function", "def": "lv_res_t lv_img_decoder_read_line(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y, lv_coord_t len,\n                                  uint8_t * buf)", "sline": 179}, "lv_img_decoder_close": {"type": "Function", "def": "void lv_img_decoder_close(lv_img_decoder_dsc_t * dsc)", "sline": 186}, "lv_img_decoder_create": {"type": "Function", "def": "lv_img_decoder_t * lv_img_decoder_create(void)", "sline": 192}, "lv_img_decoder_delete": {"type": "Function", "def": "void lv_img_decoder_delete(lv_img_decoder_t * decoder)", "sline": 198}, "lv_img_decoder_set_info_cb": {"type": "Function", "def": "void lv_img_decoder_set_info_cb(lv_img_decoder_t * decoder, lv_img_decoder_info_f_t info_cb)", "sline": 205}, "lv_img_decoder_set_open_cb": {"type": "Function", "def": "void lv_img_decoder_set_open_cb(lv_img_decoder_t * decoder, lv_img_decoder_open_f_t open_cb)", "sline": 212}, "lv_img_decoder_set_read_line_cb": {"type": "Function", "def": "void lv_img_decoder_set_read_line_cb(lv_img_decoder_t * decoder, lv_img_decoder_read_line_f_t read_line_cb)", "sline": 219}, "lv_img_decoder_set_close_cb": {"type": "Function", "def": "void lv_img_decoder_set_close_cb(lv_img_decoder_t * decoder, lv_img_decoder_close_f_t close_cb)", "sline": 226}, "lv_img_decoder_built_in_info": {"type": "Function", "def": "lv_res_t lv_img_decoder_built_in_info(lv_img_decoder_t * decoder, const void * src, lv_img_header_t * header)", "sline": 235}, "lv_img_decoder_built_in_open": {"type": "Function", "def": "lv_res_t lv_img_decoder_built_in_open(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc)", "sline": 243}, "lv_img_decoder_built_in_read_line": {"type": "Function", "def": "lv_res_t lv_img_decoder_built_in_read_line(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc, lv_coord_t x,\n                                           lv_coord_t y, lv_coord_t len, uint8_t * buf)", "sline": 256}, "lv_img_decoder_built_in_close": {"type": "Function", "def": "void lv_img_decoder_built_in_close(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc)", "sline": 264}, "carbit_updater/lvgl/src/draw/lv_img_decoder.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_img_decoder.h"}}, "carbit_updater/lvgl/src/extra/themes/basic/lv_theme_basic.h": {"lv_obj": {"type": "Variable", "def": "#include ../../../core/lv_obj.h", "sline": 16}, "lv_theme_basic_init": {"type": "Function", "def": "lv_theme_t * lv_theme_basic_init(lv_disp_t * disp)", "sline": 37}, "carbit_updater/lvgl/src/extra/themes/basic/lv_theme_basic.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/themes/basic/lv_theme_basic.h"}}, "carbit_updater/lvgl/src/misc/lv_printf.c": {"lv_printf": {"type": "Variable", "def": "#include lv_printf.h", "sline": 35, "include": ["carbit_updater/lvgl/src/misc/lv_printf.h", null]}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 39}, "out_fct_type": {"type": "Variable", "def": "typedef void (*out_fct_type)(char character, void * buffer, size_t idx, size_t maxlen)", "sline": 116, "docstring": "// output function type"}, "out_fct_wrap_type.fct": {"type": "Variable", "def": "void (*fct)(char character, void * arg)", "sline": 120, "in_struct": "out_fct_wrap_type"}, "out_fct_wrap_type.arg": {"type": "Variable", "def": "void * arg", "sline": 121, "in_struct": "out_fct_wrap_type"}, "out_fct_wrap_type": {"type": "Variable", "def": "typedef struct {\n    void (*fct)(char character, void * arg);\n    void * arg;\n} out_fct_wrap_type", "sline": 122, "docstring": "// wrapper (used as buffer) for output function type"}, "_out_buffer": {"type": "Function", "def": "static inline void _out_buffer(char character, void * buffer, size_t idx, size_t maxlen)", "sline": 125, "docstring": "// internal buffer output", "body": "{\n    if(idx < maxlen) {\n        ((char *)buffer)[idx] = character;\n    }\n}"}, "_out_null": {"type": "Function", "def": "static inline void _out_null(char character, void * buffer, size_t idx, size_t maxlen)", "sline": 133, "docstring": "// internal null output", "body": "{\n    LV_UNUSED(character);\n    LV_UNUSED(buffer);\n    LV_UNUSED(idx);\n    LV_UNUSED(maxlen);\n}"}, "_strnlen_s": {"type": "Function", "def": "static inline unsigned int _strnlen_s(const char * str, size_t maxsize)", "sline": 143, "docstring": "// internal secure strlen\n// \\return The length of the string (excluding the terminating 0) limited by 'maxsize'", "body": "{\n    const char * s;\n    for(s = str; *s && maxsize--; ++s);\n    return (unsigned int)(s - str);\n}"}, "_is_digit": {"type": "Function", "def": "static inline bool _is_digit(char ch)", "sline": 152, "docstring": "// internal test if char is a digit (0-9)\n// \\return true if char is a digit", "body": "{\n    return (ch >= '0') && (ch <= '9');\n}"}, "_atoi": {"type": "Function", "def": "static unsigned int _atoi(const char ** str)", "sline": 158, "docstring": "// internal ASCII string to unsigned int conversion", "body": "{\n    unsigned int i = 0U;\n    while(_is_digit(**str)) {\n        i = i * 10U + (unsigned int)(*((*str)++) - '0');\n    }\n    return i;\n}"}, "_out_rev": {"type": "Function", "def": "static size_t _out_rev(out_fct_type out, char * buffer, size_t idx, size_t maxlen, const char * buf, size_t len,\n                       unsigned int width, unsigned int flags)", "sline": 168, "docstring": "// output the specified string in reverse, taking care of any zero-padding", "body": "{\n    const size_t start_idx = idx;\n\n    // pad spaces up to given width\n    if(!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {\n        size_t i;\n        for(i = len; i < width; i++) {\n            out(' ', buffer, idx++, maxlen);\n        }\n    }\n\n    // reverse string\n    while(len) {\n        out(buf[--len], buffer, idx++, maxlen);\n    }\n\n    // append pad spaces up to given width\n    if(flags & FLAGS_LEFT) {\n        while(idx - start_idx < width) {\n            out(' ', buffer, idx++, maxlen);\n        }\n    }\n\n    return idx;\n}"}, "_ntoa_format": {"type": "Function", "def": "static size_t _ntoa_format(out_fct_type out, char * buffer, size_t idx, size_t maxlen, char * buf, size_t len,\n                           bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)", "sline": 197, "docstring": "// internal itoa format", "body": "{\n    // pad leading zeros\n    if(!(flags & FLAGS_LEFT)) {\n        if(width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {\n            width--;\n        }\n        while((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\n            buf[len++] = '0';\n        }\n        while((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\n            buf[len++] = '0';\n        }\n    }\n\n    // handle hash\n    if(flags & FLAGS_HASH) {\n        if(!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {\n            len--;\n            if(len && (base == 16U)) {\n                len--;\n            }\n        }\n        if((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\n            buf[len++] = 'x';\n        }\n        else if((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\n            buf[len++] = 'X';\n        }\n        else if((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\n            buf[len++] = 'b';\n        }\n        if(len < PRINTF_NTOA_BUFFER_SIZE) {\n            buf[len++] = '0';\n        }\n    }\n\n    if(len < PRINTF_NTOA_BUFFER_SIZE) {\n        if(negative) {\n            buf[len++] = '-';\n        }\n        else if(flags & FLAGS_PLUS) {\n            buf[len++] = '+';  // ignore the space if the '+' exists\n        }\n        else if(flags & FLAGS_SPACE) {\n            buf[len++] = ' ';\n        }\n    }\n\n    return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);\n}"}, "_ntoa_long": {"type": "Function", "def": "static size_t _ntoa_long(out_fct_type out, char * buffer, size_t idx, size_t maxlen, unsigned long value, bool negative,\n                         unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)", "sline": 251, "docstring": "// internal itoa for 'long' type", "body": "{\n    char buf[PRINTF_NTOA_BUFFER_SIZE];\n    size_t len = 0U;\n\n    // no hash for 0 values\n    if(!value) {\n        flags &= ~FLAGS_HASH;\n    }\n\n    // write if precision != 0 and value is != 0\n    if(!(flags & FLAGS_PRECISION) || value) {\n        do {\n            const char digit = (char)(value % base);\n            buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;\n            value /= base;\n        } while(value && (len < PRINTF_NTOA_BUFFER_SIZE));\n    }\n\n    return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);\n}"}, "_ntoa_long_long": {"type": "Function", "def": "static size_t _ntoa_long_long(out_fct_type out, char * buffer, size_t idx, size_t maxlen, unsigned long long value,\n                              bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)", "sline": 276, "docstring": "// internal itoa for 'long long' type", "body": "{\n    char buf[PRINTF_NTOA_BUFFER_SIZE];\n    size_t len = 0U;\n\n    // no hash for 0 values\n    if(!value) {\n        flags &= ~FLAGS_HASH;\n    }\n\n    // write if precision != 0 and value is != 0\n    if(!(flags & FLAGS_PRECISION) || value) {\n        do {\n            const char digit = (char)(value % base);\n            buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;\n            value /= base;\n        } while(value && (len < PRINTF_NTOA_BUFFER_SIZE));\n    }\n\n    return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);\n}"}, "_vsnprintf": {"type": "Function", "def": "static int _vsnprintf(out_fct_type out, char * buffer, const size_t maxlen, const char * format, va_list va)", "sline": 550, "docstring": "// internal vsnprintf", "body": "{\n    unsigned int flags, width, precision, n;\n    size_t idx = 0U;\n\n    if(!buffer) {\n        // use null output function\n        out = _out_null;\n    }\n\n    while(*format) {\n        // format specifier?  %[flags][width][.precision][length]\n        if(*format != '%') {\n            // no\n            out(*format, buffer, idx++, maxlen);\n            format++;\n            continue;\n        }\n        else {\n            // yes, evaluate it\n            format++;\n        }\n\n        // evaluate flags\n        flags = 0U;\n        do {\n            switch(*format) {\n                case '0':\n                    flags |= FLAGS_ZEROPAD;\n                    format++;\n                    n = 1U;\n                    break;\n                case '-':\n                    flags |= FLAGS_LEFT;\n                    format++;\n                    n = 1U;\n                    break;\n                case '+':\n                    flags |= FLAGS_PLUS;\n                    format++;\n                    n = 1U;\n                    break;\n                case ' ':\n                    flags |= FLAGS_SPACE;\n                    format++;\n                    n = 1U;\n                    break;\n                case '#':\n                    flags |= FLAGS_HASH;\n                    format++;\n                    n = 1U;\n                    break;\n                default :\n                    n = 0U;\n                    break;\n            }\n        } while(n);\n\n        // evaluate width field\n        width = 0U;\n        if(_is_digit(*format)) {\n            width = _atoi(&format);\n        }\n        else if(*format == '*') {\n            const int w = va_arg(va, int);\n            if(w < 0) {\n                flags |= FLAGS_LEFT;    // reverse padding\n                width = (unsigned int) - w;\n            }\n            else {\n                width = (unsigned int)w;\n            }\n            format++;\n        }\n\n        // evaluate precision field\n        precision = 0U;\n        if(*format == '.') {\n            flags |= FLAGS_PRECISION;\n            format++;\n            if(_is_digit(*format)) {\n                precision = _atoi(&format);\n            }\n            else if(*format == '*') {\n                const int prec = (int)va_arg(va, int);\n                precision = prec > 0 ? (unsigned int)prec : 0U;\n                format++;\n            }\n        }\n\n        // evaluate length field\n        switch(*format) {\n            case 'l' :\n                flags |= FLAGS_LONG;\n                format++;\n                if(*format == 'l') {\n                    flags |= FLAGS_LONG_LONG;\n                    format++;\n                }\n                break;\n            case 'h' :\n                flags |= FLAGS_SHORT;\n                format++;\n                if(*format == 'h') {\n                    flags |= FLAGS_CHAR;\n                    format++;\n                }\n                break;\n#if defined(PRINTF_SUPPORT_PTRDIFF_T)\n            case 't' :\n                flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);\n                format++;\n                break;\n#endif\n            case 'j' :\n                flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);\n                format++;\n                break;\n            case 'z' :\n                flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);\n                format++;\n                break;\n            default :\n                break;\n        }\n\n        // evaluate specifier\n        switch(*format) {\n            case 'd' :\n            case 'i' :\n            case 'u' :\n            case 'x' :\n            case 'X' :\n            case 'p' :\n            case 'P' :\n            case 'o' :\n            case 'b' : {\n                    // set the base\n                    unsigned int base;\n                    if(*format == 'x' || *format == 'X') {\n                        base = 16U;\n                    }\n                    else if(*format == 'p' || *format == 'P') {\n                        base = 16U;\n                        flags |= FLAGS_HASH;   // always hash for pointer format\n#if defined(PRINTF_SUPPORT_LONG_LONG)\n                        if(sizeof(uintptr_t) == sizeof(long long))\n                            flags |= FLAGS_LONG_LONG;\n                        else\n#endif\n                            flags |= FLAGS_LONG;\n\n                        if(*(format + 1) == 'V')\n                            format++;\n                    }\n                    else if(*format == 'o') {\n                        base =  8U;\n                    }\n                    else if(*format == 'b') {\n                        base =  2U;\n                    }\n                    else {\n                        base = 10U;\n                        flags &= ~FLAGS_HASH;   // no hash for dec format\n                    }\n                    // uppercase\n                    if(*format == 'X' || *format == 'P') {\n                        flags |= FLAGS_UPPERCASE;\n                    }\n\n                    // no plus or space flag for u, x, X, o, b\n                    if((*format != 'i') && (*format != 'd')) {\n                        flags &= ~(FLAGS_PLUS | FLAGS_SPACE);\n                    }\n\n                    // ignore '0' flag when precision is given\n                    if(flags & FLAGS_PRECISION) {\n                        flags &= ~FLAGS_ZEROPAD;\n                    }\n\n                    // convert the integer\n                    if((*format == 'i') || (*format == 'd')) {\n                        // signed\n                        if(flags & FLAGS_LONG_LONG) {\n#if defined(PRINTF_SUPPORT_LONG_LONG)\n                            const long long value = va_arg(va, long long);\n                            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base,\n                                                  precision, width, flags);\n#endif\n                        }\n                        else if(flags & FLAGS_LONG) {\n                            const long value = va_arg(va, long);\n                            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision,\n                                             width, flags);\n                        }\n                        else {\n                            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va,\n                                                                                                                                       int) : va_arg(va, int);\n                            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision,\n                                             width, flags);\n                        }\n                    }\n                    else if (*format == 'V') {\n                        lv_vaformat_t * vaf = va_arg(va, lv_vaformat_t *);\n                        va_list copy;\n\n                        va_copy(copy, *vaf->va);\n                        idx += _vsnprintf(out, buffer + idx, maxlen - idx, vaf->fmt, copy);\n                        va_end(copy);\n                    }\n                    else {\n                        // unsigned\n                        if(flags & FLAGS_LONG_LONG) {\n#if defined(PRINTF_SUPPORT_LONG_LONG)\n                            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);\n#endif\n                        }\n                        else if(flags & FLAGS_LONG) {\n                            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);\n                        }\n                        else {\n                            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va,\n                                                                                                    unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);\n                            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);\n                        }\n                    }\n                    format++;\n                    break;\n                }\n#if defined(PRINTF_SUPPORT_FLOAT)\n            case 'f' :\n            case 'F' :\n                if(*format == 'F') flags |= FLAGS_UPPERCASE;\n                idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);\n                format++;\n                break;\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\n            case 'e':\n            case 'E':\n            case 'g':\n            case 'G':\n                if((*format == 'g') || (*format == 'G')) flags |= FLAGS_ADAPT_EXP;\n                if((*format == 'E') || (*format == 'G')) flags |= FLAGS_UPPERCASE;\n                idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);\n                format++;\n                break;\n#endif  // PRINTF_SUPPORT_EXPONENTIAL\n#endif  // PRINTF_SUPPORT_FLOAT\n            case 'c' : {\n                    unsigned int l = 1U;\n                    // pre padding\n                    if(!(flags & FLAGS_LEFT)) {\n                        while(l++ < width) {\n                            out(' ', buffer, idx++, maxlen);\n                        }\n                    }\n                    // char output\n                    out((char)va_arg(va, int), buffer, idx++, maxlen);\n                    // post padding\n                    if(flags & FLAGS_LEFT) {\n                        while(l++ < width) {\n                            out(' ', buffer, idx++, maxlen);\n                        }\n                    }\n                    format++;\n                    break;\n                }\n\n            case 's' : {\n                    const char * p = va_arg(va, char *);\n                    unsigned int l = _strnlen_s(p, precision ? precision : (size_t) -1);\n                    // pre padding\n                    if(flags & FLAGS_PRECISION) {\n                        l = (l < precision ? l : precision);\n                    }\n                    if(!(flags & FLAGS_LEFT)) {\n                        while(l++ < width) {\n                            out(' ', buffer, idx++, maxlen);\n                        }\n                    }\n                    // string output\n                    while((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {\n                        out(*(p++), buffer, idx++, maxlen);\n                    }\n                    // post padding\n                    if(flags & FLAGS_LEFT) {\n                        while(l++ < width) {\n                            out(' ', buffer, idx++, maxlen);\n                        }\n                    }\n                    format++;\n                    break;\n                }\n\n            case '%' :\n                out('%', buffer, idx++, maxlen);\n                format++;\n                break;\n\n            default :\n                out(*format, buffer, idx++, maxlen);\n                format++;\n                break;\n        }\n    }\n\n    // termination\n    out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);\n\n    // return written chars without terminating \\0\n    return (int)idx;\n}"}, "lv_snprintf": {"type": "Function", "def": "int lv_snprintf(char * buffer, size_t count, const char * format, ...)", "sline": 865, "docstring": "///////////////////////////////////////////////////////////////////////////////", "body": "{\n    va_list va;\n    va_start(va, format);\n    const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);\n    va_end(va);\n    return ret;\n}"}, "lv_vsnprintf": {"type": "Function", "def": "int lv_vsnprintf(char * buffer, size_t count, const char * format, va_list va)", "sline": 874, "body": "{\n    return _vsnprintf(_out_buffer, buffer, count, format, va);\n}"}, "carbit_updater/lvgl/src/misc/lv_printf.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_printf.c"}}, "carbit_updater/lvgl/src/lvgl.h": {"lvgl": {"type": "Variable", "def": "#include ../lvgl.h", "sline": 17}, "carbit_updater/lvgl/src/lvgl.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/lvgl.h"}}, "carbit_updater/lvgl/src/core/lv_obj_pos.c": {"lv_obj": {"type": "Variable", "def": "#include lv_obj.h", "sline": 9, "include": ["carbit_updater/lvgl/src/core/lv_obj.h", null]}, "lv_disp": {"type": "Variable", "def": "#include lv_disp.h", "sline": 10, "include": ["carbit_updater/lvgl/src/core/lv_disp.h", null]}, "lv_refr": {"type": "Variable", "def": "#include lv_refr.h", "sline": 11, "include": ["carbit_updater/lvgl/src/core/lv_refr.h", null]}, "lv_gc": {"type": "Variable", "def": "#include ../misc/lv_gc.h", "sline": 12}, "calc_content_width": {"type": "Function", "def": "static lv_coord_t calc_content_width(lv_obj_t * obj)", "sline": 927, "body": "{\n    lv_obj_scroll_to_x(obj, 0, LV_ANIM_OFF);\n\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n    lv_coord_t pad_right = lv_obj_get_style_pad_right(obj, LV_PART_MAIN) + border_width;\n    lv_coord_t pad_left = lv_obj_get_style_pad_left(obj, LV_PART_MAIN) + border_width;\n\n    lv_coord_t self_w;\n    self_w = lv_obj_get_self_width(obj) +  pad_left + pad_right;\n\n    lv_coord_t child_res = LV_COORD_MIN;\n    uint32_t i;\n    uint32_t child_cnt = lv_obj_get_child_cnt(obj);\n    /*With RTL find the left most coordinate*/\n    if(lv_obj_get_style_base_dir(obj, LV_PART_MAIN) == LV_BASE_DIR_RTL) {\n        for(i = 0; i < child_cnt; i++) {\n            lv_obj_t * child = obj->spec_attr->children[i];\n            if(lv_obj_has_flag_any(child,  LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;\n\n            if(!lv_obj_is_layout_positioned(child)) {\n                lv_align_t align = lv_obj_get_style_align(child, 0);\n                switch(align) {\n                    case LV_ALIGN_DEFAULT:\n                    case LV_ALIGN_TOP_RIGHT:\n                    case LV_ALIGN_BOTTOM_RIGHT:\n                    case LV_ALIGN_RIGHT_MID:\n                        /*Normal right aligns. Other are ignored due to possible circular dependencies*/\n                        child_res = LV_MAX(child_res, obj->coords.x2 - child->coords.x1 + 1);\n                        break;\n                    default:\n                    \t/* Consider other cases only if x=0 and use the width of the object.\n                    \t * With x!=0 circular dependency could occur. */\n                    \tif(lv_obj_get_style_y(child, 0) == 0) {\n                    \t\tchild_res = LV_MAX(child_res, lv_area_get_width(&child->coords));\n                    \t}\n                }\n            } else {\n                child_res = LV_MAX(child_res, obj->coords.x2 - child->coords.x1 + 1);\n            }\n        }\n        if(child_res != LV_COORD_MIN) {\n            child_res += pad_left;\n        }\n    }\n    /*Else find the right most coordinate*/\n    else {\n        for(i = 0; i < child_cnt; i++) {\n            lv_obj_t * child = obj->spec_attr->children[i];\n            if(lv_obj_has_flag_any(child,  LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;\n\n            if(!lv_obj_is_layout_positioned(child)) {\n                lv_align_t align = lv_obj_get_style_align(child, 0);\n                switch(align) {\n                    case LV_ALIGN_DEFAULT:\n                    case LV_ALIGN_TOP_LEFT:\n                    case LV_ALIGN_BOTTOM_LEFT:\n                    case LV_ALIGN_LEFT_MID:\n                        /*Normal left aligns.*/\n                        child_res = LV_MAX(child_res, child->coords.x2 - obj->coords.x1 + 1);\n                        break;\n                    default:\n                    \t/* Consider other cases only if x=0 and use the width of the object.\n                    \t * With x!=0 circular dependency could occur. */\n                    \tif(lv_obj_get_style_y(child, 0) == 0) {\n                    \t\tchild_res = LV_MAX(child_res, lv_area_get_width(&child->coords));\n                    \t}\n                }\n            } else {\n                child_res = LV_MAX(child_res, child->coords.x2 - obj->coords.x1 + 1);\n            }\n        }\n\n        if(child_res != LV_COORD_MIN) {\n            child_res += pad_right;\n        }\n    }\n\n    if(child_res == LV_COORD_MIN) return self_w;\n    else return LV_MAX(child_res, self_w);\n}"}, "calc_content_height": {"type": "Function", "def": "static lv_coord_t calc_content_height(lv_obj_t * obj)", "sline": 1009, "body": "{\n    lv_obj_scroll_to_y(obj, 0, LV_ANIM_OFF);\n\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n    lv_coord_t pad_top = lv_obj_get_style_pad_top(obj, LV_PART_MAIN) + border_width;\n    lv_coord_t pad_bottom = lv_obj_get_style_pad_bottom(obj, LV_PART_MAIN) + border_width;\n\n    lv_coord_t self_h;\n    self_h = lv_obj_get_self_height(obj) + pad_top + pad_bottom;\n\n    lv_coord_t child_res = LV_COORD_MIN;\n    uint32_t i;\n    uint32_t child_cnt = lv_obj_get_child_cnt(obj);\n    for(i = 0; i < child_cnt; i++) {\n        lv_obj_t * child = obj->spec_attr->children[i];\n        if(lv_obj_has_flag_any(child,  LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;\n\n\n        if(!lv_obj_is_layout_positioned(child)) {\n            lv_align_t align = lv_obj_get_style_align(child, 0);\n            switch(align) {\n                case LV_ALIGN_DEFAULT:\n                case LV_ALIGN_TOP_RIGHT:\n                case LV_ALIGN_TOP_MID:\n                case LV_ALIGN_TOP_LEFT:\n                    /*Normal top aligns. */\n                    child_res = LV_MAX(child_res, child->coords.y2 - obj->coords.y1 + 1);\n                    break;\n                default:\n                \t/* Consider other cases only if y=0 and use the height of the object.\n                \t * With y!=0 circular dependency could occur. */\n                \tif(lv_obj_get_style_y(child, 0) == 0) {\n                \t\tchild_res = LV_MAX(child_res, lv_area_get_height(&child->coords));\n                \t}\n                \tbreak;\n            }\n        } else {\n            child_res = LV_MAX(child_res, child->coords.y2 - obj->coords.y1 + 1);\n        }\n    }\n\n    if(child_res != LV_COORD_MIN) {\n        child_res += pad_bottom;\n        return LV_MAX(child_res, self_h);\n    } else {\n        return self_h;\n    }\n\n}"}, "layout_update_core": {"type": "Function", "def": "static void layout_update_core(lv_obj_t * obj)", "sline": 1060, "body": "{\n    uint32_t i;\n    uint32_t child_cnt = lv_obj_get_child_cnt(obj);\n    for(i = 0; i < child_cnt; i++) {\n        lv_obj_t * child = obj->spec_attr->children[i];\n        layout_update_core(child);\n    }\n\n    if(obj->layout_inv == 0) return;\n\n    obj->layout_inv = 0;\n\n    lv_obj_refr_size(obj);\n    lv_obj_refr_pos(obj);\n\n    if(child_cnt > 0) {\n        uint32_t layout_id = lv_obj_get_style_layout(obj, LV_PART_MAIN);\n        if(layout_id > 0 && layout_id <= layout_cnt) {\n            void  * user_data = LV_GC_ROOT(_lv_layout_list)[layout_id - 1].user_data;\n            LV_GC_ROOT(_lv_layout_list)[layout_id - 1].cb(obj, user_data);\n        }\n    }\n}"}, "layout_cnt": {"type": "Variable", "def": "static uint32_t layout_cnt", "sline": 33}, "lv_obj_set_pos": {"type": "Function", "def": "void lv_obj_set_pos(lv_obj_t * obj, lv_coord_t x, lv_coord_t y)", "sline": 43, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_obj_set_x(obj, x);\n    lv_obj_set_y(obj, y);\n}"}, "lv_obj_set_x": {"type": "Function", "def": "void lv_obj_set_x(lv_obj_t * obj, lv_coord_t x)", "sline": 51, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_res_t res_x;\n    lv_style_value_t v_x;\n\n    res_x = lv_obj_get_local_style_prop(obj, LV_STYLE_X, &v_x, 0);\n\n    if((res_x == LV_RES_OK && v_x.num != x) || res_x == LV_RES_INV) {\n        lv_obj_set_style_x(obj, x, 0);\n    }\n}"}, "lv_obj_set_y": {"type": "Function", "def": "void lv_obj_set_y(lv_obj_t * obj, lv_coord_t y)", "sline": 65, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_res_t res_y;\n    lv_style_value_t v_y;\n\n    res_y = lv_obj_get_local_style_prop(obj, LV_STYLE_Y, &v_y, 0);\n\n    if((res_y == LV_RES_OK && v_y.num != y) || res_y == LV_RES_INV) {\n        lv_obj_set_style_y(obj, y, 0);\n    }\n}"}, "lv_obj_refr_size": {"type": "Function", "def": "bool lv_obj_refr_size(lv_obj_t * obj)", "sline": 79, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    /*If the width or height is set by a layout do not modify them*/\n    if(obj->w_layout && obj->h_layout) return false;\n\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    if(parent == NULL) return false;\n\n    lv_coord_t sl_ori = lv_obj_get_scroll_left(obj);\n    bool w_is_content = false;\n    bool w_is_pct = false;\n\n    lv_coord_t w;\n    if(obj->w_layout) {\n        w = lv_obj_get_width(obj);\n    }\n    else {\n        w = lv_obj_get_style_width(obj, LV_PART_MAIN);\n        w_is_content = w == LV_SIZE_CONTENT ? true : false;\n        w_is_pct = LV_COORD_IS_PCT(w) ? true : false;\n        lv_coord_t parent_w = lv_obj_get_content_width(parent);\n\n        if(w_is_content) {\n            w = calc_content_width(obj);\n        }\n        else if(w_is_pct) {\n            /*If parent has content size and the child has pct size\n             *a circular dependency will occur. To solve it keep child size at zero */\n            if(parent->w_layout == 0 && lv_obj_get_style_width(parent, 0) == LV_SIZE_CONTENT) {\n                lv_coord_t border_w = lv_obj_get_style_border_width(obj, 0);\n                w = lv_obj_get_style_pad_left(obj, 0) + border_w;\n                w += lv_obj_get_style_pad_right(obj, 0) + border_w;\n            }\n            else {\n                w = (LV_COORD_GET_PCT(w) * parent_w) / 100;\n            }\n        }\n\n        lv_coord_t minw = lv_obj_get_style_min_width(obj, LV_PART_MAIN);\n        lv_coord_t maxw = lv_obj_get_style_max_width(obj, LV_PART_MAIN);\n        w = lv_clamp_width(w, minw, maxw, parent_w);\n    }\n\n    lv_coord_t st_ori = lv_obj_get_scroll_top(obj);\n    lv_coord_t h;\n    bool h_is_content = false;\n    bool h_is_pct = false;\n    if(obj->h_layout) {\n        h = lv_obj_get_height(obj);\n    }\n    else {\n        h = lv_obj_get_style_height(obj, LV_PART_MAIN);\n        h_is_content = h == LV_SIZE_CONTENT ? true : false;\n        h_is_pct = LV_COORD_IS_PCT(h) ? true : false;\n        lv_coord_t parent_h = lv_obj_get_content_height(parent);\n\n        if(h_is_content) {\n            h = calc_content_height(obj);\n        }\n        else if(h_is_pct) {\n            /*If parent has content size and the child has pct size\n             *a circular dependency will occur. To solve it keep child size at zero */\n            if(parent->h_layout == 0 && lv_obj_get_style_height(parent, 0) == LV_SIZE_CONTENT) {\n                lv_coord_t border_w = lv_obj_get_style_border_width(obj, 0);\n                h = lv_obj_get_style_pad_top(obj, 0) + border_w;\n                h += lv_obj_get_style_pad_bottom(obj, 0) + border_w;\n            }\n            else {\n                h = (LV_COORD_GET_PCT(h) * parent_h) / 100;\n            }\n        }\n\n        lv_coord_t minh = lv_obj_get_style_min_height(obj, LV_PART_MAIN);\n        lv_coord_t maxh = lv_obj_get_style_max_height(obj, LV_PART_MAIN);\n        h = lv_clamp_height(h, minh, maxh, parent_h);\n    }\n\n    /*calc_auto_size set the scroll x/y to 0 so revert the original value*/\n    if(w_is_content || h_is_content) {\n        lv_obj_scroll_to(obj, sl_ori, st_ori, LV_ANIM_OFF);\n    }\n\n    /*Do nothing if the size is not changed*/\n    /*It is very important else recursive resizing can occur without size change*/\n    if(lv_obj_get_width(obj) == w && lv_obj_get_height(obj) == h) return false;\n\n    /*Invalidate the original area*/\n    lv_obj_invalidate(obj);\n\n    /*Save the original coordinates*/\n    lv_area_t ori;\n    lv_obj_get_coords(obj, &ori);\n\n    /*Check if the object inside the parent or not*/\n    lv_area_t parent_fit_area;\n    lv_obj_get_content_coords(parent, &parent_fit_area);\n\n    /*If the object is already out of the parent and its position is changes\n     *surely the scrollbars also changes so invalidate them*/\n    bool on1 = _lv_area_is_in(&ori, &parent_fit_area, 0);\n    if(!on1) lv_obj_scrollbar_invalidate(parent);\n\n    /*Set the length and height\n     *Be sure the content is not scrolled in an invalid position on the new size*/\n    obj->coords.y2 = obj->coords.y1 + h - 1;\n    if(lv_obj_get_style_base_dir(obj, LV_PART_MAIN) == LV_BASE_DIR_RTL) {\n        obj->coords.x1 = obj->coords.x2 - w + 1;\n    }\n    else {\n        obj->coords.x2 = obj->coords.x1 + w - 1;\n    }\n\n    /*Call the ancestor's event handler to the object with its new coordinates*/\n    lv_event_send(obj, LV_EVENT_SIZE_CHANGED, &ori);\n\n    /*Call the ancestor's event handler to the parent too*/\n    lv_event_send(parent, LV_EVENT_CHILD_CHANGED, obj);\n\n    /*Invalidate the new area*/\n    lv_obj_invalidate(obj);\n\n    lv_obj_readjust_scroll(obj, LV_ANIM_OFF);\n\n    /*If the object was out of the parent invalidate the new scrollbar area too.\n     *If it wasn't out of the parent but out now, also invalidate the srollbars*/\n    bool on2 = _lv_area_is_in(&obj->coords, &parent_fit_area, 0);\n    if(on1 || (!on1 && on2)) lv_obj_scrollbar_invalidate(parent);\n\n    return true;\n}"}, "lv_obj_set_size": {"type": "Function", "def": "void lv_obj_set_size(lv_obj_t * obj, lv_coord_t w, lv_coord_t h)", "sline": 212, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_obj_set_width(obj, w);\n    lv_obj_set_height(obj, h);\n}"}, "lv_obj_set_width": {"type": "Function", "def": "void lv_obj_set_width(lv_obj_t * obj, lv_coord_t w)", "sline": 220, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_res_t res_w;\n    lv_style_value_t v_w;\n\n    res_w = lv_obj_get_local_style_prop(obj, LV_STYLE_WIDTH, &v_w, 0);\n\n    if((res_w == LV_RES_OK && v_w.num != w) || res_w == LV_RES_INV) {\n        lv_obj_set_style_width(obj, w, 0);\n    }\n}"}, "lv_obj_set_height": {"type": "Function", "def": "void lv_obj_set_height(lv_obj_t * obj, lv_coord_t h)", "sline": 233, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_res_t res_h;\n    lv_style_value_t v_h;\n\n    res_h = lv_obj_get_local_style_prop(obj, LV_STYLE_HEIGHT, &v_h, 0);\n\n    if((res_h == LV_RES_OK && v_h.num != h) || res_h == LV_RES_INV) {\n        lv_obj_set_style_height(obj, h, 0);\n    }\n}"}, "lv_obj_set_content_width": {"type": "Function", "def": "void lv_obj_set_content_width(lv_obj_t * obj, lv_coord_t w)", "sline": 246, "body": "{\n    lv_coord_t pleft = lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n    lv_coord_t pright = lv_obj_get_style_pad_right(obj, LV_PART_MAIN);\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n\n    lv_obj_set_width(obj, w + pleft + pright + 2 * border_width);\n}"}, "lv_obj_set_content_height": {"type": "Function", "def": "void lv_obj_set_content_height(lv_obj_t * obj, lv_coord_t h)", "sline": 255, "body": "{\n    lv_coord_t ptop = lv_obj_get_style_pad_top(obj, LV_PART_MAIN);\n    lv_coord_t pbottom = lv_obj_get_style_pad_bottom(obj, LV_PART_MAIN);\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n\n    lv_obj_set_height(obj, h + ptop + pbottom + 2 * border_width);\n}"}, "lv_obj_set_layout": {"type": "Function", "def": "void lv_obj_set_layout(lv_obj_t * obj, uint32_t layout)", "sline": 264, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_obj_set_style_layout(obj, layout, 0);\n\n    lv_obj_mark_layout_as_dirty(obj);\n}"}, "lv_obj_is_layout_positioned": {"type": "Function", "def": "bool lv_obj_is_layout_positioned(const lv_obj_t * obj)", "sline": 273, "body": "{\n    if(lv_obj_has_flag_any(obj, LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_IGNORE_LAYOUT | LV_OBJ_FLAG_FLOATING)) return false;\n\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    if(parent == NULL) return false;\n\n    uint32_t layout = lv_obj_get_style_layout(parent, LV_PART_MAIN);\n    if(layout) return true;\n    else return false;\n}"}, "lv_obj_mark_layout_as_dirty": {"type": "Function", "def": "void lv_obj_mark_layout_as_dirty(lv_obj_t * obj)", "sline": 285, "body": "{\n    obj->layout_inv = 1;\n\n    /*Mark the screen as dirty too to mark that there is something to do on this screen*/\n    lv_obj_t * scr = lv_obj_get_screen(obj);\n    scr->scr_layout_inv = 1;\n\n    /*Make the display refreshing*/\n    lv_disp_t * disp = lv_obj_get_disp(scr);\n    lv_timer_resume(disp->refr_timer);\n}"}, "lv_obj_update_layout": {"type": "Function", "def": "void lv_obj_update_layout(const lv_obj_t * obj)", "sline": 298, "body": "{\n    static bool mutex = false;\n    if(mutex) {\n        LV_LOG_TRACE(\"Already running, returning\");\n        return;\n    }\n    mutex = true;\n\n    lv_obj_t * scr = lv_obj_get_screen(obj);\n\n    /*Repeat until there where layout invalidations*/\n    while(scr->scr_layout_inv) {\n        LV_LOG_INFO(\"Layout update begin\");\n        scr->scr_layout_inv = 0;\n        layout_update_core(scr);\n        LV_LOG_TRACE(\"Layout update end\");\n    }\n\n    mutex = false;\n}"}, "lv_layout_register": {"type": "Function", "def": "uint32_t lv_layout_register(lv_layout_update_cb_t cb, void * user_data)", "sline": 320, "body": "{\n    layout_cnt++;\n    LV_GC_ROOT(_lv_layout_list) = lv_mem_realloc(LV_GC_ROOT(_lv_layout_list), layout_cnt * sizeof(lv_layout_dsc_t));\n    LV_ASSERT_MALLOC(LV_GC_ROOT(_lv_layout_list));\n\n    LV_GC_ROOT(_lv_layout_list)[layout_cnt - 1].cb = cb;\n    LV_GC_ROOT(_lv_layout_list)[layout_cnt - 1].user_data = user_data;\n    return layout_cnt;  /*No -1 to skip 0th index*/\n}"}, "lv_obj_set_align": {"type": "Function", "def": "void lv_obj_set_align(lv_obj_t * obj, lv_align_t align)", "sline": 331, "body": "{\n    lv_obj_set_style_align(obj, align, 0);\n}"}, "lv_obj_align": {"type": "Function", "def": "void lv_obj_align(lv_obj_t * obj, lv_align_t align, lv_coord_t x_ofs, lv_coord_t y_ofs)", "sline": 336, "body": "{\n    lv_obj_set_style_align(obj, align, 0);\n    lv_obj_set_pos(obj, x_ofs, y_ofs);\n}"}, "lv_obj_align_to": {"type": "Function", "def": "void lv_obj_align_to(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs, lv_coord_t y_ofs)", "sline": 342, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_obj_update_layout(obj);\n    if(base == NULL) base = lv_obj_get_parent(obj);\n\n    LV_ASSERT_OBJ(base, MY_CLASS);\n\n    lv_coord_t x = 0;\n    lv_coord_t y = 0;\n\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    lv_coord_t pborder = lv_obj_get_style_border_width(parent, LV_PART_MAIN);\n    lv_coord_t pleft = lv_obj_get_style_pad_left(parent, LV_PART_MAIN) + pborder;\n    lv_coord_t ptop = lv_obj_get_style_pad_top(parent, LV_PART_MAIN) + pborder;\n\n    lv_coord_t bborder = lv_obj_get_style_border_width(base, LV_PART_MAIN);\n    lv_coord_t bleft = lv_obj_get_style_pad_left(base, LV_PART_MAIN) + bborder;\n    lv_coord_t btop = lv_obj_get_style_pad_top(base, LV_PART_MAIN) + bborder;\n\n    if(align == LV_ALIGN_DEFAULT) {\n        if(lv_obj_get_style_base_dir(base, LV_PART_MAIN) == LV_BASE_DIR_RTL) align = LV_ALIGN_TOP_RIGHT;\n        else align = LV_ALIGN_TOP_LEFT;\n    }\n\n    switch(align) {\n        case LV_ALIGN_CENTER:\n            x = lv_obj_get_content_width(base) / 2 - lv_obj_get_width(obj) / 2 + bleft;\n            y = lv_obj_get_content_height(base) / 2 - lv_obj_get_height(obj) / 2 + btop;\n            break;\n        case LV_ALIGN_TOP_LEFT:\n            x = bleft;\n            y = btop;\n            break;\n        case LV_ALIGN_TOP_MID:\n            x = lv_obj_get_content_width(base) / 2 - lv_obj_get_width(obj) / 2 + bleft;\n            y = btop;\n            break;\n\n        case LV_ALIGN_TOP_RIGHT:\n            x = lv_obj_get_content_width(base) - lv_obj_get_width(obj) + bleft;\n            y = btop;\n            break;\n\n        case LV_ALIGN_BOTTOM_LEFT:\n            x = bleft;\n            y = lv_obj_get_content_height(base) - lv_obj_get_height(obj) + btop;\n            break;\n        case LV_ALIGN_BOTTOM_MID:\n            x = lv_obj_get_content_width(base) / 2 - lv_obj_get_width(obj) / 2 + bleft;\n            y = lv_obj_get_content_height(base) - lv_obj_get_height(obj) + btop;\n            break;\n\n        case LV_ALIGN_BOTTOM_RIGHT:\n            x = lv_obj_get_content_width(base) - lv_obj_get_width(obj) + bleft;\n            y = lv_obj_get_content_height(base) - lv_obj_get_height(obj) + btop;\n            break;\n\n        case LV_ALIGN_LEFT_MID:\n            x = bleft;\n            y = lv_obj_get_content_height(base) / 2 - lv_obj_get_height(obj) / 2 + btop;\n            break;\n\n        case LV_ALIGN_RIGHT_MID:\n            x = lv_obj_get_content_width(base) - lv_obj_get_width(obj) + bleft;\n            y = lv_obj_get_content_height(base) / 2 - lv_obj_get_height(obj) / 2 + btop;\n            break;\n\n        case LV_ALIGN_OUT_TOP_LEFT:\n            x = 0;\n            y = -lv_obj_get_height(obj);\n            break;\n\n        case LV_ALIGN_OUT_TOP_MID:\n            x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;\n            y = -lv_obj_get_height(obj);\n            break;\n\n        case LV_ALIGN_OUT_TOP_RIGHT:\n            x = lv_obj_get_width(base) - lv_obj_get_width(obj);\n            y = -lv_obj_get_height(obj);\n            break;\n\n        case LV_ALIGN_OUT_BOTTOM_LEFT:\n            x = 0;\n            y = lv_obj_get_height(base);\n            break;\n\n        case LV_ALIGN_OUT_BOTTOM_MID:\n            x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;\n            y = lv_obj_get_height(base);\n            break;\n\n        case LV_ALIGN_OUT_BOTTOM_RIGHT:\n            x = lv_obj_get_width(base) - lv_obj_get_width(obj);\n            y = lv_obj_get_height(base);\n            break;\n\n        case LV_ALIGN_OUT_LEFT_TOP:\n            x = -lv_obj_get_width(obj);\n            y = 0;\n            break;\n\n        case LV_ALIGN_OUT_LEFT_MID:\n            x = -lv_obj_get_width(obj);\n            y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;\n            break;\n\n        case LV_ALIGN_OUT_LEFT_BOTTOM:\n            x = -lv_obj_get_width(obj);\n            y = lv_obj_get_height(base) - lv_obj_get_height(obj);\n            break;\n\n        case LV_ALIGN_OUT_RIGHT_TOP:\n            x = lv_obj_get_width(base);\n            y = 0;\n            break;\n\n        case LV_ALIGN_OUT_RIGHT_MID:\n            x = lv_obj_get_width(base);\n            y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;\n            break;\n\n        case LV_ALIGN_OUT_RIGHT_BOTTOM:\n            x = lv_obj_get_width(base);\n            y = lv_obj_get_height(base) - lv_obj_get_height(obj);\n            break;\n    }\n\n    if(lv_obj_get_style_base_dir(parent, LV_PART_MAIN) == LV_BASE_DIR_RTL) {\n        x += x_ofs + base->coords.x1 - parent->coords.x1 + lv_obj_get_scroll_right(parent) - pleft;\n    }\n    else {\n        x += x_ofs + base->coords.x1 - parent->coords.x1 + lv_obj_get_scroll_left(parent) - pleft;\n    }\n    y += y_ofs + base->coords.y1 - parent->coords.y1 + lv_obj_get_scroll_top(parent) - ptop;\n    lv_obj_set_style_align(obj, LV_ALIGN_TOP_LEFT, 0);\n    lv_obj_set_pos(obj, x, y);\n\n}"}, "lv_obj_get_coords": {"type": "Function", "def": "void lv_obj_get_coords(const lv_obj_t * obj, lv_area_t * coords)", "sline": 484, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_area_copy(coords, &obj->coords);\n}"}, "lv_obj_get_x": {"type": "Function", "def": "lv_coord_t lv_obj_get_x(const lv_obj_t * obj)", "sline": 491, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_coord_t rel_x;\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    if(parent) {\n        rel_x  = obj->coords.x1 - parent->coords.x1;\n        rel_x += lv_obj_get_scroll_x(parent);\n        rel_x -= lv_obj_get_style_pad_left(parent, LV_PART_MAIN);\n        rel_x -= lv_obj_get_style_border_width(parent, LV_PART_MAIN);\n    }\n    else {\n        rel_x = obj->coords.x1;\n    }\n    return rel_x;\n}"}, "lv_obj_get_x2": {"type": "Function", "def": "lv_coord_t lv_obj_get_x2(const lv_obj_t * obj)", "sline": 509, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    return lv_obj_get_x(obj) + lv_obj_get_width(obj);\n}"}, "lv_obj_get_y": {"type": "Function", "def": "lv_coord_t lv_obj_get_y(const lv_obj_t * obj)", "sline": 516, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_coord_t rel_y;\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    if(parent) {\n        rel_y = obj->coords.y1 - parent->coords.y1;\n        rel_y += lv_obj_get_scroll_y(parent);\n        rel_y -= lv_obj_get_style_pad_top(parent, LV_PART_MAIN);\n        rel_y -= lv_obj_get_style_border_width(parent, LV_PART_MAIN);\n    }\n    else {\n        rel_y = obj->coords.y1;\n    }\n    return rel_y;\n}"}, "lv_obj_get_y2": {"type": "Function", "def": "lv_coord_t lv_obj_get_y2(const lv_obj_t * obj)", "sline": 534, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    return lv_obj_get_y(obj) + lv_obj_get_height(obj);\n}"}, "lv_obj_get_width": {"type": "Function", "def": "lv_coord_t lv_obj_get_width(const lv_obj_t * obj)", "sline": 541, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    return lv_area_get_width(&obj->coords);\n}"}, "lv_obj_get_height": {"type": "Function", "def": "lv_coord_t lv_obj_get_height(const lv_obj_t * obj)", "sline": 548, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    return lv_area_get_height(&obj->coords);\n}"}, "lv_obj_get_content_width": {"type": "Function", "def": "lv_coord_t lv_obj_get_content_width(const lv_obj_t * obj)", "sline": 555, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_coord_t left = lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n    lv_coord_t right = lv_obj_get_style_pad_right(obj, LV_PART_MAIN);\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n\n    return lv_obj_get_width(obj) - left - right - 2 * border_width;\n}"}, "lv_obj_get_content_height": {"type": "Function", "def": "lv_coord_t lv_obj_get_content_height(const lv_obj_t * obj)", "sline": 566, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_coord_t top = lv_obj_get_style_pad_top(obj, LV_PART_MAIN);\n    lv_coord_t bottom =  lv_obj_get_style_pad_bottom(obj, LV_PART_MAIN);\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n\n    return lv_obj_get_height(obj) - top - bottom - 2 * border_width;\n}"}, "lv_obj_get_content_coords": {"type": "Function", "def": "void lv_obj_get_content_coords(const lv_obj_t * obj, lv_area_t * area)", "sline": 577, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n\n    lv_obj_get_coords(obj, area);\n    lv_area_increase(area, -border_width, -border_width);\n    area->x1 += lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n    area->x2 -= lv_obj_get_style_pad_right(obj, LV_PART_MAIN);\n    area->y1 += lv_obj_get_style_pad_top(obj, LV_PART_MAIN);\n    area->y2 -= lv_obj_get_style_pad_bottom(obj, LV_PART_MAIN);\n\n}"}, "lv_obj_get_self_width": {"type": "Function", "def": "lv_coord_t lv_obj_get_self_width(const lv_obj_t * obj)", "sline": 591, "body": "{\n    lv_point_t p = {0, LV_COORD_MIN};\n    lv_event_send((lv_obj_t *)obj, LV_EVENT_GET_SELF_SIZE, &p);\n    return p.x;\n}"}, "lv_obj_get_self_height": {"type": "Function", "def": "lv_coord_t lv_obj_get_self_height(const lv_obj_t * obj)", "sline": 598, "body": "{\n    lv_point_t p = {LV_COORD_MIN, 0};\n    lv_event_send((lv_obj_t *)obj, LV_EVENT_GET_SELF_SIZE, &p);\n    return p.y;\n}"}, "lv_obj_refresh_self_size": {"type": "Function", "def": "bool lv_obj_refresh_self_size(lv_obj_t * obj)", "sline": 605, "body": "{\n    lv_coord_t w_set = lv_obj_get_style_width(obj, LV_PART_MAIN);\n    lv_coord_t h_set = lv_obj_get_style_height(obj, LV_PART_MAIN);\n    if(w_set != LV_SIZE_CONTENT && h_set != LV_SIZE_CONTENT) return false;\n\n    lv_obj_mark_layout_as_dirty(obj);\n    return true;\n}"}, "lv_obj_refr_pos": {"type": "Function", "def": "void lv_obj_refr_pos(lv_obj_t * obj)", "sline": 615, "body": "{\n    if(lv_obj_is_layout_positioned(obj)) return;\n\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    lv_coord_t x = lv_obj_get_style_x(obj, LV_PART_MAIN);\n    lv_coord_t y = lv_obj_get_style_y(obj, LV_PART_MAIN);\n\n    if(parent == NULL) {\n        lv_obj_move_to(obj, x, y);\n        return;\n    }\n\n    /*Handle percentage value*/\n    lv_coord_t pw = lv_obj_get_content_width(parent);\n    lv_coord_t ph = lv_obj_get_content_height(parent);\n    if(LV_COORD_IS_PCT(x)) x = (pw * LV_COORD_GET_PCT(x)) / 100;\n    if(LV_COORD_IS_PCT(y)) y = (ph * LV_COORD_GET_PCT(y)) / 100;\n\n    /*Handle percentage value of translate*/\n    lv_coord_t tr_x = lv_obj_get_style_translate_x(obj, LV_PART_MAIN);\n    lv_coord_t tr_y = lv_obj_get_style_translate_y(obj, LV_PART_MAIN);\n    lv_coord_t w = lv_obj_get_width(obj);\n    lv_coord_t h = lv_obj_get_height(obj);\n    if(LV_COORD_IS_PCT(tr_x)) tr_x = (w * LV_COORD_GET_PCT(tr_x)) / 100;\n    if(LV_COORD_IS_PCT(tr_y)) tr_y = (h * LV_COORD_GET_PCT(tr_y)) / 100;\n\n    /*Use the translation*/\n    x += tr_x;\n    y += tr_y;\n\n    lv_align_t align = lv_obj_get_style_align(obj, LV_PART_MAIN);\n\n    if(align == LV_ALIGN_DEFAULT) {\n        if(lv_obj_get_style_base_dir(parent, LV_PART_MAIN) == LV_BASE_DIR_RTL) align = LV_ALIGN_TOP_RIGHT;\n        else align = LV_ALIGN_TOP_LEFT;\n    }\n\n    if(align == LV_ALIGN_TOP_LEFT) {\n        lv_obj_move_to(obj, x, y);\n    }\n    else {\n\n        switch(align) {\n            case LV_ALIGN_TOP_MID:\n                x += pw / 2 - w / 2;\n                break;\n            case LV_ALIGN_TOP_RIGHT:\n                x += pw - w;\n                break;\n            case LV_ALIGN_LEFT_MID:\n                y += ph / 2 - h / 2;\n                break;\n            case LV_ALIGN_BOTTOM_LEFT:\n                y += ph - h;\n                break;\n            case LV_ALIGN_BOTTOM_MID:\n                x += pw / 2 - w / 2;\n                y += ph - h;\n                break;\n            case LV_ALIGN_BOTTOM_RIGHT:\n                x += pw - w;\n                y += ph - h;\n                break;\n            case LV_ALIGN_RIGHT_MID:\n                x += pw - w;\n                y += ph / 2 - h / 2;\n                break;\n            case LV_ALIGN_CENTER:\n                x += pw / 2 - w / 2;\n                y += ph / 2 - h / 2;\n                break;\n            default:\n                break;\n        }\n        lv_obj_move_to(obj, x, y);\n    }\n}"}, "lv_obj_move_to": {"type": "Function", "def": "void lv_obj_move_to(lv_obj_t * obj, lv_coord_t x, lv_coord_t y)", "sline": 694, "body": "{\n    /*Convert x and y to absolute coordinates*/\n    lv_obj_t * parent = obj->parent;\n\n    if(parent) {\n        lv_coord_t pad_left = lv_obj_get_style_pad_left(parent, LV_PART_MAIN);\n        lv_coord_t pad_top = lv_obj_get_style_pad_top(parent, LV_PART_MAIN);\n\n        if(lv_obj_has_flag(obj, LV_OBJ_FLAG_FLOATING)) {\n            x += pad_left + parent->coords.x1;\n            y += pad_top + parent->coords.y1;\n        }\n        else {\n            x += pad_left + parent->coords.x1 - lv_obj_get_scroll_x(parent);\n            y += pad_top + parent->coords.y1 - lv_obj_get_scroll_y(parent);\n        }\n\n        lv_coord_t border_width = lv_obj_get_style_border_width(parent, LV_PART_MAIN);\n        x += border_width;\n        y += border_width;\n    }\n\n    /*Calculate and set the movement*/\n    lv_point_t diff;\n    diff.x = x - obj->coords.x1;\n    diff.y = y - obj->coords.y1;\n\n    /*Do nothing if the position is not changed*/\n    /*It is very important else recursive positioning can\n     *occur without position change*/\n    if(diff.x == 0 && diff.y == 0) return;\n\n    /*Invalidate the original area*/\n    lv_obj_invalidate(obj);\n\n    /*Save the original coordinates*/\n    lv_area_t ori;\n    lv_obj_get_coords(obj, &ori);\n\n    /*Check if the object inside the parent or not*/\n    lv_area_t parent_fit_area;\n    bool on1 = false;\n    if(parent) {\n        lv_obj_get_content_coords(parent, &parent_fit_area);\n\n        /*If the object is already out of the parent and its position is changes\n         *surely the scrollbars also changes so invalidate them*/\n        on1 = _lv_area_is_in(&ori, &parent_fit_area, 0);\n        if(!on1) lv_obj_scrollbar_invalidate(parent);\n    }\n\n    obj->coords.x1 += diff.x;\n    obj->coords.y1 += diff.y;\n    obj->coords.x2 += diff.x;\n    obj->coords.y2 += diff.y;\n\n    lv_obj_move_children_by(obj, diff.x, diff.y, false);\n\n    /*Call the ancestor's event handler to the parent too*/\n    if(parent) lv_event_send(parent, LV_EVENT_CHILD_CHANGED, obj);\n\n    /*Invalidate the new area*/\n    lv_obj_invalidate(obj);\n\n    /*If the object was out of the parent invalidate the new scrollbar area too.\n     *If it wasn't out of the parent but out now, also invalidate the srollbars*/\n    if(parent) {\n        bool on2 = _lv_area_is_in(&obj->coords, &parent_fit_area, 0);\n        if(on1 || (!on1 && on2)) lv_obj_scrollbar_invalidate(parent);\n    }\n}"}, "lv_obj_move_children_by": {"type": "Function", "def": "void lv_obj_move_children_by(lv_obj_t * obj, lv_coord_t x_diff, lv_coord_t y_diff, bool ignore_floating)", "sline": 767, "body": "{\n    uint32_t i;\n    uint32_t child_cnt = lv_obj_get_child_cnt(obj);\n    for(i = 0; i < child_cnt; i++) {\n        lv_obj_t * child = obj->spec_attr->children[i];\n        if(ignore_floating && lv_obj_has_flag(child, LV_OBJ_FLAG_FLOATING)) continue;\n        child->coords.x1 += x_diff;\n        child->coords.y1 += y_diff;\n        child->coords.x2 += x_diff;\n        child->coords.y2 += y_diff;\n\n        lv_obj_move_children_by(child, x_diff, y_diff, false);\n    }\n}"}, "lv_obj_invalidate_area": {"type": "Function", "def": "void lv_obj_invalidate_area(const lv_obj_t * obj, const lv_area_t * area)", "sline": 784, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_area_t area_tmp;\n    lv_area_copy(&area_tmp, area);\n    bool visible = lv_obj_area_is_visible(obj, &area_tmp);\n\n    if(visible) _lv_inv_area(lv_obj_get_disp(obj), &area_tmp);\n}"}, "lv_obj_invalidate": {"type": "Function", "def": "void lv_obj_invalidate(const lv_obj_t * obj)", "sline": 795, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    /*Truncate the area to the object*/\n    lv_area_t obj_coords;\n    lv_coord_t ext_size = _lv_obj_get_ext_draw_size(obj);\n    lv_area_copy(&obj_coords, &obj->coords);\n    obj_coords.x1 -= ext_size;\n    obj_coords.y1 -= ext_size;\n    obj_coords.x2 += ext_size;\n    obj_coords.y2 += ext_size;\n\n    lv_obj_invalidate_area(obj, &obj_coords);\n\n}"}, "lv_obj_area_is_visible": {"type": "Function", "def": "bool lv_obj_area_is_visible(const lv_obj_t * obj, lv_area_t * area)", "sline": 812, "body": "{\n    if(lv_obj_has_flag(obj, LV_OBJ_FLAG_HIDDEN)) return false;\n\n    /*Invalidate the object only if it belongs to the current or previous'*/\n    lv_obj_t * obj_scr = lv_obj_get_screen(obj);\n    lv_disp_t * disp   = lv_obj_get_disp(obj_scr);\n    if(obj_scr != lv_disp_get_scr_act(disp) &&\n       obj_scr != lv_disp_get_scr_prev(disp) &&\n       obj_scr != lv_disp_get_layer_top(disp) &&\n       obj_scr != lv_disp_get_layer_sys(disp)) {\n        return false;\n    }\n\n    /*Truncate the area to the object*/\n    lv_area_t obj_coords;\n    lv_coord_t ext_size = _lv_obj_get_ext_draw_size(obj);\n    lv_area_copy(&obj_coords, &obj->coords);\n    obj_coords.x1 -= ext_size;\n    obj_coords.y1 -= ext_size;\n    obj_coords.x2 += ext_size;\n    obj_coords.y2 += ext_size;\n\n    bool is_common;\n\n    is_common = _lv_area_intersect(area, area, &obj_coords);\n    if(is_common == false) return false;  /*The area is not on the object*/\n\n    /*Truncate recursively to the parents*/\n    lv_obj_t * par = lv_obj_get_parent(obj);\n    while(par != NULL) {\n        is_common = _lv_area_intersect(area, area, &par->coords);\n        if(is_common == false) return false;       /*If no common parts with parent break;*/\n        if(lv_obj_has_flag(par, LV_OBJ_FLAG_HIDDEN)) return\n                false; /*If the parent is hidden then the child is hidden and won't be drawn*/\n\n        par = lv_obj_get_parent(par);\n    }\n\n    return true;\n}"}, "lv_obj_is_visible": {"type": "Function", "def": "bool lv_obj_is_visible(const lv_obj_t * obj)", "sline": 854, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_area_t obj_coords;\n    lv_coord_t ext_size = _lv_obj_get_ext_draw_size(obj);\n    lv_area_copy(&obj_coords, &obj->coords);\n    obj_coords.x1 -= ext_size;\n    obj_coords.y1 -= ext_size;\n    obj_coords.x2 += ext_size;\n    obj_coords.y2 += ext_size;\n\n    return lv_obj_area_is_visible(obj, &obj_coords);\n\n}"}, "lv_obj_set_ext_click_area": {"type": "Function", "def": "void lv_obj_set_ext_click_area(lv_obj_t * obj, lv_coord_t size)", "sline": 870, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_obj_allocate_spec_attr(obj);\n    obj->spec_attr->ext_click_pad = size;\n}"}, "lv_obj_get_click_area": {"type": "Function", "def": "void lv_obj_get_click_area(const lv_obj_t * obj, lv_area_t * area)", "sline": 878, "body": "{\n    lv_area_copy(area, &obj->coords);\n    if(obj->spec_attr) {\n        area->x1 -= obj->spec_attr->ext_click_pad;\n        area->x2 += obj->spec_attr->ext_click_pad;\n        area->y1 -= obj->spec_attr->ext_click_pad;\n        area->y2 += obj->spec_attr->ext_click_pad;\n    }\n}"}, "lv_obj_hit_test": {"type": "Function", "def": "bool lv_obj_hit_test(lv_obj_t * obj, const lv_point_t * point)", "sline": 889, "body": "{\n    lv_area_t a;\n    lv_obj_get_click_area(obj, &a);\n    bool res = _lv_area_is_point_on(&a, point, 0);\n    if(res == false) return false;\n\n    if(lv_obj_has_flag(obj, LV_OBJ_FLAG_ADV_HITTEST)) {\n        lv_hit_test_info_t hit_info;\n        hit_info.point = point;\n        hit_info.res = true;\n        lv_event_send(obj, LV_EVENT_HIT_TEST, &hit_info);\n        return hit_info.res;\n    }\n\n    return res;\n}"}, "lv_clamp_width": {"type": "Function", "def": "lv_coord_t lv_clamp_width(lv_coord_t width, lv_coord_t min_width, lv_coord_t max_width, lv_coord_t ref_width)", "sline": 907, "body": "{\n    if(LV_COORD_IS_PCT(min_width)) min_width = (ref_width * LV_COORD_GET_PCT(min_width)) / 100;\n    if(LV_COORD_IS_PCT(max_width)) max_width = (ref_width * LV_COORD_GET_PCT(max_width)) / 100;\n    return LV_CLAMP(min_width, width, max_width);\n}"}, "lv_clamp_height": {"type": "Function", "def": "lv_coord_t lv_clamp_height(lv_coord_t height, lv_coord_t min_height, lv_coord_t max_height, lv_coord_t ref_height)", "sline": 914, "body": "{\n    if(LV_COORD_IS_PCT(min_height)) min_height = (ref_height * LV_COORD_GET_PCT(min_height)) / 100;\n    if(LV_COORD_IS_PCT(max_height)) max_height = (ref_height * LV_COORD_GET_PCT(max_height)) / 100;\n    return LV_CLAMP(min_height, height, max_height);\n}"}, "carbit_updater/lvgl/src/core/lv_obj_pos.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_pos.c"}}, "carbit_updater/lv_drivers/indev/evdev.c": {"evdev": {"type": "Variable", "def": "#include evdev.h", "sline": 9, "include": ["carbit_updater/lv_drivers/indev/evdev.h", null]}, "stdio": {"type": "Variable", "def": "#include stdio.h", "sline": 12}, "unistd": {"type": "Variable", "def": "#include unistd.h", "sline": 13}, "fcntl": {"type": "Variable", "def": "#include fcntl.h", "sline": 14}, "input": {"type": "Variable", "def": "#include linux/input.h", "sline": 18}, "map": {"type": "Function", "def": "int map(int x, int in_min, int in_max, int out_min, int out_max)", "sline": 271, "docstring": "/**********************", "body": "{\n  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n}"}, "evdev_fd": {"type": "Variable", "def": "int evdev_fd", "sline": 41}, "evdev_root_x": {"type": "Variable", "def": "int evdev_root_x", "sline": 42}, "evdev_root_y": {"type": "Variable", "def": "int evdev_root_y", "sline": 43}, "evdev_button": {"type": "Variable", "def": "int evdev_button", "sline": 44}, "evdev_key_val": {"type": "Variable", "def": "int evdev_key_val", "sline": 46}, "evdev_init": {"type": "Function", "def": "void evdev_init(void)", "sline": 59, "docstring": "/**", "body": "{\n#if USE_BSD_EVDEV\n    evdev_fd = open(EVDEV_NAME, O_RDWR | O_NOCTTY);\n#else\n    if (access(\"/dev/input/touchscreen\", F_OK) != 0)\n        evdev_fd = open(EVDEV_NAME, O_RDWR | O_NOCTTY | O_NDELAY);\n    else\n        evdev_fd = open(\"/dev/input/touchscreen\", O_RDWR | O_NOCTTY | O_NDELAY);\n#endif\n    if(evdev_fd == -1) {\n        perror(\"unable open evdev interface:\");\n        return;\n    }\n\n#if USE_BSD_EVDEV\n    fcntl(evdev_fd, F_SETFL, O_NONBLOCK);\n#else\n    fcntl(evdev_fd, F_SETFL, O_ASYNC | O_NONBLOCK);\n#endif\n\n    evdev_root_x = 0;\n    evdev_root_y = 0;\n    evdev_key_val = 0;\n    evdev_button = LV_INDEV_STATE_REL;\n\n#if USE_XKB\n    xkb_init();\n#endif\n}"}, "evdev_set_file": {"type": "Function", "def": "bool evdev_set_file(char* dev_name)", "sline": 95, "body": "{ \n     if(evdev_fd != -1) {\n        close(evdev_fd);\n     }\n#if USE_BSD_EVDEV\n     evdev_fd = open(dev_name, O_RDWR | O_NOCTTY);\n#else\n     evdev_fd = open(dev_name, O_RDWR | O_NOCTTY | O_NDELAY);\n#endif\n\n     if(evdev_fd == -1) {\n        perror(\"unable open evdev interface:\");\n        return false;\n     }\n\n#if USE_BSD_EVDEV\n     fcntl(evdev_fd, F_SETFL, O_NONBLOCK);\n#else\n     fcntl(evdev_fd, F_SETFL, O_ASYNC | O_NONBLOCK);\n#endif\n\n     evdev_root_x = 0;\n     evdev_root_y = 0;\n     evdev_key_val = 0;\n     evdev_button = LV_INDEV_STATE_REL;\n\n     return true;\n}"}, "evdev_read": {"type": "Function", "def": "void evdev_read(lv_indev_drv_t * drv, lv_indev_data_t * data)", "sline": 128, "body": "{\n    struct input_event in;\n\n    while(read(evdev_fd, &in, sizeof(struct input_event)) > 0) {\n        if(in.type == EV_REL) {\n            if(in.code == REL_X)\n\t\t\t\t#if EVDEV_SWAP_AXES\n\t\t\t\t\tevdev_root_y += in.value;\n\t\t\t\t#else\n\t\t\t\t\tevdev_root_x += in.value;\n\t\t\t\t#endif\n            else if(in.code == REL_Y)\n\t\t\t\t#if EVDEV_SWAP_AXES\n\t\t\t\t\tevdev_root_x += in.value;\n\t\t\t\t#else\n\t\t\t\t\tevdev_root_y += in.value;\n\t\t\t\t#endif\n        } else if(in.type == EV_ABS) {\n            if(in.code == ABS_X)\n\t\t\t\t#if EVDEV_SWAP_AXES\n\t\t\t\t\tevdev_root_y = in.value;\n\t\t\t\t#else\n\t\t\t\t\tevdev_root_x = in.value;\n\t\t\t\t#endif\n            else if(in.code == ABS_Y)\n\t\t\t\t#if EVDEV_SWAP_AXES\n\t\t\t\t\tevdev_root_x = in.value;\n\t\t\t\t#else\n\t\t\t\t\tevdev_root_y = in.value;\n\t\t\t\t#endif\n            else if(in.code == ABS_MT_POSITION_X)\n                                #if EVDEV_SWAP_AXES\n                                        evdev_root_y = in.value;\n                                #else\n                                        evdev_root_x = in.value;\n                                #endif\n            else if(in.code == ABS_MT_POSITION_Y)\n                                #if EVDEV_SWAP_AXES\n                                        evdev_root_x = in.value;\n                                #else\n                                        evdev_root_y = in.value;\n                                #endif\n            else if(in.code == ABS_MT_TRACKING_ID) {\n                                if(in.value == -1)\n                                    evdev_button = LV_INDEV_STATE_REL;\n                                else if(in.value == 0)\n                                    evdev_button = LV_INDEV_STATE_PR;\n            } else if(in.code == ABS_PRESSURE) {\n                                if(in.value == 0)\n                                    evdev_button = LV_INDEV_STATE_REL;\n                                else if(in.value > 0)\n                                    evdev_button = LV_INDEV_STATE_PR;\n            }\n        } else if(in.type == EV_KEY) {\n            if(in.code == BTN_MOUSE || in.code == BTN_TOUCH) {\n                if(in.value == 0)\n                    evdev_button = LV_INDEV_STATE_REL;\n                else if(in.value == 1)\n                    evdev_button = LV_INDEV_STATE_PR;\n            } else if(drv->type == LV_INDEV_TYPE_KEYPAD) {\n#if USE_XKB\n                data->key = xkb_process_key(in.code, in.value != 0);\n#else\n                switch(in.code) {\n                    case KEY_BACKSPACE:\n                        data->key = LV_KEY_BACKSPACE;\n                        break;\n                    case KEY_ENTER:\n                        data->key = LV_KEY_ENTER;\n                        break;\n                    case KEY_PREVIOUS:\n                        data->key = LV_KEY_PREV;\n                        break;\n                    case KEY_NEXT:\n                        data->key = LV_KEY_NEXT;\n                        break;\n                    case KEY_UP:\n                        data->key = LV_KEY_UP;\n                        break;\n                    case KEY_LEFT:\n                        data->key = LV_KEY_LEFT;\n                        break;\n                    case KEY_RIGHT:\n                        data->key = LV_KEY_RIGHT;\n                        break;\n                    case KEY_DOWN:\n                        data->key = LV_KEY_DOWN;\n                        break;\n                    case KEY_TAB:\n                        data->key = LV_KEY_NEXT;\n                        break;\n                    default:\n                        data->key = 0;\n                        break;\n                }\n#endif /* USE_XKB */\n                if (data->key != 0) {\n                    /* Only record button state when actual output is produced to prevent widgets from refreshing */\n                    data->state = (in.value) ? LV_INDEV_STATE_PR : LV_INDEV_STATE_REL;\n                }\n                evdev_key_val = data->key;\n                evdev_button = data->state;\n                return;\n            }\n        }\n    }\n\n    if(drv->type == LV_INDEV_TYPE_KEYPAD) {\n        /* No data retrieved */\n        data->key = evdev_key_val;\n        data->state = evdev_button;\n        return;\n    }\n    if(drv->type != LV_INDEV_TYPE_POINTER)\n        return ;\n    /*Store the collected data*/\n\n#if EVDEV_CALIBRATE\n    data->point.x = map(evdev_root_x, EVDEV_HOR_MIN, EVDEV_HOR_MAX, 0, drv->disp->driver->hor_res);\n    data->point.y = map(evdev_root_y, EVDEV_VER_MIN, EVDEV_VER_MAX, 0, drv->disp->driver->ver_res);\n#else\n    data->point.x = evdev_root_x;\n    data->point.y = evdev_root_y;\n#endif\n\n    data->state = evdev_button;\n\n    if(data->point.x < 0)\n      data->point.x = 0;\n    if(data->point.y < 0)\n      data->point.y = 0;\n    if(data->point.x >= drv->disp->driver->hor_res)\n      data->point.x = drv->disp->driver->hor_res - 1;\n    if(data->point.y >= drv->disp->driver->ver_res)\n      data->point.y = drv->disp->driver->ver_res - 1;\n\n    return ;\n}"}, "carbit_updater/lv_drivers/indev/evdev.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/indev/evdev.c"}}, "carbit_updater/lvgl/src/extra/libs/sjpg/tjpgdcnf.h": {"carbit_updater/lvgl/src/extra/libs/sjpg/tjpgdcnf.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/sjpg/tjpgdcnf.h"}}, "carbit_updater/lvgl/src/widgets/lv_btnmatrix.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "lv_obj": {"type": "Variable", "def": "#include ../core/lv_obj.h", "sline": 20}, "_silence_gcc_warning": {"type": "Struct", "def": "LV_EXPORT_CONST_INT(LV_BTNMATRIX_BTN_NONE)", "sline": 26}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_btnmatrix.h:34:1)": {"type": "Enum", "def": "enum {\n    _LV_BTNMATRIX_WIDTH     = 0x0007,      /**< Reserved to stire the size units*/\n    LV_BTNMATRIX_CTRL_HIDDEN     = 0x0008, /**< Button hidden*/\n    LV_BTNMATRIX_CTRL_NO_REPEAT  = 0x0010, /**< Do not repeat press this button.*/\n    LV_BTNMATRIX_CTRL_DISABLED   = 0x0020, /**< Disable this button.*/\n    LV_BTNMATRIX_CTRL_CHECKABLE  = 0x0040, /**< The button can be toggled.*/\n    LV_BTNMATRIX_CTRL_CHECKED    = 0x0080, /**< Button is currently toggled (e.g. checked).*/\n    LV_BTNMATRIX_CTRL_CLICK_TRIG = 0x0100, /**< 1: Send LV_EVENT_VALUE_CHANGE on CLICK, 0: Send LV_EVENT_VALUE_CHANGE on PRESS*/\n    LV_BTNMATRIX_CTRL_POPOVER    = 0x0200, /**< Show a popover when pressing this key*/\n    LV_BTNMATRIX_CTRL_RECOLOR    = 0x1000, /**< Enable text recoloring with `#color`*/\n    _LV_BTNMATRIX_CTRL_RESERVED  = 0x2000, /**< Reserved for later use*/\n    LV_BTNMATRIX_CTRL_CUSTOM_1   = 0x4000, /**< Custom free to use flag*/\n    LV_BTNMATRIX_CTRL_CUSTOM_2   = 0x8000, /**< Custom free to use flag*/\n}", "sline": 34, "docstring": "/** Type to store button control bits (disabled, hidden etc.)"}, "lv_btnmatrix_ctrl_t": {"type": "Variable", "def": "typedef uint16_t lv_btnmatrix_ctrl_t", "sline": 49}, "bool": {"type": "Variable", "def": "", "sline": 51}, "lv_btnmatrix_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 56, "in_struct": "lv_btnmatrix_t"}, "lv_btnmatrix_t.map_p": {"type": "Variable", "def": "const char ** map_p", "sline": 57, "in_struct": "lv_btnmatrix_t"}, "lv_btnmatrix_t.button_areas": {"type": "Variable", "def": "lv_area_t * button_areas", "sline": 58, "in_struct": "lv_btnmatrix_t"}, "lv_btnmatrix_t.ctrl_bits": {"type": "Variable", "def": "lv_btnmatrix_ctrl_t * ctrl_bits", "sline": 59, "in_struct": "lv_btnmatrix_t"}, "lv_btnmatrix_t.btn_cnt": {"type": "Variable", "def": "uint16_t btn_cnt", "sline": 60, "in_struct": "lv_btnmatrix_t"}, "lv_btnmatrix_t.row_cnt": {"type": "Variable", "def": "uint16_t row_cnt", "sline": 61, "in_struct": "lv_btnmatrix_t"}, "lv_btnmatrix_t.btn_id_sel": {"type": "Variable", "def": "uint16_t btn_id_sel", "sline": 62, "in_struct": "lv_btnmatrix_t"}, "lv_btnmatrix_t.one_check": {"type": "Variable", "def": "uint8_t one_check : 1", "sline": 63, "in_struct": "lv_btnmatrix_t"}, "lv_btnmatrix_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    const char ** map_p;                              /*Pointer to the current map*/\n    lv_area_t * button_areas;                         /*Array of areas of buttons*/\n    lv_btnmatrix_ctrl_t * ctrl_bits;                       /*Array of control bytes*/\n    uint16_t btn_cnt;                                 /*Number of button in 'map_p'(Handled by the library)*/\n    uint16_t row_cnt;                                 /*Number of rows in 'map_p'(Handled by the library)*/\n    uint16_t btn_id_sel;    /*Index of the active button (being pressed/released etc) or LV_BTNMATRIX_BTN_NONE*/\n    uint8_t one_check : 1;  /*Single button toggled at once*/\n} lv_btnmatrix_t", "sline": 64, "docstring": "/*Data of button matrix*/"}, "lv_btnmatrix_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_btnmatrix_class", "sline": 66}, "lv_btnmatrix_draw_part_type_t": {"type": "Variable", "def": "typedef enum {\n    LV_BTNMATRIX_DRAW_PART_BTN,    /**< The rectangle and label of buttons*/\n} lv_btnmatrix_draw_part_type_t", "sline": 74}, "lv_btnmatrix_create": {"type": "Function", "def": "lv_obj_t * lv_btnmatrix_create(lv_obj_t * parent)", "sline": 85}, "lv_btnmatrix_set_map": {"type": "Function", "def": "void lv_btnmatrix_set_map(lv_obj_t * obj, const char * map[])", "sline": 98}, "lv_btnmatrix_set_ctrl_map": {"type": "Function", "def": "void lv_btnmatrix_set_ctrl_map(lv_obj_t * obj, const lv_btnmatrix_ctrl_t ctrl_map[])", "sline": 112}, "lv_btnmatrix_set_selected_btn": {"type": "Function", "def": "void lv_btnmatrix_set_selected_btn(lv_obj_t * obj, uint16_t btn_id)", "sline": 119}, "lv_btnmatrix_set_btn_ctrl": {"type": "Function", "def": "void lv_btnmatrix_set_btn_ctrl(lv_obj_t * obj, uint16_t btn_id, lv_btnmatrix_ctrl_t ctrl)", "sline": 127}, "lv_btnmatrix_clear_btn_ctrl": {"type": "Function", "def": "void lv_btnmatrix_clear_btn_ctrl(lv_obj_t * obj, uint16_t btn_id, lv_btnmatrix_ctrl_t ctrl)", "sline": 135}, "lv_btnmatrix_set_btn_ctrl_all": {"type": "Function", "def": "void lv_btnmatrix_set_btn_ctrl_all(lv_obj_t * obj, lv_btnmatrix_ctrl_t ctrl)", "sline": 142}, "lv_btnmatrix_clear_btn_ctrl_all": {"type": "Function", "def": "void lv_btnmatrix_clear_btn_ctrl_all(lv_obj_t * obj, lv_btnmatrix_ctrl_t ctrl)", "sline": 150}, "lv_btnmatrix_set_btn_width": {"type": "Function", "def": "void lv_btnmatrix_set_btn_width(lv_obj_t * obj, uint16_t btn_id, uint8_t width)", "sline": 161}, "lv_btnmatrix_set_one_checked": {"type": "Function", "def": "void lv_btnmatrix_set_one_checked(lv_obj_t * obj, bool en)", "sline": 170}, "lv_btnmatrix_get_map": {"type": "Function", "def": "const char ** lv_btnmatrix_get_map(const lv_obj_t * obj)", "sline": 181}, "lv_btnmatrix_get_selected_btn": {"type": "Function", "def": "uint16_t lv_btnmatrix_get_selected_btn(const lv_obj_t * obj)", "sline": 189}, "lv_btnmatrix_get_btn_text": {"type": "Function", "def": "const char * lv_btnmatrix_get_btn_text(const lv_obj_t * obj, uint16_t btn_id)", "sline": 197}, "lv_btnmatrix_has_btn_ctrl": {"type": "Function", "def": "bool lv_btnmatrix_has_btn_ctrl(lv_obj_t * obj, uint16_t btn_id, lv_btnmatrix_ctrl_t ctrl)", "sline": 206}, "lv_btnmatrix_get_one_checked": {"type": "Function", "def": "bool lv_btnmatrix_get_one_checked(const lv_obj_t * obj)", "sline": 213}, "carbit_updater/lvgl/src/widgets/lv_btnmatrix.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_btnmatrix.h"}}, "carbit_updater/lvgl/src/core/lv_event.c": {"lv_obj": {"type": "Variable", "def": "#include lv_obj.h", "sline": 9, "include": ["carbit_updater/lvgl/src/core/lv_obj.h", null]}, "lv_indev": {"type": "Variable", "def": "#include lv_indev.h", "sline": 10, "include": ["carbit_updater/lvgl/src/core/lv_indev.h", null]}, "_lv_event_dsc_t.cb": {"type": "Variable", "def": "lv_event_cb_t cb", "sline": 21, "in_struct": "_lv_event_dsc_t"}, "_lv_event_dsc_t.user_data": {"type": "Variable", "def": "void * user_data", "sline": 22, "in_struct": "_lv_event_dsc_t"}, "_lv_event_dsc_t.filter": {"type": "Variable", "def": "lv_event_code_t filter : 8", "sline": 23, "in_struct": "_lv_event_dsc_t"}, "_lv_event_dsc_t": {"type": "Struct", "def": "struct _lv_event_dsc_t {\n    lv_event_cb_t cb;\n    void * user_data;\n    lv_event_code_t filter : 8;\n}", "sline": 20, "docstring": "/**********************", "body": "lv_event_cb_t cb\nvoid * user_data\nlv_event_code_t filter : 8\n"}, "lv_event_dsc_t": {"type": "Variable", "def": "typedef struct _lv_event_dsc_t {\n    lv_event_cb_t cb;\n    void * user_data;\n    lv_event_code_t filter : 8;\n} lv_event_dsc_t", "sline": 24, "docstring": "/**********************"}, "lv_obj_get_event_dsc": {"type": "Function", "def": "static lv_event_dsc_t * lv_obj_get_event_dsc(const lv_obj_t * obj, uint32_t id)", "sline": 393, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    if(!obj->spec_attr) return NULL;\n    if(id >= obj->spec_attr->event_dsc_cnt) return NULL;\n\n    return &obj->spec_attr->event_dsc[id];\n}"}, "event_send_core": {"type": "Function", "def": "static lv_res_t event_send_core(lv_event_t * e)", "sline": 403, "body": "{\n    EVENT_TRACE(\"Sending event %d to %p with %p param\", e->code, (void *)e->current_target, e->param);\n\n    /*Call the input device's feedback callback if set*/\n    lv_indev_t * indev_act = lv_indev_get_act();\n    if(indev_act) {\n        if(indev_act->driver->feedback_cb) indev_act->driver->feedback_cb(indev_act->driver, e->code);\n    }\n\n    lv_event_dsc_t * event_dsc = lv_obj_get_event_dsc(e->current_target, 0);\n    lv_res_t res = LV_RES_OK;\n    res = lv_obj_event_base(NULL, e);\n\n    uint32_t i = 0;\n    while(event_dsc && res == LV_RES_OK) {\n        if(event_dsc->cb && (event_dsc->filter == LV_EVENT_ALL || event_dsc->filter == e->code)) {\n            e->user_data = event_dsc->user_data;\n            event_dsc->cb(e);\n\n            /*Stop if the object is deleted*/\n            if(e->deleted) return LV_RES_INV;\n        }\n\n        i++;\n        event_dsc = lv_obj_get_event_dsc(e->current_target, i);\n    }\n\n    if(res == LV_RES_OK && e->current_target->parent && event_is_bubbled(e))\n    {\n            e->current_target = e->current_target->parent;\n            res = event_send_core(e);\n            if(res != LV_RES_OK) return LV_RES_INV;\n\n    }\n\n    return res;\n}"}, "event_is_bubbled": {"type": "Function", "def": "static bool event_is_bubbled(lv_event_t * e)", "sline": 442, "body": "{\n    /*Event codes that always bubble*/\n    switch(e->code) {\n        case LV_EVENT_CHILD_CREATED:\n        case LV_EVENT_CHILD_DELETED:\n            return true;\n        default:\n            break;\n    }\n\n    /*Check other codes only if bubbling is enabled*/\n    if(lv_obj_has_flag(e->current_target, LV_OBJ_FLAG_EVENT_BUBBLE) == false) return false;\n\n    switch(e->code) {\n        case LV_EVENT_HIT_TEST:\n        case LV_EVENT_COVER_CHECK:\n        case LV_EVENT_REFR_EXT_DRAW_SIZE:\n        case LV_EVENT_DRAW_MAIN_BEGIN:\n        case LV_EVENT_DRAW_MAIN:\n        case LV_EVENT_DRAW_MAIN_END:\n        case LV_EVENT_DRAW_POST_BEGIN:\n        case LV_EVENT_DRAW_POST:\n        case LV_EVENT_DRAW_POST_END:\n        case LV_EVENT_DRAW_PART_BEGIN:\n        case LV_EVENT_DRAW_PART_END:\n        case LV_EVENT_REFRESH:\n        case LV_EVENT_DELETE:\n        case LV_EVENT_CHILD_CREATED:\n        case LV_EVENT_CHILD_DELETED:\n        case LV_EVENT_CHILD_CHANGED:\n        case LV_EVENT_SIZE_CHANGED:\n        case LV_EVENT_STYLE_CHANGED:\n        case LV_EVENT_GET_SELF_SIZE:\n            return false;\n        default:\n            return true;\n    }\n}"}, "event_head": {"type": "Variable", "def": "static lv_event_t * event_head", "sline": 37}, "lv_event_send": {"type": "Function", "def": "lv_res_t lv_event_send(lv_obj_t * obj, lv_event_code_t event_code, void * param)", "sline": 52, "body": "{\n    if(obj == NULL) return LV_RES_OK;\n\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_event_t e;\n    e.target = obj;\n    e.current_target = obj;\n    e.code = event_code;\n    e.user_data = NULL;\n    e.param = param;\n    e.deleted = 0;\n\n\n    /*Build a simple linked list from the objects used in the events\n     *It's important to know if an this object was deleted by a nested event\n     *called from this `event_cb`.*/\n    e.prev = event_head;\n    event_head = &e;\n\n    /*Send the event*/\n    lv_res_t res = event_send_core(&e);\n\n    /*Remove this element from the list*/\n    event_head = e.prev;\n\n    return res;\n}"}, "lv_obj_event_base": {"type": "Function", "def": "lv_res_t lv_obj_event_base(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 83, "body": "{\n    const lv_obj_class_t * base;\n    if(class_p == NULL) base = e->current_target->class_p;\n    else base = class_p->base_class;\n\n    /*Find a base in which Call the ancestor's event handler_cb is set*/\n    while(base && base->event_cb == NULL) base = base->base_class;\n\n    if(base == NULL) return LV_RES_OK;\n    if(base->event_cb == NULL) return LV_RES_OK;\n\n    /*Call the actual event callback*/\n    e->user_data = NULL;\n    base->event_cb(base, e);\n\n    lv_res_t res = LV_RES_OK;\n    /*Stop if the object is deleted*/\n    if(e->deleted) res = LV_RES_INV;\n\n    return res;\n}"}, "lv_event_get_target": {"type": "Function", "def": "lv_obj_t * lv_event_get_target(lv_event_t * e)", "sline": 107, "body": "{\n    return e->target;\n}"}, "lv_event_get_current_target": {"type": "Function", "def": "lv_obj_t * lv_event_get_current_target(lv_event_t * e)", "sline": 112, "body": "{\n    return e->current_target;\n}"}, "lv_event_get_code": {"type": "Function", "def": "lv_event_code_t lv_event_get_code(lv_event_t * e)", "sline": 117, "body": "{\n    return e->code;\n}"}, "lv_event_get_param": {"type": "Function", "def": "void * lv_event_get_param(lv_event_t * e)", "sline": 122, "body": "{\n    return e->param;\n}"}, "lv_event_get_user_data": {"type": "Function", "def": "void * lv_event_get_user_data(lv_event_t * e)", "sline": 127, "body": "{\n    return e->user_data;\n}"}, "lv_event_register_id": {"type": "Function", "def": "uint32_t lv_event_register_id(void)", "sline": 133, "body": "{\n    static uint32_t last_id = _LV_EVENT_LAST;\n    last_id ++;\n    return last_id;\n}"}, "_lv_event_mark_deleted": {"type": "Function", "def": "void _lv_event_mark_deleted(lv_obj_t * obj)", "sline": 140, "body": "{\n    lv_event_t * e = event_head;\n\n    while(e) {\n        if(e->current_target == obj || e->target == obj) e->deleted = 1;\n        e = e->prev;\n    }\n}"}, "lv_obj_add_event_cb": {"type": "Function", "def": "struct _lv_event_dsc_t * lv_obj_add_event_cb(lv_obj_t * obj, lv_event_cb_t event_cb, lv_event_code_t filter,\n                                             void * user_data)", "sline": 151, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_obj_allocate_spec_attr(obj);\n\n    obj->spec_attr->event_dsc_cnt++;\n    obj->spec_attr->event_dsc = lv_mem_realloc(obj->spec_attr->event_dsc,\n                                               obj->spec_attr->event_dsc_cnt * sizeof(lv_event_dsc_t));\n    LV_ASSERT_MALLOC(obj->spec_attr->event_dsc);\n\n    obj->spec_attr->event_dsc[obj->spec_attr->event_dsc_cnt - 1].cb = event_cb;\n    obj->spec_attr->event_dsc[obj->spec_attr->event_dsc_cnt - 1].filter = filter;\n    obj->spec_attr->event_dsc[obj->spec_attr->event_dsc_cnt - 1].user_data = user_data;\n\n    return &obj->spec_attr->event_dsc[obj->spec_attr->event_dsc_cnt - 1];\n}"}, "lv_obj_remove_event_cb": {"type": "Function", "def": "bool lv_obj_remove_event_cb(lv_obj_t * obj, lv_event_cb_t event_cb)", "sline": 169, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    if(obj->spec_attr == NULL) return false;\n\n    int32_t i = 0;\n    for(i = 0; i < obj->spec_attr->event_dsc_cnt; i++) {\n        if(event_cb == NULL || obj->spec_attr->event_dsc[i].cb == event_cb) {\n            /*Shift the remaining event handlers forward*/\n            for(; i < (obj->spec_attr->event_dsc_cnt - 1); i++) {\n                obj->spec_attr->event_dsc[i] = obj->spec_attr->event_dsc[i + 1];\n            }\n            obj->spec_attr->event_dsc_cnt--;\n            obj->spec_attr->event_dsc = lv_mem_realloc(obj->spec_attr->event_dsc,\n                                                       obj->spec_attr->event_dsc_cnt * sizeof(lv_event_dsc_t));\n            LV_ASSERT_MALLOC(obj->spec_attr->event_dsc);\n            return true;\n        }\n    }\n\n    /*No event handler found*/\n    return false;\n}"}, "lv_obj_remove_event_cb_with_user_data": {"type": "Function", "def": "bool lv_obj_remove_event_cb_with_user_data(lv_obj_t * obj, lv_event_cb_t event_cb, const void * user_data)", "sline": 193, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    if(obj->spec_attr == NULL) return false;\n\n    int32_t i = 0;\n    for(i = 0; i < obj->spec_attr->event_dsc_cnt; i++) {\n        if((event_cb == NULL || obj->spec_attr->event_dsc[i].cb) &&\n           obj->spec_attr->event_dsc[i].user_data == user_data) {\n            /*Shift the remaining event handlers forward*/\n            for(; i < (obj->spec_attr->event_dsc_cnt - 1); i++) {\n                obj->spec_attr->event_dsc[i] = obj->spec_attr->event_dsc[i + 1];\n            }\n            obj->spec_attr->event_dsc_cnt--;\n            obj->spec_attr->event_dsc = lv_mem_realloc(obj->spec_attr->event_dsc,\n                                                       obj->spec_attr->event_dsc_cnt * sizeof(lv_event_dsc_t));\n            LV_ASSERT_MALLOC(obj->spec_attr->event_dsc);\n            return true;\n        }\n    }\n\n    /*No event handler found*/\n    return false;\n}"}, "lv_obj_remove_event_dsc": {"type": "Function", "def": "bool lv_obj_remove_event_dsc(lv_obj_t * obj, struct _lv_event_dsc_t * event_dsc)", "sline": 219, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    if(obj->spec_attr == NULL) return false;\n\n    int32_t i = 0;\n    for(i = 0; i < obj->spec_attr->event_dsc_cnt; i++) {\n        if(&obj->spec_attr->event_dsc[i] == event_dsc) {\n            /*Shift the remaining event handlers forward*/\n            for(; i < (obj->spec_attr->event_dsc_cnt - 1); i++) {\n                obj->spec_attr->event_dsc[i] = obj->spec_attr->event_dsc[i + 1];\n            }\n            obj->spec_attr->event_dsc_cnt--;\n            obj->spec_attr->event_dsc = lv_mem_realloc(obj->spec_attr->event_dsc,\n                                                       obj->spec_attr->event_dsc_cnt * sizeof(lv_event_dsc_t));\n            LV_ASSERT_MALLOC(obj->spec_attr->event_dsc);\n            return true;\n        }\n    }\n\n    /*No event handler found*/\n    return false;\n}"}, "lv_event_get_indev": {"type": "Function", "def": "lv_indev_t * lv_event_get_indev(lv_event_t * e)", "sline": 243, "body": "{\n\n    if(e->code == LV_EVENT_PRESSED ||\n       e->code == LV_EVENT_PRESSING ||\n       e->code == LV_EVENT_PRESS_LOST ||\n       e->code == LV_EVENT_SHORT_CLICKED ||\n       e->code == LV_EVENT_LONG_PRESSED ||\n       e->code == LV_EVENT_LONG_PRESSED_REPEAT ||\n       e->code == LV_EVENT_CLICKED ||\n       e->code == LV_EVENT_RELEASED ||\n       e->code == LV_EVENT_SCROLL_BEGIN ||\n       e->code == LV_EVENT_SCROLL_END ||\n       e->code == LV_EVENT_SCROLL ||\n       e->code == LV_EVENT_GESTURE ||\n       e->code == LV_EVENT_KEY ||\n       e->code == LV_EVENT_FOCUSED ||\n       e->code == LV_EVENT_DEFOCUSED ||\n       e->code == LV_EVENT_LEAVE) {\n        return lv_event_get_param(e);\n    }\n    else {\n        LV_LOG_WARN(\"Not interpreted with this event code\");\n        return NULL;\n    }\n}"}, "lv_event_get_draw_part_dsc": {"type": "Function", "def": "lv_obj_draw_part_dsc_t * lv_event_get_draw_part_dsc(lv_event_t * e)", "sline": 270, "body": "{\n    if(e->code == LV_EVENT_DRAW_PART_BEGIN ||\n       e->code == LV_EVENT_DRAW_PART_END) {\n        return lv_event_get_param(e);\n    }\n    else {\n        LV_LOG_WARN(\"Not interpreted with this event code\");\n        return NULL;\n    }\n}"}, "lv_event_get_clip_area": {"type": "Function", "def": "const lv_area_t * lv_event_get_clip_area(lv_event_t * e)", "sline": 282, "body": "{\n    if(e->code == LV_EVENT_DRAW_MAIN ||\n       e->code == LV_EVENT_DRAW_MAIN_BEGIN ||\n       e->code == LV_EVENT_DRAW_MAIN_END ||\n       e->code == LV_EVENT_DRAW_POST ||\n       e->code == LV_EVENT_DRAW_POST_BEGIN ||\n       e->code == LV_EVENT_DRAW_POST_END) {\n        return lv_event_get_param(e);\n    }\n    else {\n        LV_LOG_WARN(\"Not interpreted with this event code\");\n        return NULL;\n    }\n}"}, "lv_event_get_old_size": {"type": "Function", "def": "const lv_area_t * lv_event_get_old_size(lv_event_t * e)", "sline": 298, "body": "{\n    if(e->code == LV_EVENT_SIZE_CHANGED) {\n        return lv_event_get_param(e);\n    }\n    else {\n        LV_LOG_WARN(\"Not interpreted with this event code\");\n        return NULL;\n    }\n}"}, "lv_event_get_key": {"type": "Function", "def": "uint32_t lv_event_get_key(lv_event_t * e)", "sline": 309, "body": "{\n    if(e->code == LV_EVENT_KEY) {\n        uint32_t * k = lv_event_get_param(e);\n        if(k) return *k;\n        else return 0;\n    }\n    else {\n        LV_LOG_WARN(\"Not interpreted with this event code\");\n        return 0;\n    }\n}"}, "lv_event_get_scroll_anim": {"type": "Function", "def": "lv_anim_t * lv_event_get_scroll_anim(lv_event_t * e)", "sline": 322, "body": "{\n    if(e->code == LV_EVENT_SCROLL_BEGIN) {\n        return lv_event_get_param(e);\n    }\n    else {\n        LV_LOG_WARN(\"Not interpreted with this event code\");\n        return 0;\n    }\n}"}, "lv_event_set_ext_draw_size": {"type": "Function", "def": "void lv_event_set_ext_draw_size(lv_event_t * e, lv_coord_t size)", "sline": 333, "body": "{\n    if(e->code == LV_EVENT_REFR_EXT_DRAW_SIZE) {\n        lv_coord_t * cur_size = lv_event_get_param(e);\n        *cur_size = LV_MAX(*cur_size, size);\n    }\n    else {\n        LV_LOG_WARN(\"Not interpreted with this event code\");\n    }\n}"}, "lv_event_get_self_size_info": {"type": "Function", "def": "lv_point_t * lv_event_get_self_size_info(lv_event_t * e)", "sline": 344, "body": "{\n    if(e->code == LV_EVENT_GET_SELF_SIZE) {\n        return lv_event_get_param(e);\n    }\n    else {\n        LV_LOG_WARN(\"Not interpreted with this event code\");\n        return 0;\n    }\n}"}, "lv_event_get_hit_test_info": {"type": "Function", "def": "lv_hit_test_info_t * lv_event_get_hit_test_info(lv_event_t * e)", "sline": 355, "body": "{\n    if(e->code == LV_EVENT_HIT_TEST) {\n        return lv_event_get_param(e);\n    }\n    else {\n        LV_LOG_WARN(\"Not interpreted with this event code\");\n        return 0;\n    }\n}"}, "lv_event_get_cover_area": {"type": "Function", "def": "const lv_area_t * lv_event_get_cover_area(lv_event_t * e)", "sline": 366, "body": "{\n    if(e->code == LV_EVENT_COVER_CHECK) {\n        lv_cover_check_info_t * p = lv_event_get_param(e);\n        return p->area;\n    }\n    else {\n        LV_LOG_WARN(\"Not interpreted with this event code\");\n        return NULL;\n    }\n}"}, "lv_event_set_cover_res": {"type": "Function", "def": "void lv_event_set_cover_res(lv_event_t * e, lv_cover_res_t res)", "sline": 378, "body": "{\n    if(e->code == LV_EVENT_COVER_CHECK) {\n        lv_cover_check_info_t * p = lv_event_get_param(e);\n        if(res > p->res) p->res = res;  /*Save only \"stronger\" results*/\n    }\n    else {\n        LV_LOG_WARN(\"Not interpreted with this event code\");\n    }\n}"}, "carbit_updater/lvgl/src/core/lv_event.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_event.c"}}, "carbit_updater/lvgl/src/core/lv_obj_scroll.h": {"lv_area": {"type": "Variable", "def": "#include ../misc/lv_area.h", "sline": 16}, "lv_anim": {"type": "Variable", "def": "#include ../misc/lv_anim.h", "sline": 17}, "_lv_obj_t": {"type": "Struct", "def": "struct _lv_obj_t", "sline": 28, "docstring": "/*Can't include lv_obj.h because it includes this header file*/"}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_scroll.h:31:1)": {"type": "Enum", "def": "enum {\n    LV_SCROLLBAR_MODE_OFF,      /**< Never show scrollbars*/\n    LV_SCROLLBAR_MODE_ON,       /**< Always show scrollbars*/\n    LV_SCROLLBAR_MODE_ACTIVE,   /**< Show scroll bars when object is being scrolled*/\n    LV_SCROLLBAR_MODE_AUTO,     /**< Show scroll bars when the content is large enough to be scrolled*/\n}", "sline": 31, "docstring": "/** Scrollbar modes: shows when should the scrollbars be visible*/"}, "lv_scrollbar_mode_t": {"type": "Variable", "def": "typedef uint8_t lv_scrollbar_mode_t", "sline": 37}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_scroll.h:41:1)": {"type": "Enum", "def": "enum {\n    LV_SCROLL_SNAP_NONE,    /**< Do not align, leave where it is*/\n    LV_SCROLL_SNAP_START,   /**< Align to the left/top*/\n    LV_SCROLL_SNAP_END,     /**< Align to the right/bottom*/\n    LV_SCROLL_SNAP_CENTER   /**< Align to the center*/\n}", "sline": 41, "docstring": "/** Scroll span align options. Tells where to align the snappable children when scroll stops.*/"}, "lv_scroll_snap_t": {"type": "Variable", "def": "typedef uint8_t lv_scroll_snap_t", "sline": 47}, "lv_obj_set_scrollbar_mode": {"type": "Function", "def": "void lv_obj_set_scrollbar_mode(struct _lv_obj_t * obj, lv_scrollbar_mode_t mode)", "sline": 62}, "lv_obj_set_scroll_dir": {"type": "Function", "def": "void lv_obj_set_scroll_dir(struct _lv_obj_t * obj, lv_dir_t dir)", "sline": 69}, "lv_obj_set_scroll_snap_x": {"type": "Function", "def": "void lv_obj_set_scroll_snap_x(struct _lv_obj_t * obj, lv_scroll_snap_t align)", "sline": 76}, "lv_obj_set_scroll_snap_y": {"type": "Function", "def": "void lv_obj_set_scroll_snap_y(struct _lv_obj_t * obj, lv_scroll_snap_t align)", "sline": 83}, "lv_obj_get_scrollbar_mode": {"type": "Function", "def": "lv_scrollbar_mode_t lv_obj_get_scrollbar_mode(const struct _lv_obj_t * obj)", "sline": 94, "rels": [["lv_scrollbar_mode_t", null, "Typeof"]]}, "lv_obj_get_scroll_dir": {"type": "Function", "def": "lv_dir_t lv_obj_get_scroll_dir(const struct _lv_obj_t * obj)", "sline": 101}, "lv_obj_get_scroll_snap_x": {"type": "Function", "def": "lv_scroll_snap_t lv_obj_get_scroll_snap_x(const struct _lv_obj_t * obj)", "sline": 108, "rels": [["lv_scroll_snap_t", null, "Typeof"]]}, "lv_obj_get_scroll_snap_y": {"type": "Function", "def": "lv_scroll_snap_t lv_obj_get_scroll_snap_y(const struct _lv_obj_t * obj)", "sline": 115, "rels": [["lv_scroll_snap_t", null, "Typeof"]]}, "lv_obj_get_scroll_x": {"type": "Function", "def": "lv_coord_t lv_obj_get_scroll_x(const struct _lv_obj_t * obj)", "sline": 125}, "lv_obj_get_scroll_y": {"type": "Function", "def": "lv_coord_t lv_obj_get_scroll_y(const struct _lv_obj_t * obj)", "sline": 135}, "lv_obj_get_scroll_top": {"type": "Function", "def": "lv_coord_t lv_obj_get_scroll_top(struct _lv_obj_t * obj)", "sline": 144}, "lv_obj_get_scroll_bottom": {"type": "Function", "def": "lv_coord_t lv_obj_get_scroll_bottom(struct _lv_obj_t * obj)", "sline": 153}, "lv_obj_get_scroll_left": {"type": "Function", "def": "lv_coord_t lv_obj_get_scroll_left(struct _lv_obj_t * obj)", "sline": 162}, "lv_obj_get_scroll_right": {"type": "Function", "def": "lv_coord_t lv_obj_get_scroll_right(struct _lv_obj_t * obj)", "sline": 171}, "lv_obj_get_scroll_end": {"type": "Function", "def": "void lv_obj_get_scroll_end(struct _lv_obj_t  * obj, lv_point_t * end)", "sline": 179}, "lv_obj_scroll_by": {"type": "Function", "def": "void lv_obj_scroll_by(struct _lv_obj_t * obj, lv_coord_t x, lv_coord_t y, lv_anim_enable_t anim_en)", "sline": 195}, "lv_obj_scroll_to": {"type": "Function", "def": "void lv_obj_scroll_to(struct _lv_obj_t * obj, lv_coord_t x, lv_coord_t y, lv_anim_enable_t anim_en)", "sline": 205}, "lv_obj_scroll_to_x": {"type": "Function", "def": "void lv_obj_scroll_to_x(struct _lv_obj_t * obj, lv_coord_t x, lv_anim_enable_t anim_en)", "sline": 214}, "lv_obj_scroll_to_y": {"type": "Function", "def": "void lv_obj_scroll_to_y(struct _lv_obj_t * obj, lv_coord_t y, lv_anim_enable_t anim_en)", "sline": 223}, "lv_obj_scroll_to_view": {"type": "Function", "def": "void lv_obj_scroll_to_view(struct _lv_obj_t * obj, lv_anim_enable_t anim_en)", "sline": 230}, "lv_obj_scroll_to_view_recursive": {"type": "Function", "def": "void lv_obj_scroll_to_view_recursive(struct _lv_obj_t * obj, lv_anim_enable_t anim_en)", "sline": 239}, "lv_obj_is_scrolling": {"type": "Function", "def": "bool lv_obj_is_scrolling(const struct _lv_obj_t * obj)", "sline": 246}, "lv_obj_update_snap": {"type": "Function", "def": "void lv_obj_update_snap(struct _lv_obj_t * obj, lv_anim_enable_t anim_en)", "sline": 253}, "lv_obj_get_scrollbar_area": {"type": "Function", "def": "void lv_obj_get_scrollbar_area(struct _lv_obj_t * obj, lv_area_t * hor, lv_area_t * ver)", "sline": 261}, "lv_obj_scrollbar_invalidate": {"type": "Function", "def": "void lv_obj_scrollbar_invalidate(struct _lv_obj_t * obj)", "sline": 267}, "lv_obj_readjust_scroll": {"type": "Function", "def": "void lv_obj_readjust_scroll(struct _lv_obj_t * obj, lv_anim_enable_t anim_en)", "sline": 274}, "carbit_updater/lvgl/src/core/lv_obj_scroll.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_scroll.h"}}, "carbit_updater/lvgl/src/draw/lv_draw_triangle.h": {"lv_draw_rect": {"type": "Variable", "def": "#include lv_draw_rect.h", "sline": 16, "include": ["carbit_updater/lvgl/src/draw/lv_draw_rect.h", null]}, "lv_draw_triangle": {"type": "Function", "def": "void lv_draw_triangle(const lv_point_t points[], const lv_area_t * clip, const lv_draw_rect_dsc_t * draw_dsc)", "sline": 36}, "lv_draw_polygon": {"type": "Function", "def": "void lv_draw_polygon(const lv_point_t points[], uint16_t point_cnt, const lv_area_t * mask,\n                     const lv_draw_rect_dsc_t * draw_dsc)", "sline": 45}, "carbit_updater/lvgl/src/draw/lv_draw_triangle.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_draw_triangle.h"}}, "carbit_updater/lvgl/src/widgets/lv_bar.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "lv_obj": {"type": "Variable", "def": "#include ../core/lv_obj.h", "sline": 20}, "lv_anim": {"type": "Variable", "def": "#include ../misc/lv_anim.h", "sline": 21}, "lv_btn": {"type": "Variable", "def": "#include lv_btn.h", "sline": 22, "include": ["carbit_updater/lvgl/src/widgets/lv_btn.h", null]}, "lv_label": {"type": "Variable", "def": "#include lv_label.h", "sline": 23, "include": ["carbit_updater/lvgl/src/widgets/lv_label.h", null]}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_bar.h:33:1)": {"type": "Enum", "def": "enum {\n    LV_BAR_MODE_NORMAL,\n    LV_BAR_MODE_SYMMETRICAL,\n    LV_BAR_MODE_RANGE\n}", "sline": 33}, "lv_bar_mode_t": {"type": "Variable", "def": "typedef uint8_t lv_bar_mode_t", "sline": 38}, "_lv_bar_anim_t.bar": {"type": "Variable", "def": "lv_obj_t * bar", "sline": 41, "in_struct": "_lv_bar_anim_t"}, "_lv_bar_anim_t.anim_start": {"type": "Variable", "def": "int32_t anim_start", "sline": 42, "in_struct": "_lv_bar_anim_t"}, "_lv_bar_anim_t.anim_end": {"type": "Variable", "def": "int32_t anim_end", "sline": 43, "in_struct": "_lv_bar_anim_t"}, "_lv_bar_anim_t.anim_state": {"type": "Variable", "def": "int32_t anim_state", "sline": 44, "in_struct": "_lv_bar_anim_t"}, "_lv_bar_anim_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t * bar;\n    int32_t anim_start;\n    int32_t anim_end;\n    int32_t anim_state;\n} _lv_bar_anim_t", "sline": 45}, "lv_bar_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 48, "in_struct": "lv_bar_t"}, "lv_bar_t.cur_value": {"type": "Variable", "def": "int32_t cur_value", "sline": 49, "in_struct": "lv_bar_t"}, "lv_bar_t.min_value": {"type": "Variable", "def": "int32_t min_value", "sline": 50, "in_struct": "lv_bar_t"}, "lv_bar_t.max_value": {"type": "Variable", "def": "int32_t max_value", "sline": 51, "in_struct": "lv_bar_t"}, "lv_bar_t.start_value": {"type": "Variable", "def": "int32_t start_value", "sline": 52, "in_struct": "lv_bar_t"}, "lv_bar_t.indic_area": {"type": "Variable", "def": "lv_area_t indic_area", "sline": 53, "in_struct": "lv_bar_t"}, "lv_bar_t.cur_value_anim": {"type": "Variable", "def": "_lv_bar_anim_t cur_value_anim", "sline": 54, "in_struct": "lv_bar_t", "rels": [["_lv_bar_anim_t", null, "Typeof"]]}, "lv_bar_t.start_value_anim": {"type": "Variable", "def": "_lv_bar_anim_t start_value_anim", "sline": 55, "in_struct": "lv_bar_t", "rels": [["_lv_bar_anim_t", null, "Typeof"]]}, "lv_bar_t.mode": {"type": "Variable", "def": "lv_bar_mode_t mode : 2", "sline": 56, "in_struct": "lv_bar_t", "rels": [["lv_bar_mode_t", null, "Typeof"]]}, "lv_bar_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    int32_t cur_value;          /**< Current value of the bar*/\n    int32_t min_value;          /**< Minimum value of the bar*/\n    int32_t max_value;          /**< Maximum value of the bar*/\n    int32_t start_value;        /**< Start value of the bar*/\n    lv_area_t indic_area;       /**< Save the indicator area. Might be used by derived types*/\n    _lv_bar_anim_t cur_value_anim;\n    _lv_bar_anim_t start_value_anim;\n    lv_bar_mode_t mode : 2;     /**< Type of bar*/\n} lv_bar_t", "sline": 57}, "lv_bar_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_bar_class", "sline": 59}, "lv_bar_draw_part_type_t": {"type": "Variable", "def": "typedef enum {\n    LV_BAR_DRAW_PART_INDICATOR,    /**< The indicator*/\n} lv_bar_draw_part_type_t", "sline": 67}, "lv_bar_create": {"type": "Function", "def": "lv_obj_t * lv_bar_create(lv_obj_t * parent)", "sline": 78}, "lv_bar_set_value": {"type": "Function", "def": "void lv_bar_set_value(lv_obj_t * obj, int32_t value, lv_anim_enable_t anim)", "sline": 90}, "lv_bar_set_start_value": {"type": "Function", "def": "void lv_bar_set_start_value(lv_obj_t * obj, int32_t start_value, lv_anim_enable_t anim)", "sline": 98}, "lv_bar_set_range": {"type": "Function", "def": "void lv_bar_set_range(lv_obj_t * obj, int32_t min, int32_t max)", "sline": 106}, "lv_bar_set_mode": {"type": "Function", "def": "void lv_bar_set_mode(lv_obj_t * obj, lv_bar_mode_t mode)", "sline": 113}, "lv_bar_get_value": {"type": "Function", "def": "int32_t lv_bar_get_value(const lv_obj_t * obj)", "sline": 124}, "lv_bar_get_start_value": {"type": "Function", "def": "int32_t lv_bar_get_start_value(const lv_obj_t * obj)", "sline": 131}, "lv_bar_get_min_value": {"type": "Function", "def": "int32_t lv_bar_get_min_value(const lv_obj_t * obj)", "sline": 138}, "lv_bar_get_max_value": {"type": "Function", "def": "int32_t lv_bar_get_max_value(const lv_obj_t * obj)", "sline": 145}, "lv_bar_get_mode": {"type": "Function", "def": "lv_bar_mode_t lv_bar_get_mode(lv_obj_t * obj)", "sline": 152, "rels": [["lv_bar_mode_t", null, "Typeof"]]}, "carbit_updater/lvgl/src/widgets/lv_bar.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_bar.h"}}, "carbit_updater/lvgl/src/draw/lv_draw_mask.h": {"stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 17}, "lv_area": {"type": "Variable", "def": "#include ../misc/lv_area.h", "sline": 18}, "lv_color": {"type": "Variable", "def": "#include ../misc/lv_color.h", "sline": 19}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 20}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_draw_mask.h:39:1)": {"type": "Enum", "def": "enum {\n    LV_DRAW_MASK_RES_TRANSP,\n    LV_DRAW_MASK_RES_FULL_COVER,\n    LV_DRAW_MASK_RES_CHANGED,\n    LV_DRAW_MASK_RES_UNKNOWN\n}", "sline": 39}, "lv_draw_mask_res_t": {"type": "Variable", "def": "typedef uint8_t lv_draw_mask_res_t", "sline": 46}, "_lv_draw_mask_saved_t.param": {"type": "Variable", "def": "void * param", "sline": 49, "in_struct": "_lv_draw_mask_saved_t"}, "_lv_draw_mask_saved_t.custom_id": {"type": "Variable", "def": "void * custom_id", "sline": 50, "in_struct": "_lv_draw_mask_saved_t"}, "_lv_draw_mask_saved_t": {"type": "Variable", "def": "typedef struct {\n    void * param;\n    void * custom_id;\n} _lv_draw_mask_saved_t", "sline": 51}, "_lv_draw_mask_saved_arr_t": {"type": "Variable", "def": "typedef _lv_draw_mask_saved_t _lv_draw_mask_saved_arr_t[_LV_MASK_MAX_NUM]", "sline": 53}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_draw_mask.h:73:1)": {"type": "Enum", "def": "enum {\n    LV_DRAW_MASK_TYPE_LINE,\n    LV_DRAW_MASK_TYPE_ANGLE,\n    LV_DRAW_MASK_TYPE_RADIUS,\n    LV_DRAW_MASK_TYPE_FADE,\n    LV_DRAW_MASK_TYPE_MAP,\n}", "sline": 73}, "lv_draw_mask_type_t": {"type": "Variable", "def": "typedef uint8_t lv_draw_mask_type_t", "sline": 81}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_draw_mask.h:83:1)": {"type": "Enum", "def": "enum {\n    LV_DRAW_MASK_LINE_SIDE_LEFT = 0,\n    LV_DRAW_MASK_LINE_SIDE_RIGHT,\n    LV_DRAW_MASK_LINE_SIDE_TOP,\n    LV_DRAW_MASK_LINE_SIDE_BOTTOM,\n}", "sline": 83}, "lv_draw_mask_xcb_t": {"type": "Variable", "def": "typedef lv_draw_mask_res_t (*lv_draw_mask_xcb_t)(lv_opa_t * mask_buf, lv_coord_t abs_x, lv_coord_t abs_y,\n                                                 lv_coord_t len,\n                                                 void * p)", "sline": 94}, "lv_draw_mask_line_side_t": {"type": "Variable", "def": "typedef uint8_t lv_draw_mask_line_side_t", "sline": 98}, "_lv_draw_mask_common_dsc_t.cb": {"type": "Variable", "def": "lv_draw_mask_xcb_t cb", "sline": 101, "in_struct": "_lv_draw_mask_common_dsc_t", "rels": [["lv_draw_mask_xcb_t", null, "Typeof"]]}, "_lv_draw_mask_common_dsc_t.type": {"type": "Variable", "def": "lv_draw_mask_type_t type", "sline": 102, "in_struct": "_lv_draw_mask_common_dsc_t", "rels": [["lv_draw_mask_type_t", null, "Typeof"]]}, "_lv_draw_mask_common_dsc_t": {"type": "Variable", "def": "typedef struct {\n    lv_draw_mask_xcb_t cb;\n    lv_draw_mask_type_t type;\n} _lv_draw_mask_common_dsc_t", "sline": 103}, "lv_draw_mask_line_param_t.dsc": {"type": "Variable", "def": "_lv_draw_mask_common_dsc_t dsc", "sline": 107, "in_struct": "lv_draw_mask_line_param_t", "rels": [["_lv_draw_mask_common_dsc_t", null, "Typeof"]]}, "lv_draw_mask_line_param_t.cfg": {"type": "Variable", "def": "struct {\n        /*First point*/\n        lv_point_t p1;\n\n        /*Second point*/\n        lv_point_t p2;\n\n        /*Which side to keep?*/\n        lv_draw_mask_line_side_t side : 2;\n    } cfg", "sline": 118, "in_struct": "lv_draw_mask_line_param_t"}, "lv_draw_mask_line_param_t.origo": {"type": "Variable", "def": "lv_point_t origo", "sline": 121, "in_struct": "lv_draw_mask_line_param_t"}, "lv_draw_mask_line_param_t.xy_steep": {"type": "Variable", "def": "int32_t xy_steep", "sline": 124, "in_struct": "lv_draw_mask_line_param_t"}, "lv_draw_mask_line_param_t.yx_steep": {"type": "Variable", "def": "int32_t yx_steep", "sline": 127, "in_struct": "lv_draw_mask_line_param_t"}, "lv_draw_mask_line_param_t.steep": {"type": "Variable", "def": "int32_t steep", "sline": 130, "in_struct": "lv_draw_mask_line_param_t"}, "lv_draw_mask_line_param_t.spx": {"type": "Variable", "def": "int32_t spx", "sline": 133, "in_struct": "lv_draw_mask_line_param_t"}, "lv_draw_mask_line_param_t.flat": {"type": "Variable", "def": "uint8_t flat : 1", "sline": 136, "in_struct": "lv_draw_mask_line_param_t"}, "lv_draw_mask_line_param_t.inv": {"type": "Variable", "def": "uint8_t inv: 1", "sline": 140, "in_struct": "lv_draw_mask_line_param_t"}, "lv_draw_mask_line_param_t": {"type": "Variable", "def": "typedef struct {\n    /*The first element must be the common descriptor*/\n    _lv_draw_mask_common_dsc_t dsc;\n\n    struct {\n        /*First point*/\n        lv_point_t p1;\n\n        /*Second point*/\n        lv_point_t p2;\n\n        /*Which side to keep?*/\n        lv_draw_mask_line_side_t side : 2;\n    } cfg;\n\n    /*A point of the line*/\n    lv_point_t origo;\n\n    /*X / (1024*Y) steepness (X is 0..1023 range). What is the change of X in 1024 Y?*/\n    int32_t xy_steep;\n\n    /*Y / (1024*X) steepness (Y is 0..1023 range). What is the change of Y in 1024 X?*/\n    int32_t yx_steep;\n\n    /*Helper which stores yx_steep for flat lines and xy_steep for steep (non flat) lines*/\n    int32_t steep;\n\n    /*Steepness in 1 px in 0..255 range. Used only by flat lines.*/\n    int32_t spx;\n\n    /*1: It's a flat line? (Near to horizontal)*/\n    uint8_t flat : 1;\n\n    /*Invert the mask. The default is: Keep the left part.\n     *It is used to select left/right/top/bottom*/\n    uint8_t inv: 1;\n} lv_draw_mask_line_param_t", "sline": 141}, "lv_draw_mask_angle_param_t.dsc": {"type": "Variable", "def": "_lv_draw_mask_common_dsc_t dsc", "sline": 145, "in_struct": "lv_draw_mask_angle_param_t", "rels": [["_lv_draw_mask_common_dsc_t", null, "Typeof"]]}, "lv_draw_mask_angle_param_t.cfg": {"type": "Variable", "def": "struct {\n        lv_point_t vertex_p;\n        lv_coord_t start_angle;\n        lv_coord_t end_angle;\n    } cfg", "sline": 151, "in_struct": "lv_draw_mask_angle_param_t"}, "lv_draw_mask_angle_param_t.start_line": {"type": "Variable", "def": "lv_draw_mask_line_param_t start_line", "sline": 153, "in_struct": "lv_draw_mask_angle_param_t", "rels": [["lv_draw_mask_line_param_t", null, "Typeof"]]}, "lv_draw_mask_angle_param_t.end_line": {"type": "Variable", "def": "lv_draw_mask_line_param_t end_line", "sline": 154, "in_struct": "lv_draw_mask_angle_param_t", "rels": [["lv_draw_mask_line_param_t", null, "Typeof"]]}, "lv_draw_mask_angle_param_t.delta_deg": {"type": "Variable", "def": "uint16_t delta_deg", "sline": 155, "in_struct": "lv_draw_mask_angle_param_t"}, "lv_draw_mask_angle_param_t": {"type": "Variable", "def": "typedef struct {\n    /*The first element must be the common descriptor*/\n    _lv_draw_mask_common_dsc_t dsc;\n\n    struct {\n        lv_point_t vertex_p;\n        lv_coord_t start_angle;\n        lv_coord_t end_angle;\n    } cfg;\n\n    lv_draw_mask_line_param_t start_line;\n    lv_draw_mask_line_param_t end_line;\n    uint16_t delta_deg;\n} lv_draw_mask_angle_param_t", "sline": 156}, "_lv_draw_mask_radius_circle_dsc_t.buf": {"type": "Variable", "def": "uint8_t * buf", "sline": 159, "in_struct": "_lv_draw_mask_radius_circle_dsc_t"}, "_lv_draw_mask_radius_circle_dsc_t.cir_opa": {"type": "Variable", "def": "lv_opa_t * cir_opa", "sline": 160, "in_struct": "_lv_draw_mask_radius_circle_dsc_t"}, "_lv_draw_mask_radius_circle_dsc_t.x_start_on_y": {"type": "Variable", "def": "uint16_t * x_start_on_y", "sline": 161, "in_struct": "_lv_draw_mask_radius_circle_dsc_t"}, "_lv_draw_mask_radius_circle_dsc_t.opa_start_on_y": {"type": "Variable", "def": "uint16_t * opa_start_on_y", "sline": 162, "in_struct": "_lv_draw_mask_radius_circle_dsc_t"}, "_lv_draw_mask_radius_circle_dsc_t.life": {"type": "Variable", "def": "int32_t life", "sline": 163, "in_struct": "_lv_draw_mask_radius_circle_dsc_t"}, "_lv_draw_mask_radius_circle_dsc_t.used_cnt": {"type": "Variable", "def": "uint32_t used_cnt", "sline": 164, "in_struct": "_lv_draw_mask_radius_circle_dsc_t"}, "_lv_draw_mask_radius_circle_dsc_t.radius": {"type": "Variable", "def": "lv_coord_t radius", "sline": 165, "in_struct": "_lv_draw_mask_radius_circle_dsc_t"}, "_lv_draw_mask_radius_circle_dsc_t": {"type": "Variable", "def": "typedef struct  {\n    uint8_t * buf;\n    lv_opa_t * cir_opa;         /*Opacity of values on the circumference of an 1/4 circle*/\n    uint16_t * x_start_on_y;        /*The x coordinate of the circle for each y value*/\n    uint16_t * opa_start_on_y;      /*The index of `cir_opa` for each y value*/\n    int32_t life;               /*How many times the entry way used*/\n    uint32_t used_cnt;          /*Like a semaphore to count the referencing masks*/\n    lv_coord_t radius;          /*The radius of the entry*/\n} _lv_draw_mask_radius_circle_dsc_t", "sline": 166}, "_lv_draw_mask_radius_circle_dsc_arr_t": {"type": "Variable", "def": "typedef _lv_draw_mask_radius_circle_dsc_t _lv_draw_mask_radius_circle_dsc_arr_t[LV_CIRCLE_CACHE_SIZE]", "sline": 168}, "lv_draw_mask_radius_param_t.dsc": {"type": "Variable", "def": "_lv_draw_mask_common_dsc_t dsc", "sline": 172, "in_struct": "lv_draw_mask_radius_param_t", "rels": [["_lv_draw_mask_common_dsc_t", null, "Typeof"]]}, "lv_draw_mask_radius_param_t.cfg": {"type": "Variable", "def": "struct {\n        lv_area_t rect;\n        lv_coord_t radius;\n        /*Invert the mask. 0: Keep the pixels inside.*/\n        uint8_t outer: 1;\n    } cfg", "sline": 179, "in_struct": "lv_draw_mask_radius_param_t"}, "lv_draw_mask_radius_param_t.circle": {"type": "Variable", "def": "_lv_draw_mask_radius_circle_dsc_t * circle", "sline": 181, "in_struct": "lv_draw_mask_radius_param_t"}, "lv_draw_mask_radius_param_t": {"type": "Variable", "def": "typedef struct {\n    /*The first element must be the common descriptor*/\n    _lv_draw_mask_common_dsc_t dsc;\n\n    struct {\n        lv_area_t rect;\n        lv_coord_t radius;\n        /*Invert the mask. 0: Keep the pixels inside.*/\n        uint8_t outer: 1;\n    } cfg;\n\n    _lv_draw_mask_radius_circle_dsc_t * circle;\n} lv_draw_mask_radius_param_t", "sline": 182}, "lv_draw_mask_fade_param_t.dsc": {"type": "Variable", "def": "_lv_draw_mask_common_dsc_t dsc", "sline": 187, "in_struct": "lv_draw_mask_fade_param_t", "rels": [["_lv_draw_mask_common_dsc_t", null, "Typeof"]]}, "lv_draw_mask_fade_param_t.cfg": {"type": "Variable", "def": "struct {\n        lv_area_t coords;\n        lv_coord_t y_top;\n        lv_coord_t y_bottom;\n        lv_opa_t opa_top;\n        lv_opa_t opa_bottom;\n    } cfg", "sline": 195, "in_struct": "lv_draw_mask_fade_param_t"}, "lv_draw_mask_fade_param_t": {"type": "Variable", "def": "typedef struct {\n    /*The first element must be the common descriptor*/\n    _lv_draw_mask_common_dsc_t dsc;\n\n    struct {\n        lv_area_t coords;\n        lv_coord_t y_top;\n        lv_coord_t y_bottom;\n        lv_opa_t opa_top;\n        lv_opa_t opa_bottom;\n    } cfg;\n\n} lv_draw_mask_fade_param_t", "sline": 197}, "_lv_draw_mask_map_param_t.dsc": {"type": "Variable", "def": "_lv_draw_mask_common_dsc_t dsc", "sline": 202, "in_struct": "_lv_draw_mask_map_param_t", "rels": [["_lv_draw_mask_common_dsc_t", null, "Typeof"]]}, "_lv_draw_mask_map_param_t.cfg": {"type": "Variable", "def": "struct {\n        lv_area_t coords;\n        const lv_opa_t * map;\n    } cfg", "sline": 207, "in_struct": "_lv_draw_mask_map_param_t"}, "_lv_draw_mask_map_param_t": {"type": "Struct", "def": "struct _lv_draw_mask_map_param_t {\n    /*The first element must be the common descriptor*/\n    _lv_draw_mask_common_dsc_t dsc;\n\n    struct {\n        lv_area_t coords;\n        const lv_opa_t * map;\n    } cfg;\n}", "sline": 200, "body": "_lv_draw_mask_common_dsc_t dsc\nstruct {\n        lv_area_t coords;\n        const lv_opa_t * map;\n    } cfg\n"}, "lv_draw_mask_map_param_t": {"type": "Variable", "def": "typedef struct _lv_draw_mask_map_param_t {\n    /*The first element must be the common descriptor*/\n    _lv_draw_mask_common_dsc_t dsc;\n\n    struct {\n        lv_area_t coords;\n        const lv_opa_t * map;\n    } cfg;\n} lv_draw_mask_map_param_t", "sline": 208}, "lv_draw_mask_add": {"type": "Function", "def": "int16_t lv_draw_mask_add(void * param, void * custom_id)", "sline": 221}, "lv_draw_mask_apply": {"type": "Function", "def": "lv_draw_mask_res_t lv_draw_mask_apply(lv_opa_t * mask_buf, lv_coord_t abs_x, lv_coord_t abs_y,\n                                                            lv_coord_t len)", "sline": 236, "rels": [["lv_draw_mask_res_t", null, "Typeof"]]}, "lv_draw_mask_apply_ids": {"type": "Function", "def": "lv_draw_mask_res_t lv_draw_mask_apply_ids(lv_opa_t * mask_buf, lv_coord_t abs_x, lv_coord_t abs_y,\n                                                                lv_coord_t len, const int16_t *ids, int16_t ids_count)", "sline": 252, "rels": [["lv_draw_mask_res_t", null, "Typeof"]]}, "lv_draw_mask_remove_id": {"type": "Function", "def": "void * lv_draw_mask_remove_id(int16_t id)", "sline": 263}, "lv_draw_mask_remove_custom": {"type": "Function", "def": "void * lv_draw_mask_remove_custom(void * custom_id)", "sline": 271}, "lv_draw_mask_free_param": {"type": "Function", "def": "void lv_draw_mask_free_param(void * p)", "sline": 280}, "_lv_draw_mask_cleanup": {"type": "Function", "def": "void _lv_draw_mask_cleanup(void)", "sline": 286}, "lv_draw_mask_get_cnt": {"type": "Function", "def": "uint8_t lv_draw_mask_get_cnt(void)", "sline": 294}, "lv_draw_mask_is_any": {"type": "Function", "def": "bool lv_draw_mask_is_any(const lv_area_t * a)", "sline": 302}, "lv_draw_mask_line_points_init": {"type": "Function", "def": "void lv_draw_mask_line_points_init(lv_draw_mask_line_param_t * param, lv_coord_t p1x, lv_coord_t p1y, lv_coord_t p2x,\n                                   lv_coord_t p2y, lv_draw_mask_line_side_t side)", "sline": 317}, "lv_draw_mask_line_angle_init": {"type": "Function", "def": "void lv_draw_mask_line_angle_init(lv_draw_mask_line_param_t * param, lv_coord_t p1x, lv_coord_t py, int16_t angle,\n                                  lv_draw_mask_line_side_t side)", "sline": 330}, "lv_draw_mask_angle_init": {"type": "Function", "def": "void lv_draw_mask_angle_init(lv_draw_mask_angle_param_t * param, lv_coord_t vertex_x, lv_coord_t vertex_y,\n                             lv_coord_t start_angle, lv_coord_t end_angle)", "sline": 341}, "lv_draw_mask_radius_init": {"type": "Function", "def": "void lv_draw_mask_radius_init(lv_draw_mask_radius_param_t * param, const lv_area_t * rect, lv_coord_t radius, bool inv)", "sline": 351}, "lv_draw_mask_fade_init": {"type": "Function", "def": "void lv_draw_mask_fade_init(lv_draw_mask_fade_param_t * param, const lv_area_t * coords, lv_opa_t opa_top,\n                            lv_coord_t y_top,\n                            lv_opa_t opa_bottom, lv_coord_t y_bottom)", "sline": 362}, "lv_draw_mask_map_init": {"type": "Function", "def": "void lv_draw_mask_map_init(lv_draw_mask_map_param_t * param, const lv_area_t * coords, const lv_opa_t * map)", "sline": 372}, "carbit_updater/lvgl/src/draw/lv_draw_mask.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_draw_mask.h"}}, "carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar_header_dropdown.h": {"lv_obj": {"type": "Variable", "def": "#include ../../../core/lv_obj.h", "sline": 16}, "lv_calendar_header_dropdown_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_calendar_header_dropdown_class", "sline": 26}, "lv_calendar_header_dropdown_create": {"type": "Function", "def": "lv_obj_t * lv_calendar_header_dropdown_create(lv_obj_t * parent)", "sline": 37}, "carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar_header_dropdown.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar_header_dropdown.h"}}, "carbit_updater/lvgl/src/extra/widgets/spinbox/lv_spinbox.c": {"lv_spinbox": {"type": "Variable", "def": "#include lv_spinbox.h", "sline": 9, "include": ["carbit_updater/lvgl/src/extra/widgets/spinbox/lv_spinbox.h", null]}, "lv_assert": {"type": "Variable", "def": "#include ../../../misc/lv_assert.h", "sline": 12}, "lv_spinbox_constructor": {"type": "Function", "def": "static void lv_spinbox_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 320, "body": "{\n    LV_UNUSED(class_p);\n    LV_LOG_TRACE(\"begin\");\n\n    lv_spinbox_t * spinbox = (lv_spinbox_t *)obj;\n\n    /*Initialize the allocated 'ext'*/\n    spinbox->value              = 0;\n    spinbox->dec_point_pos      = 0;\n    spinbox->digit_count        = 5;\n    spinbox->step               = 1;\n    spinbox->range_max          = 99999;\n    spinbox->range_min          = -99999;\n    spinbox->rollover           = false;\n    spinbox->digit_step_dir     = LV_DIR_RIGHT;\n\n    lv_textarea_set_one_line(obj, true);\n    lv_textarea_set_cursor_click_pos(obj, true);\n    lv_obj_set_width(obj, LV_DPI_DEF);\n\n    lv_spinbox_updatevalue(obj);\n\n    LV_LOG_TRACE(\"Spinbox constructor finished\");\n}"}, "lv_spinbox_event": {"type": "Function", "def": "static void lv_spinbox_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 346, "body": "{\n    LV_UNUSED(class_p);\n\n    /*Call the ancestor's event handler*/\n    lv_res_t res = LV_RES_OK;\n    res = lv_obj_event_base(MY_CLASS, e);\n    if(res != LV_RES_OK) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_spinbox_t * spinbox = (lv_spinbox_t *)obj;\n    if(code == LV_EVENT_RELEASED) {\n        /*If released with an ENCODER then move to the next digit*/\n        lv_indev_t * indev = lv_indev_get_act();\n        if(lv_indev_get_type(indev) == LV_INDEV_TYPE_ENCODER) {\n            if(lv_group_get_editing(lv_obj_get_group(obj))) {\n                if (spinbox->digit_count > 1) {\n                    if (spinbox->digit_step_dir == LV_DIR_RIGHT) {\n                        if(spinbox->step > 1) {\n                           lv_spinbox_step_next(obj);\n                        }\n                        else {\n                            /*Restart from the MSB*/\n                            spinbox->step = lv_pow(10, spinbox->digit_count - 2);\n                            lv_spinbox_step_prev(obj);\n                        }\n                    }\n                    else {\n                        if(spinbox->step < lv_pow(10, spinbox->digit_count - 1)) {\n                            lv_spinbox_step_prev(obj);\n                        }\n                        else {\n                            /*Restart from the LSB*/\n                            spinbox->step = 10;\n                            lv_spinbox_step_next(obj);\n                        }\n                    }\n                }\n            }\n        }\n        /*The cursor has been positioned to a digit.\n         * Set `step` accordingly*/\n        else {\n            const char * txt = lv_textarea_get_text(obj);\n            size_t txt_len = strlen(txt);\n\n            if(txt[spinbox->ta.cursor.pos] == '.') {\n                lv_textarea_cursor_left(obj);\n            }\n            else if(spinbox->ta.cursor.pos == (uint32_t)txt_len) {\n                lv_textarea_set_cursor_pos(obj, txt_len - 1);\n            }\n            else if(spinbox->ta.cursor.pos == 0 && spinbox->range_min < 0) {\n                lv_textarea_set_cursor_pos(obj, 1);\n            }\n\n            size_t len = spinbox->digit_count - 1;\n            uint16_t cp = spinbox->ta.cursor.pos;\n\n            if(spinbox->ta.cursor.pos > spinbox->dec_point_pos && spinbox->dec_point_pos != 0) cp--;\n            uint32_t pos = len - cp;\n\n            if(spinbox->range_min < 0) pos++;\n\n            spinbox->step = 1;\n            uint16_t i;\n            for(i = 0; i < pos; i++) spinbox->step *= 10;\n        }\n    }\n    else if(code == LV_EVENT_KEY) {\n        lv_indev_type_t indev_type = lv_indev_get_type(lv_indev_get_act());\n\n        uint32_t c = *((uint32_t *)lv_event_get_param(e)); /*uint32_t because can be UTF-8*/\n        if(c == LV_KEY_RIGHT) {\n            if(indev_type == LV_INDEV_TYPE_ENCODER)\n                lv_spinbox_increment(obj);\n            else\n                lv_spinbox_step_next(obj);\n        }\n        else if(c == LV_KEY_LEFT) {\n            if(indev_type == LV_INDEV_TYPE_ENCODER)\n                lv_spinbox_decrement(obj);\n            else\n                lv_spinbox_step_prev(obj);\n        }\n        else if(c == LV_KEY_UP) {\n            lv_spinbox_increment(obj);\n        }\n        else if(c == LV_KEY_DOWN) {\n            lv_spinbox_decrement(obj);\n        }\n        else {\n            lv_textarea_add_char(obj, c);\n        }\n    }\n}"}, "lv_spinbox_updatevalue": {"type": "Function", "def": "static void lv_spinbox_updatevalue(lv_obj_t * obj)", "sline": 444, "body": "{\n    lv_spinbox_t * spinbox = (lv_spinbox_t *)obj;\n\n    char buf[LV_SPINBOX_MAX_DIGIT_COUNT + 8];\n    lv_memset_00(buf, sizeof(buf));\n    char * buf_p = buf;\n    uint8_t cur_shift_left = 0;\n\n    if(spinbox->range_min < 0) {  // hide sign if there are only positive values\n        /*Add the sign*/\n        (*buf_p) = spinbox->value >= 0 ? '+' : '-';\n        buf_p++;\n    }\n    else {\n        /*Cursor need shift to left*/\n        cur_shift_left++;\n    }\n\n    int32_t i;\n    char digits[LV_SPINBOX_MAX_DIGIT_COUNT + 4];\n    /*Convert the numbers to string (the sign is already handled so always covert positive number)*/\n    lv_snprintf(digits, sizeof(digits), \"%\" LV_PRId32, LV_ABS(spinbox->value));\n\n    /*Add leading zeros*/\n    int lz_cnt = spinbox->digit_count - (int)strlen(digits);\n    if(lz_cnt > 0) {\n        for(i = (uint16_t)strlen(digits); i >= 0; i--) {\n            digits[i + lz_cnt] = digits[i];\n        }\n        for(i = 0; i < lz_cnt; i++) {\n            digits[i] = '0';\n        }\n    }\n\n    int32_t intDigits;\n    intDigits = (spinbox->dec_point_pos == 0) ? spinbox->digit_count : spinbox->dec_point_pos;\n\n    /*Add the decimal part*/\n    for(i = 0; i < intDigits && digits[i] != '\\0'; i++) {\n        (*buf_p) = digits[i];\n        buf_p++;\n    }\n\n    if(spinbox->dec_point_pos != 0) {\n        /*Insert the decimal point*/\n        (*buf_p) = '.';\n        buf_p++;\n\n        for(/*Leave i*/; i < spinbox->digit_count && digits[i] != '\\0'; i++) {\n            (*buf_p) = digits[i];\n            buf_p++;\n        }\n    }\n\n    /*Refresh the text*/\n    lv_textarea_set_text(obj, (char *)buf);\n\n    /*Set the cursor position*/\n    int32_t step    = spinbox->step;\n    uint8_t cur_pos = (uint8_t)spinbox->digit_count;\n    while(step >= 10) {\n        step /= 10;\n        cur_pos--;\n    }\n\n    if(cur_pos > intDigits) cur_pos++; /*Skip the decimal point*/\n\n    cur_pos -= cur_shift_left;\n\n    lv_textarea_set_cursor_pos(obj, cur_pos);\n}"}, "lv_spinbox_class": {"type": "Variable", "def": "const lv_obj_class_t lv_spinbox_class = {\n    .constructor_cb = lv_spinbox_constructor,\n    .event_cb = lv_spinbox_event,\n    .instance_size = sizeof(lv_spinbox_t),\n    .editable = LV_OBJ_CLASS_EDITABLE_TRUE,\n    .base_class = &lv_textarea_class\n}", "sline": 34}, "lv_spinbox_create": {"type": "Function", "def": "lv_obj_t * lv_spinbox_create(lv_obj_t * parent)", "sline": 49, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_spinbox_set_value": {"type": "Function", "def": "void lv_spinbox_set_value(lv_obj_t * obj, int32_t i)", "sline": 66, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spinbox_t * spinbox = (lv_spinbox_t *)obj;\n\n    if(i > spinbox->range_max) i = spinbox->range_max;\n    if(i < spinbox->range_min) i = spinbox->range_min;\n\n    spinbox->value = i;\n\n    lv_spinbox_updatevalue(obj);\n}"}, "lv_spinbox_set_rollover": {"type": "Function", "def": "void lv_spinbox_set_rollover(lv_obj_t * obj, bool b)", "sline": 84, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spinbox_t * spinbox = (lv_spinbox_t *)obj;\n\n    spinbox->rollover = b;\n}"}, "lv_spinbox_set_digit_format": {"type": "Function", "def": "void lv_spinbox_set_digit_format(lv_obj_t * obj, uint8_t digit_count, uint8_t separator_position)", "sline": 99, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spinbox_t * spinbox = (lv_spinbox_t *)obj;\n\n    if(digit_count > LV_SPINBOX_MAX_DIGIT_COUNT) digit_count = LV_SPINBOX_MAX_DIGIT_COUNT;\n\n    if(separator_position >= digit_count) separator_position = 0;\n    if(separator_position > LV_SPINBOX_MAX_DIGIT_COUNT) separator_position = LV_SPINBOX_MAX_DIGIT_COUNT;\n\n    if(digit_count < LV_SPINBOX_MAX_DIGIT_COUNT) {\n        int64_t max_val = lv_pow(10, digit_count);\n        if(spinbox->range_max > max_val - 1) spinbox->range_max = max_val - 1;\n        if(spinbox->range_min < - max_val  + 1) spinbox->range_min = - max_val  + 1;\n    }\n\n    spinbox->digit_count   = digit_count;\n    spinbox->dec_point_pos = separator_position;\n\n    lv_spinbox_updatevalue(obj);\n}"}, "lv_spinbox_set_step": {"type": "Function", "def": "void lv_spinbox_set_step(lv_obj_t * obj, uint32_t step)", "sline": 126, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spinbox_t * spinbox = (lv_spinbox_t *)obj;\n\n    spinbox->step = step;\n    lv_spinbox_updatevalue(obj);\n}"}, "lv_spinbox_set_range": {"type": "Function", "def": "void lv_spinbox_set_range(lv_obj_t * obj, int32_t range_min, int32_t range_max)", "sline": 141, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spinbox_t * spinbox = (lv_spinbox_t *)obj;\n\n    spinbox->range_max = range_max;\n    spinbox->range_min = range_min;\n\n    if(spinbox->value > spinbox->range_max) spinbox->value = spinbox->range_max;\n    if(spinbox->value < spinbox->range_min) spinbox->value = spinbox->range_min;\n\n    lv_spinbox_updatevalue(obj);\n}"}, "lv_spinbox_set_pos": {"type": "Function", "def": "void lv_spinbox_set_pos(lv_obj_t * obj, uint8_t pos)", "sline": 160, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spinbox_t * spinbox = (lv_spinbox_t *)obj;\n    int32_t step_limit;\n    step_limit       = LV_MAX(spinbox->range_max, (spinbox->range_min < 0 ? (-spinbox->range_min) : spinbox->range_min));\n    int32_t new_step = spinbox->step * lv_pow(10, pos);\n    if(pos <= 0) spinbox->step = 1;\n    else if(new_step <= step_limit) spinbox->step = new_step;\n\n    lv_spinbox_updatevalue(obj);\n}"}, "lv_spinbox_set_digit_step_direction": {"type": "Function", "def": "void lv_spinbox_set_digit_step_direction(lv_obj_t *obj, lv_dir_t direction)", "sline": 178, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spinbox_t * spinbox = (lv_spinbox_t *)obj;\n    spinbox->digit_step_dir = direction;\n\n    lv_spinbox_updatevalue(obj);\n}"}, "lv_spinbox_get_value": {"type": "Function", "def": "int32_t lv_spinbox_get_value(lv_obj_t * obj)", "sline": 195, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spinbox_t * spinbox = (lv_spinbox_t *)obj;\n\n    return spinbox->value;\n}"}, "lv_spinbox_get_step": {"type": "Function", "def": "int32_t lv_spinbox_get_step(lv_obj_t * obj)", "sline": 207, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spinbox_t * spinbox = (lv_spinbox_t *)obj;\n\n    return spinbox->step;\n}"}, "lv_spinbox_step_next": {"type": "Function", "def": "void lv_spinbox_step_next(lv_obj_t * obj)", "sline": 223, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spinbox_t * spinbox = (lv_spinbox_t *)obj;\n\n    int32_t new_step = spinbox->step / 10;\n    if((new_step) > 0)\n        spinbox->step = new_step;\n    else\n        spinbox->step = 1;\n\n    lv_spinbox_updatevalue(obj);\n}"}, "lv_spinbox_step_prev": {"type": "Function", "def": "void lv_spinbox_step_prev(lv_obj_t * obj)", "sline": 241, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spinbox_t * spinbox = (lv_spinbox_t *)obj;\n    int32_t step_limit;\n    step_limit       = LV_MAX(spinbox->range_max, (spinbox->range_min < 0 ? (-spinbox->range_min) : spinbox->range_min));\n    int32_t new_step = spinbox->step * 10;\n    if(new_step <= step_limit) spinbox->step = new_step;\n\n    lv_spinbox_updatevalue(obj);\n}"}, "lv_spinbox_get_rollover": {"type": "Function", "def": "bool lv_spinbox_get_rollover(lv_obj_t * obj)", "sline": 257, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spinbox_t * spinbox = (lv_spinbox_t *)obj;\n\n    return spinbox->rollover;\n}"}, "lv_spinbox_increment": {"type": "Function", "def": "void lv_spinbox_increment(lv_obj_t * obj)", "sline": 269, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spinbox_t * spinbox = (lv_spinbox_t *)obj;\n\n    if(spinbox->value + spinbox->step <= spinbox->range_max) {\n        /*Special mode when zero crossing*/\n        if((spinbox->value + spinbox->step) > 0 && spinbox->value < 0) spinbox->value = -spinbox->value;\n        spinbox->value += spinbox->step;\n\n    }\n    else {\n        // Rollover?\n        if((spinbox->rollover) && (spinbox->value == spinbox->range_max))\n            spinbox->value = spinbox->range_min;\n        else\n            spinbox->value = spinbox->range_max;\n    }\n\n    lv_spinbox_updatevalue(obj);\n}"}, "lv_spinbox_decrement": {"type": "Function", "def": "void lv_spinbox_decrement(lv_obj_t * obj)", "sline": 295, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spinbox_t * spinbox = (lv_spinbox_t *)obj;\n\n    if(spinbox->value - spinbox->step >= spinbox->range_min) {\n        /*Special mode when zero crossing*/\n        if((spinbox->value - spinbox->step) < 0 && spinbox->value > 0) spinbox->value = -spinbox->value;\n        spinbox->value -= spinbox->step;\n    }\n    else {\n        /*Rollover?*/\n        if((spinbox->rollover) && (spinbox->value == spinbox->range_min))\n            spinbox->value = spinbox->range_max;\n        else\n            spinbox->value = spinbox->range_min;\n    }\n\n    lv_spinbox_updatevalue(obj);\n}"}, "carbit_updater/lvgl/src/extra/widgets/spinbox/lv_spinbox.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/spinbox/lv_spinbox.c"}}, "carbit_updater/lvgl/src/misc/lv_style_gen.h": {"lv_style_set_width": {"type": "Function", "def": "void lv_style_set_width(lv_style_t * style, lv_coord_t value)", "sline": 1}, "lv_style_set_min_width": {"type": "Function", "def": "void lv_style_set_min_width(lv_style_t * style, lv_coord_t value)", "sline": 2}, "lv_style_set_max_width": {"type": "Function", "def": "void lv_style_set_max_width(lv_style_t * style, lv_coord_t value)", "sline": 3}, "lv_style_set_height": {"type": "Function", "def": "void lv_style_set_height(lv_style_t * style, lv_coord_t value)", "sline": 4}, "lv_style_set_min_height": {"type": "Function", "def": "void lv_style_set_min_height(lv_style_t * style, lv_coord_t value)", "sline": 5}, "lv_style_set_max_height": {"type": "Function", "def": "void lv_style_set_max_height(lv_style_t * style, lv_coord_t value)", "sline": 6}, "lv_style_set_x": {"type": "Function", "def": "void lv_style_set_x(lv_style_t * style, lv_coord_t value)", "sline": 7}, "lv_style_set_y": {"type": "Function", "def": "void lv_style_set_y(lv_style_t * style, lv_coord_t value)", "sline": 8}, "lv_style_set_align": {"type": "Function", "def": "void lv_style_set_align(lv_style_t * style, lv_align_t value)", "sline": 9}, "lv_style_set_transform_width": {"type": "Function", "def": "void lv_style_set_transform_width(lv_style_t * style, lv_coord_t value)", "sline": 10}, "lv_style_set_transform_height": {"type": "Function", "def": "void lv_style_set_transform_height(lv_style_t * style, lv_coord_t value)", "sline": 11}, "lv_style_set_translate_x": {"type": "Function", "def": "void lv_style_set_translate_x(lv_style_t * style, lv_coord_t value)", "sline": 12}, "lv_style_set_translate_y": {"type": "Function", "def": "void lv_style_set_translate_y(lv_style_t * style, lv_coord_t value)", "sline": 13}, "lv_style_set_transform_zoom": {"type": "Function", "def": "void lv_style_set_transform_zoom(lv_style_t * style, lv_coord_t value)", "sline": 14}, "lv_style_set_transform_angle": {"type": "Function", "def": "void lv_style_set_transform_angle(lv_style_t * style, lv_coord_t value)", "sline": 15}, "lv_style_set_pad_top": {"type": "Function", "def": "void lv_style_set_pad_top(lv_style_t * style, lv_coord_t value)", "sline": 16}, "lv_style_set_pad_bottom": {"type": "Function", "def": "void lv_style_set_pad_bottom(lv_style_t * style, lv_coord_t value)", "sline": 17}, "lv_style_set_pad_left": {"type": "Function", "def": "void lv_style_set_pad_left(lv_style_t * style, lv_coord_t value)", "sline": 18}, "lv_style_set_pad_right": {"type": "Function", "def": "void lv_style_set_pad_right(lv_style_t * style, lv_coord_t value)", "sline": 19}, "lv_style_set_pad_row": {"type": "Function", "def": "void lv_style_set_pad_row(lv_style_t * style, lv_coord_t value)", "sline": 20}, "lv_style_set_pad_column": {"type": "Function", "def": "void lv_style_set_pad_column(lv_style_t * style, lv_coord_t value)", "sline": 21}, "lv_style_set_radius": {"type": "Function", "def": "void lv_style_set_radius(lv_style_t * style, lv_coord_t value)", "sline": 22}, "lv_style_set_clip_corner": {"type": "Function", "def": "void lv_style_set_clip_corner(lv_style_t * style, bool value)", "sline": 23}, "lv_style_set_opa": {"type": "Function", "def": "void lv_style_set_opa(lv_style_t * style, lv_opa_t value)", "sline": 24}, "lv_style_set_color_filter_dsc": {"type": "Function", "def": "void lv_style_set_color_filter_dsc(lv_style_t * style, const lv_color_filter_dsc_t * value)", "sline": 25}, "lv_style_set_color_filter_opa": {"type": "Function", "def": "void lv_style_set_color_filter_opa(lv_style_t * style, lv_opa_t value)", "sline": 26}, "lv_style_set_anim_time": {"type": "Function", "def": "void lv_style_set_anim_time(lv_style_t * style, uint32_t value)", "sline": 27}, "lv_style_set_anim_speed": {"type": "Function", "def": "void lv_style_set_anim_speed(lv_style_t * style, uint32_t value)", "sline": 28}, "lv_style_set_transition": {"type": "Function", "def": "void lv_style_set_transition(lv_style_t * style, const lv_style_transition_dsc_t * value)", "sline": 29}, "lv_style_set_blend_mode": {"type": "Function", "def": "void lv_style_set_blend_mode(lv_style_t * style, lv_blend_mode_t value)", "sline": 30}, "lv_style_set_layout": {"type": "Function", "def": "void lv_style_set_layout(lv_style_t * style, uint16_t value)", "sline": 31}, "lv_style_set_base_dir": {"type": "Function", "def": "void lv_style_set_base_dir(lv_style_t * style, lv_base_dir_t value)", "sline": 32}, "lv_style_set_bg_color": {"type": "Function", "def": "void lv_style_set_bg_color(lv_style_t * style, lv_color_t value)", "sline": 33}, "lv_style_set_bg_color_filtered": {"type": "Function", "def": "void lv_style_set_bg_color_filtered(lv_style_t * style, lv_color_t value)", "sline": 34}, "lv_style_set_bg_opa": {"type": "Function", "def": "void lv_style_set_bg_opa(lv_style_t * style, lv_opa_t value)", "sline": 35}, "lv_style_set_bg_grad_color": {"type": "Function", "def": "void lv_style_set_bg_grad_color(lv_style_t * style, lv_color_t value)", "sline": 36}, "lv_style_set_bg_grad_color_filtered": {"type": "Function", "def": "void lv_style_set_bg_grad_color_filtered(lv_style_t * style, lv_color_t value)", "sline": 37}, "lv_style_set_bg_grad_dir": {"type": "Function", "def": "void lv_style_set_bg_grad_dir(lv_style_t * style, lv_grad_dir_t value)", "sline": 38}, "lv_style_set_bg_main_stop": {"type": "Function", "def": "void lv_style_set_bg_main_stop(lv_style_t * style, lv_coord_t value)", "sline": 39}, "lv_style_set_bg_grad_stop": {"type": "Function", "def": "void lv_style_set_bg_grad_stop(lv_style_t * style, lv_coord_t value)", "sline": 40}, "lv_style_set_bg_img_src": {"type": "Function", "def": "void lv_style_set_bg_img_src(lv_style_t * style, const void * value)", "sline": 41}, "lv_style_set_bg_img_opa": {"type": "Function", "def": "void lv_style_set_bg_img_opa(lv_style_t * style, lv_opa_t value)", "sline": 42}, "lv_style_set_bg_img_recolor": {"type": "Function", "def": "void lv_style_set_bg_img_recolor(lv_style_t * style, lv_color_t value)", "sline": 43}, "lv_style_set_bg_img_recolor_filtered": {"type": "Function", "def": "void lv_style_set_bg_img_recolor_filtered(lv_style_t * style, lv_color_t value)", "sline": 44}, "lv_style_set_bg_img_recolor_opa": {"type": "Function", "def": "void lv_style_set_bg_img_recolor_opa(lv_style_t * style, lv_opa_t value)", "sline": 45}, "lv_style_set_bg_img_tiled": {"type": "Function", "def": "void lv_style_set_bg_img_tiled(lv_style_t * style, bool value)", "sline": 46}, "lv_style_set_border_color": {"type": "Function", "def": "void lv_style_set_border_color(lv_style_t * style, lv_color_t value)", "sline": 47}, "lv_style_set_border_color_filtered": {"type": "Function", "def": "void lv_style_set_border_color_filtered(lv_style_t * style, lv_color_t value)", "sline": 48}, "lv_style_set_border_opa": {"type": "Function", "def": "void lv_style_set_border_opa(lv_style_t * style, lv_opa_t value)", "sline": 49}, "lv_style_set_border_width": {"type": "Function", "def": "void lv_style_set_border_width(lv_style_t * style, lv_coord_t value)", "sline": 50}, "lv_style_set_border_side": {"type": "Function", "def": "void lv_style_set_border_side(lv_style_t * style, lv_border_side_t value)", "sline": 51}, "lv_style_set_border_post": {"type": "Function", "def": "void lv_style_set_border_post(lv_style_t * style, bool value)", "sline": 52}, "lv_style_set_text_color": {"type": "Function", "def": "void lv_style_set_text_color(lv_style_t * style, lv_color_t value)", "sline": 53}, "lv_style_set_text_color_filtered": {"type": "Function", "def": "void lv_style_set_text_color_filtered(lv_style_t * style, lv_color_t value)", "sline": 54}, "lv_style_set_text_opa": {"type": "Function", "def": "void lv_style_set_text_opa(lv_style_t * style, lv_opa_t value)", "sline": 55}, "lv_style_set_text_font": {"type": "Function", "def": "void lv_style_set_text_font(lv_style_t * style, const lv_font_t * value)", "sline": 56}, "lv_style_set_text_letter_space": {"type": "Function", "def": "void lv_style_set_text_letter_space(lv_style_t * style, lv_coord_t value)", "sline": 57}, "lv_style_set_text_line_space": {"type": "Function", "def": "void lv_style_set_text_line_space(lv_style_t * style, lv_coord_t value)", "sline": 58}, "lv_style_set_text_decor": {"type": "Function", "def": "void lv_style_set_text_decor(lv_style_t * style, lv_text_decor_t value)", "sline": 59}, "lv_style_set_text_align": {"type": "Function", "def": "void lv_style_set_text_align(lv_style_t * style, lv_text_align_t value)", "sline": 60}, "lv_style_set_img_opa": {"type": "Function", "def": "void lv_style_set_img_opa(lv_style_t * style, lv_opa_t value)", "sline": 61}, "lv_style_set_img_recolor": {"type": "Function", "def": "void lv_style_set_img_recolor(lv_style_t * style, lv_color_t value)", "sline": 62}, "lv_style_set_img_recolor_filtered": {"type": "Function", "def": "void lv_style_set_img_recolor_filtered(lv_style_t * style, lv_color_t value)", "sline": 63}, "lv_style_set_img_recolor_opa": {"type": "Function", "def": "void lv_style_set_img_recolor_opa(lv_style_t * style, lv_opa_t value)", "sline": 64}, "lv_style_set_outline_width": {"type": "Function", "def": "void lv_style_set_outline_width(lv_style_t * style, lv_coord_t value)", "sline": 65}, "lv_style_set_outline_color": {"type": "Function", "def": "void lv_style_set_outline_color(lv_style_t * style, lv_color_t value)", "sline": 66}, "lv_style_set_outline_color_filtered": {"type": "Function", "def": "void lv_style_set_outline_color_filtered(lv_style_t * style, lv_color_t value)", "sline": 67}, "lv_style_set_outline_opa": {"type": "Function", "def": "void lv_style_set_outline_opa(lv_style_t * style, lv_opa_t value)", "sline": 68}, "lv_style_set_outline_pad": {"type": "Function", "def": "void lv_style_set_outline_pad(lv_style_t * style, lv_coord_t value)", "sline": 69}, "lv_style_set_shadow_width": {"type": "Function", "def": "void lv_style_set_shadow_width(lv_style_t * style, lv_coord_t value)", "sline": 70}, "lv_style_set_shadow_ofs_x": {"type": "Function", "def": "void lv_style_set_shadow_ofs_x(lv_style_t * style, lv_coord_t value)", "sline": 71}, "lv_style_set_shadow_ofs_y": {"type": "Function", "def": "void lv_style_set_shadow_ofs_y(lv_style_t * style, lv_coord_t value)", "sline": 72}, "lv_style_set_shadow_spread": {"type": "Function", "def": "void lv_style_set_shadow_spread(lv_style_t * style, lv_coord_t value)", "sline": 73}, "lv_style_set_shadow_color": {"type": "Function", "def": "void lv_style_set_shadow_color(lv_style_t * style, lv_color_t value)", "sline": 74}, "lv_style_set_shadow_color_filtered": {"type": "Function", "def": "void lv_style_set_shadow_color_filtered(lv_style_t * style, lv_color_t value)", "sline": 75}, "lv_style_set_shadow_opa": {"type": "Function", "def": "void lv_style_set_shadow_opa(lv_style_t * style, lv_opa_t value)", "sline": 76}, "lv_style_set_line_width": {"type": "Function", "def": "void lv_style_set_line_width(lv_style_t * style, lv_coord_t value)", "sline": 77}, "lv_style_set_line_dash_width": {"type": "Function", "def": "void lv_style_set_line_dash_width(lv_style_t * style, lv_coord_t value)", "sline": 78}, "lv_style_set_line_dash_gap": {"type": "Function", "def": "void lv_style_set_line_dash_gap(lv_style_t * style, lv_coord_t value)", "sline": 79}, "lv_style_set_line_rounded": {"type": "Function", "def": "void lv_style_set_line_rounded(lv_style_t * style, bool value)", "sline": 80}, "lv_style_set_line_color": {"type": "Function", "def": "void lv_style_set_line_color(lv_style_t * style, lv_color_t value)", "sline": 81}, "lv_style_set_line_color_filtered": {"type": "Function", "def": "void lv_style_set_line_color_filtered(lv_style_t * style, lv_color_t value)", "sline": 82}, "lv_style_set_line_opa": {"type": "Function", "def": "void lv_style_set_line_opa(lv_style_t * style, lv_opa_t value)", "sline": 83}, "lv_style_set_arc_width": {"type": "Function", "def": "void lv_style_set_arc_width(lv_style_t * style, lv_coord_t value)", "sline": 84}, "lv_style_set_arc_rounded": {"type": "Function", "def": "void lv_style_set_arc_rounded(lv_style_t * style, bool value)", "sline": 85}, "lv_style_set_arc_color": {"type": "Function", "def": "void lv_style_set_arc_color(lv_style_t * style, lv_color_t value)", "sline": 86}, "lv_style_set_arc_color_filtered": {"type": "Function", "def": "void lv_style_set_arc_color_filtered(lv_style_t * style, lv_color_t value)", "sline": 87}, "lv_style_set_arc_opa": {"type": "Function", "def": "void lv_style_set_arc_opa(lv_style_t * style, lv_opa_t value)", "sline": 88}, "lv_style_set_arc_img_src": {"type": "Function", "def": "void lv_style_set_arc_img_src(lv_style_t * style, const void * value)", "sline": 89}, "carbit_updater/lvgl/src/misc/lv_style_gen.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_style_gen.h"}}, "carbit_updater/lvgl/src/draw/lv_draw_blend.c": {"lv_draw_blend": {"type": "Variable", "def": "#include lv_draw_blend.h", "sline": 9, "include": ["carbit_updater/lvgl/src/draw/lv_draw_blend.h", null]}, "lv_img_decoder": {"type": "Variable", "def": "#include lv_img_decoder.h", "sline": 10, "include": ["carbit_updater/lvgl/src/draw/lv_img_decoder.h", null]}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 11}, "lv_hal_disp": {"type": "Variable", "def": "#include ../hal/lv_hal_disp.h", "sline": 12}, "lv_refr": {"type": "Variable", "def": "#include ../core/lv_refr.h", "sline": 13}, "fill_set_px": {"type": "Function", "def": "static void fill_set_px(const lv_area_t * disp_area, lv_color_t * disp_buf,  const lv_area_t * draw_area,\n                        lv_color_t color, lv_opa_t opa,\n                        const lv_opa_t * mask, lv_draw_mask_res_t mask_res)", "sline": 241, "body": "{\n\n    lv_disp_t * disp = _lv_refr_get_disp_refreshing();\n\n    /*Get the width of the `disp_area` it will be used to go to the next line*/\n    int32_t disp_w = lv_area_get_width(disp_area);\n\n    int32_t x;\n    int32_t y;\n\n    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {\n        for(y = draw_area->y1; y <= draw_area->y2; y++) {\n            for(x = draw_area->x1; x <= draw_area->x2; x++) {\n                disp->driver->set_px_cb(disp->driver, (void *)disp_buf, disp_w, x, y, color, opa);\n            }\n        }\n    }\n    else {\n        /*The mask is relative to the clipped area.\n         *In the cycles below mask will be indexed from `draw_area.x1`\n         *but it corresponds to zero index. So prepare `mask_tmp` accordingly.*/\n        const lv_opa_t * mask_tmp = mask - draw_area->x1;\n\n        /*Get the width of the `draw_area` it will be used to go to the next line of the mask*/\n        int32_t draw_area_w = lv_area_get_width(draw_area);\n\n        for(y = draw_area->y1; y <= draw_area->y2; y++) {\n            for(x = draw_area->x1; x <= draw_area->x2; x++) {\n                if(mask_tmp[x]) {\n                    disp->driver->set_px_cb(disp->driver, (void *)disp_buf, disp_w, x, y, color,\n                                            (uint32_t)((uint32_t)opa * mask_tmp[x]) >> 8);\n                }\n            }\n            mask_tmp += draw_area_w;\n        }\n    }\n}"}, "fill_normal": {"type": "Function", "def": "static void fill_normal(const lv_area_t * disp_area, lv_color_t * disp_buf,\n                                              const lv_area_t * draw_area,\n                                              lv_color_t color, lv_opa_t opa,\n                                              const lv_opa_t * mask, lv_draw_mask_res_t mask_res)", "sline": 296, "body": "{\n\n    lv_disp_t * disp = _lv_refr_get_disp_refreshing();\n\n    /*Get the width of the `disp_area` it will be used to go to the next line*/\n    int32_t disp_w = lv_area_get_width(disp_area);\n\n    int32_t draw_area_w = lv_area_get_width(draw_area);\n    int32_t draw_area_h = lv_area_get_height(draw_area);\n\n    /*Create a temp. disp_buf which always point to the first pixel of the destination area*/\n    lv_color_t * disp_buf_first = disp_buf + disp_w * draw_area->y1 + draw_area->x1;\n\n    int32_t x;\n    int32_t y;\n\n    /*Simple fill (maybe with opacity), no masking*/\n    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {\n        if(opa > LV_OPA_MAX) {\n#if LV_USE_GPU_NXP_PXP\n            if(lv_area_get_size(draw_area) >= LV_GPU_NXP_PXP_FILL_SIZE_LIMIT) {\n                lv_gpu_nxp_pxp_fill(disp_buf, disp_w, draw_area, color, opa);\n                return;\n            }\n#elif LV_USE_GPU_NXP_VG_LITE\n            if(lv_area_get_size(draw_area) >= LV_GPU_NXP_VG_LITE_FILL_SIZE_LIMIT) {\n                if(lv_gpu_nxp_vglite_fill(disp_buf, disp_w, lv_area_get_height(disp_area), draw_area, color, opa) == LV_RES_OK) {\n                    return;\n                }\n            }\n#elif LV_USE_GPU_STM32_DMA2D\n            if(lv_area_get_size(draw_area) >= 240) {\n                lv_gpu_stm32_dma2d_fill(disp_buf_first, disp_w, color, draw_area_w, draw_area_h);\n                return;\n            }\n#elif LV_USE_SUNXIFB_G2D_FILL\n#if 0\n            if(draw_area_w > sunxifb_g2d_get_limit(SUNXI_G2D_LIMIT_FILL)) {\n                if (!sunxifb_g2d_fill(disp_buf, disp_area, draw_area, color, opa))\n                    return;\n            }\n#endif\n#endif\n\n            if(disp->driver->gpu_fill_cb && lv_area_get_size(draw_area) > GPU_SIZE_LIMIT) {\n                disp->driver->gpu_fill_cb(disp->driver, disp_buf, disp_w, draw_area, color);\n                return;\n            }\n\n            /*Software rendering*/\n            for(y = 0; y < draw_area_h; y++) {\n                lv_color_fill(disp_buf_first, color, draw_area_w);\n                disp_buf_first += disp_w;\n            }\n        }\n        /*No mask with opacity*/\n        else {\n#if LV_USE_GPU_NXP_PXP\n            if(lv_area_get_size(draw_area) >= LV_GPU_NXP_PXP_FILL_OPA_SIZE_LIMIT) {\n                lv_gpu_nxp_pxp_fill(disp_buf, disp_w, draw_area, color, opa);\n                return;\n            }\n#elif LV_USE_GPU_NXP_VG_LITE\n            if(lv_area_get_size(draw_area) >= LV_GPU_NXP_VG_LITE_FILL_OPA_SIZE_LIMIT) {\n                if(lv_gpu_nxp_vglite_fill(disp_buf, disp_w, lv_area_get_height(disp_area), draw_area, color, opa) == LV_RES_OK) {\n                    return;\n                }\n                /*Fall down to SW render in case of error*/\n            }\n#elif LV_USE_SUNXIFB_G2D_FILL\n            if(draw_area_w * draw_area_h >= sunxifb_g2d_get_limit(SUNXI_G2D_LIMIT_OPA_FILL)) {\n                if (!sunxifb_g2d_fill(disp_buf, disp_area, draw_area, color, opa))\n                    return;\n            }\n#endif\n            lv_color_t last_dest_color = lv_color_black();\n            lv_color_t last_res_color = lv_color_mix(color, last_dest_color, opa);\n\n            uint16_t color_premult[3];\n            lv_color_premult(color, opa, color_premult);\n            lv_opa_t opa_inv = 255 - opa;\n\n            for(y = 0; y < draw_area_h; y++) {\n                for(x = 0; x < draw_area_w; x++) {\n                    if(last_dest_color.full != disp_buf_first[x].full) {\n                        last_dest_color = disp_buf_first[x];\n\n#if LV_COLOR_SCREEN_TRANSP\n                        if(disp->driver->screen_transp) {\n                            lv_color_mix_with_alpha(disp_buf_first[x], disp_buf_first[x].ch.alpha, color, opa, &last_res_color,\n                                                    &last_res_color.ch.alpha);\n                        }\n                        else\n#endif\n                        {\n                            last_res_color = lv_color_mix_premult(color_premult, disp_buf_first[x], opa_inv);\n                        }\n                    }\n                    disp_buf_first[x] = last_res_color;\n                }\n                disp_buf_first += disp_w;\n            }\n        }\n    }\n    /*Masked*/\n    else {\n        int32_t x_end4 = draw_area_w - 4;\n\n#if LV_COLOR_DEPTH == 16\n        uint32_t c32 = color.full + ((uint32_t)color.full << 16);\n#endif\n\n        /*Only the mask matters*/\n        if(opa > LV_OPA_MAX) {\n            for(y = 0; y < draw_area_h; y++) {\n                for(x = 0; x < draw_area_w && ((lv_uintptr_t)(mask) & 0x3); x++) {\n                    FILL_NORMAL_MASK_PX(color)\n                }\n\n                for(; x <= x_end4; x += 4) {\n                    uint32_t mask32 = *((uint32_t *)mask);\n                    if(mask32 == 0xFFFFFFFF) {\n#if LV_COLOR_DEPTH == 16\n                        if((lv_uintptr_t)disp_buf_first & 0x3) {\n                            *(disp_buf_first + 0) = color;\n                            uint32_t * d = (uint32_t *)(disp_buf_first + 1);\n                            *d = c32;\n                            *(disp_buf_first + 3) = color;\n                        }\n                        else {\n                            uint32_t * d = (uint32_t *)disp_buf_first;\n                            *d = c32;\n                            *(d + 1) = c32;\n                        }\n#else\n                        disp_buf_first[0] = color;\n                        disp_buf_first[1] = color;\n                        disp_buf_first[2] = color;\n                        disp_buf_first[3] = color;\n#endif\n                        disp_buf_first += 4;\n                        mask += 4;\n                    }\n                    else if(mask32) {\n                        FILL_NORMAL_MASK_PX(color)\n                        FILL_NORMAL_MASK_PX(color)\n                        FILL_NORMAL_MASK_PX(color)\n                        FILL_NORMAL_MASK_PX(color)\n                    }\n                    else {\n                        mask += 4;\n                        disp_buf_first += 4;\n                    }\n                }\n\n                for(; x < draw_area_w ; x++) {\n                    FILL_NORMAL_MASK_PX(color)\n                }\n                disp_buf_first += (disp_w - draw_area_w);\n            }\n        }\n        /*Handle opa and mask values too*/\n        else {\n            /*Buffer the result color to avoid recalculating the same color*/\n            lv_color_t last_dest_color;\n            lv_color_t last_res_color;\n            lv_opa_t last_mask = LV_OPA_TRANSP;\n            last_dest_color.full = disp_buf_first[0].full;\n            last_res_color.full = disp_buf_first[0].full;\n            lv_opa_t opa_tmp = LV_OPA_TRANSP;\n\n            for(y = draw_area->y1; y <= draw_area->y2; y++) {\n                const lv_opa_t * mask_tmp_x = mask;\n                for(x = 0; x < draw_area_w; x++) {\n                    if(*mask_tmp_x) {\n                        if(*mask_tmp_x != last_mask) opa_tmp = *mask_tmp_x == LV_OPA_COVER ? opa :\n                                                                   (uint32_t)((uint32_t)(*mask_tmp_x) * opa) >> 8;\n                        if(*mask_tmp_x != last_mask || last_dest_color.full != disp_buf_first[x].full) {\n#if LV_COLOR_SCREEN_TRANSP\n                            if(disp->driver->screen_transp) {\n                                lv_color_mix_with_alpha(disp_buf_first[x], disp_buf_first[x].ch.alpha, color, opa_tmp, &last_res_color,\n                                                        &last_res_color.ch.alpha);\n                            }\n                            else\n#endif\n                            {\n                                if(opa_tmp == LV_OPA_COVER) last_res_color = color;\n                                else last_res_color = lv_color_mix(color, disp_buf_first[x], opa_tmp);\n                            }\n                            last_mask = *mask_tmp_x;\n                            last_dest_color.full = disp_buf_first[x].full;\n                        }\n                        disp_buf_first[x] = last_res_color;\n                    }\n                    mask_tmp_x++;\n                }\n                disp_buf_first += disp_w;\n                mask += draw_area_w;\n            }\n        }\n    }\n}"}, "fill_blended": {"type": "Function", "def": "static void fill_blended(const lv_area_t * disp_area, lv_color_t * disp_buf,  const lv_area_t * draw_area,\n                         lv_color_t color, lv_opa_t opa,\n                         const lv_opa_t * mask, lv_draw_mask_res_t mask_res, lv_blend_mode_t mode)", "sline": 518, "body": "{\n    /*Get the width of the `disp_area` it will be used to go to the next line*/\n    int32_t disp_w = lv_area_get_width(disp_area);\n\n    /*Create a temp. disp_buf which always point to current line to draw*/\n    lv_color_t * disp_buf_tmp = disp_buf + disp_w * draw_area->y1;\n\n    lv_color_t (*blend_fp)(lv_color_t, lv_color_t, lv_opa_t);\n    switch(mode) {\n        case LV_BLEND_MODE_ADDITIVE:\n            blend_fp = color_blend_true_color_additive;\n            break;\n        case LV_BLEND_MODE_SUBTRACTIVE:\n            blend_fp = color_blend_true_color_subtractive;\n            break;\n        case LV_BLEND_MODE_MULTIPLY:\n            blend_fp = color_blend_true_color_multiply;\n            break;\n        default:\n            LV_LOG_WARN(\"fill_blended: unsupported blend mode\");\n            return;\n    }\n\n    int32_t x;\n    int32_t y;\n\n    /*Simple fill (maybe with opacity), no masking*/\n    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {\n        lv_color_t last_dest_color = lv_color_black();\n        lv_color_t last_res_color = lv_color_mix(color, last_dest_color, opa);\n        for(y = draw_area->y1; y <= draw_area->y2; y++) {\n            for(x = draw_area->x1; x <= draw_area->x2; x++) {\n                if(last_dest_color.full != disp_buf_tmp[x].full) {\n                    last_dest_color = disp_buf_tmp[x];\n                    last_res_color = blend_fp(color, disp_buf_tmp[x], opa);\n                }\n                disp_buf_tmp[x] = last_res_color;\n            }\n            disp_buf_tmp += disp_w;\n        }\n    }\n    /*Masked*/\n    else {\n        /*Get the width of the `draw_area` it will be used to go to the next line of the mask*/\n        int32_t draw_area_w = lv_area_get_width(draw_area);\n\n        /*The mask is relative to the clipped area.\n         *In the cycles below mask will be indexed from `draw_area.x1`\n         *but it corresponds to zero index. So prepare `mask_tmp` accordingly.*/\n        const lv_opa_t * mask_tmp = mask - draw_area->x1;\n\n        /*Buffer the result color to avoid recalculating the same color*/\n        lv_color_t last_dest_color;\n        lv_color_t last_res_color;\n        lv_opa_t last_mask = LV_OPA_TRANSP;\n        last_dest_color.full = disp_buf_tmp[0].full;\n        last_res_color.full = disp_buf_tmp[0].full;\n\n        for(y = draw_area->y1; y <= draw_area->y2; y++) {\n            for(x = draw_area->x1; x <= draw_area->x2; x++) {\n                if(mask_tmp[x] == 0) continue;\n                if(mask_tmp[x] != last_mask || last_dest_color.full != disp_buf_tmp[x].full) {\n                    lv_opa_t opa_tmp = mask_tmp[x] >= LV_OPA_MAX ? opa : (uint32_t)((uint32_t)mask_tmp[x] * opa) >> 8;\n\n                    last_res_color = blend_fp(color, disp_buf_tmp[x], opa_tmp);\n                    last_mask = mask_tmp[x];\n                    last_dest_color.full = disp_buf_tmp[x].full;\n                }\n                disp_buf_tmp[x] = last_res_color;\n            }\n            disp_buf_tmp += disp_w;\n            mask_tmp += draw_area_w;\n        }\n    }\n}"}, "map_set_px": {"type": "Function", "def": "static void map_set_px(const lv_area_t * disp_area, lv_color_t * disp_buf,  const lv_area_t * draw_area,\n                       const lv_area_t * map_area, const lv_color_t * map_buf, lv_opa_t opa,\n                       const lv_opa_t * mask, lv_draw_mask_res_t mask_res)", "sline": 599, "body": "{\n    lv_disp_t * disp = _lv_refr_get_disp_refreshing();\n\n    /*Get the width of the `disp_area` it will be used to go to the next line*/\n    int32_t disp_w = lv_area_get_width(disp_area);\n\n    /*Get the width of the `draw_area` it will be used to go to the next line of the mask*/\n    int32_t draw_area_w = lv_area_get_width(draw_area);\n\n    /*Get the width of the `mask_area` it will be used to go to the next line*/\n    int32_t map_w = lv_area_get_width(map_area);\n\n    /*Create a temp. map_buf which always point to current line to draw*/\n    const lv_color_t * map_buf_tmp = map_buf + map_w * (draw_area->y1 - (map_area->y1 - disp_area->y1));\n\n    map_buf_tmp += (draw_area->x1 - (map_area->x1 - disp_area->x1));\n    map_buf_tmp -= draw_area->x1;\n    int32_t x;\n    int32_t y;\n\n    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {\n        for(y = draw_area->y1; y <= draw_area->y2; y++) {\n            for(x = draw_area->x1; x <= draw_area->x2; x++) {\n                disp->driver->set_px_cb(disp->driver, (void *)disp_buf, disp_w, x, y, map_buf_tmp[x], opa);\n            }\n            map_buf_tmp += map_w;\n        }\n    }\n    else {\n        /*The mask is relative to the clipped area.\n         *In the cycles below mask will be indexed from `draw_area.x1`\n         *but it corresponds to zero index. So prepare `mask_tmp` accordingly.*/\n        const lv_opa_t * mask_tmp = mask - draw_area->x1;\n\n        for(y = draw_area->y1; y <= draw_area->y2; y++) {\n            for(x = draw_area->x1; x <= draw_area->x2; x++) {\n                if(mask_tmp[x]) {\n                    disp->driver->set_px_cb(disp->driver, (void *)disp_buf, disp_w, x, y, map_buf_tmp[x],\n                                            (uint32_t)((uint32_t)opa * mask_tmp[x]) >> 8);\n                }\n            }\n            mask_tmp += draw_area_w;\n            map_buf_tmp += map_w;\n        }\n    }\n}"}, "map_normal": {"type": "Function", "def": "static void map_normal(const lv_area_t * disp_area, lv_color_t * disp_buf,\n                                             const lv_area_t * draw_area,\n                                             const lv_area_t * map_area, const lv_color_t * map_buf, lv_opa_t opa,\n                                             const lv_opa_t * mask, lv_draw_mask_res_t mask_res)", "sline": 663, "body": "{\n\n    /*Get the width of the `disp_area` it will be used to go to the next line*/\n    int32_t disp_w = lv_area_get_width(disp_area);\n\n    int32_t draw_area_w = lv_area_get_width(draw_area);\n    int32_t draw_area_h = lv_area_get_height(draw_area);\n\n    /*Get the width of the `mask_area` it will be used to go to the next line*/\n    int32_t map_w = lv_area_get_width(map_area);\n\n    /*Create a temp. disp_buf which always point to first pixel to draw*/\n    lv_color_t * disp_buf_first = disp_buf + disp_w * draw_area->y1 + draw_area->x1;\n\n    /*Create a temp. map_buf which always point to first pixel to draw from the map*/\n    const lv_color_t * map_buf_first = map_buf + map_w * (draw_area->y1 - (map_area->y1 - disp_area->y1));\n    map_buf_first += (draw_area->x1 - (map_area->x1 - disp_area->x1));\n\n#if LV_COLOR_SCREEN_TRANSP\n    lv_disp_t * disp = _lv_refr_get_disp_refreshing();\n#endif\n\n    int32_t x;\n    int32_t y;\n\n    /*Simple fill (maybe with opacity), no masking*/\n    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {\n        if(opa > LV_OPA_MAX) {\n#if LV_USE_GPU_NXP_PXP\n            if(lv_area_get_size(draw_area) >= LV_GPU_NXP_PXP_BLIT_SIZE_LIMIT) {\n                lv_gpu_nxp_pxp_blit(disp_buf_first, disp_w, map_buf_first, map_w, draw_area_w, draw_area_h, opa);\n                return;\n            }\n#elif (LV_USE_GPU_NXP_VG_LITE)\n            if(lv_area_get_size(draw_area) >= LV_GPU_NXP_VG_LITE_BLIT_SIZE_LIMIT) {\n\n                lv_gpu_nxp_vglite_blit_info_t blit;\n\n                blit.src = map_buf;\n                blit.src_width = draw_area_w;\n                blit.src_height = draw_area_h;\n                blit.src_stride = lv_area_get_width(map_area) * sizeof(lv_color_t);\n                blit.src_area.x1 = (draw_area->x1 - (map_area->x1 - disp_area->x1));\n                blit.src_area.y1 = (draw_area->y1 - (map_area->y1 - disp_area->y1));\n                blit.src_area.x2 = blit.src_area.x1 + draw_area_w;\n                blit.src_area.y2 = blit.src_area.y1 + draw_area_h;\n\n                blit.dst = disp_buf;\n                blit.dst_width = lv_area_get_width(disp_area);\n                blit.dst_height = lv_area_get_height(disp_area);\n                blit.dst_stride = lv_area_get_width(disp_area) * sizeof(lv_color_t);\n                blit.dst_area.x1 = draw_area->x1;\n                blit.dst_area.y1 = draw_area->y1;\n                blit.dst_area.x2 = blit.dst_area.x1 + draw_area_w;\n                blit.dst_area.y2 = blit.dst_area.y1 + draw_area_h;\n\n                blit.opa = opa;\n\n                if(lv_gpu_nxp_vglite_blit(&blit) == LV_RES_OK) {\n                    return;\n                }\n                /*Fall down to SW render in case of error*/\n            }\n#elif LV_USE_GPU_STM32_DMA2D\n            if(lv_area_get_size(draw_area) >= 240) {\n                lv_gpu_stm32_dma2d_copy(disp_buf_first, disp_w, map_buf_first, map_w, draw_area_w, draw_area_h);\n                return;\n            }\n#endif\n\n            /*Software rendering*/\n            for(y = 0; y < draw_area_h; y++) {\n                lv_memcpy(disp_buf_first, map_buf_first, draw_area_w * sizeof(lv_color_t));\n                disp_buf_first += disp_w;\n                map_buf_first += map_w;\n            }\n        }\n        else {\n#if LV_USE_GPU_NXP_PXP\n            if(lv_area_get_size(draw_area) >= LV_GPU_NXP_PXP_BLIT_OPA_SIZE_LIMIT) {\n                lv_gpu_nxp_pxp_blit(disp_buf_first, disp_w, map_buf_first, map_w, draw_area_w, draw_area_h, opa);\n                return;\n            }\n#elif (LV_USE_GPU_NXP_VG_LITE)\n            if(lv_area_get_size(draw_area) >= LV_GPU_NXP_VG_LITE_BLIT_OPA_SIZE_LIMIT) {\n\n                lv_gpu_nxp_vglite_blit_info_t blit;\n\n                blit.src = map_buf;\n                blit.src_width = lv_area_get_width(map_area);\n                blit.src_height = lv_area_get_height(map_area);\n                blit.src_stride = lv_area_get_width(map_area) * sizeof(lv_color_t);\n                blit.src_area.x1 = (draw_area->x1 - (map_area->x1 - disp_area->x1));\n                blit.src_area.y1 = (draw_area->y1 - (map_area->y1 - disp_area->y1));\n                blit.src_area.x2 = blit.src_area.x1 + draw_area_w;\n                blit.src_area.y2 = blit.src_area.y1 + draw_area_h;\n\n                blit.dst = disp_buf;\n                blit.dst_width = lv_area_get_width(disp_area);\n                blit.dst_height = lv_area_get_height(disp_area);\n                blit.dst_stride = lv_area_get_width(disp_area) * sizeof(lv_color_t);\n                blit.dst_area.x1 = draw_area->x1;\n                blit.dst_area.y1 = draw_area->y1;\n                blit.dst_area.x2 = blit.dst_area.x1 + draw_area_w;\n                blit.dst_area.y2 = blit.dst_area.y1 + draw_area_h;\n\n                blit.opa = opa;\n\n                if(lv_gpu_nxp_vglite_blit(&blit) == LV_RES_OK) {\n                    return;\n                }\n                /*Fall down to SW render in case of error*/\n            }\n#elif LV_USE_GPU_STM32_DMA2D\n            if(lv_area_get_size(draw_area) >= 240) {\n                lv_gpu_stm32_dma2d_blend(disp_buf_first, disp_w, map_buf_first, opa, map_w, draw_area_w, draw_area_h);\n                return;\n            }\n#endif\n\n            /*Software rendering*/\n\n            for(y = 0; y < draw_area_h; y++) {\n                for(x = 0; x < draw_area_w; x++) {\n#if LV_COLOR_SCREEN_TRANSP\n                    if(disp->driver->screen_transp) {\n                        lv_color_mix_with_alpha(disp_buf_first[x], disp_buf_first[x].ch.alpha, map_buf_first[x], opa, &disp_buf_first[x],\n                                                &disp_buf_first[x].ch.alpha);\n                    }\n                    else\n#endif\n                    {\n                        disp_buf_first[x] = lv_color_mix(map_buf_first[x], disp_buf_first[x], opa);\n                    }\n                }\n                disp_buf_first += disp_w;\n                map_buf_first += map_w;\n            }\n        }\n    }\n    /*Masked*/\n    else {\n        /*Only the mask matters*/\n        if(opa > LV_OPA_MAX) {\n            /*Go to the first pixel of the row*/\n\n            int32_t x_end4 = draw_area_w - 4;\n\n            for(y = 0; y < draw_area_h; y++) {\n                const lv_opa_t * mask_tmp_x = mask;\n#if 0\n                for(x = 0; x < draw_area_w; x++) {\n                    MAP_NORMAL_MASK_PX(x);\n                }\n#else\n                for(x = 0; x < draw_area_w && ((lv_uintptr_t)mask_tmp_x & 0x3); x++) {\n#if LV_COLOR_SCREEN_TRANSP\n                    MAP_NORMAL_MASK_PX_SCR_TRANSP(x)\n#else\n                    MAP_NORMAL_MASK_PX(x)\n#endif\n                }\n\n                uint32_t * mask32 = (uint32_t *)mask_tmp_x;\n                for(; x < x_end4; x += 4) {\n                    if(*mask32) {\n                        if((*mask32) == 0xFFFFFFFF) {\n                            disp_buf_first[x] = map_buf_first[x];\n                            disp_buf_first[x + 1] = map_buf_first[x + 1];\n                            disp_buf_first[x + 2] = map_buf_first[x + 2];\n                            disp_buf_first[x + 3] = map_buf_first[x + 3];\n                        }\n                        else {\n                            mask_tmp_x = (const lv_opa_t *)mask32;\n#if LV_COLOR_SCREEN_TRANSP\n                            MAP_NORMAL_MASK_PX_SCR_TRANSP(x)\n                            MAP_NORMAL_MASK_PX_SCR_TRANSP(x + 1)\n                            MAP_NORMAL_MASK_PX_SCR_TRANSP(x + 2)\n                            MAP_NORMAL_MASK_PX_SCR_TRANSP(x + 3)\n#else\n                            MAP_NORMAL_MASK_PX(x)\n                            MAP_NORMAL_MASK_PX(x + 1)\n                            MAP_NORMAL_MASK_PX(x + 2)\n                            MAP_NORMAL_MASK_PX(x + 3)\n#endif\n                        }\n                    }\n                    mask32++;\n                }\n\n                mask_tmp_x = (const lv_opa_t *)mask32;\n                for(; x < draw_area_w ; x++) {\n#if LV_COLOR_SCREEN_TRANSP\n                    MAP_NORMAL_MASK_PX_SCR_TRANSP(x)\n#else\n                    MAP_NORMAL_MASK_PX(x)\n#endif\n                }\n#endif\n                disp_buf_first += disp_w;\n                mask += draw_area_w;\n                map_buf_first += map_w;\n            }\n        }\n        /*Handle opa and mask values too*/\n        else {\n            for(y = 0; y < draw_area_h; y++) {\n                for(x = 0; x < draw_area_w; x++) {\n                    if(mask[x]) {\n                        lv_opa_t opa_tmp = mask[x] >= LV_OPA_MAX ? opa : ((opa * mask[x]) >> 8);\n#if LV_COLOR_SCREEN_TRANSP\n                        if(disp->driver->screen_transp) {\n                            lv_color_mix_with_alpha(disp_buf_first[x], disp_buf_first[x].ch.alpha, map_buf_first[x], opa_tmp, &disp_buf_first[x],\n                                                    &disp_buf_first[x].ch.alpha);\n                        }\n                        else\n#endif\n                        {\n                            disp_buf_first[x] = lv_color_mix(map_buf_first[x], disp_buf_first[x], opa_tmp);\n                        }\n                    }\n                }\n                disp_buf_first += disp_w;\n                mask += draw_area_w;\n                map_buf_first += map_w;\n            }\n        }\n    }\n}"}, "map_blended": {"type": "Function", "def": "static void map_blended(const lv_area_t * disp_area, lv_color_t * disp_buf,  const lv_area_t * draw_area,\n                        const lv_area_t * map_area, const lv_color_t * map_buf, lv_opa_t opa,\n                        const lv_opa_t * mask, lv_draw_mask_res_t mask_res, lv_blend_mode_t mode)", "sline": 897, "body": "{\n\n    /*Get the width of the `disp_area` it will be used to go to the next line*/\n    int32_t disp_w = lv_area_get_width(disp_area);\n\n    /*Get the width of the `draw_area` it will be used to go to the next line of the mask*/\n    int32_t draw_area_w = lv_area_get_width(draw_area);\n\n    /*Get the width of the `mask_area` it will be used to go to the next line*/\n    int32_t map_w = lv_area_get_width(map_area);\n\n    /*Create a temp. disp_buf which always point to current line to draw*/\n    lv_color_t * disp_buf_tmp = disp_buf + disp_w * draw_area->y1;\n\n    /*Create a temp. map_buf which always point to current line to draw*/\n    const lv_color_t * map_buf_tmp = map_buf + map_w * (draw_area->y1 - (map_area->y1 - disp_area->y1));\n\n    lv_color_t (*blend_fp)(lv_color_t, lv_color_t, lv_opa_t);\n    switch(mode) {\n        case LV_BLEND_MODE_ADDITIVE:\n            blend_fp = color_blend_true_color_additive;\n            break;\n        case LV_BLEND_MODE_SUBTRACTIVE:\n            blend_fp = color_blend_true_color_subtractive;\n            break;\n        case LV_BLEND_MODE_MULTIPLY:\n            blend_fp = color_blend_true_color_multiply;\n            break;\n        default:\n            LV_LOG_WARN(\"fill_blended: unsupported blend mode\");\n            return;\n    }\n\n    int32_t x;\n    int32_t y;\n\n    /*Simple fill (maybe with opacity), no masking*/\n    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {\n        /*Go to the first px of the row*/\n        map_buf_tmp += (draw_area->x1 - (map_area->x1 - disp_area->x1));\n\n        /*The map will be indexed from `draw_area->x1` so compensate it.*/\n        map_buf_tmp -= draw_area->x1;\n\n        for(y = draw_area->y1; y <= draw_area->y2; y++) {\n            for(x = draw_area->x1; x <= draw_area->x2; x++) {\n                disp_buf_tmp[x] = blend_fp(map_buf_tmp[x], disp_buf_tmp[x], opa);\n            }\n            disp_buf_tmp += disp_w;\n            map_buf_tmp += map_w;\n        }\n    }\n    /*Masked*/\n    else {\n        /*The mask is relative to the clipped area.\n         *In the cycles below mask will be indexed from `draw_area.x1`\n         *but it corresponds to zero index. So prepare `mask_tmp` accordingly.*/\n        const lv_opa_t * mask_tmp = mask - draw_area->x1;\n\n        map_buf_tmp -= draw_area->x1;\n        for(y = draw_area->y1; y <= draw_area->y2; y++) {\n            for(x = draw_area->x1; x <= draw_area->x2; x++) {\n                if(mask_tmp[x] == 0) continue;\n                lv_opa_t opa_tmp = mask_tmp[x] >= LV_OPA_MAX ? opa : ((opa * mask_tmp[x]) >> 8);\n                disp_buf_tmp[x] = blend_fp(map_buf_tmp[x], disp_buf_tmp[x], opa_tmp);\n            }\n            disp_buf_tmp += disp_w;\n            mask_tmp += draw_area_w;\n            map_buf_tmp += map_w;\n        }\n    }\n}"}, "color_blend_true_color_additive": {"type": "Function", "def": "static inline lv_color_t color_blend_true_color_additive(lv_color_t fg, lv_color_t bg, lv_opa_t opa)", "sline": 973, "body": "{\n\n    if(opa <= LV_OPA_MIN) return bg;\n\n    uint32_t tmp;\n#if LV_COLOR_DEPTH == 1\n    tmp = bg.full + fg.full;\n    fg.full = LV_MIN(tmp, 1);\n#else\n    tmp = bg.ch.red + fg.ch.red;\n#if LV_COLOR_DEPTH == 8\n    fg.ch.red = LV_MIN(tmp, 7);\n#elif LV_COLOR_DEPTH == 16\n    fg.ch.red = LV_MIN(tmp, 31);\n#elif LV_COLOR_DEPTH == 32\n    fg.ch.red = LV_MIN(tmp, 255);\n#endif\n\n#if LV_COLOR_DEPTH == 8\n    tmp = bg.ch.green + fg.ch.green;\n    fg.ch.green = LV_MIN(tmp, 7);\n#elif LV_COLOR_DEPTH == 16\n#if LV_COLOR_16_SWAP == 0\n    tmp = bg.ch.green + fg.ch.green;\n    fg.ch.green = LV_MIN(tmp, 63);\n#else\n    tmp = (bg.ch.green_h << 3) + bg.ch.green_l + (fg.ch.green_h << 3) + fg.ch.green_l;\n    tmp = LV_MIN(tmp, 63);\n    fg.ch.green_h = tmp >> 3;\n    fg.ch.green_l = tmp & 0x7;\n#endif\n\n#elif LV_COLOR_DEPTH == 32\n    tmp = bg.ch.green + fg.ch.green;\n    fg.ch.green = LV_MIN(tmp, 255);\n#endif\n\n    tmp = bg.ch.blue + fg.ch.blue;\n#if LV_COLOR_DEPTH == 8\n    fg.ch.blue = LV_MIN(tmp, 4);\n#elif LV_COLOR_DEPTH == 16\n    fg.ch.blue = LV_MIN(tmp, 31);\n#elif LV_COLOR_DEPTH == 32\n    fg.ch.blue = LV_MIN(tmp, 255);\n#endif\n#endif\n\n    if(opa == LV_OPA_COVER) return fg;\n\n    return lv_color_mix(fg, bg, opa);\n}"}, "color_blend_true_color_subtractive": {"type": "Function", "def": "static inline lv_color_t color_blend_true_color_subtractive(lv_color_t fg, lv_color_t bg, lv_opa_t opa)", "sline": 1026, "body": "{\n    if(opa <= LV_OPA_MIN) return bg;\n\n    int32_t tmp;\n    tmp = bg.ch.red - fg.ch.red;\n    fg.ch.red = LV_MAX(tmp, 0);\n\n#if LV_COLOR_16_SWAP == 0\n    tmp = bg.ch.green - fg.ch.green;\n    fg.ch.green = LV_MAX(tmp, 0);\n#else\n    tmp = (bg.ch.green_h << 3) + bg.ch.green_l + (fg.ch.green_h << 3) + fg.ch.green_l;\n    tmp = LV_MAX(tmp, 0);\n    fg.ch.green_h = tmp >> 3;\n    fg.ch.green_l = tmp & 0x7;\n#endif\n\n    tmp = bg.ch.blue - fg.ch.blue;\n    fg.ch.blue = LV_MAX(tmp, 0);\n\n    if(opa == LV_OPA_COVER) return fg;\n\n    return lv_color_mix(fg, bg, opa);\n}"}, "color_blend_true_color_multiply": {"type": "Function", "def": "static inline lv_color_t color_blend_true_color_multiply(lv_color_t fg, lv_color_t bg, lv_opa_t opa)", "sline": 1052, "body": "{\n    if(opa <= LV_OPA_MIN) return bg;\n\n#if LV_COLOR_DEPTH == 32\n    fg.ch.red = (fg.ch.red * bg.ch.red) >> 8;\n    fg.ch.green = (fg.ch.green * bg.ch.green) >> 8;\n    fg.ch.blue = (fg.ch.blue * bg.ch.blue) >> 8;\n#elif LV_COLOR_DEPTH == 16\n    fg.ch.red = (fg.ch.red * bg.ch.red) >> 5;\n    fg.ch.blue = (fg.ch.blue * bg.ch.blue) >> 5;\n    LV_COLOR_SET_G(fg, (LV_COLOR_GET_G(fg) * LV_COLOR_GET_G(bg)) >> 6);\n#elif LV_COLOR_DEPTH == 8\n    fg.ch.red = (fg.ch.red * bg.ch.red) >> 3;\n    fg.ch.green = (fg.ch.green * bg.ch.green) >> 3;\n    fg.ch.blue = (fg.ch.blue * bg.ch.blue) >> 2;\n#endif\n\n    if(opa == LV_OPA_COVER) return fg;\n\n    return lv_color_mix(fg, bg, opa);\n}"}, "_lv_blend_fill": {"type": "Function", "def": "void _lv_blend_fill(const lv_area_t * clip_area, const lv_area_t * fill_area,\n                                          lv_color_t color, lv_opa_t * mask, lv_draw_mask_res_t mask_res, lv_opa_t opa,\n                                          lv_blend_mode_t mode)", "sline": 131, "body": "{\n    /*Do not draw transparent things*/\n    if(opa < LV_OPA_MIN) return;\n    if(mask_res == LV_DRAW_MASK_RES_TRANSP) return;\n\n    lv_disp_t * disp = _lv_refr_get_disp_refreshing();\n    lv_disp_draw_buf_t * draw_buf = lv_disp_get_draw_buf(disp);\n    const lv_area_t * disp_area = &draw_buf->area;\n    lv_color_t * disp_buf = draw_buf->buf_act;\n\n    if(disp->driver->gpu_wait_cb) disp->driver->gpu_wait_cb(disp->driver);\n\n    /*Get clipped fill area which is the real draw area.\n     *It is always the same or inside `fill_area`*/\n    lv_area_t draw_area;\n    if(!_lv_area_intersect(&draw_area, clip_area, fill_area)) return;\n\n    /*Now `draw_area` has absolute coordinates.\n     *Make it relative to `disp_area` to simplify the drawing to `disp_buf`*/\n    lv_area_move(&draw_area, -disp_area->x1, -disp_area->y1);\n\n    /*Round the values in the mask if anti-aliasing is disabled*/\n    if(mask && disp->driver->antialiasing == 0 && mask) {\n        int32_t mask_w = lv_area_get_width(&draw_area);\n        int32_t i;\n        for(i = 0; i < mask_w; i++)  mask[i] = mask[i] > 128 ? LV_OPA_COVER : LV_OPA_TRANSP;\n    }\n\n    if(disp->driver->set_px_cb) {\n        fill_set_px(disp_area, disp_buf, &draw_area, color, opa, mask, mask_res);\n    }\n    else if(mode == LV_BLEND_MODE_NORMAL) {\n        fill_normal(disp_area, disp_buf, &draw_area, color, opa, mask, mask_res);\n    }\n#if LV_DRAW_COMPLEX\n    else {\n        fill_blended(disp_area, disp_buf, &draw_area, color, opa, mask, mask_res, mode);\n    }\n#endif\n}"}, "_lv_blend_map": {"type": "Function", "def": "void _lv_blend_map(const lv_area_t * clip_area, const lv_area_t * map_area,\n                                         const lv_color_t * map_buf,\n                                         lv_opa_t * mask, lv_draw_mask_res_t mask_res,\n                                         lv_opa_t opa, lv_blend_mode_t mode)", "sline": 188, "body": "{\n    /*Do not draw transparent things*/\n    if(opa < LV_OPA_MIN) return;\n    if(mask_res == LV_DRAW_MASK_RES_TRANSP) return;\n\n    /*Get clipped fill area which is the real draw area.\n     *It is always the same or inside `fill_area`*/\n    lv_area_t draw_area;\n    bool is_common;\n    is_common = _lv_area_intersect(&draw_area, clip_area, map_area);\n    if(!is_common) return;\n\n    lv_disp_t * disp = _lv_refr_get_disp_refreshing();\n    lv_disp_draw_buf_t * draw_buf = lv_disp_get_draw_buf(disp);\n    const lv_area_t * disp_area = &draw_buf->area;\n    lv_color_t * disp_buf = draw_buf->buf_act;\n\n    if(disp->driver->gpu_wait_cb) disp->driver->gpu_wait_cb(disp->driver);\n\n    /*Now `draw_area` has absolute coordinates.\n     *Make it relative to `disp_area` to simplify draw to `disp_buf`*/\n    draw_area.x1 -= disp_area->x1;\n    draw_area.y1 -= disp_area->y1;\n    draw_area.x2 -= disp_area->x1;\n    draw_area.y2 -= disp_area->y1;\n\n    /*Round the values in the mask if anti-aliasing is disabled*/\n    if(mask && disp->driver->antialiasing == 0) {\n        int32_t mask_w = lv_area_get_width(&draw_area);\n        int32_t i;\n        for(i = 0; i < mask_w; i++)  mask[i] = mask[i] > 128 ? LV_OPA_COVER : LV_OPA_TRANSP;\n    }\n    if(disp->driver->set_px_cb) {\n        map_set_px(disp_area, disp_buf, &draw_area, map_area, map_buf, opa, mask, mask_res);\n    }\n    else if(mode == LV_BLEND_MODE_NORMAL) {\n        map_normal(disp_area, disp_buf, &draw_area, map_area, map_buf, opa, mask, mask_res);\n    }\n#if LV_DRAW_COMPLEX\n    else {\n        map_blended(disp_area, disp_buf, &draw_area, map_area, map_buf, opa, mask, mask_res, mode);\n    }\n#endif\n}"}, "carbit_updater/lvgl/src/draw/lv_draw_blend.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_draw_blend.c"}}, "carbit_updater/lvgl/src/misc/lv_log.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 17}, "lv_types": {"type": "Variable", "def": "#include lv_types.h", "sline": 19, "include": ["carbit_updater/lvgl/src/misc/lv_types.h", null]}, "_silence_gcc_warning": {"type": "Struct", "def": "LV_EXPORT_CONST_INT(LV_LOG_LEVEL_NONE)", "sline": 40}, "lv_log_level_t": {"type": "Variable", "def": "typedef int8_t lv_log_level_t", "sline": 42}, "carbit_updater/lvgl/src/misc/lv_log.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_log.h"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_12.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "glyph_bitmap": {"type": "Variable", "def": "static LV_ATTRIBUTE_LARGE_CONST const uint8_t glyph_bitmap[] = {\n    /* U+0020 \" \" */\n\n    /* U+0021 \"!\" */\n    0xf, 0x40, 0xf3, 0xf, 0x30, 0xf2, 0xe, 0x20,\n    0xd1, 0x3, 0x0, 0x81, 0x1e, 0x30,\n\n    /* U+0022 \"\\\"\" */\n    0x3c, 0x1e, 0x3b, 0xe, 0x3b, 0xe, 0x15, 0x7,\n\n    /* U+0023 \"#\" */\n    0x0, 0x48, 0x3, 0xa0, 0x0, 0x6, 0x60, 0x58,\n    0x0, 0x4f, 0xff, 0xff, 0xff, 0x10, 0xa, 0x20,\n    0x84, 0x0, 0x0, 0xc1, 0xa, 0x30, 0x0, 0xd,\n    0x0, 0xb1, 0x0, 0xaf, 0xff, 0xff, 0xfb, 0x0,\n    0x1c, 0x0, 0xd0, 0x0, 0x3, 0xa0, 0x1c, 0x0,\n    0x0,\n\n    /* U+0024 \"$\" */\n    0x0, 0x9, 0x20, 0x0, 0x0, 0x92, 0x0, 0x3,\n    0xcf, 0xfb, 0x31, 0xf7, 0xa5, 0x74, 0x4e, 0x9,\n    0x20, 0x1, 0xf9, 0xb2, 0x0, 0x2, 0xbf, 0xe8,\n    0x0, 0x0, 0x97, 0xda, 0x0, 0x9, 0x24, 0xe5,\n    0xb4, 0xa5, 0xba, 0x8, 0xef, 0xfa, 0x10, 0x0,\n    0x92, 0x0, 0x0, 0x4, 0x10, 0x0,\n\n    /* U+0025 \"%\" */\n    0xa, 0xc8, 0x0, 0xc, 0x10, 0x66, 0xa, 0x20,\n    0x76, 0x0, 0x83, 0x7, 0x42, 0xc0, 0x0, 0x57,\n    0xa, 0x2b, 0x20, 0x0, 0x9, 0xc6, 0x68, 0x5c,\n    0x90, 0x0, 0x1, 0xc1, 0xc0, 0x67, 0x0, 0xa,\n    0x43, 0x90, 0x2a, 0x0, 0x49, 0x1, 0xb0, 0x47,\n    0x0, 0xc1, 0x0, 0x7b, 0xb1,\n\n    /* U+0026 \"&\" */\n    0x0, 0x9e, 0xd4, 0x0, 0x0, 0x5c, 0x3, 0xd0,\n    0x0, 0x4, 0xc0, 0x5c, 0x0, 0x0, 0xc, 0xbd,\n    0x20, 0x0, 0x3, 0xde, 0x80, 0x10, 0x1, 0xe3,\n    0x1d, 0x78, 0x80, 0x6b, 0x0, 0x1d, 0xf2, 0x4,\n    0xf4, 0x13, 0xcf, 0x60, 0x6, 0xdf, 0xd6, 0x2b,\n    0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+0027 \"'\" */\n    0x3c, 0x3b, 0x3b, 0x15,\n\n    /* U+0028 \"(\" */\n    0xa, 0x71, 0xf1, 0x5c, 0x9, 0x80, 0xb6, 0xc,\n    0x40, 0xd4, 0xc, 0x40, 0xb6, 0x9, 0x80, 0x5b,\n    0x1, 0xf1, 0xa, 0x70,\n\n    /* U+0029 \")\" */\n    0x6b, 0x0, 0xf2, 0xb, 0x60, 0x7a, 0x5, 0xc0,\n    0x4d, 0x3, 0xe0, 0x4d, 0x5, 0xc0, 0x7a, 0xb,\n    0x60, 0xf1, 0x6b, 0x0,\n\n    /* U+002A \"*\" */\n    0x0, 0xb0, 0x8, 0x9c, 0xb5, 0xb, 0xf8, 0x8,\n    0x7c, 0x95, 0x0, 0xa0, 0x0,\n\n    /* U+002B \"+\" */\n    0x0, 0xb, 0x0, 0x0, 0x0, 0xf0, 0x0, 0x0,\n    0xf, 0x0, 0x2, 0xee, 0xfe, 0xe2, 0x1, 0x1f,\n    0x11, 0x0, 0x0, 0xf0, 0x0,\n\n    /* U+002C \",\" */\n    0x18, 0x4, 0xf1, 0xd, 0x3, 0x80,\n\n    /* U+002D \"-\" */\n    0x4f, 0xfd, 0x2, 0x22,\n\n    /* U+002E \".\" */\n    0x2a, 0x4, 0xd0,\n\n    /* U+002F \"/\" */\n    0x0, 0x0, 0x34, 0x0, 0x0, 0xb5, 0x0, 0x0,\n    0xf0, 0x0, 0x5, 0xb0, 0x0, 0xa, 0x60, 0x0,\n    0xe, 0x10, 0x0, 0x4c, 0x0, 0x0, 0x97, 0x0,\n    0x0, 0xe2, 0x0, 0x3, 0xd0, 0x0, 0x8, 0x70,\n    0x0, 0xd, 0x20, 0x0, 0x2d, 0x0, 0x0,\n\n    /* U+0030 \"0\" */\n    0x0, 0x9e, 0xe9, 0x0, 0xa, 0xd4, 0x4d, 0xa0,\n    0x1f, 0x20, 0x2, 0xf1, 0x5e, 0x0, 0x0, 0xd5,\n    0x6c, 0x0, 0x0, 0xc6, 0x5e, 0x0, 0x0, 0xd5,\n    0x1f, 0x20, 0x2, 0xf1, 0xa, 0xd4, 0x4d, 0xa0,\n    0x0, 0x9e, 0xe9, 0x0,\n\n    /* U+0031 \"1\" */\n    0xef, 0xf3, 0x22, 0xf3, 0x0, 0xf3, 0x0, 0xf3,\n    0x0, 0xf3, 0x0, 0xf3, 0x0, 0xf3, 0x0, 0xf3,\n    0x0, 0xf3,\n\n    /* U+0032 \"2\" */\n    0x19, 0xef, 0xc2, 0x8, 0xb4, 0x3a, 0xe0, 0x0,\n    0x0, 0x2f, 0x10, 0x0, 0x5, 0xe0, 0x0, 0x2,\n    0xe5, 0x0, 0x1, 0xd7, 0x0, 0x1, 0xd8, 0x0,\n    0x1, 0xda, 0x22, 0x21, 0x8f, 0xff, 0xff, 0x70,\n\n    /* U+0033 \"3\" */\n    0x9f, 0xff, 0xff, 0x1, 0x22, 0x2d, 0x80, 0x0,\n    0x9, 0xb0, 0x0, 0x5, 0xf2, 0x0, 0x0, 0x7c,\n    0xf8, 0x0, 0x0, 0x2, 0xf2, 0x0, 0x0, 0xe,\n    0x4b, 0x94, 0x39, 0xf1, 0x3b, 0xff, 0xc3, 0x0,\n\n    /* U+0034 \"4\" */\n    0x0, 0x0, 0x9b, 0x0, 0x0, 0x4, 0xe1, 0x0,\n    0x0, 0x1e, 0x50, 0x0, 0x0, 0xaa, 0x0, 0x0,\n    0x5, 0xe1, 0xd, 0x40, 0x1e, 0x40, 0xd, 0x40,\n    0x8f, 0xff, 0xff, 0xfd, 0x12, 0x22, 0x2e, 0x62,\n    0x0, 0x0, 0xe, 0x40,\n\n    /* U+0035 \"5\" */\n    0xc, 0xff, 0xff, 0x0, 0xe5, 0x22, 0x20, 0xf,\n    0x10, 0x0, 0x1, 0xff, 0xeb, 0x30, 0x2, 0x23,\n    0x9f, 0x10, 0x0, 0x0, 0xd6, 0x0, 0x0, 0xd,\n    0x69, 0xb4, 0x38, 0xf1, 0x2a, 0xef, 0xc4, 0x0,\n\n    /* U+0036 \"6\" */\n    0x0, 0x6d, 0xfd, 0x50, 0x8, 0xd5, 0x23, 0x20,\n    0x1f, 0x20, 0x0, 0x0, 0x4d, 0x6d, 0xea, 0x10,\n    0x6f, 0xc4, 0x3c, 0xa0, 0x5f, 0x30, 0x2, 0xf0,\n    0x2f, 0x20, 0x2, 0xf0, 0xa, 0xc3, 0x2b, 0xa0,\n    0x1, 0xaf, 0xfa, 0x10,\n\n    /* U+0037 \"7\" */\n    0xaf, 0xff, 0xff, 0xba, 0x92, 0x22, 0xd7, 0x76,\n    0x0, 0x3f, 0x10, 0x0, 0xa, 0x90, 0x0, 0x1,\n    0xf2, 0x0, 0x0, 0x7c, 0x0, 0x0, 0xe, 0x50,\n    0x0, 0x5, 0xe0, 0x0, 0x0, 0xc8, 0x0, 0x0,\n\n    /* U+0038 \"8\" */\n    0x3, 0xcf, 0xea, 0x10, 0xe, 0x81, 0x2c, 0xa0,\n    0x2f, 0x10, 0x5, 0xd0, 0xe, 0x70, 0x1b, 0x90,\n    0x6, 0xff, 0xff, 0x20, 0x3f, 0x50, 0x18, 0xe0,\n    0x6c, 0x0, 0x0, 0xf2, 0x3f, 0x61, 0x29, 0xe0,\n    0x5, 0xcf, 0xfb, 0x20,\n\n    /* U+0039 \"9\" */\n    0x7, 0xef, 0xc3, 0x6, 0xe3, 0x15, 0xe1, 0x98,\n    0x0, 0xb, 0x87, 0xd2, 0x3, 0xfb, 0xa, 0xff,\n    0xd9, 0xc0, 0x0, 0x10, 0x8b, 0x0, 0x0, 0xd,\n    0x70, 0x62, 0x4b, 0xd0, 0x1c, 0xfe, 0xa1, 0x0,\n\n    /* U+003A \":\" */\n    0x4e, 0x2, 0xa0, 0x0, 0x0, 0x0, 0x0, 0x2,\n    0xa0, 0x4d, 0x0,\n\n    /* U+003B \";\" */\n    0x4e, 0x2, 0xa0, 0x0, 0x0, 0x0, 0x0, 0x1,\n    0x80, 0x4f, 0x10, 0xd0, 0x38, 0x0,\n\n    /* U+003C \"<\" */\n    0x0, 0x0, 0x2, 0x10, 0x0, 0x4b, 0xe1, 0x7,\n    0xdc, 0x50, 0x3, 0xf8, 0x0, 0x0, 0x4, 0xbe,\n    0x71, 0x0, 0x0, 0x29, 0xe2, 0x0, 0x0, 0x0,\n    0x0,\n\n    /* U+003D \"=\" */\n    0x3f, 0xff, 0xff, 0x30, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x2, 0xee, 0xee, 0xe2, 0x1, 0x11,\n    0x11, 0x0,\n\n    /* U+003E \">\" */\n    0x12, 0x0, 0x0, 0x2, 0xeb, 0x40, 0x0, 0x0,\n    0x5c, 0xd6, 0x0, 0x0, 0x8, 0xf2, 0x1, 0x7e,\n    0xb4, 0x2, 0xe9, 0x20, 0x0, 0x0, 0x0, 0x0,\n    0x0,\n\n    /* U+003F \"?\" */\n    0x1a, 0xef, 0xc3, 0x9, 0xa3, 0x2a, 0xe0, 0x0,\n    0x0, 0x3f, 0x0, 0x0, 0xa, 0xa0, 0x0, 0x9,\n    0xc0, 0x0, 0x2, 0xf1, 0x0, 0x0, 0x1, 0x0,\n    0x0, 0x2, 0x80, 0x0, 0x0, 0x4d, 0x0, 0x0,\n\n    /* U+0040 \"@\" */\n    0x0, 0x4, 0xbd, 0xdd, 0x81, 0x0, 0x0, 0x9b,\n    0x30, 0x0, 0x6d, 0x30, 0x7, 0xa0, 0x8e, 0xe8,\n    0xd5, 0xd1, 0xd, 0x7, 0xd2, 0x19, 0xf3, 0x77,\n    0x4a, 0xd, 0x40, 0x0, 0xf3, 0x1b, 0x58, 0xf,\n    0x20, 0x0, 0xd3, 0xc, 0x58, 0xd, 0x40, 0x0,\n    0xf3, 0x1b, 0x3a, 0x7, 0xd2, 0x1a, 0xf5, 0x77,\n    0xd, 0x0, 0x8e, 0xe8, 0x5f, 0xb0, 0x6, 0xa0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x9b, 0x30, 0x2,\n    0x40, 0x0, 0x0, 0x5, 0xbd, 0xed, 0x60, 0x0,\n\n    /* U+0041 \"A\" */\n    0x0, 0x0, 0x6f, 0x30, 0x0, 0x0, 0x0, 0xdd,\n    0x90, 0x0, 0x0, 0x4, 0xe3, 0xf1, 0x0, 0x0,\n    0xb, 0x80, 0xc7, 0x0, 0x0, 0x1f, 0x20, 0x6e,\n    0x0, 0x0, 0x8c, 0x0, 0x1f, 0x50, 0x0, 0xef,\n    0xee, 0xef, 0xb0, 0x6, 0xe2, 0x11, 0x14, 0xf2,\n    0xc, 0x70, 0x0, 0x0, 0xb9,\n\n    /* U+0042 \"B\" */\n    0xbf, 0xff, 0xfb, 0x20, 0xb7, 0x11, 0x2a, 0xd0,\n    0xb7, 0x0, 0x3, 0xf0, 0xb7, 0x0, 0x8, 0xc0,\n    0xbf, 0xff, 0xff, 0x50, 0xb8, 0x22, 0x26, 0xf2,\n    0xb7, 0x0, 0x0, 0xc7, 0xb7, 0x11, 0x15, 0xf4,\n    0xbf, 0xff, 0xfd, 0x60,\n\n    /* U+0043 \"C\" */\n    0x0, 0x3b, 0xef, 0xb3, 0x0, 0x5f, 0x93, 0x38,\n    0xe0, 0xe, 0x60, 0x0, 0x0, 0x4, 0xe0, 0x0,\n    0x0, 0x0, 0x6c, 0x0, 0x0, 0x0, 0x4, 0xe0,\n    0x0, 0x0, 0x0, 0xe, 0x60, 0x0, 0x0, 0x0,\n    0x5f, 0x93, 0x38, 0xe0, 0x0, 0x3b, 0xff, 0xb3,\n    0x0,\n\n    /* U+0044 \"D\" */\n    0xbf, 0xff, 0xea, 0x30, 0xb, 0x82, 0x23, 0x9f,\n    0x40, 0xb7, 0x0, 0x0, 0x7e, 0xb, 0x70, 0x0,\n    0x0, 0xf3, 0xb7, 0x0, 0x0, 0xe, 0x5b, 0x70,\n    0x0, 0x0, 0xf3, 0xb7, 0x0, 0x0, 0x7e, 0xb,\n    0x82, 0x23, 0x9f, 0x40, 0xbf, 0xff, 0xeb, 0x30,\n    0x0,\n\n    /* U+0045 \"E\" */\n    0xbf, 0xff, 0xff, 0x3b, 0x82, 0x22, 0x20, 0xb7,\n    0x0, 0x0, 0xb, 0x70, 0x0, 0x0, 0xbf, 0xff,\n    0xfa, 0xb, 0x82, 0x22, 0x10, 0xb7, 0x0, 0x0,\n    0xb, 0x82, 0x22, 0x20, 0xbf, 0xff, 0xff, 0x50,\n\n    /* U+0046 \"F\" */\n    0xbf, 0xff, 0xff, 0x3b, 0x82, 0x22, 0x20, 0xb7,\n    0x0, 0x0, 0xb, 0x70, 0x0, 0x0, 0xbf, 0xff,\n    0xfa, 0xb, 0x82, 0x22, 0x10, 0xb7, 0x0, 0x0,\n    0xb, 0x70, 0x0, 0x0, 0xb7, 0x0, 0x0, 0x0,\n\n    /* U+0047 \"G\" */\n    0x0, 0x3b, 0xef, 0xc4, 0x0, 0x5f, 0x94, 0x38,\n    0xe1, 0xe, 0x70, 0x0, 0x0, 0x4, 0xe0, 0x0,\n    0x0, 0x0, 0x6c, 0x0, 0x0, 0x8, 0x24, 0xe0,\n    0x0, 0x0, 0xe3, 0xe, 0x60, 0x0, 0xe, 0x30,\n    0x5f, 0x93, 0x37, 0xf3, 0x0, 0x3b, 0xef, 0xc4,\n    0x0,\n\n    /* U+0048 \"H\" */\n    0xb7, 0x0, 0x0, 0xb7, 0xb7, 0x0, 0x0, 0xb7,\n    0xb7, 0x0, 0x0, 0xb7, 0xb7, 0x0, 0x0, 0xb7,\n    0xbf, 0xff, 0xff, 0xf7, 0xb8, 0x22, 0x22, 0xc7,\n    0xb7, 0x0, 0x0, 0xb7, 0xb7, 0x0, 0x0, 0xb7,\n    0xb7, 0x0, 0x0, 0xb7,\n\n    /* U+0049 \"I\" */\n    0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7,\n    0xb7,\n\n    /* U+004A \"J\" */\n    0x4, 0xff, 0xff, 0x0, 0x22, 0x5f, 0x0, 0x0,\n    0x3f, 0x0, 0x0, 0x3f, 0x0, 0x0, 0x3f, 0x0,\n    0x0, 0x3f, 0x0, 0x0, 0x4e, 0xd, 0x52, 0xba,\n    0x5, 0xdf, 0xb2,\n\n    /* U+004B \"K\" */\n    0xb7, 0x0, 0x7, 0xd1, 0xb7, 0x0, 0x5e, 0x20,\n    0xb7, 0x4, 0xe3, 0x0, 0xb7, 0x3e, 0x40, 0x0,\n    0xb9, 0xef, 0x20, 0x0, 0xbf, 0x89, 0xd0, 0x0,\n    0xba, 0x0, 0xca, 0x0, 0xb7, 0x0, 0x1e, 0x70,\n    0xb7, 0x0, 0x3, 0xf3,\n\n    /* U+004C \"L\" */\n    0xb7, 0x0, 0x0, 0xb, 0x70, 0x0, 0x0, 0xb7,\n    0x0, 0x0, 0xb, 0x70, 0x0, 0x0, 0xb7, 0x0,\n    0x0, 0xb, 0x70, 0x0, 0x0, 0xb7, 0x0, 0x0,\n    0xb, 0x82, 0x22, 0x20, 0xbf, 0xff, 0xff, 0x0,\n\n    /* U+004D \"M\" */\n    0xb8, 0x0, 0x0, 0x1, 0xf3, 0xbf, 0x10, 0x0,\n    0x9, 0xf3, 0xbe, 0xa0, 0x0, 0x2e, 0xf3, 0xb7,\n    0xe3, 0x0, 0xb7, 0xf3, 0xb6, 0x7b, 0x4, 0xd0,\n    0xf3, 0xb6, 0xd, 0x4c, 0x50, 0xf3, 0xb6, 0x5,\n    0xfc, 0x0, 0xf3, 0xb6, 0x0, 0xb3, 0x0, 0xf3,\n    0xb6, 0x0, 0x0, 0x0, 0xf3,\n\n    /* U+004E \"N\" */\n    0xb9, 0x0, 0x0, 0xb7, 0xbf, 0x50, 0x0, 0xb7,\n    0xbc, 0xf2, 0x0, 0xb7, 0xb7, 0xad, 0x0, 0xb7,\n    0xb7, 0xd, 0x90, 0xb7, 0xb7, 0x2, 0xf5, 0xb7,\n    0xb7, 0x0, 0x6f, 0xd7, 0xb7, 0x0, 0xa, 0xf7,\n    0xb7, 0x0, 0x0, 0xd7,\n\n    /* U+004F \"O\" */\n    0x0, 0x3b, 0xef, 0xb4, 0x0, 0x5, 0xf9, 0x33,\n    0x8f, 0x60, 0xe, 0x60, 0x0, 0x5, 0xf1, 0x4e,\n    0x0, 0x0, 0x0, 0xd5, 0x6c, 0x0, 0x0, 0x0,\n    0xb7, 0x4e, 0x0, 0x0, 0x0, 0xd5, 0xe, 0x60,\n    0x0, 0x5, 0xf1, 0x5, 0xf9, 0x33, 0x8f, 0x60,\n    0x0, 0x3b, 0xef, 0xb4, 0x0,\n\n    /* U+0050 \"P\" */\n    0xbf, 0xff, 0xd8, 0x0, 0xb8, 0x22, 0x5d, 0x90,\n    0xb7, 0x0, 0x4, 0xe0, 0xb7, 0x0, 0x3, 0xf0,\n    0xb7, 0x0, 0x2c, 0xa0, 0xbf, 0xff, 0xfa, 0x10,\n    0xb8, 0x22, 0x0, 0x0, 0xb7, 0x0, 0x0, 0x0,\n    0xb7, 0x0, 0x0, 0x0,\n\n    /* U+0051 \"Q\" */\n    0x0, 0x3b, 0xef, 0xb4, 0x0, 0x4, 0xf9, 0x33,\n    0x8f, 0x60, 0xe, 0x60, 0x0, 0x5, 0xf1, 0x4e,\n    0x0, 0x0, 0x0, 0xd5, 0x6c, 0x0, 0x0, 0x0,\n    0xb7, 0x4e, 0x0, 0x0, 0x0, 0xd6, 0xf, 0x60,\n    0x0, 0x5, 0xf1, 0x5, 0xf8, 0x32, 0x7f, 0x60,\n    0x0, 0x4c, 0xff, 0xc5, 0x0, 0x0, 0x0, 0xc,\n    0xb0, 0x28, 0x0, 0x0, 0x1, 0xbf, 0xe5, 0x0,\n    0x0, 0x0, 0x0, 0x0,\n\n    /* U+0052 \"R\" */\n    0xbf, 0xff, 0xd8, 0x0, 0xb8, 0x22, 0x5d, 0x90,\n    0xb7, 0x0, 0x4, 0xe0, 0xb7, 0x0, 0x3, 0xf0,\n    0xb7, 0x0, 0x1b, 0xb0, 0xbf, 0xff, 0xfb, 0x10,\n    0xb8, 0x22, 0xb9, 0x0, 0xb7, 0x0, 0x1f, 0x30,\n    0xb7, 0x0, 0x7, 0xd0,\n\n    /* U+0053 \"S\" */\n    0x3, 0xcf, 0xeb, 0x31, 0xf7, 0x23, 0x74, 0x4e,\n    0x0, 0x0, 0x1, 0xf9, 0x20, 0x0, 0x2, 0xbf,\n    0xd7, 0x0, 0x0, 0x4, 0xca, 0x0, 0x0, 0x4,\n    0xe5, 0xb4, 0x23, 0xbb, 0x8, 0xdf, 0xea, 0x10,\n\n    /* U+0054 \"T\" */\n    0xff, 0xff, 0xff, 0xf2, 0x23, 0xf3, 0x22, 0x0,\n    0x1f, 0x10, 0x0, 0x1, 0xf1, 0x0, 0x0, 0x1f,\n    0x10, 0x0, 0x1, 0xf1, 0x0, 0x0, 0x1f, 0x10,\n    0x0, 0x1, 0xf1, 0x0, 0x0, 0x1f, 0x10, 0x0,\n\n    /* U+0055 \"U\" */\n    0xd6, 0x0, 0x0, 0xe4, 0xd6, 0x0, 0x0, 0xe4,\n    0xd6, 0x0, 0x0, 0xe4, 0xd6, 0x0, 0x0, 0xe4,\n    0xd6, 0x0, 0x0, 0xe4, 0xc7, 0x0, 0x0, 0xf3,\n    0x9a, 0x0, 0x2, 0xf1, 0x2f, 0x83, 0x5d, 0xa0,\n    0x4, 0xcf, 0xd8, 0x0,\n\n    /* U+0056 \"V\" */\n    0xc, 0x70, 0x0, 0x0, 0xd5, 0x6, 0xe0, 0x0,\n    0x4, 0xe0, 0x0, 0xf4, 0x0, 0xa, 0x80, 0x0,\n    0x9b, 0x0, 0x1f, 0x20, 0x0, 0x2f, 0x20, 0x7b,\n    0x0, 0x0, 0xc, 0x80, 0xe4, 0x0, 0x0, 0x5,\n    0xe5, 0xe0, 0x0, 0x0, 0x0, 0xee, 0x70, 0x0,\n    0x0, 0x0, 0x8f, 0x10, 0x0,\n\n    /* U+0057 \"W\" */\n    0x7c, 0x0, 0x0, 0xe8, 0x0, 0x2, 0xf0, 0x2f,\n    0x10, 0x3, 0xfd, 0x0, 0x7, 0xa0, 0xd, 0x60,\n    0x8, 0x9f, 0x20, 0xc, 0x50, 0x8, 0xb0, 0xe,\n    0x3b, 0x70, 0x1f, 0x0, 0x3, 0xf0, 0x3e, 0x6,\n    0xc0, 0x6b, 0x0, 0x0, 0xe5, 0x89, 0x1, 0xf1,\n    0xb6, 0x0, 0x0, 0x9a, 0xd4, 0x0, 0xb7, 0xf1,\n    0x0, 0x0, 0x4f, 0xe0, 0x0, 0x6f, 0xc0, 0x0,\n    0x0, 0xf, 0xa0, 0x0, 0x1f, 0x70, 0x0,\n\n    /* U+0058 \"X\" */\n    0x5f, 0x10, 0x0, 0xe5, 0xa, 0xb0, 0x9, 0xa0,\n    0x1, 0xe6, 0x4e, 0x10, 0x0, 0x4f, 0xe4, 0x0,\n    0x0, 0xd, 0xe0, 0x0, 0x0, 0x7d, 0xd8, 0x0,\n    0x2, 0xf3, 0x2f, 0x30, 0xc, 0x80, 0x7, 0xd0,\n    0x8d, 0x0, 0x0, 0xc9,\n\n    /* U+0059 \"Y\" */\n    0xc, 0x80, 0x0, 0xa, 0x80, 0x3f, 0x10, 0x3,\n    0xe0, 0x0, 0xaa, 0x0, 0xc6, 0x0, 0x1, 0xf3,\n    0x5d, 0x0, 0x0, 0x7, 0xce, 0x40, 0x0, 0x0,\n    0xe, 0xb0, 0x0, 0x0, 0x0, 0xb7, 0x0, 0x0,\n    0x0, 0xb, 0x70, 0x0, 0x0, 0x0, 0xb7, 0x0,\n    0x0,\n\n    /* U+005A \"Z\" */\n    0x6f, 0xff, 0xff, 0xf5, 0x2, 0x22, 0x29, 0xd0,\n    0x0, 0x0, 0x3f, 0x30, 0x0, 0x1, 0xe6, 0x0,\n    0x0, 0xb, 0xa0, 0x0, 0x0, 0x8d, 0x0, 0x0,\n    0x4, 0xf2, 0x0, 0x0, 0x1e, 0x82, 0x22, 0x21,\n    0x7f, 0xff, 0xff, 0xf8,\n\n    /* U+005B \"[\" */\n    0xbf, 0xcb, 0x60, 0xb6, 0xb, 0x60, 0xb6, 0xb,\n    0x60, 0xb6, 0xb, 0x60, 0xb6, 0xb, 0x60, 0xb6,\n    0xb, 0x60, 0xbf, 0xc0,\n\n    /* U+005C \"\\\\\" */\n    0x35, 0x0, 0x0, 0x2e, 0x0, 0x0, 0xd, 0x30,\n    0x0, 0x8, 0x80, 0x0, 0x3, 0xd0, 0x0, 0x0,\n    0xd2, 0x0, 0x0, 0x87, 0x0, 0x0, 0x3c, 0x0,\n    0x0, 0xe, 0x10, 0x0, 0x9, 0x70, 0x0, 0x4,\n    0xc0, 0x0, 0x0, 0xe1, 0x0, 0x0, 0xa6,\n\n    /* U+005D \"]\" */\n    0xcf, 0xb0, 0x7b, 0x6, 0xb0, 0x6b, 0x6, 0xb0,\n    0x6b, 0x6, 0xb0, 0x6b, 0x6, 0xb0, 0x6b, 0x6,\n    0xb0, 0x7b, 0xcf, 0xb0,\n\n    /* U+005E \"^\" */\n    0x0, 0x7, 0x0, 0x0, 0x5, 0xe5, 0x0, 0x0,\n    0xb4, 0xb0, 0x0, 0x2c, 0xc, 0x20, 0x8, 0x60,\n    0x68, 0x0, 0xd0, 0x0, 0xd0,\n\n    /* U+005F \"_\" */\n    0xdd, 0xdd, 0xdd,\n\n    /* U+0060 \"`\" */\n    0x27, 0x10, 0x5, 0xc1,\n\n    /* U+0061 \"a\" */\n    0x8, 0xdf, 0xc3, 0x0, 0xa4, 0x29, 0xd0, 0x0,\n    0x0, 0x1f, 0x10, 0x8d, 0xee, 0xf2, 0x4e, 0x10,\n    0xf, 0x24, 0xe0, 0x7, 0xf2, 0x9, 0xed, 0x8f,\n    0x20,\n\n    /* U+0062 \"b\" */\n    0xe4, 0x0, 0x0, 0xe, 0x40, 0x0, 0x0, 0xe4,\n    0x0, 0x0, 0xe, 0x7c, 0xfc, 0x40, 0xef, 0x52,\n    0x8f, 0x2e, 0x60, 0x0, 0xb8, 0xe4, 0x0, 0x8,\n    0xae, 0x60, 0x0, 0xb8, 0xef, 0x52, 0x8f, 0x2e,\n    0x6d, 0xfc, 0x40,\n\n    /* U+0063 \"c\" */\n    0x2, 0xbf, 0xe8, 0x0, 0xda, 0x24, 0xc3, 0x5d,\n    0x0, 0x0, 0x7, 0xb0, 0x0, 0x0, 0x5d, 0x0,\n    0x0, 0x0, 0xda, 0x24, 0xd3, 0x2, 0xbf, 0xe8,\n    0x0,\n\n    /* U+0064 \"d\" */\n    0x0, 0x0, 0x1, 0xf1, 0x0, 0x0, 0x1, 0xf1,\n    0x0, 0x0, 0x1, 0xf1, 0x2, 0xbf, 0xd6, 0xf1,\n    0xe, 0x92, 0x3d, 0xf1, 0x5d, 0x0, 0x4, 0xf1,\n    0x7b, 0x0, 0x1, 0xf1, 0x5d, 0x0, 0x3, 0xf1,\n    0xe, 0x91, 0x2d, 0xf1, 0x2, 0xbf, 0xe6, 0xf1,\n\n    /* U+0065 \"e\" */\n    0x2, 0xbf, 0xd5, 0x0, 0xe8, 0x14, 0xe4, 0x5c,\n    0x0, 0x6, 0xb7, 0xfe, 0xee, 0xec, 0x5d, 0x0,\n    0x0, 0x0, 0xe9, 0x23, 0xa2, 0x2, 0xbf, 0xe9,\n    0x0,\n\n    /* U+0066 \"f\" */\n    0x1, 0xcf, 0x60, 0x9a, 0x11, 0xb, 0x60, 0xd,\n    0xff, 0xf3, 0xb, 0x60, 0x0, 0xb6, 0x0, 0xb,\n    0x60, 0x0, 0xb6, 0x0, 0xb, 0x60, 0x0, 0xb6,\n    0x0,\n\n    /* U+0067 \"g\" */\n    0x2, 0xbf, 0xe6, 0xe2, 0xe, 0xa2, 0x3c, 0xf2,\n    0x5d, 0x0, 0x2, 0xf2, 0x7b, 0x0, 0x0, 0xf2,\n    0x5d, 0x0, 0x2, 0xf2, 0xe, 0xa2, 0x3d, 0xf2,\n    0x2, 0xbf, 0xe5, 0xf2, 0x0, 0x0, 0x2, 0xf0,\n    0xc, 0x62, 0x3b, 0xa0, 0x6, 0xdf, 0xea, 0x10,\n\n    /* U+0068 \"h\" */\n    0xe4, 0x0, 0x0, 0xe, 0x40, 0x0, 0x0, 0xe4,\n    0x0, 0x0, 0xe, 0x7d, 0xfc, 0x20, 0xee, 0x42,\n    0xac, 0xe, 0x60, 0x2, 0xf0, 0xe4, 0x0, 0xf,\n    0x1e, 0x40, 0x0, 0xf2, 0xe4, 0x0, 0xf, 0x2e,\n    0x40, 0x0, 0xf2,\n\n    /* U+0069 \"i\" */\n    0xd, 0x40, 0x82, 0x0, 0x0, 0xe4, 0xe, 0x40,\n    0xe4, 0xe, 0x40, 0xe4, 0xe, 0x40, 0xe4,\n\n    /* U+006A \"j\" */\n    0x0, 0xd, 0x50, 0x0, 0x72, 0x0, 0x0, 0x0,\n    0x0, 0xd4, 0x0, 0xd, 0x40, 0x0, 0xd4, 0x0,\n    0xd, 0x40, 0x0, 0xd4, 0x0, 0xd, 0x40, 0x0,\n    0xd4, 0x0, 0xd, 0x40, 0x22, 0xf2, 0xd, 0xf8,\n    0x0,\n\n    /* U+006B \"k\" */\n    0xe4, 0x0, 0x0, 0xe, 0x40, 0x0, 0x0, 0xe4,\n    0x0, 0x0, 0xe, 0x40, 0xb, 0xa0, 0xe4, 0xb,\n    0xb0, 0xe, 0x4b, 0xc0, 0x0, 0xee, 0xfd, 0x0,\n    0xe, 0xc1, 0xd9, 0x0, 0xe4, 0x2, 0xf4, 0xe,\n    0x40, 0x6, 0xe1,\n\n    /* U+006C \"l\" */\n    0xe4, 0xe4, 0xe4, 0xe4, 0xe4, 0xe4, 0xe4, 0xe4,\n    0xe4, 0xe4,\n\n    /* U+006D \"m\" */\n    0xe7, 0xdf, 0xb2, 0x9e, 0xe8, 0xe, 0xd3, 0x2c,\n    0xfb, 0x23, 0xe5, 0xe6, 0x0, 0x4f, 0x10, 0x9,\n    0x9e, 0x40, 0x3, 0xf0, 0x0, 0x8a, 0xe4, 0x0,\n    0x3f, 0x0, 0x8, 0xae, 0x40, 0x3, 0xf0, 0x0,\n    0x8a, 0xe4, 0x0, 0x3f, 0x0, 0x8, 0xa0,\n\n    /* U+006E \"n\" */\n    0xe6, 0xdf, 0xc2, 0xe, 0xe4, 0x1a, 0xc0, 0xe6,\n    0x0, 0x1f, 0xe, 0x40, 0x0, 0xf1, 0xe4, 0x0,\n    0xf, 0x2e, 0x40, 0x0, 0xf2, 0xe4, 0x0, 0xf,\n    0x20,\n\n    /* U+006F \"o\" */\n    0x2, 0xbf, 0xe8, 0x0, 0xe, 0xa2, 0x3e, 0x80,\n    0x5d, 0x0, 0x4, 0xf0, 0x7b, 0x0, 0x1, 0xf1,\n    0x5d, 0x0, 0x4, 0xf0, 0xd, 0xa2, 0x3e, 0x80,\n    0x2, 0xbf, 0xe8, 0x0,\n\n    /* U+0070 \"p\" */\n    0xe7, 0xdf, 0xc4, 0xe, 0xf4, 0x16, 0xf2, 0xe6,\n    0x0, 0xa, 0x8e, 0x40, 0x0, 0x8a, 0xe7, 0x0,\n    0xb, 0x8e, 0xf5, 0x28, 0xf2, 0xe6, 0xcf, 0xc4,\n    0xe, 0x40, 0x0, 0x0, 0xe4, 0x0, 0x0, 0xe,\n    0x40, 0x0, 0x0,\n\n    /* U+0071 \"q\" */\n    0x2, 0xbf, 0xd5, 0xf1, 0xe, 0xa2, 0x3e, 0xf1,\n    0x5d, 0x0, 0x4, 0xf1, 0x7b, 0x0, 0x1, 0xf1,\n    0x5d, 0x0, 0x4, 0xf1, 0xe, 0xa2, 0x3e, 0xf1,\n    0x2, 0xbf, 0xd5, 0xf1, 0x0, 0x0, 0x1, 0xf1,\n    0x0, 0x0, 0x1, 0xf1, 0x0, 0x0, 0x1, 0xf1,\n\n    /* U+0072 \"r\" */\n    0xe6, 0xd8, 0xee, 0x61, 0xe7, 0x0, 0xe4, 0x0,\n    0xe4, 0x0, 0xe4, 0x0, 0xe4, 0x0,\n\n    /* U+0073 \"s\" */\n    0x9, 0xef, 0xc2, 0x6d, 0x22, 0x61, 0x7d, 0x20,\n    0x0, 0x9, 0xfe, 0x91, 0x0, 0x2, 0xc9, 0x56,\n    0x22, 0xb8, 0x4c, 0xfe, 0xa0,\n\n    /* U+0074 \"t\" */\n    0x5, 0x30, 0x0, 0xb6, 0x0, 0xdf, 0xff, 0x30,\n    0xb6, 0x0, 0xb, 0x60, 0x0, 0xb6, 0x0, 0xb,\n    0x60, 0x0, 0xaa, 0x11, 0x2, 0xdf, 0x60,\n\n    /* U+0075 \"u\" */\n    0xf3, 0x0, 0x2f, 0xf, 0x30, 0x2, 0xf0, 0xf3,\n    0x0, 0x2f, 0xf, 0x30, 0x2, 0xf0, 0xe4, 0x0,\n    0x4f, 0xa, 0xb2, 0x2c, 0xf0, 0x1b, 0xfe, 0x6f,\n    0x0,\n\n    /* U+0076 \"v\" */\n    0xd, 0x50, 0x0, 0x98, 0x6, 0xc0, 0x0, 0xf2,\n    0x1, 0xf2, 0x6, 0xb0, 0x0, 0xa8, 0xc, 0x50,\n    0x0, 0x3e, 0x3e, 0x0, 0x0, 0xd, 0xd8, 0x0,\n    0x0, 0x6, 0xf2, 0x0,\n\n    /* U+0077 \"w\" */\n    0xc5, 0x0, 0x3f, 0x10, 0x7, 0x86, 0xa0, 0x9,\n    0xf6, 0x0, 0xd3, 0x1f, 0x0, 0xe7, 0xb0, 0x2d,\n    0x0, 0xb5, 0x4c, 0xe, 0x18, 0x80, 0x6, 0xa9,\n    0x60, 0xa6, 0xd3, 0x0, 0x1f, 0xe1, 0x4, 0xed,\n    0x0, 0x0, 0xbb, 0x0, 0xe, 0x80, 0x0,\n\n    /* U+0078 \"x\" */\n    0x5d, 0x0, 0x4e, 0x10, 0xa9, 0x1e, 0x40, 0x1,\n    0xed, 0x90, 0x0, 0x8, 0xf1, 0x0, 0x2, 0xeb,\n    0xa0, 0x0, 0xc7, 0xd, 0x60, 0x7c, 0x0, 0x3f,\n    0x20,\n\n    /* U+0079 \"y\" */\n    0xd, 0x50, 0x0, 0x98, 0x7, 0xb0, 0x0, 0xe2,\n    0x1, 0xf2, 0x5, 0xc0, 0x0, 0xa7, 0xb, 0x50,\n    0x0, 0x4d, 0x1e, 0x0, 0x0, 0xe, 0xb9, 0x0,\n    0x0, 0x8, 0xf3, 0x0, 0x0, 0x5, 0xd0, 0x0,\n    0x5, 0x2c, 0x60, 0x0, 0x1c, 0xf9, 0x0, 0x0,\n\n    /* U+007A \"z\" */\n    0x7f, 0xff, 0xfb, 0x0, 0x2, 0xf3, 0x0, 0xc,\n    0x70, 0x0, 0x9b, 0x0, 0x4, 0xe1, 0x0, 0x1e,\n    0x50, 0x0, 0x8f, 0xff, 0xfd,\n\n    /* U+007B \"{\" */\n    0x0, 0xbf, 0x4, 0xe1, 0x5, 0xc0, 0x5, 0xc0,\n    0x5, 0xc0, 0x6, 0xc0, 0x4f, 0x60, 0x8, 0xc0,\n    0x5, 0xc0, 0x5, 0xc0, 0x5, 0xc0, 0x4, 0xe1,\n    0x0, 0xbf,\n\n    /* U+007C \"|\" */\n    0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5,\n    0xb5, 0xb5, 0xb5, 0xb5, 0xb5,\n\n    /* U+007D \"}\" */\n    0xcd, 0x10, 0xc, 0x70, 0x9, 0x90, 0x9, 0x90,\n    0x9, 0x90, 0x8, 0xa0, 0x3, 0xf7, 0x8, 0xb0,\n    0x9, 0x90, 0x9, 0x90, 0x9, 0x90, 0xc, 0x80,\n    0xcd, 0x20,\n\n    /* U+007E \"~\" */\n    0xb, 0xe8, 0xa, 0x33, 0x91, 0x8d, 0xa0,\n\n    /* U+00B0 \"\u00b0\" */\n    0x6, 0xb7, 0x3, 0x80, 0x84, 0x64, 0x3, 0x73,\n    0x80, 0x84, 0x6, 0xb7, 0x0,\n\n    /* U+2022 \"\u2022\" */\n    0x4, 0x22, 0xfe, 0xd, 0xa0,\n\n    /* U+F001 \"\uf001\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x12, 0x0, 0x0,\n    0x0, 0x3, 0x7c, 0xff, 0x0, 0x0, 0x59, 0xef,\n    0xff, 0xff, 0x0, 0xe, 0xff, 0xff, 0xff, 0xff,\n    0x0, 0xf, 0xff, 0xfd, 0x84, 0x8f, 0x0, 0xf,\n    0xd7, 0x20, 0x0, 0x8f, 0x0, 0xf, 0x80, 0x0,\n    0x0, 0x8f, 0x0, 0xf, 0x80, 0x0, 0x0, 0x8f,\n    0x0, 0xf, 0x80, 0x0, 0x7b, 0xdf, 0x2, 0x3f,\n    0x80, 0x6, 0xff, 0xff, 0xaf, 0xff, 0x80, 0x2,\n    0xef, 0xf9, 0xef, 0xff, 0x60, 0x0, 0x2, 0x10,\n    0x29, 0xa7, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+F008 \"\uf008\" */\n    0xb4, 0xdf, 0xff, 0xff, 0xfd, 0x4b, 0xe8, 0xe7,\n    0x22, 0x22, 0x7e, 0x8e, 0xc0, 0xc5, 0x0, 0x0,\n    0x6c, 0xc, 0xfc, 0xf6, 0x11, 0x11, 0x7f, 0xcf,\n    0xc0, 0xcf, 0xff, 0xff, 0xfb, 0xc, 0xfc, 0xf6,\n    0x11, 0x11, 0x7f, 0xcf, 0xc0, 0xc5, 0x0, 0x0,\n    0x6c, 0xc, 0xe8, 0xe7, 0x22, 0x22, 0x7e, 0x8e,\n    0xb4, 0xdf, 0xff, 0xff, 0xfd, 0x4b,\n\n    /* U+F00B \"\uf00b\" */\n    0xdf, 0xf6, 0x9f, 0xff, 0xff, 0xfd, 0xff, 0xf8,\n    0xcf, 0xff, 0xff, 0xff, 0xef, 0xf6, 0xaf, 0xff,\n    0xff, 0xfe, 0x13, 0x20, 0x3, 0x33, 0x33, 0x31,\n    0xff, 0xf7, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xf8,\n    0xcf, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xbf, 0xff,\n    0xff, 0xff, 0x13, 0x20, 0x3, 0x33, 0x33, 0x31,\n    0xef, 0xf6, 0xaf, 0xff, 0xff, 0xfe, 0xff, 0xf8,\n    0xcf, 0xff, 0xff, 0xff, 0xdf, 0xf6, 0xaf, 0xff,\n    0xff, 0xfd,\n\n    /* U+F00C \"\uf00c\" */\n    0x0, 0x0, 0x0, 0x0, 0x3, 0xd4, 0x0, 0x0,\n    0x0, 0x0, 0x3f, 0xfe, 0x0, 0x0, 0x0, 0x3,\n    0xff, 0xf4, 0x4d, 0x30, 0x0, 0x3f, 0xff, 0x40,\n    0xef, 0xf3, 0x3, 0xff, 0xf4, 0x0, 0x4f, 0xff,\n    0x6f, 0xff, 0x40, 0x0, 0x4, 0xff, 0xff, 0xf4,\n    0x0, 0x0, 0x0, 0x4f, 0xff, 0x40, 0x0, 0x0,\n    0x0, 0x3, 0xd3, 0x0, 0x0, 0x0,\n\n    /* U+F00D \"\uf00d\" */\n    0x14, 0x0, 0x0, 0x22, 0xd, 0xf7, 0x0, 0x4f,\n    0xf1, 0x9f, 0xf7, 0x4f, 0xfd, 0x0, 0xaf, 0xff,\n    0xfd, 0x10, 0x0, 0xbf, 0xfe, 0x10, 0x0, 0x4f,\n    0xff, 0xf7, 0x0, 0x4f, 0xfd, 0xaf, 0xf7, 0xe,\n    0xfd, 0x10, 0xaf, 0xf2, 0x5b, 0x10, 0x0, 0x99,\n    0x0,\n\n    /* U+F011 \"\uf011\" */\n    0x0, 0x0, 0x7, 0x70, 0x0, 0x0, 0x0, 0x32,\n    0xf, 0xf0, 0x24, 0x0, 0x5, 0xfc, 0xf, 0xf0,\n    0xcf, 0x50, 0x1f, 0xf4, 0xf, 0xf0, 0x5f, 0xf1,\n    0x7f, 0x80, 0xf, 0xf0, 0x8, 0xf7, 0xbf, 0x20,\n    0xf, 0xf0, 0x2, 0xfb, 0xcf, 0x10, 0xe, 0xe0,\n    0x1, 0xfc, 0xaf, 0x40, 0x1, 0x10, 0x4, 0xfa,\n    0x5f, 0xb0, 0x0, 0x0, 0xb, 0xf6, 0xd, 0xfa,\n    0x10, 0x1, 0xaf, 0xd0, 0x2, 0xdf, 0xfc, 0xcf,\n    0xfd, 0x20, 0x0, 0x8, 0xef, 0xfe, 0x91, 0x0,\n    0x0, 0x0, 0x1, 0x10, 0x0, 0x0,\n\n    /* U+F013 \"\uf013\" */\n    0x0, 0x0, 0x14, 0x41, 0x0, 0x0, 0x0, 0x0,\n    0x7f, 0xf7, 0x0, 0x0, 0x3, 0x43, 0xdf, 0xfd,\n    0x34, 0x30, 0xe, 0xff, 0xff, 0xff, 0xff, 0xe0,\n    0x6f, 0xff, 0xfb, 0xbf, 0xff, 0xf6, 0x1b, 0xff,\n    0x70, 0x7, 0xff, 0xb1, 0x7, 0xff, 0x20, 0x2,\n    0xff, 0x70, 0x1b, 0xff, 0x70, 0x7, 0xff, 0xb1,\n    0x6f, 0xff, 0xfb, 0xbf, 0xff, 0xf6, 0xe, 0xff,\n    0xff, 0xff, 0xff, 0xe0, 0x3, 0x42, 0xcf, 0xfc,\n    0x23, 0x30, 0x0, 0x0, 0x7f, 0xf7, 0x0, 0x0,\n    0x0, 0x0, 0x4, 0x41, 0x0, 0x0,\n\n    /* U+F015 \"\uf015\" */\n    0x0, 0x0, 0x0, 0x73, 0x3, 0x83, 0x0, 0x0,\n    0x0, 0x1d, 0xff, 0x67, 0xf7, 0x0, 0x0, 0x3,\n    0xee, 0x5a, 0xfe, 0xf7, 0x0, 0x0, 0x6f, 0xd3,\n    0xb5, 0x7f, 0xf7, 0x0, 0x9, 0xfb, 0x3d, 0xff,\n    0x85, 0xfe, 0x30, 0xbf, 0x95, 0xff, 0xff, 0xfb,\n    0x3e, 0xf4, 0x76, 0x6f, 0xff, 0xff, 0xff, 0xd2,\n    0xa1, 0x0, 0xcf, 0xff, 0xff, 0xff, 0xf4, 0x0,\n    0x0, 0xcf, 0xfa, 0x2, 0xff, 0xf4, 0x0, 0x0,\n    0xcf, 0xfa, 0x2, 0xff, 0xf4, 0x0, 0x0, 0xaf,\n    0xf8, 0x1, 0xff, 0xf3, 0x0,\n\n    /* U+F019 \"\uf019\" */\n    0x0, 0x0, 0x27, 0x72, 0x0, 0x0, 0x0, 0x0,\n    0x7f, 0xf7, 0x0, 0x0, 0x0, 0x0, 0x8f, 0xf8,\n    0x0, 0x0, 0x0, 0x0, 0x8f, 0xf8, 0x0, 0x0,\n    0x0, 0x0, 0x8f, 0xf8, 0x0, 0x0, 0x0, 0xdf,\n    0xff, 0xff, 0xfd, 0x0, 0x0, 0x4f, 0xff, 0xff,\n    0xf4, 0x0, 0x0, 0x4, 0xff, 0xff, 0x40, 0x0,\n    0x23, 0x33, 0x5f, 0xf5, 0x33, 0x32, 0xff, 0xff,\n    0xa4, 0x4a, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xcf,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5c, 0x8f,\n    0x9a, 0xaa, 0xaa, 0xaa, 0xaa, 0xa8,\n\n    /* U+F01C \"\uf01c\" */\n    0x0, 0x4f, 0xff, 0xff, 0xff, 0xb0, 0x0, 0x1,\n    0xed, 0x88, 0x88, 0x89, 0xf8, 0x0, 0xa, 0xf2,\n    0x0, 0x0, 0x0, 0xaf, 0x30, 0x5f, 0x70, 0x0,\n    0x0, 0x0, 0x1e, 0xc0, 0xef, 0x88, 0x60, 0x0,\n    0x28, 0x8b, 0xf6, 0xff, 0xff, 0xf3, 0x0, 0xbf,\n    0xff, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7,\n    0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf4,\n\n    /* U+F021 \"\uf021\" */\n    0x0, 0x0, 0x1, 0x10, 0x0, 0x59, 0x0, 0x19,\n    0xef, 0xfd, 0x70, 0x9f, 0x3, 0xef, 0xda, 0x9d,\n    0xfe, 0xbf, 0xe, 0xf6, 0x0, 0x0, 0x5f, 0xff,\n    0x7f, 0x70, 0x0, 0x3f, 0xff, 0xff, 0x69, 0x0,\n    0x0, 0x2a, 0xaa, 0xa9, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xaa, 0xaa, 0xa2, 0x0, 0x0, 0xa6,\n    0xff, 0xfe, 0xf3, 0x0, 0x7, 0xf7, 0xff, 0xf5,\n    0x0, 0x0, 0x7f, 0xe0, 0xfb, 0xef, 0xd9, 0xad,\n    0xfe, 0x30, 0xfa, 0x8, 0xef, 0xfe, 0x91, 0x0,\n    0x95, 0x0, 0x1, 0x10, 0x0, 0x0,\n\n    /* U+F026 \"\uf026\" */\n    0x0, 0x0, 0x2a, 0x0, 0x2, 0xef, 0x78, 0x8e,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xdf, 0xff, 0xff, 0x0, 0x7, 0xff,\n    0x0, 0x0, 0x7f, 0x0, 0x0, 0x1,\n\n    /* U+F027 \"\uf027\" */\n    0x0, 0x0, 0x2a, 0x0, 0x0, 0x0, 0x2e, 0xf0,\n    0x0, 0x78, 0x8e, 0xff, 0x3, 0xf, 0xff, 0xff,\n    0xf0, 0xba, 0xff, 0xff, 0xff, 0x3, 0xff, 0xff,\n    0xff, 0xf0, 0xaa, 0xdf, 0xff, 0xff, 0x4, 0x0,\n    0x0, 0x8f, 0xf0, 0x0, 0x0, 0x0, 0x8f, 0x0,\n    0x0, 0x0, 0x0, 0x10, 0x0,\n\n    /* U+F028 \"\uf028\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x6, 0xd2, 0x0, 0x0, 0x0,\n    0x2a, 0x0, 0x11, 0x8e, 0x10, 0x0, 0x2, 0xef,\n    0x0, 0x7d, 0x2b, 0x90, 0x78, 0x8e, 0xff, 0x3,\n    0xa, 0xb3, 0xf0, 0xff, 0xff, 0xff, 0xb, 0xa1,\n    0xf1, 0xe3, 0xff, 0xff, 0xff, 0x3, 0xf0, 0xe3,\n    0xc5, 0xff, 0xff, 0xff, 0xb, 0xa1, 0xf1, 0xe3,\n    0xdf, 0xff, 0xff, 0x3, 0xa, 0xb3, 0xf0, 0x0,\n    0x7, 0xff, 0x0, 0x7d, 0x2b, 0x90, 0x0, 0x0,\n    0x7f, 0x0, 0x11, 0x9e, 0x10, 0x0, 0x0, 0x1,\n    0x0, 0x6, 0xd2, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0,\n\n    /* U+F03E \"\uf03e\" */\n    0xbf, 0xff, 0xff, 0xff, 0xff, 0xfb, 0xfd, 0x5b,\n    0xff, 0xff, 0xff, 0xff, 0xf5, 0x1, 0xff, 0xff,\n    0xef, 0xff, 0xfb, 0x18, 0xff, 0xf6, 0x1c, 0xff,\n    0xff, 0xfc, 0xff, 0x60, 0x1, 0xdf, 0xff, 0x60,\n    0x96, 0x0, 0x0, 0x8f, 0xf9, 0x0, 0x0, 0x0,\n    0x0, 0x8f, 0xfc, 0x88, 0x88, 0x88, 0x88, 0xcf,\n    0xbf, 0xff, 0xff, 0xff, 0xff, 0xfb,\n\n    /* U+F043 \"\uf043\" */\n    0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0xcf, 0x10,\n    0x0, 0x0, 0x3f, 0xf7, 0x0, 0x0, 0xa, 0xff,\n    0xe0, 0x0, 0x4, 0xff, 0xff, 0x80, 0x0, 0xef,\n    0xff, 0xff, 0x30, 0x8f, 0xff, 0xff, 0xfc, 0xe,\n    0xff, 0xff, 0xff, 0xf2, 0xf9, 0xcf, 0xff, 0xff,\n    0x3d, 0xc5, 0xff, 0xff, 0xf1, 0x6f, 0xa3, 0xbf,\n    0xfa, 0x0, 0x8f, 0xff, 0xfb, 0x0, 0x0, 0x26,\n    0x74, 0x0, 0x0,\n\n    /* U+F048 \"\uf048\" */\n    0x58, 0x0, 0x0, 0x35, 0x9f, 0x10, 0x5, 0xfe,\n    0x9f, 0x10, 0x6f, 0xfe, 0x9f, 0x17, 0xff, 0xfe,\n    0x9f, 0x9f, 0xff, 0xfe, 0x9f, 0xff, 0xff, 0xfe,\n    0x9f, 0xef, 0xff, 0xfe, 0x9f, 0x2d, 0xff, 0xfe,\n    0x9f, 0x10, 0xcf, 0xfe, 0x9f, 0x10, 0xb, 0xfe,\n    0x8f, 0x0, 0x0, 0x9b, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+F04B \"\uf04b\" */\n    0x46, 0x0, 0x0, 0x0, 0x0, 0xf, 0xfd, 0x40,\n    0x0, 0x0, 0x0, 0xff, 0xff, 0xa1, 0x0, 0x0,\n    0xf, 0xff, 0xff, 0xf7, 0x0, 0x0, 0xff, 0xff,\n    0xff, 0xfd, 0x50, 0xf, 0xff, 0xff, 0xff, 0xff,\n    0xb1, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6f, 0xff,\n    0xff, 0xff, 0xff, 0xb1, 0xff, 0xff, 0xff, 0xfd,\n    0x40, 0xf, 0xff, 0xff, 0xf7, 0x0, 0x0, 0xff,\n    0xff, 0xa1, 0x0, 0x0, 0xf, 0xfd, 0x40, 0x0,\n    0x0, 0x0, 0x36, 0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+F04C \"\uf04c\" */\n    0xaf, 0xfe, 0x30, 0xaf, 0xfe, 0x3f, 0xff, 0xf7,\n    0xf, 0xff, 0xf7, 0xff, 0xff, 0x80, 0xff, 0xff,\n    0x8f, 0xff, 0xf8, 0xf, 0xff, 0xf8, 0xff, 0xff,\n    0x80, 0xff, 0xff, 0x8f, 0xff, 0xf8, 0xf, 0xff,\n    0xf8, 0xff, 0xff, 0x80, 0xff, 0xff, 0x8f, 0xff,\n    0xf8, 0xf, 0xff, 0xf8, 0xff, 0xff, 0x80, 0xff,\n    0xff, 0x8f, 0xff, 0xf7, 0xf, 0xff, 0xf7, 0x48,\n    0x98, 0x10, 0x48, 0x98, 0x10,\n\n    /* U+F04D \"\uf04d\" */\n    0x48, 0x88, 0x88, 0x88, 0x88, 0x1f, 0xff, 0xff,\n    0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x8f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff,\n    0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8f, 0xff,\n    0xff, 0xff, 0xff, 0xf8, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xaf,\n    0xff, 0xff, 0xff, 0xfe, 0x30,\n\n    /* U+F051 \"\uf051\" */\n    0x26, 0x0, 0x0, 0x58, 0x7f, 0xa0, 0x0, 0xbf,\n    0x8f, 0xfb, 0x0, 0xbf, 0x8f, 0xff, 0xc1, 0xbf,\n    0x8f, 0xff, 0xfd, 0xcf, 0x8f, 0xff, 0xff, 0xff,\n    0x8f, 0xff, 0xff, 0xef, 0x8f, 0xff, 0xf4, 0xbf,\n    0x8f, 0xff, 0x40, 0xbf, 0x8f, 0xe3, 0x0, 0xbf,\n    0x5d, 0x20, 0x0, 0xae, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+F052 \"\uf052\" */\n    0x0, 0x0, 0x3, 0x70, 0x0, 0x0, 0x0, 0x0,\n    0x3f, 0xfa, 0x0, 0x0, 0x0, 0x2, 0xef, 0xff,\n    0x90, 0x0, 0x0, 0x1e, 0xff, 0xff, 0xf8, 0x0,\n    0x1, 0xdf, 0xff, 0xff, 0xff, 0x70, 0xc, 0xff,\n    0xff, 0xff, 0xff, 0xf4, 0xd, 0xff, 0xff, 0xff,\n    0xff, 0xf5, 0x1, 0x34, 0x44, 0x44, 0x44, 0x30,\n    0xd, 0xff, 0xff, 0xff, 0xff, 0xf5, 0xf, 0xff,\n    0xff, 0xff, 0xff, 0xf8, 0xc, 0xff, 0xff, 0xff,\n    0xff, 0xf5,\n\n    /* U+F053 \"\uf053\" */\n    0x0, 0x0, 0x3, 0x10, 0x0, 0x5, 0xfb, 0x0,\n    0x5, 0xff, 0x40, 0x5, 0xff, 0x40, 0x5, 0xff,\n    0x50, 0x3, 0xff, 0x50, 0x0, 0xb, 0xfc, 0x10,\n    0x0, 0xb, 0xfc, 0x10, 0x0, 0xc, 0xfc, 0x10,\n    0x0, 0xc, 0xfb, 0x0, 0x0, 0xa, 0x50,\n\n    /* U+F054 \"\uf054\" */\n    0x3, 0x10, 0x0, 0x3, 0xfc, 0x10, 0x0, 0xb,\n    0xfc, 0x10, 0x0, 0xb, 0xfc, 0x10, 0x0, 0xb,\n    0xfc, 0x10, 0x0, 0xd, 0xfb, 0x0, 0x5, 0xff,\n    0x50, 0x5, 0xff, 0x50, 0x5, 0xff, 0x50, 0x3,\n    0xff, 0x50, 0x0, 0xa, 0x50, 0x0, 0x0,\n\n    /* U+F067 \"\uf067\" */\n    0x0, 0x0, 0x69, 0x10, 0x0, 0x0, 0x0, 0xd,\n    0xf5, 0x0, 0x0, 0x0, 0x0, 0xef, 0x60, 0x0,\n    0x0, 0x0, 0xe, 0xf6, 0x0, 0x0, 0x58, 0x88,\n    0xff, 0xb8, 0x88, 0x1f, 0xff, 0xff, 0xff, 0xff,\n    0xf7, 0x9b, 0xbb, 0xff, 0xdb, 0xbb, 0x30, 0x0,\n    0xe, 0xf6, 0x0, 0x0, 0x0, 0x0, 0xef, 0x60,\n    0x0, 0x0, 0x0, 0xe, 0xf6, 0x0, 0x0, 0x0,\n    0x0, 0x9d, 0x20, 0x0, 0x0,\n\n    /* U+F068 \"\uf068\" */\n    0x46, 0x66, 0x66, 0x66, 0x66, 0x1f, 0xff, 0xff,\n    0xff, 0xff, 0xf7, 0xad, 0xdd, 0xdd, 0xdd, 0xdd,\n    0x40,\n\n    /* U+F06E \"\uf06e\" */\n    0x0, 0x3, 0xad, 0xff, 0xc7, 0x0, 0x0, 0x0,\n    0x9f, 0xe6, 0x24, 0xaf, 0xe3, 0x0, 0xb, 0xff,\n    0x20, 0x77, 0x9, 0xff, 0x40, 0x7f, 0xf9, 0x0,\n    0xcf, 0xa1, 0xff, 0xe1, 0xef, 0xf6, 0x7f, 0xff,\n    0xf0, 0xef, 0xf7, 0x8f, 0xf9, 0x3f, 0xff, 0xc1,\n    0xff, 0xe1, 0xb, 0xff, 0x26, 0xca, 0x19, 0xff,\n    0x40, 0x0, 0x9f, 0xe6, 0x24, 0xaf, 0xe3, 0x0,\n    0x0, 0x3, 0x9d, 0xff, 0xc7, 0x0, 0x0,\n\n    /* U+F070 \"\uf070\" */\n    0x32, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0xdf, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x1c, 0xf8, 0x4a, 0xef, 0xeb, 0x50, 0x0, 0x0,\n    0x0, 0x9f, 0xfd, 0x52, 0x5d, 0xfc, 0x10, 0x0,\n    0x0, 0x5, 0xfe, 0x4a, 0x70, 0xcf, 0xe1, 0x0,\n    0xb, 0x80, 0x2d, 0xff, 0xf7, 0x4f, 0xfb, 0x0,\n    0x2f, 0xfb, 0x0, 0xaf, 0xfb, 0x2f, 0xff, 0x30,\n    0xb, 0xff, 0x50, 0x7, 0xfe, 0x7f, 0xfb, 0x0,\n    0x1, 0xdf, 0xc0, 0x0, 0x3e, 0xff, 0xe1, 0x0,\n    0x0, 0x1b, 0xfc, 0x42, 0x1, 0xbf, 0xa0, 0x0,\n    0x0, 0x0, 0x5b, 0xef, 0xb0, 0x8, 0xfc, 0x10,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4f, 0xe0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x40,\n\n    /* U+F071 \"\uf071\" */\n    0x0, 0x0, 0x0, 0x3, 0x10, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x5, 0xfd, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xef, 0xf7, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x8f, 0xff, 0xf1, 0x0, 0x0, 0x0, 0x0,\n    0x2f, 0xfd, 0xef, 0xa0, 0x0, 0x0, 0x0, 0xb,\n    0xfb, 0x3, 0xff, 0x30, 0x0, 0x0, 0x4, 0xff,\n    0xc0, 0x4f, 0xfc, 0x0, 0x0, 0x0, 0xdf, 0xfd,\n    0x5, 0xff, 0xf6, 0x0, 0x0, 0x7f, 0xff, 0xf8,\n    0xcf, 0xff, 0xe1, 0x0, 0x1f, 0xff, 0xfc, 0x4,\n    0xff, 0xff, 0x90, 0xa, 0xff, 0xff, 0xd2, 0x7f,\n    0xff, 0xff, 0x20, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xf6, 0x4, 0x78, 0x88, 0x88, 0x88, 0x88,\n    0x87, 0x0,\n\n    /* U+F074 \"\uf074\" */\n    0x0, 0x0, 0x0, 0x0, 0x6, 0x10, 0x0, 0x0,\n    0x0, 0x0, 0xf, 0xc1, 0xff, 0xf8, 0x0, 0x2e,\n    0xff, 0xfc, 0xcd, 0xff, 0x62, 0xef, 0xdf, 0xf9,\n    0x0, 0x2c, 0x4e, 0xf9, 0xf, 0x90, 0x0, 0x2,\n    0xef, 0x90, 0x7, 0x0, 0x0, 0x2e, 0xf8, 0x88,\n    0xf, 0xa0, 0xcd, 0xff, 0x80, 0xdf, 0xdf, 0xf9,\n    0xff, 0xf8, 0x0, 0x1e, 0xff, 0xfc, 0x0, 0x0,\n    0x0, 0x0, 0xf, 0xc0, 0x0, 0x0, 0x0, 0x0,\n    0x6, 0x10,\n\n    /* U+F077 \"\uf077\" */\n    0x0, 0x0, 0x27, 0x0, 0x0, 0x0, 0x0, 0x2e,\n    0xf9, 0x0, 0x0, 0x0, 0x2e, 0xff, 0xf9, 0x0,\n    0x0, 0x2e, 0xf9, 0x2e, 0xf9, 0x0, 0x2e, 0xf9,\n    0x0, 0x2e, 0xf9, 0xb, 0xf9, 0x0, 0x0, 0x2e,\n    0xf4, 0x27, 0x0, 0x0, 0x0, 0x27, 0x0,\n\n    /* U+F078 \"\uf078\" */\n    0x27, 0x0, 0x0, 0x0, 0x27, 0xb, 0xf9, 0x0,\n    0x0, 0x2e, 0xf4, 0x2e, 0xf9, 0x0, 0x2e, 0xf9,\n    0x0, 0x2e, 0xf9, 0x2e, 0xf9, 0x0, 0x0, 0x2e,\n    0xff, 0xf9, 0x0, 0x0, 0x0, 0x2e, 0xf9, 0x0,\n    0x0, 0x0, 0x0, 0x26, 0x0, 0x0, 0x0,\n\n    /* U+F079 \"\uf079\" */\n    0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x3f, 0xc0, 0x7, 0x77, 0x77, 0x72, 0x0,\n    0x3, 0xff, 0xfc, 0x2e, 0xff, 0xff, 0xf9, 0x0,\n    0xf, 0xcf, 0xcf, 0xa0, 0x0, 0x0, 0xe9, 0x0,\n    0x4, 0x1e, 0x93, 0x20, 0x0, 0x0, 0xe9, 0x0,\n    0x0, 0xe, 0x90, 0x0, 0x0, 0x0, 0xe9, 0x0,\n    0x0, 0xe, 0x90, 0x0, 0x0, 0xb5, 0xe9, 0x97,\n    0x0, 0xe, 0xc7, 0x77, 0x73, 0xbf, 0xff, 0xf6,\n    0x0, 0xd, 0xff, 0xff, 0xfd, 0xb, 0xff, 0x70,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa6, 0x0,\n\n    /* U+F07B \"\uf07b\" */\n    0xbf, 0xff, 0xf6, 0x0, 0x0, 0x0, 0xff, 0xff,\n    0xff, 0x98, 0x88, 0x74, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xbf, 0xff, 0xff, 0xff, 0xff, 0xfb,\n\n    /* U+F093 \"\uf093\" */\n    0x0, 0x0, 0x2, 0x20, 0x0, 0x0, 0x0, 0x0,\n    0x3e, 0xe3, 0x0, 0x0, 0x0, 0x3, 0xef, 0xfe,\n    0x30, 0x0, 0x0, 0x3e, 0xff, 0xff, 0xe3, 0x0,\n    0x0, 0xef, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0,\n    0x8f, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x8f, 0xf8,\n    0x0, 0x0, 0x0, 0x0, 0x8f, 0xf8, 0x0, 0x0,\n    0x23, 0x32, 0x8f, 0xf8, 0x23, 0x32, 0xff, 0xfe,\n    0x39, 0x93, 0xef, 0xff, 0xff, 0xff, 0xc9, 0x9c,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5c, 0x8f,\n    0x9a, 0xaa, 0xaa, 0xaa, 0xaa, 0xa8,\n\n    /* U+F095 \"\uf095\" */\n    0x0, 0x0, 0x0, 0x0, 0x3, 0x62, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xcf, 0xfe, 0x0, 0x0, 0x0,\n    0x0, 0x3f, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x9,\n    0xff, 0xfd, 0x0, 0x0, 0x0, 0x0, 0x2d, 0xff,\n    0x90, 0x0, 0x0, 0x0, 0x0, 0x4f, 0xf4, 0x0,\n    0x0, 0x0, 0x0, 0xc, 0xfd, 0x0, 0x0, 0x1,\n    0x0, 0x9, 0xff, 0x40, 0x1, 0x8e, 0xe1, 0x1a,\n    0xff, 0x70, 0x0, 0xef, 0xff, 0xde, 0xff, 0x90,\n    0x0, 0xc, 0xff, 0xff, 0xff, 0x60, 0x0, 0x0,\n    0x8f, 0xff, 0xe9, 0x10, 0x0, 0x0, 0x2, 0x76,\n    0x30, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+F0C4 \"\uf0c4\" */\n    0x7, 0x93, 0x0, 0x0, 0x22, 0xa, 0xff, 0xf2,\n    0x0, 0x8f, 0xf5, 0xf9, 0x1f, 0x70, 0x8f, 0xf9,\n    0xc, 0xfc, 0xf8, 0x8f, 0xf9, 0x0, 0x1a, 0xef,\n    0xff, 0xf9, 0x0, 0x0, 0x0, 0xef, 0xfc, 0x0,\n    0x0, 0x7, 0xbf, 0xff, 0xf6, 0x0, 0xa, 0xff,\n    0xfa, 0xbf, 0xf6, 0x0, 0xf9, 0x1f, 0x70, 0xbf,\n    0xf6, 0xc, 0xfc, 0xf4, 0x0, 0xbf, 0xf4, 0x1a,\n    0xc6, 0x0, 0x0, 0x56, 0x0,\n\n    /* U+F0C5 \"\uf0c5\" */\n    0x0, 0x3, 0x44, 0x41, 0x20, 0x0, 0x0, 0xff,\n    0xff, 0x5e, 0x40, 0x24, 0x1f, 0xff, 0xf5, 0xee,\n    0x2f, 0xf4, 0xff, 0xff, 0xc8, 0x82, 0xff, 0x4f,\n    0xff, 0xff, 0xff, 0x5f, 0xf4, 0xff, 0xff, 0xff,\n    0xf5, 0xff, 0x4f, 0xff, 0xff, 0xff, 0x5f, 0xf4,\n    0xff, 0xff, 0xff, 0xf5, 0xff, 0x4f, 0xff, 0xff,\n    0xff, 0x5f, 0xf4, 0xff, 0xff, 0xff, 0xf4, 0xff,\n    0x93, 0x44, 0x44, 0x43, 0xf, 0xff, 0xff, 0xff,\n    0x50, 0x0, 0x68, 0x88, 0x88, 0x71, 0x0, 0x0,\n\n    /* U+F0C7 \"\uf0c7\" */\n    0x48, 0x88, 0x88, 0x87, 0x0, 0xf, 0xff, 0xff,\n    0xff, 0xfb, 0x0, 0xf8, 0x0, 0x0, 0xb, 0xfb,\n    0xf, 0x80, 0x0, 0x0, 0xbf, 0xf3, 0xfb, 0x77,\n    0x77, 0x7d, 0xff, 0x4f, 0xff, 0xff, 0xff, 0xff,\n    0xf4, 0xff, 0xff, 0x42, 0xdf, 0xff, 0x4f, 0xff,\n    0xc0, 0x8, 0xff, 0xf4, 0xff, 0xfe, 0x0, 0xaf,\n    0xff, 0x4f, 0xff, 0xfc, 0xaf, 0xff, 0xf4, 0xaf,\n    0xff, 0xff, 0xff, 0xfd, 0x10,\n\n    /* U+F0C9 \"\uf0c9\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff,\n    0xff, 0xff, 0xf7, 0x9a, 0xaa, 0xaa, 0xaa, 0xaa,\n    0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x89, 0x99,\n    0x99, 0x99, 0x99, 0x3f, 0xff, 0xff, 0xff, 0xff,\n    0xf7, 0x12, 0x22, 0x22, 0x22, 0x22, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x9a, 0xaa, 0xaa, 0xaa,\n    0xaa, 0x4f, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+F0E0 \"\uf0e0\" */\n    0xbf, 0xff, 0xff, 0xff, 0xff, 0xfb, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0x4e, 0xff, 0xff, 0xff,\n    0xff, 0xe4, 0xc3, 0xbf, 0xff, 0xff, 0xfb, 0x3c,\n    0xff, 0x57, 0xff, 0xff, 0x75, 0xff, 0xff, 0xf9,\n    0x3d, 0xd3, 0x9f, 0xff, 0xff, 0xff, 0xd5, 0x5d,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xbf, 0xff, 0xff, 0xff, 0xff, 0xfb,\n\n    /* U+F0E7 \"\uf0e7\" */\n    0x1, 0xbb, 0xba, 0x10, 0x0, 0x5f, 0xff, 0xf1,\n    0x0, 0x7, 0xff, 0xfb, 0x0, 0x0, 0x9f, 0xff,\n    0x60, 0x0, 0xb, 0xff, 0xff, 0xff, 0x60, 0xef,\n    0xff, 0xff, 0xf1, 0xe, 0xff, 0xff, 0xf8, 0x0,\n    0x0, 0xc, 0xfe, 0x0, 0x0, 0x0, 0xff, 0x50,\n    0x0, 0x0, 0x3f, 0xc0, 0x0, 0x0, 0x7, 0xf3,\n    0x0, 0x0, 0x0, 0xa9, 0x0, 0x0, 0x0, 0x2,\n    0x0, 0x0, 0x0,\n\n    /* U+F0EA \"\uf0ea\" */\n    0x0, 0x2a, 0x50, 0x0, 0x0, 0xe, 0xff, 0x8f,\n    0xff, 0x20, 0x0, 0xff, 0xf8, 0xff, 0xf4, 0x0,\n    0xf, 0xff, 0xeb, 0xbb, 0x30, 0x0, 0xff, 0xf4,\n    0x99, 0x92, 0x60, 0xf, 0xff, 0x5f, 0xff, 0x4f,\n    0xa0, 0xff, 0xf5, 0xff, 0xf5, 0x56, 0x1f, 0xff,\n    0x5f, 0xff, 0xff, 0xf4, 0xff, 0xf5, 0xff, 0xff,\n    0xff, 0x4e, 0xff, 0x5f, 0xff, 0xff, 0xf4, 0x0,\n    0x5, 0xff, 0xff, 0xff, 0x40, 0x0, 0x5f, 0xff,\n    0xff, 0xf4, 0x0, 0x0, 0x44, 0x44, 0x44, 0x0,\n\n    /* U+F0F3 \"\uf0f3\" */\n    0x0, 0x0, 0x15, 0x0, 0x0, 0x0, 0x0, 0x9,\n    0xf1, 0x0, 0x0, 0x0, 0x2d, 0xff, 0xf9, 0x0,\n    0x0, 0xe, 0xff, 0xff, 0xf7, 0x0, 0x5, 0xff,\n    0xff, 0xff, 0xd0, 0x0, 0x8f, 0xff, 0xff, 0xff,\n    0x0, 0xa, 0xff, 0xff, 0xff, 0xf2, 0x0, 0xdf,\n    0xff, 0xff, 0xff, 0x50, 0x6f, 0xff, 0xff, 0xff,\n    0xfd, 0xe, 0xff, 0xff, 0xff, 0xff, 0xf6, 0x24,\n    0x44, 0x44, 0x44, 0x43, 0x0, 0x0, 0x2f, 0xf9,\n    0x0, 0x0, 0x0, 0x0, 0x46, 0x0, 0x0, 0x0,\n\n    /* U+F11C \"\uf11c\" */\n    0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf4, 0xfc,\n    0x8e, 0x8e, 0x8e, 0x88, 0xe8, 0xf7, 0xf8, 0xc,\n    0xc, 0xb, 0x0, 0xb0, 0xf8, 0xff, 0xec, 0xfc,\n    0xec, 0xee, 0xcf, 0xf8, 0xff, 0xa0, 0xc0, 0xa0,\n    0x77, 0x2f, 0xf8, 0xff, 0xec, 0xfc, 0xec, 0xee,\n    0xcf, 0xf8, 0xf8, 0xc, 0x0, 0x0, 0x0, 0xb0,\n    0xf8, 0xfc, 0x8e, 0x88, 0x88, 0x88, 0xe8, 0xf7,\n    0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf4,\n\n    /* U+F124 \"\uf124\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x30, 0x0,\n    0x0, 0x0, 0x0, 0x18, 0xef, 0xe0, 0x0, 0x0,\n    0x0, 0x29, 0xff, 0xff, 0xb0, 0x0, 0x0, 0x3a,\n    0xff, 0xff, 0xff, 0x30, 0x0, 0x4c, 0xff, 0xff,\n    0xff, 0xfc, 0x0, 0xb, 0xff, 0xff, 0xff, 0xff,\n    0xf5, 0x0, 0xe, 0xff, 0xff, 0xff, 0xff, 0xd0,\n    0x0, 0x1, 0x34, 0x44, 0xdf, 0xff, 0x60, 0x0,\n    0x0, 0x0, 0x0, 0xcf, 0xfe, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xcf, 0xf8, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xcf, 0xf1, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0xbf, 0x90, 0x0, 0x0, 0x0, 0x0, 0x0, 0x26,\n    0x0, 0x0, 0x0,\n\n    /* U+F15B \"\uf15b\" */\n    0x9b, 0xbb, 0xb2, 0x70, 0xf, 0xff, 0xff, 0x4f,\n    0x90, 0xff, 0xff, 0xf4, 0xff, 0x9f, 0xff, 0xff,\n    0x54, 0x44, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x34, 0x44,\n    0x44, 0x44, 0x30,\n\n    /* U+F1EB \"\uf1eb\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x5, 0x9b, 0xcb, 0x95, 0x0, 0x0, 0x0,\n    0x8f, 0xff, 0xff, 0xff, 0xff, 0x80, 0x3, 0xef,\n    0xfa, 0x53, 0x23, 0x5a, 0xff, 0xe3, 0xdf, 0xa1,\n    0x0, 0x0, 0x0, 0x1, 0xaf, 0xd2, 0x60, 0x5,\n    0xbe, 0xfe, 0xb5, 0x0, 0x52, 0x0, 0x1c, 0xff,\n    0xfe, 0xff, 0xfc, 0x10, 0x0, 0x2, 0xec, 0x40,\n    0x0, 0x4c, 0xe2, 0x0, 0x0, 0x1, 0x0, 0x1,\n    0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0xa, 0xfa,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xf0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0xd6, 0x0,\n    0x0, 0x0,\n\n    /* U+F240 \"\uf240\" */\n    0x37, 0x77, 0x77, 0x77, 0x77, 0x77, 0x75, 0xf,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xf8,\n    0x34, 0x44, 0x44, 0x44, 0x44, 0x4f, 0xdf, 0x8c,\n    0xff, 0xff, 0xff, 0xff, 0xf2, 0xcf, 0xf8, 0xcf,\n    0xff, 0xff, 0xff, 0xff, 0x8, 0xff, 0x89, 0xcc,\n    0xcc, 0xcc, 0xcc, 0xc3, 0xff, 0xfb, 0x77, 0x77,\n    0x77, 0x77, 0x77, 0x9f, 0x9c, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xe1, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0,\n\n    /* U+F241 \"\uf241\" */\n    0x37, 0x77, 0x77, 0x77, 0x77, 0x77, 0x75, 0xf,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xf8,\n    0x34, 0x44, 0x44, 0x43, 0x0, 0x4f, 0xdf, 0x8c,\n    0xff, 0xff, 0xff, 0xc0, 0x2, 0xcf, 0xf8, 0xcf,\n    0xff, 0xff, 0xfc, 0x0, 0x8, 0xff, 0x89, 0xcc,\n    0xcc, 0xcc, 0x90, 0x3, 0xff, 0xfb, 0x77, 0x77,\n    0x77, 0x77, 0x77, 0x9f, 0x9c, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xe1, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0,\n\n    /* U+F242 \"\uf242\" */\n    0x37, 0x77, 0x77, 0x77, 0x77, 0x77, 0x75, 0xf,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xf8,\n    0x34, 0x44, 0x42, 0x0, 0x0, 0x4f, 0xdf, 0x8c,\n    0xff, 0xff, 0x80, 0x0, 0x2, 0xcf, 0xf8, 0xcf,\n    0xff, 0xf8, 0x0, 0x0, 0x8, 0xff, 0x89, 0xcc,\n    0xcc, 0x60, 0x0, 0x3, 0xff, 0xfb, 0x77, 0x77,\n    0x77, 0x77, 0x77, 0x9f, 0x9c, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xe1, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0,\n\n    /* U+F243 \"\uf243\" */\n    0x37, 0x77, 0x77, 0x77, 0x77, 0x77, 0x75, 0xf,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xf8,\n    0x34, 0x41, 0x0, 0x0, 0x0, 0x4f, 0xdf, 0x8c,\n    0xff, 0x40, 0x0, 0x0, 0x2, 0xcf, 0xf8, 0xcf,\n    0xf4, 0x0, 0x0, 0x0, 0x8, 0xff, 0x89, 0xcc,\n    0x30, 0x0, 0x0, 0x3, 0xff, 0xfb, 0x77, 0x77,\n    0x77, 0x77, 0x77, 0x9f, 0x9c, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xe1, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0,\n\n    /* U+F244 \"\uf244\" */\n    0x37, 0x77, 0x77, 0x77, 0x77, 0x77, 0x75, 0xf,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xf8,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x4f, 0xdf, 0x80,\n    0x0, 0x0, 0x0, 0x0, 0x2, 0xcf, 0xf8, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x8, 0xff, 0x80, 0x0,\n    0x0, 0x0, 0x0, 0x3, 0xff, 0xfb, 0x77, 0x77,\n    0x77, 0x77, 0x77, 0x9f, 0x9c, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xe1, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0,\n\n    /* U+F287 \"\uf287\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x25, 0xfb, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x5, 0xcb, 0xfe, 0x0, 0x0, 0x0,\n    0x1, 0x0, 0xd, 0x10, 0x42, 0x0, 0x0, 0x0,\n    0x9f, 0xd1, 0x68, 0x0, 0x0, 0x0, 0x68, 0x0,\n    0xff, 0xfe, 0xee, 0xed, 0xdd, 0xdd, 0xef, 0xc0,\n    0x9f, 0xd1, 0x0, 0xb3, 0x0, 0x0, 0x68, 0x0,\n    0x1, 0x0, 0x0, 0x3b, 0x5, 0x74, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x9, 0xbe, 0xfb, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x2d, 0xfb, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+F293 \"\uf293\" */\n    0x0, 0x0, 0x34, 0x20, 0x0, 0x0, 0x6e, 0xfe,\n    0xfd, 0x20, 0x4, 0xff, 0xf3, 0xff, 0xd0, 0xc,\n    0xff, 0xf0, 0x4f, 0xf5, 0xf, 0xd5, 0xf2, 0x95,\n    0xf8, 0x2f, 0xf7, 0x41, 0x3c, 0xfa, 0x3f, 0xff,\n    0x60, 0xaf, 0xfb, 0x3f, 0xfe, 0x20, 0x4f, 0xfb,\n    0x2f, 0xe2, 0x92, 0x75, 0xfa, 0xf, 0xeb, 0xf1,\n    0x49, 0xf8, 0x9, 0xff, 0xf0, 0x9f, 0xf2, 0x1,\n    0xdf, 0xf9, 0xff, 0x90, 0x0, 0x6, 0xab, 0x95,\n    0x0,\n\n    /* U+F2ED \"\uf2ed\" */\n    0x0, 0x4, 0x88, 0x70, 0x0, 0xb, 0xcc, 0xff,\n    0xff, 0xdc, 0xc5, 0xbc, 0xcc, 0xcc, 0xcc, 0xcc,\n    0x52, 0x88, 0x88, 0x88, 0x88, 0x60, 0x4f, 0xff,\n    0xff, 0xff, 0xfc, 0x4, 0xfa, 0xae, 0x6f, 0x5f,\n    0xc0, 0x4f, 0xaa, 0xe6, 0xf4, 0xfc, 0x4, 0xfa,\n    0xae, 0x6f, 0x4f, 0xc0, 0x4f, 0xaa, 0xe6, 0xf4,\n    0xfc, 0x4, 0xfa, 0xae, 0x6f, 0x4f, 0xc0, 0x4f,\n    0xaa, 0xe6, 0xf5, 0xfc, 0x3, 0xff, 0xff, 0xff,\n    0xff, 0xb0, 0x6, 0x88, 0x88, 0x88, 0x72, 0x0,\n\n    /* U+F304 \"\uf304\" */\n    0x0, 0x0, 0x0, 0x0, 0x1, 0x71, 0x0, 0x0,\n    0x0, 0x0, 0x2, 0xef, 0xd1, 0x0, 0x0, 0x0,\n    0x1, 0x5f, 0xff, 0xc0, 0x0, 0x0, 0x2, 0xea,\n    0x5f, 0xfd, 0x0, 0x0, 0x2, 0xef, 0xfa, 0x5d,\n    0x20, 0x0, 0x2, 0xef, 0xff, 0xf8, 0x0, 0x0,\n    0x2, 0xef, 0xff, 0xfe, 0x20, 0x0, 0x2, 0xef,\n    0xff, 0xfe, 0x20, 0x0, 0x2, 0xef, 0xff, 0xfe,\n    0x20, 0x0, 0x0, 0xbf, 0xff, 0xfe, 0x20, 0x0,\n    0x0, 0xd, 0xff, 0xfe, 0x20, 0x0, 0x0, 0x0,\n    0xff, 0xfe, 0x20, 0x0, 0x0, 0x0, 0x6, 0x64,\n    0x10, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+F55A \"\uf55a\" */\n    0x0, 0x5, 0xef, 0xff, 0xff, 0xff, 0xff, 0x80,\n    0x5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5,\n    0xff, 0xff, 0x91, 0xdd, 0x19, 0xff, 0xf5, 0xff,\n    0xff, 0xfd, 0x11, 0x11, 0xdf, 0xff, 0xef, 0xff,\n    0xff, 0xfb, 0x0, 0xbf, 0xff, 0xf5, 0xff, 0xff,\n    0xfd, 0x11, 0x11, 0xdf, 0xff, 0x5, 0xff, 0xff,\n    0x91, 0xdd, 0x19, 0xff, 0xf0, 0x5, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0x0, 0x4, 0xef, 0xff,\n    0xff, 0xff, 0xff, 0x80,\n\n    /* U+F7C2 \"\uf7c2\" */\n    0x0, 0x17, 0x88, 0x87, 0x20, 0x2d, 0xff, 0xff,\n    0xfd, 0x2e, 0xa0, 0xb3, 0x78, 0xfe, 0xfa, 0xb,\n    0x37, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xfc, 0xff, 0xff, 0xff, 0xfc, 0x4, 0x44,\n    0x44, 0x44, 0x0,\n\n    /* U+F8A2 \"\uf8a2\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x4, 0xf0, 0x0, 0x69, 0x0,\n    0x0, 0x0, 0xdf, 0x0, 0x7f, 0xc0, 0x0, 0x0,\n    0xd, 0xf0, 0x8f, 0xff, 0xdd, 0xdd, 0xdd, 0xff,\n    0xb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xb,\n    0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0xc0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0\n}", "sline": 24}, "glyph_dsc": {"type": "Variable", "def": "static const lv_font_fmt_txt_glyph_dsc_t glyph_dsc[] = {\n    {.bitmap_index = 0, .adv_w = 0, .box_w = 0, .box_h = 0, .ofs_x = 0, .ofs_y = 0} /* id = 0 reserved */,\n    {.bitmap_index = 0, .adv_w = 52, .box_w = 0, .box_h = 0, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 0, .adv_w = 51, .box_w = 3, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 14, .adv_w = 75, .box_w = 4, .box_h = 4, .ofs_x = 0, .ofs_y = 5},\n    {.bitmap_index = 22, .adv_w = 135, .box_w = 9, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 63, .adv_w = 119, .box_w = 7, .box_h = 13, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 109, .adv_w = 162, .box_w = 10, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 154, .adv_w = 132, .box_w = 9, .box_h = 10, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 199, .adv_w = 40, .box_w = 2, .box_h = 4, .ofs_x = 0, .ofs_y = 5},\n    {.bitmap_index = 203, .adv_w = 65, .box_w = 3, .box_h = 13, .ofs_x = 1, .ofs_y = -3},\n    {.bitmap_index = 223, .adv_w = 65, .box_w = 3, .box_h = 13, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 243, .adv_w = 77, .box_w = 5, .box_h = 5, .ofs_x = 0, .ofs_y = 5},\n    {.bitmap_index = 256, .adv_w = 112, .box_w = 7, .box_h = 6, .ofs_x = 0, .ofs_y = 2},\n    {.bitmap_index = 277, .adv_w = 44, .box_w = 3, .box_h = 4, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 283, .adv_w = 74, .box_w = 4, .box_h = 2, .ofs_x = 0, .ofs_y = 2},\n    {.bitmap_index = 287, .adv_w = 44, .box_w = 3, .box_h = 2, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 290, .adv_w = 68, .box_w = 6, .box_h = 13, .ofs_x = -1, .ofs_y = -1},\n    {.bitmap_index = 329, .adv_w = 128, .box_w = 8, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 365, .adv_w = 71, .box_w = 4, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 383, .adv_w = 110, .box_w = 7, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 415, .adv_w = 110, .box_w = 7, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 447, .adv_w = 128, .box_w = 8, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 483, .adv_w = 110, .box_w = 7, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 515, .adv_w = 118, .box_w = 8, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 551, .adv_w = 115, .box_w = 7, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 583, .adv_w = 124, .box_w = 8, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 619, .adv_w = 118, .box_w = 7, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 651, .adv_w = 44, .box_w = 3, .box_h = 7, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 662, .adv_w = 44, .box_w = 3, .box_h = 9, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 676, .adv_w = 112, .box_w = 7, .box_h = 7, .ofs_x = 0, .ofs_y = 1},\n    {.bitmap_index = 701, .adv_w = 112, .box_w = 7, .box_h = 5, .ofs_x = 0, .ofs_y = 2},\n    {.bitmap_index = 719, .adv_w = 112, .box_w = 7, .box_h = 7, .ofs_x = 0, .ofs_y = 1},\n    {.bitmap_index = 744, .adv_w = 110, .box_w = 7, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 776, .adv_w = 199, .box_w = 12, .box_h = 12, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 848, .adv_w = 141, .box_w = 10, .box_h = 9, .ofs_x = -1, .ofs_y = 0},\n    {.bitmap_index = 893, .adv_w = 145, .box_w = 8, .box_h = 9, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 929, .adv_w = 139, .box_w = 9, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 970, .adv_w = 159, .box_w = 9, .box_h = 9, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1011, .adv_w = 129, .box_w = 7, .box_h = 9, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1043, .adv_w = 122, .box_w = 7, .box_h = 9, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1075, .adv_w = 148, .box_w = 9, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 1116, .adv_w = 156, .box_w = 8, .box_h = 9, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1152, .adv_w = 60, .box_w = 2, .box_h = 9, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1161, .adv_w = 98, .box_w = 6, .box_h = 9, .ofs_x = -1, .ofs_y = 0},\n    {.bitmap_index = 1188, .adv_w = 138, .box_w = 8, .box_h = 9, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1224, .adv_w = 114, .box_w = 7, .box_h = 9, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1256, .adv_w = 183, .box_w = 10, .box_h = 9, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1301, .adv_w = 156, .box_w = 8, .box_h = 9, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1337, .adv_w = 161, .box_w = 10, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 1382, .adv_w = 139, .box_w = 8, .box_h = 9, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1418, .adv_w = 161, .box_w = 10, .box_h = 12, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 1478, .adv_w = 140, .box_w = 8, .box_h = 9, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1514, .adv_w = 119, .box_w = 7, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 1546, .adv_w = 113, .box_w = 7, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 1578, .adv_w = 152, .box_w = 8, .box_h = 9, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1614, .adv_w = 137, .box_w = 10, .box_h = 9, .ofs_x = -1, .ofs_y = 0},\n    {.bitmap_index = 1659, .adv_w = 216, .box_w = 14, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 1722, .adv_w = 129, .box_w = 8, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 1758, .adv_w = 124, .box_w = 9, .box_h = 9, .ofs_x = -1, .ofs_y = 0},\n    {.bitmap_index = 1799, .adv_w = 126, .box_w = 8, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 1835, .adv_w = 64, .box_w = 3, .box_h = 13, .ofs_x = 1, .ofs_y = -3},\n    {.bitmap_index = 1855, .adv_w = 68, .box_w = 6, .box_h = 13, .ofs_x = -1, .ofs_y = -1},\n    {.bitmap_index = 1894, .adv_w = 64, .box_w = 3, .box_h = 13, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 1914, .adv_w = 112, .box_w = 7, .box_h = 6, .ofs_x = 0, .ofs_y = 2},\n    {.bitmap_index = 1935, .adv_w = 96, .box_w = 6, .box_h = 1, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 1938, .adv_w = 115, .box_w = 4, .box_h = 2, .ofs_x = 1, .ofs_y = 8},\n    {.bitmap_index = 1942, .adv_w = 115, .box_w = 7, .box_h = 7, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 1967, .adv_w = 131, .box_w = 7, .box_h = 10, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2002, .adv_w = 110, .box_w = 7, .box_h = 7, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2027, .adv_w = 131, .box_w = 8, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2067, .adv_w = 118, .box_w = 7, .box_h = 7, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2092, .adv_w = 68, .box_w = 5, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2117, .adv_w = 132, .box_w = 8, .box_h = 10, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 2157, .adv_w = 131, .box_w = 7, .box_h = 10, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2192, .adv_w = 54, .box_w = 3, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2207, .adv_w = 55, .box_w = 5, .box_h = 13, .ofs_x = -2, .ofs_y = -3},\n    {.bitmap_index = 2240, .adv_w = 118, .box_w = 7, .box_h = 10, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2275, .adv_w = 54, .box_w = 2, .box_h = 10, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2285, .adv_w = 203, .box_w = 11, .box_h = 7, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2324, .adv_w = 131, .box_w = 7, .box_h = 7, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2349, .adv_w = 122, .box_w = 8, .box_h = 7, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2377, .adv_w = 131, .box_w = 7, .box_h = 10, .ofs_x = 1, .ofs_y = -3},\n    {.bitmap_index = 2412, .adv_w = 131, .box_w = 8, .box_h = 10, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 2452, .adv_w = 79, .box_w = 4, .box_h = 7, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2466, .adv_w = 96, .box_w = 6, .box_h = 7, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2487, .adv_w = 79, .box_w = 5, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2510, .adv_w = 130, .box_w = 7, .box_h = 7, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2535, .adv_w = 107, .box_w = 8, .box_h = 7, .ofs_x = -1, .ofs_y = 0},\n    {.bitmap_index = 2563, .adv_w = 173, .box_w = 11, .box_h = 7, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2602, .adv_w = 106, .box_w = 7, .box_h = 7, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2627, .adv_w = 107, .box_w = 8, .box_h = 10, .ofs_x = -1, .ofs_y = -3},\n    {.bitmap_index = 2667, .adv_w = 100, .box_w = 6, .box_h = 7, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2688, .adv_w = 67, .box_w = 4, .box_h = 13, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 2714, .adv_w = 57, .box_w = 2, .box_h = 13, .ofs_x = 1, .ofs_y = -3},\n    {.bitmap_index = 2727, .adv_w = 67, .box_w = 4, .box_h = 13, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 2753, .adv_w = 112, .box_w = 7, .box_h = 2, .ofs_x = 0, .ofs_y = 4},\n    {.bitmap_index = 2760, .adv_w = 80, .box_w = 5, .box_h = 5, .ofs_x = 0, .ofs_y = 5},\n    {.bitmap_index = 2773, .adv_w = 60, .box_w = 3, .box_h = 3, .ofs_x = 0, .ofs_y = 2},\n    {.bitmap_index = 2778, .adv_w = 192, .box_w = 12, .box_h = 13, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 2856, .adv_w = 192, .box_w = 12, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2910, .adv_w = 192, .box_w = 12, .box_h = 11, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 2976, .adv_w = 192, .box_w = 12, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 3030, .adv_w = 132, .box_w = 9, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 3071, .adv_w = 192, .box_w = 12, .box_h = 13, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 3149, .adv_w = 192, .box_w = 12, .box_h = 13, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 3227, .adv_w = 216, .box_w = 14, .box_h = 11, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 3304, .adv_w = 192, .box_w = 12, .box_h = 13, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 3382, .adv_w = 216, .box_w = 14, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 3445, .adv_w = 192, .box_w = 12, .box_h = 13, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 3523, .adv_w = 96, .box_w = 6, .box_h = 10, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 3553, .adv_w = 144, .box_w = 9, .box_h = 10, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 3598, .adv_w = 216, .box_w = 14, .box_h = 13, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 3689, .adv_w = 192, .box_w = 12, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 3743, .adv_w = 132, .box_w = 9, .box_h = 13, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 3802, .adv_w = 168, .box_w = 8, .box_h = 12, .ofs_x = 1, .ofs_y = -2},\n    {.bitmap_index = 3850, .adv_w = 168, .box_w = 11, .box_h = 13, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 3922, .adv_w = 168, .box_w = 11, .box_h = 11, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 3983, .adv_w = 168, .box_w = 11, .box_h = 11, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 4044, .adv_w = 168, .box_w = 8, .box_h = 12, .ofs_x = 1, .ofs_y = -2},\n    {.bitmap_index = 4092, .adv_w = 168, .box_w = 12, .box_h = 11, .ofs_x = -1, .ofs_y = -1},\n    {.bitmap_index = 4158, .adv_w = 120, .box_w = 7, .box_h = 11, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 4197, .adv_w = 120, .box_w = 7, .box_h = 11, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 4236, .adv_w = 168, .box_w = 11, .box_h = 11, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 4297, .adv_w = 168, .box_w = 11, .box_h = 3, .ofs_x = 0, .ofs_y = 3},\n    {.bitmap_index = 4314, .adv_w = 216, .box_w = 14, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 4377, .adv_w = 240, .box_w = 16, .box_h = 13, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 4481, .adv_w = 216, .box_w = 15, .box_h = 13, .ofs_x = -1, .ofs_y = -2},\n    {.bitmap_index = 4579, .adv_w = 192, .box_w = 12, .box_h = 11, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 4645, .adv_w = 168, .box_w = 11, .box_h = 7, .ofs_x = 0, .ofs_y = 1},\n    {.bitmap_index = 4684, .adv_w = 168, .box_w = 11, .box_h = 7, .ofs_x = 0, .ofs_y = 1},\n    {.bitmap_index = 4723, .adv_w = 240, .box_w = 16, .box_h = 10, .ofs_x = -1, .ofs_y = 0},\n    {.bitmap_index = 4803, .adv_w = 192, .box_w = 12, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 4857, .adv_w = 192, .box_w = 12, .box_h = 13, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 4935, .adv_w = 192, .box_w = 13, .box_h = 13, .ofs_x = -1, .ofs_y = -2},\n    {.bitmap_index = 5020, .adv_w = 168, .box_w = 11, .box_h = 11, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 5081, .adv_w = 168, .box_w = 11, .box_h = 13, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 5153, .adv_w = 168, .box_w = 11, .box_h = 11, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 5214, .adv_w = 168, .box_w = 11, .box_h = 11, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 5275, .adv_w = 192, .box_w = 12, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 5329, .adv_w = 120, .box_w = 9, .box_h = 13, .ofs_x = -1, .ofs_y = -2},\n    {.bitmap_index = 5388, .adv_w = 168, .box_w = 11, .box_h = 13, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 5460, .adv_w = 168, .box_w = 11, .box_h = 13, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 5532, .adv_w = 216, .box_w = 14, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 5595, .adv_w = 192, .box_w = 14, .box_h = 13, .ofs_x = -1, .ofs_y = -2},\n    {.bitmap_index = 5686, .adv_w = 144, .box_w = 9, .box_h = 13, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 5745, .adv_w = 240, .box_w = 15, .box_h = 12, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 5835, .adv_w = 240, .box_w = 15, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 5903, .adv_w = 240, .box_w = 15, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 5971, .adv_w = 240, .box_w = 15, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 6039, .adv_w = 240, .box_w = 15, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 6107, .adv_w = 240, .box_w = 15, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 6175, .adv_w = 240, .box_w = 16, .box_h = 11, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 6263, .adv_w = 168, .box_w = 10, .box_h = 13, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 6328, .adv_w = 168, .box_w = 11, .box_h = 13, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 6400, .adv_w = 192, .box_w = 13, .box_h = 13, .ofs_x = -1, .ofs_y = -2},\n    {.bitmap_index = 6485, .adv_w = 240, .box_w = 15, .box_h = 9, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 6553, .adv_w = 144, .box_w = 9, .box_h = 13, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 6612, .adv_w = 193, .box_w = 13, .box_h = 9, .ofs_x = 0, .ofs_y = 0}\n}", "sline": 1242}, "unicode_list_1": {"type": "Variable", "def": "static const uint16_t unicode_list_1[] = {\n    0x0, 0x1f72, 0xef51, 0xef58, 0xef5b, 0xef5c, 0xef5d, 0xef61,\n    0xef63, 0xef65, 0xef69, 0xef6c, 0xef71, 0xef76, 0xef77, 0xef78,\n    0xef8e, 0xef93, 0xef98, 0xef9b, 0xef9c, 0xef9d, 0xefa1, 0xefa2,\n    0xefa3, 0xefa4, 0xefb7, 0xefb8, 0xefbe, 0xefc0, 0xefc1, 0xefc4,\n    0xefc7, 0xefc8, 0xefc9, 0xefcb, 0xefe3, 0xefe5, 0xf014, 0xf015,\n    0xf017, 0xf019, 0xf030, 0xf037, 0xf03a, 0xf043, 0xf06c, 0xf074,\n    0xf0ab, 0xf13b, 0xf190, 0xf191, 0xf192, 0xf193, 0xf194, 0xf1d7,\n    0xf1e3, 0xf23d, 0xf254, 0xf4aa, 0xf712, 0xf7f2\n}", "sline": 1407}, "cmaps": {"type": "Variable", "def": "static const lv_font_fmt_txt_cmap_t cmaps[]", "sline": 1419}, "kern_left_class_mapping": {"type": "Variable", "def": "static const uint8_t kern_left_class_mapping[] =\n{\n    0, 0, 1, 2, 0, 3, 4, 5,\n    2, 6, 7, 8, 9, 10, 9, 10,\n    11, 12, 0, 13, 14, 15, 16, 17,\n    18, 19, 12, 20, 20, 0, 0, 0,\n    21, 22, 23, 24, 25, 22, 26, 27,\n    28, 29, 29, 30, 31, 32, 29, 29,\n    22, 33, 34, 35, 3, 36, 30, 37,\n    37, 38, 39, 40, 41, 42, 43, 0,\n    44, 0, 45, 46, 47, 48, 49, 50,\n    51, 45, 52, 52, 53, 48, 45, 45,\n    46, 46, 54, 55, 56, 57, 51, 58,\n    58, 59, 58, 60, 41, 0, 0, 9,\n    61, 9, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0\n}", "sline": 1437}, "kern_right_class_mapping": {"type": "Variable", "def": "static const uint8_t kern_right_class_mapping[] =\n{\n    0, 0, 1, 2, 0, 3, 4, 5,\n    2, 6, 7, 8, 9, 10, 9, 10,\n    11, 12, 13, 14, 15, 16, 17, 12,\n    18, 19, 20, 21, 21, 0, 0, 0,\n    22, 23, 24, 25, 23, 25, 25, 25,\n    23, 25, 25, 26, 25, 25, 25, 25,\n    23, 25, 23, 25, 3, 27, 28, 29,\n    29, 30, 31, 32, 33, 34, 35, 0,\n    36, 0, 37, 38, 39, 39, 39, 0,\n    39, 38, 40, 41, 38, 38, 42, 42,\n    39, 42, 39, 42, 43, 44, 45, 46,\n    46, 47, 46, 48, 0, 0, 35, 9,\n    49, 9, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0\n}", "sline": 1462}, "kern_class_values": {"type": "Variable", "def": "static const int8_t kern_class_values[] =\n{\n    0, 1, 0, 0, 0, 0, 0, 0,\n    0, 1, 0, 0, 2, 0, 0, 0,\n    0, 1, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 1, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 1, 9, 0, 5, -4, 0, 0,\n    0, 0, -11, -12, 1, 9, 4, 3,\n    -8, 1, 9, 1, 8, 2, 6, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 12, 2, -1, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 4, 0, -6, 0, 0, 0, 0,\n    0, -4, 3, 4, 0, 0, -2, 0,\n    -1, 2, 0, -2, 0, -2, -1, -4,\n    0, 0, 0, 0, -2, 0, 0, -2,\n    -3, 0, 0, -2, 0, -4, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, -2,\n    -2, 0, -3, 0, -5, 0, -23, 0,\n    0, -4, 0, 4, 6, 0, 0, -4,\n    2, 2, 6, 4, -3, 4, 0, 0,\n    -11, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -7, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, -5, -2, -9, 0, -8,\n    -1, 0, 0, 0, 0, 0, 7, 0,\n    -6, -2, -1, 1, 0, -3, 0, 0,\n    -1, -14, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -15, -2, 7,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -8, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 6,\n    0, 2, 0, 0, -4, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 7, 2,\n    1, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    -7, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 1,\n    4, 2, 6, -2, 0, 0, 4, -2,\n    -6, -26, 1, 5, 4, 0, -2, 0,\n    7, 0, 6, 0, 6, 0, -18, 0,\n    -2, 6, 0, 6, -2, 4, 2, 0,\n    0, 1, -2, 0, 0, -3, 15, 0,\n    15, 0, 6, 0, 8, 2, 3, 6,\n    0, 0, 0, -7, 0, 0, 0, 0,\n    1, -1, 0, 1, -3, -2, -4, 1,\n    0, -2, 0, 0, 0, -8, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, -12, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 1, -11, 0, -12, 0, 0, 0,\n    0, -1, 0, 19, -2, -2, 2, 2,\n    -2, 0, -2, 2, 0, 0, -10, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, -19, 0, 2, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, -12, 0, 12, 0, 0, -7, 0,\n    6, 0, -13, -19, -13, -4, 6, 0,\n    0, -13, 0, 2, -4, 0, -3, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 5, 6, -23, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 9, 0, 1, 0, 0, 0,\n    0, 0, 1, 1, -2, -4, 0, -1,\n    -1, -2, 0, 0, -1, 0, 0, 0,\n    -4, 0, -2, 0, -4, -4, 0, -5,\n    -6, -6, -4, 0, -4, 0, -4, 0,\n    0, 0, 0, -2, 0, 0, 2, 0,\n    1, -2, 0, 1, 0, 0, 0, 2,\n    -1, 0, 0, 0, -1, 2, 2, -1,\n    0, 0, 0, -4, 0, -1, 0, 0,\n    0, 0, 0, 1, 0, 2, -1, 0,\n    -2, 0, -3, 0, 0, -1, 0, 6,\n    0, 0, -2, 0, 0, 0, 0, 0,\n    -1, 1, -1, -1, 0, 0, -2, 0,\n    -2, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, -1, -1, 0, -2, -2, 0,\n    0, 0, 0, 0, 1, 0, 0, -1,\n    0, -2, -2, -2, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -1, 0, 0,\n    0, 0, -1, -2, 0, -3, 0, -6,\n    -1, -6, 4, 0, 0, -4, 2, 4,\n    5, 0, -5, -1, -2, 0, -1, -9,\n    2, -1, 1, -10, 2, 0, 0, 1,\n    -10, 0, -10, -2, -17, -1, 0, -10,\n    0, 4, 5, 0, 2, 0, 0, 0,\n    0, 0, 0, -3, -2, 0, -6, 0,\n    0, 0, -2, 0, 0, 0, -2, 0,\n    0, 0, 0, 0, -1, -1, 0, -1,\n    -2, 0, 0, 0, 0, 0, 0, 0,\n    -2, -2, 0, -1, -2, -2, 0, 0,\n    -2, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -2, -2, 0, -2,\n    0, -1, 0, -4, 2, 0, 0, -2,\n    1, 2, 2, 0, 0, 0, 0, 0,\n    0, -1, 0, 0, 0, 0, 0, 1,\n    0, 0, -2, 0, -2, -1, -2, 0,\n    0, 0, 0, 0, 0, 0, 2, 0,\n    -2, 0, 0, 0, 0, -2, -3, 0,\n    -4, 0, 6, -1, 1, -6, 0, 0,\n    5, -10, -10, -8, -4, 2, 0, -2,\n    -12, -3, 0, -3, 0, -4, 3, -3,\n    -12, 0, -5, 0, 0, 1, -1, 2,\n    -1, 0, 2, 0, -6, -7, 0, -10,\n    -5, -4, -5, -6, -2, -5, 0, -4,\n    -5, 1, 0, 1, 0, -2, 0, 0,\n    0, 1, 0, 2, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, -2,\n    0, -1, 0, -1, -2, 0, -3, -4,\n    -4, -1, 0, -6, 0, 0, 0, 0,\n    0, 0, -2, 0, 0, 0, 0, 1,\n    -1, 0, 0, 0, 2, 0, 0, 0,\n    0, 0, 0, 0, 0, 9, 0, 0,\n    0, 0, 0, 0, 1, 0, 0, 0,\n    -2, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -3, 0, 2, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -1, 0, 0, 0,\n    -4, 0, 0, 0, 0, -10, -6, 0,\n    0, 0, -3, -10, 0, 0, -2, 2,\n    0, -5, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -3, 0, 0, -4,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 2, 0, -3, 0,\n    0, 0, 0, 2, 0, 1, -4, -4,\n    0, -2, -2, -2, 0, 0, 0, 0,\n    0, 0, -6, 0, -2, 0, -3, -2,\n    0, -4, -5, -6, -2, 0, -4, 0,\n    -6, 0, 0, 0, 0, 15, 0, 0,\n    1, 0, 0, -2, 0, 2, 0, -8,\n    0, 0, 0, 0, 0, -18, -3, 6,\n    6, -2, -8, 0, 2, -3, 0, -10,\n    -1, -2, 2, -13, -2, 2, 0, 3,\n    -7, -3, -7, -6, -8, 0, 0, -12,\n    0, 11, 0, 0, -1, 0, 0, 0,\n    -1, -1, -2, -5, -6, 0, -18, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    1, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, -2, 0, -1, -2, -3, 0, 0,\n    -4, 0, -2, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, -1, 0, -4, 0, 0, 4,\n    -1, 2, 0, -4, 2, -1, -1, -5,\n    -2, 0, -2, -2, -1, 0, -3, -3,\n    0, 0, -2, -1, -1, -3, -2, 0,\n    0, -2, 0, 2, -1, 0, -4, 0,\n    0, 0, -4, 0, -3, 0, -3, -3,\n    2, 0, 0, 0, 0, 0, 0, 0,\n    0, -4, 2, 0, -3, 0, -1, -2,\n    -6, -1, -1, -1, -1, -1, -2, -1,\n    0, 0, 0, 0, 0, -2, -2, -2,\n    0, 0, 0, 0, 2, -1, 0, -1,\n    0, 0, 0, -1, -2, -1, -2, -2,\n    -2, 0, 2, 8, -1, 0, -5, 0,\n    -1, 4, 0, -2, -8, -2, 3, 0,\n    0, -9, -3, 2, -3, 1, 0, -1,\n    -2, -6, 0, -3, 1, 0, 0, -3,\n    0, 0, 0, 2, 2, -4, -4, 0,\n    -3, -2, -3, -2, -2, 0, -3, 1,\n    -4, -3, 6, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 2, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -3, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    -1, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, -2, -2,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -3, 0, 0, -2,\n    0, 0, -2, -2, 0, 0, 0, 0,\n    -2, 0, 0, 0, 0, -1, 0, 0,\n    0, 0, 0, -1, 0, 0, 0, 0,\n    -3, 0, -4, 0, 0, 0, -6, 0,\n    1, -4, 4, 0, -1, -9, 0, 0,\n    -4, -2, 0, -8, -5, -5, 0, 0,\n    -8, -2, -8, -7, -9, 0, -5, 0,\n    2, 13, -2, 0, -4, -2, -1, -2,\n    -3, -5, -3, -7, -8, -4, -2, 0,\n    0, -1, 0, 1, 0, 0, -13, -2,\n    6, 4, -4, -7, 0, 1, -6, 0,\n    -10, -1, -2, 4, -18, -2, 1, 0,\n    0, -12, -2, -10, -2, -14, 0, 0,\n    -13, 0, 11, 1, 0, -1, 0, 0,\n    0, 0, -1, -1, -7, -1, 0, -12,\n    0, 0, 0, 0, -6, 0, -2, 0,\n    -1, -5, -9, 0, 0, -1, -3, -6,\n    -2, 0, -1, 0, 0, 0, 0, -9,\n    -2, -6, -6, -2, -3, -5, -2, -3,\n    0, -4, -2, -6, -3, 0, -2, -4,\n    -2, -4, 0, 1, 0, -1, -6, 0,\n    4, 0, -3, 0, 0, 0, 0, 2,\n    0, 1, -4, 8, 0, -2, -2, -2,\n    0, 0, 0, 0, 0, 0, -6, 0,\n    -2, 0, -3, -2, 0, -4, -5, -6,\n    -2, 0, -4, 2, 8, 0, 0, 0,\n    0, 15, 0, 0, 1, 0, 0, -2,\n    0, 2, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    -1, -4, 0, 0, 0, 0, 0, -1,\n    0, 0, 0, -2, -2, 0, 0, -4,\n    -2, 0, 0, -4, 0, 3, -1, 0,\n    0, 0, 0, 0, 0, 1, 0, 0,\n    0, 0, 3, 4, 2, -2, 0, -6,\n    -3, 0, 6, -6, -6, -4, -4, 8,\n    3, 2, -17, -1, 4, -2, 0, -2,\n    2, -2, -7, 0, -2, 2, -2, -2,\n    -6, -2, 0, 0, 6, 4, 0, -5,\n    0, -11, -2, 6, -2, -7, 1, -2,\n    -6, -6, -2, 8, 2, 0, -3, 0,\n    -5, 0, 2, 6, -4, -7, -8, -5,\n    6, 0, 1, -14, -2, 2, -3, -1,\n    -4, 0, -4, -7, -3, -3, -2, 0,\n    0, -4, -4, -2, 0, 6, 4, -2,\n    -11, 0, -11, -3, 0, -7, -11, -1,\n    -6, -3, -6, -5, 5, 0, 0, -2,\n    0, -4, -2, 0, -2, -3, 0, 3,\n    -6, 2, 0, 0, -10, 0, -2, -4,\n    -3, -1, -6, -5, -6, -4, 0, -6,\n    -2, -4, -4, -6, -2, 0, 0, 1,\n    9, -3, 0, -6, -2, 0, -2, -4,\n    -4, -5, -5, -7, -2, -4, 4, 0,\n    -3, 0, -10, -2, 1, 4, -6, -7,\n    -4, -6, 6, -2, 1, -18, -3, 4,\n    -4, -3, -7, 0, -6, -8, -2, -2,\n    -2, -2, -4, -6, -1, 0, 0, 6,\n    5, -1, -12, 0, -12, -4, 5, -7,\n    -13, -4, -7, -8, -10, -6, 4, 0,\n    0, 0, 0, -2, 0, 0, 2, -2,\n    4, 1, -4, 4, 0, 0, -6, -1,\n    0, -1, 0, 1, 1, -2, 0, 0,\n    0, 0, 0, 0, -2, 0, 0, 0,\n    0, 2, 6, 0, 0, -2, 0, 0,\n    0, 0, -1, -1, -2, 0, 0, 0,\n    1, 2, 0, 0, 0, 0, 2, 0,\n    -2, 0, 7, 0, 3, 1, 1, -2,\n    0, 4, 0, 0, 0, 2, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 6, 0, 5, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, -12, 0, -2, 3, 0, 6,\n    0, 0, 19, 2, -4, -4, 2, 2,\n    -1, 1, -10, 0, 0, 9, -12, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, -13, 7, 27, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, -12, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -3, 0, 0, -4,\n    -2, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -1, 0, -5, 0,\n    0, 1, 0, 0, 2, 25, -4, -2,\n    6, 5, -5, 2, 0, 0, 2, 2,\n    -2, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -25, 5, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, -5,\n    0, 0, 0, -5, 0, 0, 0, 0,\n    -4, -1, 0, 0, 0, -4, 0, -2,\n    0, -9, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -13, 0, 0,\n    0, 0, 1, 0, 0, 0, 0, 0,\n    0, -2, 0, 0, -4, 0, -3, 0,\n    -5, 0, 0, 0, -3, 2, -2, 0,\n    0, -5, -2, -4, 0, 0, -5, 0,\n    -2, 0, -9, 0, -2, 0, 0, -16,\n    -4, -8, -2, -7, 0, 0, -13, 0,\n    -5, -1, 0, 0, 0, 0, 0, 0,\n    0, 0, -3, -3, -2, -3, 0, 0,\n    0, 0, -4, 0, -4, 2, -2, 4,\n    0, -1, -4, -1, -3, -4, 0, -2,\n    -1, -1, 1, -5, -1, 0, 0, 0,\n    -17, -2, -3, 0, -4, 0, -1, -9,\n    -2, 0, 0, -1, -2, 0, 0, 0,\n    0, 1, 0, -1, -3, -1, 3, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 2, 0, 0, 0, 0, 0,\n    0, -4, 0, -1, 0, 0, 0, -4,\n    2, 0, 0, 0, -5, -2, -4, 0,\n    0, -5, 0, -2, 0, -9, 0, 0,\n    0, 0, -19, 0, -4, -7, -10, 0,\n    0, -13, 0, -1, -3, 0, 0, 0,\n    0, 0, 0, 0, 0, -2, -3, -1,\n    -3, 1, 0, 0, 3, -2, 0, 6,\n    9, -2, -2, -6, 2, 9, 3, 4,\n    -5, 2, 8, 2, 6, 4, 5, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 12, 9, -3, -2, 0, -2,\n    15, 8, 15, 0, 0, 0, 2, 0,\n    0, 7, 0, 0, -3, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, -1, 0,\n    0, 0, 0, 0, 0, 0, 0, 3,\n    0, 0, 0, 0, -16, -2, -2, -8,\n    -9, 0, 0, -13, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -3, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, -1,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    3, 0, 0, 0, 0, -16, -2, -2,\n    -8, -9, 0, 0, -8, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    -2, 0, 0, 0, -4, 2, 0, -2,\n    2, 3, 2, -6, 0, 0, -2, 2,\n    0, 2, 0, 0, 0, 0, -5, 0,\n    -2, -1, -4, 0, -2, -8, 0, 12,\n    -2, 0, -4, -1, 0, -1, -3, 0,\n    -2, -5, -4, -2, 0, 0, 0, -3,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, -1, 0, 0, 0, 0, 0, 0,\n    0, 0, 3, 0, 0, 0, 0, -16,\n    -2, -2, -8, -9, 0, 0, -13, 0,\n    0, 0, 0, 0, 0, 10, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    -3, 0, -6, -2, -2, 6, -2, -2,\n    -8, 1, -1, 1, -1, -5, 0, 4,\n    0, 2, 1, 2, -5, -8, -2, 0,\n    -7, -4, -5, -8, -7, 0, -3, -4,\n    -2, -2, -2, -1, -2, -1, 0, -1,\n    -1, 3, 0, 3, -1, 0, 6, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, -1, -2, -2, 0, 0,\n    -5, 0, -1, 0, -3, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    -12, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -2, -2, 0, -2,\n    0, 0, 0, 0, -2, 0, 0, -3,\n    -2, 2, 0, -3, -4, -1, 0, -6,\n    -1, -4, -1, -2, 0, -3, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, -13, 0, 6, 0, 0, -3, 0,\n    0, 0, 0, -2, 0, -2, 0, 0,\n    -1, 0, 0, -1, 0, -4, 0, 0,\n    8, -2, -6, -6, 1, 2, 2, 0,\n    -5, 1, 3, 1, 6, 1, 6, -1,\n    -5, 0, 0, -8, 0, 0, -6, -5,\n    0, 0, -4, 0, -2, -3, 0, -3,\n    0, -3, 0, -1, 3, 0, -2, -6,\n    -2, 7, 0, 0, -2, 0, -4, 0,\n    0, 2, -4, 0, 2, -2, 2, 0,\n    0, -6, 0, -1, -1, 0, -2, 2,\n    -2, 0, 0, 0, -8, -2, -4, 0,\n    -6, 0, 0, -9, 0, 7, -2, 0,\n    -3, 0, 1, 0, -2, 0, -2, -6,\n    0, -2, 2, 0, 0, 0, 0, -1,\n    0, 0, 2, -2, 1, 0, 0, -2,\n    -1, 0, -2, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -12, 0, 4, 0,\n    0, -2, 0, 0, 0, 0, 0, 0,\n    -2, -2, 0, 0, 0, 4, 0, 4,\n    0, 0, 0, 0, 0, -12, -11, 1,\n    8, 6, 3, -8, 1, 8, 0, 7,\n    0, 4, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 10, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0\n}", "sline": 1487}, "kern_classes": {"type": "Variable", "def": "static const lv_font_fmt_txt_kern_classes_t kern_classes =\n{\n    .class_pair_values   = kern_class_values,\n    .left_class_mapping  = kern_left_class_mapping,\n    .right_class_mapping = kern_right_class_mapping,\n    .left_class_cnt      = 61,\n    .right_class_cnt     = 49,\n}", "sline": 1867}, "cache": {"type": "Variable", "def": "static  lv_font_fmt_txt_glyph_cache_t cache", "sline": 1882}, "font_dsc": {"type": "Variable", "def": "static const lv_font_fmt_txt_dsc_t font_dsc = {\n#else\nstatic lv_font_fmt_txt_dsc_t font_dsc = {\n#endif\n    .glyph_bitmap = glyph_bitmap,\n    .glyph_dsc = glyph_dsc,\n    .cmaps = cmaps,\n    .kern_dsc = &kern_classes,\n    .kern_scale = 16,\n    .cmap_num = 2,\n    .bpp = 4,\n    .kern_classes = 1,\n    .bitmap_format = 0,\n#if LV_VERSION_CHECK(8, 0, 0)\n    .cache = &cache\n#endif\n}", "sline": 1883}, "lv_font_montserrat_12": {"type": "Variable", "def": "const lv_font_t lv_font_montserrat_12 = {\n#else\nlv_font_t lv_font_montserrat_12 = {\n#endif\n    .get_glyph_dsc = lv_font_get_glyph_dsc_fmt_txt,    /*Function pointer to get glyph's data*/\n    .get_glyph_bitmap = lv_font_get_bitmap_fmt_txt,    /*Function pointer to get glyph's bitmap*/\n    .line_height = 15,          /*The maximum line height required by the font*/\n    .base_line = 3,             /*Baseline measured from the bottom of the line*/\n#if !(LVGL_VERSION_MAJOR == 6 && LVGL_VERSION_MINOR == 0)\n    .subpx = LV_FONT_SUBPX_NONE,\n#endif\n#if LV_VERSION_CHECK(7, 4, 0)\n    .underline_position = -1,\n    .underline_thickness = 1,\n#endif\n    .dsc = &font_dsc           /*The custom font data. Will be accessed by `get_glyph_bitmap/dsc` */\n}", "sline": 1908}, "carbit_updater/lvgl/src/font/lv_font_montserrat_12.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_12.c"}}, "carbit_updater/lvgl/src/misc/lv_printf.h": {"inttypes": {"type": "Variable", "def": "#include inttypes.h", "sline": 39}, "lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 57}, "stdarg": {"type": "Variable", "def": "#include stdarg.h", "sline": 61}, "stddef": {"type": "Variable", "def": "#include stddef.h", "sline": 62}, "lv_types": {"type": "Variable", "def": "#include lv_types.h", "sline": 64, "include": ["carbit_updater/lvgl/src/misc/lv_types.h", null]}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_printf.h:66:9).fmt": {"type": "Variable", "def": "const char * fmt", "sline": 67, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_printf.h:66:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_printf.h:66:9).va": {"type": "Variable", "def": "va_list * va", "sline": 68, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_printf.h:66:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_printf.h:66:9)": {"type": "Struct", "def": "struct {\n  const char * fmt;\n  va_list * va;\n}", "sline": 66, "body": "const char * fmt\nva_list * va\n"}, "lv_vaformat_t": {"type": "Variable", "def": "typedef struct {\n  const char * fmt;\n  va_list * va;\n} lv_vaformat_t", "sline": 69}, "lv_snprintf": {"type": "Function", "def": "int  lv_snprintf(char * buffer, size_t count, const char * format, ...) LV_FORMAT_ATTRIBUTE(3, 4)", "sline": 81}, "lv_vsnprintf": {"type": "Function", "def": "int lv_vsnprintf(char * buffer, size_t count, const char * format, va_list va) LV_FORMAT_ATTRIBUTE(3, 0)", "sline": 82}, "carbit_updater/lvgl/src/misc/lv_printf.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_printf.h"}}, "carbit_updater/lvgl/src/widgets/lv_checkbox.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "lv_obj": {"type": "Variable", "def": "#include ../core/lv_obj.h", "sline": 17}, "lv_checkbox_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 30, "in_struct": "lv_checkbox_t"}, "lv_checkbox_t.txt": {"type": "Variable", "def": "char * txt", "sline": 31, "in_struct": "lv_checkbox_t"}, "lv_checkbox_t.static_txt": {"type": "Variable", "def": "uint32_t static_txt : 1", "sline": 32, "in_struct": "lv_checkbox_t"}, "lv_checkbox_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    char * txt;\n    uint32_t static_txt : 1;\n} lv_checkbox_t", "sline": 33}, "lv_checkbox_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_checkbox_class", "sline": 35}, "lv_checkbox_draw_part_type_t": {"type": "Variable", "def": "typedef enum {\n    LV_CHECKBOX_DRAW_PART_BOX,    /**< The tick box*/\n} lv_checkbox_draw_part_type_t", "sline": 43}, "lv_checkbox_create": {"type": "Function", "def": "lv_obj_t * lv_checkbox_create(lv_obj_t * parent)", "sline": 54}, "lv_checkbox_set_text": {"type": "Function", "def": "void lv_checkbox_set_text(lv_obj_t * obj, const char * txt)", "sline": 66}, "lv_checkbox_set_text_static": {"type": "Function", "def": "void lv_checkbox_set_text_static(lv_obj_t * obj, const char * txt)", "sline": 74}, "lv_checkbox_get_text": {"type": "Function", "def": "const char * lv_checkbox_get_text(const lv_obj_t * obj)", "sline": 85}, "carbit_updater/lvgl/src/widgets/lv_checkbox.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_checkbox.h"}}, "carbit_updater/lvgl/tests/src/test_cases/test_style.c": {"carbit_updater/lvgl/tests/src/test_cases/test_style.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/tests/src/test_cases/test_style.c"}}, "carbit_updater/lvgl/src/extra/libs/bmp/lv_bmp.c": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 9}, "carbit_updater/lvgl/src/extra/libs/bmp/lv_bmp.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/bmp/lv_bmp.c"}}, "carbit_updater/lvgl/src/core/lv_obj_class.h": {"stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 16}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 17}, "_lv_obj_t": {"type": "Struct", "def": "struct _lv_obj_t", "sline": 28}, "_lv_obj_class_t": {"type": "Struct", "def": "struct _lv_obj_class_t {\n    const struct _lv_obj_class_t * base_class;\n    void (*constructor_cb)(const struct _lv_obj_class_t * class_p, struct _lv_obj_t * obj);\n    void (*destructor_cb)(const struct _lv_obj_class_t * class_p, struct _lv_obj_t * obj);\n#if LV_USE_USER_DATA\n    void * user_data;\n#endif\n    void (*event_cb)(const struct _lv_obj_class_t * class_p,\n                     struct _lv_event_t * e);  /**< Widget type specific event function*/\n    lv_coord_t width_def;\n    lv_coord_t height_def;\n    uint32_t editable : 2;             /**< Value from ::lv_obj_class_editable_t*/\n    uint32_t group_def : 2;            /**< Value from ::lv_obj_class_group_def_t*/\n    uint32_t instance_size : 16;\n}", "sline": 49, "body": "const struct _lv_obj_class_t * base_class\nvoid (*constructor_cb)(const struct _lv_obj_class_t * class_p, struct _lv_obj_t * obj)\nvoid (*destructor_cb)(const struct _lv_obj_class_t * class_p, struct _lv_obj_t * obj)\nvoid (*event_cb)(const struct _lv_obj_class_t * class_p,\n                     struct _lv_event_t * e)\nlv_coord_t width_def\nlv_coord_t height_def\nuint32_t editable : 2\nuint32_t group_def : 2\nuint32_t instance_size : 16\n"}, "_lv_event_t": {"type": "Struct", "def": "struct _lv_event_t", "sline": 30}, "lv_obj_class_editable_t": {"type": "Variable", "def": "typedef enum {\n    LV_OBJ_CLASS_EDITABLE_INHERIT,      /**< Check the base class. Must have 0 value to let zero initialized class inherit*/\n    LV_OBJ_CLASS_EDITABLE_TRUE,\n    LV_OBJ_CLASS_EDITABLE_FALSE,\n} lv_obj_class_editable_t", "sline": 36}, "lv_obj_class_group_def_t": {"type": "Variable", "def": "typedef enum {\n    LV_OBJ_CLASS_GROUP_DEF_INHERIT,      /**< Check the base class. Must have 0 value to let zero initialized class inherit*/\n    LV_OBJ_CLASS_GROUP_DEF_TRUE,\n    LV_OBJ_CLASS_GROUP_DEF_FALSE,\n} lv_obj_class_group_def_t", "sline": 42}, "lv_obj_class_event_cb_t": {"type": "Variable", "def": "typedef void (*lv_obj_class_event_cb_t)(struct _lv_obj_class_t * class_p, struct _lv_event_t * e)", "sline": 44}, "_lv_obj_class_t.base_class": {"type": "Variable", "def": "const struct _lv_obj_class_t * base_class", "sline": 50, "in_struct": "_lv_obj_class_t"}, "_lv_obj_class_t.constructor_cb": {"type": "Variable", "def": "void (*constructor_cb)(const struct _lv_obj_class_t * class_p, struct _lv_obj_t * obj)", "sline": 51, "in_struct": "_lv_obj_class_t"}, "_lv_obj_class_t.destructor_cb": {"type": "Variable", "def": "void (*destructor_cb)(const struct _lv_obj_class_t * class_p, struct _lv_obj_t * obj)", "sline": 52, "in_struct": "_lv_obj_class_t"}, "_lv_obj_class_t.event_cb": {"type": "Variable", "def": "void (*event_cb)(const struct _lv_obj_class_t * class_p,\n                     struct _lv_event_t * e)", "sline": 56, "in_struct": "_lv_obj_class_t"}, "_lv_obj_class_t.width_def": {"type": "Variable", "def": "lv_coord_t width_def", "sline": 58, "in_struct": "_lv_obj_class_t"}, "_lv_obj_class_t.height_def": {"type": "Variable", "def": "lv_coord_t height_def", "sline": 59, "in_struct": "_lv_obj_class_t"}, "_lv_obj_class_t.editable": {"type": "Variable", "def": "uint32_t editable : 2", "sline": 60, "in_struct": "_lv_obj_class_t"}, "_lv_obj_class_t.group_def": {"type": "Variable", "def": "uint32_t group_def : 2", "sline": 61, "in_struct": "_lv_obj_class_t"}, "_lv_obj_class_t.instance_size": {"type": "Variable", "def": "uint32_t instance_size : 16", "sline": 62, "in_struct": "_lv_obj_class_t"}, "lv_obj_class_t": {"type": "Variable", "def": "typedef struct _lv_obj_class_t {\n    const struct _lv_obj_class_t * base_class;\n    void (*constructor_cb)(const struct _lv_obj_class_t * class_p, struct _lv_obj_t * obj);\n    void (*destructor_cb)(const struct _lv_obj_class_t * class_p, struct _lv_obj_t * obj);\n#if LV_USE_USER_DATA\n    void * user_data;\n#endif\n    void (*event_cb)(const struct _lv_obj_class_t * class_p,\n                     struct _lv_event_t * e);  /**< Widget type specific event function*/\n    lv_coord_t width_def;\n    lv_coord_t height_def;\n    uint32_t editable : 2;             /**< Value from ::lv_obj_class_editable_t*/\n    uint32_t group_def : 2;            /**< Value from ::lv_obj_class_group_def_t*/\n    uint32_t instance_size : 16;\n} lv_obj_class_t", "sline": 63}, "lv_obj_class_create_obj": {"type": "Function", "def": "struct _lv_obj_t * lv_obj_class_create_obj(const struct _lv_obj_class_t * class_p, struct _lv_obj_t * parent)", "sline": 75}, "lv_obj_class_init_obj": {"type": "Function", "def": "void lv_obj_class_init_obj(struct _lv_obj_t * obj)", "sline": 77}, "_lv_obj_destruct": {"type": "Function", "def": "void _lv_obj_destruct(struct _lv_obj_t * obj)", "sline": 79}, "lv_obj_is_editable": {"type": "Function", "def": "bool lv_obj_is_editable(struct _lv_obj_t * obj)", "sline": 81}, "lv_obj_is_group_def": {"type": "Function", "def": "bool lv_obj_is_group_def(struct _lv_obj_t * obj)", "sline": 83}, "carbit_updater/lvgl/src/core/lv_obj_class.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_class.h"}}, "carbit_updater/lvgl/src/gpu/lv_gpu_nxp_pxp.h": {"lv_area": {"type": "Variable", "def": "#include ../misc/lv_area.h", "sline": 41}, "lv_color": {"type": "Variable", "def": "#include ../misc/lv_color.h", "sline": 42}, "lv_nxp_pxp_cfg_t.pxp_interrupt_init": {"type": "Variable", "def": "lv_res_t (*pxp_interrupt_init)(void)", "sline": 88, "in_struct": "lv_nxp_pxp_cfg_t"}, "lv_nxp_pxp_cfg_t.pxp_interrupt_deinit": {"type": "Variable", "def": "void (*pxp_interrupt_deinit)(void)", "sline": 91, "in_struct": "lv_nxp_pxp_cfg_t"}, "lv_nxp_pxp_cfg_t.pxp_run": {"type": "Variable", "def": "void (*pxp_run)(void)", "sline": 94, "in_struct": "lv_nxp_pxp_cfg_t"}, "lv_nxp_pxp_cfg_t": {"type": "Variable", "def": "typedef struct {\n    /** Callback for PXP interrupt initialization*/\n    lv_res_t (*pxp_interrupt_init)(void);\n\n    /** Callback for PXP interrupt de-initialization*/\n    void (*pxp_interrupt_deinit)(void);\n\n    /** Callback that should start PXP and wait for operation complete*/\n    void (*pxp_run)(void);\n} lv_nxp_pxp_cfg_t", "sline": 95}, "lv_gpu_nxp_pxp_init": {"type": "Function", "def": "lv_res_t lv_gpu_nxp_pxp_init(lv_nxp_pxp_cfg_t * cfg)", "sline": 115}, "lv_gpu_nxp_pxp_deinit": {"type": "Function", "def": "void lv_gpu_nxp_pxp_deinit(void)", "sline": 120}, "lv_gpu_nxp_pxp_fill": {"type": "Function", "def": "void lv_gpu_nxp_pxp_fill(lv_color_t * dest_buf, lv_coord_t dest_width, const lv_area_t * fill_area, lv_color_t color,\n                         lv_opa_t opa)", "sline": 131}, "lv_gpu_nxp_pxp_blit": {"type": "Function", "def": "void lv_gpu_nxp_pxp_blit(lv_color_t * dest, lv_coord_t dest_width, const lv_color_t * src, lv_coord_t src_width,\n                         lv_coord_t copy_width, lv_coord_t copy_height, lv_opa_t opa)", "sline": 150}, "lv_gpu_nxp_pxp_enable_color_key": {"type": "Function", "def": "void lv_gpu_nxp_pxp_enable_color_key(void)", "sline": 158}, "lv_gpu_nxp_pxp_disable_color_key": {"type": "Function", "def": "void lv_gpu_nxp_pxp_disable_color_key(void)", "sline": 164}, "lv_gpu_nxp_pxp_enable_recolor": {"type": "Function", "def": "void lv_gpu_nxp_pxp_enable_recolor(lv_color_t color, lv_opa_t opa)", "sline": 172}, "lv_gpu_nxp_pxp_disable_recolor": {"type": "Function", "def": "void lv_gpu_nxp_pxp_disable_recolor(void)", "sline": 177}, "carbit_updater/lvgl/src/gpu/lv_gpu_nxp_pxp.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_pxp.h"}}, "carbit_updater/lvgl/tests/src/test_cases/test_font_loader.c": {"carbit_updater/lvgl/tests/src/test_cases/test_font_loader.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/tests/src/test_cases/test_font_loader.c"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_20.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_montserrat_20.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_20.c"}}, "carbit_updater/lvgl/src/extra/libs/png/lv_png.c": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 9}, "carbit_updater/lvgl/src/extra/libs/png/lv_png.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/png/lv_png.c"}}, "carbit_updater/lvgl/src/extra/layouts/grid/lv_grid.h": {"lv_obj": {"type": "Variable", "def": "#include ../../../core/lv_obj.h", "sline": 16}, "_silence_gcc_warning": {"type": "Struct", "def": "LV_EXPORT_CONST_INT(LV_GRID_TEMPLATE_LAST)", "sline": 33}, "_lv_obj_t": {"type": "Struct", "def": "struct _lv_obj_t", "sline": 40, "docstring": "/*Can't include lv_obj.h because it includes this header file*/"}, "lv_grid_align_t": {"type": "Variable", "def": "typedef enum {\n    LV_GRID_ALIGN_START,\n    LV_GRID_ALIGN_CENTER,\n    LV_GRID_ALIGN_END,\n    LV_GRID_ALIGN_STRETCH,\n    LV_GRID_ALIGN_SPACE_EVENLY,\n    LV_GRID_ALIGN_SPACE_AROUND,\n    LV_GRID_ALIGN_SPACE_BETWEEN,\n} lv_grid_align_t", "sline": 50, "docstring": "/*Can't include lv_obj.h because it includes this header file*/"}, "LV_LAYOUT_GRID": {"type": "Variable", "def": "extern uint32_t LV_LAYOUT_GRID", "sline": 56}, "LV_STYLE_GRID_COLUMN_DSC_ARRAY": {"type": "Variable", "def": "extern lv_style_prop_t LV_STYLE_GRID_COLUMN_DSC_ARRAY", "sline": 57}, "LV_STYLE_GRID_COLUMN_ALIGN": {"type": "Variable", "def": "extern lv_style_prop_t LV_STYLE_GRID_COLUMN_ALIGN", "sline": 58}, "LV_STYLE_GRID_ROW_DSC_ARRAY": {"type": "Variable", "def": "extern lv_style_prop_t LV_STYLE_GRID_ROW_DSC_ARRAY", "sline": 59}, "LV_STYLE_GRID_ROW_ALIGN": {"type": "Variable", "def": "extern lv_style_prop_t LV_STYLE_GRID_ROW_ALIGN", "sline": 60}, "LV_STYLE_GRID_CELL_COLUMN_POS": {"type": "Variable", "def": "extern lv_style_prop_t LV_STYLE_GRID_CELL_COLUMN_POS", "sline": 61}, "LV_STYLE_GRID_CELL_COLUMN_SPAN": {"type": "Variable", "def": "extern lv_style_prop_t LV_STYLE_GRID_CELL_COLUMN_SPAN", "sline": 62}, "LV_STYLE_GRID_CELL_X_ALIGN": {"type": "Variable", "def": "extern lv_style_prop_t LV_STYLE_GRID_CELL_X_ALIGN", "sline": 63}, "LV_STYLE_GRID_CELL_ROW_POS": {"type": "Variable", "def": "extern lv_style_prop_t LV_STYLE_GRID_CELL_ROW_POS", "sline": 64}, "LV_STYLE_GRID_CELL_ROW_SPAN": {"type": "Variable", "def": "extern lv_style_prop_t LV_STYLE_GRID_CELL_ROW_SPAN", "sline": 65}, "LV_STYLE_GRID_CELL_Y_ALIGN": {"type": "Variable", "def": "extern lv_style_prop_t LV_STYLE_GRID_CELL_Y_ALIGN", "sline": 66}, "lv_grid_init": {"type": "Function", "def": "void lv_grid_init(void)", "sline": 72}, "lv_obj_set_grid_dsc_array": {"type": "Function", "def": "void lv_obj_set_grid_dsc_array(lv_obj_t * obj, const lv_coord_t col_dsc[], const lv_coord_t row_dsc[])", "sline": 74}, "lv_obj_set_grid_align": {"type": "Function", "def": "void lv_obj_set_grid_align(lv_obj_t * obj, lv_grid_align_t column_align, lv_grid_align_t row_align)", "sline": 76}, "lv_obj_set_grid_cell": {"type": "Function", "def": "void lv_obj_set_grid_cell(lv_obj_t * obj, lv_grid_align_t column_align, uint8_t col_pos, uint8_t col_span,\n                          lv_grid_align_t row_align, uint8_t row_pos, uint8_t row_span)", "sline": 88}, "lv_grid_fr": {"type": "Function", "def": "static inline lv_coord_t lv_grid_fr(uint8_t x)", "sline": 94, "docstring": "/**", "body": "{\n    return LV_GRID_FR(x);\n}"}, "lv_style_set_grid_row_dsc_array": {"type": "Function", "def": "void lv_style_set_grid_row_dsc_array(lv_style_t * style, const lv_coord_t value[])", "sline": 99}, "lv_style_set_grid_column_dsc_array": {"type": "Function", "def": "void lv_style_set_grid_column_dsc_array(lv_style_t * style, const lv_coord_t value[])", "sline": 100}, "lv_style_set_grid_row_align": {"type": "Function", "def": "void lv_style_set_grid_row_align(lv_style_t * style, lv_grid_align_t value)", "sline": 101}, "lv_style_set_grid_column_align": {"type": "Function", "def": "void lv_style_set_grid_column_align(lv_style_t * style, lv_grid_align_t value)", "sline": 102}, "lv_style_set_grid_cell_column_pos": {"type": "Function", "def": "void lv_style_set_grid_cell_column_pos(lv_style_t * style, lv_coord_t value)", "sline": 103}, "lv_style_set_grid_cell_column_span": {"type": "Function", "def": "void lv_style_set_grid_cell_column_span(lv_style_t * style, lv_coord_t value)", "sline": 104}, "lv_style_set_grid_cell_row_pos": {"type": "Function", "def": "void lv_style_set_grid_cell_row_pos(lv_style_t * style, lv_coord_t value)", "sline": 105}, "lv_style_set_grid_cell_row_span": {"type": "Function", "def": "void lv_style_set_grid_cell_row_span(lv_style_t * style, lv_coord_t value)", "sline": 106}, "lv_style_set_grid_cell_x_align": {"type": "Function", "def": "void lv_style_set_grid_cell_x_align(lv_style_t * style, lv_coord_t value)", "sline": 107}, "lv_style_set_grid_cell_y_align": {"type": "Function", "def": "void lv_style_set_grid_cell_y_align(lv_style_t * style, lv_coord_t value)", "sline": 108}, "lv_obj_set_style_grid_row_dsc_array": {"type": "Function", "def": "void lv_obj_set_style_grid_row_dsc_array(lv_obj_t * obj, const lv_coord_t value[], lv_style_selector_t selector)", "sline": 110}, "lv_obj_set_style_grid_column_dsc_array": {"type": "Function", "def": "void lv_obj_set_style_grid_column_dsc_array(lv_obj_t * obj, const lv_coord_t value[], lv_style_selector_t selector)", "sline": 111}, "lv_obj_set_style_grid_row_align": {"type": "Function", "def": "void lv_obj_set_style_grid_row_align(lv_obj_t * obj, lv_grid_align_t value, lv_style_selector_t selector)", "sline": 112}, "lv_obj_set_style_grid_column_align": {"type": "Function", "def": "void lv_obj_set_style_grid_column_align(lv_obj_t * obj, lv_grid_align_t value, lv_style_selector_t selector)", "sline": 113}, "lv_obj_set_style_grid_cell_column_pos": {"type": "Function", "def": "void lv_obj_set_style_grid_cell_column_pos(lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 114}, "lv_obj_set_style_grid_cell_column_span": {"type": "Function", "def": "void lv_obj_set_style_grid_cell_column_span(lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 115}, "lv_obj_set_style_grid_cell_row_pos": {"type": "Function", "def": "void lv_obj_set_style_grid_cell_row_pos(lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 116}, "lv_obj_set_style_grid_cell_row_span": {"type": "Function", "def": "void lv_obj_set_style_grid_cell_row_span(lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 117}, "lv_obj_set_style_grid_cell_x_align": {"type": "Function", "def": "void lv_obj_set_style_grid_cell_x_align(lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 118}, "lv_obj_set_style_grid_cell_y_align": {"type": "Function", "def": "void lv_obj_set_style_grid_cell_y_align(lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 119}, "lv_obj_get_style_grid_row_dsc_array": {"type": "Function", "def": "static inline const lv_coord_t * lv_obj_get_style_grid_row_dsc_array(const lv_obj_t * obj, uint32_t part)", "sline": 121, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_GRID_ROW_DSC_ARRAY);\n    return (const lv_coord_t *)v.ptr;\n}"}, "lv_obj_get_style_grid_column_dsc_array": {"type": "Function", "def": "static inline const lv_coord_t * lv_obj_get_style_grid_column_dsc_array(const lv_obj_t * obj, uint32_t part)", "sline": 127, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_GRID_COLUMN_DSC_ARRAY);\n    return (const lv_coord_t *)v.ptr;\n}"}, "lv_obj_get_style_grid_row_align": {"type": "Function", "def": "static inline lv_grid_align_t lv_obj_get_style_grid_row_align(const lv_obj_t * obj, uint32_t part)", "sline": 133, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_GRID_ROW_ALIGN);\n    return (lv_grid_align_t)v.num;\n}", "rels": [["lv_grid_align_t", null, "Typeof"]]}, "lv_obj_get_style_grid_column_align": {"type": "Function", "def": "static inline lv_grid_align_t lv_obj_get_style_grid_column_align(const lv_obj_t * obj, uint32_t part)", "sline": 139, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_GRID_COLUMN_ALIGN);\n    return (lv_grid_align_t)v.num;\n}", "rels": [["lv_grid_align_t", null, "Typeof"]]}, "lv_obj_get_style_grid_cell_column_pos": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_grid_cell_column_pos(const lv_obj_t * obj, uint32_t part)", "sline": 145, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_GRID_CELL_COLUMN_POS);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_grid_cell_column_span": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_grid_cell_column_span(const lv_obj_t * obj, uint32_t part)", "sline": 151, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_GRID_CELL_COLUMN_SPAN);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_grid_cell_row_pos": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_grid_cell_row_pos(const lv_obj_t * obj, uint32_t part)", "sline": 157, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_GRID_CELL_ROW_POS);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_grid_cell_row_span": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_grid_cell_row_span(const lv_obj_t * obj, uint32_t part)", "sline": 163, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_GRID_CELL_ROW_SPAN);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_grid_cell_x_align": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_grid_cell_x_align(const lv_obj_t * obj, uint32_t part)", "sline": 169, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_GRID_CELL_X_ALIGN);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_grid_cell_y_align": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_grid_cell_y_align(const lv_obj_t * obj, uint32_t part)", "sline": 175, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_GRID_CELL_Y_ALIGN);\n    return (lv_coord_t)v.num;\n}"}, "carbit_updater/lvgl/src/extra/layouts/grid/lv_grid.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/layouts/grid/lv_grid.h"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_22.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_montserrat_22.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_22.c"}}, "carbit_updater/lvgl/src/misc/lv_types.h": {"stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 16}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_types.h:42:1)": {"type": "Enum", "def": "enum {\n    LV_RES_INV = 0, /*Typically indicates that the object is deleted (become invalid) in the action\n                      function or an operation was failed*/\n    LV_RES_OK,      /*The object is valid (no deleted) after the action*/\n}", "sline": 42, "docstring": "/**"}, "lv_res_t": {"type": "Variable", "def": "typedef uint8_t lv_res_t", "sline": 47}, "lv_uintptr_t": {"type": "Variable", "def": "typedef uintptr_t lv_uintptr_t", "sline": 51, "docstring": "// If c99 or newer,  use the definition of uintptr_t directly from <stdint.h>"}, "carbit_updater/lvgl/src/misc/lv_types.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_types.h"}}, "carbit_updater/lvgl/src/draw/lv_draw_label.h": {"lv_draw_blend": {"type": "Variable", "def": "#include lv_draw_blend.h", "sline": 16, "include": ["carbit_updater/lvgl/src/draw/lv_draw_blend.h", null]}, "lv_bidi": {"type": "Variable", "def": "#include ../misc/lv_bidi.h", "sline": 17}, "lv_txt": {"type": "Variable", "def": "#include ../misc/lv_txt.h", "sline": 18}, "lv_color": {"type": "Variable", "def": "#include ../misc/lv_color.h", "sline": 19}, "lv_draw_label_dsc_t.font": {"type": "Variable", "def": "const lv_font_t * font", "sline": 31, "in_struct": "lv_draw_label_dsc_t"}, "lv_draw_label_dsc_t.sel_start": {"type": "Variable", "def": "uint32_t sel_start", "sline": 32, "in_struct": "lv_draw_label_dsc_t"}, "lv_draw_label_dsc_t.sel_end": {"type": "Variable", "def": "uint32_t sel_end", "sline": 33, "in_struct": "lv_draw_label_dsc_t"}, "lv_draw_label_dsc_t.color": {"type": "Variable", "def": "lv_color_t color", "sline": 34, "in_struct": "lv_draw_label_dsc_t"}, "lv_draw_label_dsc_t.sel_color": {"type": "Variable", "def": "lv_color_t sel_color", "sline": 35, "in_struct": "lv_draw_label_dsc_t"}, "lv_draw_label_dsc_t.sel_bg_color": {"type": "Variable", "def": "lv_color_t sel_bg_color", "sline": 36, "in_struct": "lv_draw_label_dsc_t"}, "lv_draw_label_dsc_t.line_space": {"type": "Variable", "def": "lv_coord_t line_space", "sline": 37, "in_struct": "lv_draw_label_dsc_t"}, "lv_draw_label_dsc_t.letter_space": {"type": "Variable", "def": "lv_coord_t letter_space", "sline": 38, "in_struct": "lv_draw_label_dsc_t"}, "lv_draw_label_dsc_t.ofs_x": {"type": "Variable", "def": "lv_coord_t ofs_x", "sline": 39, "in_struct": "lv_draw_label_dsc_t"}, "lv_draw_label_dsc_t.ofs_y": {"type": "Variable", "def": "lv_coord_t ofs_y", "sline": 40, "in_struct": "lv_draw_label_dsc_t"}, "lv_draw_label_dsc_t.opa": {"type": "Variable", "def": "lv_opa_t opa", "sline": 41, "in_struct": "lv_draw_label_dsc_t"}, "lv_draw_label_dsc_t.bidi_dir": {"type": "Variable", "def": "lv_base_dir_t bidi_dir", "sline": 42, "in_struct": "lv_draw_label_dsc_t"}, "lv_draw_label_dsc_t.align": {"type": "Variable", "def": "lv_text_align_t align", "sline": 43, "in_struct": "lv_draw_label_dsc_t"}, "lv_draw_label_dsc_t.flag": {"type": "Variable", "def": "lv_text_flag_t flag", "sline": 44, "in_struct": "lv_draw_label_dsc_t"}, "lv_draw_label_dsc_t.decor": {"type": "Variable", "def": "lv_text_decor_t decor : 3", "sline": 45, "in_struct": "lv_draw_label_dsc_t"}, "lv_draw_label_dsc_t.blend_mode": {"type": "Variable", "def": "lv_blend_mode_t blend_mode: 3", "sline": 46, "in_struct": "lv_draw_label_dsc_t"}, "lv_draw_label_dsc_t": {"type": "Variable", "def": "typedef struct {\n    const lv_font_t * font;\n    uint32_t sel_start;\n    uint32_t sel_end;\n    lv_color_t color;\n    lv_color_t sel_color;\n    lv_color_t sel_bg_color;\n    lv_coord_t line_space;\n    lv_coord_t letter_space;\n    lv_coord_t ofs_x;\n    lv_coord_t ofs_y;\n    lv_opa_t opa;\n    lv_base_dir_t bidi_dir;\n    lv_text_align_t align;\n    lv_text_flag_t flag;\n    lv_text_decor_t decor : 3;\n    lv_blend_mode_t blend_mode: 3;\n} lv_draw_label_dsc_t", "sline": 47}, "_lv_draw_label_hint_t.line_start": {"type": "Variable", "def": "int32_t line_start", "sline": 56, "in_struct": "_lv_draw_label_hint_t"}, "_lv_draw_label_hint_t.y": {"type": "Variable", "def": "int32_t y", "sline": 59, "in_struct": "_lv_draw_label_hint_t"}, "_lv_draw_label_hint_t.coord_y": {"type": "Variable", "def": "int32_t coord_y", "sline": 63, "in_struct": "_lv_draw_label_hint_t"}, "_lv_draw_label_hint_t": {"type": "Struct", "def": "struct _lv_draw_label_hint_t {\n    /** Index of the line at `y` coordinate*/\n    int32_t line_start;\n\n    /** Give the `y` coordinate of the first letter at `line start` index. Relative to the label's coordinates*/\n    int32_t y;\n\n    /** The 'y1' coordinate of the label when the hint was saved.\n     * Used to invalidate the hint if the label has moved too much.*/\n    int32_t coord_y;\n}", "sline": 54, "body": "int32_t line_start\nint32_t y\nint32_t coord_y\n"}, "lv_draw_label_hint_t": {"type": "Variable", "def": "typedef struct _lv_draw_label_hint_t {\n    /** Index of the line at `y` coordinate*/\n    int32_t line_start;\n\n    /** Give the `y` coordinate of the first letter at `line start` index. Relative to the label's coordinates*/\n    int32_t y;\n\n    /** The 'y1' coordinate of the label when the hint was saved.\n     * Used to invalidate the hint if the label has moved too much.*/\n    int32_t coord_y;\n} lv_draw_label_hint_t", "sline": 64}, "lv_draw_label_dsc_init": {"type": "Function", "def": "void lv_draw_label_dsc_init(lv_draw_label_dsc_t * dsc)", "sline": 72}, "lv_draw_label": {"type": "Function", "def": "void lv_draw_label(const lv_area_t * coords, const lv_area_t * mask,\n                                         const lv_draw_label_dsc_t * dsc,\n                                         const char * txt, lv_draw_label_hint_t * hint)", "sline": 83}, "lv_draw_letter": {"type": "Function", "def": "void lv_draw_letter(const lv_point_t * pos_p, const lv_area_t * clip_area,\n                                          const lv_font_t * font_p,\n                                          uint32_t letter, lv_color_t color, lv_opa_t opa, lv_blend_mode_t blend_mode)", "sline": 87}, "_lv_bpp2_opa_table": {"type": "Variable", "def": "extern const uint8_t _lv_bpp2_opa_table[]", "sline": 94}, "_lv_bpp3_opa_table": {"type": "Variable", "def": "extern const uint8_t _lv_bpp3_opa_table[]", "sline": 95}, "_lv_bpp1_opa_table": {"type": "Variable", "def": "extern const uint8_t _lv_bpp1_opa_table[]", "sline": 96}, "_lv_bpp4_opa_table": {"type": "Variable", "def": "extern const uint8_t _lv_bpp4_opa_table[]", "sline": 97}, "_lv_bpp8_opa_table": {"type": "Variable", "def": "extern const uint8_t _lv_bpp8_opa_table[]", "sline": 98}, "carbit_updater/lvgl/src/draw/lv_draw_label.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_draw_label.h"}}, "carbit_updater/lvgl/src/draw/lv_draw_mask.c": {"lv_draw_mask": {"type": "Variable", "def": "#include lv_draw_mask.h", "sline": 9, "include": ["carbit_updater/lvgl/src/draw/lv_draw_mask.h", null]}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 11}, "lv_log": {"type": "Variable", "def": "#include ../misc/lv_log.h", "sline": 12}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 13}, "lv_gc": {"type": "Variable", "def": "#include ../misc/lv_gc.h", "sline": 14}, "lv_draw_mask_line": {"type": "Function", "def": "static lv_draw_mask_res_t lv_draw_mask_line(lv_opa_t * mask_buf, lv_coord_t abs_x,\n                                                                  lv_coord_t abs_y, lv_coord_t len,\n                                                                  lv_draw_mask_line_param_t * p)", "sline": 567, "body": "{\n    /*Make to points relative to the vertex*/\n    abs_y -= p->origo.y;\n    abs_x -= p->origo.x;\n\n    /*Handle special cases*/\n    if(p->steep == 0) {\n        /*Horizontal*/\n        if(p->flat) {\n            /*Non sense: Can't be on the right/left of a horizontal line*/\n            if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_LEFT ||\n               p->cfg.side == LV_DRAW_MASK_LINE_SIDE_RIGHT) return LV_DRAW_MASK_RES_FULL_COVER;\n            else if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_TOP && abs_y + 1 < 0) return LV_DRAW_MASK_RES_FULL_COVER;\n            else if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_BOTTOM && abs_y > 0) return LV_DRAW_MASK_RES_FULL_COVER;\n            else {\n                return LV_DRAW_MASK_RES_TRANSP;\n            }\n        }\n        /*Vertical*/\n        else {\n            /*Non sense: Can't be on the top/bottom of a vertical line*/\n            if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_TOP ||\n               p->cfg.side == LV_DRAW_MASK_LINE_SIDE_BOTTOM) return LV_DRAW_MASK_RES_FULL_COVER;\n            else if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_RIGHT && abs_x > 0) return LV_DRAW_MASK_RES_FULL_COVER;\n            else if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_LEFT) {\n                if(abs_x + len < 0) return LV_DRAW_MASK_RES_FULL_COVER;\n                else {\n                    int32_t k = - abs_x;\n                    if(k < 0) return LV_DRAW_MASK_RES_TRANSP;\n                    if(k >= 0 && k < len) lv_memset_00(&mask_buf[k], len - k);\n                    return  LV_DRAW_MASK_RES_CHANGED;\n                }\n            }\n            else {\n                if(abs_x + len < 0) return LV_DRAW_MASK_RES_TRANSP;\n                else {\n                    int32_t k = - abs_x;\n                    if(k < 0) k = 0;\n                    if(k >= len) return LV_DRAW_MASK_RES_TRANSP;\n                    else if(k >= 0 && k < len) lv_memset_00(&mask_buf[0], k);\n                    return  LV_DRAW_MASK_RES_CHANGED;\n                }\n            }\n        }\n    }\n\n    lv_draw_mask_res_t res;\n    if(p->flat) {\n        res = line_mask_flat(mask_buf, abs_x, abs_y, len, p);\n    }\n    else {\n        res = line_mask_steep(mask_buf, abs_x, abs_y, len, p);\n    }\n\n    return res;\n}"}, "lv_draw_mask_radius": {"type": "Function", "def": "static lv_draw_mask_res_t lv_draw_mask_radius(lv_opa_t * mask_buf, lv_coord_t abs_x,\n                                                                    lv_coord_t abs_y, lv_coord_t len,\n                                                                    lv_draw_mask_radius_param_t * p)", "sline": 1024, "body": "{\n    bool outer = p->cfg.outer;\n    int32_t radius = p->cfg.radius;\n    lv_area_t rect;\n    lv_area_copy(&rect, &p->cfg.rect);\n\n    if(outer == false) {\n        if((abs_y < rect.y1 || abs_y > rect.y2)) {\n            return LV_DRAW_MASK_RES_TRANSP;\n        }\n    }\n    else {\n        if(abs_y < rect.y1 || abs_y > rect.y2) {\n            return LV_DRAW_MASK_RES_FULL_COVER;\n        }\n    }\n\n    if((abs_x >= rect.x1 + radius && abs_x + len <= rect.x2 - radius) ||\n       (abs_y >= rect.y1 + radius && abs_y <= rect.y2 - radius)) {\n        if(outer == false) {\n            /*Remove the edges*/\n            int32_t last =  rect.x1 - abs_x;\n            if(last > len) return LV_DRAW_MASK_RES_TRANSP;\n            if(last >= 0) {\n                lv_memset_00(&mask_buf[0], last);\n            }\n\n            int32_t first = rect.x2 - abs_x + 1;\n            if(first <= 0) return LV_DRAW_MASK_RES_TRANSP;\n            else if(first < len) {\n                lv_memset_00(&mask_buf[first], len - first);\n            }\n            if(last == 0 && first == len) return LV_DRAW_MASK_RES_FULL_COVER;\n            else return LV_DRAW_MASK_RES_CHANGED;\n        }\n        else {\n            int32_t first = rect.x1 - abs_x;\n            if(first < 0) first = 0;\n            if(first <= len) {\n                int32_t last =  rect.x2 - abs_x - first + 1;\n                if(first + last > len) last = len - first;\n                if(last >= 0) {\n                    lv_memset_00(&mask_buf[first], last);\n                }\n            }\n        }\n        return LV_DRAW_MASK_RES_CHANGED;\n    }\n    //    printf(\"exec: x:%d.. %d, y:%d: r:%d, %s\\n\", abs_x, abs_x + len - 1, abs_y, p->cfg.radius, p->cfg.outer ? \"inv\" : \"norm\");\n\n\n    //    if( abs_x == 276 && abs_x + len - 1 == 479 && abs_y == 63 && p->cfg.radius == 5 && p->cfg.outer == 1) {\n    //        char x = 0;\n    //    }\n    //exec: x:276.. 479, y:63: r:5, inv)\n\n    int32_t k = rect.x1 - abs_x; /*First relevant coordinate on the of the mask*/\n    int32_t w = lv_area_get_width(&rect);\n    int32_t h = lv_area_get_height(&rect);\n    abs_x -= rect.x1;\n    abs_y -= rect.y1;\n\n    lv_coord_t aa_len;\n    lv_coord_t x_start;\n    lv_coord_t cir_y;\n    if(abs_y < radius) {\n        cir_y = radius - abs_y - 1;\n    }\n    else {\n        cir_y = abs_y - (h - radius);\n    }\n    lv_opa_t * aa_opa = get_next_line(p->circle, cir_y, &aa_len, &x_start);\n    lv_coord_t cir_x_right = k + w - radius + x_start;\n    lv_coord_t cir_x_left = k + radius - x_start - 1;\n    lv_coord_t i;\n\n    if(outer == false) {\n        for(i = 0; i < aa_len; i++) {\n            lv_opa_t opa = aa_opa[aa_len - i - 1];\n            if(cir_x_right + i >= 0 && cir_x_right + i < len) {\n                mask_buf[cir_x_right + i] = mask_mix(opa, mask_buf[cir_x_right + i]);\n            }\n            if(cir_x_left - i >= 0 && cir_x_left - i < len) {\n                mask_buf[cir_x_left - i] = mask_mix(opa, mask_buf[cir_x_left - i]);\n            }\n        }\n\n        /*Clean the right side*/\n        cir_x_right = LV_CLAMP(0, cir_x_right + i, len);\n        lv_memset_00(&mask_buf[cir_x_right], len - cir_x_right);\n\n        /*Clean the left side*/\n        cir_x_left = LV_CLAMP(0, cir_x_left - aa_len + 1, len);\n        lv_memset_00(&mask_buf[0], cir_x_left);\n    }\n    else {\n        for(i = 0; i < aa_len; i++) {\n            lv_opa_t opa = 255 - (aa_opa[aa_len - 1 - i]);\n            if(cir_x_right + i >= 0 && cir_x_right + i < len) {\n                mask_buf[cir_x_right + i] = mask_mix(opa, mask_buf[cir_x_right + i]);\n            }\n            if(cir_x_left - i >= 0 && cir_x_left - i < len) {\n                mask_buf[cir_x_left - i] = mask_mix(opa, mask_buf[cir_x_left - i]);\n            }\n        }\n\n        lv_coord_t clr_start = LV_CLAMP(0, cir_x_left + 1, len);\n        lv_coord_t clr_len = LV_CLAMP(0, cir_x_right - clr_start, len - clr_start);\n        lv_memset_00(&mask_buf[clr_start], clr_len);\n    }\n\n    return LV_DRAW_MASK_RES_CHANGED;\n}"}, "lv_draw_mask_angle": {"type": "Function", "def": "static lv_draw_mask_res_t lv_draw_mask_angle(lv_opa_t * mask_buf, lv_coord_t abs_x,\n                                                                   lv_coord_t abs_y, lv_coord_t len,\n                                                                   lv_draw_mask_angle_param_t * p)", "sline": 885, "body": "{\n    int32_t rel_y = abs_y - p->cfg.vertex_p.y;\n    int32_t rel_x = abs_x - p->cfg.vertex_p.x;\n\n    if(p->cfg.start_angle < 180 && p->cfg.end_angle < 180 &&\n       p->cfg.start_angle != 0  && p->cfg.end_angle != 0 &&\n       p->cfg.start_angle > p->cfg.end_angle) {\n\n        if(abs_y < p->cfg.vertex_p.y) {\n            return LV_DRAW_MASK_RES_FULL_COVER;\n        }\n\n        /*Start angle mask can work only from the end of end angle mask*/\n        int32_t end_angle_first = (rel_y * p->end_line.xy_steep) >> 10;\n        int32_t start_angle_last = ((rel_y + 1) * p->start_line.xy_steep) >> 10;\n\n        /*Do not let the line end cross the vertex else it will affect the opposite part*/\n        if(p->cfg.start_angle > 270 && p->cfg.start_angle <= 359 && start_angle_last < 0) start_angle_last = 0;\n        else if(p->cfg.start_angle > 0 && p->cfg.start_angle <= 90 && start_angle_last < 0) start_angle_last = 0;\n        else if(p->cfg.start_angle > 90 && p->cfg.start_angle < 270 && start_angle_last > 0) start_angle_last = 0;\n\n        if(p->cfg.end_angle > 270 && p->cfg.end_angle <= 359 && start_angle_last < 0) start_angle_last = 0;\n        else if(p->cfg.end_angle > 0 &&   p->cfg.end_angle <= 90 && start_angle_last < 0) start_angle_last = 0;\n        else if(p->cfg.end_angle > 90 &&  p->cfg.end_angle < 270 && start_angle_last > 0) start_angle_last = 0;\n\n        int32_t dist = (end_angle_first - start_angle_last) >> 1;\n\n        lv_draw_mask_res_t res1 = LV_DRAW_MASK_RES_FULL_COVER;\n        lv_draw_mask_res_t res2 = LV_DRAW_MASK_RES_FULL_COVER;\n\n        int32_t tmp = start_angle_last + dist - rel_x;\n        if(tmp > len) tmp = len;\n        if(tmp > 0) {\n            res1 = lv_draw_mask_line(&mask_buf[0], abs_x, abs_y, tmp, &p->start_line);\n            if(res1 == LV_DRAW_MASK_RES_TRANSP) {\n                lv_memset_00(&mask_buf[0], tmp);\n            }\n        }\n\n        if(tmp > len) tmp = len;\n        if(tmp < 0) tmp = 0;\n        res2 = lv_draw_mask_line(&mask_buf[tmp], abs_x + tmp, abs_y, len - tmp, &p->end_line);\n        if(res2 == LV_DRAW_MASK_RES_TRANSP) {\n            lv_memset_00(&mask_buf[tmp], len - tmp);\n        }\n        if(res1 == res2) return res1;\n        else return LV_DRAW_MASK_RES_CHANGED;\n    }\n    else if(p->cfg.start_angle > 180 && p->cfg.end_angle > 180 && p->cfg.start_angle > p->cfg.end_angle) {\n\n        if(abs_y > p->cfg.vertex_p.y) {\n            return LV_DRAW_MASK_RES_FULL_COVER;\n        }\n\n        /*Start angle mask can work only from the end of end angle mask*/\n        int32_t end_angle_first = (rel_y * p->end_line.xy_steep) >> 10;\n        int32_t start_angle_last = ((rel_y + 1) * p->start_line.xy_steep) >> 10;\n\n        /*Do not let the line end cross the vertex else it will affect the opposite part*/\n        if(p->cfg.start_angle > 270 && p->cfg.start_angle <= 359 && start_angle_last < 0) start_angle_last = 0;\n        else if(p->cfg.start_angle > 0 && p->cfg.start_angle <= 90 && start_angle_last < 0) start_angle_last = 0;\n        else if(p->cfg.start_angle > 90 && p->cfg.start_angle < 270 && start_angle_last > 0) start_angle_last = 0;\n\n        if(p->cfg.end_angle > 270 && p->cfg.end_angle <= 359 && start_angle_last < 0) start_angle_last = 0;\n        else if(p->cfg.end_angle > 0 &&   p->cfg.end_angle <= 90 && start_angle_last < 0) start_angle_last = 0;\n        else if(p->cfg.end_angle > 90 &&  p->cfg.end_angle < 270 && start_angle_last > 0) start_angle_last = 0;\n\n        int32_t dist = (end_angle_first - start_angle_last) >> 1;\n\n        lv_draw_mask_res_t res1 = LV_DRAW_MASK_RES_FULL_COVER;\n        lv_draw_mask_res_t res2 = LV_DRAW_MASK_RES_FULL_COVER;\n\n        int32_t tmp = start_angle_last + dist - rel_x;\n        if(tmp > len) tmp = len;\n        if(tmp > 0) {\n            res1 = lv_draw_mask_line(&mask_buf[0], abs_x, abs_y, tmp, (lv_draw_mask_line_param_t *)&p->end_line);\n            if(res1 == LV_DRAW_MASK_RES_TRANSP) {\n                lv_memset_00(&mask_buf[0], tmp);\n            }\n        }\n\n        if(tmp > len) tmp = len;\n        if(tmp < 0) tmp = 0;\n        res2 = lv_draw_mask_line(&mask_buf[tmp], abs_x + tmp, abs_y, len - tmp, (lv_draw_mask_line_param_t *)&p->start_line);\n        if(res2 == LV_DRAW_MASK_RES_TRANSP) {\n            lv_memset_00(&mask_buf[tmp], len - tmp);\n        }\n        if(res1 == res2) return res1;\n        else return LV_DRAW_MASK_RES_CHANGED;\n    }\n    else  {\n\n        lv_draw_mask_res_t res1 = LV_DRAW_MASK_RES_FULL_COVER;\n        lv_draw_mask_res_t res2 = LV_DRAW_MASK_RES_FULL_COVER;\n\n        if(p->cfg.start_angle == 180) {\n            if(abs_y < p->cfg.vertex_p.y) res1 = LV_DRAW_MASK_RES_FULL_COVER;\n            else res1 = LV_DRAW_MASK_RES_UNKNOWN;\n        }\n        else if(p->cfg.start_angle == 0) {\n            if(abs_y < p->cfg.vertex_p.y) res1 = LV_DRAW_MASK_RES_UNKNOWN;\n            else res1 = LV_DRAW_MASK_RES_FULL_COVER;\n        }\n        else if((p->cfg.start_angle < 180 && abs_y < p->cfg.vertex_p.y) ||\n                (p->cfg.start_angle > 180 && abs_y >= p->cfg.vertex_p.y)) {\n            res1 = LV_DRAW_MASK_RES_UNKNOWN;\n        }\n        else  {\n            res1 = lv_draw_mask_line(mask_buf, abs_x, abs_y, len, &p->start_line);\n        }\n\n        if(p->cfg.end_angle == 180) {\n            if(abs_y < p->cfg.vertex_p.y) res2 = LV_DRAW_MASK_RES_UNKNOWN;\n            else res2 = LV_DRAW_MASK_RES_FULL_COVER;\n        }\n        else if(p->cfg.end_angle == 0) {\n            if(abs_y < p->cfg.vertex_p.y) res2 = LV_DRAW_MASK_RES_FULL_COVER;\n            else res2 = LV_DRAW_MASK_RES_UNKNOWN;\n        }\n        else if((p->cfg.end_angle < 180 && abs_y < p->cfg.vertex_p.y) ||\n                (p->cfg.end_angle > 180 && abs_y >= p->cfg.vertex_p.y)) {\n            res2 = LV_DRAW_MASK_RES_UNKNOWN;\n        }\n        else {\n            res2 = lv_draw_mask_line(mask_buf, abs_x, abs_y, len, &p->end_line);\n        }\n\n        if(res1 == LV_DRAW_MASK_RES_TRANSP || res2 == LV_DRAW_MASK_RES_TRANSP) return LV_DRAW_MASK_RES_TRANSP;\n        else if(res1 == LV_DRAW_MASK_RES_UNKNOWN && res2 == LV_DRAW_MASK_RES_UNKNOWN) return LV_DRAW_MASK_RES_TRANSP;\n        else if(res1 == LV_DRAW_MASK_RES_FULL_COVER &&  res2 == LV_DRAW_MASK_RES_FULL_COVER) return LV_DRAW_MASK_RES_FULL_COVER;\n        else return LV_DRAW_MASK_RES_CHANGED;\n    }\n}"}, "lv_draw_mask_fade": {"type": "Function", "def": "static lv_draw_mask_res_t lv_draw_mask_fade(lv_opa_t * mask_buf, lv_coord_t abs_x,\n                                                                  lv_coord_t abs_y, lv_coord_t len,\n                                                                  lv_draw_mask_fade_param_t * p)", "sline": 1141, "body": "{\n    if(abs_y < p->cfg.coords.y1) return LV_DRAW_MASK_RES_FULL_COVER;\n    if(abs_y > p->cfg.coords.y2) return LV_DRAW_MASK_RES_FULL_COVER;\n    if(abs_x + len < p->cfg.coords.x1) return LV_DRAW_MASK_RES_FULL_COVER;\n    if(abs_x > p->cfg.coords.x2) return LV_DRAW_MASK_RES_FULL_COVER;\n\n    if(abs_x + len > p->cfg.coords.x2) len -= abs_x + len - p->cfg.coords.x2 - 1;\n\n    if(abs_x < p->cfg.coords.x1) {\n        int32_t x_ofs = 0;\n        x_ofs = p->cfg.coords.x1 - abs_x;\n        len -= x_ofs;\n        mask_buf += x_ofs;\n    }\n\n    int32_t i;\n\n    if(abs_y <= p->cfg.y_top) {\n        for(i = 0; i < len; i++) {\n            mask_buf[i] = mask_mix(mask_buf[i], p->cfg.opa_top);\n        }\n        return LV_DRAW_MASK_RES_CHANGED;\n    }\n    else if(abs_y >= p->cfg.y_bottom) {\n        for(i = 0; i < len; i++) {\n            mask_buf[i] = mask_mix(mask_buf[i], p->cfg.opa_bottom);\n        }\n        return LV_DRAW_MASK_RES_CHANGED;\n    }\n    else {\n        /*Calculate the opa proportionally*/\n        int16_t opa_diff = p->cfg.opa_bottom - p->cfg.opa_top;\n        int32_t y_diff = p->cfg.y_bottom - p->cfg.y_top + 1;\n        lv_opa_t opa_act = (int32_t)((int32_t)(abs_y - p->cfg.y_top) * opa_diff) / y_diff;\n        opa_act += p->cfg.opa_top;\n\n        for(i = 0; i < len; i++) {\n            mask_buf[i] = mask_mix(mask_buf[i], opa_act);\n        }\n        return LV_DRAW_MASK_RES_CHANGED;\n    }\n}"}, "lv_draw_mask_map": {"type": "Function", "def": "static lv_draw_mask_res_t lv_draw_mask_map(lv_opa_t * mask_buf, lv_coord_t abs_x,\n                                                                 lv_coord_t abs_y, lv_coord_t len,\n                                                                 lv_draw_mask_map_param_t * p)", "sline": 1187, "body": "{\n    /*Handle out of the mask cases*/\n    if(abs_y < p->cfg.coords.y1) return LV_DRAW_MASK_RES_FULL_COVER;\n    if(abs_y > p->cfg.coords.y2) return LV_DRAW_MASK_RES_FULL_COVER;\n    if(abs_x + len < p->cfg.coords.x1) return LV_DRAW_MASK_RES_FULL_COVER;\n    if(abs_x > p->cfg.coords.x2) return LV_DRAW_MASK_RES_FULL_COVER;\n\n    /*Got to the current row in the map*/\n    const lv_opa_t * map_tmp = p->cfg.map;\n    map_tmp += (abs_y - p->cfg.coords.y1) * lv_area_get_width(&p->cfg.coords);\n\n    if(abs_x + len > p->cfg.coords.x2) len -= abs_x + len - p->cfg.coords.x2 - 1;\n\n    if(abs_x < p->cfg.coords.x1) {\n        int32_t x_ofs = 0;\n        x_ofs = p->cfg.coords.x1 - abs_x;\n        len -= x_ofs;\n        mask_buf += x_ofs;\n    }\n    else {\n        map_tmp += (abs_x - p->cfg.coords.x1);\n    }\n\n    int32_t i;\n    for(i = 0; i < len; i++) {\n        mask_buf[i] = mask_mix(mask_buf[i], map_tmp[i]);\n    }\n\n    return LV_DRAW_MASK_RES_CHANGED;\n}"}, "line_mask_flat": {"type": "Function", "def": "static lv_draw_mask_res_t line_mask_flat(lv_opa_t * mask_buf, lv_coord_t abs_x, lv_coord_t abs_y,\n                                                               lv_coord_t len,\n                                                               lv_draw_mask_line_param_t * p)", "sline": 627, "body": "{\n\n    int32_t y_at_x;\n    y_at_x = (int32_t)((int32_t)p->yx_steep * abs_x) >> 10;\n\n    if(p->yx_steep > 0) {\n        if(y_at_x > abs_y) {\n            if(p->inv) {\n                return LV_DRAW_MASK_RES_FULL_COVER;\n            }\n            else {\n                return LV_DRAW_MASK_RES_TRANSP;\n            }\n        }\n    }\n    else {\n        if(y_at_x < abs_y) {\n            if(p->inv) {\n                return LV_DRAW_MASK_RES_FULL_COVER;\n            }\n            else {\n                return LV_DRAW_MASK_RES_TRANSP;\n            }\n        }\n    }\n\n    /*At the end of the mask if the limit line is smaller than the mask's y.\n     *Then the mask is in the \"good\" area*/\n    y_at_x = (int32_t)((int32_t)p->yx_steep * (abs_x + len)) >> 10;\n    if(p->yx_steep > 0) {\n        if(y_at_x < abs_y) {\n            if(p->inv) {\n                return LV_DRAW_MASK_RES_TRANSP;\n            }\n            else {\n                return LV_DRAW_MASK_RES_FULL_COVER;\n            }\n        }\n    }\n    else {\n        if(y_at_x > abs_y) {\n            if(p->inv) {\n                return LV_DRAW_MASK_RES_TRANSP;\n            }\n            else {\n                return LV_DRAW_MASK_RES_FULL_COVER;\n            }\n        }\n    }\n\n    int32_t xe;\n    if(p->yx_steep > 0) xe = ((abs_y * 256) * p->xy_steep) >> 10;\n    else xe = (((abs_y + 1) * 256) * p->xy_steep) >> 10;\n\n    int32_t xei = xe >> 8;\n    int32_t xef = xe & 0xFF;\n\n    int32_t px_h;\n    if(xef == 0) px_h = 255;\n    else px_h = 255 - (((255 - xef) * p->spx) >> 8);\n    int32_t k = xei - abs_x;\n    lv_opa_t m;\n\n    if(xef) {\n        if(k >= 0 && k < len) {\n            m = 255 - (((255 - xef) * (255 - px_h)) >> 9);\n            if(p->inv) m = 255 - m;\n            mask_buf[k] = mask_mix(mask_buf[k], m);\n        }\n        k++;\n    }\n\n    while(px_h > p->spx) {\n        if(k >= 0 && k < len) {\n            m = px_h - (p->spx >> 1);\n            if(p->inv) m = 255 - m;\n            mask_buf[k] = mask_mix(mask_buf[k], m);\n        }\n        px_h -= p->spx;\n        k++;\n        if(k >= len) break;\n    }\n\n    if(k < len && k >= 0) {\n        int32_t x_inters = (px_h * p->xy_steep) >> 10;\n        m = (x_inters * px_h) >> 9;\n        if(p->yx_steep < 0) m = 255 - m;\n        if(p->inv) m = 255 - m;\n        mask_buf[k] = mask_mix(mask_buf[k], m);\n    }\n\n    if(p->inv) {\n        k = xei - abs_x;\n        if(k > len) {\n            return LV_DRAW_MASK_RES_TRANSP;\n        }\n        if(k >= 0) {\n            lv_memset_00(&mask_buf[0], k);\n        }\n    }\n    else {\n        k++;\n        if(k < 0) {\n            return LV_DRAW_MASK_RES_TRANSP;\n        }\n        if(k <= len) {\n            lv_memset_00(&mask_buf[k], len - k);\n        }\n    }\n\n    return LV_DRAW_MASK_RES_CHANGED;\n}"}, "line_mask_steep": {"type": "Function", "def": "static lv_draw_mask_res_t line_mask_steep(lv_opa_t * mask_buf, lv_coord_t abs_x, lv_coord_t abs_y,\n                                                                lv_coord_t len,\n                                                                lv_draw_mask_line_param_t * p)", "sline": 743, "body": "{\n    int32_t k;\n    int32_t x_at_y;\n    /*At the beginning of the mask if the limit line is greater than the mask's y.\n     *Then the mask is in the \"wrong\" area*/\n    x_at_y = (int32_t)((int32_t)p->xy_steep * abs_y) >> 10;\n    if(p->xy_steep > 0) x_at_y++;\n    if(x_at_y < abs_x) {\n        if(p->inv) {\n            return LV_DRAW_MASK_RES_FULL_COVER;\n        }\n        else {\n            return LV_DRAW_MASK_RES_TRANSP;\n        }\n    }\n\n    /*At the end of the mask if the limit line is smaller than the mask's y.\n     *Then the mask is in the \"good\" area*/\n    x_at_y = (int32_t)((int32_t)p->xy_steep * (abs_y)) >> 10;\n    if(x_at_y > abs_x + len) {\n        if(p->inv) {\n            return LV_DRAW_MASK_RES_TRANSP;\n        }\n        else {\n            return LV_DRAW_MASK_RES_FULL_COVER;\n        }\n    }\n\n    /*X start*/\n    int32_t xs = ((abs_y * 256) * p->xy_steep) >> 10;\n    int32_t xsi = xs >> 8;\n    int32_t xsf = xs & 0xFF;\n\n    /*X end*/\n    int32_t xe = (((abs_y + 1) * 256) * p->xy_steep) >> 10;\n    int32_t xei = xe >> 8;\n    int32_t xef = xe & 0xFF;\n\n    lv_opa_t m;\n\n    k = xsi - abs_x;\n    if(xsi != xei && (p->xy_steep < 0 && xsf == 0)) {\n        xsf = 0xFF;\n        xsi = xei;\n        k--;\n    }\n\n    if(xsi == xei) {\n        if(k >= 0 && k < len) {\n            m = (xsf + xef) >> 1;\n            if(p->inv) m = 255 - m;\n            mask_buf[k] = mask_mix(mask_buf[k], m);\n        }\n        k++;\n\n        if(p->inv) {\n            k = xsi - abs_x;\n            if(k >= len) {\n                return LV_DRAW_MASK_RES_TRANSP;\n            }\n            if(k >= 0) lv_memset_00(&mask_buf[0], k);\n\n        }\n        else {\n            if(k > len) k = len;\n            if(k == 0) return LV_DRAW_MASK_RES_TRANSP;\n            else if(k > 0) lv_memset_00(&mask_buf[k],  len - k);\n        }\n\n    }\n    else {\n        int32_t y_inters;\n        if(p->xy_steep < 0) {\n            y_inters = (xsf * (-p->yx_steep)) >> 10;\n            if(k >= 0 && k < len) {\n                m = (y_inters * xsf) >> 9;\n                if(p->inv) m = 255 - m;\n                mask_buf[k] = mask_mix(mask_buf[k], m);\n            }\n            k--;\n\n            int32_t x_inters = ((255 - y_inters) * (-p->xy_steep)) >> 10;\n\n            if(k >= 0 && k < len) {\n                m = 255 - (((255 - y_inters) * x_inters) >> 9);\n                if(p->inv) m = 255 - m;\n                mask_buf[k] = mask_mix(mask_buf[k], m);\n            }\n\n            k += 2;\n\n            if(p->inv) {\n                k = xsi - abs_x - 1;\n\n                if(k > len) k = len;\n                else if(k > 0) lv_memset_00(&mask_buf[0],  k);\n\n            }\n            else {\n                if(k > len) return LV_DRAW_MASK_RES_FULL_COVER;\n                if(k >= 0) lv_memset_00(&mask_buf[k],  len - k);\n            }\n\n        }\n        else {\n            y_inters = ((255 - xsf) * p->yx_steep) >> 10;\n            if(k >= 0 && k < len) {\n                m = 255 - ((y_inters * (255 - xsf)) >> 9);\n                if(p->inv) m = 255 - m;\n                mask_buf[k] = mask_mix(mask_buf[k], m);\n            }\n\n            k++;\n\n            int32_t x_inters = ((255 - y_inters) * p->xy_steep) >> 10;\n            if(k >= 0 && k < len) {\n                m = ((255 - y_inters) * x_inters) >> 9;\n                if(p->inv) m = 255 - m;\n                mask_buf[k] = mask_mix(mask_buf[k], m);\n            }\n            k++;\n\n            if(p->inv) {\n                k = xsi - abs_x;\n                if(k > len)  return LV_DRAW_MASK_RES_TRANSP;\n                if(k >= 0) lv_memset_00(&mask_buf[0],  k);\n\n            }\n            else {\n                if(k > len) k = len;\n                if(k == 0) return LV_DRAW_MASK_RES_TRANSP;\n                else if(k > 0) lv_memset_00(&mask_buf[k],  len - k);\n            }\n        }\n    }\n\n    return LV_DRAW_MASK_RES_CHANGED;\n}"}, "circ_init": {"type": "Function", "def": "static void circ_init(lv_point_t * c, lv_coord_t * tmp, lv_coord_t radius)", "sline": 1227, "body": "{\n    c->x = radius;\n    c->y = 0;\n    *tmp = 1 - radius;\n}"}, "circ_cont": {"type": "Function", "def": "static bool circ_cont(lv_point_t * c)", "sline": 1239, "body": "{\n    return c->y <= c->x ? true : false;\n}"}, "circ_next": {"type": "Function", "def": "static void circ_next(lv_point_t * c, lv_coord_t * tmp)", "sline": 1249, "body": "{\n\n    if(*tmp <= 0) {\n        (*tmp) += 2 * c->y + 3; /*Change in decision criterion for y -> y+1*/\n    }\n    else {\n        (*tmp) += 2 * (c->y - c->x) + 5; /*Change for y -> y+1, x -> x-1*/\n        c->x--;\n    }\n    c->y++;\n}"}, "circ_calc_aa4": {"type": "Function", "def": "static void circ_calc_aa4(_lv_draw_mask_radius_circle_dsc_t * c, lv_coord_t radius)", "sline": 1262, "body": "{\n    if(radius == 0) return;\n    c->radius = radius;\n\n    /*Allocate buffers*/\n    if(c->buf) lv_mem_free(c->buf);\n\n    c->buf = lv_mem_alloc(radius * 6 + 6);  /*Use uint16_t for opa_start_on_y and x_start_on_y*/\n    LV_ASSERT_MALLOC(c->buf);\n    c->cir_opa = c->buf;\n    c->opa_start_on_y = (uint16_t *)(c->buf + 2 * radius + 2);\n    c->x_start_on_y = (uint16_t *)(c->buf + 4 * radius + 4);\n\n    /*Special case, handle manually*/\n    if(radius == 1) {\n        c->cir_opa[0] =  180;\n        c->opa_start_on_y[0] =  0;\n        c->opa_start_on_y[1] =  1;\n        c->x_start_on_y[0] =  0;\n        return;\n    }\n\n    lv_coord_t * cir_x = lv_mem_buf_get((radius + 1) * 2 * 2 * sizeof(lv_coord_t));\n    lv_coord_t * cir_y = &cir_x[(radius + 1) * 2];\n\n    uint32_t y_8th_cnt = 0;\n    lv_point_t cp;\n    lv_coord_t tmp;\n    circ_init(&cp, &tmp, radius * 4);    /*Upscale by 4*/\n    int32_t i;\n\n    uint32_t x_int[4];\n    uint32_t x_fract[4];\n    lv_coord_t cir_size = 0;\n    x_int[0] = cp.x >> 2;\n    x_fract[0] = 0;\n\n    /*Calculate an 1/8 circle*/\n    while(circ_cont(&cp)) {\n        /*Calculate 4 point of the circle */\n        for(i = 0; i < 4; i++) {\n            circ_next(&cp, &tmp);\n            if(circ_cont(&cp) == false) break;\n            x_int[i] = cp.x >> 2;\n            x_fract[i] = cp.x & 0x3;\n        }\n        if(i != 4) break;\n\n        /*All lines on the same x when downscaled*/\n        if(x_int[0] == x_int[3]) {\n            cir_x[cir_size] = x_int[0];\n            cir_y[cir_size] = y_8th_cnt;\n            c->cir_opa[cir_size] = x_fract[0] + x_fract[1] + x_fract[2] + x_fract[3];\n            c->cir_opa[cir_size] *= 16;\n            cir_size++;\n        }\n        /*Second line on new x when downscaled*/\n        else if(x_int[0] != x_int[1]) {\n            cir_x[cir_size] = x_int[0];\n            cir_y[cir_size] = y_8th_cnt;\n            c->cir_opa[cir_size] = x_fract[0];\n            c->cir_opa[cir_size] *= 16;\n            cir_size++;\n\n            cir_x[cir_size] = x_int[0] - 1;\n            cir_y[cir_size] = y_8th_cnt;\n            c->cir_opa[cir_size] = 1 * 4 + x_fract[1] + x_fract[2] + x_fract[3];;\n            c->cir_opa[cir_size] *= 16;\n            cir_size++;\n        }\n        /*Third line on new x when downscaled*/\n        else if(x_int[0] != x_int[2]) {\n            cir_x[cir_size] = x_int[0];\n            cir_y[cir_size] = y_8th_cnt;\n            c->cir_opa[cir_size] = x_fract[0] + x_fract[1];\n            c->cir_opa[cir_size] *= 16;\n            cir_size++;\n\n            cir_x[cir_size] = x_int[0] - 1;\n            cir_y[cir_size] = y_8th_cnt;\n            c->cir_opa[cir_size] = 2 * 4 + x_fract[2] + x_fract[3];;\n            c->cir_opa[cir_size] *= 16;\n            cir_size++;\n        }\n        /*Forth line on new x when downscaled*/\n        else {\n            cir_x[cir_size] = x_int[0];\n            cir_y[cir_size] = y_8th_cnt;\n            c->cir_opa[cir_size] = x_fract[0] + x_fract[1] + x_fract[2];\n            c->cir_opa[cir_size] *= 16;\n            cir_size++;\n\n            cir_x[cir_size] = x_int[0] - 1;\n            cir_y[cir_size] = y_8th_cnt;\n            c->cir_opa[cir_size] = 3 * 4 + x_fract[3];;\n            c->cir_opa[cir_size] *= 16;\n            cir_size++;\n        }\n\n        y_8th_cnt++;\n    }\n\n    /*The point on the 1/8 circle is special, calculate it manually*/\n    int32_t mid = radius * 723;\n    int32_t mid_int = mid >> 10;\n    if(cir_x[cir_size - 1] != mid_int || cir_y[cir_size - 1] != mid_int) {\n        int32_t tmp_val = mid - (mid_int << 10);\n        if(tmp_val <= 512) {\n            tmp_val = tmp_val * tmp_val * 2;\n            tmp_val = tmp_val >> (10 + 6);\n        }\n        else {\n            tmp_val = 1024 - tmp_val;\n            tmp_val = tmp_val * tmp_val * 2;\n            tmp_val = tmp_val >> (10 + 6);\n            tmp_val = 15 - tmp_val;\n        }\n\n        cir_x[cir_size] = mid_int;\n        cir_y[cir_size] = mid_int;\n        c->cir_opa[cir_size] = tmp_val;\n        c->cir_opa[cir_size] *= 16;\n        cir_size++;\n    }\n\n    /*Build the second octet by mirroring the first*/\n    for(i = cir_size - 2; i >= 0; i--, cir_size++) {\n        cir_x[cir_size] = cir_y[i];\n        cir_y[cir_size] = cir_x[i];\n        c->cir_opa[cir_size] = c->cir_opa[i];\n    }\n\n    lv_coord_t y = 0;\n    i = 0;\n    c->opa_start_on_y[0] = 0;\n    while(i < cir_size) {\n        c->opa_start_on_y[y] = i;\n        c->x_start_on_y[y] = cir_x[i];\n        for(; cir_y[i] == y && i < (int32_t)cir_size; i++) {\n            c->x_start_on_y[y] = LV_MIN(c->x_start_on_y[y], cir_x[i]);\n        }\n        y++;\n    }\n\n    lv_mem_buf_release(cir_x);\n}"}, "get_next_line": {"type": "Function", "def": "static lv_opa_t * get_next_line(_lv_draw_mask_radius_circle_dsc_t * c, lv_coord_t y, lv_coord_t * len,\n                                lv_coord_t * x_start)", "sline": 1410, "body": "{\n    *len = c->opa_start_on_y[y + 1] - c->opa_start_on_y[y];\n    *x_start = c->x_start_on_y[y];\n    return &c->cir_opa[c->opa_start_on_y[y]];\n}"}, "mask_mix": {"type": "Function", "def": "static inline lv_opa_t mask_mix(lv_opa_t mask_act, lv_opa_t mask_new)", "sline": 1419, "body": "{\n    if(mask_new >= LV_OPA_MAX) return mask_act;\n    if(mask_new <= LV_OPA_MIN) return 0;\n\n    return LV_UDIV255(mask_act * mask_new);// >> 8);\n}"}, "lv_draw_mask_add": {"type": "Function", "def": "int16_t lv_draw_mask_add(void * param, void * custom_id)", "sline": 78, "body": "{\n    /*Look for a free entry*/\n    uint8_t i;\n    for(i = 0; i < _LV_MASK_MAX_NUM; i++) {\n        if(LV_GC_ROOT(_lv_draw_mask_list[i]).param == NULL) break;\n    }\n\n    if(i >= _LV_MASK_MAX_NUM) {\n        LV_LOG_WARN(\"lv_mask_add: no place to add the mask\");\n        return LV_MASK_ID_INV;\n    }\n\n    LV_GC_ROOT(_lv_draw_mask_list[i]).param = param;\n    LV_GC_ROOT(_lv_draw_mask_list[i]).custom_id = custom_id;\n\n    return i;\n}"}, "lv_draw_mask_apply": {"type": "Function", "def": "lv_draw_mask_res_t lv_draw_mask_apply(lv_opa_t * mask_buf, lv_coord_t abs_x, lv_coord_t abs_y,\n                                                            lv_coord_t len)", "sline": 108, "body": "{\n    bool changed = false;\n    _lv_draw_mask_common_dsc_t * dsc;\n\n    _lv_draw_mask_saved_t * m = LV_GC_ROOT(_lv_draw_mask_list);\n\n    while(m->param) {\n        dsc = m->param;\n        lv_draw_mask_res_t res = LV_DRAW_MASK_RES_FULL_COVER;\n        res = dsc->cb(mask_buf, abs_x, abs_y, len, (void *)m->param);\n        if(res == LV_DRAW_MASK_RES_TRANSP) return LV_DRAW_MASK_RES_TRANSP;\n        else if(res == LV_DRAW_MASK_RES_CHANGED) changed = true;\n\n        m++;\n    }\n\n    return changed ? LV_DRAW_MASK_RES_CHANGED : LV_DRAW_MASK_RES_FULL_COVER;\n}"}, "lv_draw_mask_apply_ids": {"type": "Function", "def": "lv_draw_mask_res_t lv_draw_mask_apply_ids(lv_opa_t * mask_buf, lv_coord_t abs_x, lv_coord_t abs_y,\n                                                                lv_coord_t len, const int16_t *ids, int16_t ids_count)", "sline": 142, "body": "{\n    bool changed = false;\n    _lv_draw_mask_common_dsc_t * dsc;\n\n    for (int i = 0; i < ids_count; i++) {\n        int16_t id = ids[i];\n        if (id == LV_MASK_ID_INV) continue;\n        dsc = LV_GC_ROOT(_lv_draw_mask_list[id]).param;\n        if (!dsc) continue;\n        lv_draw_mask_res_t res = LV_DRAW_MASK_RES_FULL_COVER;\n        res = dsc->cb(mask_buf, abs_x, abs_y, len, dsc);\n        if(res == LV_DRAW_MASK_RES_TRANSP) return LV_DRAW_MASK_RES_TRANSP;\n        else if(res == LV_DRAW_MASK_RES_CHANGED) changed = true;\n    }\n\n    return changed ? LV_DRAW_MASK_RES_CHANGED : LV_DRAW_MASK_RES_FULL_COVER;\n}"}, "lv_draw_mask_remove_id": {"type": "Function", "def": "void * lv_draw_mask_remove_id(int16_t id)", "sline": 168, "body": "{\n    _lv_draw_mask_common_dsc_t * p = NULL;\n\n    if(id != LV_MASK_ID_INV) {\n        p = LV_GC_ROOT(_lv_draw_mask_list[id]).param;\n        LV_GC_ROOT(_lv_draw_mask_list[id]).param = NULL;\n        LV_GC_ROOT(_lv_draw_mask_list[id]).custom_id = NULL;\n    }\n\n    return p;\n}"}, "lv_draw_mask_remove_custom": {"type": "Function", "def": "void * lv_draw_mask_remove_custom(void * custom_id)", "sline": 187, "body": "{\n    _lv_draw_mask_common_dsc_t * p = NULL;\n    uint8_t i;\n    for(i = 0; i < _LV_MASK_MAX_NUM; i++) {\n        if(LV_GC_ROOT(_lv_draw_mask_list[i]).custom_id == custom_id) {\n            p = LV_GC_ROOT(_lv_draw_mask_list[i]).param;\n            lv_draw_mask_remove_id(i);\n        }\n    }\n    return p;\n}"}, "lv_draw_mask_free_param": {"type": "Function", "def": "void lv_draw_mask_free_param(void * p)", "sline": 207, "body": "{\n    _lv_draw_mask_common_dsc_t * pdsc = p;\n    if(pdsc->type == LV_DRAW_MASK_TYPE_RADIUS) {\n        lv_draw_mask_radius_param_t * radius_p = (lv_draw_mask_radius_param_t *) p;\n        if(radius_p->circle) {\n            if(radius_p->circle->life < 0) {\n                lv_mem_free(radius_p->circle->cir_opa);\n                lv_mem_free(radius_p->circle);\n            }\n            else {\n                radius_p->circle->used_cnt--;\n            }\n        }\n    }\n}"}, "_lv_draw_mask_cleanup": {"type": "Function", "def": "void _lv_draw_mask_cleanup(void)", "sline": 224, "body": "{\n    uint8_t i;\n    for(i = 0; i < LV_CIRCLE_CACHE_SIZE; i++) {\n        if(LV_GC_ROOT(_lv_circle_cache[i]).buf) {\n            lv_mem_free(LV_GC_ROOT(_lv_circle_cache[i]).buf);\n        }\n        lv_memset_00(&LV_GC_ROOT(_lv_circle_cache[i]), sizeof(LV_GC_ROOT(_lv_circle_cache[i])));\n    }\n}"}, "lv_draw_mask_get_cnt": {"type": "Function", "def": "uint8_t lv_draw_mask_get_cnt(void)", "sline": 239, "body": "{\n    uint8_t cnt = 0;\n    uint8_t i;\n    for(i = 0; i < _LV_MASK_MAX_NUM; i++) {\n        if(LV_GC_ROOT(_lv_draw_mask_list[i]).param) cnt++;\n    }\n    return cnt;\n}"}, "lv_draw_mask_is_any": {"type": "Function", "def": "bool lv_draw_mask_is_any(const lv_area_t * a)", "sline": 249, "body": "{\n    if(a == NULL) return LV_GC_ROOT(_lv_draw_mask_list[0]).param ? true : false;\n\n    uint8_t i;\n    for(i = 0; i < _LV_MASK_MAX_NUM; i++) {\n        _lv_draw_mask_common_dsc_t * comm_param =  LV_GC_ROOT(_lv_draw_mask_list[i]).param;\n        if(comm_param == NULL) continue;\n        if(comm_param->type == LV_DRAW_MASK_TYPE_RADIUS) {\n            lv_draw_mask_radius_param_t * radius_param =  LV_GC_ROOT(_lv_draw_mask_list[i]).param;\n            if(radius_param->cfg.outer) {\n                if(!_lv_area_is_out(a, &radius_param->cfg.rect, radius_param->cfg.radius)) return true;\n            }\n            else {\n                if(!_lv_area_is_in(a, &radius_param->cfg.rect, radius_param->cfg.radius)) return true;\n            }\n        }\n        else {\n            return true;\n        }\n    }\n\n    return false;\n\n}"}, "lv_draw_mask_line_points_init": {"type": "Function", "def": "void lv_draw_mask_line_points_init(lv_draw_mask_line_param_t * param, lv_coord_t p1x, lv_coord_t p1y, lv_coord_t p2x,\n                                   lv_coord_t p2y, lv_draw_mask_line_side_t side)", "sline": 286, "body": "{\n    lv_memset_00(param, sizeof(lv_draw_mask_line_param_t));\n\n    if(p1y == p2y && side == LV_DRAW_MASK_LINE_SIDE_BOTTOM) {\n        p1y--;\n        p2y--;\n    }\n\n    if(p1y > p2y) {\n        lv_coord_t t;\n        t = p2x;\n        p2x = p1x;\n        p1x = t;\n\n        t = p2y;\n        p2y = p1y;\n        p1y = t;\n    }\n\n    param->cfg.p1.x = p1x;\n    param->cfg.p1.y = p1y;\n    param->cfg.p2.x = p2x;\n    param->cfg.p2.y = p2y;\n    param->cfg.side = side;\n\n    param->origo.x = p1x;\n    param->origo.y = p1y;\n    param->flat = (LV_ABS(p2x - p1x) > LV_ABS(p2y - p1y)) ? 1 : 0;\n    param->yx_steep = 0;\n    param->xy_steep = 0;\n    param->dsc.cb = (lv_draw_mask_xcb_t)lv_draw_mask_line;\n    param->dsc.type = LV_DRAW_MASK_TYPE_LINE;\n\n    int32_t dx = p2x - p1x;\n    int32_t dy = p2y - p1y;\n\n    if(param->flat) {\n        /*Normalize the steep. Delta x should be relative to delta x = 1024*/\n        int32_t m;\n\n        if(dx) {\n            m = (1L << 20) / dx;  /*m is multiplier to normalize y (upscaled by 1024)*/\n            param->yx_steep = (m * dy) >> 10;\n        }\n\n        if(dy) {\n            m = (1L << 20) / dy;  /*m is multiplier to normalize x (upscaled by 1024)*/\n            param->xy_steep = (m * dx) >> 10;\n        }\n        param->steep = param->yx_steep;\n    }\n    else {\n        /*Normalize the steep. Delta y should be relative to delta x = 1024*/\n        int32_t m;\n\n        if(dy) {\n            m = (1L << 20) / dy;  /*m is multiplier to normalize x (upscaled by 1024)*/\n            param->xy_steep = (m * dx) >> 10;\n        }\n\n        if(dx) {\n            m = (1L << 20) / dx;  /*m is multiplier to normalize x (upscaled by 1024)*/\n            param->yx_steep = (m * dy) >> 10;\n        }\n        param->steep = param->xy_steep;\n    }\n\n    if(param->cfg.side == LV_DRAW_MASK_LINE_SIDE_LEFT) param->inv = 0;\n    else if(param->cfg.side == LV_DRAW_MASK_LINE_SIDE_RIGHT) param->inv = 1;\n    else if(param->cfg.side == LV_DRAW_MASK_LINE_SIDE_TOP) {\n        if(param->steep > 0) param->inv = 1;\n        else param->inv = 0;\n    }\n    else if(param->cfg.side == LV_DRAW_MASK_LINE_SIDE_BOTTOM) {\n        if(param->steep > 0) param->inv = 0;\n        else param->inv = 1;\n    }\n\n    param->spx = param->steep >> 2;\n    if(param->steep < 0) param->spx = -param->spx;\n}"}, "lv_draw_mask_line_angle_init": {"type": "Function", "def": "void lv_draw_mask_line_angle_init(lv_draw_mask_line_param_t * param, lv_coord_t p1x, lv_coord_t py, int16_t angle,\n                                  lv_draw_mask_line_side_t side)", "sline": 380, "body": "{\n    /*Find an optimal degree.\n     *lv_mask_line_points_init will swap the points to keep the smaller y in p1\n     *Theoretically a line with `angle` or `angle+180` is the same only the points are swapped\n     *Find the degree which keeps the origo in place*/\n    if(angle > 180) angle -= 180; /*> 180 will swap the origo*/\n\n    int32_t p2x;\n    int32_t p2y;\n\n    p2x = (lv_trigo_sin(angle + 90) >> 5) + p1x;\n    p2y = (lv_trigo_sin(angle) >> 5) + py;\n\n    lv_draw_mask_line_points_init(param, p1x, py, p2x, p2y, side);\n}"}, "lv_draw_mask_angle_init": {"type": "Function", "def": "void lv_draw_mask_angle_init(lv_draw_mask_angle_param_t * param, lv_coord_t vertex_x, lv_coord_t vertex_y,\n                             lv_coord_t start_angle, lv_coord_t end_angle)", "sline": 406, "body": "{\n    lv_draw_mask_line_side_t start_side;\n    lv_draw_mask_line_side_t end_side;\n\n    /*Constrain the input angles*/\n    if(start_angle < 0)\n        start_angle = 0;\n    else if(start_angle > 359)\n        start_angle = 359;\n\n    if(end_angle < 0)\n        end_angle = 0;\n    else if(end_angle > 359)\n        end_angle = 359;\n\n    if(end_angle < start_angle) {\n        param->delta_deg = 360 - start_angle + end_angle;\n    }\n    else {\n        param->delta_deg = LV_ABS(end_angle - start_angle);\n    }\n\n    param->cfg.start_angle = start_angle;\n    param->cfg.end_angle = end_angle;\n    param->cfg.vertex_p.x = vertex_x;\n    param->cfg.vertex_p.y = vertex_y;\n    param->dsc.cb = (lv_draw_mask_xcb_t)lv_draw_mask_angle;\n    param->dsc.type = LV_DRAW_MASK_TYPE_ANGLE;\n\n    LV_ASSERT_MSG(start_angle >= 0 && start_angle <= 360, \"Unexpected start angle\");\n\n    if(start_angle >= 0 && start_angle < 180) {\n        start_side = LV_DRAW_MASK_LINE_SIDE_LEFT;\n    }\n    else if(start_angle >= 180 && start_angle < 360) {\n        start_side = LV_DRAW_MASK_LINE_SIDE_RIGHT;\n    }\n    else\n        start_side = LV_DRAW_MASK_LINE_SIDE_RIGHT; /*silence compiler*/\n\n    LV_ASSERT_MSG(end_angle >= 0 && start_angle <= 360, \"Unexpected end angle\");\n\n    if(end_angle >= 0 && end_angle < 180) {\n        end_side = LV_DRAW_MASK_LINE_SIDE_RIGHT;\n    }\n    else if(end_angle >= 180 && end_angle < 360) {\n        end_side = LV_DRAW_MASK_LINE_SIDE_LEFT;\n    }\n    else\n        end_side = LV_DRAW_MASK_LINE_SIDE_RIGHT; /*silence compiler*/\n\n    lv_draw_mask_line_angle_init(&param->start_line, vertex_x, vertex_y, start_angle, start_side);\n    lv_draw_mask_line_angle_init(&param->end_line, vertex_x, vertex_y, end_angle, end_side);\n}"}, "lv_draw_mask_radius_init": {"type": "Function", "def": "void lv_draw_mask_radius_init(lv_draw_mask_radius_param_t * param, const lv_area_t * rect, lv_coord_t radius, bool inv)", "sline": 470, "body": "{\n    lv_coord_t w = lv_area_get_width(rect);\n    lv_coord_t h = lv_area_get_height(rect);\n    if(radius < 0) radius = 0;\n    int32_t short_side = LV_MIN(w, h);\n    if(radius > short_side >> 1) radius = short_side >> 1;\n\n    lv_area_copy(&param->cfg.rect, rect);\n    param->cfg.radius = radius;\n    param->cfg.outer = inv ? 1 : 0;\n    param->dsc.cb = (lv_draw_mask_xcb_t)lv_draw_mask_radius;\n    param->dsc.type = LV_DRAW_MASK_TYPE_RADIUS;\n\n    if(radius == 0) {\n        param->circle = NULL;\n        return;\n    }\n\n    uint32_t i;\n\n    /*Try to reuse a circle cache entry*/\n    for(i = 0; i < LV_CIRCLE_CACHE_SIZE; i++) {\n        if(LV_GC_ROOT(_lv_circle_cache[i]).radius == radius) {\n            LV_GC_ROOT(_lv_circle_cache[i]).used_cnt++;\n            CIRCLE_CACHE_AGING(LV_GC_ROOT(_lv_circle_cache[i]).life, radius);\n            param->circle = &LV_GC_ROOT(_lv_circle_cache[i]);\n            return;\n        }\n    }\n\n    /*If not found find a free entry with lowest life*/\n    _lv_draw_mask_radius_circle_dsc_t * entry = NULL;\n    for(i = 0; i < LV_CIRCLE_CACHE_SIZE; i++) {\n        if(LV_GC_ROOT(_lv_circle_cache[i]).used_cnt == 0) {\n            if(!entry) entry = &LV_GC_ROOT(_lv_circle_cache[i]);\n            else if(LV_GC_ROOT(_lv_circle_cache[i]).life < entry->life) entry = &LV_GC_ROOT(_lv_circle_cache[i]);\n        }\n    }\n\n    if(!entry) {\n        entry = lv_mem_alloc(sizeof(_lv_draw_mask_radius_circle_dsc_t));\n        LV_ASSERT_MALLOC(entry);\n        lv_memset_00(entry, sizeof(_lv_draw_mask_radius_circle_dsc_t));\n        entry->life = -1;\n    }\n    else {\n        entry->used_cnt++;\n        entry->life = 0;\n        CIRCLE_CACHE_AGING(entry->life, radius);\n    }\n\n    param->circle = entry;\n\n    circ_calc_aa4(param->circle, radius);\n}"}, "lv_draw_mask_fade_init": {"type": "Function", "def": "void lv_draw_mask_fade_init(lv_draw_mask_fade_param_t * param, const lv_area_t * coords, lv_opa_t opa_top,\n                            lv_coord_t y_top,\n                            lv_opa_t opa_bottom, lv_coord_t y_bottom)", "sline": 536, "body": "{\n    lv_area_copy(&param->cfg.coords, coords);\n    param->cfg.opa_top = opa_top;\n    param->cfg.opa_bottom = opa_bottom;\n    param->cfg.y_top = y_top;\n    param->cfg.y_bottom = y_bottom;\n    param->dsc.cb = (lv_draw_mask_xcb_t)lv_draw_mask_fade;\n    param->dsc.type = LV_DRAW_MASK_TYPE_FADE;\n}"}, "lv_draw_mask_map_init": {"type": "Function", "def": "void lv_draw_mask_map_init(lv_draw_mask_map_param_t * param, const lv_area_t * coords, const lv_opa_t * map)", "sline": 555, "body": "{\n    lv_area_copy(&param->cfg.coords, coords);\n    param->cfg.map = map;\n    param->dsc.cb = (lv_draw_mask_xcb_t)lv_draw_mask_map;\n    param->dsc.type = LV_DRAW_MASK_TYPE_MAP;\n}"}, "carbit_updater/lvgl/src/draw/lv_draw_mask.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_draw_mask.c"}}, "carbit_updater/lvgl/src/extra/widgets/spinner/lv_spinner.h": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 16}, "lv_spinner_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_spinner_class", "sline": 32}, "lv_spinner_create": {"type": "Function", "def": "lv_obj_t * lv_spinner_create(lv_obj_t * parent, uint32_t time, uint32_t arc_length)", "sline": 38}, "carbit_updater/lvgl/src/extra/widgets/spinner/lv_spinner.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/spinner/lv_spinner.h"}}, "carbit_updater/lvgl/tests/src/test_cases/test_dropdown.c": {"carbit_updater/lvgl/tests/src/test_cases/test_dropdown.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/tests/src/test_cases/test_dropdown.c"}}, "carbit_updater/lvgl/src/widgets/lv_label.c": {"lv_label": {"type": "Variable", "def": "#include lv_label.h", "sline": 9, "include": ["carbit_updater/lvgl/src/widgets/lv_label.h", null]}, "lv_obj": {"type": "Variable", "def": "#include ../core/lv_obj.h", "sline": 11}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 12}, "lv_group": {"type": "Variable", "def": "#include ../core/lv_group.h", "sline": 13}, "lv_draw": {"type": "Variable", "def": "#include ../draw/lv_draw.h", "sline": 14}, "lv_color": {"type": "Variable", "def": "#include ../misc/lv_color.h", "sline": 15}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 16}, "lv_bidi": {"type": "Variable", "def": "#include ../misc/lv_bidi.h", "sline": 17}, "lv_txt_ap": {"type": "Variable", "def": "#include ../misc/lv_txt_ap.h", "sline": 18}, "lv_printf": {"type": "Variable", "def": "#include ../misc/lv_printf.h", "sline": 19}, "lv_label_constructor": {"type": "Function", "def": "static void lv_label_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 688, "body": "{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_label_t * label = (lv_label_t *)obj;\n\n    label->text       = NULL;\n    label->static_txt = 0;\n    label->recolor    = 0;\n    label->dot_end    = LV_LABEL_DOT_END_INV;\n    label->long_mode  = LV_LABEL_LONG_WRAP;\n    label->offset.x = 0;\n    label->offset.y = 0;\n\n#if LV_LABEL_LONG_TXT_HINT\n    label->hint.line_start = -1;\n    label->hint.coord_y    = 0;\n    label->hint.y          = 0;\n#endif\n\n#if LV_LABEL_TEXT_SELECTION\n    label->sel_start = LV_DRAW_LABEL_NO_TXT_SEL;\n    label->sel_end   = LV_DRAW_LABEL_NO_TXT_SEL;\n#endif\n    label->dot.tmp_ptr   = NULL;\n    label->dot_tmp_alloc = 0;\n\n    lv_obj_clear_flag(obj, LV_OBJ_FLAG_CLICKABLE);\n    lv_label_set_long_mode(obj, LV_LABEL_LONG_WRAP);\n    lv_label_set_text(obj, \"Text\");\n\n\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}"}, "lv_label_destructor": {"type": "Function", "def": "static void lv_label_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 724, "body": "{\n    LV_UNUSED(class_p);\n    lv_label_t * label = (lv_label_t *)obj;\n\n    lv_label_dot_tmp_free(obj);\n    if(!label->static_txt) lv_mem_free(label->text);\n    label->text = NULL;\n}"}, "lv_label_event": {"type": "Function", "def": "static void lv_label_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 734, "body": "{\n    LV_UNUSED(class_p);\n\n    lv_res_t res;\n\n    /*Call the ancestor's event handler*/\n    res = lv_obj_event_base(MY_CLASS, e);\n    if(res != LV_RES_OK) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n\n    if(code == LV_EVENT_STYLE_CHANGED) {\n        /*Revert dots for proper refresh*/\n        lv_label_revert_dots(obj);\n        lv_label_refr_text(obj);\n    }\n    else if(code == LV_EVENT_REFR_EXT_DRAW_SIZE) {\n        /* Italic or other non-typical letters can be drawn of out of the object.\n         * It happens if box_w + ofs_x > adw_w in the glyph.\n         * To avoid this add some extra draw area.\n         * font_h / 4 is an empirical value. */\n        const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_MAIN);\n        lv_coord_t font_h = lv_font_get_line_height(font);\n        lv_event_set_ext_draw_size(e, font_h / 4);\n    }\n    else if(code == LV_EVENT_SIZE_CHANGED) {\n        lv_label_revert_dots(obj);\n        lv_label_refr_text(obj);\n    }\n    else if(code == LV_EVENT_GET_SELF_SIZE) {\n        lv_point_t size;\n        lv_label_t * label = (lv_label_t *)obj;\n        const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_MAIN);\n        lv_coord_t letter_space = lv_obj_get_style_text_letter_space(obj, LV_PART_MAIN);\n        lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);\n        lv_text_flag_t flag = LV_TEXT_FLAG_NONE;\n        if(label->recolor != 0) flag |= LV_TEXT_FLAG_RECOLOR;\n        if(label->expand != 0) flag |= LV_TEXT_FLAG_EXPAND;\n\n        lv_coord_t w = lv_obj_get_content_width(obj);\n        if(lv_obj_get_style_width(obj, LV_PART_MAIN) == LV_SIZE_CONTENT && !obj->w_layout) w = LV_COORD_MAX;\n        else w = lv_obj_get_content_width(obj);\n\n        lv_txt_get_size(&size, label->text, font, letter_space, line_space, w, flag);\n\n        lv_point_t * self_size = lv_event_get_param(e);\n        self_size->x = LV_MAX(self_size->x, size.x);\n        self_size->y = LV_MAX(self_size->y, size.y);\n    }\n    else if(code == LV_EVENT_DRAW_MAIN) {\n        draw_main(e);\n    }\n}"}, "draw_main": {"type": "Function", "def": "static void draw_main(lv_event_t * e)", "sline": 791, "body": "{\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_label_t * label = (lv_label_t *)obj;\n    const lv_area_t * clip_area = lv_event_get_param(e);\n\n    lv_area_t txt_coords;\n    lv_obj_get_content_coords(obj, &txt_coords);\n\n    lv_text_flag_t flag = LV_TEXT_FLAG_NONE;\n    if(label->recolor != 0) flag |= LV_TEXT_FLAG_RECOLOR;\n    if(label->expand != 0) flag |= LV_TEXT_FLAG_EXPAND;\n    if(lv_obj_get_style_width(obj, LV_PART_MAIN) == LV_SIZE_CONTENT && !obj->w_layout) flag |= LV_TEXT_FLAG_FIT;\n\n    lv_draw_label_dsc_t label_draw_dsc;\n    lv_draw_label_dsc_init(&label_draw_dsc);\n\n    label_draw_dsc.ofs_x = label->offset.x;\n    label_draw_dsc.ofs_y = label->offset.y;\n\n    label_draw_dsc.flag = flag;\n    lv_obj_init_draw_label_dsc(obj, LV_PART_MAIN, &label_draw_dsc);\n    lv_bidi_calculate_align(&label_draw_dsc.align, &label_draw_dsc.bidi_dir, label->text);\n\n    label_draw_dsc.sel_start = lv_label_get_text_selection_start(obj);\n    label_draw_dsc.sel_end = lv_label_get_text_selection_end(obj);\n    if(label_draw_dsc.sel_start != LV_DRAW_LABEL_NO_TXT_SEL && label_draw_dsc.sel_end != LV_DRAW_LABEL_NO_TXT_SEL) {\n        label_draw_dsc.sel_color = lv_obj_get_style_text_color_filtered(obj, LV_PART_SELECTED);\n        label_draw_dsc.sel_bg_color = lv_obj_get_style_bg_color(obj, LV_PART_SELECTED);\n    }\n\n    /* In SROLL and SROLL_CIRC mode the CENTER and RIGHT are pointless so remove them.\n     * (In addition they will result misalignment is this case)*/\n    if((label->long_mode == LV_LABEL_LONG_SCROLL || label->long_mode == LV_LABEL_LONG_SCROLL_CIRCULAR) &&\n       (label_draw_dsc.align == LV_TEXT_ALIGN_CENTER || label_draw_dsc.align == LV_TEXT_ALIGN_RIGHT)) {\n        lv_point_t size;\n        lv_txt_get_size(&size, label->text, label_draw_dsc.font, label_draw_dsc.letter_space, label_draw_dsc.line_space,\n                        LV_COORD_MAX, flag);\n        if(size.x > lv_area_get_width(&txt_coords)) {\n            label_draw_dsc.align = LV_TEXT_ALIGN_LEFT;\n        }\n    }\n#if LV_LABEL_LONG_TXT_HINT\n    lv_draw_label_hint_t * hint = &label->hint;\n    if(label->long_mode == LV_LABEL_LONG_SCROLL_CIRCULAR || lv_area_get_height(&txt_coords) < LV_LABEL_HINT_HEIGHT_LIMIT)\n        hint = NULL;\n\n#else\n    /*Just for compatibility*/\n    lv_draw_label_hint_t * hint = NULL;\n#endif\n\n    lv_area_t txt_clip;\n    bool is_common = _lv_area_intersect(&txt_clip, &txt_coords, clip_area);\n    if(!is_common) return;\n\n    if(label->long_mode == LV_LABEL_LONG_WRAP) {\n        lv_coord_t s = lv_obj_get_scroll_top(obj);\n        lv_area_move(&txt_coords, 0, -s);\n        txt_coords.y2 = obj->coords.y2;\n    }\n\n    if(label->long_mode == LV_LABEL_LONG_SCROLL || label->long_mode == LV_LABEL_LONG_SCROLL_CIRCULAR) {\n        lv_draw_label(&txt_coords, &txt_clip, &label_draw_dsc, label->text, hint);\n    } else {\n        lv_draw_label(&txt_coords, clip_area, &label_draw_dsc, label->text, hint);\n    }\n\n    if(label->long_mode == LV_LABEL_LONG_SCROLL_CIRCULAR) {\n        lv_point_t size;\n        lv_txt_get_size(&size, label->text, label_draw_dsc.font, label_draw_dsc.letter_space, label_draw_dsc.line_space,\n                        LV_COORD_MAX, flag);\n\n        /*Draw the text again on label to the original to make a circular effect */\n        if(size.x > lv_area_get_width(&txt_coords)) {\n            label_draw_dsc.ofs_x = label->offset.x + size.x +\n                                   lv_font_get_glyph_width(label_draw_dsc.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;\n            label_draw_dsc.ofs_y = label->offset.y;\n\n            lv_draw_label(&txt_coords, &txt_clip, &label_draw_dsc, label->text, hint);\n        }\n\n        /*Draw the text again below the original to make a circular effect */\n        if(size.y > lv_area_get_height(&txt_coords)) {\n            label_draw_dsc.ofs_x = label->offset.x;\n            label_draw_dsc.ofs_y = label->offset.y + size.y + lv_font_get_line_height(label_draw_dsc.font);\n\n            lv_draw_label(&txt_coords, &txt_clip, &label_draw_dsc, label->text, hint);\n        }\n    }\n}"}, "lv_label_refr_text": {"type": "Function", "def": "static void lv_label_refr_text(lv_obj_t * obj)", "sline": 887, "body": "{\n    lv_label_t * label = (lv_label_t *)obj;\n    if(label->text == NULL) return;\n#if LV_LABEL_LONG_TXT_HINT\n    label->hint.line_start = -1; /*The hint is invalid if the text changes*/\n#endif\n\n    lv_area_t txt_coords;\n    lv_obj_get_content_coords(obj, &txt_coords);\n    lv_coord_t max_w         = lv_area_get_width(&txt_coords);\n    const lv_font_t * font   = lv_obj_get_style_text_font(obj, LV_PART_MAIN);\n    lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);\n    lv_coord_t letter_space = lv_obj_get_style_text_letter_space(obj, LV_PART_MAIN);\n\n    /*Calc. the height and longest line*/\n    lv_point_t size;\n    lv_text_flag_t flag = LV_TEXT_FLAG_NONE;\n    if(label->recolor != 0) flag |= LV_TEXT_FLAG_RECOLOR;\n    if(label->expand != 0) flag |= LV_TEXT_FLAG_EXPAND;\n    if(lv_obj_get_style_width(obj, LV_PART_MAIN) == LV_SIZE_CONTENT && !obj->w_layout) flag |= LV_TEXT_FLAG_FIT;\n\n    lv_txt_get_size(&size, label->text, font, letter_space, line_space, max_w, flag);\n\n    lv_obj_refresh_self_size(obj);\n\n    /*In scroll mode start an offset animations*/\n    if(label->long_mode == LV_LABEL_LONG_SCROLL) {\n        uint16_t anim_speed = lv_obj_get_style_anim_speed(obj, LV_PART_MAIN);\n        if(anim_speed == 0) anim_speed = LV_LABEL_DEF_SCROLL_SPEED;\n        lv_anim_t a;\n        lv_anim_init(&a);\n        lv_anim_set_var(&a, obj);\n        lv_anim_set_repeat_count(&a, LV_ANIM_REPEAT_INFINITE);\n        lv_anim_set_playback_delay(&a, LV_LABEL_SCROLL_DELAY);\n        lv_anim_set_repeat_delay(&a, a.playback_delay);\n\n        bool hor_anim = false;\n        if(size.x > lv_area_get_width(&txt_coords)) {\n#if LV_USE_BIDI\n            int32_t start, end;\n            lv_base_dir_t base_dir = lv_obj_get_style_base_dir(obj, LV_PART_MAIN);\n\n            if(base_dir == LV_BASE_DIR_AUTO)\n                base_dir = _lv_bidi_detect_base_dir(label->text);\n\n            if(base_dir == LV_BASE_DIR_RTL) {\n                start = lv_area_get_width(&txt_coords) - size.x;\n                end = 0;\n            }\n            else {\n                start = 0;\n                end = lv_area_get_width(&txt_coords) - size.x;\n            }\n\n            lv_anim_set_values(&a, start, end);\n#else\n            lv_anim_set_values(&a, 0, lv_area_get_width(&txt_coords) - size.x);\n            lv_anim_set_exec_cb(&a, set_ofs_x_anim);\n#endif\n            lv_anim_set_exec_cb(&a, set_ofs_x_anim);\n\n            lv_anim_t * anim_cur = lv_anim_get(obj, set_ofs_x_anim);\n            int32_t act_time = 0;\n            bool playback_now = false;\n            if(anim_cur) {\n                act_time = anim_cur->act_time;\n                playback_now = anim_cur->playback_now;\n            }\n            if(act_time < a.time) {\n                a.act_time = act_time;      /*To keep the old position*/\n                a.early_apply = 0;\n                if(playback_now) {\n                    a.playback_now = 1;\n                    /*Swap the start and end values*/\n                    int32_t tmp;\n                    tmp      = a.start_value;\n                    a.start_value = a.end_value;\n                    a.end_value   = tmp;\n                }\n            }\n\n            lv_anim_set_time(&a, lv_anim_speed_to_time(anim_speed, a.start_value, a.end_value));\n            lv_anim_set_playback_time(&a, a.time);\n            lv_anim_start(&a);\n            hor_anim = true;\n        }\n        else {\n            /*Delete the offset animation if not required*/\n            lv_anim_del(obj, set_ofs_x_anim);\n            label->offset.x = 0;\n        }\n\n        if(size.y > lv_area_get_height(&txt_coords) && hor_anim == false) {\n            lv_anim_set_values(&a, 0, lv_area_get_height(&txt_coords) - size.y - (lv_font_get_line_height(font)));\n            lv_anim_set_exec_cb(&a, set_ofs_y_anim);\n\n            lv_anim_t * anim_cur = lv_anim_get(obj, set_ofs_y_anim);\n            int32_t act_time = 0;\n            bool playback_now = false;\n            if(anim_cur) {\n                act_time = anim_cur->act_time;\n                playback_now = anim_cur->playback_now;\n            }\n            if(act_time < a.time) {\n                a.act_time = act_time;      /*To keep the old position*/\n                a.early_apply = 0;\n                if(playback_now) {\n                    a.playback_now = 1;\n                    /*Swap the start and end values*/\n                    int32_t tmp;\n                    tmp      = a.start_value;\n                    a.start_value = a.end_value;\n                    a.end_value   = tmp;\n                }\n            }\n\n            lv_anim_set_time(&a, lv_anim_speed_to_time(anim_speed, a.start_value, a.end_value));\n            lv_anim_set_playback_time(&a, a.time);\n            lv_anim_start(&a);\n        }\n        else {\n            /*Delete the offset animation if not required*/\n            lv_anim_del(obj, set_ofs_y_anim);\n            label->offset.y = 0;\n        }\n    }\n    /*In roll inf. mode keep the size but start offset animations*/\n    else if(label->long_mode == LV_LABEL_LONG_SCROLL_CIRCULAR) {\n        uint16_t anim_speed = lv_obj_get_style_anim_speed(obj, LV_PART_MAIN);\n        if(anim_speed == 0) anim_speed = LV_LABEL_DEF_SCROLL_SPEED;\n        lv_anim_t a;\n        lv_anim_init(&a);\n        lv_anim_set_var(&a, obj);\n        lv_anim_set_repeat_count(&a, LV_ANIM_REPEAT_INFINITE);\n\n        bool hor_anim = false;\n        if(size.x > lv_area_get_width(&txt_coords)) {\n#if LV_USE_BIDI\n            int32_t start, end;\n            lv_base_dir_t base_dir = lv_obj_get_style_base_dir(obj, LV_PART_MAIN);\n\n            if(base_dir == LV_BASE_DIR_AUTO)\n                base_dir = _lv_bidi_detect_base_dir(label->text);\n\n            if(base_dir == LV_BASE_DIR_RTL) {\n                start = -size.x - lv_font_get_glyph_width(font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;\n                end = 0;\n            }\n            else {\n                start = 0;\n                end = -size.x - lv_font_get_glyph_width(font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;\n            }\n\n            lv_anim_set_values(&a, start, end);\n#else\n            lv_anim_set_values(&a, 0, -size.x - lv_font_get_glyph_width(font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT);\n#endif\n            lv_anim_set_exec_cb(&a, set_ofs_x_anim);\n            lv_anim_set_time(&a, lv_anim_speed_to_time(anim_speed, a.start_value, a.end_value));\n\n            lv_anim_t * anim_cur = lv_anim_get(obj, set_ofs_x_anim);\n            int32_t act_time = anim_cur ? anim_cur->act_time : 0;\n            if(act_time < a.time) {\n                a.act_time = act_time;      /*To keep the old position*/\n                a.early_apply = 0;\n            }\n\n            lv_anim_start(&a);\n            hor_anim = true;\n        }\n        else {\n            /*Delete the offset animation if not required*/\n            lv_anim_del(obj, set_ofs_x_anim);\n            label->offset.x = 0;\n        }\n\n        if(size.y > lv_area_get_height(&txt_coords) && hor_anim == false) {\n            lv_anim_set_values(&a, 0, -size.y - (lv_font_get_line_height(font)));\n            lv_anim_set_exec_cb(&a, set_ofs_y_anim);\n            lv_anim_set_time(&a, lv_anim_speed_to_time(anim_speed, a.start_value, a.end_value));\n\n            lv_anim_t * anim_cur = lv_anim_get(obj, set_ofs_y_anim);\n            int32_t act_time = anim_cur ? anim_cur->act_time : 0;\n            if(act_time < a.time) {\n                a.act_time = act_time;      /*To keep the old position*/\n                a.early_apply = 0;\n            }\n\n            lv_anim_start(&a);\n        }\n        else {\n            /*Delete the offset animation if not required*/\n            lv_anim_del(obj, set_ofs_y_anim);\n            label->offset.y = 0;\n        }\n    }\n    else if(label->long_mode == LV_LABEL_LONG_DOT) {\n        if(size.y <= lv_area_get_height(&txt_coords)) { /*No dots are required, the text is short enough*/\n            label->dot_end = LV_LABEL_DOT_END_INV;\n        }\n        else if(_lv_txt_get_encoded_length(label->text) <= LV_LABEL_DOT_NUM) {   /*Don't turn to dots all the characters*/\n            label->dot_end = LV_LABEL_DOT_END_INV;\n        }\n        else {\n            lv_point_t p;\n            lv_coord_t y_overed;\n            p.x = lv_area_get_width(&txt_coords) -\n                  (lv_font_get_glyph_width(font, '.', '.') + letter_space) *\n                  LV_LABEL_DOT_NUM; /*Shrink with dots*/\n            p.y = lv_area_get_height(&txt_coords);\n            y_overed = p.y %\n                       (lv_font_get_line_height(font) + line_space); /*Round down to the last line*/\n            if(y_overed >= lv_font_get_line_height(font)) {\n                p.y -= y_overed;\n                p.y += lv_font_get_line_height(font);\n            }\n            else {\n                p.y -= y_overed;\n                p.y -= line_space;\n            }\n\n            uint32_t letter_id = lv_label_get_letter_on(obj, &p);\n\n            /*Be sure there is space for the dots*/\n            size_t txt_len = strlen(label->text);\n            uint32_t byte_id     = _lv_txt_encoded_get_byte_id(label->text, letter_id);\n            while(byte_id + LV_LABEL_DOT_NUM > txt_len) {\n                _lv_txt_encoded_prev(label->text, &byte_id);\n                letter_id--;\n            }\n\n            /*Save letters under the dots and replace them with dots*/\n            uint32_t byte_id_ori = byte_id;\n            uint32_t i;\n            uint8_t len = 0;\n            for(i = 0; i <= LV_LABEL_DOT_NUM; i++) {\n                len += _lv_txt_encoded_size(&label->text[byte_id]);\n                _lv_txt_encoded_next(label->text, &byte_id);\n                if (len > LV_LABEL_DOT_NUM || byte_id > txt_len) {\n                    break;\n                }\n            }\n\n            if(lv_label_set_dot_tmp(obj, &label->text[byte_id_ori], len)) {\n                for(i = 0; i < LV_LABEL_DOT_NUM; i++) {\n                    label->text[byte_id_ori + i] = '.';\n                }\n                label->text[byte_id_ori + LV_LABEL_DOT_NUM] = '\\0';\n                label->dot_end                              = letter_id + LV_LABEL_DOT_NUM;\n            }\n        }\n    }\n    else if(label->long_mode == LV_LABEL_LONG_CLIP) {\n        /*Do nothing*/\n    }\n\n    lv_obj_invalidate(obj);\n}"}, "lv_label_revert_dots": {"type": "Function", "def": "static void lv_label_revert_dots(lv_obj_t * obj)", "sline": 1148, "body": "{\n\n    lv_label_t * label = (lv_label_t *)obj;\n\n    if(label->long_mode != LV_LABEL_LONG_DOT) return;\n    if(label->dot_end == LV_LABEL_DOT_END_INV) return;\n    uint32_t letter_i = label->dot_end - LV_LABEL_DOT_NUM;\n    uint32_t byte_i   = _lv_txt_encoded_get_byte_id(label->text, letter_i);\n\n    /*Restore the characters*/\n    uint8_t i      = 0;\n    char * dot_tmp = lv_label_get_dot_tmp(obj);\n    while(label->text[byte_i + i] != '\\0') {\n        label->text[byte_i + i] = dot_tmp[i];\n        i++;\n    }\n    label->text[byte_i + i] = dot_tmp[i];\n    lv_label_dot_tmp_free(obj);\n\n    label->dot_end = LV_LABEL_DOT_END_INV;\n}"}, "lv_label_set_dot_tmp": {"type": "Function", "def": "static bool lv_label_set_dot_tmp(lv_obj_t * obj, char * data, uint32_t len)", "sline": 1178, "body": "{\n\n    lv_label_t * label = (lv_label_t *)obj;\n    lv_label_dot_tmp_free(obj); /*Deallocate any existing space*/\n    if(len > sizeof(char *)) {\n        /*Memory needs to be allocated. Allocates an additional byte\n         *for a NULL-terminator so it can be copied.*/\n        label->dot.tmp_ptr = lv_mem_alloc(len + 1);\n        if(label->dot.tmp_ptr == NULL) {\n            LV_LOG_ERROR(\"Failed to allocate memory for dot_tmp_ptr\");\n            return false;\n        }\n        lv_memcpy(label->dot.tmp_ptr, data, len);\n        label->dot.tmp_ptr[len] = '\\0';\n        label->dot_tmp_alloc    = true;\n    }\n    else {\n        /*Characters can be directly stored in object*/\n        label->dot_tmp_alloc = false;\n        lv_memcpy(label->dot.tmp, data, len);\n    }\n    return true;\n}"}, "lv_label_get_dot_tmp": {"type": "Function", "def": "static char * lv_label_get_dot_tmp(lv_obj_t * obj)", "sline": 1208, "body": "{\n    lv_label_t * label = (lv_label_t *)obj;\n    if(label->dot_tmp_alloc) {\n        return label->dot.tmp_ptr;\n    }\n    else {\n        return label->dot.tmp;\n    }\n}"}, "lv_label_dot_tmp_free": {"type": "Function", "def": "static void lv_label_dot_tmp_free(lv_obj_t * obj)", "sline": 1224, "body": "{\n    lv_label_t * label = (lv_label_t *)obj;\n    if(label->dot_tmp_alloc && label->dot.tmp_ptr) {\n        lv_mem_free(label->dot.tmp_ptr);\n    }\n    label->dot_tmp_alloc = false;\n    label->dot.tmp_ptr   = NULL;\n}"}, "set_ofs_x_anim": {"type": "Function", "def": "static void set_ofs_x_anim(void * obj, int32_t v)", "sline": 1235, "body": "{\n    lv_label_t * label = (lv_label_t *)obj;\n    label->offset.x    = v;\n    lv_obj_invalidate(obj);\n}"}, "set_ofs_y_anim": {"type": "Function", "def": "static void set_ofs_y_anim(void * obj, int32_t v)", "sline": 1242, "body": "{\n    lv_label_t * label = (lv_label_t *)obj;\n    label->offset.y    = v;\n    lv_obj_invalidate(obj);\n}"}, "lv_label_class": {"type": "Variable", "def": "const lv_obj_class_t lv_label_class = {\n    .constructor_cb = lv_label_constructor,\n    .destructor_cb = lv_label_destructor,\n    .event_cb = lv_label_event,\n    .width_def = LV_SIZE_CONTENT,\n    .height_def = LV_SIZE_CONTENT,\n    .instance_size = sizeof(lv_label_t),\n    .base_class = &lv_obj_class\n}", "sline": 55}, "lv_label_create": {"type": "Function", "def": "lv_obj_t * lv_label_create(lv_obj_t * parent)", "sline": 73, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_label_set_text": {"type": "Function", "def": "void lv_label_set_text(lv_obj_t * obj, const char * text)", "sline": 85, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_label_t * label = (lv_label_t *)obj;\n\n    lv_obj_invalidate(obj);\n\n    /*If text is NULL then just refresh with the current text*/\n    if(text == NULL) text = label->text;\n\n    if(label->text == text && label->static_txt == 0) {\n        /*If set its own text then reallocate it (maybe its size changed)*/\n#if LV_USE_ARABIC_PERSIAN_CHARS\n        /*Get the size of the text and process it*/\n        size_t len = _lv_txt_ap_calc_bytes_cnt(text);\n\n        label->text = lv_mem_realloc(label->text, len);\n        LV_ASSERT_MALLOC(label->text);\n        if(label->text == NULL) return;\n\n        _lv_txt_ap_proc(label->text, label->text);\n#else\n        label->text = lv_mem_realloc(label->text, strlen(label->text) + 1);\n#endif\n\n        LV_ASSERT_MALLOC(label->text);\n        if(label->text == NULL) return;\n    }\n    else {\n        /*Free the old text*/\n        if(label->text != NULL && label->static_txt == 0) {\n            lv_mem_free(label->text);\n            label->text = NULL;\n        }\n\n#if LV_USE_ARABIC_PERSIAN_CHARS\n        /*Get the size of the text and process it*/\n        size_t len = _lv_txt_ap_calc_bytes_cnt(text);\n\n        label->text = lv_mem_alloc(len);\n        LV_ASSERT_MALLOC(label->text);\n        if(label->text == NULL) return;\n\n        _lv_txt_ap_proc(text, label->text);\n#else\n        /*Get the size of the text*/\n        size_t len = strlen(text) + 1;\n\n        /*Allocate space for the new text*/\n        label->text = lv_mem_alloc(len);\n        LV_ASSERT_MALLOC(label->text);\n        if(label->text == NULL) return;\n        strcpy(label->text, text);\n#endif\n\n        /*Now the text is dynamically allocated*/\n        label->static_txt = 0;\n    }\n\n    lv_label_refr_text(obj);\n}"}, "lv_label_set_text_fmt": {"type": "Function", "def": "void lv_label_set_text_fmt(lv_obj_t * obj, const char * fmt, ...)", "sline": 147, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(fmt);\n\n    lv_obj_invalidate(obj);\n    lv_label_t * label = (lv_label_t *)obj;\n\n    /*If text is NULL then refresh*/\n    if(fmt == NULL) {\n        lv_label_refr_text(obj);\n        return;\n    }\n\n    if(label->text != NULL && label->static_txt == 0) {\n        lv_mem_free(label->text);\n        label->text = NULL;\n    }\n\n    va_list args;\n    va_start(args, fmt);\n    label->text = _lv_txt_set_text_vfmt(fmt, args);\n    va_end(args);\n    label->static_txt = 0; /*Now the text is dynamically allocated*/\n\n    lv_label_refr_text(obj);\n}"}, "lv_label_set_text_static": {"type": "Function", "def": "void lv_label_set_text_static(lv_obj_t * obj, const char * text)", "sline": 175, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_label_t * label = (lv_label_t *)obj;\n\n    if(label->static_txt == 0 && label->text != NULL) {\n        lv_mem_free(label->text);\n        label->text = NULL;\n    }\n\n    if(text != NULL) {\n        label->static_txt = 1;\n        label->text       = (char *)text;\n    }\n\n    lv_label_refr_text(obj);\n}"}, "lv_label_set_long_mode": {"type": "Function", "def": "void lv_label_set_long_mode(lv_obj_t * obj, lv_label_long_mode_t long_mode)", "sline": 193, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_label_t * label = (lv_label_t *)obj;\n\n    /*Delete the old animation (if exists)*/\n    lv_anim_del(obj, set_ofs_x_anim);\n    lv_anim_del(obj, set_ofs_y_anim);\n    label->offset.x = 0;\n    label->offset.y = 0;\n\n    if(long_mode == LV_LABEL_LONG_SCROLL || long_mode == LV_LABEL_LONG_SCROLL_CIRCULAR || long_mode == LV_LABEL_LONG_CLIP)\n        label->expand = 1;\n    else\n        label->expand = 0;\n\n    /*Restore the character under the dots*/\n    if(label->long_mode == LV_LABEL_LONG_DOT && label->dot_end != LV_LABEL_DOT_END_INV) {\n        lv_label_revert_dots(obj);\n    }\n\n    label->long_mode = long_mode;\n    lv_label_refr_text(obj);\n}"}, "lv_label_set_recolor": {"type": "Function", "def": "void lv_label_set_recolor(lv_obj_t * obj, bool en)", "sline": 219, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_label_t * label = (lv_label_t *)obj;\n    if(label->recolor == en) return;\n\n    label->recolor = en == false ? 0 : 1;\n\n    /*Refresh the text because the potential color codes in text needs to be hidden or revealed*/\n    lv_label_refr_text(obj);\n}"}, "lv_label_set_text_sel_start": {"type": "Function", "def": "void lv_label_set_text_sel_start(lv_obj_t * obj, uint32_t index)", "sline": 232, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n#if LV_LABEL_TEXT_SELECTION\n    lv_label_t * label = (lv_label_t *)obj;\n    label->sel_start   = index;\n    lv_obj_invalidate(obj);\n#else\n    LV_UNUSED(obj);    /*Unused*/\n    LV_UNUSED(index);  /*Unused*/\n#endif\n}"}, "lv_label_set_text_sel_end": {"type": "Function", "def": "void lv_label_set_text_sel_end(lv_obj_t * obj, uint32_t index)", "sline": 246, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n#if LV_LABEL_TEXT_SELECTION\n    lv_label_t * label = (lv_label_t *)obj;\n    label->sel_end     = index;\n    lv_obj_invalidate(obj);\n#else\n    LV_UNUSED(obj);   /*Unused*/\n    LV_UNUSED(index); /*Unused*/\n#endif\n}"}, "lv_label_get_text": {"type": "Function", "def": "char * lv_label_get_text(const lv_obj_t * obj)", "sline": 264, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_label_t * label = (lv_label_t *)obj;\n    return label->text;\n}"}, "lv_label_get_long_mode": {"type": "Function", "def": "lv_label_long_mode_t lv_label_get_long_mode(const lv_obj_t * obj)", "sline": 271, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_label_t * label = (lv_label_t *)obj;\n    return label->long_mode;\n}"}, "lv_label_get_recolor": {"type": "Function", "def": "bool lv_label_get_recolor(const lv_obj_t * obj)", "sline": 278, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_label_t * label = (lv_label_t *)obj;\n    return label->recolor == 0 ? false : true;\n}"}, "lv_label_get_letter_pos": {"type": "Function", "def": "void lv_label_get_letter_pos(const lv_obj_t * obj, uint32_t char_id, lv_point_t * pos)", "sline": 286, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(pos);\n\n    lv_label_t * label = (lv_label_t *)obj;\n    const char * txt         = lv_label_get_text(obj);\n    lv_text_align_t align = lv_obj_calculate_style_text_align(obj, LV_PART_MAIN, txt);\n\n    if(txt[0] == '\\0') {\n        pos->y = 0;\n        switch(align) {\n            case LV_TEXT_ALIGN_LEFT:\n                pos->x = 0;\n                break;\n            case LV_TEXT_ALIGN_RIGHT:\n                pos->x = lv_obj_get_content_width(obj);\n                break;\n            case LV_TEXT_ALIGN_CENTER:\n                pos->x = lv_obj_get_content_width(obj) / 2;\n                break;\n        }\n        return;\n    }\n\n    lv_area_t txt_coords;\n    lv_obj_get_content_coords(obj, &txt_coords);\n\n    uint32_t line_start      = 0;\n    uint32_t new_line_start  = 0;\n    lv_coord_t max_w         = lv_area_get_width(&txt_coords);\n    const lv_font_t * font   = lv_obj_get_style_text_font(obj, LV_PART_MAIN);\n    lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);\n    lv_coord_t letter_space = lv_obj_get_style_text_letter_space(obj, LV_PART_MAIN);\n    lv_coord_t letter_height    = lv_font_get_line_height(font);\n    lv_coord_t y             = 0;\n    lv_text_flag_t flag       = LV_TEXT_FLAG_NONE;\n\n    if(label->recolor != 0) flag |= LV_TEXT_FLAG_RECOLOR;\n    if(label->expand != 0) flag |= LV_TEXT_FLAG_EXPAND;\n    if(lv_obj_get_style_width(obj, LV_PART_MAIN) == LV_SIZE_CONTENT && !obj->w_layout) flag |= LV_TEXT_FLAG_FIT;\n\n    uint32_t byte_id = _lv_txt_encoded_get_byte_id(txt, char_id);\n\n    /*Search the line of the index letter*/;\n    while(txt[new_line_start] != '\\0') {\n        new_line_start += _lv_txt_get_next_line(&txt[line_start], font, letter_space, max_w, flag);\n        if(byte_id < new_line_start || txt[new_line_start] == '\\0')\n            break; /*The line of 'index' letter begins at 'line_start'*/\n\n        y += letter_height + line_space;\n        line_start = new_line_start;\n    }\n\n    /*If the last character is line break then go to the next line*/\n    if(byte_id > 0) {\n        if((txt[byte_id - 1] == '\\n' || txt[byte_id - 1] == '\\r') && txt[byte_id] == '\\0') {\n            y += letter_height + line_space;\n            line_start = byte_id;\n        }\n    }\n\n    const char * bidi_txt;\n    uint32_t visual_byte_pos;\n#if LV_USE_BIDI\n    lv_base_dir_t base_dir = lv_obj_get_style_base_dir(obj, LV_PART_MAIN);\n    if(base_dir == LV_BASE_DIR_AUTO) base_dir = _lv_bidi_detect_base_dir(txt);\n\n    char * mutable_bidi_txt = NULL;\n    /*Handle Bidi*/\n    if(new_line_start == byte_id) {\n        visual_byte_pos = base_dir == LV_BASE_DIR_RTL ? 0 : byte_id - line_start;\n        bidi_txt =  &txt[line_start];\n    }\n    else {\n        uint32_t line_char_id = _lv_txt_encoded_get_char_id(&txt[line_start], byte_id - line_start);\n\n        bool is_rtl;\n        uint32_t visual_char_pos = _lv_bidi_get_visual_pos(&txt[line_start], &mutable_bidi_txt, new_line_start - line_start,\n                                                           base_dir, line_char_id, &is_rtl);\n        bidi_txt = mutable_bidi_txt;\n        if(is_rtl) visual_char_pos++;\n\n        visual_byte_pos = _lv_txt_encoded_get_byte_id(bidi_txt, visual_char_pos);\n    }\n#else\n    bidi_txt = &txt[line_start];\n    visual_byte_pos = byte_id - line_start;\n#endif\n\n    /*Calculate the x coordinate*/\n    lv_coord_t x = lv_txt_get_width(bidi_txt, visual_byte_pos, font, letter_space, flag);\n    if(char_id != line_start) x += letter_space;\n\n    if(align == LV_TEXT_ALIGN_CENTER) {\n        lv_coord_t line_w;\n        line_w = lv_txt_get_width(bidi_txt, new_line_start - line_start, font, letter_space, flag);\n        x += lv_area_get_width(&txt_coords) / 2 - line_w / 2;\n\n    }\n    else if(align == LV_TEXT_ALIGN_RIGHT) {\n        lv_coord_t line_w;\n        line_w = lv_txt_get_width(bidi_txt, new_line_start - line_start, font, letter_space, flag);\n\n        x += lv_area_get_width(&txt_coords) - line_w;\n    }\n    pos->x = x;\n    pos->y = y;\n\n#if LV_USE_BIDI\n    if(mutable_bidi_txt) lv_mem_buf_release(mutable_bidi_txt);\n#endif\n}"}, "lv_label_get_letter_on": {"type": "Function", "def": "uint32_t lv_label_get_letter_on(const lv_obj_t * obj, lv_point_t * pos_in)", "sline": 400, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(pos_in);\n    lv_label_t * label = (lv_label_t *)obj;\n\n    lv_point_t pos;\n    pos.x = pos_in->x - lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n    pos.y = pos_in->y - lv_obj_get_style_pad_top(obj, LV_PART_MAIN);\n\n    lv_area_t txt_coords;\n    lv_obj_get_content_coords(obj, &txt_coords);\n    const char * txt         = lv_label_get_text(obj);\n    uint32_t line_start      = 0;\n    uint32_t new_line_start  = 0;\n    lv_coord_t max_w         = lv_area_get_width(&txt_coords);\n    const lv_font_t * font   = lv_obj_get_style_text_font(obj, LV_PART_MAIN);\n    lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);\n    lv_coord_t letter_space = lv_obj_get_style_text_letter_space(obj, LV_PART_MAIN);\n    lv_coord_t letter_height    = lv_font_get_line_height(font);\n    lv_coord_t y             = 0;\n    lv_text_flag_t flag       = LV_TEXT_FLAG_NONE;\n    uint32_t logical_pos;\n    char * bidi_txt;\n\n    if(label->recolor != 0) flag |= LV_TEXT_FLAG_RECOLOR;\n    if(label->expand != 0) flag |= LV_TEXT_FLAG_EXPAND;\n    if(lv_obj_get_style_width(obj, LV_PART_MAIN) == LV_SIZE_CONTENT && !obj->w_layout) flag |= LV_TEXT_FLAG_FIT;\n\n    lv_text_align_t align = lv_obj_calculate_style_text_align(obj, LV_PART_MAIN, label->text);\n\n    /*Search the line of the index letter*/;\n    while(txt[line_start] != '\\0') {\n        new_line_start += _lv_txt_get_next_line(&txt[line_start], font, letter_space, max_w, flag);\n\n        if(pos.y <= y + letter_height) {\n            /*The line is found (stored in 'line_start')*/\n            /*Include the NULL terminator in the last line*/\n            uint32_t tmp = new_line_start;\n            uint32_t letter;\n            letter = _lv_txt_encoded_prev(txt, &tmp);\n            if(letter != '\\n' && txt[new_line_start] == '\\0') new_line_start++;\n            break;\n        }\n        y += letter_height + line_space;\n\n        line_start = new_line_start;\n    }\n\n#if LV_USE_BIDI\n    bidi_txt = lv_mem_buf_get(new_line_start - line_start + 1);\n    uint32_t txt_len = new_line_start - line_start;\n    if(new_line_start > 0 && txt[new_line_start - 1] == '\\0' && txt_len > 0) txt_len--;\n    _lv_bidi_process_paragraph(txt + line_start, bidi_txt, txt_len, lv_obj_get_style_base_dir(obj, LV_PART_MAIN), NULL, 0);\n#else\n    bidi_txt = (char *)txt + line_start;\n#endif\n\n    /*Calculate the x coordinate*/\n    lv_coord_t x = 0;\n    if(align == LV_TEXT_ALIGN_CENTER) {\n        lv_coord_t line_w;\n        line_w = lv_txt_get_width(bidi_txt, new_line_start - line_start, font, letter_space, flag);\n        x += lv_area_get_width(&txt_coords) / 2 - line_w / 2;\n    }\n    else if(align == LV_TEXT_ALIGN_RIGHT) {\n        lv_coord_t line_w;\n        line_w = lv_txt_get_width(bidi_txt, new_line_start - line_start, font, letter_space, flag);\n        x += lv_area_get_width(&txt_coords) - line_w;\n    }\n\n    lv_text_cmd_state_t cmd_state = LV_TEXT_CMD_STATE_WAIT;\n\n    uint32_t i = 0;\n    uint32_t i_act = i;\n\n    if(new_line_start > 0) {\n        while(i + line_start < new_line_start) {\n            /*Get the current letter and the next letter for kerning*/\n            /*Be careful 'i' already points to the next character*/\n            uint32_t letter;\n            uint32_t letter_next;\n            _lv_txt_encoded_letter_next_2(bidi_txt, &letter, &letter_next, &i);\n\n            /*Handle the recolor command*/\n            if((flag & LV_TEXT_FLAG_RECOLOR) != 0) {\n                if(_lv_txt_is_cmd(&cmd_state, bidi_txt[i]) != false) {\n                    continue; /*Skip the letter if it is part of a command*/\n                }\n            }\n\n            lv_coord_t gw = lv_font_get_glyph_width(font, letter, letter_next);\n\n            /*Finish if the x position or the last char of the next line is reached*/\n            if(pos.x < x + gw || i + line_start == new_line_start ||  txt[i_act + line_start] == '\\0') {\n                i = i_act;\n                break;\n            }\n            x += gw;\n            x += letter_space;\n            i_act = i;\n        }\n    }\n\n#if LV_USE_BIDI\n    /*Handle Bidi*/\n    uint32_t cid = _lv_txt_encoded_get_char_id(bidi_txt, i);\n    if(txt[line_start + i] == '\\0') {\n        logical_pos = i;\n    }\n    else {\n        bool is_rtl;\n        logical_pos = _lv_bidi_get_logical_pos(&txt[line_start], NULL,\n                                               txt_len, lv_obj_get_style_base_dir(obj, LV_PART_MAIN), cid, &is_rtl);\n        if(is_rtl) logical_pos++;\n    }\n    lv_mem_buf_release(bidi_txt);\n#else\n    logical_pos = _lv_txt_encoded_get_char_id(bidi_txt, i);\n#endif\n\n    return  logical_pos + _lv_txt_encoded_get_char_id(txt, line_start);\n}"}, "lv_label_is_char_under_pos": {"type": "Function", "def": "bool lv_label_is_char_under_pos(const lv_obj_t * obj, lv_point_t * pos)", "sline": 524, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(pos);\n\n    lv_area_t txt_coords;\n    lv_obj_get_content_coords(obj, &txt_coords);\n    const char * txt         = lv_label_get_text(obj);\n    lv_label_t * label     = (lv_label_t *)obj;\n    uint32_t line_start      = 0;\n    uint32_t new_line_start  = 0;\n    lv_coord_t max_w         = lv_area_get_width(&txt_coords);\n    const lv_font_t * font   = lv_obj_get_style_text_font(obj, LV_PART_MAIN);\n    lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);\n    lv_coord_t letter_space = lv_obj_get_style_text_letter_space(obj, LV_PART_MAIN);\n    lv_coord_t letter_height    = lv_font_get_line_height(font);\n    lv_text_align_t align = lv_obj_calculate_style_text_align(obj, LV_PART_MAIN, label->text);\n\n    lv_coord_t y             = 0;\n    lv_text_flag_t flag       = LV_TEXT_FLAG_NONE;\n\n    if(label->recolor != 0) flag |= LV_TEXT_FLAG_RECOLOR;\n    if(label->expand != 0) flag |= LV_TEXT_FLAG_EXPAND;\n    if(lv_obj_get_style_width(obj, LV_PART_MAIN) == LV_SIZE_CONTENT && !obj->w_layout) flag |= LV_TEXT_FLAG_FIT;\n\n    /*Search the line of the index letter*/;\n    while(txt[line_start] != '\\0') {\n        new_line_start += _lv_txt_get_next_line(&txt[line_start], font, letter_space, max_w, flag);\n\n        if(pos->y <= y + letter_height) break; /*The line is found (stored in 'line_start')*/\n        y += letter_height + line_space;\n\n        line_start = new_line_start;\n    }\n\n    /*Calculate the x coordinate*/\n    lv_coord_t x      = 0;\n    lv_coord_t last_x = 0;\n    if(align == LV_TEXT_ALIGN_CENTER) {\n        lv_coord_t line_w;\n        line_w = lv_txt_get_width(&txt[line_start], new_line_start - line_start, font, letter_space, flag);\n        x += lv_area_get_width(&txt_coords) / 2 - line_w / 2;\n    }\n    else if(align == LV_TEXT_ALIGN_RIGHT) {\n        lv_coord_t line_w;\n        line_w = lv_txt_get_width(&txt[line_start], new_line_start - line_start, font, letter_space, flag);\n        x += lv_area_get_width(&txt_coords) - line_w;\n    }\n\n    lv_text_cmd_state_t cmd_state = LV_TEXT_CMD_STATE_WAIT;\n\n    uint32_t i           = line_start;\n    uint32_t i_current   = i;\n    uint32_t letter      = '\\0';\n    uint32_t letter_next = '\\0';\n\n    if(new_line_start > 0) {\n        while(i <= new_line_start - 1) {\n            /*Get the current letter and the next letter for kerning*/\n            /*Be careful 'i' already points to the next character*/\n            _lv_txt_encoded_letter_next_2(txt, &letter, &letter_next, &i);\n\n            /*Handle the recolor command*/\n            if((flag & LV_TEXT_FLAG_RECOLOR) != 0) {\n                if(_lv_txt_is_cmd(&cmd_state, txt[i]) != false) {\n                    continue; /*Skip the letter if it is part of a command*/\n                }\n            }\n            last_x = x;\n            x += lv_font_get_glyph_width(font, letter, letter_next);\n            if(pos->x < x) {\n                i = i_current;\n                break;\n            }\n            x += letter_space;\n            i_current = i;\n        }\n    }\n\n    int32_t max_diff = lv_font_get_glyph_width(font, letter, letter_next) + letter_space + 1;\n    return (pos->x >= (last_x - letter_space) && pos->x <= (last_x + max_diff));\n}"}, "lv_label_get_text_selection_start": {"type": "Function", "def": "uint32_t lv_label_get_text_selection_start(const lv_obj_t * obj)", "sline": 607, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n#if LV_LABEL_TEXT_SELECTION\n    lv_label_t * label = (lv_label_t *)obj;\n    return label->sel_start;\n\n#else\n    LV_UNUSED(obj); /*Unused*/\n    return LV_LABEL_TEXT_SELECTION_OFF;\n#endif\n}"}, "lv_label_get_text_selection_end": {"type": "Function", "def": "uint32_t lv_label_get_text_selection_end(const lv_obj_t * obj)", "sline": 621, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n#if LV_LABEL_TEXT_SELECTION\n    lv_label_t * label = (lv_label_t *)obj;\n    return label->sel_end;\n#else\n    LV_UNUSED(obj); /*Unused*/\n    return LV_LABEL_TEXT_SELECTION_OFF;\n#endif\n}"}, "lv_label_ins_text": {"type": "Function", "def": "void lv_label_ins_text(lv_obj_t * obj, uint32_t pos, const char * txt)", "sline": 638, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(txt);\n\n    lv_label_t * label = (lv_label_t *)obj;\n\n    /*Can not append to static text*/\n    if(label->static_txt != 0) return;\n\n    lv_obj_invalidate(obj);\n\n    /*Allocate space for the new text*/\n    size_t old_len = strlen(label->text);\n    size_t ins_len = strlen(txt);\n    size_t new_len = ins_len + old_len;\n    label->text        = lv_mem_realloc(label->text, new_len + 1);\n    LV_ASSERT_MALLOC(label->text);\n    if(label->text == NULL) return;\n\n    if(pos == LV_LABEL_POS_LAST) {\n        pos = _lv_txt_get_encoded_length(label->text);\n    }\n\n    _lv_txt_ins(label->text, pos, txt);\n    lv_label_set_text(obj, NULL);\n}"}, "lv_label_cut_text": {"type": "Function", "def": "void lv_label_cut_text(lv_obj_t * obj, uint32_t pos, uint32_t cnt)", "sline": 666, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_label_t * label = (lv_label_t *)obj;\n\n    /*Can not append to static text*/\n    if(label->static_txt != 0) return;\n\n    lv_obj_invalidate(obj);\n\n    char * label_txt = lv_label_get_text(obj);\n    /*Delete the characters*/\n    _lv_txt_cut(label_txt, pos, cnt);\n\n    /*Refresh the label*/\n    lv_label_refr_text(obj);\n}"}, "carbit_updater/lvgl/src/widgets/lv_label.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_label.c"}}, "carbit_updater/lvgl/src/hal/lv_hal_tick.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 18}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 19}, "lv_tick_get": {"type": "Function", "def": "uint32_t lv_tick_get(void)", "sline": 52}, "lv_tick_elaps": {"type": "Function", "def": "uint32_t lv_tick_elaps(uint32_t prev_tick)", "sline": 59}, "carbit_updater/lvgl/src/hal/lv_hal_tick.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/hal/lv_hal_tick.h"}}, "carbit_updater/lvgl/src/core/lv_group.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 17}, "stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 19}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 20}, "lv_ll": {"type": "Variable", "def": "#include ../misc/lv_ll.h", "sline": 21}, "lv_types": {"type": "Variable", "def": "#include ../misc/lv_types.h", "sline": 22}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_group.h:29:1)": {"type": "Enum", "def": "enum {\n    LV_KEY_UP        = 17,  /*0x11*/\n    LV_KEY_DOWN      = 18,  /*0x12*/\n    LV_KEY_RIGHT     = 19,  /*0x13*/\n    LV_KEY_LEFT      = 20,  /*0x14*/\n    LV_KEY_ESC       = 27,  /*0x1B*/\n    LV_KEY_DEL       = 127, /*0x7F*/\n    LV_KEY_BACKSPACE = 8,   /*0x08*/\n    LV_KEY_ENTER     = 10,  /*0x0A, '\\n'*/\n    LV_KEY_NEXT      = 9,   /*0x09, '\\t'*/\n    LV_KEY_PREV      = 11,  /*0x0B, '*/\n    LV_KEY_HOME      = 2,   /*0x02, STX*/\n    LV_KEY_END       = 3,   /*0x03, ETX*/\n}", "sline": 29, "docstring": "/*Predefined keys to control the focused object via lv_group_send(group, c)*/"}, "lv_key_t": {"type": "Variable", "def": "typedef uint8_t lv_key_t", "sline": 43}, "_lv_obj_t": {"type": "Struct", "def": "struct _lv_obj_t", "sline": 49}, "_lv_group_t": {"type": "Struct", "def": "struct _lv_group_t {\n    lv_ll_t obj_ll;        /**< Linked list to store the objects in the group*/\n    struct _lv_obj_t ** obj_focus; /**< The object in focus*/\n\n    lv_group_focus_cb_t focus_cb;              /**< A function to call when a new object is focused (optional)*/\n#if LV_USE_USER_DATA\n    void * user_data;\n#endif\n\n    uint8_t frozen : 1;         /**< 1: can't focus to new object*/\n    uint8_t editing : 1;        /**< 1: Edit mode, 0: Navigate mode*/\n    uint8_t refocus_policy : 1; /**< 1: Focus prev if focused on deletion. 0: Focus next if focused on\n                                   deletion.*/\n    uint8_t wrap : 1;           /**< 1: Focus next/prev can wrap at end of list. 0: Focus next/prev stops at end\n                                   of list.*/\n}", "sline": 58, "body": "lv_ll_t obj_ll\nstruct _lv_obj_t ** obj_focus\nlv_group_focus_cb_t focus_cb\nvoid * user_data\nuint8_t frozen : 1\nuint8_t editing : 1\nuint8_t refocus_policy : 1\nuint8_t wrap : 1\n"}, "lv_group_focus_cb_t": {"type": "Variable", "def": "typedef void (*lv_group_focus_cb_t)(struct _lv_group_t *)", "sline": 52}, "_lv_group_t.obj_ll": {"type": "Variable", "def": "lv_ll_t obj_ll", "sline": 59, "in_struct": "_lv_group_t"}, "_lv_group_t.obj_focus": {"type": "Variable", "def": "struct _lv_obj_t ** obj_focus", "sline": 60, "in_struct": "_lv_group_t"}, "_lv_group_t.focus_cb": {"type": "Variable", "def": "lv_group_focus_cb_t focus_cb", "sline": 62, "in_struct": "_lv_group_t", "rels": [["lv_group_focus_cb_t", null, "Typeof"]]}, "_lv_group_t.user_data": {"type": "Variable", "def": "void * user_data", "sline": 64, "in_struct": "_lv_group_t"}, "_lv_group_t.frozen": {"type": "Variable", "def": "uint8_t frozen : 1", "sline": 67, "in_struct": "_lv_group_t"}, "_lv_group_t.editing": {"type": "Variable", "def": "uint8_t editing : 1", "sline": 68, "in_struct": "_lv_group_t"}, "_lv_group_t.refocus_policy": {"type": "Variable", "def": "uint8_t refocus_policy : 1", "sline": 69, "in_struct": "_lv_group_t"}, "_lv_group_t.wrap": {"type": "Variable", "def": "uint8_t wrap : 1", "sline": 71, "in_struct": "_lv_group_t"}, "lv_group_t": {"type": "Variable", "def": "typedef struct _lv_group_t {\n    lv_ll_t obj_ll;        /**< Linked list to store the objects in the group*/\n    struct _lv_obj_t ** obj_focus; /**< The object in focus*/\n\n    lv_group_focus_cb_t focus_cb;              /**< A function to call when a new object is focused (optional)*/\n#if LV_USE_USER_DATA\n    void * user_data;\n#endif\n\n    uint8_t frozen : 1;         /**< 1: can't focus to new object*/\n    uint8_t editing : 1;        /**< 1: Edit mode, 0: Navigate mode*/\n    uint8_t refocus_policy : 1; /**< 1: Focus prev if focused on deletion. 0: Focus next if focused on\n                                   deletion.*/\n    uint8_t wrap : 1;           /**< 1: Focus next/prev can wrap at end of list. 0: Focus next/prev stops at end\n                                   of list.*/\n} lv_group_t", "sline": 73}, "lv_group_refocus_policy_t": {"type": "Variable", "def": "typedef enum {\n    LV_GROUP_REFOCUS_POLICY_NEXT = 0,\n    LV_GROUP_REFOCUS_POLICY_PREV = 1\n} lv_group_refocus_policy_t", "sline": 79}, "_lv_group_init": {"type": "Function", "def": "void _lv_group_init(void)", "sline": 89}, "lv_group_create": {"type": "Function", "def": "lv_group_t * lv_group_create(void)", "sline": 95}, "lv_group_del": {"type": "Function", "def": "void lv_group_del(lv_group_t * group)", "sline": 101}, "lv_group_set_default": {"type": "Function", "def": "void lv_group_set_default(lv_group_t * group)", "sline": 107}, "lv_group_get_default": {"type": "Function", "def": "lv_group_t * lv_group_get_default(void)", "sline": 113}, "lv_group_add_obj": {"type": "Function", "def": "void lv_group_add_obj(lv_group_t * group, struct _lv_obj_t * obj)", "sline": 120}, "lv_group_swap_obj": {"type": "Function", "def": "void lv_group_swap_obj(struct _lv_obj_t * obj1, struct _lv_obj_t * obj2)", "sline": 127}, "lv_group_remove_obj": {"type": "Function", "def": "void lv_group_remove_obj(struct _lv_obj_t * obj)", "sline": 133}, "lv_group_remove_all_objs": {"type": "Function", "def": "void lv_group_remove_all_objs(lv_group_t * group)", "sline": 139}, "lv_group_focus_obj": {"type": "Function", "def": "void lv_group_focus_obj(struct _lv_obj_t * obj)", "sline": 145}, "lv_group_focus_next": {"type": "Function", "def": "void lv_group_focus_next(lv_group_t * group)", "sline": 151}, "lv_group_focus_prev": {"type": "Function", "def": "void lv_group_focus_prev(lv_group_t * group)", "sline": 157}, "lv_group_focus_freeze": {"type": "Function", "def": "void lv_group_focus_freeze(lv_group_t * group, bool en)", "sline": 164}, "lv_group_send_data": {"type": "Function", "def": "lv_res_t lv_group_send_data(lv_group_t * group, uint32_t c)", "sline": 172}, "lv_group_set_focus_cb": {"type": "Function", "def": "void lv_group_set_focus_cb(lv_group_t * group, lv_group_focus_cb_t focus_cb)", "sline": 179}, "lv_group_set_refocus_policy": {"type": "Function", "def": "void lv_group_set_refocus_policy(lv_group_t * group, lv_group_refocus_policy_t policy)", "sline": 187}, "lv_group_set_editing": {"type": "Function", "def": "void lv_group_set_editing(lv_group_t * group, bool edit)", "sline": 194}, "lv_group_set_wrap": {"type": "Function", "def": "void lv_group_set_wrap(lv_group_t * group, bool en)", "sline": 201}, "lv_group_get_focused": {"type": "Function", "def": "struct _lv_obj_t * lv_group_get_focused(const lv_group_t * group)", "sline": 208}, "lv_group_get_focus_cb": {"type": "Function", "def": "lv_group_focus_cb_t lv_group_get_focus_cb(const lv_group_t * group)", "sline": 215, "rels": [["lv_group_focus_cb_t", null, "Typeof"]]}, "lv_group_get_editing": {"type": "Function", "def": "bool lv_group_get_editing(const lv_group_t * group)", "sline": 222}, "lv_group_get_wrap": {"type": "Function", "def": "bool lv_group_get_wrap(lv_group_t * group)", "sline": 229}, "lv_group_get_obj_count": {"type": "Function", "def": "uint32_t lv_group_get_obj_count(lv_group_t * group)", "sline": 236}, "carbit_updater/lvgl/src/core/lv_group.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_group.h"}}, "carbit_updater/lvgl/src/widgets/lv_img.c": {"lv_img": {"type": "Variable", "def": "#include lv_img.h", "sline": 9, "include": ["carbit_updater/lvgl/src/widgets/lv_img.h", null]}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 12}, "lv_img_decoder": {"type": "Variable", "def": "#include ../draw/lv_img_decoder.h", "sline": 13}, "lv_fs": {"type": "Variable", "def": "#include ../misc/lv_fs.h", "sline": 14}, "lv_txt": {"type": "Variable", "def": "#include ../misc/lv_txt.h", "sline": 15}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 16}, "lv_log": {"type": "Variable", "def": "#include ../misc/lv_log.h", "sline": 17}, "lv_img_constructor": {"type": "Function", "def": "static void lv_img_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 382, "body": "{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_img_t * img = (lv_img_t *)obj;\n\n    img->src       = NULL;\n    img->src_type  = LV_IMG_SRC_UNKNOWN;\n    img->cf        = LV_IMG_CF_UNKNOWN;\n    img->w         = lv_obj_get_width(obj);\n    img->h         = lv_obj_get_height(obj);\n    img->angle = 0;\n    img->zoom = LV_IMG_ZOOM_NONE;\n    img->antialias = LV_COLOR_DEPTH > 8 ? 1 : 0;\n    img->offset.x  = 0;\n    img->offset.y  = 0;\n    img->pivot.x = 0;\n    img->pivot.y = 0;\n    img->obj_size_mode = LV_IMG_SIZE_MODE_VIRTUAL;\n\n    lv_obj_clear_flag(obj, LV_OBJ_FLAG_CLICKABLE);\n    lv_obj_add_flag(obj, LV_OBJ_FLAG_ADV_HITTEST);\n\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}"}, "lv_img_destructor": {"type": "Function", "def": "static void lv_img_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 409, "body": "{\n    LV_UNUSED(class_p);\n    lv_img_t * img = (lv_img_t *)obj;\n    if(img->src_type == LV_IMG_SRC_FILE || img->src_type == LV_IMG_SRC_SYMBOL) {\n        lv_mem_free((void *)img->src);\n        img->src      = NULL;\n        img->src_type = LV_IMG_SRC_UNKNOWN;\n    }\n}"}, "lv_img_event": {"type": "Function", "def": "static void lv_img_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 438, "body": "{\n    LV_UNUSED(class_p);\n\n    lv_event_code_t code = lv_event_get_code(e);\n\n    /*Ancestor events will be called during drawing*/\n    if(code != LV_EVENT_DRAW_MAIN && code != LV_EVENT_DRAW_POST) {\n        /*Call the ancestor's event handler*/\n        lv_res_t res = lv_obj_event_base(MY_CLASS, e);\n        if(res != LV_RES_OK) return;\n    }\n\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_img_t * img = (lv_img_t *)obj;\n\n    if(code == LV_EVENT_STYLE_CHANGED) {\n        /*Refresh the file name to refresh the symbol text size*/\n        if(img->src_type == LV_IMG_SRC_SYMBOL) {\n            lv_img_set_src(obj, img->src);\n        }\n        else {\n            /*With transformation it might change*/\n            lv_obj_refresh_ext_draw_size(obj);\n        }\n    }\n    else if(code == LV_EVENT_REFR_EXT_DRAW_SIZE) {\n\n        lv_coord_t * s = lv_event_get_param(e);\n        lv_coord_t transf_zoom = lv_obj_get_style_transform_zoom(obj, LV_PART_MAIN);\n        transf_zoom = ((int32_t)transf_zoom * img->zoom) >> 8;\n\n        lv_coord_t transf_angle = lv_obj_get_style_transform_angle(obj, LV_PART_MAIN);\n        transf_angle += img->angle;\n\n        /*If the image has angle provide enough room for the rotated corners*/\n        if(transf_angle || transf_zoom != LV_IMG_ZOOM_NONE) {\n            lv_area_t a;\n            lv_coord_t w = lv_obj_get_width(obj);\n            lv_coord_t h = lv_obj_get_height(obj);\n            _lv_img_buf_get_transformed_area(&a, w, h, transf_angle, transf_zoom, &img->pivot);\n            lv_coord_t pad_ori = *s;\n            *s = LV_MAX(*s, pad_ori - a.x1);\n            *s = LV_MAX(*s, pad_ori - a.y1);\n            *s = LV_MAX(*s, pad_ori + a.x2 - w);\n            *s = LV_MAX(*s, pad_ori + a.y2 - h);\n        }\n    }\n    else if(code == LV_EVENT_HIT_TEST) {\n        lv_hit_test_info_t * info = lv_event_get_param(e);\n        lv_coord_t zoom = lv_obj_get_style_transform_zoom(obj, LV_PART_MAIN);\n        zoom = (zoom * img->zoom) >> 8;\n\n        lv_coord_t angle = lv_obj_get_style_transform_angle(obj, LV_PART_MAIN);\n        angle += img->angle;\n\n        /*If the object is exactly image sized (not cropped, not mosaic) and transformed\n         *perform hit test on its transformed area*/\n        if(img->w == lv_obj_get_width(obj) && img->h == lv_obj_get_height(obj) &&\n           (zoom != LV_IMG_ZOOM_NONE || angle != 0 || img->pivot.x != img->w / 2 || img->pivot.y != img->h / 2)) {\n\n            lv_coord_t w = lv_obj_get_width(obj);\n            lv_coord_t h = lv_obj_get_height(obj);\n            lv_area_t coords;\n            _lv_img_buf_get_transformed_area(&coords, w, h, angle, zoom, &img->pivot);\n            coords.x1 += obj->coords.x1;\n            coords.y1 += obj->coords.y1;\n            coords.x2 += obj->coords.x1;\n            coords.y2 += obj->coords.y1;\n\n            info->res = _lv_area_is_point_on(&coords, info->point, 0);\n        }\n        else {\n            lv_area_t a;\n            lv_obj_get_click_area(obj, &a);\n            info->res = _lv_area_is_point_on(&a, info->point, 0);\n        }\n    }\n    else if(code == LV_EVENT_GET_SELF_SIZE) {\n        lv_point_t * p = lv_event_get_param(e);\n        if(img->obj_size_mode == LV_IMG_SIZE_MODE_REAL) {\n            *p = lv_img_get_transformed_size(obj);\n        }\n        else {\n            p->x = img->w;\n            p->y = img->h;\n        }\n    }\n    else if(code == LV_EVENT_DRAW_MAIN || code == LV_EVENT_DRAW_POST || code == LV_EVENT_COVER_CHECK) {\n        draw_img(e);\n    }\n}"}, "draw_img": {"type": "Function", "def": "static void draw_img(lv_event_t * e)", "sline": 531, "body": "{\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_img_t * img = (lv_img_t *)obj;\n    if(code == LV_EVENT_COVER_CHECK) {\n        lv_cover_check_info_t * info = lv_event_get_param(e);\n        if(info->res == LV_COVER_RES_MASKED) return;\n        if(img->src_type == LV_IMG_SRC_UNKNOWN || img->src_type == LV_IMG_SRC_SYMBOL) {\n            info->res = LV_COVER_RES_NOT_COVER;\n            return;\n        }\n\n        /*Non true color format might have \"holes\"*/\n        if(img->cf != LV_IMG_CF_TRUE_COLOR && img->cf != LV_IMG_CF_RAW) {\n            info->res = LV_COVER_RES_NOT_COVER;\n            return;\n        }\n\n        /*With not LV_OPA_COVER images can't cover an area */\n        if(lv_obj_get_style_img_opa(obj, LV_PART_MAIN) != LV_OPA_COVER) {\n            info->res = LV_COVER_RES_NOT_COVER;\n            return;\n        }\n\n        int32_t angle_final = lv_obj_get_style_transform_angle(obj, LV_PART_MAIN);\n        angle_final += img->angle;\n\n        if(angle_final != 0) {\n            info->res = LV_COVER_RES_NOT_COVER;\n            return;\n        }\n\n        int32_t zoom_final = lv_obj_get_style_transform_zoom(obj, LV_PART_MAIN);\n        zoom_final = (zoom_final * img->zoom) >> 8;\n\n        const lv_area_t * clip_area = lv_event_get_param(e);\n        if(zoom_final == LV_IMG_ZOOM_NONE) {\n            if(_lv_area_is_in(clip_area, &obj->coords, 0) == false) {\n                info->res = LV_COVER_RES_NOT_COVER;\n                return;\n            }\n        }\n        else {\n            lv_area_t a;\n            _lv_img_buf_get_transformed_area(&a, lv_obj_get_width(obj), lv_obj_get_height(obj), 0, zoom_final, &img->pivot);\n            a.x1 += obj->coords.x1;\n            a.y1 += obj->coords.y1;\n            a.x2 += obj->coords.x1;\n            a.y2 += obj->coords.y1;\n\n            if(_lv_area_is_in(clip_area, &a, 0) == false) {\n                info->res = LV_COVER_RES_NOT_COVER;\n                return;\n            }\n        }\n    }\n    else if(code == LV_EVENT_DRAW_MAIN || code == LV_EVENT_DRAW_POST) {\n\n        int32_t zoom_final = lv_obj_get_style_transform_zoom(obj, LV_PART_MAIN);\n        zoom_final = (zoom_final * img->zoom) >> 8;\n\n        int32_t angle_final = lv_obj_get_style_transform_angle(obj, LV_PART_MAIN);\n        angle_final += img->angle;\n\n        lv_coord_t obj_w = lv_obj_get_width(obj);\n        lv_coord_t obj_h = lv_obj_get_height(obj);\n\n        lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n        lv_coord_t pleft = lv_obj_get_style_pad_left(obj, LV_PART_MAIN) + border_width;\n        lv_coord_t pright = lv_obj_get_style_pad_right(obj, LV_PART_MAIN) + border_width;\n        lv_coord_t ptop = lv_obj_get_style_pad_top(obj, LV_PART_MAIN) + border_width;\n        lv_coord_t pbottom = lv_obj_get_style_pad_bottom(obj, LV_PART_MAIN) + border_width;\n\n        lv_point_t bg_pivot;\n        bg_pivot.x = img->pivot.x + pleft;\n        bg_pivot.y = img->pivot.y + ptop;\n        lv_area_t bg_coords;\n\n        if(img->obj_size_mode == LV_IMG_SIZE_MODE_REAL) {\n            /*Object size equals to transformed image size*/\n            lv_obj_get_coords(obj, &bg_coords);\n        }\n        else {\n            _lv_img_buf_get_transformed_area(&bg_coords, obj_w, obj_h,\n                                             angle_final, zoom_final, &bg_pivot);\n\n            /*Modify the coordinates to draw the background for the rotated and scaled coordinates*/\n            bg_coords.x1 += obj->coords.x1;\n            bg_coords.y1 += obj->coords.y1;\n            bg_coords.x2 += obj->coords.x1;\n            bg_coords.y2 += obj->coords.y1;\n        }\n\n        lv_area_t ori_coords;\n        lv_area_copy(&ori_coords, &obj->coords);\n        lv_area_copy(&obj->coords, &bg_coords);\n\n        lv_res_t res = lv_obj_event_base(MY_CLASS, e);\n        if(res != LV_RES_OK) return;\n\n        lv_area_copy(&obj->coords, &ori_coords);\n\n        if(code == LV_EVENT_DRAW_MAIN) {\n            if(img->h == 0 || img->w == 0) return;\n            if(zoom_final == 0) return;\n\n            const lv_area_t * clip_area = lv_event_get_param(e);\n\n            lv_area_t img_max_area;\n            lv_area_copy(&img_max_area, &obj->coords);\n\n            lv_point_t img_size_final = lv_img_get_transformed_size(obj);\n\n            if(img->obj_size_mode == LV_IMG_SIZE_MODE_REAL) {\n                img_max_area.x1 -= ((img->w - img_size_final.x) + 1) / 2;\n                img_max_area.x2 -= ((img->w - img_size_final.x) + 1) / 2;\n                img_max_area.y1 -= ((img->h - img_size_final.y) + 1) / 2;\n                img_max_area.y2 -= ((img->h - img_size_final.y) + 1) / 2;\n            }\n            else {\n                img_max_area.x2 = img_max_area.x1 + lv_area_get_width(&bg_coords) - 1;\n                img_max_area.y2 = img_max_area.y1 + lv_area_get_height(&bg_coords) - 1;\n            }\n\n            img_max_area.x1 += pleft;\n            img_max_area.y1 += ptop;\n            img_max_area.x2 -= pright;\n            img_max_area.y2 -= pbottom;\n\n            if(img->src_type == LV_IMG_SRC_FILE || img->src_type == LV_IMG_SRC_VARIABLE) {\n                lv_draw_img_dsc_t img_dsc;\n                lv_draw_img_dsc_init(&img_dsc);\n                lv_obj_init_draw_img_dsc(obj, LV_PART_MAIN, &img_dsc);\n\n                img_dsc.zoom = zoom_final;\n                img_dsc.angle = angle_final;\n                img_dsc.pivot.x = img->pivot.x;\n                img_dsc.pivot.y = img->pivot.y;\n                img_dsc.antialias = img->antialias;\n\n                lv_area_t img_clip_area;\n                img_clip_area.x1 = bg_coords.x1 + pleft;\n                img_clip_area.y1 = bg_coords.y1 + ptop;\n                img_clip_area.x2 = bg_coords.x2 - pright;\n                img_clip_area.y2 = bg_coords.y2 - pbottom;\n\n                _lv_area_intersect(&img_clip_area, clip_area, &img_clip_area);\n\n                lv_area_t coords_tmp;\n                coords_tmp.y1 = img_max_area.y1 + img->offset.y;\n                if(coords_tmp.y1 > img_max_area.y1) coords_tmp.y1 -= img->h;\n                coords_tmp.y2 = coords_tmp.y1 + img->h - 1;\n\n                for(; coords_tmp.y1 < img_max_area.y2; coords_tmp.y1 += img_size_final.y, coords_tmp.y2 += img_size_final.y) {\n                    coords_tmp.x1 = img_max_area.x1 + img->offset.x;\n                    if(coords_tmp.x1 > img_max_area.x1) coords_tmp.x1 -= img->w;\n                    coords_tmp.x2 = coords_tmp.x1 + img->w - 1;\n\n                    for(; coords_tmp.x1 < img_max_area.x2; coords_tmp.x1 += img_size_final.x, coords_tmp.x2 += img_size_final.x) {\n                        lv_draw_img(&coords_tmp, &img_clip_area, img->src, &img_dsc);\n                    }\n                }\n            }\n            else if(img->src_type == LV_IMG_SRC_SYMBOL) {\n                lv_draw_label_dsc_t label_dsc;\n                lv_draw_label_dsc_init(&label_dsc);\n                lv_obj_init_draw_label_dsc(obj, LV_PART_MAIN, &label_dsc);\n\n                lv_draw_label(&obj->coords, clip_area, &label_dsc, img->src, NULL);\n            }\n            else {\n                /*Trigger the error handler of image draw*/\n                LV_LOG_WARN(\"draw_img: image source type is unknown\");\n                lv_draw_img(&obj->coords, clip_area, NULL, NULL);\n            }\n        }\n    }\n}"}, "lv_img_class": {"type": "Variable", "def": "const lv_obj_class_t lv_img_class = {\n    .constructor_cb = lv_img_constructor,\n    .destructor_cb = lv_img_destructor,\n    .event_cb = lv_img_event,\n    .width_def = LV_SIZE_CONTENT,\n    .height_def = LV_SIZE_CONTENT,\n    .instance_size = sizeof(lv_img_t),\n    .base_class = &lv_obj_class\n}", "sline": 39}, "lv_img_create": {"type": "Function", "def": "lv_obj_t * lv_img_create(lv_obj_t * parent)", "sline": 57, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_img_set_src": {"type": "Function", "def": "void lv_img_set_src(lv_obj_t * obj, const void * src)", "sline": 69, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_obj_invalidate(obj);\n\n    lv_img_src_t src_type = lv_img_src_get_type(src);\n    lv_img_t * img = (lv_img_t *)obj;\n\n#if LV_USE_LOG && LV_LOG_LEVEL >= LV_LOG_LEVEL_INFO\n    switch(src_type) {\n        case LV_IMG_SRC_FILE:\n            LV_LOG_TRACE(\"lv_img_set_src: `LV_IMG_SRC_FILE` type found\");\n            break;\n        case LV_IMG_SRC_VARIABLE:\n            LV_LOG_TRACE(\"lv_img_set_src: `LV_IMG_SRC_VARIABLE` type found\");\n            break;\n        case LV_IMG_SRC_SYMBOL:\n            LV_LOG_TRACE(\"lv_img_set_src: `LV_IMG_SRC_SYMBOL` type found\");\n            break;\n        default:\n            LV_LOG_WARN(\"lv_img_set_src: unknown type\");\n    }\n#endif\n\n    /*If the new source type is unknown free the memories of the old source*/\n    if(src_type == LV_IMG_SRC_UNKNOWN) {\n        LV_LOG_WARN(\"lv_img_set_src: unknown image type\");\n        if(img->src_type == LV_IMG_SRC_SYMBOL || img->src_type == LV_IMG_SRC_FILE) {\n            lv_mem_free((void *)img->src);\n        }\n        img->src      = NULL;\n        img->src_type = LV_IMG_SRC_UNKNOWN;\n        return;\n    }\n\n    lv_img_header_t header;\n    lv_img_decoder_get_info(src, &header);\n\n    /*Save the source*/\n    if(src_type == LV_IMG_SRC_VARIABLE) {\n        /*If memory was allocated because of the previous `src_type` then free it*/\n        if(img->src_type == LV_IMG_SRC_FILE || img->src_type == LV_IMG_SRC_SYMBOL) {\n            lv_mem_free((void *)img->src);\n        }\n        img->src = src;\n    }\n    else if(src_type == LV_IMG_SRC_FILE || src_type == LV_IMG_SRC_SYMBOL) {\n        /*If the new and the old src are the same then it was only a refresh.*/\n        if(img->src != src) {\n            const void * old_src = NULL;\n            /*If memory was allocated because of the previous `src_type` then save its pointer and free after allocation.\n             *It's important to allocate first to be sure the new data will be on a new address.\n             *Else `img_cache` wouldn't see the change in source.*/\n            if(img->src_type == LV_IMG_SRC_FILE || img->src_type == LV_IMG_SRC_SYMBOL) {\n                old_src = img->src;\n            }\n            char * new_str = lv_mem_alloc(strlen(src) + 1);\n            LV_ASSERT_MALLOC(new_str);\n            if(new_str == NULL) return;\n            strcpy(new_str, src);\n            img->src = new_str;\n\n            if(old_src) lv_mem_free((void *)old_src);\n        }\n    }\n\n    if(src_type == LV_IMG_SRC_SYMBOL) {\n        /*`lv_img_dsc_get_info` couldn't set the with and height of a font so set it here*/\n        const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_MAIN);\n        lv_coord_t letter_space = lv_obj_get_style_text_letter_space(obj, LV_PART_MAIN);\n        lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);\n        lv_point_t size;\n        lv_txt_get_size(&size, src, font, letter_space, line_space, LV_COORD_MAX, LV_TEXT_FLAG_NONE);\n        header.w = size.x;\n        header.h = size.y;\n    }\n\n    img->src_type = src_type;\n    img->w        = header.w;\n    img->h        = header.h;\n    img->cf       = header.cf;\n    img->pivot.x = header.w / 2;\n    img->pivot.y = header.h / 2;\n\n    lv_obj_refresh_self_size(obj);\n\n    /*Provide enough room for the rotated corners*/\n    if(img->angle || img->zoom != LV_IMG_ZOOM_NONE) lv_obj_refresh_ext_draw_size(obj);\n\n    lv_obj_invalidate(obj);\n}"}, "lv_img_set_offset_x": {"type": "Function", "def": "void lv_img_set_offset_x(lv_obj_t * obj, lv_coord_t x)", "sline": 162, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_img_t * img = (lv_img_t *)obj;\n\n    x = x % img->w;\n\n    img->offset.x = x;\n    lv_obj_invalidate(obj);\n}"}, "lv_img_set_offset_y": {"type": "Function", "def": "void lv_img_set_offset_y(lv_obj_t * obj, lv_coord_t y)", "sline": 174, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_img_t * img = (lv_img_t *)obj;\n\n    y = y % img->h;\n\n    img->offset.y = y;\n    lv_obj_invalidate(obj);\n}"}, "lv_img_set_angle": {"type": "Function", "def": "void lv_img_set_angle(lv_obj_t * obj, int16_t angle)", "sline": 186, "body": "{\n    if(angle < 0 || angle >= 3600) angle = angle % 3600;\n\n    lv_img_t * img = (lv_img_t *)obj;\n    if(angle == img->angle) return;\n\n    lv_coord_t transf_zoom = lv_obj_get_style_transform_zoom(obj, LV_PART_MAIN);\n    transf_zoom = ((int32_t)transf_zoom * img->zoom) >> 8;\n\n    lv_coord_t transf_angle = lv_obj_get_style_transform_angle(obj, LV_PART_MAIN);\n\n    lv_coord_t w = lv_obj_get_width(obj);\n    lv_coord_t h = lv_obj_get_height(obj);\n    lv_area_t a;\n    _lv_img_buf_get_transformed_area(&a, w, h, transf_angle + img->angle, transf_zoom, &img->pivot);\n    a.x1 += obj->coords.x1;\n    a.y1 += obj->coords.y1;\n    a.x2 += obj->coords.x1;\n    a.y2 += obj->coords.y1;\n    lv_obj_invalidate_area(obj, &a);\n\n    img->angle = angle;\n    lv_obj_refresh_ext_draw_size(obj);\n\n    _lv_img_buf_get_transformed_area(&a, w, h, transf_angle + img->angle, transf_zoom, &img->pivot);\n    a.x1 += obj->coords.x1;\n    a.y1 += obj->coords.y1;\n    a.x2 += obj->coords.x1;\n    a.y2 += obj->coords.y1;\n    lv_obj_invalidate_area(obj, &a);\n}"}, "lv_img_set_pivot": {"type": "Function", "def": "void lv_img_set_pivot(lv_obj_t * obj, lv_coord_t x, lv_coord_t y)", "sline": 219, "body": "{\n    lv_img_t * img = (lv_img_t *)obj;\n    if(img->pivot.x == x && img->pivot.y == y) return;\n\n    lv_coord_t transf_zoom = lv_obj_get_style_transform_zoom(obj, LV_PART_MAIN);\n    transf_zoom = ((int32_t)transf_zoom * img->zoom) >> 8;\n\n    lv_coord_t transf_angle = lv_obj_get_style_transform_angle(obj, LV_PART_MAIN);\n    transf_angle += img->angle;\n\n    lv_coord_t w = lv_obj_get_width(obj);\n    lv_coord_t h = lv_obj_get_height(obj);\n    lv_area_t a;\n    _lv_img_buf_get_transformed_area(&a, w, h, transf_angle, transf_zoom, &img->pivot);\n    a.x1 += obj->coords.x1;\n    a.y1 += obj->coords.y1;\n    a.x2 += obj->coords.x1;\n    a.y2 += obj->coords.y1;\n    lv_obj_invalidate_area(obj, &a);\n\n    img->pivot.x = x;\n    img->pivot.y = y;\n    lv_obj_refresh_ext_draw_size(obj);\n\n    _lv_img_buf_get_transformed_area(&a, w, h, transf_angle, transf_zoom, &img->pivot);\n    a.x1 += obj->coords.x1;\n    a.y1 += obj->coords.y1;\n    a.x2 += obj->coords.x1;\n    a.y2 += obj->coords.y1;\n    lv_obj_invalidate_area(obj, &a);\n}"}, "lv_img_set_zoom": {"type": "Function", "def": "void lv_img_set_zoom(lv_obj_t * obj, uint16_t zoom)", "sline": 252, "body": "{\n    lv_img_t * img = (lv_img_t *)obj;\n    if(zoom == img->zoom) return;\n\n    if(zoom == 0) zoom = 1;\n\n    lv_coord_t transf_zoom = lv_obj_get_style_transform_zoom(obj, LV_PART_MAIN);\n\n    lv_coord_t transf_angle = lv_obj_get_style_transform_angle(obj, LV_PART_MAIN);\n    transf_angle += img->angle;\n\n    lv_coord_t w = lv_obj_get_width(obj);\n    lv_coord_t h = lv_obj_get_height(obj);\n    lv_area_t a;\n    _lv_img_buf_get_transformed_area(&a, w, h, transf_angle, ((int32_t)transf_zoom * img->zoom) >> 8, &img->pivot);\n    a.x1 += obj->coords.x1 - 1;\n    a.y1 += obj->coords.y1 - 1;\n    a.x2 += obj->coords.x1 + 1;\n    a.y2 += obj->coords.y1 + 1;\n    lv_obj_invalidate_area(obj, &a);\n\n    img->zoom = zoom;\n    lv_obj_refresh_ext_draw_size(obj);\n\n    _lv_img_buf_get_transformed_area(&a, w, h, transf_angle, ((int32_t)transf_zoom * img->zoom) >> 8, &img->pivot);\n    a.x1 += obj->coords.x1 - 1;\n    a.y1 += obj->coords.y1 - 1;\n    a.x2 += obj->coords.x1 + 1;\n    a.y2 += obj->coords.y1 + 1;\n    lv_obj_invalidate_area(obj, &a);\n}"}, "lv_img_set_antialias": {"type": "Function", "def": "void lv_img_set_antialias(lv_obj_t * obj, bool antialias)", "sline": 285, "body": "{\n    lv_img_t * img = (lv_img_t *)obj;\n    if(antialias == img->antialias) return;\n\n    img->antialias = antialias;\n    lv_obj_invalidate(obj);\n}"}, "lv_img_set_size_mode": {"type": "Function", "def": "void lv_img_set_size_mode(lv_obj_t * obj, lv_img_size_mode_t mode)", "sline": 294, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_img_t * img = (lv_img_t *)obj;\n    if(mode == img->obj_size_mode) return;\n\n    img->obj_size_mode = mode;\n    lv_obj_invalidate(obj);\n}"}, "lv_img_get_src": {"type": "Function", "def": "const void * lv_img_get_src(lv_obj_t * obj)", "sline": 308, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_img_t * img = (lv_img_t *)obj;\n\n    return img->src;\n}"}, "lv_img_get_offset_x": {"type": "Function", "def": "lv_coord_t lv_img_get_offset_x(lv_obj_t * obj)", "sline": 317, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_img_t * img = (lv_img_t *)obj;\n\n    return img->offset.x;\n}"}, "lv_img_get_offset_y": {"type": "Function", "def": "lv_coord_t lv_img_get_offset_y(lv_obj_t * obj)", "sline": 326, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_img_t * img = (lv_img_t *)obj;\n\n    return img->offset.y;\n}"}, "lv_img_get_angle": {"type": "Function", "def": "uint16_t lv_img_get_angle(lv_obj_t * obj)", "sline": 335, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_img_t * img = (lv_img_t *)obj;\n\n    return img->angle;\n}"}, "lv_img_get_pivot": {"type": "Function", "def": "void lv_img_get_pivot(lv_obj_t * obj, lv_point_t * pivot)", "sline": 344, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_img_t * img = (lv_img_t *)obj;\n\n    *pivot = img->pivot;\n}"}, "lv_img_get_zoom": {"type": "Function", "def": "uint16_t lv_img_get_zoom(lv_obj_t * obj)", "sline": 353, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_img_t * img = (lv_img_t *)obj;\n\n    return img->zoom;\n}"}, "lv_img_get_antialias": {"type": "Function", "def": "bool lv_img_get_antialias(lv_obj_t * obj)", "sline": 362, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_img_t * img = (lv_img_t *)obj;\n\n    return img->antialias ? true : false;\n}"}, "lv_img_get_size_mode": {"type": "Function", "def": "lv_img_size_mode_t lv_img_get_size_mode(lv_obj_t * obj)", "sline": 371, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_img_t * img = (lv_img_t *)obj;\n    return img->obj_size_mode;\n}"}, "lv_img_get_transformed_size": {"type": "Function", "def": "static lv_point_t lv_img_get_transformed_size(lv_obj_t * obj)", "sline": 420, "body": "{\n    lv_img_t * img = (lv_img_t *)obj;\n\n    int32_t zoom_final = lv_obj_get_style_transform_zoom(obj, LV_PART_MAIN);\n    zoom_final = (zoom_final * img->zoom) >> 8;\n    int32_t angle_final = lv_obj_get_style_transform_angle(obj, LV_PART_MAIN);\n    angle_final += img->angle;\n\n    lv_area_t area_transform;\n    _lv_img_buf_get_transformed_area(&area_transform, img->w, img->h,\n                                     angle_final, zoom_final, &img->pivot);\n\n    return (lv_point_t) {\n        lv_area_get_width(&area_transform), lv_area_get_height(&area_transform)\n    };\n}"}, "carbit_updater/lvgl/src/widgets/lv_img.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_img.c"}}, "carbit_updater/lvgl/src/core/lv_obj_style_gen.h": {"lv_obj_get_style_width": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_width(const struct _lv_obj_t * obj, uint32_t part)", "sline": 1, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_WIDTH);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_min_width": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_min_width(const struct _lv_obj_t * obj, uint32_t part)", "sline": 7, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MIN_WIDTH);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_max_width": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_max_width(const struct _lv_obj_t * obj, uint32_t part)", "sline": 13, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MAX_WIDTH);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_height": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_height(const struct _lv_obj_t * obj, uint32_t part)", "sline": 19, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_HEIGHT);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_min_height": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_min_height(const struct _lv_obj_t * obj, uint32_t part)", "sline": 25, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MIN_HEIGHT);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_max_height": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_max_height(const struct _lv_obj_t * obj, uint32_t part)", "sline": 31, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MAX_HEIGHT);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_x": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_x(const struct _lv_obj_t * obj, uint32_t part)", "sline": 37, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_X);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_y": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_y(const struct _lv_obj_t * obj, uint32_t part)", "sline": 43, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_Y);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_align": {"type": "Function", "def": "static inline lv_align_t lv_obj_get_style_align(const struct _lv_obj_t * obj, uint32_t part)", "sline": 49, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_ALIGN);\n    return (lv_align_t)v.num;\n}"}, "lv_obj_get_style_transform_width": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_transform_width(const struct _lv_obj_t * obj, uint32_t part)", "sline": 55, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_WIDTH);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_transform_height": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_transform_height(const struct _lv_obj_t * obj, uint32_t part)", "sline": 61, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_HEIGHT);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_translate_x": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_translate_x(const struct _lv_obj_t * obj, uint32_t part)", "sline": 67, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSLATE_X);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_translate_y": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_translate_y(const struct _lv_obj_t * obj, uint32_t part)", "sline": 73, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSLATE_Y);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_transform_zoom": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_transform_zoom(const struct _lv_obj_t * obj, uint32_t part)", "sline": 79, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_ZOOM);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_transform_angle": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_transform_angle(const struct _lv_obj_t * obj, uint32_t part)", "sline": 85, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_ANGLE);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_pad_top": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_pad_top(const struct _lv_obj_t * obj, uint32_t part)", "sline": 91, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_TOP);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_pad_bottom": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_pad_bottom(const struct _lv_obj_t * obj, uint32_t part)", "sline": 97, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_BOTTOM);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_pad_left": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_pad_left(const struct _lv_obj_t * obj, uint32_t part)", "sline": 103, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_LEFT);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_pad_right": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_pad_right(const struct _lv_obj_t * obj, uint32_t part)", "sline": 109, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_RIGHT);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_pad_row": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_pad_row(const struct _lv_obj_t * obj, uint32_t part)", "sline": 115, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_ROW);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_pad_column": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_pad_column(const struct _lv_obj_t * obj, uint32_t part)", "sline": 121, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_COLUMN);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_radius": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_radius(const struct _lv_obj_t * obj, uint32_t part)", "sline": 127, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_RADIUS);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_clip_corner": {"type": "Function", "def": "static inline bool lv_obj_get_style_clip_corner(const struct _lv_obj_t * obj, uint32_t part)", "sline": 133, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_CLIP_CORNER);\n    return (bool)v.num;\n}"}, "lv_obj_get_style_opa": {"type": "Function", "def": "static inline lv_opa_t lv_obj_get_style_opa(const struct _lv_obj_t * obj, uint32_t part)", "sline": 139, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_OPA);\n    return (lv_opa_t)v.num;\n}"}, "lv_obj_get_style_color_filter_dsc": {"type": "Function", "def": "static inline const lv_color_filter_dsc_t * lv_obj_get_style_color_filter_dsc(const struct _lv_obj_t * obj, uint32_t part)", "sline": 145, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_COLOR_FILTER_DSC);\n    return (const lv_color_filter_dsc_t *)v.ptr;\n}"}, "lv_obj_get_style_color_filter_opa": {"type": "Function", "def": "static inline lv_opa_t lv_obj_get_style_color_filter_opa(const struct _lv_obj_t * obj, uint32_t part)", "sline": 151, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_COLOR_FILTER_OPA);\n    return (lv_opa_t)v.num;\n}"}, "lv_obj_get_style_anim_time": {"type": "Function", "def": "static inline uint32_t lv_obj_get_style_anim_time(const struct _lv_obj_t * obj, uint32_t part)", "sline": 157, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_ANIM_TIME);\n    return (uint32_t)v.num;\n}"}, "lv_obj_get_style_anim_speed": {"type": "Function", "def": "static inline uint32_t lv_obj_get_style_anim_speed(const struct _lv_obj_t * obj, uint32_t part)", "sline": 163, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_ANIM_SPEED);\n    return (uint32_t)v.num;\n}"}, "lv_obj_get_style_transition": {"type": "Function", "def": "static inline const lv_style_transition_dsc_t * lv_obj_get_style_transition(const struct _lv_obj_t * obj, uint32_t part)", "sline": 169, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSITION);\n    return (const lv_style_transition_dsc_t *)v.ptr;\n}"}, "lv_obj_get_style_blend_mode": {"type": "Function", "def": "static inline lv_blend_mode_t lv_obj_get_style_blend_mode(const struct _lv_obj_t * obj, uint32_t part)", "sline": 175, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BLEND_MODE);\n    return (lv_blend_mode_t)v.num;\n}"}, "lv_obj_get_style_layout": {"type": "Function", "def": "static inline uint16_t lv_obj_get_style_layout(const struct _lv_obj_t * obj, uint32_t part)", "sline": 181, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_LAYOUT);\n    return (uint16_t)v.num;\n}"}, "lv_obj_get_style_base_dir": {"type": "Function", "def": "static inline lv_base_dir_t lv_obj_get_style_base_dir(const struct _lv_obj_t * obj, uint32_t part)", "sline": 187, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BASE_DIR);\n    return (lv_base_dir_t)v.num;\n}"}, "lv_obj_get_style_bg_color": {"type": "Function", "def": "static inline lv_color_t lv_obj_get_style_bg_color(const struct _lv_obj_t * obj, uint32_t part)", "sline": 193, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_COLOR);\n    return v.color;\n}"}, "lv_obj_get_style_bg_color_filtered": {"type": "Function", "def": "static inline lv_color_t lv_obj_get_style_bg_color_filtered(const struct _lv_obj_t * obj, uint32_t part)", "sline": 199, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_COLOR_FILTERED);\n    return v.color;\n}"}, "lv_obj_get_style_bg_opa": {"type": "Function", "def": "static inline lv_opa_t lv_obj_get_style_bg_opa(const struct _lv_obj_t * obj, uint32_t part)", "sline": 205, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_OPA);\n    return (lv_opa_t)v.num;\n}"}, "lv_obj_get_style_bg_grad_color": {"type": "Function", "def": "static inline lv_color_t lv_obj_get_style_bg_grad_color(const struct _lv_obj_t * obj, uint32_t part)", "sline": 211, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_GRAD_COLOR);\n    return v.color;\n}"}, "lv_obj_get_style_bg_grad_color_filtered": {"type": "Function", "def": "static inline lv_color_t lv_obj_get_style_bg_grad_color_filtered(const struct _lv_obj_t * obj, uint32_t part)", "sline": 217, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_GRAD_COLOR_FILTERED);\n    return v.color;\n}"}, "lv_obj_get_style_bg_grad_dir": {"type": "Function", "def": "static inline lv_grad_dir_t lv_obj_get_style_bg_grad_dir(const struct _lv_obj_t * obj, uint32_t part)", "sline": 223, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_GRAD_DIR);\n    return (lv_grad_dir_t)v.num;\n}"}, "lv_obj_get_style_bg_main_stop": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_bg_main_stop(const struct _lv_obj_t * obj, uint32_t part)", "sline": 229, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_MAIN_STOP);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_bg_grad_stop": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_bg_grad_stop(const struct _lv_obj_t * obj, uint32_t part)", "sline": 235, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_GRAD_STOP);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_bg_img_src": {"type": "Function", "def": "static inline const void * lv_obj_get_style_bg_img_src(const struct _lv_obj_t * obj, uint32_t part)", "sline": 241, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_IMG_SRC);\n    return (const void *)v.ptr;\n}"}, "lv_obj_get_style_bg_img_opa": {"type": "Function", "def": "static inline lv_opa_t lv_obj_get_style_bg_img_opa(const struct _lv_obj_t * obj, uint32_t part)", "sline": 247, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_IMG_OPA);\n    return (lv_opa_t)v.num;\n}"}, "lv_obj_get_style_bg_img_recolor": {"type": "Function", "def": "static inline lv_color_t lv_obj_get_style_bg_img_recolor(const struct _lv_obj_t * obj, uint32_t part)", "sline": 253, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_IMG_RECOLOR);\n    return v.color;\n}"}, "lv_obj_get_style_bg_img_recolor_filtered": {"type": "Function", "def": "static inline lv_color_t lv_obj_get_style_bg_img_recolor_filtered(const struct _lv_obj_t * obj, uint32_t part)", "sline": 259, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_IMG_RECOLOR_FILTERED);\n    return v.color;\n}"}, "lv_obj_get_style_bg_img_recolor_opa": {"type": "Function", "def": "static inline lv_opa_t lv_obj_get_style_bg_img_recolor_opa(const struct _lv_obj_t * obj, uint32_t part)", "sline": 265, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_IMG_RECOLOR_OPA);\n    return (lv_opa_t)v.num;\n}"}, "lv_obj_get_style_bg_img_tiled": {"type": "Function", "def": "static inline bool lv_obj_get_style_bg_img_tiled(const struct _lv_obj_t * obj, uint32_t part)", "sline": 271, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_IMG_TILED);\n    return (bool)v.num;\n}"}, "lv_obj_get_style_border_color": {"type": "Function", "def": "static inline lv_color_t lv_obj_get_style_border_color(const struct _lv_obj_t * obj, uint32_t part)", "sline": 277, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_COLOR);\n    return v.color;\n}"}, "lv_obj_get_style_border_color_filtered": {"type": "Function", "def": "static inline lv_color_t lv_obj_get_style_border_color_filtered(const struct _lv_obj_t * obj, uint32_t part)", "sline": 283, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_COLOR_FILTERED);\n    return v.color;\n}"}, "lv_obj_get_style_border_opa": {"type": "Function", "def": "static inline lv_opa_t lv_obj_get_style_border_opa(const struct _lv_obj_t * obj, uint32_t part)", "sline": 289, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_OPA);\n    return (lv_opa_t)v.num;\n}"}, "lv_obj_get_style_border_width": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_border_width(const struct _lv_obj_t * obj, uint32_t part)", "sline": 295, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_WIDTH);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_border_side": {"type": "Function", "def": "static inline lv_border_side_t lv_obj_get_style_border_side(const struct _lv_obj_t * obj, uint32_t part)", "sline": 301, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_SIDE);\n    return (lv_border_side_t)v.num;\n}"}, "lv_obj_get_style_border_post": {"type": "Function", "def": "static inline bool lv_obj_get_style_border_post(const struct _lv_obj_t * obj, uint32_t part)", "sline": 307, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_POST);\n    return (bool)v.num;\n}"}, "lv_obj_get_style_text_color": {"type": "Function", "def": "static inline lv_color_t lv_obj_get_style_text_color(const struct _lv_obj_t * obj, uint32_t part)", "sline": 313, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_COLOR);\n    return v.color;\n}"}, "lv_obj_get_style_text_color_filtered": {"type": "Function", "def": "static inline lv_color_t lv_obj_get_style_text_color_filtered(const struct _lv_obj_t * obj, uint32_t part)", "sline": 319, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_COLOR_FILTERED);\n    return v.color;\n}"}, "lv_obj_get_style_text_opa": {"type": "Function", "def": "static inline lv_opa_t lv_obj_get_style_text_opa(const struct _lv_obj_t * obj, uint32_t part)", "sline": 325, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_OPA);\n    return (lv_opa_t)v.num;\n}"}, "lv_obj_get_style_text_font": {"type": "Function", "def": "static inline const lv_font_t * lv_obj_get_style_text_font(const struct _lv_obj_t * obj, uint32_t part)", "sline": 331, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_FONT);\n    return (const lv_font_t *)v.ptr;\n}"}, "lv_obj_get_style_text_letter_space": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_text_letter_space(const struct _lv_obj_t * obj, uint32_t part)", "sline": 337, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_LETTER_SPACE);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_text_line_space": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_text_line_space(const struct _lv_obj_t * obj, uint32_t part)", "sline": 343, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_LINE_SPACE);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_text_decor": {"type": "Function", "def": "static inline lv_text_decor_t lv_obj_get_style_text_decor(const struct _lv_obj_t * obj, uint32_t part)", "sline": 349, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_DECOR);\n    return (lv_text_decor_t)v.num;\n}"}, "lv_obj_get_style_text_align": {"type": "Function", "def": "static inline lv_text_align_t lv_obj_get_style_text_align(const struct _lv_obj_t * obj, uint32_t part)", "sline": 355, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_ALIGN);\n    return (lv_text_align_t)v.num;\n}"}, "lv_obj_get_style_img_opa": {"type": "Function", "def": "static inline lv_opa_t lv_obj_get_style_img_opa(const struct _lv_obj_t * obj, uint32_t part)", "sline": 361, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_IMG_OPA);\n    return (lv_opa_t)v.num;\n}"}, "lv_obj_get_style_img_recolor": {"type": "Function", "def": "static inline lv_color_t lv_obj_get_style_img_recolor(const struct _lv_obj_t * obj, uint32_t part)", "sline": 367, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_IMG_RECOLOR);\n    return v.color;\n}"}, "lv_obj_get_style_img_recolor_filtered": {"type": "Function", "def": "static inline lv_color_t lv_obj_get_style_img_recolor_filtered(const struct _lv_obj_t * obj, uint32_t part)", "sline": 373, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_IMG_RECOLOR_FILTERED);\n    return v.color;\n}"}, "lv_obj_get_style_img_recolor_opa": {"type": "Function", "def": "static inline lv_opa_t lv_obj_get_style_img_recolor_opa(const struct _lv_obj_t * obj, uint32_t part)", "sline": 379, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_IMG_RECOLOR_OPA);\n    return (lv_opa_t)v.num;\n}"}, "lv_obj_get_style_outline_width": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_outline_width(const struct _lv_obj_t * obj, uint32_t part)", "sline": 385, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_OUTLINE_WIDTH);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_outline_color": {"type": "Function", "def": "static inline lv_color_t lv_obj_get_style_outline_color(const struct _lv_obj_t * obj, uint32_t part)", "sline": 391, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_OUTLINE_COLOR);\n    return v.color;\n}"}, "lv_obj_get_style_outline_color_filtered": {"type": "Function", "def": "static inline lv_color_t lv_obj_get_style_outline_color_filtered(const struct _lv_obj_t * obj, uint32_t part)", "sline": 397, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_OUTLINE_COLOR_FILTERED);\n    return v.color;\n}"}, "lv_obj_get_style_outline_opa": {"type": "Function", "def": "static inline lv_opa_t lv_obj_get_style_outline_opa(const struct _lv_obj_t * obj, uint32_t part)", "sline": 403, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_OUTLINE_OPA);\n    return (lv_opa_t)v.num;\n}"}, "lv_obj_get_style_outline_pad": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_outline_pad(const struct _lv_obj_t * obj, uint32_t part)", "sline": 409, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_OUTLINE_PAD);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_shadow_width": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_shadow_width(const struct _lv_obj_t * obj, uint32_t part)", "sline": 415, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_SHADOW_WIDTH);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_shadow_ofs_x": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_shadow_ofs_x(const struct _lv_obj_t * obj, uint32_t part)", "sline": 421, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_SHADOW_OFS_X);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_shadow_ofs_y": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_shadow_ofs_y(const struct _lv_obj_t * obj, uint32_t part)", "sline": 427, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_SHADOW_OFS_Y);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_shadow_spread": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_shadow_spread(const struct _lv_obj_t * obj, uint32_t part)", "sline": 433, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_SHADOW_SPREAD);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_shadow_color": {"type": "Function", "def": "static inline lv_color_t lv_obj_get_style_shadow_color(const struct _lv_obj_t * obj, uint32_t part)", "sline": 439, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_SHADOW_COLOR);\n    return v.color;\n}"}, "lv_obj_get_style_shadow_color_filtered": {"type": "Function", "def": "static inline lv_color_t lv_obj_get_style_shadow_color_filtered(const struct _lv_obj_t * obj, uint32_t part)", "sline": 445, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_SHADOW_COLOR_FILTERED);\n    return v.color;\n}"}, "lv_obj_get_style_shadow_opa": {"type": "Function", "def": "static inline lv_opa_t lv_obj_get_style_shadow_opa(const struct _lv_obj_t * obj, uint32_t part)", "sline": 451, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_SHADOW_OPA);\n    return (lv_opa_t)v.num;\n}"}, "lv_obj_get_style_line_width": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_line_width(const struct _lv_obj_t * obj, uint32_t part)", "sline": 457, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_LINE_WIDTH);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_line_dash_width": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_line_dash_width(const struct _lv_obj_t * obj, uint32_t part)", "sline": 463, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_LINE_DASH_WIDTH);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_line_dash_gap": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_line_dash_gap(const struct _lv_obj_t * obj, uint32_t part)", "sline": 469, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_LINE_DASH_GAP);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_line_rounded": {"type": "Function", "def": "static inline bool lv_obj_get_style_line_rounded(const struct _lv_obj_t * obj, uint32_t part)", "sline": 475, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_LINE_ROUNDED);\n    return (bool)v.num;\n}"}, "lv_obj_get_style_line_color": {"type": "Function", "def": "static inline lv_color_t lv_obj_get_style_line_color(const struct _lv_obj_t * obj, uint32_t part)", "sline": 481, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_LINE_COLOR);\n    return v.color;\n}"}, "lv_obj_get_style_line_color_filtered": {"type": "Function", "def": "static inline lv_color_t lv_obj_get_style_line_color_filtered(const struct _lv_obj_t * obj, uint32_t part)", "sline": 487, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_LINE_COLOR_FILTERED);\n    return v.color;\n}"}, "lv_obj_get_style_line_opa": {"type": "Function", "def": "static inline lv_opa_t lv_obj_get_style_line_opa(const struct _lv_obj_t * obj, uint32_t part)", "sline": 493, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_LINE_OPA);\n    return (lv_opa_t)v.num;\n}"}, "lv_obj_get_style_arc_width": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_style_arc_width(const struct _lv_obj_t * obj, uint32_t part)", "sline": 499, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_ARC_WIDTH);\n    return (lv_coord_t)v.num;\n}"}, "lv_obj_get_style_arc_rounded": {"type": "Function", "def": "static inline bool lv_obj_get_style_arc_rounded(const struct _lv_obj_t * obj, uint32_t part)", "sline": 505, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_ARC_ROUNDED);\n    return (bool)v.num;\n}"}, "lv_obj_get_style_arc_color": {"type": "Function", "def": "static inline lv_color_t lv_obj_get_style_arc_color(const struct _lv_obj_t * obj, uint32_t part)", "sline": 511, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_ARC_COLOR);\n    return v.color;\n}"}, "lv_obj_get_style_arc_color_filtered": {"type": "Function", "def": "static inline lv_color_t lv_obj_get_style_arc_color_filtered(const struct _lv_obj_t * obj, uint32_t part)", "sline": 517, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_ARC_COLOR_FILTERED);\n    return v.color;\n}"}, "lv_obj_get_style_arc_opa": {"type": "Function", "def": "static inline lv_opa_t lv_obj_get_style_arc_opa(const struct _lv_obj_t * obj, uint32_t part)", "sline": 523, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_ARC_OPA);\n    return (lv_opa_t)v.num;\n}"}, "lv_obj_get_style_arc_img_src": {"type": "Function", "def": "static inline const void * lv_obj_get_style_arc_img_src(const struct _lv_obj_t * obj, uint32_t part)", "sline": 529, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_ARC_IMG_SRC);\n    return (const void *)v.ptr;\n}"}, "lv_obj_set_style_width": {"type": "Function", "def": "void lv_obj_set_style_width(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 535}, "lv_obj_set_style_min_width": {"type": "Function", "def": "void lv_obj_set_style_min_width(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 536}, "lv_obj_set_style_max_width": {"type": "Function", "def": "void lv_obj_set_style_max_width(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 537}, "lv_obj_set_style_height": {"type": "Function", "def": "void lv_obj_set_style_height(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 538}, "lv_obj_set_style_min_height": {"type": "Function", "def": "void lv_obj_set_style_min_height(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 539}, "lv_obj_set_style_max_height": {"type": "Function", "def": "void lv_obj_set_style_max_height(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 540}, "lv_obj_set_style_x": {"type": "Function", "def": "void lv_obj_set_style_x(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 541}, "lv_obj_set_style_y": {"type": "Function", "def": "void lv_obj_set_style_y(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 542}, "lv_obj_set_style_align": {"type": "Function", "def": "void lv_obj_set_style_align(struct _lv_obj_t * obj, lv_align_t value, lv_style_selector_t selector)", "sline": 543}, "lv_obj_set_style_transform_width": {"type": "Function", "def": "void lv_obj_set_style_transform_width(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 544}, "lv_obj_set_style_transform_height": {"type": "Function", "def": "void lv_obj_set_style_transform_height(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 545}, "lv_obj_set_style_translate_x": {"type": "Function", "def": "void lv_obj_set_style_translate_x(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 546}, "lv_obj_set_style_translate_y": {"type": "Function", "def": "void lv_obj_set_style_translate_y(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 547}, "lv_obj_set_style_transform_zoom": {"type": "Function", "def": "void lv_obj_set_style_transform_zoom(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 548}, "lv_obj_set_style_transform_angle": {"type": "Function", "def": "void lv_obj_set_style_transform_angle(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 549}, "lv_obj_set_style_pad_top": {"type": "Function", "def": "void lv_obj_set_style_pad_top(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 550}, "lv_obj_set_style_pad_bottom": {"type": "Function", "def": "void lv_obj_set_style_pad_bottom(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 551}, "lv_obj_set_style_pad_left": {"type": "Function", "def": "void lv_obj_set_style_pad_left(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 552}, "lv_obj_set_style_pad_right": {"type": "Function", "def": "void lv_obj_set_style_pad_right(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 553}, "lv_obj_set_style_pad_row": {"type": "Function", "def": "void lv_obj_set_style_pad_row(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 554}, "lv_obj_set_style_pad_column": {"type": "Function", "def": "void lv_obj_set_style_pad_column(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 555}, "lv_obj_set_style_radius": {"type": "Function", "def": "void lv_obj_set_style_radius(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 556}, "lv_obj_set_style_clip_corner": {"type": "Function", "def": "void lv_obj_set_style_clip_corner(struct _lv_obj_t * obj, bool value, lv_style_selector_t selector)", "sline": 557}, "lv_obj_set_style_opa": {"type": "Function", "def": "void lv_obj_set_style_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 558}, "lv_obj_set_style_color_filter_dsc": {"type": "Function", "def": "void lv_obj_set_style_color_filter_dsc(struct _lv_obj_t * obj, const lv_color_filter_dsc_t * value, lv_style_selector_t selector)", "sline": 559}, "lv_obj_set_style_color_filter_opa": {"type": "Function", "def": "void lv_obj_set_style_color_filter_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 560}, "lv_obj_set_style_anim_time": {"type": "Function", "def": "void lv_obj_set_style_anim_time(struct _lv_obj_t * obj, uint32_t value, lv_style_selector_t selector)", "sline": 561}, "lv_obj_set_style_anim_speed": {"type": "Function", "def": "void lv_obj_set_style_anim_speed(struct _lv_obj_t * obj, uint32_t value, lv_style_selector_t selector)", "sline": 562}, "lv_obj_set_style_transition": {"type": "Function", "def": "void lv_obj_set_style_transition(struct _lv_obj_t * obj, const lv_style_transition_dsc_t * value, lv_style_selector_t selector)", "sline": 563}, "lv_obj_set_style_blend_mode": {"type": "Function", "def": "void lv_obj_set_style_blend_mode(struct _lv_obj_t * obj, lv_blend_mode_t value, lv_style_selector_t selector)", "sline": 564}, "lv_obj_set_style_layout": {"type": "Function", "def": "void lv_obj_set_style_layout(struct _lv_obj_t * obj, uint16_t value, lv_style_selector_t selector)", "sline": 565}, "lv_obj_set_style_base_dir": {"type": "Function", "def": "void lv_obj_set_style_base_dir(struct _lv_obj_t * obj, lv_base_dir_t value, lv_style_selector_t selector)", "sline": 566}, "lv_obj_set_style_bg_color": {"type": "Function", "def": "void lv_obj_set_style_bg_color(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 567}, "lv_obj_set_style_bg_color_filtered": {"type": "Function", "def": "void lv_obj_set_style_bg_color_filtered(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 568}, "lv_obj_set_style_bg_opa": {"type": "Function", "def": "void lv_obj_set_style_bg_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 569}, "lv_obj_set_style_bg_grad_color": {"type": "Function", "def": "void lv_obj_set_style_bg_grad_color(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 570}, "lv_obj_set_style_bg_grad_color_filtered": {"type": "Function", "def": "void lv_obj_set_style_bg_grad_color_filtered(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 571}, "lv_obj_set_style_bg_grad_dir": {"type": "Function", "def": "void lv_obj_set_style_bg_grad_dir(struct _lv_obj_t * obj, lv_grad_dir_t value, lv_style_selector_t selector)", "sline": 572}, "lv_obj_set_style_bg_main_stop": {"type": "Function", "def": "void lv_obj_set_style_bg_main_stop(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 573}, "lv_obj_set_style_bg_grad_stop": {"type": "Function", "def": "void lv_obj_set_style_bg_grad_stop(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 574}, "lv_obj_set_style_bg_img_src": {"type": "Function", "def": "void lv_obj_set_style_bg_img_src(struct _lv_obj_t * obj, const void * value, lv_style_selector_t selector)", "sline": 575}, "lv_obj_set_style_bg_img_opa": {"type": "Function", "def": "void lv_obj_set_style_bg_img_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 576}, "lv_obj_set_style_bg_img_recolor": {"type": "Function", "def": "void lv_obj_set_style_bg_img_recolor(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 577}, "lv_obj_set_style_bg_img_recolor_filtered": {"type": "Function", "def": "void lv_obj_set_style_bg_img_recolor_filtered(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 578}, "lv_obj_set_style_bg_img_recolor_opa": {"type": "Function", "def": "void lv_obj_set_style_bg_img_recolor_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 579}, "lv_obj_set_style_bg_img_tiled": {"type": "Function", "def": "void lv_obj_set_style_bg_img_tiled(struct _lv_obj_t * obj, bool value, lv_style_selector_t selector)", "sline": 580}, "lv_obj_set_style_border_color": {"type": "Function", "def": "void lv_obj_set_style_border_color(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 581}, "lv_obj_set_style_border_color_filtered": {"type": "Function", "def": "void lv_obj_set_style_border_color_filtered(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 582}, "lv_obj_set_style_border_opa": {"type": "Function", "def": "void lv_obj_set_style_border_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 583}, "lv_obj_set_style_border_width": {"type": "Function", "def": "void lv_obj_set_style_border_width(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 584}, "lv_obj_set_style_border_side": {"type": "Function", "def": "void lv_obj_set_style_border_side(struct _lv_obj_t * obj, lv_border_side_t value, lv_style_selector_t selector)", "sline": 585}, "lv_obj_set_style_border_post": {"type": "Function", "def": "void lv_obj_set_style_border_post(struct _lv_obj_t * obj, bool value, lv_style_selector_t selector)", "sline": 586}, "lv_obj_set_style_text_color": {"type": "Function", "def": "void lv_obj_set_style_text_color(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 587}, "lv_obj_set_style_text_color_filtered": {"type": "Function", "def": "void lv_obj_set_style_text_color_filtered(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 588}, "lv_obj_set_style_text_opa": {"type": "Function", "def": "void lv_obj_set_style_text_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 589}, "lv_obj_set_style_text_font": {"type": "Function", "def": "void lv_obj_set_style_text_font(struct _lv_obj_t * obj, const lv_font_t * value, lv_style_selector_t selector)", "sline": 590}, "lv_obj_set_style_text_letter_space": {"type": "Function", "def": "void lv_obj_set_style_text_letter_space(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 591}, "lv_obj_set_style_text_line_space": {"type": "Function", "def": "void lv_obj_set_style_text_line_space(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 592}, "lv_obj_set_style_text_decor": {"type": "Function", "def": "void lv_obj_set_style_text_decor(struct _lv_obj_t * obj, lv_text_decor_t value, lv_style_selector_t selector)", "sline": 593}, "lv_obj_set_style_text_align": {"type": "Function", "def": "void lv_obj_set_style_text_align(struct _lv_obj_t * obj, lv_text_align_t value, lv_style_selector_t selector)", "sline": 594}, "lv_obj_set_style_img_opa": {"type": "Function", "def": "void lv_obj_set_style_img_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 595}, "lv_obj_set_style_img_recolor": {"type": "Function", "def": "void lv_obj_set_style_img_recolor(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 596}, "lv_obj_set_style_img_recolor_filtered": {"type": "Function", "def": "void lv_obj_set_style_img_recolor_filtered(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 597}, "lv_obj_set_style_img_recolor_opa": {"type": "Function", "def": "void lv_obj_set_style_img_recolor_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 598}, "lv_obj_set_style_outline_width": {"type": "Function", "def": "void lv_obj_set_style_outline_width(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 599}, "lv_obj_set_style_outline_color": {"type": "Function", "def": "void lv_obj_set_style_outline_color(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 600}, "lv_obj_set_style_outline_color_filtered": {"type": "Function", "def": "void lv_obj_set_style_outline_color_filtered(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 601}, "lv_obj_set_style_outline_opa": {"type": "Function", "def": "void lv_obj_set_style_outline_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 602}, "lv_obj_set_style_outline_pad": {"type": "Function", "def": "void lv_obj_set_style_outline_pad(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 603}, "lv_obj_set_style_shadow_width": {"type": "Function", "def": "void lv_obj_set_style_shadow_width(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 604}, "lv_obj_set_style_shadow_ofs_x": {"type": "Function", "def": "void lv_obj_set_style_shadow_ofs_x(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 605}, "lv_obj_set_style_shadow_ofs_y": {"type": "Function", "def": "void lv_obj_set_style_shadow_ofs_y(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 606}, "lv_obj_set_style_shadow_spread": {"type": "Function", "def": "void lv_obj_set_style_shadow_spread(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 607}, "lv_obj_set_style_shadow_color": {"type": "Function", "def": "void lv_obj_set_style_shadow_color(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 608}, "lv_obj_set_style_shadow_color_filtered": {"type": "Function", "def": "void lv_obj_set_style_shadow_color_filtered(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 609}, "lv_obj_set_style_shadow_opa": {"type": "Function", "def": "void lv_obj_set_style_shadow_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 610}, "lv_obj_set_style_line_width": {"type": "Function", "def": "void lv_obj_set_style_line_width(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 611}, "lv_obj_set_style_line_dash_width": {"type": "Function", "def": "void lv_obj_set_style_line_dash_width(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 612}, "lv_obj_set_style_line_dash_gap": {"type": "Function", "def": "void lv_obj_set_style_line_dash_gap(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 613}, "lv_obj_set_style_line_rounded": {"type": "Function", "def": "void lv_obj_set_style_line_rounded(struct _lv_obj_t * obj, bool value, lv_style_selector_t selector)", "sline": 614}, "lv_obj_set_style_line_color": {"type": "Function", "def": "void lv_obj_set_style_line_color(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 615}, "lv_obj_set_style_line_color_filtered": {"type": "Function", "def": "void lv_obj_set_style_line_color_filtered(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 616}, "lv_obj_set_style_line_opa": {"type": "Function", "def": "void lv_obj_set_style_line_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 617}, "lv_obj_set_style_arc_width": {"type": "Function", "def": "void lv_obj_set_style_arc_width(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 618}, "lv_obj_set_style_arc_rounded": {"type": "Function", "def": "void lv_obj_set_style_arc_rounded(struct _lv_obj_t * obj, bool value, lv_style_selector_t selector)", "sline": 619}, "lv_obj_set_style_arc_color": {"type": "Function", "def": "void lv_obj_set_style_arc_color(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 620}, "lv_obj_set_style_arc_color_filtered": {"type": "Function", "def": "void lv_obj_set_style_arc_color_filtered(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 621}, "lv_obj_set_style_arc_opa": {"type": "Function", "def": "void lv_obj_set_style_arc_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 622}, "lv_obj_set_style_arc_img_src": {"type": "Function", "def": "void lv_obj_set_style_arc_img_src(struct _lv_obj_t * obj, const void * value, lv_style_selector_t selector)", "sline": 623}, "carbit_updater/lvgl/src/core/lv_obj_style_gen.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style_gen.h"}}, "carbit_updater/lv_drivers/display/SSD1963.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 20}, "carbit_updater/lv_drivers/display/SSD1963.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/SSD1963.h"}}, "carbit_updater/lvgl/src/misc/lv_style.h": {"stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 16}, "lv_font": {"type": "Variable", "def": "#include ../font/lv_font.h", "sline": 17}, "lv_color": {"type": "Variable", "def": "#include lv_color.h", "sline": 18, "include": ["carbit_updater/lvgl/src/misc/lv_color.h", null]}, "lv_area": {"type": "Variable", "def": "#include lv_area.h", "sline": 19, "include": ["carbit_updater/lvgl/src/misc/lv_area.h", null]}, "lv_anim": {"type": "Variable", "def": "#include lv_anim.h", "sline": 20, "include": ["carbit_updater/lvgl/src/misc/lv_anim.h", null]}, "lv_txt": {"type": "Variable", "def": "#include lv_txt.h", "sline": 21, "include": ["carbit_updater/lvgl/src/misc/lv_txt.h", null]}, "lv_types": {"type": "Variable", "def": "#include lv_types.h", "sline": 22, "include": ["carbit_updater/lvgl/src/misc/lv_types.h", null]}, "lv_assert": {"type": "Variable", "def": "#include lv_assert.h", "sline": 23, "include": ["carbit_updater/lvgl/src/misc/lv_assert.h", null]}, "lv_bidi": {"type": "Variable", "def": "#include lv_bidi.h", "sline": 24, "include": ["carbit_updater/lvgl/src/misc/lv_bidi.h", null]}, "lv_style_gen": {"type": "Variable", "def": "#include lv_style_gen.h", "sline": 426, "include": ["carbit_updater/lvgl/src/misc/lv_style_gen.h", null]}, "_silence_gcc_warning": {"type": "Struct", "def": "LV_EXPORT_CONST_INT(LV_IMG_ZOOM_NONE)", "sline": 45}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_style.h:60:1)": {"type": "Enum", "def": "enum {\n    LV_BLEND_MODE_NORMAL,     /**< Simply mix according to the opacity value*/\n    LV_BLEND_MODE_ADDITIVE,   /**< Add the respective color channels*/\n    LV_BLEND_MODE_SUBTRACTIVE,/**< Subtract the foreground from the background*/\n    LV_BLEND_MODE_MULTIPLY,   /**< Multiply the foreground and background*/\n}", "sline": 60, "docstring": "/**"}, "lv_blend_mode_t": {"type": "Variable", "def": "typedef uint8_t lv_blend_mode_t", "sline": 67}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_style.h:73:1)": {"type": "Enum", "def": "enum {\n    LV_TEXT_DECOR_NONE          = 0x00,\n    LV_TEXT_DECOR_UNDERLINE     = 0x01,\n    LV_TEXT_DECOR_STRIKETHROUGH = 0x02,\n}", "sline": 73}, "lv_text_decor_t": {"type": "Variable", "def": "typedef uint8_t lv_text_decor_t", "sline": 79}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_style.h:85:1)": {"type": "Enum", "def": "enum {\n    LV_BORDER_SIDE_NONE     = 0x00,\n    LV_BORDER_SIDE_BOTTOM   = 0x01,\n    LV_BORDER_SIDE_TOP      = 0x02,\n    LV_BORDER_SIDE_LEFT     = 0x04,\n    LV_BORDER_SIDE_RIGHT    = 0x08,\n    LV_BORDER_SIDE_FULL     = 0x0F,\n    LV_BORDER_SIDE_INTERNAL = 0x10, /**< FOR matrix-like objects (e.g. Button matrix)*/\n}", "sline": 85}, "lv_border_side_t": {"type": "Variable", "def": "typedef uint8_t lv_border_side_t", "sline": 94}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_style.h:99:1)": {"type": "Enum", "def": "enum {\n    LV_GRAD_DIR_NONE, /**< No gradient (the `grad_color` property is ignored)*/\n    LV_GRAD_DIR_VER,  /**< Vertical (top to bottom) gradient*/\n    LV_GRAD_DIR_HOR,  /**< Horizontal (left to right) gradient*/\n}", "sline": 99, "docstring": "/**"}, "lv_grad_dir_t": {"type": "Variable", "def": "typedef uint8_t lv_grad_dir_t", "sline": 105}, "lv_style_value_t.num": {"type": "Variable", "def": "int32_t num", "sline": 111, "in_struct": "lv_style_value_t"}, "lv_style_value_t.ptr": {"type": "Variable", "def": "const void * ptr", "sline": 112, "in_struct": "lv_style_value_t"}, "lv_style_value_t.color": {"type": "Variable", "def": "lv_color_t color", "sline": 113, "in_struct": "lv_style_value_t"}, "lv_style_value_t": {"type": "Variable", "def": "typedef union {\n    int32_t num;         /**< Number integer number (opacity, enums, booleans or \"normal\" numbers)*/\n    const void * ptr;    /**< Constant pointers  (font, cone text, etc)*/\n    lv_color_t color;    /**< Colors*/\n} lv_style_value_t", "sline": 114, "docstring": "/**"}, "lv_style_prop_t": {"type": "Variable", "def": "typedef enum {\n    LV_STYLE_PROP_INV                = 0,\n\n    /*Group 0*/\n    LV_STYLE_WIDTH                   = 1 | LV_STYLE_PROP_LAYOUT_REFR,\n    LV_STYLE_MIN_WIDTH               = 2 | LV_STYLE_PROP_LAYOUT_REFR,\n    LV_STYLE_MAX_WIDTH               = 3 | LV_STYLE_PROP_LAYOUT_REFR,\n    LV_STYLE_HEIGHT                  = 4 | LV_STYLE_PROP_LAYOUT_REFR,\n    LV_STYLE_MIN_HEIGHT              = 5 | LV_STYLE_PROP_LAYOUT_REFR,\n    LV_STYLE_MAX_HEIGHT              = 6 | LV_STYLE_PROP_LAYOUT_REFR,\n    LV_STYLE_X                       = 7 | LV_STYLE_PROP_LAYOUT_REFR,\n    LV_STYLE_Y                       = 8 | LV_STYLE_PROP_LAYOUT_REFR,\n    LV_STYLE_ALIGN                   = 9 | LV_STYLE_PROP_LAYOUT_REFR,\n    LV_STYLE_TRANSFORM_WIDTH         = 10 | LV_STYLE_PROP_EXT_DRAW,\n    LV_STYLE_TRANSFORM_HEIGHT        = 11 | LV_STYLE_PROP_EXT_DRAW,\n    LV_STYLE_TRANSLATE_X             = 12 | LV_STYLE_PROP_LAYOUT_REFR | LV_STYLE_PROP_PARENT_LAYOUT_REFR,\n    LV_STYLE_TRANSLATE_Y             = 13 | LV_STYLE_PROP_LAYOUT_REFR | LV_STYLE_PROP_PARENT_LAYOUT_REFR,\n    LV_STYLE_TRANSFORM_ZOOM          = 14 | LV_STYLE_PROP_EXT_DRAW | LV_STYLE_PROP_LAYOUT_REFR | LV_STYLE_PROP_PARENT_LAYOUT_REFR,\n    LV_STYLE_TRANSFORM_ANGLE         = 15 | LV_STYLE_PROP_EXT_DRAW | LV_STYLE_PROP_LAYOUT_REFR | LV_STYLE_PROP_PARENT_LAYOUT_REFR,\n\n    /*Group 1*/\n    LV_STYLE_PAD_TOP                 = 16 | LV_STYLE_PROP_EXT_DRAW | LV_STYLE_PROP_LAYOUT_REFR,\n    LV_STYLE_PAD_BOTTOM              = 17 | LV_STYLE_PROP_EXT_DRAW | LV_STYLE_PROP_LAYOUT_REFR,\n    LV_STYLE_PAD_LEFT                = 18 | LV_STYLE_PROP_EXT_DRAW | LV_STYLE_PROP_LAYOUT_REFR,\n    LV_STYLE_PAD_RIGHT               = 19 | LV_STYLE_PROP_EXT_DRAW | LV_STYLE_PROP_LAYOUT_REFR,\n    LV_STYLE_PAD_ROW                 = 20 | LV_STYLE_PROP_EXT_DRAW | LV_STYLE_PROP_LAYOUT_REFR,\n    LV_STYLE_PAD_COLUMN              = 21 | LV_STYLE_PROP_EXT_DRAW | LV_STYLE_PROP_LAYOUT_REFR,\n\n    /*Group 2*/\n    LV_STYLE_BG_COLOR                = 32,\n    LV_STYLE_BG_COLOR_FILTERED       = 32 | LV_STYLE_PROP_FILTER,\n    LV_STYLE_BG_OPA                  = 33,\n    LV_STYLE_BG_GRAD_COLOR           = 34,\n    LV_STYLE_BG_GRAD_COLOR_FILTERED  = 34 | LV_STYLE_PROP_FILTER,\n    LV_STYLE_BG_GRAD_DIR             = 35,\n    LV_STYLE_BG_MAIN_STOP            = 36,\n    LV_STYLE_BG_GRAD_STOP            = 37,\n\n    LV_STYLE_BG_IMG_SRC              = 38 | LV_STYLE_PROP_EXT_DRAW,\n    LV_STYLE_BG_IMG_OPA              = 39,\n    LV_STYLE_BG_IMG_RECOLOR          = 40,\n    LV_STYLE_BG_IMG_RECOLOR_FILTERED = 40 | LV_STYLE_PROP_FILTER,\n    LV_STYLE_BG_IMG_RECOLOR_OPA      = 41,\n    LV_STYLE_BG_IMG_TILED            = 42,\n\n    /*Group 3*/\n    LV_STYLE_BORDER_COLOR            = 48,\n    LV_STYLE_BORDER_COLOR_FILTERED   = 48 | LV_STYLE_PROP_FILTER,\n    LV_STYLE_BORDER_OPA              = 49,\n    LV_STYLE_BORDER_WIDTH            = 50 | LV_STYLE_PROP_LAYOUT_REFR,\n    LV_STYLE_BORDER_SIDE             = 51,\n    LV_STYLE_BORDER_POST             = 52,\n\n    LV_STYLE_OUTLINE_WIDTH           = 58 | LV_STYLE_PROP_EXT_DRAW,\n    LV_STYLE_OUTLINE_COLOR           = 59,\n    LV_STYLE_OUTLINE_COLOR_FILTERED  = 59 | LV_STYLE_PROP_FILTER,\n    LV_STYLE_OUTLINE_OPA             = 60 | LV_STYLE_PROP_EXT_DRAW,\n    LV_STYLE_OUTLINE_PAD             = 61 | LV_STYLE_PROP_EXT_DRAW,\n\n    /*Group 4*/\n    LV_STYLE_SHADOW_WIDTH            = 64 | LV_STYLE_PROP_EXT_DRAW,\n    LV_STYLE_SHADOW_OFS_X            = 65 | LV_STYLE_PROP_EXT_DRAW,\n    LV_STYLE_SHADOW_OFS_Y            = 66 | LV_STYLE_PROP_EXT_DRAW,\n    LV_STYLE_SHADOW_SPREAD           = 67 | LV_STYLE_PROP_EXT_DRAW,\n    LV_STYLE_SHADOW_COLOR            = 68,\n    LV_STYLE_SHADOW_COLOR_FILTERED   = 68 | LV_STYLE_PROP_FILTER,\n    LV_STYLE_SHADOW_OPA              = 69 | LV_STYLE_PROP_EXT_DRAW,\n\n    LV_STYLE_IMG_OPA                 = 70,\n    LV_STYLE_IMG_RECOLOR             = 71,\n    LV_STYLE_IMG_RECOLOR_FILTERED    = 71 | LV_STYLE_PROP_FILTER,\n    LV_STYLE_IMG_RECOLOR_OPA         = 72,\n\n    LV_STYLE_LINE_WIDTH              = 73 | LV_STYLE_PROP_EXT_DRAW,\n    LV_STYLE_LINE_DASH_WIDTH         = 74,\n    LV_STYLE_LINE_DASH_GAP           = 75,\n    LV_STYLE_LINE_ROUNDED            = 76,\n    LV_STYLE_LINE_COLOR              = 77,\n    LV_STYLE_LINE_COLOR_FILTERED     = 77 | LV_STYLE_PROP_FILTER,\n    LV_STYLE_LINE_OPA                = 78,\n\n    /*Group 5*/\n    LV_STYLE_ARC_WIDTH               = 80 | LV_STYLE_PROP_EXT_DRAW,\n    LV_STYLE_ARC_ROUNDED             = 81,\n    LV_STYLE_ARC_COLOR               = 82,\n    LV_STYLE_ARC_COLOR_FILTERED      = 82 | LV_STYLE_PROP_FILTER,\n    LV_STYLE_ARC_OPA                 = 83,\n    LV_STYLE_ARC_IMG_SRC             = 84,\n\n    LV_STYLE_TEXT_COLOR              = 87 | LV_STYLE_PROP_INHERIT,\n    LV_STYLE_TEXT_COLOR_FILTERED     = 87 | LV_STYLE_PROP_INHERIT | LV_STYLE_PROP_FILTER,\n    LV_STYLE_TEXT_OPA                = 88 | LV_STYLE_PROP_INHERIT,\n    LV_STYLE_TEXT_FONT               = 89 | LV_STYLE_PROP_INHERIT | LV_STYLE_PROP_LAYOUT_REFR,\n    LV_STYLE_TEXT_LETTER_SPACE       = 90 | LV_STYLE_PROP_INHERIT | LV_STYLE_PROP_LAYOUT_REFR,\n    LV_STYLE_TEXT_LINE_SPACE         = 91 | LV_STYLE_PROP_INHERIT | LV_STYLE_PROP_LAYOUT_REFR,\n    LV_STYLE_TEXT_DECOR              = 92 | LV_STYLE_PROP_INHERIT,\n    LV_STYLE_TEXT_ALIGN              = 93 | LV_STYLE_PROP_INHERIT | LV_STYLE_PROP_LAYOUT_REFR,\n\n    /*Group 6*/\n    LV_STYLE_RADIUS                  = 96,\n    LV_STYLE_CLIP_CORNER             = 97,\n    LV_STYLE_OPA                     = 98 | LV_STYLE_PROP_INHERIT,\n    LV_STYLE_COLOR_FILTER_DSC        = 99,\n    LV_STYLE_COLOR_FILTER_OPA        = 100,\n    LV_STYLE_ANIM_TIME               = 101,\n    LV_STYLE_ANIM_SPEED              = 102,\n    LV_STYLE_TRANSITION              = 103,\n    LV_STYLE_BLEND_MODE              = 104,\n    LV_STYLE_LAYOUT                  = 105 | LV_STYLE_PROP_LAYOUT_REFR,\n    LV_STYLE_BASE_DIR                = 106 | LV_STYLE_PROP_INHERIT | LV_STYLE_PROP_LAYOUT_REFR,\n\n    _LV_STYLE_LAST_BUILT_IN_PROP     = 111,\n\n    LV_STYLE_PROP_ANY                = 0xFFFF\n} lv_style_prop_t", "sline": 233, "docstring": "/**"}, "lv_style_transition_dsc_t.props": {"type": "Variable", "def": "const lv_style_prop_t * props", "sline": 239, "in_struct": "lv_style_transition_dsc_t"}, "lv_style_transition_dsc_t.user_data": {"type": "Variable", "def": "void * user_data", "sline": 241, "in_struct": "lv_style_transition_dsc_t"}, "lv_style_transition_dsc_t.path_xcb": {"type": "Variable", "def": "lv_anim_path_cb_t path_xcb", "sline": 243, "in_struct": "lv_style_transition_dsc_t"}, "lv_style_transition_dsc_t.time": {"type": "Variable", "def": "uint32_t time", "sline": 244, "in_struct": "lv_style_transition_dsc_t"}, "lv_style_transition_dsc_t.delay": {"type": "Variable", "def": "uint32_t delay", "sline": 245, "in_struct": "lv_style_transition_dsc_t"}, "lv_style_transition_dsc_t": {"type": "Variable", "def": "typedef struct {\n    const lv_style_prop_t * props; /**< An array with the properties to animate.*/\n#if LV_USE_USER_DATA\n    void * user_data;              /**< A custom user data that will be passed to the animation's user_data */\n#endif\n    lv_anim_path_cb_t path_xcb;     /**< A path for the animation.*/\n    uint32_t time;                 /**< Duration of the transition in [ms]*/\n    uint32_t delay;                /**< Delay before the transition in [ms]*/\n} lv_style_transition_dsc_t", "sline": 246, "docstring": "/**"}, "lv_style_const_prop_t.prop": {"type": "Variable", "def": "lv_style_prop_t prop", "sline": 252, "in_struct": "lv_style_const_prop_t", "rels": [["lv_style_prop_t", null, "Typeof"]]}, "lv_style_const_prop_t.value": {"type": "Variable", "def": "lv_style_value_t value", "sline": 253, "in_struct": "lv_style_const_prop_t", "rels": [["lv_style_value_t", null, "Typeof"]]}, "lv_style_const_prop_t": {"type": "Variable", "def": "typedef struct {\n    lv_style_prop_t prop;\n    lv_style_value_t value;\n} lv_style_const_prop_t", "sline": 254, "docstring": "/**"}, "lv_style_t.v_p": {"type": "Variable", "def": "union {\n        lv_style_value_t value1;\n        uint8_t * values_and_props;\n        const lv_style_const_prop_t * const_props;\n    } v_p", "sline": 271, "in_struct": "lv_style_t"}, "lv_style_t.prop1": {"type": "Variable", "def": "uint16_t prop1 : 15", "sline": 273, "in_struct": "lv_style_t"}, "lv_style_t.is_const": {"type": "Variable", "def": "uint16_t is_const : 1", "sline": 274, "in_struct": "lv_style_t"}, "lv_style_t.has_group": {"type": "Variable", "def": "uint8_t has_group", "sline": 275, "in_struct": "lv_style_t"}, "lv_style_t.prop_cnt": {"type": "Variable", "def": "uint8_t prop_cnt", "sline": 276, "in_struct": "lv_style_t"}, "lv_style_t": {"type": "Variable", "def": "typedef struct {\n\n#if LV_USE_ASSERT_STYLE\n    uint32_t sentinel;\n#endif\n\n    /*If there is only one property store it directly.\n     *For more properties allocate an array*/\n    union {\n        lv_style_value_t value1;\n        uint8_t * values_and_props;\n        const lv_style_const_prop_t * const_props;\n    } v_p;\n\n    uint16_t prop1 : 15;\n    uint16_t is_const : 1;\n    uint8_t has_group;\n    uint8_t prop_cnt;\n} lv_style_t", "sline": 277, "docstring": "/**"}, "lv_style_init": {"type": "Function", "def": "void lv_style_init(lv_style_t * style)", "sline": 291}, "lv_style_reset": {"type": "Function", "def": "void lv_style_reset(lv_style_t * style)", "sline": 297}, "lv_style_register_prop": {"type": "Function", "def": "lv_style_prop_t lv_style_register_prop(void)", "sline": 312, "rels": [["lv_style_prop_t", null, "Typeof"]]}, "lv_style_remove_prop": {"type": "Function", "def": "bool lv_style_remove_prop(lv_style_t * style, lv_style_prop_t prop)", "sline": 320}, "lv_style_set_prop": {"type": "Function", "def": "void lv_style_set_prop(lv_style_t * style, lv_style_prop_t prop, lv_style_value_t value)", "sline": 330}, "lv_style_get_prop": {"type": "Function", "def": "lv_res_t lv_style_get_prop(lv_style_t * style, lv_style_prop_t prop, lv_style_value_t * value)", "sline": 341}, "lv_style_get_prop_inlined": {"type": "Function", "def": "static inline lv_res_t lv_style_get_prop_inlined(lv_style_t * style, lv_style_prop_t prop, lv_style_value_t * value)", "sline": 354, "body": "{\n    if(style->is_const) {\n        const lv_style_const_prop_t * const_prop;\n        for(const_prop = style->v_p.const_props; const_prop->prop != LV_STYLE_PROP_INV; const_prop++) {\n            if(const_prop->prop == prop) {\n                *value = const_prop->value;\n                return LV_RES_OK;\n            }\n        }\n        return LV_RES_INV;\n    }\n\n    if(style->prop_cnt == 0) return LV_RES_INV;\n\n    if(style->prop_cnt > 1) {\n        uint8_t * tmp = style->v_p.values_and_props + style->prop_cnt * sizeof(lv_style_value_t);\n        uint16_t * props = (uint16_t *)tmp;\n        uint32_t i;\n        for(i = 0; i < style->prop_cnt; i++) {\n            if(props[i] == prop) {\n                lv_style_value_t * values = (lv_style_value_t *)style->v_p.values_and_props;\n                *value = values[i];\n                return LV_RES_OK;\n            }\n        }\n    }\n    else if(style->prop1 == prop) {\n        *value = style->v_p.value1;\n        return LV_RES_OK;\n    }\n    return LV_RES_INV;\n}"}, "lv_style_transition_dsc_init": {"type": "Function", "def": "void lv_style_transition_dsc_init(lv_style_transition_dsc_t * tr, const lv_style_prop_t props[],\n                                  lv_anim_path_cb_t path_cb, uint32_t time, uint32_t delay, void * user_data)", "sline": 401}, "lv_style_prop_get_default": {"type": "Function", "def": "lv_style_value_t lv_style_prop_get_default(lv_style_prop_t prop)", "sline": 409, "rels": [["lv_style_value_t", null, "Typeof"]]}, "lv_style_is_empty": {"type": "Function", "def": "bool lv_style_is_empty(const lv_style_t * style)", "sline": 416}, "_lv_style_get_prop_group": {"type": "Function", "def": "uint8_t _lv_style_get_prop_group(lv_style_prop_t prop)", "sline": 424}, "lv_style_set_pad_all": {"type": "Function", "def": "static inline void lv_style_set_pad_all(lv_style_t * style, lv_coord_t value)", "sline": 428, "body": "{\n    lv_style_set_pad_left(style, value);\n    lv_style_set_pad_right(style, value);\n    lv_style_set_pad_top(style, value);\n    lv_style_set_pad_bottom(style, value);\n}"}, "lv_style_set_pad_hor": {"type": "Function", "def": "static inline void lv_style_set_pad_hor(lv_style_t * style, lv_coord_t value)", "sline": 436, "body": "{\n    lv_style_set_pad_left(style, value);\n    lv_style_set_pad_right(style, value);\n}"}, "lv_style_set_pad_ver": {"type": "Function", "def": "static inline void lv_style_set_pad_ver(lv_style_t * style, lv_coord_t value)", "sline": 442, "body": "{\n    lv_style_set_pad_top(style, value);\n    lv_style_set_pad_bottom(style, value);\n}"}, "lv_style_set_pad_gap": {"type": "Function", "def": "static inline void lv_style_set_pad_gap(lv_style_t * style, lv_coord_t value)", "sline": 448, "body": "{\n    lv_style_set_pad_row(style, value);\n    lv_style_set_pad_column(style, value);\n}"}, "lv_style_set_size": {"type": "Function", "def": "static inline void lv_style_set_size(lv_style_t * style, lv_coord_t value)", "sline": 454, "body": "{\n    lv_style_set_width(style, value);\n    lv_style_set_height(style, value);\n}"}, "carbit_updater/lvgl/src/misc/lv_style.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_style.h"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_30.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_montserrat_30.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_30.c"}}, "carbit_updater/lvgl/tests/unity/unity.c": {"carbit_updater/lvgl/tests/unity/unity.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/tests/unity/unity.c"}}, "carbit_updater/lvgl/src/extra/layouts/lv_layouts.h": {"lv_flex": {"type": "Variable", "def": "#include flex/lv_flex.h", "sline": 16, "include": ["carbit_updater/lvgl/src/extra/layouts/flex/lv_flex.h", null]}, "lv_grid": {"type": "Variable", "def": "#include grid/lv_grid.h", "sline": 17, "include": ["carbit_updater/lvgl/src/extra/layouts/grid/lv_grid.h", null]}, "carbit_updater/lvgl/src/extra/layouts/lv_layouts.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/layouts/lv_layouts.h"}}, "carbit_updater/loopbuffer.c": {"stdlib": {"type": "Variable", "def": "#include stdlib.h", "sline": 1}, "unistd": {"type": "Variable", "def": "#include unistd.h", "sline": 2}, "stdio": {"type": "Variable", "def": "#include stdio.h", "sline": 3}, "fcntl": {"type": "Variable", "def": "#include fcntl.h", "sline": 4}, "mman": {"type": "Variable", "def": "#include sys/mman.h", "sline": 5}, "ioctl": {"type": "Variable", "def": "#include sys/ioctl.h", "sline": 6}, "time": {"type": "Variable", "def": "#include sys/time.h", "sline": 7}, "string": {"type": "Variable", "def": "#include string.h", "sline": 8}, "errno": {"type": "Variable", "def": "#include errno.h", "sline": 9}, "pthread": {"type": "Variable", "def": "#include pthread.h", "sline": 10}, "loopbuffer": {"type": "Variable", "def": "#include loopbuffer.h", "sline": 11, "include": ["carbit_updater/loopbuffer.h", null]}, "loopbuffer_create": {"type": "Function", "def": "loopbuffer_t *loopbuffer_create(int iBuffLen)", "sline": 14, "body": "{\n    loopbuffer_t * pBuf = NULL;\n    pBuf = (loopbuffer_t *)malloc(sizeof(loopbuffer_t));\n\n    if(!pBuf) return NULL;\n    pBuf->pBuffer = (uint8_t *)malloc(iBuffLen);\n\n    if(!pBuf->pBuffer)\n    {\n        free(pBuf);\n        return NULL;\n    }\n\n    pBuf->m_nSize = iBuffLen;\n\tpBuf->m_nPos=0;\n\tpBuf->m_nLen=0;\n    return pBuf;\n}"}, "loopbuffer_destory": {"type": "Function", "def": "void loopbuffer_destory(loopbuffer_t * ipbuffer)", "sline": 34, "body": "{\n    if(ipbuffer)\n    {\n        if(ipbuffer->pBuffer)free(ipbuffer->pBuffer);\n        free(ipbuffer);\n    }\n    return ;\n}"}, "loopbuffer_addData": {"type": "Function", "def": "int32_t loopbuffer_addData(loopbuffer_t * pBuf,const unsigned char* pData, int nDataLength)", "sline": 44, "body": "{\n    if(!pBuf) return 0;\n\n\tif(pBuf->m_nSize - pBuf->m_nLen < nDataLength)\n\t{\n\t\treturn 0;\n\t}\n\n\twhile(nDataLength > 0)\n\t{\n\t    int nSaved;\n\t\tint nOffset = pBuf->m_nPos+pBuf->m_nLen;\n\t\tif(nOffset >= pBuf->m_nSize)\n\t\t\tnOffset -= pBuf->m_nSize;\n\n\t\tnSaved = min(pBuf->m_nSize-pBuf->m_nLen, nDataLength);\n\n\t\tif(nOffset+nSaved > pBuf->m_nSize)\n\t\t\tnSaved = pBuf->m_nSize-nOffset;\n\n\t\tmemcpy(pBuf->pBuffer+nOffset, pData, nSaved);\n\n\t\tpBuf->m_nLen += nSaved;\n\t\tpData += nSaved;\n\t\tnDataLength -= nSaved;\n\t}\n    return 1;\n}"}, "loopbuffer_getSize": {"type": "Function", "def": "int32_t loopbuffer_getSize(loopbuffer_t * pBuf)", "sline": 74, "body": "{\n    if(!pBuf) return 0;\n\n    return pBuf->m_nLen;\n}"}, "loopbuffer_at": {"type": "Function", "def": "unsigned char loopbuffer_at(loopbuffer_t * pBuf,int index)", "sline": 81, "body": "{\n    index += pBuf->m_nPos;\n\n    while(index >= pBuf->m_nSize)\n    {\n        index -= pBuf->m_nSize;\n    }\n\n    return pBuf->pBuffer[index];\n}"}, "loopbuffer_Pop": {"type": "Function", "def": "void loopbuffer_Pop(loopbuffer_t * pBuf,int count)", "sline": 94, "body": "{\n    if(!pBuf) return ;\n\n    if(count > pBuf->m_nLen)\n        count = pBuf->m_nLen;\n\n    pBuf->m_nPos += count;\n    while(pBuf->m_nPos >= pBuf->m_nSize)\n    {\n        pBuf->m_nPos -= pBuf->m_nSize;\n\n    }\n\n    pBuf->m_nLen -= count;\n}"}, "loopbuffer_getData": {"type": "Function", "def": "int loopbuffer_getData(loopbuffer_t * pBuf,unsigned char* pOBuf, int nLength)", "sline": 111, "body": "{\n\tint nRecved = 0;\n    int nTimes = 0;\n    if(!pBuf) return 0;\n\n\twhile(nRecved<nLength && nTimes<=1)\n\t{\n\t\tint nSubRecved = min(pBuf->m_nLen, nLength-nRecved);\n\t\tif(nSubRecved > 0)\n\t\t{\n\t\t\tif(pBuf->m_nPos>0 && pBuf->m_nPos+nSubRecved>pBuf->m_nSize)\n\t\t\t\tnSubRecved = pBuf->m_nSize-pBuf->m_nPos;\n\n\t\t\tmemcpy(pOBuf+nRecved, pBuf->pBuffer+pBuf->m_nPos, nSubRecved);\n\n\t\t\tpBuf->m_nPos += nSubRecved;\n\t\t\tif(pBuf->m_nPos >= pBuf->m_nSize)\n\t\t\t\tpBuf->m_nPos -= pBuf->m_nSize;\n\n\t\t\tpBuf->m_nLen -= nSubRecved;\n\t\t\tnRecved += nSubRecved;\n\t\t}\n\n        nTimes++;\n\t}\n\n\treturn nRecved;\n}"}, "carbit_updater/loopbuffer.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/loopbuffer.c"}}, "carbit_updater/lv_drivers/display/drm.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 20}, "carbit_updater/lv_drivers/display/drm.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/drm.h"}}, "carbit_updater/update_font_32.c": {"lvgl": {"type": "Variable", "def": "#include lvgl/lvgl.h", "sline": 10, "include": ["carbit_updater/lvgl/lvgl.h", null]}, "glyph_bitmap": {"type": "Variable", "def": "static LV_ATTRIBUTE_LARGE_CONST const uint8_t glyph_bitmap[] = {\n    /* U+0020 \" \" */\n\n    /* U+0025 \"%\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x4, 0x0, 0x0, 0x0, 0x0, 0x8d, 0xfd, 0x60,\n    0x0, 0x0, 0x0, 0x0, 0x4f, 0xc0, 0x0, 0x0,\n    0xa, 0xff, 0xff, 0xf7, 0x0, 0x0, 0x0, 0x0,\n    0xdf, 0x80, 0x0, 0x0, 0x3f, 0xf5, 0x17, 0xff,\n    0x10, 0x0, 0x0, 0x6, 0xfe, 0x0, 0x0, 0x0,\n    0x9f, 0xa0, 0x0, 0xcf, 0x60, 0x0, 0x0, 0x1e,\n    0xf6, 0x0, 0x0, 0x0, 0xcf, 0x60, 0x0, 0x8f,\n    0x90, 0x0, 0x0, 0x8f, 0xd0, 0x0, 0x0, 0x0,\n    0xdf, 0x40, 0x0, 0x7f, 0xa0, 0x0, 0x2, 0xff,\n    0x40, 0x0, 0x0, 0x0, 0xdf, 0x40, 0x0, 0x7f,\n    0xa0, 0x0, 0xb, 0xfb, 0x0, 0x0, 0x0, 0x0,\n    0xcf, 0x60, 0x0, 0x8f, 0x90, 0x0, 0x4f, 0xf2,\n    0x0, 0x0, 0x0, 0x0, 0x9f, 0xa0, 0x0, 0xcf,\n    0x60, 0x0, 0xdf, 0x90, 0x0, 0x0, 0x0, 0x0,\n    0x3f, 0xf5, 0x17, 0xff, 0x10, 0x6, 0xfe, 0x10,\n    0x0, 0x0, 0x0, 0x0, 0xa, 0xff, 0xff, 0xf7,\n    0x0, 0xe, 0xf6, 0x0, 0x7, 0xdf, 0xd7, 0x0,\n    0x0, 0x8e, 0xfd, 0x60, 0x0, 0x8f, 0xd0, 0x0,\n    0x9f, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0,\n    0x2, 0xff, 0x40, 0x3, 0xff, 0x51, 0x6f, 0xf1,\n    0x0, 0x0, 0x0, 0x0, 0xa, 0xfb, 0x0, 0x8,\n    0xfa, 0x0, 0xc, 0xf6, 0x0, 0x0, 0x0, 0x0,\n    0x4f, 0xf2, 0x0, 0xb, 0xf6, 0x0, 0x8, 0xf9,\n    0x0, 0x0, 0x0, 0x0, 0xcf, 0x90, 0x0, 0xc,\n    0xf5, 0x0, 0x6, 0xfb, 0x0, 0x0, 0x0, 0x6,\n    0xfe, 0x10, 0x0, 0xc, 0xf5, 0x0, 0x6, 0xfb,\n    0x0, 0x0, 0x0, 0xe, 0xf7, 0x0, 0x0, 0xb,\n    0xf6, 0x0, 0x8, 0xf9, 0x0, 0x0, 0x0, 0x8f,\n    0xd0, 0x0, 0x0, 0x8, 0xfa, 0x0, 0xc, 0xf6,\n    0x0, 0x0, 0x2, 0xff, 0x40, 0x0, 0x0, 0x3,\n    0xff, 0x51, 0x6f, 0xf1, 0x0, 0x0, 0xa, 0xfb,\n    0x0, 0x0, 0x0, 0x0, 0x9f, 0xff, 0xff, 0x80,\n    0x0, 0x0, 0x4, 0xd2, 0x0, 0x0, 0x0, 0x0,\n    0x7, 0xdf, 0xd7, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+002C \",\" */\n    0x0, 0x99, 0x20, 0x0, 0xff, 0xe0, 0x4, 0xff,\n    0x80, 0x8, 0xff, 0x10, 0xd, 0xf9, 0x0, 0x2f,\n    0xf2, 0x0, 0x6f, 0xa0, 0x0, 0x7f, 0x30, 0x0,\n    0x0, 0x0, 0x0,\n\n    /* U+002E \".\" */\n    0x1c, 0xf9, 0x7, 0xff, 0xf3, 0x7f, 0xff, 0x31,\n    0xcf, 0x90,\n\n    /* U+0030 \"0\" */\n    0x0, 0x0, 0x18, 0xdf, 0xec, 0x70, 0x0, 0x0,\n    0x0, 0x4, 0xef, 0xff, 0xff, 0xfd, 0x20, 0x0,\n    0x0, 0x3f, 0xff, 0xeb, 0xbf, 0xff, 0xd1, 0x0,\n    0x0, 0xdf, 0xf9, 0x0, 0x1, 0xbf, 0xf9, 0x0,\n    0x5, 0xff, 0xb0, 0x0, 0x0, 0x1e, 0xff, 0x20,\n    0xb, 0xff, 0x30, 0x0, 0x0, 0x7, 0xff, 0x70,\n    0xf, 0xfe, 0x0, 0x0, 0x0, 0x2, 0xff, 0xb0,\n    0x2f, 0xfb, 0x0, 0x0, 0x0, 0x0, 0xef, 0xe0,\n    0x4f, 0xf8, 0x0, 0x0, 0x0, 0x0, 0xcf, 0xf0,\n    0x5f, 0xf7, 0x0, 0x0, 0x0, 0x0, 0xbf, 0xf1,\n    0x5f, 0xf7, 0x0, 0x0, 0x0, 0x0, 0xaf, 0xf2,\n    0x5f, 0xf7, 0x0, 0x0, 0x0, 0x0, 0xbf, 0xf1,\n    0x4f, 0xf8, 0x0, 0x0, 0x0, 0x0, 0xcf, 0xf0,\n    0x2f, 0xfb, 0x0, 0x0, 0x0, 0x0, 0xef, 0xe0,\n    0xf, 0xfe, 0x0, 0x0, 0x0, 0x2, 0xff, 0xb0,\n    0xb, 0xff, 0x30, 0x0, 0x0, 0x7, 0xff, 0x70,\n    0x5, 0xff, 0xc0, 0x0, 0x0, 0x1e, 0xff, 0x20,\n    0x0, 0xdf, 0xf9, 0x0, 0x1, 0xcf, 0xf9, 0x0,\n    0x0, 0x3f, 0xff, 0xeb, 0xbf, 0xff, 0xd1, 0x0,\n    0x0, 0x4, 0xef, 0xff, 0xff, 0xfd, 0x20, 0x0,\n    0x0, 0x0, 0x18, 0xdf, 0xfc, 0x70, 0x0, 0x0,\n\n    /* U+0031 \"1\" */\n    0x0, 0xaf, 0xff, 0xb0, 0x5f, 0xff, 0xfb, 0x9,\n    0xaa, 0xff, 0xb0, 0x0, 0xf, 0xfb, 0x0, 0x0,\n    0xff, 0xb0, 0x0, 0xf, 0xfb, 0x0, 0x0, 0xff,\n    0xb0, 0x0, 0xf, 0xfb, 0x0, 0x0, 0xff, 0xb0,\n    0x0, 0xf, 0xfb, 0x0, 0x0, 0xff, 0xb0, 0x0,\n    0xf, 0xfb, 0x0, 0x0, 0xff, 0xb0, 0x0, 0xf,\n    0xfb, 0x0, 0x0, 0xff, 0xb0, 0x0, 0xf, 0xfb,\n    0x0, 0x0, 0xff, 0xb0, 0x0, 0xf, 0xfb, 0x0,\n    0x0, 0xff, 0xb0, 0x0, 0xf, 0xfb, 0x0, 0x0,\n    0xff, 0xb0,\n\n    /* U+0032 \"2\" */\n    0x0, 0x3, 0xae, 0xfe, 0xb5, 0x0, 0x0, 0x0,\n    0x7f, 0xff, 0xff, 0xff, 0xa0, 0x0, 0x6, 0xff,\n    0xfd, 0xbd, 0xff, 0xfa, 0x0, 0x1f, 0xff, 0x60,\n    0x0, 0x4f, 0xff, 0x40, 0x7f, 0xfa, 0x0, 0x0,\n    0x6, 0xff, 0xa0, 0xaf, 0xf4, 0x0, 0x0, 0x1,\n    0xff, 0xd0, 0x69, 0x91, 0x0, 0x0, 0x0, 0xff,\n    0xd0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xc0,\n    0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0x80, 0x0,\n    0x0, 0x0, 0x0, 0x1e, 0xff, 0x10, 0x0, 0x0,\n    0x0, 0x0, 0xaf, 0xf8, 0x0, 0x0, 0x0, 0x0,\n    0x6, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x3f,\n    0xff, 0x20, 0x0, 0x0, 0x0, 0x1, 0xef, 0xf5,\n    0x0, 0x0, 0x0, 0x0, 0xb, 0xff, 0x80, 0x0,\n    0x0, 0x0, 0x0, 0x8f, 0xfc, 0x0, 0x0, 0x0,\n    0x0, 0x4, 0xff, 0xe1, 0x0, 0x0, 0x0, 0x0,\n    0x2e, 0xff, 0x30, 0x0, 0x0, 0x0, 0x0, 0xdf,\n    0xfe, 0xaa, 0xaa, 0xaa, 0xa0, 0xa, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xf0, 0x6f, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xf0,\n\n    /* U+0033 \"3\" */\n    0x0, 0x2, 0x9d, 0xff, 0xc6, 0x0, 0x0, 0x0,\n    0x5f, 0xff, 0xff, 0xff, 0xd1, 0x0, 0x4, 0xff,\n    0xfe, 0xbc, 0xff, 0xfd, 0x0, 0xd, 0xff, 0x90,\n    0x0, 0x2e, 0xff, 0x60, 0x1f, 0xfd, 0x0, 0x0,\n    0x4, 0xff, 0xb0, 0x18, 0x85, 0x0, 0x0, 0x1,\n    0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff,\n    0xa0, 0x0, 0x0, 0x0, 0x0, 0x2d, 0xff, 0x50,\n    0x0, 0x0, 0x0, 0x5c, 0xff, 0xfb, 0x0, 0x0,\n    0x0, 0x0, 0x8f, 0xff, 0xd0, 0x0, 0x0, 0x0,\n    0x0, 0x8f, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0,\n    0x1, 0x7f, 0xff, 0x50, 0x0, 0x0, 0x0, 0x0,\n    0x5, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0xdf, 0xf1, 0x35, 0x51, 0x0, 0x0, 0x0, 0xaf,\n    0xf2, 0x9f, 0xf4, 0x0, 0x0, 0x0, 0xbf, 0xf2,\n    0x6f, 0xfa, 0x0, 0x0, 0x1, 0xff, 0xe0, 0xe,\n    0xff, 0x70, 0x0, 0x1d, 0xff, 0x80, 0x5, 0xff,\n    0xfe, 0xab, 0xff, 0xfd, 0x10, 0x0, 0x6f, 0xff,\n    0xff, 0xff, 0xd2, 0x0, 0x0, 0x2, 0x9d, 0xff,\n    0xc6, 0x0, 0x0,\n\n    /* U+0034 \"4\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x60, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xd0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xd, 0xe0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xaf, 0xe0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x5, 0xff, 0xe0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x1e, 0xff, 0xe0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xbf, 0xff, 0xe0, 0x0,\n    0x0, 0x0, 0x0, 0x6, 0xff, 0xff, 0xe0, 0x0,\n    0x0, 0x0, 0x0, 0x2f, 0xfd, 0xdf, 0xe0, 0x0,\n    0x0, 0x0, 0x0, 0xcf, 0xf3, 0xcf, 0xe0, 0x0,\n    0x0, 0x0, 0x8, 0xff, 0x80, 0xcf, 0xe0, 0x0,\n    0x0, 0x0, 0x3f, 0xfc, 0x0, 0xcf, 0xe0, 0x0,\n    0x0, 0x0, 0xdf, 0xf2, 0x0, 0xcf, 0xe0, 0x0,\n    0x0, 0x9, 0xff, 0x60, 0x0, 0xcf, 0xe0, 0x0,\n    0x0, 0x4f, 0xfb, 0x0, 0x0, 0xcf, 0xe0, 0x0,\n    0x1, 0xef, 0xfb, 0x99, 0x99, 0xef, 0xf9, 0x95,\n    0xb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9,\n    0x6f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xcf, 0xe0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xcf, 0xe0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xcf, 0xe0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xcf, 0xe0, 0x0,\n\n    /* U+0035 \"5\" */\n    0x0, 0x0, 0x8, 0xff, 0xff, 0xff, 0xfe, 0x0,\n    0x0, 0x0, 0xcf, 0xff, 0xff, 0xff, 0xe0, 0x0,\n    0x0, 0xf, 0xfd, 0xaa, 0xaa, 0xa9, 0x0, 0x0,\n    0x4, 0xff, 0x60, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x8f, 0xf2, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc,\n    0xfe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff,\n    0xb0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4f, 0xff,\n    0xfe, 0xc6, 0x0, 0x0, 0x0, 0x8, 0xff, 0xff,\n    0xff, 0xfd, 0x20, 0x0, 0x0, 0xcf, 0xc9, 0x9b,\n    0xff, 0xfe, 0x10, 0x0, 0xa, 0x20, 0x0, 0x2,\n    0xcf, 0xfb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1,\n    0xef, 0xf2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6,\n    0xff, 0x70, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f,\n    0xf9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xff,\n    0x92, 0x9d, 0x40, 0x0, 0x0, 0x0, 0x6f, 0xf7,\n    0x2f, 0xfc, 0x0, 0x0, 0x0, 0x1e, 0xff, 0x20,\n    0xaf, 0xfa, 0x10, 0x0, 0x2c, 0xff, 0xa0, 0x1,\n    0xef, 0xff, 0xb9, 0xbf, 0xff, 0xd0, 0x0, 0x2,\n    0xdf, 0xff, 0xff, 0xff, 0xb1, 0x0, 0x0, 0x0,\n    0x6b, 0xef, 0xea, 0x40, 0x0, 0x0,\n\n    /* U+0036 \"6\" */\n    0x0, 0x0, 0x0, 0x0, 0x3a, 0x10, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xd, 0xfd, 0x10, 0x0, 0x0,\n    0x0, 0x0, 0x9, 0xff, 0xb0, 0x0, 0x0, 0x0,\n    0x0, 0x4, 0xff, 0xe1, 0x0, 0x0, 0x0, 0x0,\n    0x1, 0xef, 0xf3, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0xbf, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f,\n    0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2f, 0xfe,\n    0x10, 0x0, 0x0, 0x0, 0x0, 0xd, 0xff, 0xff,\n    0xea, 0x40, 0x0, 0x0, 0x8, 0xff, 0xff, 0xff,\n    0xff, 0xa0, 0x0, 0x3, 0xff, 0xff, 0xba, 0xcf,\n    0xff, 0xb0, 0x0, 0xbf, 0xfb, 0x10, 0x0, 0x3e,\n    0xff, 0x60, 0x2f, 0xfd, 0x0, 0x0, 0x0, 0x3f,\n    0xfd, 0x7, 0xff, 0x50, 0x0, 0x0, 0x0, 0xbf,\n    0xf2, 0x9f, 0xf2, 0x0, 0x0, 0x0, 0x8, 0xff,\n    0x49, 0xff, 0x20, 0x0, 0x0, 0x0, 0x8f, 0xf4,\n    0x7f, 0xf5, 0x0, 0x0, 0x0, 0xb, 0xff, 0x23,\n    0xff, 0xd0, 0x0, 0x0, 0x3, 0xff, 0xd0, 0xb,\n    0xff, 0xb1, 0x0, 0x3, 0xef, 0xf6, 0x0, 0x1e,\n    0xff, 0xfb, 0x9c, 0xff, 0xfa, 0x0, 0x0, 0x2d,\n    0xff, 0xff, 0xff, 0xf9, 0x0, 0x0, 0x0, 0x6,\n    0xce, 0xfe, 0xa3, 0x0, 0x0,\n\n    /* U+0037 \"7\" */\n    0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf4,\n    0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa0,\n    0x9b, 0xbb, 0xbb, 0xbb, 0xbb, 0xcf, 0xff, 0x10,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x8f, 0xf7, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xd0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xb, 0xff, 0x40, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x5f, 0xfa, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xef, 0xf1, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x8, 0xff, 0x70, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x2f, 0xfd, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xbf, 0xf4, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x5, 0xff, 0xa0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xe, 0xff, 0x10, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x8f, 0xf7, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x2, 0xff, 0xd0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xb, 0xff, 0x40, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x4f, 0xfb, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xdf, 0xf2, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x8, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x2f, 0xfd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x1a, 0xf4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+0038 \"8\" */\n    0x0, 0x1, 0x7c, 0xff, 0xd8, 0x10, 0x0, 0x0,\n    0x3e, 0xff, 0xff, 0xff, 0xe4, 0x0, 0x1, 0xef,\n    0xff, 0xcb, 0xef, 0xff, 0x20, 0x9, 0xff, 0xc1,\n    0x0, 0x1b, 0xff, 0xa0, 0xd, 0xff, 0x20, 0x0,\n    0x0, 0xff, 0xf0, 0xe, 0xfe, 0x0, 0x0, 0x0,\n    0xcf, 0xf0, 0xd, 0xff, 0x10, 0x0, 0x0, 0xff,\n    0xf0, 0x7, 0xff, 0xc1, 0x0, 0xa, 0xff, 0x90,\n    0x0, 0xdf, 0xff, 0xbb, 0xef, 0xfe, 0x10, 0x0,\n    0x1e, 0xff, 0xff, 0xff, 0xf2, 0x0, 0x0, 0xaf,\n    0xff, 0xff, 0xff, 0xfc, 0x0, 0x7, 0xff, 0xe5,\n    0x0, 0x4d, 0xff, 0x90, 0xe, 0xff, 0x20, 0x0,\n    0x1, 0xef, 0xf1, 0x3f, 0xfa, 0x0, 0x0, 0x0,\n    0x8f, 0xf5, 0x5f, 0xf7, 0x0, 0x0, 0x0, 0x5f,\n    0xf7, 0x4f, 0xf8, 0x0, 0x0, 0x0, 0x6f, 0xf6,\n    0x1f, 0xfe, 0x0, 0x0, 0x0, 0xcf, 0xf3, 0xb,\n    0xff, 0xb1, 0x0, 0x9, 0xff, 0xd0, 0x2, 0xff,\n    0xff, 0xbb, 0xef, 0xff, 0x30, 0x0, 0x3e, 0xff,\n    0xff, 0xff, 0xf4, 0x0, 0x0, 0x1, 0x7c, 0xff,\n    0xd8, 0x10, 0x0,\n\n    /* U+0039 \"9\" */\n    0x0, 0x0, 0x7c, 0xef, 0xd9, 0x20, 0x0, 0x0,\n    0x3, 0xef, 0xff, 0xff, 0xff, 0x70, 0x0, 0x3,\n    0xff, 0xfe, 0xaa, 0xdf, 0xff, 0x70, 0x0, 0xdf,\n    0xf9, 0x0, 0x0, 0x5f, 0xff, 0x30, 0x5f, 0xfb,\n    0x0, 0x0, 0x0, 0x5f, 0xfb, 0xa, 0xff, 0x30,\n    0x0, 0x0, 0x0, 0xdf, 0xf0, 0xcf, 0xf0, 0x0,\n    0x0, 0x0, 0xa, 0xff, 0x1c, 0xff, 0x0, 0x0,\n    0x0, 0x0, 0xaf, 0xf1, 0xaf, 0xf3, 0x0, 0x0,\n    0x0, 0xe, 0xff, 0x6, 0xff, 0xb0, 0x0, 0x0,\n    0x5, 0xff, 0xa0, 0xe, 0xff, 0x90, 0x0, 0x5,\n    0xff, 0xf3, 0x0, 0x3f, 0xff, 0xea, 0xad, 0xff,\n    0xfa, 0x0, 0x0, 0x4f, 0xff, 0xff, 0xff, 0xfe,\n    0x10, 0x0, 0x0, 0x18, 0xdf, 0xff, 0xff, 0x50,\n    0x0, 0x0, 0x0, 0x0, 0x8, 0xff, 0xa0, 0x0,\n    0x0, 0x0, 0x0, 0x4, 0xff, 0xe0, 0x0, 0x0,\n    0x0, 0x0, 0x1, 0xef, 0xf3, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xbf, 0xf8, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x7f, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x3f, 0xff, 0x20, 0x0, 0x0, 0x0, 0x0, 0x7,\n    0xff, 0x60, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5,\n    0x90, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+0041 \"A\" */\n    0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x50,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0xe, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x6f, 0xf3, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xdf, 0xfa, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0xff,\n    0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xb,\n    0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x2f, 0xfc, 0xef, 0xe0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x9f, 0xf4, 0x8f, 0xf6, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xd0, 0x1f,\n    0xfd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff,\n    0x60, 0xa, 0xff, 0x40, 0x0, 0x0, 0x0, 0x0,\n    0xd, 0xff, 0x0, 0x3, 0xff, 0xb0, 0x0, 0x0,\n    0x0, 0x0, 0x5f, 0xf8, 0x0, 0x0, 0xcf, 0xf2,\n    0x0, 0x0, 0x0, 0x0, 0xcf, 0xf2, 0x0, 0x0,\n    0x5f, 0xf9, 0x0, 0x0, 0x0, 0x3, 0xff, 0xb0,\n    0x0, 0x0, 0xe, 0xff, 0x0, 0x0, 0x0, 0x9,\n    0xff, 0xdb, 0xbb, 0xbb, 0xbe, 0xff, 0x70, 0x0,\n    0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xd0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xf5, 0x0, 0x0, 0xef, 0xe0, 0x0,\n    0x0, 0x0, 0x0, 0x3f, 0xfc, 0x0, 0x5, 0xff,\n    0x80, 0x0, 0x0, 0x0, 0x0, 0xc, 0xff, 0x30,\n    0xc, 0xff, 0x20, 0x0, 0x0, 0x0, 0x0, 0x5,\n    0xff, 0xa0, 0x3f, 0xfa, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xef, 0xf1, 0xaf, 0xf3, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x7f, 0xf8,\n\n    /* U+0043 \"C\" */\n    0x0, 0x0, 0x0, 0x5, 0xad, 0xef, 0xeb, 0x71,\n    0x0, 0x0, 0x0, 0x6e, 0xff, 0xff, 0xff, 0xff,\n    0xf8, 0x0, 0x0, 0xbf, 0xff, 0xff, 0xdc, 0xdf,\n    0xff, 0xf0, 0x0, 0xcf, 0xff, 0xb3, 0x0, 0x0,\n    0x5, 0xdf, 0x0, 0xaf, 0xff, 0x50, 0x0, 0x0,\n    0x0, 0x0, 0x70, 0x4f, 0xff, 0x40, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xc, 0xff, 0x70, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x2, 0xff, 0xe0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x6f, 0xf9, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x8, 0xff, 0x50, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xaf, 0xf4, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0xff, 0x40,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8f, 0xf5,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0xff,\n    0x90, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2f,\n    0xfe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0xcf, 0xf7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x4, 0xff, 0xf4, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x9, 0xff, 0xf5, 0x0, 0x0, 0x0, 0x0,\n    0x7, 0x0, 0xc, 0xff, 0xfa, 0x30, 0x0, 0x0,\n    0x5c, 0xf0, 0x0, 0xa, 0xff, 0xff, 0xfd, 0xcd,\n    0xff, 0xff, 0x0, 0x0, 0x6, 0xef, 0xff, 0xff,\n    0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x5a, 0xdf,\n    0xfe, 0xb7, 0x10,\n\n    /* U+0045 \"E\" */\n    0x4f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x4f, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0x4f, 0xfd, 0xbb, 0xbb,\n    0xbb, 0xbb, 0x4f, 0xf8, 0x0, 0x0, 0x0, 0x0,\n    0x4f, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x4f, 0xf8,\n    0x0, 0x0, 0x0, 0x0, 0x4f, 0xf8, 0x0, 0x0,\n    0x0, 0x0, 0x4f, 0xf8, 0x0, 0x0, 0x0, 0x0,\n    0x4f, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x4f, 0xfd,\n    0xbb, 0xbb, 0xbb, 0xb9, 0x4f, 0xff, 0xff, 0xff,\n    0xff, 0xfd, 0x4f, 0xff, 0xff, 0xff, 0xff, 0xfd,\n    0x4f, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x4f, 0xf8,\n    0x0, 0x0, 0x0, 0x0, 0x4f, 0xf8, 0x0, 0x0,\n    0x0, 0x0, 0x4f, 0xf8, 0x0, 0x0, 0x0, 0x0,\n    0x4f, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x4f, 0xf8,\n    0x0, 0x0, 0x0, 0x0, 0x4f, 0xf8, 0x0, 0x0,\n    0x0, 0x0, 0x4f, 0xfd, 0xbb, 0xbb, 0xbb, 0xbb,\n    0x4f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x4f, 0xff,\n    0xff, 0xff, 0xff, 0xff,\n\n    /* U+0046 \"F\" */\n    0x4f, 0xff, 0xff, 0xff, 0xff, 0xb4, 0xff, 0xff,\n    0xff, 0xff, 0xfb, 0x4f, 0xfd, 0xbb, 0xbb, 0xbb,\n    0x84, 0xff, 0x80, 0x0, 0x0, 0x0, 0x4f, 0xf8,\n    0x0, 0x0, 0x0, 0x4, 0xff, 0x80, 0x0, 0x0,\n    0x0, 0x4f, 0xf8, 0x0, 0x0, 0x0, 0x4, 0xff,\n    0x80, 0x0, 0x0, 0x0, 0x4f, 0xf8, 0x0, 0x0,\n    0x0, 0x4, 0xff, 0xff, 0xff, 0xff, 0xf9, 0x4f,\n    0xff, 0xff, 0xff, 0xff, 0x94, 0xff, 0xdb, 0xbb,\n    0xbb, 0xb6, 0x4f, 0xf8, 0x0, 0x0, 0x0, 0x4,\n    0xff, 0x80, 0x0, 0x0, 0x0, 0x4f, 0xf8, 0x0,\n    0x0, 0x0, 0x4, 0xff, 0x80, 0x0, 0x0, 0x0,\n    0x4f, 0xf8, 0x0, 0x0, 0x0, 0x4, 0xff, 0x80,\n    0x0, 0x0, 0x0, 0x4f, 0xf8, 0x0, 0x0, 0x0,\n    0x4, 0xff, 0x80, 0x0, 0x0, 0x0, 0x4f, 0xf8,\n    0x0, 0x0, 0x0, 0x4, 0xff, 0x80, 0x0, 0x0,\n    0x0,\n\n    /* U+004C \"L\" */\n    0x4f, 0xf8, 0x0, 0x0, 0x0, 0x4f, 0xf8, 0x0,\n    0x0, 0x0, 0x4f, 0xf8, 0x0, 0x0, 0x0, 0x4f,\n    0xf8, 0x0, 0x0, 0x0, 0x4f, 0xf8, 0x0, 0x0,\n    0x0, 0x4f, 0xf8, 0x0, 0x0, 0x0, 0x4f, 0xf8,\n    0x0, 0x0, 0x0, 0x4f, 0xf8, 0x0, 0x0, 0x0,\n    0x4f, 0xf8, 0x0, 0x0, 0x0, 0x4f, 0xf8, 0x0,\n    0x0, 0x0, 0x4f, 0xf8, 0x0, 0x0, 0x0, 0x4f,\n    0xf8, 0x0, 0x0, 0x0, 0x4f, 0xf8, 0x0, 0x0,\n    0x0, 0x4f, 0xf8, 0x0, 0x0, 0x0, 0x4f, 0xf8,\n    0x0, 0x0, 0x0, 0x4f, 0xf8, 0x0, 0x0, 0x0,\n    0x4f, 0xf8, 0x0, 0x0, 0x0, 0x4f, 0xf8, 0x0,\n    0x0, 0x0, 0x4f, 0xf8, 0x0, 0x0, 0x0, 0x4f,\n    0xfd, 0xbb, 0xbb, 0xba, 0x4f, 0xff, 0xff, 0xff,\n    0xfe, 0x4f, 0xff, 0xff, 0xff, 0xfe,\n\n    /* U+004D \"M\" */\n    0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0xb, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x83, 0x0,\n    0x0, 0x0, 0x2, 0xf4, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xf, 0x60, 0x0, 0x0, 0x0, 0x5f,\n    0xb0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xf9,\n    0x0, 0x0, 0x0, 0x8, 0xff, 0x20, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xef, 0xc0, 0x0, 0x0, 0x0,\n    0xbf, 0xf9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f,\n    0xff, 0x0, 0x0, 0x0, 0xe, 0xff, 0xf1, 0x0,\n    0x0, 0x0, 0x0, 0xc, 0xff, 0xf2, 0x0, 0x0,\n    0x1, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x3,\n    0xff, 0xff, 0x50, 0x0, 0x0, 0x4f, 0xff, 0xfe,\n    0x0, 0x0, 0x0, 0x0, 0xbf, 0xff, 0xf8, 0x0,\n    0x0, 0x7, 0xff, 0xaf, 0xf6, 0x0, 0x0, 0x0,\n    0x2f, 0xfb, 0xff, 0xb0, 0x0, 0x0, 0xaf, 0xf1,\n    0xff, 0xd0, 0x0, 0x0, 0x9, 0xff, 0x3d, 0xfe,\n    0x0, 0x0, 0xd, 0xfd, 0x8, 0xff, 0x50, 0x0,\n    0x1, 0xff, 0xc0, 0xaf, 0xf1, 0x0, 0x0, 0xff,\n    0xa0, 0x1f, 0xfc, 0x0, 0x0, 0x8f, 0xf4, 0x7,\n    0xff, 0x40, 0x0, 0x3f, 0xf7, 0x0, 0xaf, 0xf3,\n    0x0, 0xe, 0xfd, 0x0, 0x4f, 0xf7, 0x0, 0x6,\n    0xff, 0x40, 0x2, 0xff, 0xa0, 0x6, 0xff, 0x60,\n    0x1, 0xff, 0xa0, 0x0, 0x9f, 0xf1, 0x0, 0xb,\n    0xff, 0x20, 0xdf, 0xe0, 0x0, 0xe, 0xfd, 0x0,\n    0xc, 0xfe, 0x0, 0x0, 0x4f, 0xf9, 0x4f, 0xf7,\n    0x0, 0x0, 0xbf, 0xf0, 0x0, 0xff, 0xc0, 0x0,\n    0x0, 0xdf, 0xfc, 0xff, 0x10, 0x0, 0x8, 0xff,\n    0x30, 0x2f, 0xf9, 0x0, 0x0, 0x5, 0xff, 0xff,\n    0x90, 0x0, 0x0, 0x5f, 0xf6, 0x5, 0xff, 0x60,\n    0x0, 0x0, 0xe, 0xff, 0xf2, 0x0, 0x0, 0x3,\n    0xff, 0x90, 0x8f, 0xf3, 0x0, 0x0, 0x0, 0x7f,\n    0xfa, 0x0, 0x0, 0x0, 0xf, 0xfc, 0xb, 0xff,\n    0x0, 0x0, 0x0, 0x1, 0xff, 0x30, 0x0, 0x0,\n    0x0, 0xdf, 0xf0, 0xef, 0xd0, 0x0, 0x0, 0x0,\n    0x8, 0xc0, 0x0, 0x0, 0x0, 0xa, 0xff, 0x20,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x14, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0,\n\n    /* U+0050 \"P\" */\n    0x4f, 0xff, 0xff, 0xfd, 0x81, 0x0, 0x4, 0xff,\n    0xff, 0xff, 0xff, 0xf5, 0x0, 0x4f, 0xfd, 0xbb,\n    0xcf, 0xff, 0xf4, 0x4, 0xff, 0x80, 0x0, 0x1b,\n    0xff, 0xd0, 0x4f, 0xf8, 0x0, 0x0, 0xd, 0xff,\n    0x34, 0xff, 0x80, 0x0, 0x0, 0x8f, 0xf7, 0x4f,\n    0xf8, 0x0, 0x0, 0x6, 0xff, 0x84, 0xff, 0x80,\n    0x0, 0x0, 0x8f, 0xf7, 0x4f, 0xf8, 0x0, 0x0,\n    0xe, 0xff, 0x34, 0xff, 0x80, 0x0, 0x1b, 0xff,\n    0xd0, 0x4f, 0xfd, 0xbb, 0xcf, 0xff, 0xf4, 0x4,\n    0xff, 0xff, 0xff, 0xff, 0xf5, 0x0, 0x4f, 0xff,\n    0xff, 0xfd, 0x81, 0x0, 0x4, 0xff, 0x80, 0x0,\n    0x0, 0x0, 0x0, 0x4f, 0xf8, 0x0, 0x0, 0x0,\n    0x0, 0x4, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0,\n    0x4f, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff,\n    0x80, 0x0, 0x0, 0x0, 0x0, 0x4f, 0xf8, 0x0,\n    0x0, 0x0, 0x0, 0x4, 0xff, 0x80, 0x0, 0x0,\n    0x0, 0x0, 0x4f, 0xf8, 0x0, 0x0, 0x0, 0x0,\n    0x4, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+0054 \"T\" */\n    0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa, 0x3f,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xfa, 0x2b, 0xbb,\n    0xbc, 0xff, 0xeb, 0xbb, 0xb7, 0x0, 0x0, 0x2,\n    0xff, 0xa0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff,\n    0xa0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xa0,\n    0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xa0, 0x0,\n    0x0, 0x0, 0x0, 0x2, 0xff, 0xa0, 0x0, 0x0,\n    0x0, 0x0, 0x2, 0xff, 0xa0, 0x0, 0x0, 0x0,\n    0x0, 0x2, 0xff, 0xa0, 0x0, 0x0, 0x0, 0x0,\n    0x2, 0xff, 0xa0, 0x0, 0x0, 0x0, 0x0, 0x2,\n    0xff, 0xa0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff,\n    0xa0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xa0,\n    0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xa0, 0x0,\n    0x0, 0x0, 0x0, 0x2, 0xff, 0xa0, 0x0, 0x0,\n    0x0, 0x0, 0x2, 0xff, 0xa0, 0x0, 0x0, 0x0,\n    0x0, 0x2, 0xff, 0xa0, 0x0, 0x0, 0x0, 0x0,\n    0x2, 0xff, 0xa0, 0x0, 0x0, 0x0, 0x0, 0x2,\n    0xff, 0xa0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff,\n    0xa0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xff, 0xa0,\n    0x0, 0x0,\n\n    /* U+0055 \"U\" */\n    0x8f, 0xf4, 0x0, 0x0, 0x0, 0x0, 0xb, 0xff,\n    0x18, 0xff, 0x40, 0x0, 0x0, 0x0, 0x0, 0xbf,\n    0xf1, 0x8f, 0xf4, 0x0, 0x0, 0x0, 0x0, 0xb,\n    0xff, 0x18, 0xff, 0x40, 0x0, 0x0, 0x0, 0x0,\n    0xbf, 0xf1, 0x8f, 0xf4, 0x0, 0x0, 0x0, 0x0,\n    0xb, 0xff, 0x18, 0xff, 0x40, 0x0, 0x0, 0x0,\n    0x0, 0xbf, 0xf1, 0x8f, 0xf4, 0x0, 0x0, 0x0,\n    0x0, 0xb, 0xff, 0x18, 0xff, 0x40, 0x0, 0x0,\n    0x0, 0x0, 0xbf, 0xf1, 0x8f, 0xf4, 0x0, 0x0,\n    0x0, 0x0, 0xb, 0xff, 0x18, 0xff, 0x40, 0x0,\n    0x0, 0x0, 0x0, 0xbf, 0xf1, 0x8f, 0xf4, 0x0,\n    0x0, 0x0, 0x0, 0xb, 0xff, 0x18, 0xff, 0x40,\n    0x0, 0x0, 0x0, 0x0, 0xbf, 0xf1, 0x8f, 0xf4,\n    0x0, 0x0, 0x0, 0x0, 0xb, 0xff, 0x18, 0xff,\n    0x40, 0x0, 0x0, 0x0, 0x0, 0xbf, 0xf0, 0x7f,\n    0xf5, 0x0, 0x0, 0x0, 0x0, 0xc, 0xff, 0x6,\n    0xff, 0x70, 0x0, 0x0, 0x0, 0x0, 0xef, 0xe0,\n    0x2f, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xfb,\n    0x0, 0xdf, 0xf6, 0x0, 0x0, 0x0, 0xd, 0xff,\n    0x60, 0x5, 0xff, 0xf8, 0x10, 0x0, 0x3d, 0xff,\n    0xd0, 0x0, 0x8, 0xff, 0xff, 0xdc, 0xef, 0xff,\n    0xe2, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff,\n    0xd2, 0x0, 0x0, 0x0, 0x1, 0x8c, 0xef, 0xeb,\n    0x50, 0x0, 0x0,\n\n    /* U+0061 \"a\" */\n    0x0, 0x1, 0x8d, 0xff, 0xc7, 0xd, 0xfc, 0x0,\n    0x5f, 0xff, 0xff, 0xff, 0xde, 0xfc, 0x4, 0xff,\n    0xfe, 0xba, 0xdf, 0xff, 0xfc, 0xe, 0xff, 0x90,\n    0x0, 0x5, 0xff, 0xfc, 0x6f, 0xfb, 0x0, 0x0,\n    0x0, 0x5f, 0xfc, 0xbf, 0xf2, 0x0, 0x0, 0x0,\n    0xd, 0xfc, 0xdf, 0xf0, 0x0, 0x0, 0x0, 0x9,\n    0xfc, 0xdf, 0xf0, 0x0, 0x0, 0x0, 0x9, 0xfc,\n    0xbf, 0xf2, 0x0, 0x0, 0x0, 0xd, 0xfc, 0x6f,\n    0xfb, 0x0, 0x0, 0x0, 0x5f, 0xfc, 0xe, 0xff,\n    0x90, 0x0, 0x5, 0xff, 0xfc, 0x4, 0xff, 0xfe,\n    0xba, 0xdf, 0xff, 0xfc, 0x0, 0x4f, 0xff, 0xff,\n    0xff, 0xde, 0xfc, 0x0, 0x1, 0x8d, 0xff, 0xc7,\n    0xd, 0xfc,\n\n    /* U+0063 \"c\" */\n    0x0, 0x1, 0x7c, 0xff, 0xd9, 0x20, 0x4, 0xef,\n    0xff, 0xff, 0xfc, 0x3, 0xff, 0xfe, 0xa9, 0xbf,\n    0xc0, 0xef, 0xf9, 0x0, 0x0, 0x17, 0x6f, 0xfb,\n    0x0, 0x0, 0x0, 0xb, 0xff, 0x20, 0x0, 0x0,\n    0x0, 0xdf, 0xf0, 0x0, 0x0, 0x0, 0xd, 0xff,\n    0x0, 0x0, 0x0, 0x0, 0xbf, 0xf2, 0x0, 0x0,\n    0x0, 0x6, 0xff, 0xb0, 0x0, 0x0, 0x0, 0xe,\n    0xff, 0x90, 0x0, 0x1, 0x70, 0x3f, 0xff, 0xea,\n    0x9b, 0xfc, 0x0, 0x4e, 0xff, 0xff, 0xff, 0xc0,\n    0x0, 0x17, 0xcf, 0xfd, 0x92,\n\n    /* U+0064 \"d\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x32, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xe, 0xfc, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xe, 0xfc, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xe, 0xfc, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xe, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0xe, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe,\n    0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe, 0xfc,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xe, 0xfc, 0x0,\n    0x1, 0x8d, 0xff, 0xc6, 0xe, 0xfc, 0x0, 0x5f,\n    0xff, 0xff, 0xff, 0xcf, 0xfc, 0x4, 0xff, 0xfe,\n    0xba, 0xdf, 0xff, 0xfc, 0xe, 0xff, 0x90, 0x0,\n    0x5, 0xff, 0xfc, 0x6f, 0xfb, 0x0, 0x0, 0x0,\n    0x5f, 0xfc, 0xbf, 0xf2, 0x0, 0x0, 0x0, 0xd,\n    0xfc, 0xdf, 0xf0, 0x0, 0x0, 0x0, 0x9, 0xfc,\n    0xdf, 0xf0, 0x0, 0x0, 0x0, 0x9, 0xfc, 0xbf,\n    0xf2, 0x0, 0x0, 0x0, 0xd, 0xfc, 0x6f, 0xfb,\n    0x0, 0x0, 0x0, 0x5f, 0xfc, 0xe, 0xff, 0x90,\n    0x0, 0x5, 0xff, 0xfc, 0x4, 0xff, 0xfe, 0xba,\n    0xdf, 0xff, 0xfc, 0x0, 0x4f, 0xff, 0xff, 0xff,\n    0xde, 0xfc, 0x0, 0x1, 0x8d, 0xff, 0xc7, 0xd,\n    0xfc,\n\n    /* U+0065 \"e\" */\n    0x0, 0x2, 0x9e, 0xfe, 0xb4, 0x0, 0x0, 0x0,\n    0x6f, 0xff, 0xff, 0xff, 0xa0, 0x0, 0x5, 0xff,\n    0xfb, 0x8a, 0xef, 0xfa, 0x0, 0xe, 0xfe, 0x30,\n    0x0, 0x1c, 0xff, 0x40, 0x6f, 0xf4, 0x0, 0x0,\n    0x1, 0xff, 0xa0, 0xbf, 0xf4, 0x44, 0x44, 0x44,\n    0xdf, 0xe0, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xf0, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,\n    0xbf, 0xf1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6f,\n    0xf7, 0x0, 0x0, 0x0, 0x52, 0x0, 0xe, 0xff,\n    0x60, 0x0, 0x6, 0xff, 0x70, 0x4, 0xff, 0xfd,\n    0xaa, 0xdf, 0xff, 0x30, 0x0, 0x4f, 0xff, 0xff,\n    0xff, 0xe4, 0x0, 0x0, 0x1, 0x8d, 0xff, 0xd8,\n    0x10, 0x0,\n\n    /* U+0066 \"f\" */\n    0x0, 0x0, 0x2, 0x79, 0x71, 0x0, 0x0, 0x5f,\n    0xff, 0xf4, 0x0, 0x2, 0xff, 0xff, 0xf4, 0x0,\n    0x9, 0xff, 0x91, 0x10, 0x0, 0xc, 0xff, 0x0,\n    0x0, 0x0, 0xc, 0xfe, 0x0, 0x0, 0x0, 0xd,\n    0xfd, 0x0, 0x0, 0x0, 0xd, 0xfd, 0x0, 0x0,\n    0x0, 0xd, 0xfd, 0x0, 0x0, 0x4f, 0xff, 0xff,\n    0xff, 0xf4, 0x4f, 0xff, 0xff, 0xff, 0xf4, 0x16,\n    0x6e, 0xfe, 0x66, 0x61, 0x0, 0xd, 0xfd, 0x0,\n    0x0, 0x0, 0xd, 0xfd, 0x0, 0x0, 0x0, 0xd,\n    0xfd, 0x0, 0x0, 0x0, 0xd, 0xfd, 0x0, 0x0,\n    0x0, 0xd, 0xfd, 0x0, 0x0, 0x0, 0xd, 0xfd,\n    0x0, 0x0, 0x0, 0xd, 0xfd, 0x0, 0x0, 0x0,\n    0xd, 0xfd, 0x0, 0x0, 0x0, 0xd, 0xfd, 0x0,\n    0x0, 0x0, 0xd, 0xfd, 0x0, 0x0, 0x0, 0xd,\n    0xfd, 0x0, 0x0,\n\n    /* U+0067 \"g\" */\n    0x0, 0x1, 0x8d, 0xff, 0xc7, 0xc, 0xfc, 0x0,\n    0x4f, 0xff, 0xff, 0xff, 0xde, 0xfc, 0x4, 0xff,\n    0xff, 0xba, 0xdf, 0xff, 0xfc, 0xe, 0xff, 0xa0,\n    0x0, 0x5, 0xff, 0xfc, 0x6f, 0xfb, 0x0, 0x0,\n    0x0, 0x4f, 0xfc, 0xaf, 0xf3, 0x0, 0x0, 0x0,\n    0xc, 0xfc, 0xcf, 0xf0, 0x0, 0x0, 0x0, 0x9,\n    0xfc, 0xcf, 0xf0, 0x0, 0x0, 0x0, 0x9, 0xfc,\n    0xaf, 0xf3, 0x0, 0x0, 0x0, 0xc, 0xfc, 0x6f,\n    0xfb, 0x0, 0x0, 0x0, 0x4f, 0xfc, 0xe, 0xff,\n    0x90, 0x0, 0x4, 0xff, 0xfc, 0x3, 0xff, 0xff,\n    0xba, 0xdf, 0xff, 0xfc, 0x0, 0x4f, 0xff, 0xff,\n    0xff, 0xce, 0xfc, 0x0, 0x1, 0x8d, 0xff, 0xc6,\n    0xd, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe,\n    0xfb, 0x2b, 0xb5, 0x0, 0x0, 0x0, 0xf, 0xfa,\n    0x1f, 0xfc, 0x0, 0x0, 0x0, 0x6f, 0xf6, 0xa,\n    0xff, 0xa0, 0x0, 0x4, 0xff, 0xf1, 0x2, 0xef,\n    0xfe, 0xb9, 0xcf, 0xff, 0x60, 0x0, 0x3d, 0xff,\n    0xff, 0xff, 0xf7, 0x0, 0x0, 0x0, 0x7c, 0xff,\n    0xea, 0x30, 0x0,\n\n    /* U+0068 \"h\" */\n    0x23, 0x30, 0x0, 0x0, 0x0, 0x0, 0xcf, 0xe0,\n    0x0, 0x0, 0x0, 0x0, 0xcf, 0xe0, 0x0, 0x0,\n    0x0, 0x0, 0xcf, 0xe0, 0x0, 0x0, 0x0, 0x0,\n    0xcf, 0xe0, 0x0, 0x0, 0x0, 0x0, 0xcf, 0xe0,\n    0x0, 0x0, 0x0, 0x0, 0xcf, 0xe0, 0x0, 0x0,\n    0x0, 0x0, 0xcf, 0xe0, 0x0, 0x0, 0x0, 0x0,\n    0xcf, 0xe0, 0x0, 0x0, 0x0, 0x0, 0xcf, 0xe3,\n    0xae, 0xfd, 0x70, 0x0, 0xcf, 0xff, 0xff, 0xff,\n    0xfc, 0x0, 0xcf, 0xff, 0xea, 0xbf, 0xff, 0x90,\n    0xcf, 0xfb, 0x0, 0x2, 0xff, 0xf1, 0xcf, 0xf2,\n    0x0, 0x0, 0x8f, 0xf4, 0xcf, 0xe0, 0x0, 0x0,\n    0x4f, 0xf6, 0xcf, 0xe0, 0x0, 0x0, 0x3f, 0xf7,\n    0xcf, 0xe0, 0x0, 0x0, 0x3f, 0xf7, 0xcf, 0xe0,\n    0x0, 0x0, 0x3f, 0xf7, 0xcf, 0xe0, 0x0, 0x0,\n    0x3f, 0xf7, 0xcf, 0xe0, 0x0, 0x0, 0x3f, 0xf7,\n    0xcf, 0xe0, 0x0, 0x0, 0x3f, 0xf7, 0xcf, 0xe0,\n    0x0, 0x0, 0x3f, 0xf7, 0xcf, 0xe0, 0x0, 0x0,\n    0x3f, 0xf7,\n\n    /* U+0069 \"i\" */\n    0x6, 0xc7, 0x2, 0xff, 0xf4, 0x3f, 0xff, 0x50,\n    0x9f, 0xa0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc,\n    0xfe, 0x0, 0xcf, 0xe0, 0xc, 0xfe, 0x0, 0xcf,\n    0xe0, 0xc, 0xfe, 0x0, 0xcf, 0xe0, 0xc, 0xfe,\n    0x0, 0xcf, 0xe0, 0xc, 0xfe, 0x0, 0xcf, 0xe0,\n    0xc, 0xfe, 0x0, 0xcf, 0xe0, 0xc, 0xfe, 0x0,\n    0xcf, 0xe0,\n\n    /* U+006C \"l\" */\n    0x23, 0x3c, 0xfe, 0xcf, 0xec, 0xfe, 0xcf, 0xec,\n    0xfe, 0xcf, 0xec, 0xfe, 0xcf, 0xec, 0xfe, 0xcf,\n    0xec, 0xfe, 0xcf, 0xec, 0xfe, 0xcf, 0xec, 0xfe,\n    0xcf, 0xec, 0xfe, 0xcf, 0xec, 0xfe, 0xcf, 0xec,\n    0xfe, 0xcf, 0xe0,\n\n    /* U+006D \"m\" */\n    0xcf, 0xb5, 0xcf, 0xeb, 0x30, 0x3a, 0xef, 0xd8,\n    0x0, 0xc, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xff,\n    0xff, 0xfc, 0x0, 0xcf, 0xff, 0xca, 0xdf, 0xff,\n    0xff, 0xba, 0xff, 0xf9, 0xc, 0xff, 0x80, 0x0,\n    0xbf, 0xff, 0x40, 0x2, 0xff, 0xf1, 0xcf, 0xf0,\n    0x0, 0x4, 0xff, 0xc0, 0x0, 0x9, 0xff, 0x3c,\n    0xfe, 0x0, 0x0, 0x2f, 0xf9, 0x0, 0x0, 0x6f,\n    0xf4, 0xcf, 0xe0, 0x0, 0x1, 0xff, 0x90, 0x0,\n    0x6, 0xff, 0x4c, 0xfe, 0x0, 0x0, 0x1f, 0xf9,\n    0x0, 0x0, 0x6f, 0xf4, 0xcf, 0xe0, 0x0, 0x1,\n    0xff, 0x90, 0x0, 0x6, 0xff, 0x4c, 0xfe, 0x0,\n    0x0, 0x1f, 0xf9, 0x0, 0x0, 0x6f, 0xf4, 0xcf,\n    0xe0, 0x0, 0x1, 0xff, 0x90, 0x0, 0x6, 0xff,\n    0x4c, 0xfe, 0x0, 0x0, 0x1f, 0xf9, 0x0, 0x0,\n    0x6f, 0xf4, 0xcf, 0xe0, 0x0, 0x1, 0xff, 0x90,\n    0x0, 0x6, 0xff, 0x4c, 0xfe, 0x0, 0x0, 0x1f,\n    0xf9, 0x0, 0x0, 0x6f, 0xf4,\n\n    /* U+006E \"n\" */\n    0xcf, 0xb4, 0xbe, 0xfd, 0x70, 0x0, 0xcf, 0xff,\n    0xff, 0xff, 0xfc, 0x0, 0xcf, 0xff, 0xea, 0xbf,\n    0xff, 0x90, 0xcf, 0xfb, 0x0, 0x2, 0xff, 0xf1,\n    0xcf, 0xf2, 0x0, 0x0, 0x8f, 0xf4, 0xcf, 0xe0,\n    0x0, 0x0, 0x4f, 0xf6, 0xcf, 0xe0, 0x0, 0x0,\n    0x3f, 0xf7, 0xcf, 0xe0, 0x0, 0x0, 0x3f, 0xf7,\n    0xcf, 0xe0, 0x0, 0x0, 0x3f, 0xf7, 0xcf, 0xe0,\n    0x0, 0x0, 0x3f, 0xf7, 0xcf, 0xe0, 0x0, 0x0,\n    0x3f, 0xf7, 0xcf, 0xe0, 0x0, 0x0, 0x3f, 0xf7,\n    0xcf, 0xe0, 0x0, 0x0, 0x3f, 0xf7, 0xcf, 0xe0,\n    0x0, 0x0, 0x3f, 0xf7,\n\n    /* U+006F \"o\" */\n    0x0, 0x1, 0x7c, 0xff, 0xd9, 0x20, 0x0, 0x0,\n    0x4, 0xef, 0xff, 0xff, 0xff, 0x80, 0x0, 0x3,\n    0xff, 0xfe, 0xaa, 0xdf, 0xff, 0x90, 0x0, 0xef,\n    0xf9, 0x0, 0x0, 0x4f, 0xff, 0x40, 0x6f, 0xfa,\n    0x0, 0x0, 0x0, 0x5f, 0xfb, 0xb, 0xff, 0x20,\n    0x0, 0x0, 0x0, 0xdf, 0xf0, 0xdf, 0xf0, 0x0,\n    0x0, 0x0, 0x9, 0xff, 0x2d, 0xff, 0x0, 0x0,\n    0x0, 0x0, 0x9f, 0xf2, 0xbf, 0xf2, 0x0, 0x0,\n    0x0, 0xd, 0xff, 0x6, 0xff, 0xa0, 0x0, 0x0,\n    0x5, 0xff, 0xb0, 0xe, 0xff, 0x90, 0x0, 0x4,\n    0xff, 0xf4, 0x0, 0x3f, 0xff, 0xea, 0x9d, 0xff,\n    0xf8, 0x0, 0x0, 0x4e, 0xff, 0xff, 0xff, 0xf8,\n    0x0, 0x0, 0x0, 0x17, 0xcf, 0xfd, 0x92, 0x0,\n    0x0,\n\n    /* U+0070 \"p\" */\n    0xcf, 0xc0, 0x7c, 0xff, 0xd8, 0x10, 0x0, 0xcf,\n    0xed, 0xff, 0xff, 0xff, 0xf4, 0x0, 0xcf, 0xff,\n    0xfd, 0xab, 0xff, 0xff, 0x40, 0xcf, 0xff, 0x50,\n    0x0, 0xa, 0xff, 0xe0, 0xcf, 0xf4, 0x0, 0x0,\n    0x0, 0xbf, 0xf6, 0xcf, 0xc0, 0x0, 0x0, 0x0,\n    0x3f, 0xfa, 0xcf, 0x90, 0x0, 0x0, 0x0, 0xf,\n    0xfc, 0xcf, 0x90, 0x0, 0x0, 0x0, 0xf, 0xfc,\n    0xcf, 0xc0, 0x0, 0x0, 0x0, 0x3f, 0xfa, 0xcf,\n    0xf4, 0x0, 0x0, 0x0, 0xbf, 0xf6, 0xcf, 0xff,\n    0x40, 0x0, 0xa, 0xff, 0xe0, 0xcf, 0xff, 0xfd,\n    0xab, 0xff, 0xff, 0x40, 0xcf, 0xec, 0xff, 0xff,\n    0xff, 0xf4, 0x0, 0xcf, 0xe0, 0x6c, 0xff, 0xd8,\n    0x10, 0x0, 0xcf, 0xe0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xcf, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0xcf, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xcf,\n    0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xcf, 0xe0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xcf, 0xe0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xcf, 0xe0, 0x0, 0x0,\n    0x0, 0x0, 0x0,\n\n    /* U+0072 \"r\" */\n    0xcf, 0xb0, 0x8d, 0xf7, 0xcf, 0xdd, 0xff, 0xf7,\n    0xcf, 0xff, 0xfb, 0x94, 0xcf, 0xfe, 0x30, 0x0,\n    0xcf, 0xf5, 0x0, 0x0, 0xcf, 0xf0, 0x0, 0x0,\n    0xcf, 0xe0, 0x0, 0x0, 0xcf, 0xe0, 0x0, 0x0,\n    0xcf, 0xe0, 0x0, 0x0, 0xcf, 0xe0, 0x0, 0x0,\n    0xcf, 0xe0, 0x0, 0x0, 0xcf, 0xe0, 0x0, 0x0,\n    0xcf, 0xe0, 0x0, 0x0, 0xcf, 0xe0, 0x0, 0x0,\n\n    /* U+0073 \"s\" */\n    0x0, 0x8, 0xdf, 0xd7, 0x0, 0x0, 0xb, 0xff,\n    0xff, 0xfb, 0x0, 0x5, 0xff, 0xd7, 0xcf, 0xf4,\n    0x0, 0x8f, 0xf2, 0x0, 0x72, 0x0, 0x7, 0xff,\n    0x60, 0x0, 0x0, 0x0, 0x2f, 0xff, 0xb5, 0x0,\n    0x0, 0x0, 0x6f, 0xff, 0xfe, 0x50, 0x0, 0x0,\n    0x29, 0xff, 0xff, 0x50, 0x0, 0x0, 0x0, 0x6f,\n    0xfe, 0x0, 0x0, 0x0, 0x0, 0x8f, 0xf1, 0x8,\n    0xca, 0x0, 0xa, 0xff, 0x10, 0xaf, 0xfc, 0x7a,\n    0xff, 0xd0, 0x1, 0xdf, 0xff, 0xff, 0xf3, 0x0,\n    0x0, 0x8d, 0xfe, 0xa2, 0x0,\n\n    /* U+0074 \"t\" */\n    0x0, 0xb, 0xec, 0x0, 0x0, 0x0, 0xdf, 0xd0,\n    0x0, 0x0, 0xd, 0xfd, 0x0, 0x0, 0x0, 0xdf,\n    0xd0, 0x0, 0x0, 0xd, 0xfd, 0x0, 0x4, 0xff,\n    0xff, 0xff, 0xfb, 0x4f, 0xff, 0xff, 0xff, 0xb1,\n    0x66, 0xef, 0xe6, 0x64, 0x0, 0xd, 0xfd, 0x0,\n    0x0, 0x0, 0xdf, 0xd0, 0x0, 0x0, 0xd, 0xfd,\n    0x0, 0x0, 0x0, 0xdf, 0xd0, 0x0, 0x0, 0xd,\n    0xfd, 0x0, 0x0, 0x0, 0xdf, 0xd0, 0x0, 0x0,\n    0xd, 0xfd, 0x0, 0x0, 0x0, 0xdf, 0xd0, 0x0,\n    0x0, 0xd, 0xfd, 0x0, 0x0, 0x0, 0xdf, 0xd0,\n    0x0, 0x0, 0xd, 0xfd, 0x0, 0x0,\n\n    /* U+0075 \"u\" */\n    0xf, 0xfa, 0x0, 0x0, 0xa, 0xff, 0xf, 0xfa,\n    0x0, 0x0, 0xa, 0xff, 0xf, 0xfa, 0x0, 0x0,\n    0xa, 0xff, 0xf, 0xfa, 0x0, 0x0, 0xa, 0xff,\n    0xf, 0xfa, 0x0, 0x0, 0xa, 0xff, 0xf, 0xfa,\n    0x0, 0x0, 0xa, 0xff, 0xf, 0xfa, 0x0, 0x0,\n    0xa, 0xff, 0xf, 0xfa, 0x0, 0x0, 0xa, 0xff,\n    0xf, 0xfa, 0x0, 0x0, 0xb, 0xff, 0xe, 0xfd,\n    0x0, 0x0, 0xd, 0xfd, 0xa, 0xff, 0x70, 0x0,\n    0x7f, 0xfa, 0x3, 0xff, 0xfc, 0xac, 0xff, 0xf3,\n    0x0, 0x6f, 0xff, 0xff, 0xff, 0x50, 0x0, 0x3,\n    0xae, 0xfe, 0xa2, 0x0,\n\n    /* U+0076 \"v\" */\n    0x7f, 0xf5, 0x0, 0x0, 0x0, 0x3f, 0xf8, 0x1f,\n    0xfc, 0x0, 0x0, 0x0, 0xaf, 0xf1, 0x9, 0xff,\n    0x30, 0x0, 0x2, 0xff, 0xa0, 0x1, 0xff, 0xb0,\n    0x0, 0x9, 0xff, 0x20, 0x0, 0xaf, 0xf2, 0x0,\n    0x1f, 0xfb, 0x0, 0x0, 0x2f, 0xf9, 0x0, 0x8f,\n    0xf3, 0x0, 0x0, 0xb, 0xff, 0x10, 0xef, 0xc0,\n    0x0, 0x0, 0x4, 0xff, 0x86, 0xff, 0x50, 0x0,\n    0x0, 0x0, 0xcf, 0xed, 0xfd, 0x0, 0x0, 0x0,\n    0x0, 0x5f, 0xff, 0xf6, 0x0, 0x0, 0x0, 0x0,\n    0xd, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x6,\n    0xff, 0x70, 0x0, 0x0, 0x0, 0x0, 0x0, 0xef,\n    0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x78, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x11, 0x0, 0x0,\n    0x0,\n\n    /* U+0077 \"w\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x60, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x8f, 0xf4, 0x0, 0x0, 0x0,\n    0xe5, 0x0, 0x0, 0x0, 0xdf, 0xe0, 0x1f, 0xfb,\n    0x0, 0x0, 0x5, 0xfc, 0x0, 0x0, 0x4, 0xff,\n    0x70, 0xa, 0xff, 0x20, 0x0, 0xc, 0xff, 0x20,\n    0x0, 0xb, 0xff, 0x10, 0x4, 0xff, 0x80, 0x0,\n    0x3f, 0xff, 0x90, 0x0, 0x2f, 0xfa, 0x0, 0x0,\n    0xdf, 0xe0, 0x0, 0xaf, 0xff, 0xf1, 0x0, 0x9f,\n    0xf3, 0x0, 0x0, 0x6f, 0xf6, 0x1, 0xff, 0x8f,\n    0xf7, 0x0, 0xff, 0xc0, 0x0, 0x0, 0xe, 0xfd,\n    0x8, 0xff, 0xa, 0xfe, 0x7, 0xff, 0x50, 0x0,\n    0x0, 0x8, 0xff, 0x4e, 0xf9, 0x3, 0xff, 0x5d,\n    0xfe, 0x0, 0x0, 0x0, 0x1, 0xff, 0xef, 0xf2,\n    0x0, 0xcf, 0xef, 0xf7, 0x0, 0x0, 0x0, 0x0,\n    0xaf, 0xff, 0xb0, 0x0, 0x5f, 0xff, 0xf1, 0x0,\n    0x0, 0x0, 0x0, 0x3f, 0xff, 0x40, 0x0, 0xe,\n    0xff, 0xa0, 0x0, 0x0, 0x0, 0x0, 0xc, 0xfd,\n    0x0, 0x0, 0x7, 0xff, 0x30, 0x0, 0x0, 0x0,\n    0x0, 0x6, 0xf7, 0x0, 0x0, 0x1, 0xfc, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xd0, 0x0, 0x0,\n    0x0, 0x95, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x20, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0,\n\n    /* U+0079 \"y\" */\n    0x8f, 0xf6, 0x0, 0x0, 0x0, 0x1, 0xff, 0xc0,\n    0xe, 0xfe, 0x0, 0x0, 0x0, 0x8, 0xff, 0x40,\n    0x6, 0xff, 0x70, 0x0, 0x0, 0x1f, 0xfc, 0x0,\n    0x0, 0xdf, 0xe1, 0x0, 0x0, 0x8f, 0xf4, 0x0,\n    0x0, 0x5f, 0xf8, 0x0, 0x0, 0xef, 0xc0, 0x0,\n    0x0, 0xc, 0xff, 0x10, 0x7, 0xff, 0x40, 0x0,\n    0x0, 0x3, 0xff, 0xa0, 0xe, 0xfc, 0x0, 0x0,\n    0x0, 0x0, 0xaf, 0xf2, 0x7f, 0xf4, 0x0, 0x0,\n    0x0, 0x0, 0x2f, 0xfb, 0xef, 0xc0, 0x0, 0x0,\n    0x0, 0x0, 0x9, 0xff, 0xff, 0x50, 0x0, 0x0,\n    0x0, 0x0, 0x1, 0xff, 0xfd, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x9f, 0xf5, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xef, 0xd0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x6, 0xff, 0x50, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xe, 0xfd, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x6f, 0xf5, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xef, 0xd0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x6, 0xff, 0x50, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xd, 0xfd, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x6f, 0xf6, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xdf, 0xd0, 0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+007A \"z\" */\n    0x9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0x9,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0x40, 0x3, 0x66,\n    0x66, 0x66, 0xcf, 0xf9, 0x0, 0x0, 0x0, 0x0,\n    0x3, 0xff, 0xd0, 0x0, 0x0, 0x0, 0x0, 0xd,\n    0xff, 0x30, 0x0, 0x0, 0x0, 0x0, 0x9f, 0xf7,\n    0x0, 0x0, 0x0, 0x0, 0x5, 0xff, 0xc0, 0x0,\n    0x0, 0x0, 0x0, 0x1e, 0xff, 0x10, 0x0, 0x0,\n    0x0, 0x0, 0xbf, 0xf5, 0x0, 0x0, 0x0, 0x0,\n    0x6, 0xff, 0xa0, 0x0, 0x0, 0x0, 0x0, 0x2f,\n    0xfe, 0x10, 0x0, 0x0, 0x0, 0x0, 0xcf, 0xfa,\n    0x66, 0x66, 0x66, 0x60, 0x8, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xf0, 0x3f, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xf0,\n\n    /* U+00E1 \"\u00e1\" */\n    0x0, 0x0, 0x0, 0x0, 0xa, 0x10, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xaf, 0xc0, 0x0, 0x0, 0x0,\n    0x0, 0x7, 0xff, 0xb1, 0x0, 0x0, 0x0, 0x0,\n    0x4f, 0xf9, 0x0, 0x0, 0x0, 0x0, 0x0, 0xaf,\n    0x60, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x1, 0x8d, 0xff, 0xc7, 0xd, 0xfc,\n    0x0, 0x5f, 0xff, 0xff, 0xff, 0xde, 0xfc, 0x4,\n    0xff, 0xfe, 0xba, 0xdf, 0xff, 0xfc, 0xe, 0xff,\n    0x90, 0x0, 0x5, 0xff, 0xfc, 0x6f, 0xfb, 0x0,\n    0x0, 0x0, 0x5f, 0xfc, 0xbf, 0xf2, 0x0, 0x0,\n    0x0, 0xd, 0xfc, 0xdf, 0xf0, 0x0, 0x0, 0x0,\n    0x9, 0xfc, 0xdf, 0xf0, 0x0, 0x0, 0x0, 0x9,\n    0xfc, 0xbf, 0xf2, 0x0, 0x0, 0x0, 0xd, 0xfc,\n    0x6f, 0xfb, 0x0, 0x0, 0x0, 0x5f, 0xfc, 0xe,\n    0xff, 0x90, 0x0, 0x5, 0xff, 0xfc, 0x4, 0xff,\n    0xfe, 0xba, 0xdf, 0xff, 0xfc, 0x0, 0x4f, 0xff,\n    0xff, 0xff, 0xde, 0xfc, 0x0, 0x1, 0x8d, 0xff,\n    0xc7, 0xd, 0xfc,\n\n    /* U+00F3 \"\u00f3\" */\n    0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xb, 0xfb, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x8, 0xff, 0xa0, 0x0, 0x0, 0x0,\n    0x0, 0x5, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xbf, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x17, 0xcf,\n    0xfd, 0x92, 0x0, 0x0, 0x0, 0x4e, 0xff, 0xff,\n    0xff, 0xf8, 0x0, 0x0, 0x3f, 0xff, 0xea, 0xad,\n    0xff, 0xf9, 0x0, 0xe, 0xff, 0x90, 0x0, 0x4,\n    0xff, 0xf4, 0x6, 0xff, 0xa0, 0x0, 0x0, 0x5,\n    0xff, 0xb0, 0xbf, 0xf2, 0x0, 0x0, 0x0, 0xd,\n    0xff, 0xd, 0xff, 0x0, 0x0, 0x0, 0x0, 0x9f,\n    0xf2, 0xdf, 0xf0, 0x0, 0x0, 0x0, 0x9, 0xff,\n    0x2b, 0xff, 0x20, 0x0, 0x0, 0x0, 0xdf, 0xf0,\n    0x6f, 0xfa, 0x0, 0x0, 0x0, 0x5f, 0xfb, 0x0,\n    0xef, 0xf9, 0x0, 0x0, 0x4f, 0xff, 0x40, 0x3,\n    0xff, 0xfe, 0xa9, 0xdf, 0xff, 0x80, 0x0, 0x4,\n    0xef, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x1,\n    0x7c, 0xff, 0xd9, 0x20, 0x0, 0x0,\n\n    /* U+2026 \"\u2026\" */\n    0x1c, 0xf9, 0x0, 0x0, 0xa, 0xfa, 0x0, 0x0,\n    0x9, 0xfb, 0x17, 0xff, 0xf3, 0x0, 0x5, 0xff,\n    0xf5, 0x0, 0x3, 0xff, 0xf7, 0x7f, 0xff, 0x30,\n    0x0, 0x5f, 0xff, 0x50, 0x0, 0x3f, 0xff, 0x71,\n    0xcf, 0x90, 0x0, 0x0, 0xaf, 0xa0, 0x0, 0x0,\n    0x9f, 0xb1,\n\n    /* U+52FF \"\u52ff\" */\n    0x0, 0x0, 0x0, 0x6, 0xc9, 0x40, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xef, 0xf5, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6f, 0xfe,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xe, 0xff, 0x70, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x20, 0x0, 0x2, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xf1, 0x0, 0x0, 0xcf, 0xfd, 0xbb, 0xcf, 0xfe,\n    0xbb, 0xbe, 0xff, 0xbb, 0xbf, 0xff, 0x0, 0x0,\n    0x9f, 0xff, 0x10, 0x6, 0xff, 0x70, 0x0, 0xdf,\n    0xf0, 0x0, 0xef, 0xf0, 0x0, 0x5f, 0xff, 0x50,\n    0x0, 0xbf, 0xf2, 0x0, 0xf, 0xfd, 0x0, 0xf,\n    0xfe, 0x0, 0x3f, 0xff, 0xa0, 0x0, 0x1f, 0xfe,\n    0x0, 0x3, 0xff, 0xa0, 0x0, 0xff, 0xe0, 0xe,\n    0xff, 0xd0, 0x0, 0x7, 0xff, 0x80, 0x0, 0x7f,\n    0xf6, 0x0, 0xf, 0xfd, 0x0, 0x3f, 0xe1, 0x0,\n    0x0, 0xef, 0xf2, 0x0, 0xc, 0xff, 0x20, 0x1,\n    0xff, 0xc0, 0x0, 0x33, 0x0, 0x0, 0x8f, 0xfa,\n    0x0, 0x1, 0xff, 0xe0, 0x0, 0x2f, 0xfb, 0x0,\n    0x0, 0x0, 0x0, 0x4f, 0xff, 0x20, 0x0, 0x7f,\n    0xf9, 0x0, 0x3, 0xff, 0xa0, 0x0, 0x0, 0x0,\n    0x2e, 0xff, 0x80, 0x0, 0xd, 0xff, 0x30, 0x0,\n    0x4f, 0xf9, 0x0, 0x0, 0x0, 0x2e, 0xff, 0xc0,\n    0x0, 0x6, 0xff, 0xd0, 0x0, 0x5, 0xff, 0x90,\n    0x0, 0x0, 0x4f, 0xff, 0xd1, 0x0, 0x1, 0xef,\n    0xf5, 0x0, 0x0, 0x6f, 0xf8, 0x0, 0x0, 0x8f,\n    0xff, 0xd1, 0x0, 0x0, 0xbf, 0xfd, 0x0, 0x0,\n    0x7, 0xff, 0x70, 0x3, 0xdf, 0xff, 0xc1, 0x0,\n    0x0, 0x7f, 0xff, 0x30, 0x0, 0x0, 0x8f, 0xf6,\n    0x0, 0x7f, 0xff, 0xa0, 0x0, 0x0, 0x7f, 0xff,\n    0x80, 0x0, 0x0, 0x9, 0xff, 0x50, 0x0, 0x9f,\n    0x60, 0x0, 0x0, 0x7f, 0xff, 0xb0, 0x0, 0x0,\n    0x0, 0xdf, 0xf3, 0x0, 0x0, 0x10, 0x0, 0x0,\n    0xaf, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x5f, 0xff,\n    0x10, 0x0, 0x0, 0x0, 0x3, 0xdf, 0xff, 0xb0,\n    0xb, 0xaa, 0xaa, 0xdf, 0xff, 0xc0, 0x0, 0x0,\n    0x0, 0x7, 0xff, 0xff, 0xa0, 0x0, 0xef, 0xff,\n    0xff, 0xff, 0xf5, 0x0, 0x0, 0x0, 0x0, 0x2e,\n    0xff, 0x60, 0x0, 0xb, 0xff, 0xff, 0xff, 0xc4,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x3c, 0x20, 0x0,\n    0x0, 0x24, 0x43, 0x32, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+5347 \"\u5347\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xaf,\n    0xf7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x2, 0x44, 0x0, 0xaf, 0xf7, 0x0,\n    0x0, 0x0, 0x0, 0x12, 0x34, 0x57, 0x8a, 0xce,\n    0xff, 0xfd, 0x0, 0xaf, 0xf7, 0x0, 0x0, 0x0,\n    0x5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x10, 0xaf, 0xf7, 0x0, 0x0, 0x0, 0x3, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xed, 0xb9, 0x20, 0xaf,\n    0xf7, 0x0, 0x0, 0x0, 0x0, 0xcb, 0xa8, 0x7d,\n    0xff, 0x70, 0x0, 0x0, 0x0, 0xaf, 0xf7, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xb, 0xff, 0x60,\n    0x0, 0x0, 0x0, 0xaf, 0xf7, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xb, 0xff, 0x60, 0x0, 0x0,\n    0x0, 0xaf, 0xf7, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xb, 0xff, 0x60, 0x0, 0x0, 0x0, 0xaf,\n    0xf7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xb,\n    0xff, 0x60, 0x0, 0x0, 0x0, 0xaf, 0xf7, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xb, 0xff, 0x60,\n    0x0, 0x0, 0x0, 0xaf, 0xf7, 0x0, 0x0, 0x0,\n    0x1c, 0xcc, 0xcc, 0xce, 0xff, 0xdc, 0xcc, 0xcc,\n    0xcc, 0xef, 0xfe, 0xcc, 0xcc, 0xc1, 0x2f, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xf2, 0x2f, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xf2, 0x0, 0x0, 0x0, 0xc, 0xff, 0x60,\n    0x0, 0x0, 0x0, 0xaf, 0xf7, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xe, 0xff, 0x40, 0x0, 0x0,\n    0x0, 0xaf, 0xf7, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xf, 0xff, 0x20, 0x0, 0x0, 0x0, 0xaf,\n    0xf7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4f,\n    0xff, 0x0, 0x0, 0x0, 0x0, 0xaf, 0xf7, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x9f, 0xfc, 0x0,\n    0x0, 0x0, 0x0, 0xaf, 0xf7, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x1, 0xff, 0xf7, 0x0, 0x0, 0x0,\n    0x0, 0xaf, 0xf7, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0xa, 0xff, 0xf1, 0x0, 0x0, 0x0, 0x0, 0xaf,\n    0xf7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8f, 0xff,\n    0x70, 0x0, 0x0, 0x0, 0x0, 0xaf, 0xf7, 0x0,\n    0x0, 0x0, 0x0, 0xa, 0xff, 0xfc, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xaf, 0xf7, 0x0, 0x0, 0x0,\n    0x2, 0xdf, 0xff, 0xd1, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xaf, 0xf7, 0x0, 0x0, 0x0, 0x5, 0xff,\n    0xfc, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xaf,\n    0xf7, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x90, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xaf, 0xf7, 0x0,\n    0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+542F \"\u542f\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3b, 0xce,\n    0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x2f, 0xff, 0x60, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0xd, 0xff, 0xa0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0xd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xfd, 0x0, 0xd, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xfd, 0x0, 0xd, 0xff, 0x98, 0x88, 0x88, 0x88,\n    0x88, 0x88, 0x88, 0x88, 0x9f, 0xfd, 0x0, 0xd,\n    0xff, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x2f, 0xfd, 0x0, 0xd, 0xff, 0x10, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2f, 0xfd,\n    0x0, 0xd, 0xff, 0x10, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x2f, 0xfd, 0x0, 0xd, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xfd, 0x0, 0xd, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0x0,\n    0xd, 0xff, 0xa9, 0x99, 0x99, 0x99, 0x99, 0x99,\n    0x99, 0x99, 0x99, 0x97, 0x0, 0xd, 0xff, 0x10,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xd, 0xff, 0x10, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe,\n    0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0x3, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9,\n    0x0, 0x1f, 0xfe, 0x3, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xf9, 0x0, 0x2f, 0xfc,\n    0x3, 0xff, 0xd7, 0x77, 0x77, 0x77, 0x77, 0x77,\n    0xaf, 0xf9, 0x0, 0x5f, 0xf9, 0x3, 0xff, 0xb0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0xf9, 0x0,\n    0x9f, 0xf6, 0x3, 0xff, 0xb0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x5f, 0xf9, 0x0, 0xef, 0xf2, 0x3,\n    0xff, 0xb0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f,\n    0xf9, 0x5, 0xff, 0xd0, 0x3, 0xff, 0xb0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x5f, 0xf9, 0xd, 0xff,\n    0x70, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xf9, 0x5f, 0xff, 0x10, 0x3, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9,\n    0xc, 0xf9, 0x0, 0x3, 0xff, 0xd8, 0x88, 0x88,\n    0x88, 0x88, 0x88, 0xbf, 0xf9, 0x1, 0xc1, 0x0,\n    0x3, 0xff, 0xb0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x5f, 0xf9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+5728 \"\u5728\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xbf, 0xe6, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x1, 0xff, 0xf2, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff,\n    0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x2, 0xaa, 0xaa, 0xaa, 0xae, 0xff, 0xda, 0xaa,\n    0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa1, 0x3, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xf2, 0x3, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xf2, 0x0, 0x0, 0x0, 0x6, 0xff, 0xe1,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xe, 0xff, 0x60, 0x0, 0x0,\n    0x47, 0x72, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x9f, 0xfd, 0x0, 0x0, 0x0, 0xaf, 0xf5,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5, 0xff,\n    0xf3, 0x0, 0x0, 0x0, 0xaf, 0xf5, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x2f, 0xff, 0x80, 0x0,\n    0x0, 0x0, 0xaf, 0xf5, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x1, 0xdf, 0xfd, 0x0, 0x0, 0x0, 0x0,\n    0xaf, 0xf5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1d,\n    0xff, 0xfc, 0x0, 0x99, 0x99, 0x99, 0xdf, 0xfb,\n    0x99, 0x99, 0x97, 0x0, 0x1, 0xdf, 0xff, 0xfc,\n    0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xfc, 0x0, 0x1d, 0xff, 0xff, 0xfc, 0x1, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0,\n    0x1f, 0xff, 0x7f, 0xfc, 0x0, 0x0, 0x0, 0x0,\n    0xaf, 0xf5, 0x0, 0x0, 0x0, 0x0, 0xa, 0xf5,\n    0x2f, 0xfc, 0x0, 0x0, 0x0, 0x0, 0xaf, 0xf5,\n    0x0, 0x0, 0x0, 0x0, 0x3, 0x40, 0x2f, 0xfc,\n    0x0, 0x0, 0x0, 0x0, 0xaf, 0xf5, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x2f, 0xfc, 0x0, 0x0,\n    0x0, 0x0, 0xaf, 0xf5, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x2f, 0xfc, 0x0, 0x0, 0x0, 0x0,\n    0xaf, 0xf5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x2f, 0xfc, 0x0, 0x0, 0x0, 0x0, 0xaf, 0xf5,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2f, 0xfc,\n    0x0, 0x0, 0x0, 0x0, 0xaf, 0xf5, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x2f, 0xfc, 0x4f, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1,\n    0x0, 0x0, 0x2f, 0xfc, 0x4f, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xf2, 0x0, 0x0,\n    0x2f, 0xfc, 0x2b, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,\n    0xbb, 0xbb, 0xbb, 0xb1, 0x0, 0x0, 0x2f, 0xfc,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0,\n\n    /* U+5B8C \"\u5b8c\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x4d, 0xef, 0x20, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x1, 0xff, 0xf7, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0xff,\n    0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xfc, 0x0, 0x3f, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xc0, 0x3, 0xff, 0xe9, 0x99, 0x99, 0x99, 0x99,\n    0x99, 0x99, 0x99, 0x99, 0xaf, 0xfc, 0x0, 0x3f,\n    0xfb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x2, 0xff, 0xc0, 0x3, 0xff, 0xb0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2f,\n    0xfc, 0x0, 0x2a, 0xa7, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x2, 0xaa, 0x80, 0x0,\n    0x0, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xf3, 0x0, 0x0, 0x0, 0x9, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x30, 0x0, 0x0, 0x0, 0x59, 0x99, 0x99, 0x99,\n    0x99, 0x99, 0x99, 0x99, 0x99, 0x91, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x79, 0x99, 0x99, 0x99, 0x99,\n    0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x92,\n    0xc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0x40, 0xcf, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xf4, 0x0, 0x0, 0x0, 0x0, 0xef,\n    0xf2, 0x0, 0xe, 0xff, 0x30, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0x0, 0x0,\n    0xef, 0xf2, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0,\n    0x0, 0x6, 0xff, 0xd0, 0x0, 0xe, 0xff, 0x20,\n    0x0, 0x0, 0xec, 0x70, 0x0, 0x0, 0x1, 0xef,\n    0xf8, 0x0, 0x0, 0xef, 0xf2, 0x0, 0x0, 0x1f,\n    0xfd, 0x0, 0x0, 0x2, 0xdf, 0xff, 0x10, 0x0,\n    0xe, 0xff, 0x30, 0x0, 0x3, 0xff, 0xa0, 0x0,\n    0x3a, 0xff, 0xff, 0x70, 0x0, 0x0, 0xcf, 0xf8,\n    0x0, 0x0, 0xaf, 0xf7, 0x8, 0xdf, 0xff, 0xff,\n    0x70, 0x0, 0x0, 0xa, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0x30, 0xaf, 0xff, 0xfb, 0x20, 0x0, 0x0,\n    0x0, 0x2e, 0xff, 0xff, 0xff, 0xff, 0xa0, 0x1,\n    0xef, 0xa3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x17,\n    0x9a, 0xaa, 0x98, 0x40, 0x0, 0x2, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0,\n\n    /* U+5DF2 \"\u5df2\" */\n    0x6b, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,\n    0xbb, 0xbb, 0xbb, 0x10, 0x0, 0x9f, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x10, 0x0, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0x10, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0xf, 0xff, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0x10,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xf, 0xff, 0x10, 0x0, 0x8, 0x99,\n    0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf,\n    0xff, 0x10, 0x0, 0xe, 0xff, 0x30, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0x10, 0x0,\n    0xe, 0xff, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xf, 0xff, 0x10, 0x0, 0xe, 0xff, 0x40,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff,\n    0x10, 0x0, 0xe, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0x10, 0x0, 0xe,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0x10, 0x0, 0xe, 0xff, 0xcb, 0xbb,\n    0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0x10,\n    0x0, 0xe, 0xff, 0x30, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe, 0xff,\n    0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xe, 0xff, 0x30, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x30, 0x0,\n    0xe, 0xff, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x1, 0xff, 0xa0, 0xe, 0xff, 0x30,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3,\n    0xff, 0xd0, 0xe, 0xff, 0x30, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x6, 0xff, 0xb0, 0xe,\n    0xff, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xa, 0xff, 0x80, 0xd, 0xff, 0xa0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4f, 0xff,\n    0x50, 0x9, 0xff, 0xfe, 0xbb, 0xbb, 0xbb, 0xbb,\n    0xbb, 0xbb, 0xbd, 0xff, 0xff, 0x0, 0x2, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xf7, 0x0, 0x0, 0x2a, 0xef, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x60, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+6210 \"\u6210\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xb,\n    0xee, 0x0, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0xff, 0x1,\n    0xbf, 0xd2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xc, 0xff, 0x10, 0xaf, 0xff,\n    0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xc, 0xff, 0x10, 0x8, 0xff, 0xc0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc,\n    0xff, 0x20, 0x0, 0x69, 0x10, 0x0, 0x0, 0xd,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xf0, 0x0, 0xd, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xf0, 0x0, 0xd, 0xff, 0x99, 0x99, 0x99,\n    0x99, 0x9d, 0xff, 0xa9, 0x99, 0x99, 0x99, 0x90,\n    0x0, 0xd, 0xff, 0x0, 0x0, 0x0, 0x0, 0x9,\n    0xff, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0xd,\n    0xff, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0x60,\n    0x0, 0x6, 0x10, 0x0, 0x0, 0xd, 0xff, 0x0,\n    0x0, 0x0, 0x0, 0x6, 0xff, 0x70, 0x0, 0x6f,\n    0xf7, 0x0, 0x0, 0xd, 0xff, 0xff, 0xff, 0xff,\n    0xf4, 0x5, 0xff, 0x90, 0x0, 0xdf, 0xf4, 0x0,\n    0x0, 0xd, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x3,\n    0xff, 0xb0, 0x6, 0xff, 0xb0, 0x0, 0x0, 0xd,\n    0xff, 0x99, 0x99, 0xdf, 0xf3, 0x1, 0xff, 0xd0,\n    0xe, 0xff, 0x30, 0x0, 0x0, 0xd, 0xff, 0x0,\n    0x0, 0x9f, 0xf2, 0x0, 0xef, 0xf0, 0x8f, 0xfa,\n    0x0, 0x0, 0x0, 0xe, 0xff, 0x0, 0x0, 0xaf,\n    0xf2, 0x0, 0xbf, 0xf5, 0xff, 0xf2, 0x0, 0x0,\n    0x0, 0xf, 0xfe, 0x0, 0x0, 0xaf, 0xf1, 0x0,\n    0x8f, 0xff, 0xff, 0x70, 0x0, 0x0, 0x0, 0xf,\n    0xfd, 0x0, 0x0, 0xbf, 0xf1, 0x0, 0x4f, 0xff,\n    0xfd, 0x0, 0x0, 0x0, 0x0, 0x2f, 0xfb, 0x0,\n    0x0, 0xcf, 0xf0, 0x0, 0xf, 0xff, 0xf2, 0x0,\n    0x3a, 0x40, 0x0, 0x5f, 0xf9, 0x0, 0x4, 0xff,\n    0xe0, 0x0, 0x5f, 0xff, 0x90, 0x0, 0x6f, 0xf2,\n    0x0, 0xaf, 0xf5, 0x9f, 0xff, 0xff, 0xa0, 0x6,\n    0xff, 0xff, 0xd0, 0x0, 0x9f, 0xf0, 0x0, 0xef,\n    0xf1, 0x7f, 0xff, 0xff, 0x30, 0x8f, 0xff, 0xff,\n    0xf5, 0x0, 0xdf, 0xd0, 0x5, 0xff, 0xc0, 0x3b,\n    0xba, 0x81, 0x1b, 0xff, 0xf8, 0x8f, 0xff, 0x56,\n    0xff, 0xa0, 0xd, 0xff, 0x60, 0x0, 0x0, 0x3,\n    0xef, 0xff, 0x70, 0xe, 0xff, 0xff, 0xff, 0x50,\n    0x2f, 0xff, 0x0, 0x0, 0x0, 0x1, 0xdf, 0xe4,\n    0x0, 0x3, 0xef, 0xff, 0xfd, 0x0, 0x2, 0xc8,\n    0x0, 0x0, 0x0, 0x0, 0x2b, 0x20, 0x0, 0x0,\n    0x1a, 0xef, 0xa1, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0,\n\n    /* U+65AD \"\u65ad\" */\n    0x0, 0x0, 0x0, 0x0, 0xcd, 0x50, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x22, 0x1, 0xdd, 0x60,\n    0x0, 0xe, 0xf6, 0x0, 0x0, 0x0, 0x24, 0x57,\n    0xad, 0xff, 0xa0, 0x1f, 0xf8, 0x8d, 0x0, 0xef,\n    0x60, 0x4c, 0x49, 0xff, 0xff, 0xff, 0xff, 0xfe,\n    0x1, 0xff, 0x8a, 0xf5, 0xe, 0xf6, 0xb, 0xf4,\n    0xaf, 0xff, 0xff, 0xff, 0xdb, 0x91, 0x1f, 0xf8,\n    0x4f, 0xc0, 0xef, 0x62, 0xfd, 0xa, 0xff, 0x75,\n    0x31, 0x0, 0x0, 0x1, 0xff, 0x80, 0xef, 0x2e,\n    0xf6, 0x9f, 0x60, 0xaf, 0xf1, 0x0, 0x0, 0x0,\n    0x0, 0x1f, 0xf8, 0x8, 0xf6, 0xef, 0x7f, 0xf0,\n    0xa, 0xff, 0x10, 0x0, 0x0, 0x0, 0x1, 0xff,\n    0x80, 0x12, 0xe, 0xf6, 0x24, 0x0, 0xaf, 0xf1,\n    0x0, 0x0, 0x0, 0x0, 0x1f, 0xf8, 0x0, 0x0,\n    0xef, 0x60, 0x0, 0xa, 0xff, 0x10, 0x0, 0x0,\n    0x0, 0x1, 0xff, 0x8a, 0xff, 0xff, 0xff, 0xff,\n    0xf1, 0xaf, 0xfd, 0xdd, 0xdd, 0xdd, 0xd3, 0x1f,\n    0xf8, 0xaf, 0xff, 0xff, 0xff, 0xff, 0x1a, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0x41, 0xff, 0x84, 0x77,\n    0xaf, 0xfa, 0x77, 0x70, 0xaf, 0xfd, 0xdd, 0xff,\n    0xfd, 0xd3, 0x1f, 0xf8, 0x0, 0xd, 0xff, 0x60,\n    0x0, 0xa, 0xff, 0x10, 0xc, 0xfe, 0x0, 0x1,\n    0xff, 0x80, 0x7, 0xff, 0xfa, 0xa0, 0x0, 0xaf,\n    0xf1, 0x0, 0xcf, 0xe0, 0x0, 0x1f, 0xf8, 0x2,\n    0xff, 0xff, 0xff, 0xb0, 0xa, 0xff, 0x0, 0xc,\n    0xfe, 0x0, 0x1, 0xff, 0x80, 0xdf, 0xae, 0xfc,\n    0xff, 0xb0, 0xaf, 0xf0, 0x0, 0xcf, 0xe0, 0x0,\n    0x1f, 0xf9, 0xbf, 0xf1, 0xef, 0x66, 0xff, 0x9b,\n    0xff, 0x0, 0xc, 0xfe, 0x0, 0x1, 0xff, 0xbf,\n    0xf6, 0xe, 0xf6, 0x7, 0xc1, 0xcf, 0xe0, 0x0,\n    0xcf, 0xe0, 0x0, 0x1f, 0xf8, 0xda, 0x0, 0xef,\n    0x60, 0x0, 0xe, 0xfd, 0x0, 0xc, 0xfe, 0x0,\n    0x1, 0xff, 0x84, 0x0, 0xe, 0xf6, 0x0, 0x0,\n    0xff, 0xb0, 0x0, 0xcf, 0xe0, 0x0, 0x1f, 0xf8,\n    0x0, 0x0, 0xef, 0x60, 0x0, 0x4f, 0xf8, 0x0,\n    0xc, 0xfe, 0x0, 0x1, 0xff, 0x80, 0x0, 0x2,\n    0x21, 0x0, 0x9, 0xff, 0x40, 0x0, 0xcf, 0xe0,\n    0x0, 0x1f, 0xfc, 0x99, 0x99, 0x99, 0x99, 0x90,\n    0xef, 0xe0, 0x0, 0xc, 0xfe, 0x0, 0x1, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xf9, 0x0,\n    0x0, 0xcf, 0xe0, 0x0, 0x1f, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xfe, 0xff, 0x20, 0x0, 0xc, 0xfe,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x3d, 0xa0, 0x0, 0x0, 0xcf, 0xe0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+6B63 \"\u6b63\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xcf,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x10, 0x0, 0xcf, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0x10, 0x0, 0x9c, 0xcc, 0xcc, 0xcc, 0xcc,\n    0xcc, 0xff, 0xfc, 0xcc, 0xcc, 0xcc, 0xcc, 0x10,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xff,\n    0xf1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xf1, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x1, 0xff, 0xf1, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x9, 0x99, 0x0, 0x0,\n    0x1, 0xff, 0xf1, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x1f, 0xff, 0x0, 0x0, 0x1, 0xff,\n    0xf1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x1f, 0xff, 0x0, 0x0, 0x1, 0xff, 0xf1, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff,\n    0x0, 0x0, 0x1, 0xff, 0xfb, 0xaa, 0xaa, 0xaa,\n    0xa1, 0x0, 0x0, 0x0, 0x1f, 0xff, 0x0, 0x0,\n    0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf2, 0x0,\n    0x0, 0x0, 0x1f, 0xff, 0x0, 0x0, 0x1, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xf2, 0x0, 0x0, 0x0,\n    0x1f, 0xff, 0x0, 0x0, 0x1, 0xff, 0xf2, 0x11,\n    0x11, 0x11, 0x10, 0x0, 0x0, 0x0, 0x1f, 0xff,\n    0x0, 0x0, 0x1, 0xff, 0xf1, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0x0, 0x0,\n    0x1, 0xff, 0xf1, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x1f, 0xff, 0x0, 0x0, 0x1, 0xff,\n    0xf1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x1f, 0xff, 0x0, 0x0, 0x1, 0xff, 0xf1, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff,\n    0x0, 0x0, 0x1, 0xff, 0xf1, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0x0, 0x0,\n    0x1, 0xff, 0xf1, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x1f, 0xff, 0x0, 0x0, 0x1, 0xff,\n    0xf1, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe, 0xee,\n    0xef, 0xff, 0xee, 0xee, 0xee, 0xff, 0xfe, 0xee,\n    0xee, 0xee, 0xee, 0xe0, 0xf, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xf0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,\n\n    /* U+7535 \"\u7535\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xfc, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x3, 0xff, 0xc0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x3f, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xaa, 0xaa, 0xaa, 0xaa, 0xab, 0xff, 0xea,\n    0xaa, 0xaa, 0xaa, 0xaa, 0x60, 0x0, 0xf, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xf9, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x90,\n    0x0, 0xf, 0xfe, 0x0, 0x0, 0x0, 0x3f, 0xfc,\n    0x0, 0x0, 0x0, 0x6f, 0xf9, 0x0, 0x0, 0xff,\n    0xe0, 0x0, 0x0, 0x3, 0xff, 0xc0, 0x0, 0x0,\n    0x6, 0xff, 0x90, 0x0, 0xf, 0xfe, 0x0, 0x0,\n    0x0, 0x3f, 0xfc, 0x0, 0x0, 0x0, 0x6f, 0xf9,\n    0x0, 0x0, 0xff, 0xe0, 0x0, 0x0, 0x4, 0xff,\n    0xc0, 0x0, 0x0, 0x6, 0xff, 0x90, 0x0, 0xf,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xf9, 0x0, 0x0, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x90, 0x0, 0xf, 0xff, 0x99, 0x99, 0x99, 0xaf,\n    0xfe, 0x99, 0x99, 0x99, 0xbf, 0xf9, 0x0, 0x0,\n    0xff, 0xe0, 0x0, 0x0, 0x3, 0xff, 0xc0, 0x0,\n    0x0, 0x6, 0xff, 0x90, 0x0, 0xf, 0xfe, 0x0,\n    0x0, 0x0, 0x3f, 0xfc, 0x0, 0x0, 0x0, 0x6f,\n    0xf9, 0x0, 0x0, 0xff, 0xe0, 0x0, 0x0, 0x3,\n    0xff, 0xc0, 0x0, 0x0, 0x6, 0xff, 0x90, 0x0,\n    0xf, 0xff, 0xbb, 0xbb, 0xbb, 0xcf, 0xff, 0xbb,\n    0xbb, 0xbb, 0xdf, 0xf9, 0x0, 0x0, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xa0, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd8,\n    0x30, 0xff, 0xe0, 0x0, 0x0, 0x3, 0xff, 0xc0,\n    0x0, 0x0, 0x0, 0x0, 0x9f, 0xf7, 0xe, 0xec,\n    0x0, 0x0, 0x0, 0x3f, 0xfc, 0x0, 0x0, 0x0,\n    0x0, 0xc, 0xff, 0x40, 0x0, 0x0, 0x0, 0x0,\n    0x3, 0xff, 0xd0, 0x0, 0x0, 0x0, 0x0, 0xff,\n    0xf1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2f, 0xff,\n    0x71, 0x0, 0x0, 0x2, 0xaf, 0xfd, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xef, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x70, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2,\n    0x79, 0xaa, 0xaa, 0xaa, 0x98, 0x50, 0x0,\n\n    /* U+7EA7 \"\u7ea7\" */\n    0x0, 0x0, 0xc, 0x83, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x7f, 0xfc, 0x0, 0x8a, 0xaa, 0xaa, 0xaa, 0xaa,\n    0xaa, 0xa9, 0x0, 0x0, 0x0, 0x0, 0xef, 0xf3,\n    0x0, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x0, 0x0, 0x0, 0x5, 0xff, 0xa0, 0x0, 0xdf,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0,\n    0x0, 0xd, 0xff, 0x20, 0x0, 0x0, 0xbf, 0xf2,\n    0x0, 0x0, 0x2f, 0xfd, 0x0, 0x0, 0x0, 0x7f,\n    0xf8, 0x0, 0x71, 0x0, 0xbf, 0xf1, 0x0, 0x0,\n    0x9f, 0xf4, 0x0, 0x0, 0x1, 0xef, 0xd0, 0x5,\n    0xff, 0x70, 0xbf, 0xf1, 0x0, 0x2, 0xff, 0xc0,\n    0x0, 0x0, 0xa, 0xff, 0x40, 0xd, 0xff, 0x30,\n    0xbf, 0xf0, 0x0, 0xa, 0xff, 0x40, 0x0, 0x0,\n    0x5f, 0xff, 0xbc, 0xdf, 0xf9, 0x0, 0xcf, 0xf3,\n    0x0, 0x2f, 0xfc, 0x0, 0x0, 0x0, 0x3f, 0xff,\n    0xff, 0xff, 0xd0, 0x0, 0xcf, 0xf9, 0x0, 0x6f,\n    0xff, 0xff, 0xfe, 0x0, 0xd, 0xed, 0xbf, 0xff,\n    0x40, 0x0, 0xdf, 0xfe, 0x0, 0x6f, 0xff, 0xff,\n    0xfe, 0x0, 0x0, 0x0, 0x6f, 0xf8, 0x0, 0x0,\n    0xff, 0xff, 0x50, 0x39, 0x99, 0xaf, 0xfe, 0x0,\n    0x0, 0x2, 0xff, 0xc0, 0x0, 0x0, 0xff, 0xff,\n    0xc0, 0x0, 0x0, 0x5f, 0xf9, 0x0, 0x0, 0xd,\n    0xff, 0x20, 0x0, 0x2, 0xff, 0xff, 0xf3, 0x0,\n    0x0, 0xbf, 0xf4, 0x0, 0x0, 0xbf, 0xf6, 0x0,\n    0x0, 0x4, 0xff, 0x8e, 0xfc, 0x0, 0x2, 0xff,\n    0xd0, 0x0, 0xa, 0xff, 0xfb, 0xce, 0xf6, 0x7,\n    0xff, 0x57, 0xff, 0x50, 0xa, 0xff, 0x60, 0x0,\n    0xb, 0xff, 0xff, 0xff, 0xf4, 0xa, 0xff, 0x21,\n    0xff, 0xe2, 0x3f, 0xfe, 0x0, 0x0, 0x5, 0xff,\n    0xec, 0xb9, 0x81, 0xe, 0xfe, 0x0, 0x6f, 0xfc,\n    0xdf, 0xf6, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0,\n    0x0, 0x3f, 0xfa, 0x0, 0xb, 0xff, 0xff, 0xd0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xaf,\n    0xf5, 0x0, 0x1, 0xff, 0xff, 0x30, 0x0, 0x0,\n    0x0, 0x0, 0x25, 0x8a, 0xb1, 0xff, 0xf0, 0x0,\n    0x8, 0xff, 0xff, 0xb1, 0x0, 0x0, 0x3b, 0xdf,\n    0xff, 0xff, 0xda, 0xff, 0x90, 0x1, 0xbf, 0xff,\n    0xff, 0xfe, 0x40, 0x0, 0x3f, 0xff, 0xff, 0xff,\n    0xef, 0xff, 0x10, 0x5e, 0xff, 0xf9, 0x4f, 0xff,\n    0xf9, 0x10, 0xf, 0xfd, 0xa7, 0x41, 0xdf, 0xf8,\n    0x3b, 0xff, 0xff, 0x70, 0x2, 0xdf, 0xff, 0xe0,\n    0x3, 0x0, 0x0, 0x0, 0xcf, 0xd0, 0x7f, 0xff,\n    0xe3, 0x0, 0x0, 0x1b, 0xff, 0x90, 0x0, 0x0,\n    0x0, 0x0, 0xc, 0x30, 0xb, 0xf9, 0x0, 0x0,\n    0x0, 0x0, 0x6d, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x2, 0x30, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0,\n\n    /* U+8BF7 \"\u8bf7\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x11, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3,\n    0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0xef, 0xe0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x8f, 0xd0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xef, 0xe0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xcf, 0xfb, 0x0, 0x6f, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb0,\n    0x0, 0x2e, 0xff, 0x80, 0x6f, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xb0, 0x0, 0x4,\n    0xff, 0xf5, 0x0, 0x0, 0x0, 0x0, 0xef, 0xe0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8f, 0xd3,\n    0x2, 0x22, 0x22, 0x22, 0xef, 0xe2, 0x22, 0x22,\n    0x22, 0x0, 0x0, 0x0, 0x6, 0x0, 0xe, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x9, 0xaa, 0xaa, 0xaa,\n    0xff, 0xfa, 0xaa, 0xaa, 0xaa, 0x0, 0x2, 0x22,\n    0x22, 0x0, 0x0, 0x0, 0x0, 0x0, 0xef, 0xe0,\n    0x0, 0x0, 0x0, 0x0, 0x4f, 0xff, 0xff, 0x11,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xf2, 0x4f, 0xff, 0xff, 0x11, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3,\n    0x29, 0x9e, 0xff, 0x10, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xb,\n    0xff, 0x10, 0x1, 0x33, 0x33, 0x33, 0x33, 0x33,\n    0x33, 0x33, 0x31, 0x0, 0x0, 0xb, 0xff, 0x10,\n    0x5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xf6, 0x0, 0x0, 0xb, 0xff, 0x10, 0x5, 0xff,\n    0xdc, 0xcc, 0xcc, 0xcc, 0xcc, 0xdf, 0xf6, 0x0,\n    0x0, 0xb, 0xff, 0x10, 0x5, 0xff, 0x70, 0x0,\n    0x0, 0x0, 0x0, 0x6f, 0xf6, 0x0, 0x0, 0xb,\n    0xff, 0x10, 0x5, 0xff, 0xdb, 0xbb, 0xbb, 0xbb,\n    0xbb, 0xdf, 0xf6, 0x0, 0x0, 0xb, 0xff, 0x10,\n    0x5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xf6, 0x0, 0x0, 0xb, 0xff, 0x10, 0x5, 0xff,\n    0x70, 0x0, 0x0, 0x0, 0x0, 0x6f, 0xf6, 0x0,\n    0x0, 0xb, 0xff, 0x14, 0x65, 0xff, 0x70, 0x0,\n    0x0, 0x0, 0x0, 0x6f, 0xf6, 0x0, 0x0, 0xb,\n    0xff, 0x8f, 0x95, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xf6, 0x0, 0x0, 0xb, 0xff, 0xff,\n    0xb5, 0xff, 0xdc, 0xcc, 0xcc, 0xcc, 0xcc, 0xdf,\n    0xf6, 0x0, 0x0, 0xd, 0xff, 0xff, 0x55, 0xff,\n    0x70, 0x0, 0x0, 0x0, 0x0, 0x6f, 0xf6, 0x0,\n    0x0, 0x3f, 0xff, 0xc2, 0x5, 0xff, 0x70, 0x0,\n    0x3, 0x33, 0x24, 0xcf, 0xf4, 0x0, 0x0, 0xd,\n    0xfa, 0x0, 0x5, 0xff, 0x70, 0x0, 0x9, 0xff,\n    0xff, 0xff, 0xf1, 0x0, 0x0, 0x2, 0x80, 0x0,\n    0x5, 0xff, 0x70, 0x0, 0x4, 0xff, 0xff, 0xfb,\n    0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x33,\n    0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+91CD \"\u91cd\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x1, 0x22, 0x34, 0x30, 0x0, 0x0, 0x2b,\n    0xbb, 0xcc, 0xcc, 0xdd, 0xee, 0xef, 0xff, 0xff,\n    0xff, 0xff, 0xc0, 0x0, 0x0, 0x1f, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xee,\n    0xd0, 0x0, 0x0, 0x6, 0x65, 0x55, 0x44, 0x43,\n    0x9f, 0xf8, 0x11, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8f, 0xf7,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xf1, 0x1f, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xf1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x7f, 0xf7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8f, 0xf7,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0x70, 0x0, 0x0, 0x7, 0xff, 0xdc,\n    0xcc, 0xcc, 0xef, 0xfd, 0xcc, 0xcc, 0xcd, 0xff,\n    0x70, 0x0, 0x0, 0x7, 0xff, 0x50, 0x0, 0x0,\n    0x7f, 0xf7, 0x0, 0x0, 0x5, 0xff, 0x70, 0x0,\n    0x0, 0x7, 0xff, 0xdb, 0xbb, 0xbb, 0xdf, 0xfd,\n    0xbb, 0xbb, 0xbd, 0xff, 0x70, 0x0, 0x0, 0x7,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0x70, 0x0, 0x0, 0x7, 0xff, 0x61,\n    0x11, 0x11, 0x8f, 0xf7, 0x11, 0x11, 0x16, 0xff,\n    0x70, 0x0, 0x0, 0x7, 0xff, 0x50, 0x0, 0x0,\n    0x7f, 0xf7, 0x0, 0x0, 0x5, 0xff, 0x70, 0x0,\n    0x0, 0x7, 0xff, 0xdc, 0xcc, 0xcc, 0xef, 0xfe,\n    0xcc, 0xcc, 0xcd, 0xff, 0x70, 0x0, 0x0, 0x7,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0x70, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x8f, 0xf7, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x1, 0x11, 0x11, 0x11, 0x11,\n    0x8f, 0xf7, 0x11, 0x11, 0x11, 0x11, 0x10, 0x0,\n    0x0, 0x5f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xf4, 0x0, 0x0, 0x4d,\n    0xdd, 0xdd, 0xdd, 0xdd, 0xef, 0xfe, 0xdd, 0xdd,\n    0xdd, 0xdd, 0xd3, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x7f, 0xf7, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf2,\n    0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xf2, 0x1, 0x11,\n    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,\n    0x11, 0x11, 0x11, 0x10\n}", "sline": 24}, "glyph_dsc": {"type": "Variable", "def": "static const lv_font_fmt_txt_glyph_dsc_t glyph_dsc[] = {\n    {.bitmap_index = 0, .adv_w = 0, .box_w = 0, .box_h = 0, .ofs_x = 0, .ofs_y = 0} /* id = 0 reserved */,\n    {.bitmap_index = 0, .adv_w = 108, .box_w = 0, .box_h = 0, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 0, .adv_w = 414, .box_w = 24, .box_h = 24, .ofs_x = 1, .ofs_y = -1},\n    {.bitmap_index = 288, .adv_w = 104, .box_w = 6, .box_h = 9, .ofs_x = 0, .ofs_y = -5},\n    {.bitmap_index = 315, .adv_w = 108, .box_w = 5, .box_h = 4, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 325, .adv_w = 284, .box_w = 16, .box_h = 21, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 493, .adv_w = 153, .box_w = 7, .box_h = 21, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 567, .adv_w = 251, .box_w = 14, .box_h = 21, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 714, .adv_w = 254, .box_w = 14, .box_h = 21, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 861, .adv_w = 270, .box_w = 16, .box_h = 23, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 1045, .adv_w = 258, .box_w = 15, .box_h = 21, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 1203, .adv_w = 264, .box_w = 15, .box_h = 22, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1368, .adv_w = 270, .box_w = 16, .box_h = 22, .ofs_x = 1, .ofs_y = -1},\n    {.bitmap_index = 1544, .adv_w = 258, .box_w = 14, .box_h = 21, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1691, .adv_w = 264, .box_w = 15, .box_h = 22, .ofs_x = 1, .ofs_y = -1},\n    {.bitmap_index = 1856, .adv_w = 317, .box_w = 20, .box_h = 23, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2086, .adv_w = 308, .box_w = 17, .box_h = 22, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2273, .adv_w = 253, .box_w = 12, .box_h = 22, .ofs_x = 2, .ofs_y = 0},\n    {.bitmap_index = 2405, .adv_w = 224, .box_w = 11, .box_h = 22, .ofs_x = 2, .ofs_y = 0},\n    {.bitmap_index = 2526, .adv_w = 203, .box_w = 10, .box_h = 22, .ofs_x = 2, .ofs_y = 0},\n    {.bitmap_index = 2636, .adv_w = 420, .box_w = 25, .box_h = 24, .ofs_x = 1, .ofs_y = -1},\n    {.bitmap_index = 2936, .adv_w = 246, .box_w = 13, .box_h = 22, .ofs_x = 2, .ofs_y = 0},\n    {.bitmap_index = 3079, .adv_w = 231, .box_w = 14, .box_h = 22, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 3233, .adv_w = 329, .box_w = 17, .box_h = 22, .ofs_x = 2, .ofs_y = 0},\n    {.bitmap_index = 3420, .adv_w = 271, .box_w = 14, .box_h = 14, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 3518, .adv_w = 209, .box_w = 11, .box_h = 14, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 3595, .adv_w = 271, .box_w = 14, .box_h = 23, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 3756, .adv_w = 244, .box_w = 14, .box_h = 14, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 3854, .adv_w = 156, .box_w = 10, .box_h = 23, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 3969, .adv_w = 271, .box_w = 14, .box_h = 21, .ofs_x = 1, .ofs_y = -7},\n    {.bitmap_index = 4116, .adv_w = 247, .box_w = 12, .box_h = 23, .ofs_x = 2, .ofs_y = 0},\n    {.bitmap_index = 4254, .adv_w = 113, .box_w = 5, .box_h = 20, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 4304, .adv_w = 113, .box_w = 3, .box_h = 23, .ofs_x = 2, .ofs_y = 0},\n    {.bitmap_index = 4339, .adv_w = 356, .box_w = 19, .box_h = 14, .ofs_x = 2, .ofs_y = 0},\n    {.bitmap_index = 4472, .adv_w = 247, .box_w = 12, .box_h = 14, .ofs_x = 2, .ofs_y = 0},\n    {.bitmap_index = 4556, .adv_w = 262, .box_w = 15, .box_h = 14, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 4661, .adv_w = 271, .box_w = 14, .box_h = 21, .ofs_x = 2, .ofs_y = -7},\n    {.bitmap_index = 4808, .adv_w = 160, .box_w = 8, .box_h = 14, .ofs_x = 2, .ofs_y = 0},\n    {.bitmap_index = 4864, .adv_w = 180, .box_w = 11, .box_h = 14, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 4941, .adv_w = 148, .box_w = 9, .box_h = 19, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 5027, .adv_w = 240, .box_w = 12, .box_h = 14, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 5111, .adv_w = 225, .box_w = 14, .box_h = 15, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 5216, .adv_w = 342, .box_w = 22, .box_h = 16, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 5392, .adv_w = 244, .box_w = 16, .box_h = 21, .ofs_x = 0, .ofs_y = -7},\n    {.bitmap_index = 5560, .adv_w = 225, .box_w = 14, .box_h = 14, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 5658, .adv_w = 271, .box_w = 14, .box_h = 21, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 5805, .adv_w = 262, .box_w = 15, .box_h = 21, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 5963, .adv_w = 368, .box_w = 21, .box_h = 4, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 6005, .adv_w = 448, .box_w = 27, .box_h = 27, .ofs_x = 0, .ofs_y = -4},\n    {.bitmap_index = 6370, .adv_w = 448, .box_w = 28, .box_h = 28, .ofs_x = 0, .ofs_y = -4},\n    {.bitmap_index = 6762, .adv_w = 448, .box_w = 26, .box_h = 27, .ofs_x = 0, .ofs_y = -4},\n    {.bitmap_index = 7113, .adv_w = 448, .box_w = 28, .box_h = 27, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 7491, .adv_w = 448, .box_w = 27, .box_h = 28, .ofs_x = 0, .ofs_y = -4},\n    {.bitmap_index = 7869, .adv_w = 448, .box_w = 26, .box_h = 25, .ofs_x = 2, .ofs_y = -3},\n    {.bitmap_index = 8194, .adv_w = 448, .box_w = 28, .box_h = 27, .ofs_x = 0, .ofs_y = -4},\n    {.bitmap_index = 8572, .adv_w = 448, .box_w = 27, .box_h = 27, .ofs_x = 1, .ofs_y = -4},\n    {.bitmap_index = 8937, .adv_w = 448, .box_w = 28, .box_h = 24, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 9273, .adv_w = 448, .box_w = 27, .box_h = 26, .ofs_x = 1, .ofs_y = -3},\n    {.bitmap_index = 9624, .adv_w = 448, .box_w = 28, .box_h = 27, .ofs_x = 0, .ofs_y = -4},\n    {.bitmap_index = 10002, .adv_w = 448, .box_w = 28, .box_h = 28, .ofs_x = 0, .ofs_y = -4},\n    {.bitmap_index = 10394, .adv_w = 448, .box_w = 28, .box_h = 26, .ofs_x = 0, .ofs_y = -3}\n}", "sline": 1523}, "unicode_list_0": {"type": "Variable", "def": "static const uint16_t unicode_list_0[] = {\n    0x0, 0x5, 0xc, 0xe, 0x10, 0x11, 0x12, 0x13,\n    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x21, 0x23,\n    0x25, 0x26, 0x2c, 0x2d, 0x30, 0x34, 0x35, 0x41,\n    0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4c,\n    0x4d, 0x4e, 0x4f, 0x50, 0x52, 0x53, 0x54, 0x55,\n    0x56, 0x57, 0x59, 0x5a, 0xc1, 0xd3, 0x2006, 0x52df,\n    0x5327, 0x540f, 0x5708, 0x5b6c, 0x5dd2, 0x61f0, 0x658d, 0x6b43,\n    0x7515, 0x7e87, 0x8bd7, 0x91ad\n}", "sline": 1591}, "cmaps": {"type": "Variable", "def": "static const lv_font_fmt_txt_cmap_t cmaps[]", "sline": 1603}, "cache": {"type": "Variable", "def": "static  lv_font_fmt_txt_glyph_cache_t cache", "sline": 1619}, "font_dsc": {"type": "Variable", "def": "static const lv_font_fmt_txt_dsc_t font_dsc", "sline": 1620}, "update_font_32": {"type": "Variable", "def": "const lv_font_t update_font_32 = {\n#else\nlv_font_t update_font_32 = {\n#endif\n    .get_glyph_dsc = lv_font_get_glyph_dsc_fmt_txt,    /*Function pointer to get glyph's data*/\n    .get_glyph_bitmap = lv_font_get_bitmap_fmt_txt,    /*Function pointer to get glyph's bitmap*/\n    .line_height = 31,          /*The maximum line height required by the font*/\n    .base_line = 7,             /*Baseline measured from the bottom of the line*/\n#if !(LVGL_VERSION_MAJOR == 6 && LVGL_VERSION_MINOR == 0)\n    .subpx = LV_FONT_SUBPX_NONE,\n#endif\n#if LV_VERSION_CHECK(7, 4, 0) || LVGL_VERSION_MAJOR >= 8\n    .underline_position = -3,\n    .underline_thickness = 1,\n#endif\n    .dsc = &font_dsc           /*The custom font data. Will be accessed by `get_glyph_bitmap/dsc` */\n}", "sline": 1645}, "carbit_updater/update_font_32.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/update_font_32.c"}}, "carbit_updater/lvgl/src/core/lv_obj_draw.h": {"lv_draw": {"type": "Variable", "def": "#include ../draw/lv_draw.h", "sline": 16}, "_lv_obj_t": {"type": "Struct", "def": "struct _lv_obj_t", "sline": 26}, "_lv_obj_class_t": {"type": "Struct", "def": "struct _lv_obj_class_t", "sline": 27}, "lv_cover_res_t": {"type": "Variable", "def": "typedef enum {\n    LV_COVER_RES_COVER      = 0,\n    LV_COVER_RES_NOT_COVER  = 1,\n    LV_COVER_RES_MASKED     = 2,\n} lv_cover_res_t", "sline": 34, "docstring": "/** Cover check results.*/"}, "lv_obj_draw_part_dsc_t.clip_area": {"type": "Variable", "def": "const lv_area_t * clip_area", "sline": 37, "in_struct": "lv_obj_draw_part_dsc_t"}, "lv_obj_draw_part_dsc_t.class_p": {"type": "Variable", "def": "const struct _lv_obj_class_t * class_p", "sline": 38, "in_struct": "lv_obj_draw_part_dsc_t"}, "lv_obj_draw_part_dsc_t.type": {"type": "Variable", "def": "uint32_t type", "sline": 39, "in_struct": "lv_obj_draw_part_dsc_t"}, "lv_obj_draw_part_dsc_t.draw_area": {"type": "Variable", "def": "lv_area_t * draw_area", "sline": 40, "in_struct": "lv_obj_draw_part_dsc_t"}, "lv_obj_draw_part_dsc_t.rect_dsc": {"type": "Variable", "def": "lv_draw_rect_dsc_t *\n    rect_dsc", "sline": 42, "in_struct": "lv_obj_draw_part_dsc_t"}, "lv_obj_draw_part_dsc_t.label_dsc": {"type": "Variable", "def": "lv_draw_label_dsc_t *\n    label_dsc", "sline": 44, "in_struct": "lv_obj_draw_part_dsc_t"}, "lv_obj_draw_part_dsc_t.line_dsc": {"type": "Variable", "def": "lv_draw_line_dsc_t *\n    line_dsc", "sline": 46, "in_struct": "lv_obj_draw_part_dsc_t"}, "lv_obj_draw_part_dsc_t.img_dsc": {"type": "Variable", "def": "lv_draw_img_dsc_t  *\n    img_dsc", "sline": 48, "in_struct": "lv_obj_draw_part_dsc_t"}, "lv_obj_draw_part_dsc_t.arc_dsc": {"type": "Variable", "def": "lv_draw_arc_dsc_t  *\n    arc_dsc", "sline": 50, "in_struct": "lv_obj_draw_part_dsc_t"}, "lv_obj_draw_part_dsc_t.p1": {"type": "Variable", "def": "const lv_point_t *\n    p1", "sline": 52, "in_struct": "lv_obj_draw_part_dsc_t"}, "lv_obj_draw_part_dsc_t.p2": {"type": "Variable", "def": "const lv_point_t * p2", "sline": 53, "in_struct": "lv_obj_draw_part_dsc_t"}, "lv_obj_draw_part_dsc_t.text": {"type": "Variable", "def": "char * text", "sline": 54, "in_struct": "lv_obj_draw_part_dsc_t"}, "lv_obj_draw_part_dsc_t.text_length": {"type": "Variable", "def": "uint32_t text_length", "sline": 55, "in_struct": "lv_obj_draw_part_dsc_t"}, "lv_obj_draw_part_dsc_t.part": {"type": "Variable", "def": "uint32_t part", "sline": 56, "in_struct": "lv_obj_draw_part_dsc_t"}, "lv_obj_draw_part_dsc_t.id": {"type": "Variable", "def": "uint32_t id", "sline": 57, "in_struct": "lv_obj_draw_part_dsc_t"}, "lv_obj_draw_part_dsc_t.radius": {"type": "Variable", "def": "lv_coord_t radius", "sline": 58, "in_struct": "lv_obj_draw_part_dsc_t"}, "lv_obj_draw_part_dsc_t.value": {"type": "Variable", "def": "int32_t value", "sline": 59, "in_struct": "lv_obj_draw_part_dsc_t"}, "lv_obj_draw_part_dsc_t.sub_part_ptr": {"type": "Variable", "def": "const void * sub_part_ptr", "sline": 60, "in_struct": "lv_obj_draw_part_dsc_t"}, "lv_obj_draw_part_dsc_t": {"type": "Variable", "def": "typedef struct {\n    const lv_area_t * clip_area;        /**< The current clip area, required if you need to draw something in the event*/\n    const struct _lv_obj_class_t * class_p;     /**< The class that sent the event */\n    uint32_t type;                      /**< The type if part being draw. Element of `lv_<name>_draw_part_type_t` */\n    lv_area_t * draw_area;              /**< The area of the part being drawn*/\n    lv_draw_rect_dsc_t *\n    rect_dsc;      /**< A draw descriptor that can be modified to changed what LVGL will draw. Set only for rectangle-like parts*/\n    lv_draw_label_dsc_t *\n    label_dsc;    /**< A draw descriptor that can be modified to changed what LVGL will draw. Set only for text-like parts*/\n    lv_draw_line_dsc_t *\n    line_dsc;      /**< A draw descriptor that can be modified to changed what LVGL will draw. Set only for line-like parts*/\n    lv_draw_img_dsc_t  *\n    img_dsc;       /**< A draw descriptor that can be modified to changed what LVGL will draw. Set only for image-like parts*/\n    lv_draw_arc_dsc_t  *\n    arc_dsc;       /**< A draw descriptor that can be modified to changed what LVGL will draw. Set only for arc-like parts*/\n    const lv_point_t *\n    p1;              /**< A point calculated during drawing. E.g. a point of chart or the center of an arc.*/\n    const lv_point_t * p2;              /**< A point calculated during drawing. E.g. a point of chart.*/\n    char * text;                  /**< A text calculated during drawing. Can be modified. E.g. tick labels on a chart axis.*/\n    uint32_t text_length;               /**< Size of the text buffer containing null-terminated text string calculated during drawing.*/\n    uint32_t part;                      /**< The current part for which the event is sent*/\n    uint32_t id;                        /**< The index of the part. E.g. a button's index on button matrix or table cell index.*/\n    lv_coord_t radius;                  /**< E.g. the radius of an arc (not the corner radius).*/\n    int32_t value;                      /**< A value calculated during drawing. E.g. Chart's tick line value.*/\n    const void * sub_part_ptr;          /**< A pointer the identifies something in the part. E.g. chart series. */\n} lv_obj_draw_part_dsc_t", "sline": 61}, "lv_obj_init_draw_rect_dsc": {"type": "Function", "def": "void lv_obj_init_draw_rect_dsc(struct _lv_obj_t * obj, uint32_t part, lv_draw_rect_dsc_t * draw_dsc)", "sline": 77}, "lv_obj_init_draw_label_dsc": {"type": "Function", "def": "void lv_obj_init_draw_label_dsc(struct _lv_obj_t * obj, uint32_t part, lv_draw_label_dsc_t * draw_dsc)", "sline": 87}, "lv_obj_init_draw_img_dsc": {"type": "Function", "def": "void lv_obj_init_draw_img_dsc(struct _lv_obj_t * obj, uint32_t part, lv_draw_img_dsc_t * draw_dsc)", "sline": 96}, "lv_obj_init_draw_line_dsc": {"type": "Function", "def": "void lv_obj_init_draw_line_dsc(struct _lv_obj_t * obj, uint32_t part, lv_draw_line_dsc_t * draw_dsc)", "sline": 106}, "lv_obj_init_draw_arc_dsc": {"type": "Function", "def": "void lv_obj_init_draw_arc_dsc(struct _lv_obj_t * obj, uint32_t part, lv_draw_arc_dsc_t * draw_dsc)", "sline": 115}, "lv_obj_calculate_ext_draw_size": {"type": "Function", "def": "lv_coord_t lv_obj_calculate_ext_draw_size(struct _lv_obj_t * obj, uint32_t part)", "sline": 123}, "lv_obj_draw_dsc_init": {"type": "Function", "def": "void lv_obj_draw_dsc_init(lv_obj_draw_part_dsc_t * dsc, const lv_area_t * clip_area)", "sline": 130}, "lv_obj_draw_part_check_type": {"type": "Function", "def": "bool lv_obj_draw_part_check_type(lv_obj_draw_part_dsc_t * dsc, const struct _lv_obj_class_t * class_p, uint32_t type)", "sline": 139}, "lv_obj_refresh_ext_draw_size": {"type": "Function", "def": "void lv_obj_refresh_ext_draw_size(struct _lv_obj_t * obj)", "sline": 146}, "_lv_obj_get_ext_draw_size": {"type": "Function", "def": "lv_coord_t _lv_obj_get_ext_draw_size(const struct _lv_obj_t * obj)", "sline": 153}, "carbit_updater/lvgl/src/core/lv_obj_draw.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_draw.h"}}, "carbit_updater/lvgl/src/extra/libs/fsdrv/lv_fs_fatfs.c": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 9}, "carbit_updater/lvgl/src/extra/libs/fsdrv/lv_fs_fatfs.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/fsdrv/lv_fs_fatfs.c"}}, "carbit_updater/lvgl/src/widgets/lv_objx_templ.c": {"keep_pedantic_happy": {"type": "Variable", "def": "typedef int keep_pedantic_happy", "sline": 139, "docstring": "/*This dummy typedef exists purely to silence -Wpedantic.*/"}, "carbit_updater/lvgl/src/widgets/lv_objx_templ.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_objx_templ.c"}}, "carbit_updater/lvgl/src/core/lv_theme.h": {"lv_obj": {"type": "Variable", "def": "#include ../core/lv_obj.h", "sline": 16}, "_lv_theme_t": {"type": "Struct", "def": "struct _lv_theme_t {\n    lv_theme_apply_cb_t apply_cb;\n    struct _lv_theme_t * parent;    /**< Apply the current theme's style on top of this theme.*/\n    void * user_data;\n    struct _lv_disp_t * disp;\n    lv_color_t color_primary;\n    lv_color_t color_secondary;\n    const lv_font_t * font_small;\n    const lv_font_t * font_normal;\n    const lv_font_t * font_large;\n    uint32_t flags;                 /*Any custom flag used by the theme*/\n}", "sline": 31, "body": "lv_theme_apply_cb_t apply_cb\nstruct _lv_theme_t * parent\nvoid * user_data\nstruct _lv_disp_t * disp\nlv_color_t color_primary\nlv_color_t color_secondary\nconst lv_font_t * font_small\nconst lv_font_t * font_normal\nconst lv_font_t * font_large\nuint32_t flags\n"}, "_lv_disp_t": {"type": "Struct", "def": "struct _lv_disp_t", "sline": 27}, "lv_theme_apply_cb_t": {"type": "Variable", "def": "typedef void (*lv_theme_apply_cb_t)(struct _lv_theme_t *, lv_obj_t *)", "sline": 29}, "_lv_theme_t.apply_cb": {"type": "Variable", "def": "lv_theme_apply_cb_t apply_cb", "sline": 32, "in_struct": "_lv_theme_t", "rels": [["lv_theme_apply_cb_t", null, "Typeof"]]}, "_lv_theme_t.parent": {"type": "Variable", "def": "struct _lv_theme_t * parent", "sline": 33, "in_struct": "_lv_theme_t"}, "_lv_theme_t.user_data": {"type": "Variable", "def": "void * user_data", "sline": 34, "in_struct": "_lv_theme_t"}, "_lv_theme_t.disp": {"type": "Variable", "def": "struct _lv_disp_t * disp", "sline": 35, "in_struct": "_lv_theme_t"}, "_lv_theme_t.color_primary": {"type": "Variable", "def": "lv_color_t color_primary", "sline": 36, "in_struct": "_lv_theme_t"}, "_lv_theme_t.color_secondary": {"type": "Variable", "def": "lv_color_t color_secondary", "sline": 37, "in_struct": "_lv_theme_t"}, "_lv_theme_t.font_small": {"type": "Variable", "def": "const lv_font_t * font_small", "sline": 38, "in_struct": "_lv_theme_t"}, "_lv_theme_t.font_normal": {"type": "Variable", "def": "const lv_font_t * font_normal", "sline": 39, "in_struct": "_lv_theme_t"}, "_lv_theme_t.font_large": {"type": "Variable", "def": "const lv_font_t * font_large", "sline": 40, "in_struct": "_lv_theme_t"}, "_lv_theme_t.flags": {"type": "Variable", "def": "uint32_t flags", "sline": 41, "in_struct": "_lv_theme_t"}, "lv_theme_t": {"type": "Variable", "def": "typedef struct _lv_theme_t {\n    lv_theme_apply_cb_t apply_cb;\n    struct _lv_theme_t * parent;    /**< Apply the current theme's style on top of this theme.*/\n    void * user_data;\n    struct _lv_disp_t * disp;\n    lv_color_t color_primary;\n    lv_color_t color_secondary;\n    const lv_font_t * font_small;\n    const lv_font_t * font_normal;\n    const lv_font_t * font_large;\n    uint32_t flags;                 /*Any custom flag used by the theme*/\n} lv_theme_t", "sline": 42}, "lv_theme_get_from_obj": {"type": "Function", "def": "lv_theme_t  * lv_theme_get_from_obj(lv_obj_t * obj)", "sline": 53}, "lv_theme_apply": {"type": "Function", "def": "void lv_theme_apply(lv_obj_t * obj)", "sline": 59}, "lv_theme_set_parent": {"type": "Function", "def": "void lv_theme_set_parent(lv_theme_t * new_theme, lv_theme_t * parent)", "sline": 68}, "lv_theme_set_apply_cb": {"type": "Function", "def": "void lv_theme_set_apply_cb(lv_theme_t * theme, lv_theme_apply_cb_t apply_cb)", "sline": 76}, "lv_theme_get_font_small": {"type": "Function", "def": "const lv_font_t * lv_theme_get_font_small(lv_obj_t * obj)", "sline": 82}, "lv_theme_get_font_normal": {"type": "Function", "def": "const lv_font_t * lv_theme_get_font_normal(lv_obj_t * obj)", "sline": 87}, "lv_theme_get_font_large": {"type": "Function", "def": "const lv_font_t * lv_theme_get_font_large(lv_obj_t * obj)", "sline": 93}, "lv_theme_get_color_primary": {"type": "Function", "def": "lv_color_t lv_theme_get_color_primary(lv_obj_t * obj)", "sline": 99}, "lv_theme_get_color_secondary": {"type": "Function", "def": "lv_color_t lv_theme_get_color_secondary(lv_obj_t * obj)", "sline": 105}, "carbit_updater/lvgl/src/core/lv_theme.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_theme.h"}}, "carbit_updater/lvgl/src/widgets/lv_switch.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "lv_obj": {"type": "Variable", "def": "#include ../core/lv_obj.h", "sline": 20}, "lv_switch_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 31, "in_struct": "lv_switch_t"}, "lv_switch_t.anim_state": {"type": "Variable", "def": "int32_t anim_state", "sline": 32, "in_struct": "lv_switch_t"}, "lv_switch_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    int32_t anim_state;\n} lv_switch_t", "sline": 33}, "lv_switch_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_switch_class", "sline": 35}, "lv_switch_create": {"type": "Function", "def": "lv_obj_t * lv_switch_create(lv_obj_t * parent)", "sline": 46}, "carbit_updater/lvgl/src/widgets/lv_switch.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_switch.h"}}, "carbit_updater/lvgl/tests/unity/unity_support.h": {"stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 9}, "lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "lv_test_assert_img_eq": {"type": "Function", "def": "bool lv_test_assert_img_eq(const char * fn_ref)", "sline": 12}, "carbit_updater/lvgl/tests/unity/unity_support.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/tests/unity/unity_support.h"}}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../../lv_conf_internal.h", "sline": 17}, "stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 21}, "time": {"type": "Variable", "def": "#include time.h", "sline": 22}, "lruc_error": {"type": "Variable", "def": "typedef enum {\n    LV_LRU_NO_ERROR = 0,\n    LV_LRU_MISSING_CACHE,\n    LV_LRU_MISSING_KEY,\n    LV_LRU_MISSING_VALUE,\n    LV_LRU_LOCK_ERROR,\n    LV_LRU_VALUE_TOO_LARGE\n} lruc_error", "sline": 40}, "lv_lru_free_t": {"type": "Variable", "def": "typedef void (lv_lru_free_t)(void * v)", "sline": 42}, "lruc_item.value": {"type": "Variable", "def": "void * value", "sline": 45, "in_struct": "lruc_item"}, "lruc_item.key": {"type": "Variable", "def": "void * key", "sline": 46, "in_struct": "lruc_item"}, "lruc_item.value_length": {"type": "Variable", "def": "size_t value_length", "sline": 47, "in_struct": "lruc_item"}, "lruc_item.key_length": {"type": "Variable", "def": "size_t key_length", "sline": 48, "in_struct": "lruc_item"}, "lruc_item.access_count": {"type": "Variable", "def": "uint64_t access_count", "sline": 49, "in_struct": "lruc_item"}, "lruc_item.next": {"type": "Variable", "def": "struct lruc_item * next", "sline": 50, "in_struct": "lruc_item"}, "lruc_item": {"type": "Variable", "def": "typedef struct lruc_item {\n    void * value;\n    void * key;\n    size_t value_length;\n    size_t key_length;\n    uint64_t access_count;\n    struct lruc_item * next;\n} lruc_item", "sline": 51}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9).items": {"type": "Variable", "def": "lruc_item ** items", "sline": 54, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9).access_count": {"type": "Variable", "def": "uint64_t access_count", "sline": 55, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9).free_memory": {"type": "Variable", "def": "uint64_t free_memory", "sline": 56, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9).total_memory": {"type": "Variable", "def": "uint64_t total_memory", "sline": 57, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9).average_item_length": {"type": "Variable", "def": "uint64_t average_item_length", "sline": 58, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9).hash_table_size": {"type": "Variable", "def": "uint32_t hash_table_size", "sline": 59, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9).seed": {"type": "Variable", "def": "time_t seed", "sline": 60, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9).value_free": {"type": "Variable", "def": "lv_lru_free_t * value_free", "sline": 61, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9).key_free": {"type": "Variable", "def": "lv_lru_free_t * key_free", "sline": 62, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9).free_items": {"type": "Variable", "def": "lruc_item * free_items", "sline": 63, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9).mutex": {"type": "Variable", "def": "SDL_mutex * mutex", "sline": 64, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h:53:9)": {"type": "Struct", "def": "struct {\n    lruc_item ** items;\n    uint64_t access_count;\n    uint64_t free_memory;\n    uint64_t total_memory;\n    uint64_t average_item_length;\n    uint32_t hash_table_size;\n    time_t seed;\n    lv_lru_free_t * value_free;\n    lv_lru_free_t * key_free;\n    lruc_item * free_items;\n    SDL_mutex * mutex;\n}", "sline": 53, "body": "lruc_item ** items\nuint64_t access_count\nuint64_t free_memory\nuint64_t total_memory\nuint64_t average_item_length\nuint32_t hash_table_size\ntime_t seed\nlv_lru_free_t * value_free\nlv_lru_free_t * key_free\nlruc_item * free_items\nSDL_mutex * mutex\n"}, "lv_lru_t": {"type": "Variable", "def": "typedef struct {\n    lruc_item ** items;\n    uint64_t access_count;\n    uint64_t free_memory;\n    uint64_t total_memory;\n    uint64_t average_item_length;\n    uint32_t hash_table_size;\n    time_t seed;\n    lv_lru_free_t * value_free;\n    lv_lru_free_t * key_free;\n    lruc_item * free_items;\n    SDL_mutex * mutex;\n} lv_lru_t", "sline": 65}, "lv_lru_new": {"type": "Function", "def": "lv_lru_t * lv_lru_new(uint64_t cache_size, uint32_t average_length, lv_lru_free_t * value_free,\n                      lv_lru_free_t * key_free)", "sline": 72}, "lv_lru_free": {"type": "Function", "def": "lruc_error lv_lru_free(lv_lru_t * cache)", "sline": 75, "rels": [["lruc_error", null, "Typeof"]]}, "lv_lru_set": {"type": "Function", "def": "lruc_error lv_lru_set(lv_lru_t * cache, const void * key, size_t key_length, void * value, size_t value_length)", "sline": 77, "rels": [["lruc_error", null, "Typeof"]]}, "lv_lru_get": {"type": "Function", "def": "lruc_error lv_lru_get(lv_lru_t * cache, const void * key, size_t key_size, void ** value)", "sline": 79, "rels": [["lruc_error", null, "Typeof"]]}, "lv_lru_delete": {"type": "Function", "def": "lruc_error lv_lru_delete(lv_lru_t * cache, const void * key, size_t key_size)", "sline": 81, "rels": [["lruc_error", null, "Typeof"]]}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h"}}, "carbit_updater/lv_drivers/display/GC9A01.c": {"GC9A01": {"type": "Variable", "def": "#include GC9A01.h", "sline": 10, "include": ["carbit_updater/lv_drivers/display/GC9A01.h", null]}, "carbit_updater/lv_drivers/display/GC9A01.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/GC9A01.c"}}, "carbit_updater/lvgl/tests/src/lv_test_init.h": {"stdio": {"type": "Variable", "def": "#include stdio.h", "sline": 9}, "lvgl": {"type": "Variable", "def": "#include ../lvgl.h", "sline": 10}, "lv_test_init": {"type": "Function", "def": "void lv_test_init(void)", "sline": 12}, "lv_test_deinit": {"type": "Function", "def": "void lv_test_deinit(void)", "sline": 13}, "carbit_updater/lvgl/tests/src/lv_test_init.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/tests/src/lv_test_init.h"}}, "carbit_updater/lvgl/src/draw/lv_draw.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "lv_style": {"type": "Variable", "def": "#include ../misc/lv_style.h", "sline": 18}, "lv_txt": {"type": "Variable", "def": "#include ../misc/lv_txt.h", "sline": 19}, "lv_img_decoder": {"type": "Variable", "def": "#include lv_img_decoder.h", "sline": 20, "include": ["carbit_updater/lvgl/src/draw/lv_img_decoder.h", null]}, "lv_img_cache": {"type": "Variable", "def": "#include lv_img_cache.h", "sline": 21, "include": ["carbit_updater/lvgl/src/draw/lv_img_cache.h", null]}, "lv_draw_rect": {"type": "Variable", "def": "#include lv_draw_rect.h", "sline": 23, "include": ["carbit_updater/lvgl/src/draw/lv_draw_rect.h", null]}, "lv_draw_label": {"type": "Variable", "def": "#include lv_draw_label.h", "sline": 24, "include": ["carbit_updater/lvgl/src/draw/lv_draw_label.h", null]}, "lv_draw_img": {"type": "Variable", "def": "#include lv_draw_img.h", "sline": 25, "include": ["carbit_updater/lvgl/src/draw/lv_draw_img.h", null]}, "lv_draw_line": {"type": "Variable", "def": "#include lv_draw_line.h", "sline": 26, "include": ["carbit_updater/lvgl/src/draw/lv_draw_line.h", null]}, "lv_draw_triangle": {"type": "Variable", "def": "#include lv_draw_triangle.h", "sline": 27, "include": ["carbit_updater/lvgl/src/draw/lv_draw_triangle.h", null]}, "lv_draw_arc": {"type": "Variable", "def": "#include lv_draw_arc.h", "sline": 28, "include": ["carbit_updater/lvgl/src/draw/lv_draw_arc.h", null]}, "lv_draw_blend": {"type": "Variable", "def": "#include lv_draw_blend.h", "sline": 29, "include": ["carbit_updater/lvgl/src/draw/lv_draw_blend.h", null]}, "lv_draw_mask": {"type": "Variable", "def": "#include lv_draw_mask.h", "sline": 30, "include": ["carbit_updater/lvgl/src/draw/lv_draw_mask.h", null]}, "carbit_updater/lvgl/src/draw/lv_draw.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_draw.h"}}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_draw_arc.c": {"lv_conf_internal": {"type": "Variable", "def": "#include ../../lv_conf_internal.h", "sline": 12}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_draw_arc.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_draw_arc.c"}}, "carbit_updater/lvgl/src/extra/widgets/list/lv_list.c": {"lv_list": {"type": "Variable", "def": "#include lv_list.h", "sline": 9, "include": ["carbit_updater/lvgl/src/extra/widgets/list/lv_list.h", null]}, "lv_disp": {"type": "Variable", "def": "#include ../../../core/lv_disp.h", "sline": 10}, "lv_label": {"type": "Variable", "def": "#include ../../../widgets/lv_label.h", "sline": 11}, "lv_img": {"type": "Variable", "def": "#include ../../../widgets/lv_img.h", "sline": 12}, "lv_btn": {"type": "Variable", "def": "#include ../../../widgets/lv_btn.h", "sline": 13}, "lv_list_class": {"type": "Variable", "def": "const lv_obj_class_t lv_list_class = {\n    .base_class = &lv_obj_class,\n    .width_def = (LV_DPI_DEF * 3) / 2,\n    .height_def = LV_DPI_DEF * 2\n}", "sline": 30}, "lv_list_btn_class": {"type": "Variable", "def": "const lv_obj_class_t lv_list_btn_class = {\n    .base_class = &lv_btn_class,\n}", "sline": 36}, "lv_list_text_class": {"type": "Variable", "def": "const lv_obj_class_t lv_list_text_class = {\n    .base_class = &lv_label_class,\n}", "sline": 40}, "lv_list_create": {"type": "Function", "def": "lv_obj_t * lv_list_create(lv_obj_t * parent)", "sline": 56, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_list_class, parent);\n    lv_obj_class_init_obj(obj);\n    lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_COLUMN);\n    return obj;\n}"}, "lv_list_add_text": {"type": "Function", "def": "lv_obj_t * lv_list_add_text(lv_obj_t * list, const char * txt)", "sline": 65, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_list_text_class, list);\n    lv_obj_class_init_obj(obj);\n    lv_label_set_text(obj, txt);\n    lv_label_set_long_mode(obj, LV_LABEL_LONG_SCROLL_CIRCULAR);\n    lv_obj_set_width(obj, LV_PCT(100));\n    return obj;\n}"}, "lv_list_add_btn": {"type": "Function", "def": "lv_obj_t * lv_list_add_btn(lv_obj_t * list, const char * icon, const char * txt)", "sline": 76, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_list_btn_class, list);\n    lv_obj_class_init_obj(obj);\n    lv_obj_set_size(obj, LV_PCT(100), LV_SIZE_CONTENT);\n    lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_ROW);\n\n    if(icon) {\n        lv_obj_t * img = lv_img_create(obj);\n        lv_img_set_src(img, icon);\n    }\n\n    if(txt) {\n        lv_obj_t * label = lv_label_create(obj);\n        lv_label_set_text(label, txt);\n        lv_label_set_long_mode(label, LV_LABEL_LONG_SCROLL_CIRCULAR);\n        lv_obj_set_flex_grow(label, 1);\n    }\n\n    return obj;\n}"}, "lv_list_get_btn_text": {"type": "Function", "def": "const char * lv_list_get_btn_text(lv_obj_t * list, lv_obj_t * btn)", "sline": 99, "body": "{\n    LV_UNUSED(list);\n    uint32_t i;\n    for(i = 0; i < lv_obj_get_child_cnt(btn); i++) {\n        lv_obj_t * child = lv_obj_get_child(btn, i);\n        if(lv_obj_check_type(child, &lv_label_class)) {\n            return lv_label_get_text(child);\n        }\n\n    }\n\n    return \"\";\n}"}, "carbit_updater/lvgl/src/extra/widgets/list/lv_list.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/list/lv_list.c"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_42.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_montserrat_42.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_42.c"}}, "carbit_updater/lvgl/src/widgets/lv_bar.c": {"lv_bar": {"type": "Variable", "def": "#include lv_bar.h", "sline": 9, "include": ["carbit_updater/lvgl/src/widgets/lv_bar.h", null]}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 12}, "lv_draw": {"type": "Variable", "def": "#include ../draw/lv_draw.h", "sline": 13}, "lv_anim": {"type": "Variable", "def": "#include ../misc/lv_anim.h", "sline": 14}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 15}, "lv_bar_constructor": {"type": "Function", "def": "static void lv_bar_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 204, "body": "{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_bar_t * bar = (lv_bar_t *)obj;\n    bar->min_value = 0;\n    bar->max_value = 100;\n    bar->start_value = 0;\n    bar->cur_value = 0;\n    bar->mode         = LV_BAR_MODE_NORMAL;\n\n    lv_bar_init_anim(obj, &bar->cur_value_anim);\n    lv_bar_init_anim(obj, &bar->start_value_anim);\n\n    lv_obj_clear_flag(obj, LV_OBJ_FLAG_CHECKABLE);\n    lv_obj_clear_flag(obj, LV_OBJ_FLAG_SCROLLABLE);\n    lv_bar_set_value(obj, 0, LV_ANIM_OFF);\n\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}"}, "lv_bar_destructor": {"type": "Function", "def": "static void lv_bar_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 226, "body": "{\n    LV_UNUSED(class_p);\n    lv_bar_t * bar = (lv_bar_t *)obj;\n\n    lv_anim_del(&bar->cur_value_anim, NULL);\n    lv_anim_del(&bar->start_value_anim, NULL);\n}"}, "lv_bar_event": {"type": "Function", "def": "static void lv_bar_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 496, "body": "{\n    LV_UNUSED(class_p);\n\n    lv_res_t res;\n\n    /*Call the ancestor's event handler*/\n    res = lv_obj_event_base(MY_CLASS, e);\n    if(res != LV_RES_OK) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n\n    if(code == LV_EVENT_REFR_EXT_DRAW_SIZE) {\n        lv_coord_t indic_size;\n        indic_size = lv_obj_calculate_ext_draw_size(obj, LV_PART_INDICATOR);\n\n        /*Bg size is handled by lv_obj*/\n        lv_coord_t * s = lv_event_get_param(e);\n        *s = LV_MAX(*s, indic_size);\n\n        /*Calculate the indicator area*/\n        lv_coord_t bg_left = lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n        lv_coord_t bg_right = lv_obj_get_style_pad_right(obj, LV_PART_MAIN);\n        lv_coord_t bg_top = lv_obj_get_style_pad_top(obj, LV_PART_MAIN);\n        lv_coord_t bg_bottom = lv_obj_get_style_pad_bottom(obj, LV_PART_MAIN);\n\n        lv_coord_t pad = LV_MIN4(bg_left, bg_right, bg_top, bg_bottom);\n        if(pad < 0) {\n            *s = LV_MAX(*s, -pad);\n        }\n    }\n    else if(code == LV_EVENT_PRESSED || code == LV_EVENT_RELEASED) {\n        lv_bar_t * bar = (lv_bar_t *)obj;\n        lv_obj_invalidate_area(obj, &bar->indic_area);\n    }\n    else if(code == LV_EVENT_DRAW_MAIN) {\n        draw_indic(e);\n    }\n}"}, "draw_indic": {"type": "Function", "def": "static void draw_indic(lv_event_t * e)", "sline": 235, "body": "{\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_bar_t * bar = (lv_bar_t *)obj;\n\n    const lv_area_t * clip_area = lv_event_get_param(e);\n\n    lv_area_t bar_coords;\n    lv_obj_get_coords(obj, &bar_coords);\n\n    lv_coord_t transf_w = lv_obj_get_style_transform_width(obj, LV_PART_MAIN);\n    lv_coord_t transf_h = lv_obj_get_style_transform_height(obj, LV_PART_MAIN);\n    bar_coords.x1 -= transf_w;\n    bar_coords.x2 += transf_w;\n    bar_coords.y1 -= transf_h;\n    bar_coords.y2 += transf_h;\n    lv_coord_t barw = lv_area_get_width(&bar_coords);\n    lv_coord_t barh = lv_area_get_height(&bar_coords);\n    int32_t range = bar->max_value - bar->min_value;\n    bool hor = barw >= barh ? true : false;\n    bool sym = false;\n    if(bar->mode == LV_BAR_MODE_SYMMETRICAL && bar->min_value < 0 && bar->max_value > 0 &&\n       bar->start_value == bar->min_value) sym = true;\n\n    /*Calculate the indicator area*/\n    lv_coord_t bg_left = lv_obj_get_style_pad_left(obj,     LV_PART_MAIN);\n    lv_coord_t bg_right = lv_obj_get_style_pad_right(obj,   LV_PART_MAIN);\n    lv_coord_t bg_top = lv_obj_get_style_pad_top(obj,       LV_PART_MAIN);\n    lv_coord_t bg_bottom = lv_obj_get_style_pad_bottom(obj, LV_PART_MAIN);\n    /*Respect padding and minimum width/height too*/\n    lv_area_copy(&bar->indic_area, &bar_coords);\n    bar->indic_area.x1 += bg_left;\n    bar->indic_area.x2 -= bg_right;\n    bar->indic_area.y1 += bg_top;\n    bar->indic_area.y2 -= bg_bottom;\n\n    if(hor && lv_area_get_height(&bar->indic_area) < LV_BAR_SIZE_MIN) {\n        bar->indic_area.y1 = obj->coords.y1 + (barh / 2) - (LV_BAR_SIZE_MIN / 2);\n        bar->indic_area.y2 = bar->indic_area.y1 + LV_BAR_SIZE_MIN;\n    }\n    else if(!hor && lv_area_get_width(&bar->indic_area) < LV_BAR_SIZE_MIN) {\n        bar->indic_area.x1 = obj->coords.x1 + (barw / 2) - (LV_BAR_SIZE_MIN / 2);\n        bar->indic_area.x2 = bar->indic_area.x1 + LV_BAR_SIZE_MIN;\n    }\n\n    lv_coord_t indicw = lv_area_get_width(&bar->indic_area);\n    lv_coord_t indich = lv_area_get_height(&bar->indic_area);\n\n    /*Calculate the indicator length*/\n    lv_coord_t anim_length = hor ? indicw : indich;\n\n    lv_coord_t anim_cur_value_x, anim_start_value_x;\n\n    lv_coord_t * axis1, * axis2;\n    lv_coord_t (*indic_length_calc)(const lv_area_t * area);\n\n    if(hor) {\n        axis1 = &bar->indic_area.x1;\n        axis2 = &bar->indic_area.x2;\n        indic_length_calc = lv_area_get_width;\n    }\n    else {\n        axis1 = &bar->indic_area.y1;\n        axis2 = &bar->indic_area.y2;\n        indic_length_calc = lv_area_get_height;\n    }\n\n    if(LV_BAR_IS_ANIMATING(bar->start_value_anim)) {\n        lv_coord_t anim_start_value_start_x =\n            (int32_t)((int32_t)anim_length * (bar->start_value_anim.anim_start - bar->min_value)) / range;\n        lv_coord_t anim_start_value_end_x =\n            (int32_t)((int32_t)anim_length * (bar->start_value_anim.anim_end - bar->min_value)) / range;\n\n        anim_start_value_x = (((anim_start_value_end_x - anim_start_value_start_x) * bar->start_value_anim.anim_state) /\n                              LV_BAR_ANIM_STATE_END);\n\n        anim_start_value_x += anim_start_value_start_x;\n    }\n    else {\n        anim_start_value_x = (int32_t)((int32_t)anim_length * (bar->start_value - bar->min_value)) / range;\n    }\n\n    if(LV_BAR_IS_ANIMATING(bar->cur_value_anim)) {\n        lv_coord_t anim_cur_value_start_x =\n            (int32_t)((int32_t)anim_length * (bar->cur_value_anim.anim_start - bar->min_value)) / range;\n        lv_coord_t anim_cur_value_end_x =\n            (int32_t)((int32_t)anim_length * (bar->cur_value_anim.anim_end - bar->min_value)) / range;\n\n        anim_cur_value_x = anim_cur_value_start_x + (((anim_cur_value_end_x - anim_cur_value_start_x) *\n                                                      bar->cur_value_anim.anim_state) /\n                                                     LV_BAR_ANIM_STATE_END);\n    }\n    else {\n        anim_cur_value_x = (int32_t)((int32_t)anim_length * (bar->cur_value - bar->min_value)) / range;\n    }\n\n    lv_base_dir_t base_dir = lv_obj_get_style_base_dir(obj, LV_PART_MAIN);\n    if(hor && base_dir == LV_BASE_DIR_RTL) {\n        /*Swap axes*/\n        lv_coord_t * tmp;\n        tmp = axis1;\n        axis1 = axis2;\n        axis2 = tmp;\n        anim_cur_value_x = -anim_cur_value_x;\n        anim_start_value_x = -anim_start_value_x;\n    }\n\n    /*Set the indicator length*/\n    if(hor) {\n        *axis2 = *axis1 + anim_cur_value_x;\n        *axis1 += anim_start_value_x;\n    }\n    else {\n        *axis1 = *axis2 - anim_cur_value_x + 1;\n        *axis2 -= anim_start_value_x;\n    }\n    if(sym) {\n        lv_coord_t zero, shift;\n        shift = (-bar->min_value * anim_length) / range;\n        if(hor) {\n            zero = *axis1 + shift;\n            if(*axis2 > zero)\n                *axis1 = zero;\n            else {\n                *axis1 = *axis2;\n                *axis2 = zero;\n            }\n        }\n        else {\n            zero = *axis2 - shift + 1;\n            if(*axis1 > zero)\n                *axis2 = zero;\n            else {\n                *axis2 = *axis1;\n                *axis1 = zero;\n            }\n            if(*axis2 < *axis1) {\n                /*swap*/\n                zero = *axis1;\n                *axis1 = *axis2;\n                *axis2 = zero;\n            }\n        }\n    }\n\n    /*Do not draw a zero length indicator but at least call the draw part events*/\n    if(!sym && indic_length_calc(&bar->indic_area) <= 1) {\n\n        lv_obj_draw_part_dsc_t part_draw_dsc;\n        lv_obj_draw_dsc_init(&part_draw_dsc, clip_area);\n        part_draw_dsc.part = LV_PART_INDICATOR;\n        part_draw_dsc.class_p = MY_CLASS;\n        part_draw_dsc.type = LV_BAR_DRAW_PART_INDICATOR;\n        part_draw_dsc.draw_area = &bar->indic_area;\n\n        lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n        lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n        return;\n    }\n\n    lv_coord_t bg_radius = lv_obj_get_style_radius(obj, LV_PART_MAIN);\n    lv_coord_t short_side = LV_MIN(barw, barh);\n    if(bg_radius > short_side >> 1) bg_radius = short_side >> 1;\n\n    lv_area_t indic_area;\n    lv_area_copy(&indic_area, &bar->indic_area);\n\n    lv_draw_rect_dsc_t draw_rect_dsc;\n    lv_draw_rect_dsc_init(&draw_rect_dsc);\n    lv_obj_init_draw_rect_dsc(obj, LV_PART_INDICATOR, &draw_rect_dsc);\n\n    lv_obj_draw_part_dsc_t part_draw_dsc;\n    lv_obj_draw_dsc_init(&part_draw_dsc, clip_area);\n    part_draw_dsc.part = LV_PART_INDICATOR;\n    part_draw_dsc.class_p = MY_CLASS;\n    part_draw_dsc.type = LV_BAR_DRAW_PART_INDICATOR;\n    part_draw_dsc.rect_dsc = &draw_rect_dsc;\n    part_draw_dsc.draw_area = &bar->indic_area;\n\n    lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n\n    /*Draw only the shadow if the indicator is long enough.\n     *The radius of the bg and the indicator can make a strange shape where\n     *it'd be very difficult to draw shadow.*/\n    if((hor && lv_area_get_width(&bar->indic_area) > bg_radius * 2) ||\n       (!hor && lv_area_get_height(&bar->indic_area) > bg_radius * 2)) {\n        lv_opa_t bg_opa = draw_rect_dsc.bg_opa;\n        lv_opa_t bg_img_opa = draw_rect_dsc.bg_img_opa;\n        lv_opa_t border_opa = draw_rect_dsc.border_opa;\n        draw_rect_dsc.bg_opa = LV_OPA_TRANSP;\n        draw_rect_dsc.bg_img_opa = LV_OPA_TRANSP;\n        draw_rect_dsc.border_opa = LV_OPA_TRANSP;\n\n        lv_draw_rect(&bar->indic_area, clip_area, &draw_rect_dsc);\n\n        draw_rect_dsc.bg_opa = bg_opa;\n        draw_rect_dsc.bg_img_opa = bg_img_opa;\n        draw_rect_dsc.border_opa = border_opa;\n    }\n\n#if LV_DRAW_COMPLEX\n    lv_draw_mask_radius_param_t mask_bg_param;\n    lv_area_t bg_mask_area;\n    bg_mask_area.x1 = obj->coords.x1 + bg_left;\n    bg_mask_area.x2 = obj->coords.x2 - bg_right;\n    bg_mask_area.y1 = obj->coords.y1 + bg_top;\n    bg_mask_area.y2 = obj->coords.y2 - bg_bottom;\n\n    lv_draw_mask_radius_init(&mask_bg_param, &bg_mask_area, bg_radius, false);\n    lv_coord_t mask_bg_id = lv_draw_mask_add(&mask_bg_param, NULL);\n#endif\n\n    /*Draw_only the background and background image*/\n    lv_opa_t shadow_opa = draw_rect_dsc.shadow_opa;\n    lv_opa_t border_opa = draw_rect_dsc.border_opa;\n    draw_rect_dsc.border_opa = LV_OPA_TRANSP;\n    draw_rect_dsc.shadow_opa = LV_OPA_TRANSP;\n\n    /*Get the max possible indicator area. The gradient should be applied on this*/\n    lv_area_t mask_indic_max_area;\n    lv_area_copy(&mask_indic_max_area, &bar_coords);\n    mask_indic_max_area.x1 += bg_left;\n    mask_indic_max_area.y1 += bg_top;\n    mask_indic_max_area.x2 -= bg_right;\n    mask_indic_max_area.y2 -= bg_bottom;\n    if(hor && lv_area_get_height(&mask_indic_max_area) < LV_BAR_SIZE_MIN) {\n        mask_indic_max_area.y1 = obj->coords.y1 + (barh / 2) - (LV_BAR_SIZE_MIN / 2);\n        mask_indic_max_area.y2 = mask_indic_max_area.y1 + LV_BAR_SIZE_MIN;\n    }\n    else if(!hor && lv_area_get_width(&mask_indic_max_area) < LV_BAR_SIZE_MIN) {\n        mask_indic_max_area.x1 = obj->coords.x1 + (barw / 2) - (LV_BAR_SIZE_MIN / 2);\n        mask_indic_max_area.x2 = mask_indic_max_area.x1 + LV_BAR_SIZE_MIN;\n    }\n\n#if LV_DRAW_COMPLEX\n    /*Create a mask to the current indicator area to see only this part from the whole gradient.*/\n    lv_draw_mask_radius_param_t mask_indic_param;\n    lv_draw_mask_radius_init(&mask_indic_param, &bar->indic_area, draw_rect_dsc.radius, false);\n    int16_t mask_indic_id = lv_draw_mask_add(&mask_indic_param, NULL);\n#endif\n\n    lv_draw_rect(&mask_indic_max_area, clip_area, &draw_rect_dsc);\n    draw_rect_dsc.border_opa = border_opa;\n    draw_rect_dsc.shadow_opa = shadow_opa;\n\n    /*Draw the border*/\n    draw_rect_dsc.bg_opa = LV_OPA_TRANSP;\n    draw_rect_dsc.bg_img_opa = LV_OPA_TRANSP;\n    draw_rect_dsc.shadow_opa = LV_OPA_TRANSP;\n    lv_draw_rect(&bar->indic_area, clip_area, &draw_rect_dsc);\n\n#if LV_DRAW_COMPLEX\n    lv_draw_mask_free_param(&mask_indic_param);\n    lv_draw_mask_free_param(&mask_bg_param);\n    lv_draw_mask_remove_id(mask_indic_id);\n    lv_draw_mask_remove_id(mask_bg_id);\n#endif\n\n    lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n}"}, "lv_bar_set_value_with_anim": {"type": "Function", "def": "static void lv_bar_set_value_with_anim(lv_obj_t * obj, int32_t new_value, int32_t * value_ptr,\n                                       _lv_bar_anim_t * anim_info, lv_anim_enable_t en)", "sline": 558, "body": "{\n    if(en == LV_ANIM_OFF) {\n        *value_ptr = new_value;\n        lv_obj_invalidate((lv_obj_t *)obj);\n    }\n    else {\n        /*No animation in progress -> simply set the values*/\n        if(anim_info->anim_state == LV_BAR_ANIM_STATE_INV) {\n            anim_info->anim_start = *value_ptr;\n            anim_info->anim_end   = new_value;\n        }\n        /*Animation in progress. Start from the animation end value*/\n        else {\n            anim_info->anim_start = anim_info->anim_end;\n            anim_info->anim_end   = new_value;\n        }\n        *value_ptr = new_value;\n        /*Stop the previous animation if it exists*/\n        lv_anim_del(anim_info, NULL);\n\n        lv_anim_t a;\n        lv_anim_init(&a);\n        lv_anim_set_var(&a, anim_info);\n        lv_anim_set_exec_cb(&a, lv_bar_anim);\n        lv_anim_set_values(&a, LV_BAR_ANIM_STATE_START, LV_BAR_ANIM_STATE_END);\n        lv_anim_set_ready_cb(&a, lv_bar_anim_ready);\n        lv_anim_set_time(&a, lv_obj_get_style_anim_time(obj, LV_PART_MAIN));\n        lv_anim_start(&a);\n    }\n}"}, "lv_bar_init_anim": {"type": "Function", "def": "static void lv_bar_init_anim(lv_obj_t * obj, _lv_bar_anim_t * bar_anim)", "sline": 591, "body": "{\n    bar_anim->bar = obj;\n    bar_anim->anim_start = 0;\n    bar_anim->anim_end = 0;\n    bar_anim->anim_state = LV_BAR_ANIM_STATE_INV;\n}"}, "lv_bar_anim": {"type": "Function", "def": "static void lv_bar_anim(void * var, int32_t value)", "sline": 537, "body": "{\n    _lv_bar_anim_t * bar_anim = var;\n    bar_anim->anim_state    = value;\n    lv_obj_invalidate(bar_anim->bar);\n}"}, "lv_bar_anim_ready": {"type": "Function", "def": "static void lv_bar_anim_ready(lv_anim_t * a)", "sline": 544, "body": "{\n    _lv_bar_anim_t * var = a->var;\n    lv_obj_t * obj = (lv_obj_t *)var->bar;\n    lv_bar_t * bar = (lv_bar_t *)obj;\n\n    var->anim_state = LV_BAR_ANIM_STATE_INV;\n    if(var == &bar->cur_value_anim)\n        bar->cur_value = var->anim_end;\n    else if(var == &bar->start_value_anim)\n        bar->start_value = var->anim_end;\n    lv_obj_invalidate(var->bar);\n}"}, "lv_bar_class": {"type": "Variable", "def": "const lv_obj_class_t lv_bar_class = {\n    .constructor_cb = lv_bar_constructor,\n    .destructor_cb = lv_bar_destructor,\n    .event_cb = lv_bar_event,\n    .width_def = LV_DPI_DEF * 2,\n    .height_def = LV_DPI_DEF / 10,\n    .instance_size = sizeof(lv_bar_t),\n    .base_class = &lv_obj_class\n}", "sline": 60}, "lv_bar_create": {"type": "Function", "def": "lv_obj_t * lv_bar_create(lv_obj_t * parent)", "sline": 78, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_bar_set_value": {"type": "Function", "def": "void lv_bar_set_value(lv_obj_t * obj, int32_t value, lv_anim_enable_t anim)", "sline": 90, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_bar_t * bar = (lv_bar_t *)obj;\n\n    if(bar->cur_value == value) return;\n\n    value = LV_CLAMP(bar->min_value, value, bar->max_value);\n    value = value < bar->start_value ? bar->start_value : value; /*Can't be smaller than the left value*/\n\n    if(bar->cur_value == value) return;\n    lv_bar_set_value_with_anim(obj, value, &bar->cur_value, &bar->cur_value_anim, anim);\n}"}, "lv_bar_set_start_value": {"type": "Function", "def": "void lv_bar_set_start_value(lv_obj_t * obj, int32_t value, lv_anim_enable_t anim)", "sline": 104, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_bar_t * bar = (lv_bar_t *)obj;\n\n    value = LV_CLAMP(bar->min_value, value, bar->max_value);\n    value = value > bar->cur_value ? bar->cur_value : value; /*Can't be greater than the right value*/\n\n    if(bar->start_value == value) return;\n    lv_bar_set_value_with_anim(obj, value, &bar->start_value, &bar->start_value_anim, anim);\n}"}, "lv_bar_set_range": {"type": "Function", "def": "void lv_bar_set_range(lv_obj_t * obj, int32_t min, int32_t max)", "sline": 117, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_bar_t * bar = (lv_bar_t *)obj;\n\n    if(bar->min_value == min && bar->max_value == max) return;\n\n    bar->max_value = max;\n    bar->min_value = min;\n\n    if(lv_bar_get_mode(obj) != LV_BAR_MODE_RANGE)\n        bar->start_value = min;\n\n    if(bar->cur_value > max) {\n        bar->cur_value = max;\n        lv_bar_set_value(obj, bar->cur_value, false);\n    }\n    if(bar->cur_value < min) {\n        bar->cur_value = min;\n        lv_bar_set_value(obj, bar->cur_value, false);\n    }\n    lv_obj_invalidate(obj);\n}"}, "lv_bar_set_mode": {"type": "Function", "def": "void lv_bar_set_mode(lv_obj_t * obj, lv_bar_mode_t mode)", "sline": 142, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_bar_t * bar = (lv_bar_t *)obj;\n\n    bar->mode = mode;\n    if(bar->mode != LV_BAR_MODE_RANGE) {\n        bar->start_value = bar->min_value;\n    }\n\n    lv_obj_invalidate(obj);\n}"}, "lv_bar_get_value": {"type": "Function", "def": "int32_t lv_bar_get_value(const lv_obj_t * obj)", "sline": 159, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_bar_t * bar = (lv_bar_t *)obj;\n\n    return LV_BAR_GET_ANIM_VALUE(bar->cur_value, bar->cur_value_anim);\n}"}, "lv_bar_get_start_value": {"type": "Function", "def": "int32_t lv_bar_get_start_value(const lv_obj_t * obj)", "sline": 167, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_bar_t * bar = (lv_bar_t *)obj;\n\n    if(bar->mode != LV_BAR_MODE_RANGE) return bar->min_value;\n\n    return LV_BAR_GET_ANIM_VALUE(bar->start_value, bar->start_value_anim);\n}"}, "lv_bar_get_min_value": {"type": "Function", "def": "int32_t lv_bar_get_min_value(const lv_obj_t * obj)", "sline": 177, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_bar_t * bar = (lv_bar_t *)obj;\n    return bar->min_value;\n}"}, "lv_bar_get_max_value": {"type": "Function", "def": "int32_t lv_bar_get_max_value(const lv_obj_t * obj)", "sline": 184, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_bar_t * bar = (lv_bar_t *)obj;\n\n    return bar->max_value;\n}"}, "lv_bar_get_mode": {"type": "Function", "def": "lv_bar_mode_t lv_bar_get_mode(lv_obj_t * obj)", "sline": 192, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_bar_t * bar = (lv_bar_t *)obj;\n\n    return bar->mode;\n}"}, "carbit_updater/lvgl/src/widgets/lv_bar.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_bar.c"}}, "carbit_updater/lv_drivers/gtkdrv/gtkdrv.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 20}, "carbit_updater/lv_drivers/gtkdrv/gtkdrv.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/gtkdrv/gtkdrv.h"}}, "carbit_updater/lvgl/src/extra/libs/gif/lv_gif.h": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 17}, "carbit_updater/lvgl/src/extra/libs/gif/lv_gif.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/gif/lv_gif.h"}}, "carbit_updater/lv_drivers/win_drv.c": {"win_drv": {"type": "Variable", "def": "#include win_drv.h", "sline": 9, "include": ["carbit_updater/lv_drivers/win_drv.h", null]}, "carbit_updater/lv_drivers/win_drv.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/win_drv.c"}}, "carbit_updater/lvgl/src/extra/libs/sjpg/lv_sjpg.h": {"carbit_updater/lvgl/src/extra/libs/sjpg/lv_sjpg.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/sjpg/lv_sjpg.h"}}, "carbit_updater/lvgl/src/extra/widgets/spinner/lv_spinner.c": {"lv_spinner": {"type": "Variable", "def": "#include lv_spinner.h", "sline": 9, "include": ["carbit_updater/lvgl/src/extra/widgets/spinner/lv_spinner.h", null]}, "lv_spinner_constructor": {"type": "Function", "def": "static void lv_spinner_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 66, "body": "{\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    LV_UNUSED(class_p);\n\n    lv_obj_clear_flag(obj, LV_OBJ_FLAG_CLICKABLE);\n\n    lv_anim_t a;\n    lv_anim_init(&a);\n    lv_anim_set_var(&a, obj);\n    lv_anim_set_exec_cb(&a, arc_anim_end_angle);\n    lv_anim_set_repeat_count(&a, LV_ANIM_REPEAT_INFINITE);\n    lv_anim_set_time(&a, time_param);\n    lv_anim_set_values(&a, arc_length_param, 360 + arc_length_param);\n    lv_anim_start(&a);\n\n    lv_anim_set_path_cb(&a, lv_anim_path_ease_in_out);\n    lv_anim_set_values(&a, 0, 360);\n    lv_anim_set_exec_cb(&a, arc_anim_start_angle);\n    lv_anim_start(&a);\n\n    lv_arc_set_bg_angles(obj, 0, 360);\n    lv_arc_set_rotation(obj, 270);\n}"}, "arc_anim_start_angle": {"type": "Function", "def": "static void arc_anim_start_angle(void * obj, int32_t v)", "sline": 93, "body": "{\n    lv_arc_set_start_angle(obj, (uint16_t) v);\n}"}, "arc_anim_end_angle": {"type": "Function", "def": "static void arc_anim_end_angle(void * obj, int32_t v)", "sline": 99, "body": "{\n    lv_arc_set_end_angle(obj, (uint16_t) v);\n}"}, "lv_spinner_class": {"type": "Variable", "def": "const lv_obj_class_t lv_spinner_class = {\n    .base_class = &lv_arc_class,\n    .constructor_cb = lv_spinner_constructor\n}", "sline": 30}, "time_param": {"type": "Variable", "def": "static uint32_t time_param", "sline": 35}, "arc_length_param": {"type": "Variable", "def": "static uint32_t arc_length_param", "sline": 36}, "lv_spinner_create": {"type": "Function", "def": "lv_obj_t * lv_spinner_create(lv_obj_t * parent, uint32_t time, uint32_t arc_length)", "sline": 51, "body": "{\n    time_param = time;\n    arc_length_param = arc_length;\n\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_spinner_class, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "carbit_updater/lvgl/src/extra/widgets/spinner/lv_spinner.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/spinner/lv_spinner.c"}}, "carbit_updater/lvgl/src/extra/widgets/imgbtn/lv_imgbtn.c": {"lv_imgbtn": {"type": "Variable", "def": "#include lv_imgbtn.h", "sline": 10, "include": ["carbit_updater/lvgl/src/extra/widgets/imgbtn/lv_imgbtn.h", null]}, "lv_imgbtn_constructor": {"type": "Function", "def": "static void lv_imgbtn_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 163, "body": "{\n    LV_UNUSED(class_p);\n    lv_imgbtn_t * imgbtn = (lv_imgbtn_t *)obj;\n    /*Initialize the allocated 'ext'*/\n    lv_memset_00((void *)imgbtn->img_src_mid, sizeof(imgbtn->img_src_mid));\n    lv_memset_00(imgbtn->img_src_left, sizeof(imgbtn->img_src_left));\n    lv_memset_00(imgbtn->img_src_right, sizeof(imgbtn->img_src_right));\n\n    imgbtn->act_cf = LV_IMG_CF_UNKNOWN;\n}"}, "draw_main": {"type": "Function", "def": "static void draw_main(lv_event_t * e)", "sline": 209, "body": "{\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_imgbtn_t * imgbtn = (lv_imgbtn_t *)obj;\n    const lv_area_t * clip_area = lv_event_get_param(e);\n\n    /*Just draw_main an image*/\n    lv_imgbtn_state_t state  = suggest_state(obj, get_state(obj));\n\n    /*Simply draw the middle src if no tiled*/\n    const void * src = imgbtn->img_src_left[state];\n\n    lv_coord_t tw = lv_obj_get_style_transform_width(obj, LV_PART_MAIN);\n    lv_coord_t th = lv_obj_get_style_transform_height(obj, LV_PART_MAIN);\n    lv_area_t coords;\n    lv_area_copy(&coords, &obj->coords);\n    coords.x1 -= tw;\n    coords.x2 += tw;\n    coords.y1 -= th;\n    coords.y2 += th;\n\n    lv_draw_img_dsc_t img_dsc;\n    lv_draw_img_dsc_init(&img_dsc);\n    lv_obj_init_draw_img_dsc(obj, LV_PART_MAIN, &img_dsc);\n\n    lv_img_header_t header;\n    lv_area_t coords_part;\n    lv_coord_t left_w = 0;\n    lv_coord_t right_w = 0;\n\n    if(src) {\n        lv_img_decoder_get_info(src, &header);\n        left_w = header.w;\n        coords_part.x1 = coords.x1;\n        coords_part.y1 = coords.y1;\n        coords_part.x2 = coords.x1 + header.w - 1;\n        coords_part.y2 = coords.y1 + header.h - 1;\n        lv_draw_img(&coords_part, clip_area, src, &img_dsc);\n    }\n\n    src = imgbtn->img_src_right[state];\n    if(src) {\n        lv_img_decoder_get_info(src, &header);\n        right_w = header.w;\n        coords_part.x1 = coords.x2 - header.w + 1;\n        coords_part.y1 = coords.y1;\n        coords_part.x2 = coords.x2;\n        coords_part.y2 = coords.y1 + header.h - 1;\n        lv_draw_img(&coords_part, clip_area, src, &img_dsc);\n    }\n\n    src = imgbtn->img_src_mid[state];\n    if(src) {\n        lv_area_t clip_center_area;\n        clip_center_area.x1 = coords.x1 + left_w;\n        clip_center_area.x2 = coords.x2 - right_w;\n        clip_center_area.y1 = coords.y1;\n        clip_center_area.y2 = coords.y2;\n\n        bool comm_res;\n        comm_res = _lv_area_intersect(&clip_center_area, &clip_center_area, clip_area);\n        if(comm_res) {\n            lv_coord_t i;\n            lv_img_decoder_get_info(src, &header);\n\n            coords_part.x1 = coords.x1 + left_w;\n            coords_part.y1 = coords.y1;\n            coords_part.x2 = coords_part.x1 + header.w - 1;\n            coords_part.y2 = coords_part.y1 + header.h - 1;\n\n            for(i = coords_part.x1; i < (lv_coord_t)(clip_center_area.x2 + header.w - 1); i += header.w) {\n                lv_draw_img(&coords_part, &clip_center_area, src, &img_dsc);\n                coords_part.x1 = coords_part.x2 + 1;\n                coords_part.x2 += header.w;\n            }\n        }\n    }\n}"}, "lv_imgbtn_event": {"type": "Function", "def": "static void lv_imgbtn_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 176, "body": "{\n    LV_UNUSED(class_p);\n\n    lv_res_t res = lv_obj_event_base(&lv_imgbtn_class, e);\n    if(res != LV_RES_OK) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n    if(code == LV_EVENT_PRESSED || code == LV_EVENT_RELEASED || code == LV_EVENT_PRESS_LOST) {\n        refr_img(obj);\n    }\n    else if(code == LV_EVENT_DRAW_MAIN) {\n        draw_main(e);\n    }\n    else if(code == LV_EVENT_COVER_CHECK) {\n        lv_cover_check_info_t * info = lv_event_get_param(e);\n        if(info->res != LV_COVER_RES_MASKED) info->res = LV_COVER_RES_NOT_COVER;\n    }\n    else if(code == LV_EVENT_GET_SELF_SIZE) {\n        lv_point_t * p = lv_event_get_self_size_info(e);\n        lv_imgbtn_t * imgbtn = (lv_imgbtn_t *)obj;\n        lv_imgbtn_state_t state  = suggest_state(obj, get_state(obj));\n        if(imgbtn->img_src_left[state] == NULL &&\n           imgbtn->img_src_mid[state] != NULL &&\n           imgbtn->img_src_right[state] == NULL) {\n            lv_img_header_t header;\n            lv_img_decoder_get_info(imgbtn->img_src_mid[state], &header);\n            p->x = LV_MAX(p->x, header.w);\n        }\n    }\n}"}, "refr_img": {"type": "Function", "def": "static void refr_img(lv_obj_t * obj)", "sline": 288, "body": "{\n    lv_imgbtn_t * imgbtn = (lv_imgbtn_t *)obj;\n    lv_imgbtn_state_t state  = suggest_state(obj, get_state(obj));\n    lv_img_header_t header;\n\n    const void * src = imgbtn->img_src_mid[state];\n    if(src == NULL) return;\n\n    lv_res_t info_res = LV_RES_OK;\n    info_res = lv_img_decoder_get_info(src, &header);\n\n    if(info_res == LV_RES_OK) {\n        imgbtn->act_cf = header.cf;\n        lv_obj_refresh_self_size(obj);\n        lv_obj_set_height(obj, header.h); /*Keep the user defined width*/\n    }\n    else {\n        imgbtn->act_cf = LV_IMG_CF_UNKNOWN;\n    }\n\n    lv_obj_invalidate(obj);\n}"}, "suggest_state": {"type": "Function", "def": "static lv_imgbtn_state_t suggest_state(lv_obj_t * obj, lv_imgbtn_state_t state)", "sline": 319, "body": "{\n    lv_imgbtn_t * imgbtn = (lv_imgbtn_t *)obj;\n    if(imgbtn->img_src_mid[state] == NULL) {\n        switch(state) {\n            case LV_IMGBTN_STATE_PRESSED:\n                if(imgbtn->img_src_mid[LV_IMGBTN_STATE_RELEASED]) return LV_IMGBTN_STATE_RELEASED;\n                break;\n            case LV_IMGBTN_STATE_CHECKED_RELEASED:\n                if(imgbtn->img_src_mid[LV_IMGBTN_STATE_RELEASED]) return LV_IMGBTN_STATE_RELEASED;\n                break;\n            case LV_IMGBTN_STATE_CHECKED_PRESSED:\n                if(imgbtn->img_src_mid[LV_IMGBTN_STATE_CHECKED_RELEASED]) return LV_IMGBTN_STATE_CHECKED_RELEASED;\n                if(imgbtn->img_src_mid[LV_IMGBTN_STATE_PRESSED]) return LV_IMGBTN_STATE_PRESSED;\n                if(imgbtn->img_src_mid[LV_IMGBTN_STATE_RELEASED]) return LV_IMGBTN_STATE_RELEASED;\n                break;\n            case LV_IMGBTN_STATE_DISABLED:\n                if(imgbtn->img_src_mid[LV_IMGBTN_STATE_RELEASED]) return LV_IMGBTN_STATE_RELEASED;\n                break;\n            case LV_IMGBTN_STATE_CHECKED_DISABLED:\n                if(imgbtn->img_src_mid[LV_IMGBTN_STATE_CHECKED_RELEASED]) return LV_IMGBTN_STATE_CHECKED_RELEASED;\n                if(imgbtn->img_src_mid[LV_IMGBTN_STATE_RELEASED]) return LV_IMGBTN_STATE_RELEASED;\n                break;\n            default:\n                break;\n        }\n    }\n\n    return state;\n}"}, "get_state": {"type": "Function", "def": "lv_imgbtn_state_t get_state(const lv_obj_t * imgbtn)", "sline": 350, "body": "{\n    LV_ASSERT_OBJ(imgbtn, MY_CLASS);\n\n    lv_state_t obj_state = lv_obj_get_state(imgbtn);\n\n    if(obj_state & LV_STATE_DISABLED) {\n        if(obj_state & LV_STATE_CHECKED) return LV_IMGBTN_STATE_CHECKED_DISABLED;\n        else return LV_IMGBTN_STATE_DISABLED;\n    }\n\n    if(obj_state & LV_STATE_CHECKED) {\n        if(obj_state & LV_STATE_PRESSED) return LV_IMGBTN_STATE_CHECKED_PRESSED;\n        else return LV_IMGBTN_STATE_CHECKED_RELEASED;\n    }\n    else {\n        if(obj_state & LV_STATE_PRESSED) return LV_IMGBTN_STATE_PRESSED;\n        else return LV_IMGBTN_STATE_RELEASED;\n    }\n}"}, "lv_imgbtn_class": {"type": "Variable", "def": "const lv_obj_class_t lv_imgbtn_class = {\n    .base_class = &lv_obj_class,\n    .instance_size = sizeof(lv_imgbtn_t),\n    .constructor_cb = lv_imgbtn_constructor,\n    .event_cb = lv_imgbtn_event,\n}", "sline": 36}, "lv_imgbtn_create": {"type": "Function", "def": "lv_obj_t * lv_imgbtn_create(lv_obj_t * parent)", "sline": 56, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_imgbtn_set_src": {"type": "Function", "def": "void lv_imgbtn_set_src(lv_obj_t * obj, lv_imgbtn_state_t state, const void * src_left, const void * src_mid,\n                       const void * src_right)", "sline": 79, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_imgbtn_t * imgbtn = (lv_imgbtn_t *)obj;\n\n    imgbtn->img_src_left[state] = src_left;\n    imgbtn->img_src_mid[state] = src_mid;\n    imgbtn->img_src_right[state] = src_right;\n\n    refr_img(obj);\n}"}, "lv_imgbtn_set_state": {"type": "Function", "def": "void lv_imgbtn_set_state(lv_obj_t * obj, lv_imgbtn_state_t state)", "sline": 93, "body": "{\n\tLV_ASSERT_OBJ(obj, MY_CLASS);\n\n\tlv_state_t obj_state = LV_STATE_DEFAULT;\n\tif(state == LV_IMGBTN_STATE_PRESSED || state == LV_IMGBTN_STATE_CHECKED_PRESSED) obj_state |= LV_STATE_PRESSED;\n\tif(state == LV_IMGBTN_STATE_DISABLED || state == LV_IMGBTN_STATE_CHECKED_DISABLED) obj_state |= LV_STATE_DISABLED;\n\tif(state == LV_IMGBTN_STATE_CHECKED_DISABLED || state == LV_IMGBTN_STATE_CHECKED_PRESSED || state == LV_IMGBTN_STATE_CHECKED_RELEASED) {\n\t\tobj_state |= LV_STATE_CHECKED;\n\t}\n\n\tlv_obj_clear_state(obj, LV_STATE_CHECKED | LV_STATE_PRESSED | LV_STATE_DISABLED);\n\tlv_obj_add_state(obj, obj_state);\n\n\trefr_img(obj);\n}"}, "lv_imgbtn_get_src_left": {"type": "Function", "def": "const void * lv_imgbtn_get_src_left(lv_obj_t * obj, lv_imgbtn_state_t state)", "sline": 121, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_imgbtn_t * imgbtn = (lv_imgbtn_t *)obj;\n\n    return imgbtn->img_src_left[state];\n}"}, "lv_imgbtn_get_src_middle": {"type": "Function", "def": "const void * lv_imgbtn_get_src_middle(lv_obj_t * obj, lv_imgbtn_state_t state)", "sline": 136, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_imgbtn_t * imgbtn = (lv_imgbtn_t *)obj;\n\n    return imgbtn->img_src_mid[state];\n}"}, "lv_imgbtn_get_src_right": {"type": "Function", "def": "const void * lv_imgbtn_get_src_right(lv_obj_t * obj, lv_imgbtn_state_t state)", "sline": 150, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_imgbtn_t * imgbtn = (lv_imgbtn_t *)obj;\n\n    return imgbtn->img_src_right[state];\n}"}, "carbit_updater/lvgl/src/extra/widgets/imgbtn/lv_imgbtn.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/imgbtn/lv_imgbtn.c"}}, "carbit_updater/lvgl/src/extra/others/snapshot/lv_snapshot.h": {"stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 16}, "stddef": {"type": "Variable", "def": "#include stddef.h", "sline": 17}, "lv_conf_internal": {"type": "Variable", "def": "#include ../../../lv_conf_internal.h", "sline": 19}, "lv_obj": {"type": "Variable", "def": "#include ../../../core/lv_obj.h", "sline": 20}, "lv_snapshot_take": {"type": "Function", "def": "lv_img_dsc_t * lv_snapshot_take(lv_obj_t * obj, lv_img_cf_t cf)", "sline": 42}, "lv_snapshot_free": {"type": "Function", "def": "void lv_snapshot_free(lv_img_dsc_t * dsc)", "sline": 51}, "lv_snapshot_buf_size_needed": {"type": "Function", "def": "uint32_t lv_snapshot_buf_size_needed(lv_obj_t * obj, lv_img_cf_t cf)", "sline": 60}, "lv_snapshot_take_to_buf": {"type": "Function", "def": "lv_res_t lv_snapshot_take_to_buf(lv_obj_t * obj, lv_img_cf_t cf, lv_img_dsc_t * dsc, void * buf, uint32_t buff_size)", "sline": 72}, "carbit_updater/lvgl/src/extra/others/snapshot/lv_snapshot.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/others/snapshot/lv_snapshot.h"}}, "carbit_updater/lvgl/src/misc/lv_tlsf.c": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 1}, "limits": {"type": "Variable", "def": "#include limits.h", "sline": 4}, "lv_tlsf": {"type": "Variable", "def": "#include lv_tlsf.h", "sline": 5, "include": ["carbit_updater/lvgl/src/misc/lv_tlsf.h", null]}, "lv_mem": {"type": "Variable", "def": "#include lv_mem.h", "sline": 6, "include": ["carbit_updater/lvgl/src/misc/lv_mem.h", null]}, "lv_log": {"type": "Variable", "def": "#include lv_log.h", "sline": 7, "include": ["carbit_updater/lvgl/src/misc/lv_log.h", null]}, "lv_assert": {"type": "Variable", "def": "#include lv_assert.h", "sline": 8, "include": ["carbit_updater/lvgl/src/misc/lv_assert.h", null]}, "tlsf_ffs": {"type": "Function", "def": "tlsf_decl int tlsf_ffs(unsigned int word)", "sline": 94, "body": "{\n    return __builtin_ffs(word) - 1;\n}"}, "tlsf_fls": {"type": "Function", "def": "tlsf_decl int tlsf_fls(unsigned int word)", "sline": 101, "body": "{\n    const int bit = word ? 32 - __builtin_clz(word) : 0;\n    return bit - 1;\n}"}, "tlsf_fls_sizet": {"type": "Function", "def": "tlsf_decl int tlsf_fls_sizet(size_t size)", "sline": 198, "body": "{\n    int high = (int)(size >> 32);\n    int bits = 0;\n    if(high) {\n        bits = 32 + tlsf_fls(high);\n    }\n    else {\n        bits = tlsf_fls((int)size & 0xffffffff);\n\n    }\n    return bits;\n}"}, "tlsf_public": {"type": "Enum", "def": "enum tlsf_public {\n    /* log2 of number of linear subdivisions of block sizes. Larger\n    ** values require more memory in the control structure. Values of\n    ** 4 or 5 are typical.\n    */\n    SL_INDEX_COUNT_LOG2 = 5,\n}", "sline": 222, "docstring": "/* Public constants: may be modified. */"}, "tlsf_private": {"type": "Enum", "def": "enum tlsf_private {\n#if defined (TLSF_64BIT)\n    /* All allocation sizes and addresses are aligned to 8 bytes. */\n    ALIGN_SIZE_LOG2 = 3,\n#else\n    /* All allocation sizes and addresses are aligned to 4 bytes. */\n    ALIGN_SIZE_LOG2 = 2,\n#endif\n    ALIGN_SIZE = (1 << ALIGN_SIZE_LOG2),\n\n    /*\n    ** We support allocations of sizes up to (1 << FL_INDEX_MAX) bits.\n    ** However, because we linearly subdivide the second-level lists, and\n    ** our minimum size granularity is 4 bytes, it doesn't make sense to\n    ** create first-level lists for sizes smaller than SL_INDEX_COUNT * 4,\n    ** or (1 << (SL_INDEX_COUNT_LOG2 + 2)) bytes, as there we will be\n    ** trying to split size ranges into more slots than we have available.\n    ** Instead, we calculate the minimum threshold size, and place all\n    ** blocks below that size into the 0th first-level list.\n    */\n\n#if defined (TLSF_MAX_POOL_SIZE)\n    FL_INDEX_MAX = TLSF_LOG2_CEIL(TLSF_MAX_POOL_SIZE),\n#elif defined (TLSF_64BIT)\n    /*\n    ** TODO: We can increase this to support larger sizes, at the expense\n    ** of more overhead in the TLSF structure.\n    */\n    FL_INDEX_MAX = 32,\n#else\n    FL_INDEX_MAX = 30,\n#endif\n    SL_INDEX_COUNT = (1 << SL_INDEX_COUNT_LOG2),\n    FL_INDEX_SHIFT = (SL_INDEX_COUNT_LOG2 + ALIGN_SIZE_LOG2),\n    FL_INDEX_COUNT = (FL_INDEX_MAX - FL_INDEX_SHIFT + 1),\n\n    SMALL_BLOCK_SIZE = (1 << FL_INDEX_SHIFT),\n}", "sline": 231, "docstring": "/* Private constants: do not modify. */"}, "static_assert297": {"type": "Variable", "def": "tlsf_static_assert(sizeof(int) * CHAR_BIT == 32)", "sline": 297}, "static_assert298": {"type": "Variable", "def": "tlsf_static_assert(sizeof(size_t) * CHAR_BIT >= 32)", "sline": 298}, "static_assert299": {"type": "Variable", "def": "tlsf_static_assert(sizeof(size_t) * CHAR_BIT <= 64)", "sline": 299}, "static_assert302": {"type": "Variable", "def": "tlsf_static_assert(sizeof(unsigned int) * CHAR_BIT >= SL_INDEX_COUNT)", "sline": 302}, "static_assert305": {"type": "Variable", "def": "tlsf_static_assert(ALIGN_SIZE == SMALL_BLOCK_SIZE / SL_INDEX_COUNT)", "sline": 305}, "block_header_t.prev_phys_block": {"type": "Variable", "def": "struct block_header_t * prev_phys_block", "sline": 323, "in_struct": "block_header_t"}, "block_header_t.size": {"type": "Variable", "def": "size_t size", "sline": 326, "in_struct": "block_header_t"}, "block_header_t.next_free": {"type": "Variable", "def": "struct block_header_t * next_free", "sline": 329, "in_struct": "block_header_t"}, "block_header_t.prev_free": {"type": "Variable", "def": "struct block_header_t * prev_free", "sline": 330, "in_struct": "block_header_t"}, "block_header_t": {"type": "Variable", "def": "typedef struct block_header_t {\n    /* Points to the previous physical block. */\n    struct block_header_t * prev_phys_block;\n\n    /* The size of this block, excluding the block header. */\n    size_t size;\n\n    /* Next and previous free blocks. */\n    struct block_header_t * next_free;\n    struct block_header_t * prev_free;\n} block_header_t", "sline": 331}, "block_header_free_bit": {"type": "Variable", "def": "static const size_t block_header_free_bit = 1 << 0", "sline": 339}, "block_header_prev_free_bit": {"type": "Variable", "def": "static const size_t block_header_prev_free_bit = 1 << 1", "sline": 340}, "block_header_overhead": {"type": "Variable", "def": "static const size_t block_header_overhead", "sline": 346}, "block_start_offset": {"type": "Variable", "def": "static const size_t block_start_offset", "sline": 349}, "block_size_min": {"type": "Variable", "def": "static const size_t block_size_min =\n    sizeof(block_header_t) - sizeof(block_header_t *)", "sline": 357}, "block_size_max": {"type": "Variable", "def": "static const size_t block_size_max", "sline": 359}, "control_t.block_null": {"type": "Variable", "def": "block_header_t block_null", "sline": 365, "in_struct": "control_t", "rels": [["block_header_t", null, "Typeof"]]}, "control_t.fl_bitmap": {"type": "Variable", "def": "unsigned int fl_bitmap", "sline": 368, "in_struct": "control_t"}, "control_t.sl_bitmap": {"type": "Variable", "def": "unsigned int sl_bitmap[FL_INDEX_COUNT]", "sline": 369, "in_struct": "control_t"}, "control_t.blocks": {"type": "Variable", "def": "block_header_t * blocks[FL_INDEX_COUNT][SL_INDEX_COUNT]", "sline": 372, "in_struct": "control_t"}, "control_t": {"type": "Variable", "def": "typedef struct control_t {\n    /* Empty lists point at this block to indicate they are free. */\n    block_header_t block_null;\n\n    /* Bitmaps for free lists. */\n    unsigned int fl_bitmap;\n    unsigned int sl_bitmap[FL_INDEX_COUNT];\n\n    /* Head of free lists. */\n    block_header_t * blocks[FL_INDEX_COUNT][SL_INDEX_COUNT];\n} control_t", "sline": 373, "docstring": "/* The TLSF control structure. */"}, "tlsfptr_t": {"type": "Variable", "def": "typedef ptrdiff_t tlsfptr_t", "sline": 376, "docstring": "/* A type used for casting when doing pointer arithmetic. */"}, "block_size": {"type": "Function", "def": "static size_t block_size(const block_header_t * block)", "sline": 382, "body": "{\n    return block->size & ~(block_header_free_bit | block_header_prev_free_bit);\n}"}, "block_set_size": {"type": "Function", "def": "static void block_set_size(block_header_t * block, size_t size)", "sline": 387, "body": "{\n    const size_t oldsize = block->size;\n    block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));\n}"}, "block_is_last": {"type": "Function", "def": "static int block_is_last(const block_header_t * block)", "sline": 393, "body": "{\n    return block_size(block) == 0;\n}"}, "block_is_free": {"type": "Function", "def": "static int block_is_free(const block_header_t * block)", "sline": 398, "body": "{\n    return tlsf_cast(int, block->size & block_header_free_bit);\n}"}, "block_set_free": {"type": "Function", "def": "static void block_set_free(block_header_t * block)", "sline": 403, "body": "{\n    block->size |= block_header_free_bit;\n}"}, "block_set_used": {"type": "Function", "def": "static void block_set_used(block_header_t * block)", "sline": 408, "body": "{\n    block->size &= ~block_header_free_bit;\n}"}, "block_is_prev_free": {"type": "Function", "def": "static int block_is_prev_free(const block_header_t * block)", "sline": 413, "body": "{\n    return tlsf_cast(int, block->size & block_header_prev_free_bit);\n}"}, "block_set_prev_free": {"type": "Function", "def": "static void block_set_prev_free(block_header_t * block)", "sline": 418, "body": "{\n    block->size |= block_header_prev_free_bit;\n}"}, "block_set_prev_used": {"type": "Function", "def": "static void block_set_prev_used(block_header_t * block)", "sline": 423, "body": "{\n    block->size &= ~block_header_prev_free_bit;\n}"}, "block_from_ptr": {"type": "Function", "def": "static block_header_t * block_from_ptr(const void * ptr)", "sline": 428, "body": "{\n    return tlsf_cast(block_header_t *,\n                     tlsf_cast(unsigned char *, ptr) - block_start_offset);\n}"}, "block_to_ptr": {"type": "Function", "def": "static void * block_to_ptr(const block_header_t * block)", "sline": 434, "body": "{\n    return tlsf_cast(void *,\n                     tlsf_cast(unsigned char *, block) + block_start_offset);\n}"}, "offset_to_block": {"type": "Function", "def": "static block_header_t * offset_to_block(const void * ptr, size_t size)", "sline": 441, "docstring": "/* Return location of next block after block of given size. */", "body": "{\n    return tlsf_cast(block_header_t *, tlsf_cast(tlsfptr_t, ptr) + size);\n}"}, "block_prev": {"type": "Function", "def": "static block_header_t * block_prev(const block_header_t * block)", "sline": 447, "docstring": "/* Return location of previous block. */", "body": "{\n    tlsf_assert(block_is_prev_free(block) && \"previous block must be free\");\n    return block->prev_phys_block;\n}"}, "block_next": {"type": "Function", "def": "static block_header_t * block_next(const block_header_t * block)", "sline": 454, "docstring": "/* Return location of next existing block. */", "body": "{\n    block_header_t * next = offset_to_block(block_to_ptr(block),\n                                            block_size(block) - block_header_overhead);\n    tlsf_assert(!block_is_last(block));\n    return next;\n}"}, "block_link_next": {"type": "Function", "def": "static block_header_t * block_link_next(block_header_t * block)", "sline": 463, "docstring": "/* Link a new block with its physical neighbor, return the neighbor. */", "body": "{\n    block_header_t * next = block_next(block);\n    next->prev_phys_block = block;\n    return next;\n}"}, "block_mark_as_free": {"type": "Function", "def": "static void block_mark_as_free(block_header_t * block)", "sline": 470, "body": "{\n    /* Link the block to the next block, first. */\n    block_header_t * next = block_link_next(block);\n    block_set_prev_free(next);\n    block_set_free(block);\n}"}, "block_mark_as_used": {"type": "Function", "def": "static void block_mark_as_used(block_header_t * block)", "sline": 478, "body": "{\n    block_header_t * next = block_next(block);\n    block_set_prev_used(next);\n    block_set_used(block);\n}"}, "align_up": {"type": "Function", "def": "static size_t align_up(size_t x, size_t align)", "sline": 485, "body": "{\n    tlsf_assert(0 == (align & (align - 1)) && \"must align to a power of two\");\n    return (x + (align - 1)) & ~(align - 1);\n}"}, "align_down": {"type": "Function", "def": "static size_t align_down(size_t x, size_t align)", "sline": 491, "body": "{\n    tlsf_assert(0 == (align & (align - 1)) && \"must align to a power of two\");\n    return x - (x & (align - 1));\n}"}, "align_ptr": {"type": "Function", "def": "static void * align_ptr(const void * ptr, size_t align)", "sline": 497, "body": "{\n    const tlsfptr_t aligned =\n        (tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);\n    tlsf_assert(0 == (align & (align - 1)) && \"must align to a power of two\");\n    return tlsf_cast(void *, aligned);\n}"}, "adjust_request_size": {"type": "Function", "def": "static size_t adjust_request_size(size_t size, size_t align)", "sline": 509, "body": "{\n    size_t adjust = 0;\n    if(size) {\n        const size_t aligned = align_up(size, align);\n\n        /* aligned sized must not exceed block_size_max or we'll go out of bounds on sl_bitmap */\n        if(aligned < block_size_max) {\n            adjust = tlsf_max(aligned, block_size_min);\n        }\n    }\n    return adjust;\n}"}, "mapping_insert": {"type": "Function", "def": "static void mapping_insert(size_t size, int * fli, int * sli)", "sline": 528, "body": "{\n    int fl, sl;\n    if(size < SMALL_BLOCK_SIZE) {\n        /* Store small blocks in first list. */\n        fl = 0;\n        sl = tlsf_cast(int, size) / (SMALL_BLOCK_SIZE / SL_INDEX_COUNT);\n    }\n    else {\n        fl = tlsf_fls_sizet(size);\n        sl = tlsf_cast(int, size >> (fl - SL_INDEX_COUNT_LOG2)) ^ (1 << SL_INDEX_COUNT_LOG2);\n        fl -= (FL_INDEX_SHIFT - 1);\n    }\n    *fli = fl;\n    *sli = sl;\n}"}, "mapping_search": {"type": "Function", "def": "static void mapping_search(size_t size, int * fli, int * sli)", "sline": 546, "docstring": "/* This version rounds up to the next block size (for allocations) */", "body": "{\n    if(size >= SMALL_BLOCK_SIZE) {\n        const size_t round = (1 << (tlsf_fls_sizet(size) - SL_INDEX_COUNT_LOG2)) - 1;\n        size += round;\n    }\n    mapping_insert(size, fli, sli);\n}"}, "search_suitable_block": {"type": "Function", "def": "static block_header_t * search_suitable_block(control_t * control, int * fli, int * sli)", "sline": 555, "body": "{\n    int fl = *fli;\n    int sl = *sli;\n\n    /*\n    ** First, search for a block in the list associated with the given\n    ** fl/sl index.\n    */\n    unsigned int sl_map = control->sl_bitmap[fl] & (~0U << sl);\n    if(!sl_map) {\n        /* No block exists. Search in the next largest first-level list. */\n        const unsigned int fl_map = control->fl_bitmap & (~0U << (fl + 1));\n        if(!fl_map) {\n            /* No free blocks available, memory has been exhausted. */\n            return 0;\n        }\n\n        fl = tlsf_ffs(fl_map);\n        *fli = fl;\n        sl_map = control->sl_bitmap[fl];\n    }\n    tlsf_assert(sl_map && \"internal error - second level bitmap is null\");\n    sl = tlsf_ffs(sl_map);\n    *sli = sl;\n\n    /* Return the first block in the free list. */\n    return control->blocks[fl][sl];\n}"}, "remove_free_block": {"type": "Function", "def": "static void remove_free_block(control_t * control, block_header_t * block, int fl, int sl)", "sline": 586, "docstring": "/* Remove a free block from the free list.*/", "body": "{\n    block_header_t * prev = block->prev_free;\n    block_header_t * next = block->next_free;\n    tlsf_assert(prev && \"prev_free field can not be null\");\n    tlsf_assert(next && \"next_free field can not be null\");\n    next->prev_free = prev;\n    prev->next_free = next;\n\n    /* If this block is the head of the free list, set new head. */\n    if(control->blocks[fl][sl] == block) {\n        control->blocks[fl][sl] = next;\n\n        /* If the new head is null, clear the bitmap. */\n        if(next == &control->block_null) {\n            control->sl_bitmap[fl] &= ~(1U << sl);\n\n            /* If the second bitmap is now empty, clear the fl bitmap. */\n            if(!control->sl_bitmap[fl]) {\n                control->fl_bitmap &= ~(1U << fl);\n            }\n        }\n    }\n}"}, "insert_free_block": {"type": "Function", "def": "static void insert_free_block(control_t * control, block_header_t * block, int fl, int sl)", "sline": 612, "docstring": "/* Insert a free block into the free block list. */", "body": "{\n    block_header_t * current = control->blocks[fl][sl];\n    tlsf_assert(current && \"free list cannot have a null entry\");\n    tlsf_assert(block && \"cannot insert a null entry into the free list\");\n    block->next_free = current;\n    block->prev_free = &control->block_null;\n    current->prev_free = block;\n\n    tlsf_assert(block_to_ptr(block) == align_ptr(block_to_ptr(block), ALIGN_SIZE)\n                && \"block not aligned properly\");\n    /*\n    ** Insert the new block at the head of the list, and mark the first-\n    ** and second-level bitmaps appropriately.\n    */\n    control->blocks[fl][sl] = block;\n    control->fl_bitmap |= (1U << fl);\n    control->sl_bitmap[fl] |= (1U << sl);\n}"}, "block_remove": {"type": "Function", "def": "static void block_remove(control_t * control, block_header_t * block)", "sline": 633, "docstring": "/* Remove a given block from the free list. */", "body": "{\n    int fl, sl;\n    mapping_insert(block_size(block), &fl, &sl);\n    remove_free_block(control, block, fl, sl);\n}"}, "block_insert": {"type": "Function", "def": "static void block_insert(control_t * control, block_header_t * block)", "sline": 641, "docstring": "/* Insert a given block into the free list. */", "body": "{\n    int fl, sl;\n    mapping_insert(block_size(block), &fl, &sl);\n    insert_free_block(control, block, fl, sl);\n}"}, "block_can_split": {"type": "Function", "def": "static int block_can_split(block_header_t * block, size_t size)", "sline": 648, "body": "{\n    return block_size(block) >= sizeof(block_header_t) + size;\n}"}, "block_split": {"type": "Function", "def": "static block_header_t * block_split(block_header_t * block, size_t size)", "sline": 654, "docstring": "/* Split a block into two, the second of which is free. */", "body": "{\n    /* Calculate the amount of space left in the remaining block. */\n    block_header_t * remaining =\n        offset_to_block(block_to_ptr(block), size - block_header_overhead);\n\n    const size_t remain_size = block_size(block) - (size + block_header_overhead);\n\n    tlsf_assert(block_to_ptr(remaining) == align_ptr(block_to_ptr(remaining), ALIGN_SIZE)\n                && \"remaining block not aligned properly\");\n\n    tlsf_assert(block_size(block) == remain_size + size + block_header_overhead);\n    block_set_size(remaining, remain_size);\n    tlsf_assert(block_size(remaining) >= block_size_min && \"block split with invalid size\");\n\n    block_set_size(block, size);\n    block_mark_as_free(remaining);\n\n    return remaining;\n}"}, "block_absorb": {"type": "Function", "def": "static block_header_t * block_absorb(block_header_t * prev, block_header_t * block)", "sline": 676, "docstring": "/* Absorb a free block's storage into an adjacent previous free block. */", "body": "{\n    tlsf_assert(!block_is_last(prev) && \"previous block can't be last\");\n    /* Note: Leaves flags untouched. */\n    prev->size += block_size(block) + block_header_overhead;\n    block_link_next(prev);\n    return prev;\n}"}, "block_merge_prev": {"type": "Function", "def": "static block_header_t * block_merge_prev(control_t * control, block_header_t * block)", "sline": 686, "docstring": "/* Merge a just-freed block with an adjacent previous free block. */", "body": "{\n    if(block_is_prev_free(block)) {\n        block_header_t * prev = block_prev(block);\n        tlsf_assert(prev && \"prev physical block can't be null\");\n        tlsf_assert(block_is_free(prev) && \"prev block is not free though marked as such\");\n        block_remove(control, prev);\n        block = block_absorb(prev, block);\n    }\n\n    return block;\n}"}, "block_merge_next": {"type": "Function", "def": "static block_header_t * block_merge_next(control_t * control, block_header_t * block)", "sline": 700, "docstring": "/* Merge a just-freed block with an adjacent free block. */", "body": "{\n    block_header_t * next = block_next(block);\n    tlsf_assert(next && \"next physical block can't be null\");\n\n    if(block_is_free(next)) {\n        tlsf_assert(!block_is_last(block) && \"previous block can't be last\");\n        block_remove(control, next);\n        block = block_absorb(block, next);\n    }\n\n    return block;\n}"}, "block_trim_free": {"type": "Function", "def": "static void block_trim_free(control_t * control, block_header_t * block, size_t size)", "sline": 715, "docstring": "/* Trim any trailing block space off the end of a block, return to pool. */", "body": "{\n    tlsf_assert(block_is_free(block) && \"block must be free\");\n    if(block_can_split(block, size)) {\n        block_header_t * remaining_block = block_split(block, size);\n        block_link_next(block);\n        block_set_prev_free(remaining_block);\n        block_insert(control, remaining_block);\n    }\n}"}, "block_trim_used": {"type": "Function", "def": "static void block_trim_used(control_t * control, block_header_t * block, size_t size)", "sline": 727, "docstring": "/* Trim any trailing block space off the end of a used block, return to pool. */", "body": "{\n    tlsf_assert(!block_is_free(block) && \"block must be used\");\n    if(block_can_split(block, size)) {\n        /* If the next block is free, we must coalesce. */\n        block_header_t * remaining_block = block_split(block, size);\n        block_set_prev_used(remaining_block);\n\n        remaining_block = block_merge_next(control, remaining_block);\n        block_insert(control, remaining_block);\n    }\n}"}, "block_trim_free_leading": {"type": "Function", "def": "static block_header_t * block_trim_free_leading(control_t * control, block_header_t * block, size_t size)", "sline": 740, "body": "{\n    block_header_t * remaining_block = block;\n    if(block_can_split(block, size)) {\n        /* We want the 2nd block. */\n        remaining_block = block_split(block, size - block_header_overhead);\n        block_set_prev_free(remaining_block);\n\n        block_link_next(block);\n        block_insert(control, block);\n    }\n\n    return remaining_block;\n}"}, "block_locate_free": {"type": "Function", "def": "static block_header_t * block_locate_free(control_t * control, size_t size)", "sline": 755, "body": "{\n    int fl = 0, sl = 0;\n    block_header_t * block = 0;\n\n    if(size) {\n        mapping_search(size, &fl, &sl);\n\n        /*\n        ** mapping_search can futz with the size, so for excessively large sizes it can sometimes wind up\n        ** with indices that are off the end of the block array.\n        ** So, we protect against that here, since this is the only callsite of mapping_search.\n        ** Note that we don't need to check sl, since it comes from a modulo operation that guarantees it's always in range.\n        */\n        if(fl < FL_INDEX_COUNT) {\n            block = search_suitable_block(control, &fl, &sl);\n        }\n    }\n\n    if(block) {\n        tlsf_assert(block_size(block) >= size);\n        remove_free_block(control, block, fl, sl);\n    }\n\n    return block;\n}"}, "block_prepare_used": {"type": "Function", "def": "static void * block_prepare_used(control_t * control, block_header_t * block, size_t size)", "sline": 782, "body": "{\n    void * p = 0;\n    if(block) {\n        tlsf_assert(size && \"size must be non-zero\");\n        block_trim_free(control, block, size);\n        block_mark_as_used(block);\n        p = block_to_ptr(block);\n    }\n    return p;\n}"}, "control_constructor": {"type": "Function", "def": "static void control_constructor(control_t * control)", "sline": 795, "docstring": "/* Clear structure and point all empty lists at the null block. */", "body": "{\n    int i, j;\n\n    control->block_null.next_free = &control->block_null;\n    control->block_null.prev_free = &control->block_null;\n\n    control->fl_bitmap = 0;\n    for(i = 0; i < FL_INDEX_COUNT; ++i) {\n        control->sl_bitmap[i] = 0;\n        for(j = 0; j < SL_INDEX_COUNT; ++j) {\n            control->blocks[i][j] = &control->block_null;\n        }\n    }\n}"}, "integrity_t.prev_status": {"type": "Variable", "def": "int prev_status", "sline": 816, "in_struct": "integrity_t"}, "integrity_t.status": {"type": "Variable", "def": "int status", "sline": 817, "in_struct": "integrity_t"}, "integrity_t": {"type": "Variable", "def": "typedef struct integrity_t {\n    int prev_status;\n    int status;\n} integrity_t", "sline": 818}, "integrity_walker": {"type": "Function", "def": "static void integrity_walker(void * ptr, size_t size, int used, void * user)", "sline": 822, "body": "{\n    block_header_t * block = block_from_ptr(ptr);\n    integrity_t * integ = tlsf_cast(integrity_t *, user);\n    const int this_prev_status = block_is_prev_free(block) ? 1 : 0;\n    const int this_status = block_is_free(block) ? 1 : 0;\n    const size_t this_block_size = block_size(block);\n\n    int status = 0;\n    LV_UNUSED(used);\n    tlsf_insist(integ->prev_status == this_prev_status && \"prev status incorrect\");\n    tlsf_insist(size == this_block_size && \"block size incorrect\");\n\n    integ->prev_status = this_status;\n    integ->status += status;\n}"}, "lv_tlsf_check": {"type": "Function", "def": "int lv_tlsf_check(lv_tlsf_t tlsf)", "sline": 839, "body": "{\n    int i, j;\n\n    control_t * control = tlsf_cast(control_t *, tlsf);\n    int status = 0;\n\n    /* Check that the free lists and bitmaps are accurate. */\n    for(i = 0; i < FL_INDEX_COUNT; ++i) {\n        for(j = 0; j < SL_INDEX_COUNT; ++j) {\n            const int fl_map = control->fl_bitmap & (1U << i);\n            const int sl_list = control->sl_bitmap[i];\n            const int sl_map = sl_list & (1U << j);\n            const block_header_t * block = control->blocks[i][j];\n\n            /* Check that first- and second-level lists agree. */\n            if(!fl_map) {\n                tlsf_insist(!sl_map && \"second-level map must be null\");\n            }\n\n            if(!sl_map) {\n                tlsf_insist(block == &control->block_null && \"block list must be null\");\n                continue;\n            }\n\n            /* Check that there is at least one free block. */\n            tlsf_insist(sl_list && \"no free blocks in second-level map\");\n            tlsf_insist(block != &control->block_null && \"block should not be null\");\n\n            while(block != &control->block_null) {\n                int fli, sli;\n                tlsf_insist(block_is_free(block) && \"block should be free\");\n                tlsf_insist(!block_is_prev_free(block) && \"blocks should have coalesced\");\n                tlsf_insist(!block_is_free(block_next(block)) && \"blocks should have coalesced\");\n                tlsf_insist(block_is_prev_free(block_next(block)) && \"block should be free\");\n                tlsf_insist(block_size(block) >= block_size_min && \"block not minimum size\");\n\n                mapping_insert(block_size(block), &fli, &sli);\n                tlsf_insist(fli == i && sli == j && \"block size indexed in wrong list\");\n                block = block->next_free;\n            }\n        }\n    }\n\n    return status;\n}"}, "default_walker": {"type": "Function", "def": "static void default_walker(void * ptr, size_t size, int used, void * user)", "sline": 888, "body": "{\n    LV_UNUSED(user);\n    printf(\"\\t%p %s size: %x (%p)\\n\", ptr, used ? \"used\" : \"free\", (unsigned int)size, (void *)block_from_ptr(ptr));\n}"}, "lv_tlsf_walk_pool": {"type": "Function", "def": "void lv_tlsf_walk_pool(lv_pool_t pool, lv_tlsf_walker walker, void * user)", "sline": 894, "body": "{\n    lv_tlsf_walker pool_walker = walker ? walker : default_walker;\n    block_header_t * block =\n        offset_to_block(pool, -(int)block_header_overhead);\n\n    while(block && !block_is_last(block)) {\n        pool_walker(\n            block_to_ptr(block),\n            block_size(block),\n            !block_is_free(block),\n            user);\n        block = block_next(block);\n    }\n}"}, "lv_tlsf_block_size": {"type": "Function", "def": "size_t lv_tlsf_block_size(void * ptr)", "sline": 910, "body": "{\n    size_t size = 0;\n    if(ptr) {\n        const block_header_t * block = block_from_ptr(ptr);\n        size = block_size(block);\n    }\n    return size;\n}"}, "lv_tlsf_check_pool": {"type": "Function", "def": "int lv_tlsf_check_pool(lv_pool_t pool)", "sline": 920, "body": "{\n    /* Check that the blocks are physically correct. */\n    integrity_t integ = { 0, 0 };\n    lv_tlsf_walk_pool(pool, integrity_walker, &integ);\n\n    return integ.status;\n}"}, "lv_tlsf_size": {"type": "Function", "def": "size_t lv_tlsf_size(void)", "sline": 933, "body": "{\n    return sizeof(control_t);\n}"}, "lv_tlsf_align_size": {"type": "Function", "def": "size_t lv_tlsf_align_size(void)", "sline": 938, "body": "{\n    return ALIGN_SIZE;\n}"}, "lv_tlsf_block_size_min": {"type": "Function", "def": "size_t lv_tlsf_block_size_min(void)", "sline": 943, "body": "{\n    return block_size_min;\n}"}, "lv_tlsf_block_size_max": {"type": "Function", "def": "size_t lv_tlsf_block_size_max(void)", "sline": 948, "body": "{\n    return block_size_max;\n}"}, "lv_tlsf_pool_overhead": {"type": "Function", "def": "size_t lv_tlsf_pool_overhead(void)", "sline": 958, "body": "{\n    return 2 * block_header_overhead;\n}"}, "lv_tlsf_alloc_overhead": {"type": "Function", "def": "size_t lv_tlsf_alloc_overhead(void)", "sline": 963, "body": "{\n    return block_header_overhead;\n}"}, "lv_tlsf_add_pool": {"type": "Function", "def": "lv_pool_t lv_tlsf_add_pool(lv_tlsf_t tlsf, void * mem, size_t bytes)", "sline": 968, "body": "{\n    block_header_t * block;\n    block_header_t * next;\n\n    const size_t pool_overhead = lv_tlsf_pool_overhead();\n    const size_t pool_bytes = align_down(bytes - pool_overhead, ALIGN_SIZE);\n\n    if(((ptrdiff_t)mem % ALIGN_SIZE) != 0) {\n        printf(\"lv_tlsf_add_pool: Memory must be aligned by %u bytes.\\n\",\n               (unsigned int)ALIGN_SIZE);\n        return 0;\n    }\n\n    if(pool_bytes < block_size_min || pool_bytes > block_size_max) {\n#if defined (TLSF_64BIT)\n        printf(\"lv_tlsf_add_pool: Memory size must be between 0x%x and 0x%x00 bytes.\\n\",\n               (unsigned int)(pool_overhead + block_size_min),\n               (unsigned int)((pool_overhead + block_size_max) / 256));\n#else\n        printf(\"lv_tlsf_add_pool: Memory size must be between %u and %u bytes.\\n\",\n               (unsigned int)(pool_overhead + block_size_min),\n               (unsigned int)(pool_overhead + block_size_max));\n#endif\n        return 0;\n    }\n\n    /*\n    ** Create the main free block. Offset the start of the block slightly\n    ** so that the prev_phys_block field falls outside of the pool -\n    ** it will never be used.\n    */\n    block = offset_to_block(mem, -(tlsfptr_t)block_header_overhead);\n    block_set_size(block, pool_bytes);\n    block_set_free(block);\n    block_set_prev_used(block);\n    block_insert(tlsf_cast(control_t *, tlsf), block);\n\n    /* Split the block to create a zero-size sentinel block. */\n    next = block_link_next(block);\n    block_set_size(next, 0);\n    block_set_used(next);\n    block_set_prev_free(next);\n\n    return mem;\n}"}, "lv_tlsf_remove_pool": {"type": "Function", "def": "void lv_tlsf_remove_pool(lv_tlsf_t tlsf, lv_pool_t pool)", "sline": 1015, "body": "{\n    control_t * control = tlsf_cast(control_t *, tlsf);\n    block_header_t * block = offset_to_block(pool, -(int)block_header_overhead);\n\n    int fl = 0, sl = 0;\n\n    tlsf_assert(block_is_free(block) && \"block should be free\");\n    tlsf_assert(!block_is_free(block_next(block)) && \"next block should not be free\");\n    tlsf_assert(block_size(block_next(block)) == 0 && \"next block size should be zero\");\n\n    mapping_insert(block_size(block), &fl, &sl);\n    remove_free_block(control, block, fl, sl);\n}"}, "lv_tlsf_create": {"type": "Function", "def": "lv_tlsf_t lv_tlsf_create(void * mem)", "sline": 1061, "body": "{\n#if _DEBUG\n    if(test_ffs_fls()) {\n        return 0;\n    }\n#endif\n\n    if(((tlsfptr_t)mem % ALIGN_SIZE) != 0) {\n        printf(\"lv_tlsf_create: Memory must be aligned to %u bytes.\\n\",\n               (unsigned int)ALIGN_SIZE);\n        return 0;\n    }\n\n    control_constructor(tlsf_cast(control_t *, mem));\n\n    return tlsf_cast(lv_tlsf_t, mem);\n}"}, "lv_tlsf_create_with_pool": {"type": "Function", "def": "lv_tlsf_t lv_tlsf_create_with_pool(void * mem, size_t bytes)", "sline": 1080, "body": "{\n    lv_tlsf_t tlsf = lv_tlsf_create(mem);\n    lv_tlsf_add_pool(tlsf, (char *)mem + lv_tlsf_size(), bytes - lv_tlsf_size());\n    return tlsf;\n}"}, "lv_tlsf_destroy": {"type": "Function", "def": "void lv_tlsf_destroy(lv_tlsf_t tlsf)", "sline": 1087, "body": "{\n    /* Nothing to do. */\n    LV_UNUSED(tlsf);\n}"}, "lv_tlsf_get_pool": {"type": "Function", "def": "lv_pool_t lv_tlsf_get_pool(lv_tlsf_t tlsf)", "sline": 1093, "body": "{\n    return tlsf_cast(lv_pool_t, (char *)tlsf + lv_tlsf_size());\n}"}, "lv_tlsf_malloc": {"type": "Function", "def": "void * lv_tlsf_malloc(lv_tlsf_t tlsf, size_t size)", "sline": 1098, "body": "{\n    control_t * control = tlsf_cast(control_t *, tlsf);\n    const size_t adjust = adjust_request_size(size, ALIGN_SIZE);\n    block_header_t * block = block_locate_free(control, adjust);\n    return block_prepare_used(control, block, adjust);\n}"}, "lv_tlsf_memalign": {"type": "Function", "def": "void * lv_tlsf_memalign(lv_tlsf_t tlsf, size_t align, size_t size)", "sline": 1106, "body": "{\n    control_t * control = tlsf_cast(control_t *, tlsf);\n    const size_t adjust = adjust_request_size(size, ALIGN_SIZE);\n\n    /*\n    ** We must allocate an additional minimum block size bytes so that if\n    ** our free block will leave an alignment gap which is smaller, we can\n    ** trim a leading free block and release it back to the pool. We must\n    ** do this because the previous physical block is in use, therefore\n    ** the prev_phys_block field is not valid, and we can't simply adjust\n    ** the size of that block.\n    */\n    const size_t gap_minimum = sizeof(block_header_t);\n    const size_t size_with_gap = adjust_request_size(adjust + align + gap_minimum, align);\n\n    /*\n    ** If alignment is less than or equals base alignment, we're done.\n    ** If we requested 0 bytes, return null, as lv_tlsf_malloc(0) does.\n    */\n    const size_t aligned_size = (adjust && align > ALIGN_SIZE) ? size_with_gap : adjust;\n\n    block_header_t * block = block_locate_free(control, aligned_size);\n\n    /* This can't be a static assert. */\n    tlsf_assert(sizeof(block_header_t) == block_size_min + block_header_overhead);\n\n    if(block) {\n        void * ptr = block_to_ptr(block);\n        void * aligned = align_ptr(ptr, align);\n        size_t gap = tlsf_cast(size_t,\n                               tlsf_cast(tlsfptr_t, aligned) - tlsf_cast(tlsfptr_t, ptr));\n\n        /* If gap size is too small, offset to next aligned boundary. */\n        if(gap && gap < gap_minimum) {\n            const size_t gap_remain = gap_minimum - gap;\n            const size_t offset = tlsf_max(gap_remain, align);\n            const void * next_aligned = tlsf_cast(void *,\n                                                  tlsf_cast(tlsfptr_t, aligned) + offset);\n\n            aligned = align_ptr(next_aligned, align);\n            gap = tlsf_cast(size_t,\n                            tlsf_cast(tlsfptr_t, aligned) - tlsf_cast(tlsfptr_t, ptr));\n        }\n\n        if(gap) {\n            tlsf_assert(gap >= gap_minimum && \"gap size too small\");\n            block = block_trim_free_leading(control, block, gap);\n        }\n    }\n\n    return block_prepare_used(control, block, adjust);\n}"}, "lv_tlsf_free": {"type": "Function", "def": "void lv_tlsf_free(lv_tlsf_t tlsf, void * ptr)", "sline": 1160, "body": "{\n    /* Don't attempt to free a NULL pointer. */\n    if(ptr) {\n        control_t * control = tlsf_cast(control_t *, tlsf);\n        block_header_t * block = block_from_ptr(ptr);\n        tlsf_assert(!block_is_free(block) && \"block already marked as free\");\n        block_mark_as_free(block);\n        block = block_merge_prev(control, block);\n        block = block_merge_next(control, block);\n        block_insert(control, block);\n    }\n}"}, "lv_tlsf_realloc": {"type": "Function", "def": "void * lv_tlsf_realloc(lv_tlsf_t tlsf, void * ptr, size_t size)", "sline": 1187, "body": "{\n    control_t * control = tlsf_cast(control_t *, tlsf);\n    void * p = 0;\n\n    /* Zero-size requests are treated as free. */\n    if(ptr && size == 0) {\n        lv_tlsf_free(tlsf, ptr);\n    }\n    /* Requests with NULL pointers are treated as malloc. */\n    else if(!ptr) {\n        p = lv_tlsf_malloc(tlsf, size);\n    }\n    else {\n        block_header_t * block = block_from_ptr(ptr);\n        block_header_t * next = block_next(block);\n\n        const size_t cursize = block_size(block);\n        const size_t combined = cursize + block_size(next) + block_header_overhead;\n        const size_t adjust = adjust_request_size(size, ALIGN_SIZE);\n\n        tlsf_assert(!block_is_free(block) && \"block already marked as free\");\n\n        /*\n        ** If the next block is used, or when combined with the current\n        ** block, does not offer enough space, we must reallocate and copy.\n        */\n        if(adjust > cursize && (!block_is_free(next) || adjust > combined)) {\n            p = lv_tlsf_malloc(tlsf, size);\n            if(p) {\n                const size_t minsize = tlsf_min(cursize, size);\n                lv_memcpy(p, ptr, minsize);\n                lv_tlsf_free(tlsf, ptr);\n            }\n        }\n        else {\n            /* Do we need to expand to the next block? */\n            if(adjust > cursize) {\n                block_merge_next(control, block);\n                block_mark_as_used(block);\n            }\n\n            /* Trim the resulting block and return the original pointer. */\n            block_trim_used(control, block, adjust);\n            p = ptr;\n        }\n    }\n\n    return p;\n}"}, "carbit_updater/lvgl/src/misc/lv_tlsf.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_tlsf.c"}}, "carbit_updater/lvgl/src/extra/libs/lv_libs.h": {"lv_bmp": {"type": "Variable", "def": "#include bmp/lv_bmp.h", "sline": 16, "include": ["carbit_updater/lvgl/src/extra/libs/bmp/lv_bmp.h", null]}, "lv_fsdrv": {"type": "Variable", "def": "#include fsdrv/lv_fsdrv.h", "sline": 17, "include": ["carbit_updater/lvgl/src/extra/libs/fsdrv/lv_fsdrv.h", null]}, "lv_png": {"type": "Variable", "def": "#include png/lv_png.h", "sline": 18, "include": ["carbit_updater/lvgl/src/extra/libs/png/lv_png.h", null]}, "lv_gif": {"type": "Variable", "def": "#include gif/lv_gif.h", "sline": 19, "include": ["carbit_updater/lvgl/src/extra/libs/gif/lv_gif.h", null]}, "lv_qrcode": {"type": "Variable", "def": "#include qrcode/lv_qrcode.h", "sline": 20, "include": ["carbit_updater/lvgl/src/extra/libs/qrcode/lv_qrcode.h", null]}, "lv_sjpg": {"type": "Variable", "def": "#include sjpg/lv_sjpg.h", "sline": 21, "include": ["carbit_updater/lvgl/src/extra/libs/sjpg/lv_sjpg.h", null]}, "lv_freetype": {"type": "Variable", "def": "#include freetype/lv_freetype.h", "sline": 22, "include": ["carbit_updater/lvgl/src/extra/libs/freetype/lv_freetype.h", null]}, "lv_rlottie": {"type": "Variable", "def": "#include rlottie/lv_rlottie.h", "sline": 23, "include": ["carbit_updater/lvgl/src/extra/libs/rlottie/lv_rlottie.h", null]}, "carbit_updater/lvgl/src/extra/libs/lv_libs.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/lv_libs.h"}}, "carbit_updater/lv_drivers/display/fbdev.c": {"fbdev": {"type": "Variable", "def": "#include fbdev.h", "sline": 9, "include": ["carbit_updater/lv_drivers/display/fbdev.h", null]}, "carbit_updater/lv_drivers/display/fbdev.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/fbdev.c"}}, "carbit_updater/lvgl/src/widgets/lv_dropdown.c": {"lv_obj": {"type": "Variable", "def": "#include ../core/lv_obj.h", "sline": 9}, "lv_dropdown": {"type": "Variable", "def": "#include lv_dropdown.h", "sline": 10, "include": ["carbit_updater/lvgl/src/widgets/lv_dropdown.h", null]}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 13}, "lv_draw": {"type": "Variable", "def": "#include ../draw/lv_draw.h", "sline": 14}, "lv_group": {"type": "Variable", "def": "#include ../core/lv_group.h", "sline": 15}, "lv_indev": {"type": "Variable", "def": "#include ../core/lv_indev.h", "sline": 16}, "lv_disp": {"type": "Variable", "def": "#include ../core/lv_disp.h", "sline": 17}, "lv_symbol_def": {"type": "Variable", "def": "#include ../font/lv_symbol_def.h", "sline": 18}, "lv_anim": {"type": "Variable", "def": "#include ../misc/lv_anim.h", "sline": 19}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 20}, "lv_txt_ap": {"type": "Variable", "def": "#include ../misc/lv_txt_ap.h", "sline": 21}, "string": {"type": "Variable", "def": "#include string.h", "sline": 22}, "lv_dropdown_list_create": {"type": "Function", "def": "static lv_obj_t * lv_dropdown_list_create(lv_obj_t * parent)", "sline": 536, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_dropdownlist_class, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_dropdown_constructor": {"type": "Function", "def": "static void lv_dropdown_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 544, "body": "{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n\n    /*Initialize the allocated 'ext'*/\n    dropdown->list          = NULL;\n    dropdown->options     = NULL;\n    dropdown->symbol         = LV_SYMBOL_DOWN;\n    dropdown->text         = NULL;\n    dropdown->static_txt = 1;\n    dropdown->selected_highlight = 1;\n    dropdown->sel_opt_id      = 0;\n    dropdown->sel_opt_id_orig = 0;\n    dropdown->pr_opt_id = LV_DROPDOWN_PR_NONE;\n    dropdown->option_cnt      = 0;\n    dropdown->dir = LV_DIR_BOTTOM;\n\n    lv_obj_add_flag(obj, LV_OBJ_FLAG_SCROLL_ON_FOCUS);\n    lv_dropdown_set_options_static(obj, \"Option 1\\nOption 2\\nOption 3\");\n\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}"}, "lv_dropdown_destructor": {"type": "Function", "def": "static void lv_dropdown_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 570, "body": "{\n    LV_UNUSED(class_p);\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n\n    if(dropdown->list) {\n        lv_obj_del(dropdown->list);\n        dropdown->list = NULL;\n    }\n\n    if(!dropdown->static_txt) {\n        lv_mem_free(dropdown->options);\n        dropdown->options = NULL;\n    }\n}"}, "lv_dropdown_event": {"type": "Function", "def": "static void lv_dropdown_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 606, "body": "{\n    LV_UNUSED(class_p);\n\n    lv_res_t res;\n\n    /*Call the ancestor's event handler*/\n    res = lv_obj_event_base(MY_CLASS, e);\n    if(res != LV_RES_OK) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n\n    if(code == LV_EVENT_FOCUSED) {\n        lv_group_t * g             = lv_obj_get_group(obj);\n        bool editing               = lv_group_get_editing(g);\n        lv_indev_type_t indev_type = lv_indev_get_type(lv_indev_get_act());\n\n        /*Encoders need special handling*/\n        if(indev_type == LV_INDEV_TYPE_ENCODER) {\n            /*Open the list if editing*/\n            if(editing) {\n                lv_dropdown_open(obj);\n            }\n            /*Close the list if navigating*/\n            else {\n                dropdown->sel_opt_id = dropdown->sel_opt_id_orig;\n                lv_dropdown_close(obj);\n            }\n        }\n    }\n    else if(code == LV_EVENT_DEFOCUSED || code == LV_EVENT_LEAVE) {\n        lv_dropdown_close(obj);\n    }\n    else if(code == LV_EVENT_RELEASED) {\n        res = btn_release_handler(obj);\n        if(res != LV_RES_OK) return;\n    }\n    else if(code == LV_EVENT_STYLE_CHANGED) {\n        lv_obj_refresh_self_size(obj);\n    }\n    else if(code == LV_EVENT_SIZE_CHANGED) {\n        lv_obj_refresh_self_size(obj);\n    }\n    else if(code == LV_EVENT_GET_SELF_SIZE) {\n        lv_point_t * p = lv_event_get_param(e);\n        const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_MAIN);\n        p->y = lv_font_get_line_height(font);\n    }\n    else if(code == LV_EVENT_KEY) {\n        char c = *((char *)lv_event_get_param(e));\n        if(c == LV_KEY_RIGHT || c == LV_KEY_DOWN) {\n            if(dropdown->list == NULL) {\n                lv_dropdown_open(obj);\n            }\n            else if(dropdown->sel_opt_id + 1 < dropdown->option_cnt) {\n                dropdown->sel_opt_id++;\n                position_to_selected(obj);\n            }\n        }\n        else if(c == LV_KEY_LEFT || c == LV_KEY_UP) {\n\n            if(dropdown->list == NULL) {\n                lv_dropdown_open(obj);\n            }\n            else if(dropdown->sel_opt_id > 0) {\n                dropdown->sel_opt_id--;\n                position_to_selected(obj);\n            }\n        }\n        else if(c == LV_KEY_ESC) {\n            dropdown->sel_opt_id = dropdown->sel_opt_id_orig;\n            lv_dropdown_close(obj);\n        }\n        else if(c == LV_KEY_ENTER) {\n            /* Handle the ENTER key only if it was send by an other object.\n             * Do no process it if ENTER is sent by the dropdown becasue it's handled in LV_EVENT_RELEASED */\n            lv_obj_t * indev_obj = lv_indev_get_obj_act();\n            if(indev_obj != obj) {\n                res = btn_release_handler(obj);\n                if(res != LV_RES_OK) return;\n            }\n        }\n    }\n    else if(code == LV_EVENT_DRAW_MAIN) {\n        draw_main(e);\n    }\n}"}, "draw_main": {"type": "Function", "def": "static void draw_main(lv_event_t * e)", "sline": 732, "body": "{\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n    const lv_area_t * clip_area = lv_event_get_param(e);\n\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n    lv_coord_t left = lv_obj_get_style_pad_left(obj, LV_PART_MAIN) + border_width;\n    lv_coord_t right = lv_obj_get_style_pad_right(obj, LV_PART_MAIN) + border_width;\n    lv_coord_t top = lv_obj_get_style_pad_top(obj, LV_PART_MAIN) + border_width;\n\n    lv_draw_label_dsc_t symbol_dsc;\n    lv_draw_label_dsc_init(&symbol_dsc);\n    lv_obj_init_draw_label_dsc(obj, LV_PART_INDICATOR, &symbol_dsc);\n\n    /*If no text specified use the selected option*/\n    const char * opt_txt;\n    if(dropdown->text) opt_txt = dropdown->text;\n    else {\n        char * buf = lv_mem_buf_get(128);\n        lv_dropdown_get_selected_str(obj, buf, 128);\n        opt_txt = buf;\n    }\n\n    bool symbol_to_left = false;\n    if(dropdown->dir == LV_DIR_LEFT) symbol_to_left = true;\n    if(lv_obj_get_style_base_dir(obj, LV_PART_MAIN) == LV_BASE_DIR_RTL) symbol_to_left = true;\n\n    if(dropdown->symbol) {\n        lv_img_src_t symbol_type = lv_img_src_get_type(dropdown->symbol);\n        lv_coord_t symbol_w;\n        lv_coord_t symbol_h;\n        if(symbol_type == LV_IMG_SRC_SYMBOL) {\n            lv_point_t size;\n            lv_txt_get_size(&size, dropdown->symbol, symbol_dsc.font, symbol_dsc.letter_space, symbol_dsc.line_space, LV_COORD_MAX,\n                            symbol_dsc.flag);\n            symbol_w = size.x;\n            symbol_h = size.y;\n        }\n        else {\n            lv_img_header_t header;\n            lv_res_t res = lv_img_decoder_get_info(dropdown->symbol, &header);\n            if(res == LV_RES_OK) {\n                symbol_w = header.w;\n                symbol_h = header.h;\n            }\n            else {\n                symbol_w = -1;\n                symbol_h = -1;\n            }\n        }\n\n        lv_area_t symbol_area;\n        if(symbol_to_left) {\n            symbol_area.x1 = obj->coords.x1 + left;\n            symbol_area.x2 = symbol_area.x1 + symbol_w - 1;\n        }\n        else {\n            symbol_area.x1 = obj->coords.x2 - right - symbol_w;\n            symbol_area.x2 = symbol_area.x1 + symbol_w - 1;\n        }\n\n        if(symbol_type == LV_IMG_SRC_SYMBOL) {\n            symbol_area.y1 = obj->coords.y1 + top;\n            symbol_area.y2 = symbol_area.y1 + symbol_h - 1;\n            lv_draw_label(&symbol_area, clip_area, &symbol_dsc, dropdown->symbol, NULL);\n        }\n        else {\n            symbol_area.y1 = obj->coords.y1 + (lv_obj_get_height(obj) - symbol_h) / 2;\n            symbol_area.y2 = symbol_area.y1 + symbol_h - 1;\n            lv_draw_img_dsc_t img_dsc;\n            lv_draw_img_dsc_init(&img_dsc);\n            lv_obj_init_draw_img_dsc(obj, LV_PART_INDICATOR, &img_dsc);\n            img_dsc.pivot.x = symbol_w / 2;\n            img_dsc.pivot.y = symbol_h / 2;\n            img_dsc.angle = lv_obj_get_style_transform_angle(obj, LV_PART_INDICATOR);\n            lv_draw_img(&symbol_area, clip_area, dropdown->symbol, &img_dsc);\n        }\n    }\n\n    lv_draw_label_dsc_t label_dsc;\n    lv_draw_label_dsc_init(&label_dsc);\n    lv_obj_init_draw_label_dsc(obj, LV_PART_MAIN, &label_dsc);\n\n    lv_point_t size;\n    lv_txt_get_size(&size, opt_txt, label_dsc.font, label_dsc.letter_space, label_dsc.line_space, LV_COORD_MAX,\n                    label_dsc.flag);\n\n    lv_area_t txt_area;\n    txt_area.y1 = obj->coords.y1 + top;\n    txt_area.y2 = txt_area.y1 + size.y;\n    /*Center align the text if no symbol*/\n    if(dropdown->symbol == NULL) {\n        txt_area.x1 = obj->coords.x1 + (lv_obj_get_width(obj) - size.x) / 2;\n        txt_area.x2 = txt_area.x1 + size.x;\n    }\n    else {\n        /*Text to the right*/\n        if(symbol_to_left) {\n            txt_area.x1 = obj->coords.x2 - right - size.x;\n            txt_area.x2 = txt_area.x1 + size.x;\n        }\n        else {\n            txt_area.x1 = obj->coords.x1 + left;\n            txt_area.x2 = txt_area.x1 + size.x;\n        }\n    }\n    lv_draw_label(&txt_area, clip_area, &label_dsc, opt_txt, NULL);\n\n    if(dropdown->text == NULL) {\n        lv_mem_buf_release((char *)opt_txt);\n    }\n}"}, "lv_dropdownlist_constructor": {"type": "Function", "def": "static void lv_dropdownlist_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 586, "body": "{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_obj_clear_flag(obj, LV_OBJ_FLAG_SCROLL_ON_FOCUS);\n    lv_label_create(obj);\n\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}"}, "lv_dropdownlist_destructor": {"type": "Function", "def": "static void lv_dropdownlist_destructor(const lv_obj_class_t * class_p, lv_obj_t * list_obj)", "sline": 597, "body": "{\n    LV_UNUSED(class_p);\n    lv_dropdown_list_t * list = (lv_dropdown_list_t *)list_obj;\n    lv_obj_t * dropdown_obj = list->dropdown;\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)dropdown_obj;\n    dropdown->list = NULL;\n}"}, "lv_dropdown_list_event": {"type": "Function", "def": "static void lv_dropdown_list_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 696, "body": "{\n    LV_UNUSED(class_p);\n\n    lv_res_t res;\n\n    /*Call the ancestor's event handler*/\n    lv_event_code_t code = lv_event_get_code(e);\n    if(code != LV_EVENT_DRAW_POST) {\n        res = lv_obj_event_base(MY_CLASS_LIST, e);\n        if(res != LV_RES_OK) return;\n    }\n    lv_obj_t * list = lv_event_get_target(e);\n    lv_obj_t * dropdown_obj = ((lv_dropdown_list_t *)list)->dropdown;\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)dropdown_obj;\n\n    if(code == LV_EVENT_RELEASED) {\n        if(lv_indev_get_scroll_obj(lv_indev_get_act()) == NULL) {\n            list_release_handler(list);\n        }\n    }\n    else if(code == LV_EVENT_PRESSED) {\n        list_press_handler(list);\n    }\n    else if(code == LV_EVENT_SCROLL_BEGIN) {\n        dropdown->pr_opt_id = LV_DROPDOWN_PR_NONE;\n        lv_obj_invalidate(list);\n    }\n    else if(code == LV_EVENT_DRAW_POST) {\n        draw_list(e);\n        res = lv_obj_event_base(MY_CLASS_LIST, e);\n        if(res != LV_RES_OK) return;\n    }\n}"}, "draw_list": {"type": "Function", "def": "static void draw_list(lv_event_t * e)", "sline": 846, "body": "{\n    lv_obj_t * list_obj = lv_event_get_target(e);\n    lv_dropdown_list_t * list = (lv_dropdown_list_t *)list_obj;\n    lv_obj_t * dropdown_obj = list->dropdown;\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)dropdown_obj;\n    const lv_area_t * clip_area = lv_event_get_param(e);\n\n    /*Draw the box labels if the list is not being deleted*/\n    if(dropdown->list) {\n        /* Clip area might be too large too to shadow but\n         * the selected option can be drawn on only the background*/\n        lv_area_t clip_area_core;\n        bool has_common;\n        has_common = _lv_area_intersect(&clip_area_core, clip_area, &dropdown->list->coords);\n        if(has_common) {\n            if(dropdown->selected_highlight) {\n                if(dropdown->pr_opt_id == dropdown->sel_opt_id) {\n                    draw_box(dropdown_obj, &clip_area_core, dropdown->pr_opt_id, LV_STATE_CHECKED | LV_STATE_PRESSED);\n                    draw_box_label(dropdown_obj, &clip_area_core, dropdown->pr_opt_id, LV_STATE_CHECKED | LV_STATE_PRESSED);\n                }\n                else {\n                    draw_box(dropdown_obj, &clip_area_core, dropdown->pr_opt_id, LV_STATE_PRESSED);\n                    draw_box_label(dropdown_obj, &clip_area_core, dropdown->pr_opt_id, LV_STATE_PRESSED);\n                    draw_box(dropdown_obj, &clip_area_core, dropdown->sel_opt_id, LV_STATE_CHECKED);\n                    draw_box_label(dropdown_obj, &clip_area_core, dropdown->sel_opt_id, LV_STATE_CHECKED);\n                }\n            }\n            else {\n                draw_box(dropdown_obj, &clip_area_core, dropdown->pr_opt_id, LV_STATE_PRESSED);\n                draw_box_label(dropdown_obj, &clip_area_core, dropdown->pr_opt_id, LV_STATE_PRESSED);\n            }\n        }\n    }\n}"}, "draw_box": {"type": "Function", "def": "static void draw_box(lv_obj_t * dropdown_obj, const lv_area_t * clip_area, uint16_t id, lv_state_t state)", "sline": 882, "body": "{\n    if(id == LV_DROPDOWN_PR_NONE) return;\n\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)dropdown_obj;\n    lv_obj_t * list_obj = dropdown->list;\n    lv_state_t state_ori = list_obj->state;\n\n    if(state != list_obj->state) {\n        list_obj->state = state;\n        list_obj->skip_trans = 1;\n    }\n\n    /*Draw a rectangle under the selected item*/\n    const lv_font_t * font    = lv_obj_get_style_text_font(list_obj, LV_PART_SELECTED);\n    lv_coord_t line_space = lv_obj_get_style_text_line_space(list_obj,  LV_PART_SELECTED);\n    lv_coord_t font_h         = lv_font_get_line_height(font);\n\n    /*Draw the selected*/\n    lv_obj_t * label = get_label(dropdown_obj);\n    lv_area_t rect_area;\n    rect_area.y1 = label->coords.y1;\n    rect_area.y1 += id * (font_h + line_space);\n    rect_area.y1 -= line_space / 2;\n\n    rect_area.y2 = rect_area.y1 + font_h + line_space - 1;\n    rect_area.x1 = dropdown->list->coords.x1;\n    rect_area.x2 = dropdown->list->coords.x2;\n\n    lv_draw_rect_dsc_t sel_rect;\n    lv_draw_rect_dsc_init(&sel_rect);\n    lv_obj_init_draw_rect_dsc(list_obj,  LV_PART_SELECTED, &sel_rect);\n    lv_draw_rect(&rect_area, clip_area, &sel_rect);\n\n    list_obj->state = state_ori;\n    list_obj->skip_trans = 0;\n}"}, "draw_box_label": {"type": "Function", "def": "static void draw_box_label(lv_obj_t * dropdown_obj, const lv_area_t * clip_area, uint16_t id, lv_state_t state)", "sline": 920, "body": "{\n    if(id == LV_DROPDOWN_PR_NONE) return;\n\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)dropdown_obj;\n    lv_obj_t * list_obj = dropdown->list;\n    lv_state_t state_orig = list_obj->state;\n\n    if(state != list_obj->state) {\n        list_obj->state =  state;\n        list_obj->skip_trans = 1;\n    }\n\n    lv_draw_label_dsc_t label_dsc;\n    lv_draw_label_dsc_init(&label_dsc);\n    lv_obj_init_draw_label_dsc(list_obj, LV_PART_SELECTED, &label_dsc);\n\n    label_dsc.line_space = lv_obj_get_style_text_line_space(list_obj,\n                                                            LV_PART_SELECTED);  /*Line space should come from the list*/\n\n    lv_obj_t * label = get_label(dropdown_obj);\n    if(label == NULL) return;\n\n    lv_coord_t font_h        = lv_font_get_line_height(label_dsc.font);\n\n    lv_area_t area_sel;\n    area_sel.y1 = label->coords.y1;\n    area_sel.y1 += id * (font_h + label_dsc.line_space);\n    area_sel.y1 -= label_dsc.line_space / 2;\n\n    area_sel.y2 = area_sel.y1 + font_h + label_dsc.line_space - 1;\n    area_sel.x1 = list_obj->coords.x1;\n    area_sel.x2 = list_obj->coords.x2;\n    lv_area_t mask_sel;\n    bool area_ok;\n    area_ok = _lv_area_intersect(&mask_sel, clip_area, &area_sel);\n    if(area_ok) {\n        lv_draw_label(&label->coords, &mask_sel, &label_dsc, lv_label_get_text(label), NULL);\n    }\n    list_obj->state = state_orig;\n    list_obj->skip_trans = 0;\n}"}, "btn_release_handler": {"type": "Function", "def": "static lv_res_t btn_release_handler(lv_obj_t * obj)", "sline": 964, "body": "{\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n    lv_indev_t * indev = lv_indev_get_act();\n    if(lv_indev_get_scroll_obj(indev) == NULL) {\n        if(dropdown->list) {\n            lv_dropdown_close(obj);\n            if(dropdown->sel_opt_id_orig != dropdown->sel_opt_id) {\n                dropdown->sel_opt_id_orig = dropdown->sel_opt_id;\n                lv_res_t res;\n                uint32_t id  = dropdown->sel_opt_id; /*Just to use uint32_t in event data*/\n                res = lv_event_send(obj, LV_EVENT_VALUE_CHANGED, &id);\n                if(res != LV_RES_OK) return res;\n                lv_obj_invalidate(obj);\n            }\n            lv_indev_type_t indev_type = lv_indev_get_type(indev);\n            if(indev_type == LV_INDEV_TYPE_ENCODER) {\n                lv_group_set_editing(lv_obj_get_group(obj), false);\n            }\n        }\n        else {\n            lv_dropdown_open(obj);\n        }\n    }\n    else {\n        dropdown->sel_opt_id = dropdown->sel_opt_id_orig;\n        lv_obj_invalidate(obj);\n    }\n    return LV_RES_OK;\n}"}, "list_release_handler": {"type": "Function", "def": "static lv_res_t list_release_handler(lv_obj_t * list_obj)", "sline": 1000, "body": "{\n    lv_dropdown_list_t * list = (lv_dropdown_list_t *) list_obj;\n    lv_obj_t * dropdown_obj = list->dropdown;\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)dropdown_obj;\n\n    lv_indev_t * indev = lv_indev_get_act();\n    /*Leave edit mode once a new item is selected*/\n    if(lv_indev_get_type(indev) == LV_INDEV_TYPE_ENCODER) {\n        dropdown->sel_opt_id_orig = dropdown->sel_opt_id;\n        lv_group_t * g      = lv_obj_get_group(dropdown_obj);\n        if(lv_group_get_editing(g)) {\n            lv_group_set_editing(g, false);\n        }\n    }\n\n    /*Search the clicked option (For KEYPAD and ENCODER the new value should be already set)*/\n    if(lv_indev_get_type(indev) == LV_INDEV_TYPE_POINTER || lv_indev_get_type(indev) == LV_INDEV_TYPE_BUTTON) {\n        lv_point_t p;\n        lv_indev_get_point(indev, &p);\n        dropdown->sel_opt_id     = get_id_on_point(dropdown_obj, p.y);\n        dropdown->sel_opt_id_orig = dropdown->sel_opt_id;\n    }\n\n    lv_dropdown_close(dropdown_obj);\n\n    /*Invalidate to refresh the text*/\n    if(dropdown->text == NULL) lv_obj_invalidate(dropdown_obj);\n\n    uint32_t id  = dropdown->sel_opt_id; /*Just to use uint32_t in event data*/\n    lv_res_t res = lv_event_send(dropdown_obj, LV_EVENT_VALUE_CHANGED, &id);\n    if(res != LV_RES_OK) return res;\n\n    return LV_RES_OK;\n}"}, "list_press_handler": {"type": "Function", "def": "static void list_press_handler(lv_obj_t * list_obj)", "sline": 1036, "body": "{\n    lv_dropdown_list_t * list = (lv_dropdown_list_t *) list_obj;\n    lv_obj_t * dropdown_obj = list->dropdown;\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)dropdown_obj;\n\n    lv_indev_t * indev = lv_indev_get_act();\n    if(indev && (lv_indev_get_type(indev) == LV_INDEV_TYPE_POINTER || lv_indev_get_type(indev) == LV_INDEV_TYPE_BUTTON)) {\n        lv_point_t p;\n        lv_indev_get_point(indev, &p);\n        dropdown->pr_opt_id = get_id_on_point(dropdown_obj, p.y);\n        lv_obj_invalidate(list_obj);\n    }\n}"}, "get_id_on_point": {"type": "Function", "def": "static uint16_t get_id_on_point(lv_obj_t * dropdown_obj, lv_coord_t y)", "sline": 1051, "body": "{\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)dropdown_obj;\n    lv_obj_t * label = get_label(dropdown_obj);\n    if(label == NULL) return 0;\n    y -= label->coords.y1;\n\n    const lv_font_t * font         = lv_obj_get_style_text_font(label, LV_PART_MAIN);\n    lv_coord_t font_h              = lv_font_get_line_height(font);\n    lv_coord_t line_space = lv_obj_get_style_text_line_space(label, LV_PART_MAIN);\n\n    y += line_space / 2;\n    lv_coord_t h = font_h + line_space;\n\n    uint16_t opt = y / h;\n\n    if(opt >= dropdown->option_cnt) opt = dropdown->option_cnt - 1;\n    return opt;\n}"}, "position_to_selected": {"type": "Function", "def": "static void position_to_selected(lv_obj_t * dropdown_obj)", "sline": 1075, "body": "{\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)dropdown_obj;\n\n    lv_obj_t * label = get_label(dropdown_obj);\n    if(label == NULL) return;\n\n    if(lv_obj_get_height(label) <= lv_obj_get_content_height(dropdown_obj)) return;\n\n    const lv_font_t * font         = lv_obj_get_style_text_font(label, LV_PART_MAIN);\n    lv_coord_t font_h              = lv_font_get_line_height(font);\n    lv_coord_t line_space = lv_obj_get_style_text_line_space(label, LV_PART_MAIN);\n    lv_coord_t unit_h = font_h + line_space;\n    lv_coord_t line_y1 = dropdown->sel_opt_id * unit_h;\n\n    /*Scroll to the selected option*/\n    lv_obj_scroll_to_y(dropdown->list, line_y1, LV_ANIM_OFF);\n    lv_obj_invalidate(dropdown->list);\n}"}, "get_label": {"type": "Function", "def": "static lv_obj_t * get_label(const lv_obj_t * obj)", "sline": 1095, "body": "{\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n    if(dropdown->list == NULL) return NULL;\n\n    return lv_obj_get_child(dropdown->list, 0);\n}"}, "lv_dropdown_class": {"type": "Variable", "def": "const lv_obj_class_t lv_dropdown_class = {\n    .constructor_cb = lv_dropdown_constructor,\n    .destructor_cb = lv_dropdown_destructor,\n    .event_cb = lv_dropdown_event,\n    .width_def = LV_DPI_DEF,\n    .height_def = LV_SIZE_CONTENT,\n    .instance_size = sizeof(lv_dropdown_t),\n    .editable = LV_OBJ_CLASS_EDITABLE_TRUE,\n    .group_def = LV_OBJ_CLASS_GROUP_DEF_TRUE,\n    .base_class = &lv_obj_class\n}", "sline": 62}, "lv_dropdownlist_class": {"type": "Variable", "def": "const lv_obj_class_t lv_dropdownlist_class = {\n    .constructor_cb = lv_dropdownlist_constructor,\n    .destructor_cb = lv_dropdownlist_destructor,\n    .event_cb = lv_dropdown_list_event,\n    .instance_size = sizeof(lv_dropdown_list_t),\n    .base_class = &lv_obj_class\n}", "sline": 74}, "lv_dropdown_create": {"type": "Function", "def": "lv_obj_t * lv_dropdown_create(lv_obj_t * parent)", "sline": 91, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_dropdown_class, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_dropdown_set_text": {"type": "Function", "def": "void lv_dropdown_set_text(lv_obj_t * obj, const char * txt)", "sline": 103, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n    if(dropdown->text == txt) return;\n\n    dropdown->text = txt;\n\n    lv_obj_invalidate(obj);\n}"}, "lv_dropdown_set_options": {"type": "Function", "def": "void lv_dropdown_set_options(lv_obj_t * obj, const char * options)", "sline": 114, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(options);\n\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n\n    /*Count the '\\n'-s to determine the number of options*/\n    dropdown->option_cnt = 0;\n    uint32_t i;\n    for(i = 0; options[i] != '\\0'; i++) {\n        if(options[i] == '\\n') dropdown->option_cnt++;\n    }\n    dropdown->option_cnt++;   /*Last option has no `\\n`*/\n    dropdown->sel_opt_id      = 0;\n    dropdown->sel_opt_id_orig = 0;\n\n    /*Allocate space for the new text*/\n#if LV_USE_ARABIC_PERSIAN_CHARS == 0\n    size_t len = strlen(options) + 1;\n#else\n    size_t len = _lv_txt_ap_calc_bytes_cnt(options) + 1;\n#endif\n\n    if(dropdown->options != NULL && dropdown->static_txt == 0) {\n        lv_mem_free(dropdown->options);\n        dropdown->options = NULL;\n    }\n\n    dropdown->options = lv_mem_alloc(len);\n\n    LV_ASSERT_MALLOC(dropdown->options);\n    if(dropdown->options == NULL) return;\n\n#if LV_USE_ARABIC_PERSIAN_CHARS == 0\n    strcpy(dropdown->options, options);\n#else\n    _lv_txt_ap_proc(options, dropdown->options);\n#endif\n\n    /*Now the text is dynamically allocated*/\n    dropdown->static_txt = 0;\n\n    lv_obj_invalidate(obj);\n    if(dropdown->list) lv_obj_invalidate(dropdown->list);\n}"}, "lv_dropdown_set_options_static": {"type": "Function", "def": "void lv_dropdown_set_options_static(lv_obj_t * obj, const char * options)", "sline": 161, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(options);\n\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n\n    /*Count the '\\n'-s to determine the number of options*/\n    dropdown->option_cnt = 0;\n    uint32_t i;\n    for(i = 0; options[i] != '\\0'; i++) {\n        if(options[i] == '\\n') dropdown->option_cnt++;\n    }\n    dropdown->option_cnt++;   /*Last option has no `\\n`*/\n    dropdown->sel_opt_id      = 0;\n    dropdown->sel_opt_id_orig = 0;\n\n    if(dropdown->static_txt == 0 && dropdown->options != NULL) {\n        lv_mem_free(dropdown->options);\n        dropdown->options = NULL;\n    }\n\n    dropdown->static_txt = 1;\n    dropdown->options = (char *)options;\n\n    lv_obj_invalidate(obj);\n    if(dropdown->list) lv_obj_invalidate(dropdown->list);\n}"}, "lv_dropdown_add_option": {"type": "Function", "def": "void lv_dropdown_add_option(lv_obj_t * obj, const char * option, uint32_t pos)", "sline": 190, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(option);\n\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n\n    /*Convert static options to dynamic*/\n    if(dropdown->static_txt != 0) {\n        char * static_options = dropdown->options;\n        size_t len = strlen(static_options) + 1;\n\n        dropdown->options = lv_mem_alloc(len);\n        LV_ASSERT_MALLOC(dropdown->options);\n        if(dropdown->options == NULL) return;\n\n        strcpy(dropdown->options, static_options);\n        dropdown->static_txt = 0;\n    }\n\n    /*Allocate space for the new option*/\n    size_t old_len = (dropdown->options == NULL) ? 0 : strlen(dropdown->options);\n#if LV_USE_ARABIC_PERSIAN_CHARS == 0\n    size_t ins_len = strlen(option) + 1;\n#else\n    size_t ins_len = _lv_txt_ap_calc_bytes_cnt(option) + 1;\n#endif\n\n    size_t new_len = ins_len + old_len + 2; /*+2 for terminating NULL and possible \\n*/\n    dropdown->options        = lv_mem_realloc(dropdown->options, new_len + 1);\n    LV_ASSERT_MALLOC(dropdown->options);\n    if(dropdown->options == NULL) return;\n\n    dropdown->options[old_len] = '\\0';\n\n    /*Find the insert character position*/\n    uint32_t insert_pos = old_len;\n    if(pos != LV_DROPDOWN_POS_LAST) {\n        uint32_t opcnt = 0;\n        for(insert_pos = 0; dropdown->options[insert_pos] != 0; insert_pos++) {\n            if(opcnt == pos)\n                break;\n            if(dropdown->options[insert_pos] == '\\n')\n                opcnt++;\n        }\n    }\n\n    /*Add delimiter to existing options*/\n    if((insert_pos > 0) && (pos >= dropdown->option_cnt))\n        _lv_txt_ins(dropdown->options, _lv_txt_encoded_get_char_id(dropdown->options, insert_pos++), \"\\n\");\n\n    /*Insert the new option, adding \\n if necessary*/\n    char * ins_buf = lv_mem_buf_get(ins_len + 2); /*+ 2 for terminating NULL and possible \\n*/\n    LV_ASSERT_MALLOC(ins_buf);\n    if(ins_buf == NULL) return;\n#if LV_USE_ARABIC_PERSIAN_CHARS == 0\n    strcpy(ins_buf, option);\n#else\n    _lv_txt_ap_proc(option, ins_buf);\n#endif\n    if(pos < dropdown->option_cnt) strcat(ins_buf, \"\\n\");\n\n    _lv_txt_ins(dropdown->options, _lv_txt_encoded_get_char_id(dropdown->options, insert_pos), ins_buf);\n    lv_mem_buf_release(ins_buf);\n\n    dropdown->option_cnt++;\n\n    lv_obj_invalidate(obj);\n    if(dropdown->list) lv_obj_invalidate(dropdown->list);\n}"}, "lv_dropdown_clear_options": {"type": "Function", "def": "void lv_dropdown_clear_options(lv_obj_t * obj)", "sline": 261, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n    if(dropdown->options == NULL) return;\n\n    if(dropdown->static_txt == 0)\n        lv_mem_free(dropdown->options);\n\n    dropdown->options = NULL;\n    dropdown->static_txt = 0;\n    dropdown->option_cnt = 0;\n\n    lv_obj_invalidate(obj);\n    if(dropdown->list) lv_obj_invalidate(dropdown->list);\n}"}, "lv_dropdown_set_selected": {"type": "Function", "def": "void lv_dropdown_set_selected(lv_obj_t * obj, uint16_t sel_opt)", "sline": 278, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n    if(dropdown->sel_opt_id == sel_opt) return;\n\n    dropdown->sel_opt_id      = sel_opt < dropdown->option_cnt ? sel_opt : dropdown->option_cnt - 1;\n    dropdown->sel_opt_id_orig = dropdown->sel_opt_id;\n\n    lv_obj_invalidate(obj);\n}"}, "lv_dropdown_set_dir": {"type": "Function", "def": "void lv_dropdown_set_dir(lv_obj_t * obj, lv_dir_t dir)", "sline": 291, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n    if(dropdown->dir == dir) return;\n\n    dropdown->dir = dir;\n\n    lv_obj_invalidate(obj);\n}"}, "lv_dropdown_set_symbol": {"type": "Function", "def": "void lv_dropdown_set_symbol(lv_obj_t * obj, const void * symbol)", "sline": 303, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n    dropdown->symbol = symbol;\n    lv_obj_invalidate(obj);\n}"}, "lv_dropdown_set_selected_highlight": {"type": "Function", "def": "void lv_dropdown_set_selected_highlight(lv_obj_t * obj, bool en)", "sline": 312, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n    dropdown->selected_highlight = en;\n    if(dropdown->list) lv_obj_invalidate(dropdown->list);\n}"}, "lv_dropdown_get_list": {"type": "Function", "def": "lv_obj_t * lv_dropdown_get_list(lv_obj_t * obj)", "sline": 325, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n\n    return dropdown->list;\n\n}"}, "lv_dropdown_get_text": {"type": "Function", "def": "const char * lv_dropdown_get_text(lv_obj_t * obj)", "sline": 334, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n\n    return dropdown->text;\n}"}, "lv_dropdown_get_options": {"type": "Function", "def": "const char * lv_dropdown_get_options(const lv_obj_t * obj)", "sline": 342, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n    return dropdown->options == NULL ? \"\" : dropdown->options;\n}"}, "lv_dropdown_get_selected": {"type": "Function", "def": "uint16_t lv_dropdown_get_selected(const lv_obj_t * obj)", "sline": 350, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n\n    return dropdown->sel_opt_id;\n}"}, "lv_dropdown_get_option_cnt": {"type": "Function", "def": "uint16_t lv_dropdown_get_option_cnt(const lv_obj_t * obj)", "sline": 359, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n\n    return dropdown->option_cnt;\n}"}, "lv_dropdown_get_selected_str": {"type": "Function", "def": "void lv_dropdown_get_selected_str(const lv_obj_t * obj, char * buf, uint32_t buf_size)", "sline": 368, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n\n    uint32_t i;\n    uint32_t line        = 0;\n    size_t txt_len     = strlen(dropdown->options);\n\n    for(i = 0; i < txt_len && line != dropdown->sel_opt_id_orig; i++) {\n        if(dropdown->options[i] == '\\n') line++;\n    }\n\n    uint32_t c;\n    for(c = 0; i < txt_len && dropdown->options[i] != '\\n'; c++, i++) {\n        if(buf_size && c >= buf_size - 1) {\n            LV_LOG_WARN(\"lv_dropdown_get_selected_str: the buffer was too small\");\n            break;\n        }\n        buf[c] = dropdown->options[i];\n    }\n\n    buf[c] = '\\0';\n}"}, "lv_dropdown_get_symbol": {"type": "Function", "def": "const char * lv_dropdown_get_symbol(lv_obj_t * obj)", "sline": 394, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n    return dropdown->symbol;\n}"}, "lv_dropdown_get_selected_highlight": {"type": "Function", "def": "bool lv_dropdown_get_selected_highlight(lv_obj_t * obj)", "sline": 401, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n    return dropdown->selected_highlight;\n}"}, "lv_dropdown_get_dir": {"type": "Function", "def": "lv_dir_t lv_dropdown_get_dir(const lv_obj_t * obj)", "sline": 408, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n    return dropdown->dir;\n}"}, "lv_dropdown_open": {"type": "Function", "def": "void lv_dropdown_open(lv_obj_t * dropdown_obj)", "sline": 419, "body": "{\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)dropdown_obj;\n\n    lv_obj_add_state(dropdown_obj, LV_STATE_CHECKED);\n\n    if(dropdown->list == NULL) {\n        lv_obj_t * list_obj = lv_dropdown_list_create(lv_obj_get_screen(dropdown_obj));\n        ((lv_dropdown_list_t *) list_obj)->dropdown = dropdown_obj;\n        dropdown->list = list_obj;\n        lv_obj_clear_flag(dropdown->list, LV_OBJ_FLAG_CLICK_FOCUSABLE);\n        lv_obj_add_flag(dropdown->list, LV_OBJ_FLAG_IGNORE_LAYOUT);\n        lv_obj_update_layout(dropdown->list);\n    }\n\n    /*To allow styling the list*/\n    lv_event_send(dropdown_obj, LV_EVENT_READY, NULL);\n\n    lv_obj_t * label = get_label(dropdown_obj);\n    lv_label_set_text_static(label, dropdown->options);\n    lv_obj_set_width(dropdown->list, LV_SIZE_CONTENT);\n\n    lv_obj_update_layout(label);\n    /*Set smaller width to the width of the button*/\n    if(lv_obj_get_width(dropdown->list) <= lv_obj_get_width(dropdown_obj) &&\n       (dropdown->dir == LV_DIR_TOP || dropdown->dir == LV_DIR_BOTTOM)) {\n        lv_obj_set_width(dropdown->list, lv_obj_get_width(dropdown_obj));\n    }\n\n    lv_coord_t label_h = lv_obj_get_height(label);\n    lv_coord_t border_width = lv_obj_get_style_border_width(dropdown->list, LV_PART_MAIN);\n    lv_coord_t top = lv_obj_get_style_pad_top(dropdown->list, LV_PART_MAIN) + border_width;\n    lv_coord_t bottom = lv_obj_get_style_pad_bottom(dropdown->list, LV_PART_MAIN) + border_width;\n\n    lv_coord_t list_fit_h = label_h + top + bottom;\n    lv_coord_t list_h = list_fit_h;\n\n    lv_dir_t dir = dropdown->dir;\n    /*No space on the bottom? See if top is better.*/\n    if(dropdown->dir == LV_DIR_BOTTOM) {\n        if(dropdown_obj->coords.y2 + list_h > LV_VER_RES) {\n            if(dropdown_obj->coords.y1 > LV_VER_RES - dropdown_obj->coords.y2) {\n                /*There is more space on the top, so make it drop up*/\n                dir = LV_DIR_TOP;\n                list_h = dropdown_obj->coords.y1 - 1;\n            }\n            else {\n                list_h = LV_VER_RES - dropdown_obj->coords.y2 - 1 ;\n            }\n        }\n    }\n    /*No space on the top? See if bottom is better.*/\n    else if(dropdown->dir == LV_DIR_TOP) {\n        if(dropdown_obj->coords.y1 - list_h < 0) {\n            if(dropdown_obj->coords.y1 < LV_VER_RES - dropdown_obj->coords.y2) {\n                /*There is more space on the top, so make it drop up*/\n                dir = LV_DIR_BOTTOM;\n                list_h = LV_VER_RES - dropdown_obj->coords.y2;\n            }\n            else {\n                list_h = dropdown_obj->coords.y1;\n            }\n        }\n    }\n\n    if(list_h > list_fit_h) list_h = list_fit_h;\n    lv_obj_set_height(dropdown->list, list_h);\n\n    position_to_selected(dropdown_obj);\n\n    if(dir == LV_DIR_BOTTOM)     lv_obj_align_to(dropdown->list, dropdown_obj, LV_ALIGN_OUT_BOTTOM_LEFT, 0, 0);\n    else if(dir == LV_DIR_TOP)   lv_obj_align_to(dropdown->list, dropdown_obj, LV_ALIGN_OUT_TOP_LEFT, 0, 0);\n    else if(dir == LV_DIR_LEFT)  lv_obj_align_to(dropdown->list, dropdown_obj, LV_ALIGN_OUT_LEFT_TOP, 0, 0);\n    else if(dir == LV_DIR_RIGHT) lv_obj_align_to(dropdown->list, dropdown_obj, LV_ALIGN_OUT_RIGHT_TOP, 0, 0);\n\n    lv_obj_update_layout(dropdown->list);\n\n    if(dropdown->dir == LV_DIR_LEFT || dropdown->dir == LV_DIR_RIGHT) {\n        lv_coord_t y1 = lv_obj_get_y(dropdown->list);\n        lv_coord_t y2 = lv_obj_get_y2(dropdown->list);\n        if(y2 >= LV_VER_RES) {\n            lv_obj_set_y(dropdown->list, y1 - (y2 - LV_VER_RES) - 1);\n        }\n    }\n\n    lv_text_align_t align = lv_obj_calculate_style_text_align(label, LV_PART_MAIN, dropdown->options);\n\n    switch(align) {\n        default:\n        case LV_TEXT_ALIGN_LEFT:\n            lv_obj_align(label, LV_ALIGN_TOP_LEFT, 0, 0);\n            break;\n        case LV_TEXT_ALIGN_RIGHT:\n            lv_obj_align(label, LV_ALIGN_TOP_RIGHT, 0, 0);\n            break;\n        case LV_TEXT_ALIGN_CENTER:\n            lv_obj_align(label, LV_ALIGN_CENTER, 0, 0);\n            break;\n\n    }\n}"}, "lv_dropdown_close": {"type": "Function", "def": "void lv_dropdown_close(lv_obj_t * obj)", "sline": 521, "body": "{\n    lv_obj_clear_state(obj, LV_STATE_CHECKED);\n    lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;\n\n    dropdown->pr_opt_id = LV_DROPDOWN_PR_NONE;\n    if(dropdown->list) lv_obj_del(dropdown->list);\n\n    lv_event_send(obj, LV_EVENT_CANCEL, NULL);\n}"}, "carbit_updater/lvgl/src/widgets/lv_dropdown.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_dropdown.c"}}, "carbit_updater/lvgl/src/misc/lv_area.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 17}, "stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 18}, "lv_coord_t": {"type": "Variable", "def": "typedef int16_t lv_coord_t", "sline": 27}, "lv_point_t.x": {"type": "Variable", "def": "lv_coord_t x", "sline": 38, "in_struct": "lv_point_t", "rels": [["lv_coord_t", null, "Typeof"]]}, "lv_point_t.y": {"type": "Variable", "def": "lv_coord_t y", "sline": 39, "in_struct": "lv_point_t", "rels": [["lv_coord_t", null, "Typeof"]]}, "lv_point_t": {"type": "Variable", "def": "typedef struct {\n    lv_coord_t x;\n    lv_coord_t y;\n} lv_point_t", "sline": 40, "docstring": "/**"}, "lv_area_t.x1": {"type": "Variable", "def": "lv_coord_t x1", "sline": 44, "in_struct": "lv_area_t", "rels": [["lv_coord_t", null, "Typeof"]]}, "lv_area_t.y1": {"type": "Variable", "def": "lv_coord_t y1", "sline": 45, "in_struct": "lv_area_t", "rels": [["lv_coord_t", null, "Typeof"]]}, "lv_area_t.x2": {"type": "Variable", "def": "lv_coord_t x2", "sline": 46, "in_struct": "lv_area_t", "rels": [["lv_coord_t", null, "Typeof"]]}, "lv_area_t.y2": {"type": "Variable", "def": "lv_coord_t y2", "sline": 47, "in_struct": "lv_area_t", "rels": [["lv_coord_t", null, "Typeof"]]}, "lv_area_t": {"type": "Variable", "def": "typedef struct {\n    lv_coord_t x1;\n    lv_coord_t y1;\n    lv_coord_t x2;\n    lv_coord_t y2;\n} lv_area_t", "sline": 48, "docstring": "/** Represents an area of the screen.*/"}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_area.h:51:1)": {"type": "Enum", "def": "enum {\n    LV_ALIGN_DEFAULT = 0,\n    LV_ALIGN_TOP_LEFT,\n    LV_ALIGN_TOP_MID,\n    LV_ALIGN_TOP_RIGHT,\n    LV_ALIGN_BOTTOM_LEFT,\n    LV_ALIGN_BOTTOM_MID,\n    LV_ALIGN_BOTTOM_RIGHT,\n    LV_ALIGN_LEFT_MID,\n    LV_ALIGN_RIGHT_MID,\n    LV_ALIGN_CENTER,\n\n    LV_ALIGN_OUT_TOP_LEFT,\n    LV_ALIGN_OUT_TOP_MID,\n    LV_ALIGN_OUT_TOP_RIGHT,\n    LV_ALIGN_OUT_BOTTOM_LEFT,\n    LV_ALIGN_OUT_BOTTOM_MID,\n    LV_ALIGN_OUT_BOTTOM_RIGHT,\n    LV_ALIGN_OUT_LEFT_TOP,\n    LV_ALIGN_OUT_LEFT_MID,\n    LV_ALIGN_OUT_LEFT_BOTTOM,\n    LV_ALIGN_OUT_RIGHT_TOP,\n    LV_ALIGN_OUT_RIGHT_MID,\n    LV_ALIGN_OUT_RIGHT_BOTTOM,\n}", "sline": 51, "docstring": "/** Alignments*/"}, "lv_align_t": {"type": "Variable", "def": "typedef uint8_t lv_align_t", "sline": 76}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_area.h:78:1)": {"type": "Enum", "def": "enum {\n    LV_DIR_NONE     = 0x00,\n    LV_DIR_LEFT     = (1 << 0),\n    LV_DIR_RIGHT    = (1 << 1),\n    LV_DIR_TOP      = (1 << 2),\n    LV_DIR_BOTTOM   = (1 << 3),\n    LV_DIR_HOR      = LV_DIR_LEFT | LV_DIR_RIGHT,\n    LV_DIR_VER      = LV_DIR_TOP | LV_DIR_BOTTOM,\n    LV_DIR_ALL      = LV_DIR_HOR | LV_DIR_VER,\n}", "sline": 78}, "lv_dir_t": {"type": "Variable", "def": "typedef uint8_t lv_dir_t", "sline": 89}, "lv_area_set": {"type": "Function", "def": "void lv_area_set(lv_area_t * area_p, lv_coord_t x1, lv_coord_t y1, lv_coord_t x2, lv_coord_t y2)", "sline": 103}, "lv_area_copy": {"type": "Function", "def": "inline static void lv_area_copy(lv_area_t * dest, const lv_area_t * src)", "sline": 110, "body": "{\n    dest->x1 = src->x1;\n    dest->y1 = src->y1;\n    dest->x2 = src->x2;\n    dest->y2 = src->y2;\n}"}, "lv_area_get_width": {"type": "Function", "def": "static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)", "sline": 123, "body": "{\n    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);\n}", "rels": [["lv_coord_t", null, "Typeof"]]}, "lv_area_get_height": {"type": "Function", "def": "static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)", "sline": 133, "body": "{\n    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);\n}", "rels": [["lv_coord_t", null, "Typeof"]]}, "lv_area_set_width": {"type": "Function", "def": "void lv_area_set_width(lv_area_t * area_p, lv_coord_t w)", "sline": 143}, "lv_area_set_height": {"type": "Function", "def": "void lv_area_set_height(lv_area_t * area_p, lv_coord_t h)", "sline": 150}, "_lv_area_set_pos": {"type": "Function", "def": "void _lv_area_set_pos(lv_area_t * area_p, lv_coord_t x, lv_coord_t y)", "sline": 158}, "lv_area_get_size": {"type": "Function", "def": "uint32_t lv_area_get_size(const lv_area_t * area_p)", "sline": 165}, "lv_area_increase": {"type": "Function", "def": "void lv_area_increase(lv_area_t * area, lv_coord_t w_extra, lv_coord_t h_extra)", "sline": 167}, "lv_area_move": {"type": "Function", "def": "void lv_area_move(lv_area_t * area, lv_coord_t x_ofs, lv_coord_t y_ofs)", "sline": 169}, "_lv_area_intersect": {"type": "Function", "def": "bool _lv_area_intersect(lv_area_t * res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)", "sline": 178}, "_lv_area_join": {"type": "Function", "def": "void _lv_area_join(lv_area_t * a_res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)", "sline": 186}, "_lv_area_is_point_on": {"type": "Function", "def": "bool _lv_area_is_point_on(const lv_area_t * a_p, const lv_point_t * p_p, lv_coord_t radius)", "sline": 195}, "_lv_area_is_on": {"type": "Function", "def": "bool _lv_area_is_on(const lv_area_t * a1_p, const lv_area_t * a2_p)", "sline": 203}, "_lv_area_is_in": {"type": "Function", "def": "bool _lv_area_is_in(const lv_area_t * ain_p, const lv_area_t * aholder_p, lv_coord_t radius)", "sline": 212}, "_lv_area_is_out": {"type": "Function", "def": "bool _lv_area_is_out(const lv_area_t * aout_p, const lv_area_t * aholder_p, lv_coord_t radius)", "sline": 222}, "lv_area_align": {"type": "Function", "def": "void lv_area_align(const lv_area_t * base, lv_area_t * to_align, lv_align_t align, lv_coord_t ofs_x, lv_coord_t ofs_y)", "sline": 230}, "_silence_gcc_warning": {"type": "Struct", "def": "LV_EXPORT_CONST_INT(LV_COORD_MIN)", "sline": 269}, "lv_pct": {"type": "Function", "def": "static inline lv_coord_t lv_pct(lv_coord_t x)", "sline": 277, "body": "{\n    return LV_PCT(x);\n}", "rels": [["lv_coord_t", null, "Typeof"]]}, "carbit_updater/lvgl/src/misc/lv_area.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_area.h"}}, "carbit_updater/lvgl/lv_conf_template.h": {"carbit_updater/lvgl/lv_conf_template.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/lv_conf_template.h"}}, "carbit_updater/lvgl/src/widgets/lv_img.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "lv_obj": {"type": "Variable", "def": "#include ../core/lv_obj.h", "sline": 20}, "lv_fs": {"type": "Variable", "def": "#include ../misc/lv_fs.h", "sline": 21}, "lv_draw": {"type": "Variable", "def": "#include ../draw/lv_draw.h", "sline": 22}, "lv_img_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 36, "in_struct": "lv_img_t"}, "lv_img_t.src": {"type": "Variable", "def": "const void * src", "sline": 37, "in_struct": "lv_img_t"}, "lv_img_t.offset": {"type": "Variable", "def": "lv_point_t offset", "sline": 38, "in_struct": "lv_img_t"}, "lv_img_t.w": {"type": "Variable", "def": "lv_coord_t w", "sline": 39, "in_struct": "lv_img_t"}, "lv_img_t.h": {"type": "Variable", "def": "lv_coord_t h", "sline": 40, "in_struct": "lv_img_t"}, "lv_img_t.angle": {"type": "Variable", "def": "uint16_t angle", "sline": 41, "in_struct": "lv_img_t"}, "lv_img_t.pivot": {"type": "Variable", "def": "lv_point_t pivot", "sline": 42, "in_struct": "lv_img_t"}, "lv_img_t.zoom": {"type": "Variable", "def": "uint16_t zoom", "sline": 43, "in_struct": "lv_img_t"}, "lv_img_t.src_type": {"type": "Variable", "def": "uint8_t src_type : 2", "sline": 44, "in_struct": "lv_img_t"}, "lv_img_t.cf": {"type": "Variable", "def": "uint8_t cf : 5", "sline": 45, "in_struct": "lv_img_t"}, "lv_img_t.antialias": {"type": "Variable", "def": "uint8_t antialias : 1", "sline": 46, "in_struct": "lv_img_t"}, "lv_img_t.obj_size_mode": {"type": "Variable", "def": "uint8_t obj_size_mode: 2", "sline": 47, "in_struct": "lv_img_t"}, "lv_img_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    const void * src; /*Image source: Pointer to an array or a file or a symbol*/\n    lv_point_t offset;\n    lv_coord_t w;          /*Width of the image (Handled by the library)*/\n    lv_coord_t h;          /*Height of the image (Handled by the library)*/\n    uint16_t angle;    /*rotation angle of the image*/\n    lv_point_t pivot;     /*rotation center of the image*/\n    uint16_t zoom;         /*256 means no zoom, 512 double size, 128 half size*/\n    uint8_t src_type : 2;  /*See: lv_img_src_t*/\n    uint8_t cf : 5;        /*Color format from `lv_img_color_format_t`*/\n    uint8_t antialias : 1; /*Apply anti-aliasing in transformations (rotate, zoom)*/\n    uint8_t obj_size_mode: 2; /*Image size mode when image size and object size is different.*/\n} lv_img_t", "sline": 48, "docstring": "/**"}, "lv_img_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_img_class", "sline": 50}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_img.h:55:1)": {"type": "Enum", "def": "enum {\n    /** Zoom doesn't affect the coordinates of the object,\n     *  however if zoomed in the image is drawn out of the its coordinates.\n     *  The layout's won't change on zoom */\n    LV_IMG_SIZE_MODE_VIRTUAL = 0,\n\n    /** If the object size is set to SIZE_CONTENT, then object size equals zoomed image size.\n     *  It causes layout recalculation.\n     *  If the object size is set explicitly the the image will be cropped if zoomed in.*/\n    LV_IMG_SIZE_MODE_REAL,\n}", "sline": 55, "docstring": "/**"}, "lv_img_size_mode_t": {"type": "Variable", "def": "typedef uint8_t lv_img_size_mode_t", "sline": 67}, "lv_img_create": {"type": "Function", "def": "lv_obj_t * lv_img_create(lv_obj_t * parent)", "sline": 78}, "lv_img_set_src": {"type": "Function", "def": "void lv_img_set_src(lv_obj_t * obj, const void * src)", "sline": 91}, "lv_img_set_offset_x": {"type": "Function", "def": "void lv_img_set_offset_x(lv_obj_t * obj, lv_coord_t x)", "sline": 98}, "lv_img_set_offset_y": {"type": "Function", "def": "void lv_img_set_offset_y(lv_obj_t * obj, lv_coord_t y)", "sline": 106}, "lv_img_set_angle": {"type": "Function", "def": "void lv_img_set_angle(lv_obj_t * obj, int16_t angle)", "sline": 115}, "lv_img_set_pivot": {"type": "Function", "def": "void lv_img_set_pivot(lv_obj_t * obj, lv_coord_t x, lv_coord_t y)", "sline": 124}, "lv_img_set_zoom": {"type": "Function", "def": "void lv_img_set_zoom(lv_obj_t * obj, uint16_t zoom)", "sline": 137}, "lv_img_set_antialias": {"type": "Function", "def": "void lv_img_set_antialias(lv_obj_t * obj, bool antialias)", "sline": 145}, "lv_img_set_size_mode": {"type": "Function", "def": "void lv_img_set_size_mode(lv_obj_t * obj, lv_img_size_mode_t mode)", "sline": 153}, "lv_img_get_src": {"type": "Function", "def": "const void * lv_img_get_src(lv_obj_t * obj)", "sline": 163}, "lv_img_get_offset_x": {"type": "Function", "def": "lv_coord_t lv_img_get_offset_x(lv_obj_t * obj)", "sline": 170}, "lv_img_get_offset_y": {"type": "Function", "def": "lv_coord_t lv_img_get_offset_y(lv_obj_t * obj)", "sline": 177}, "lv_img_get_angle": {"type": "Function", "def": "uint16_t lv_img_get_angle(lv_obj_t * obj)", "sline": 184}, "lv_img_get_pivot": {"type": "Function", "def": "void lv_img_get_pivot(lv_obj_t * obj, lv_point_t * pivot)", "sline": 191}, "lv_img_get_zoom": {"type": "Function", "def": "uint16_t lv_img_get_zoom(lv_obj_t * obj)", "sline": 198}, "lv_img_get_antialias": {"type": "Function", "def": "bool lv_img_get_antialias(lv_obj_t * obj)", "sline": 205}, "lv_img_get_size_mode": {"type": "Function", "def": "lv_img_size_mode_t lv_img_get_size_mode(lv_obj_t * obj)", "sline": 212, "rels": [["lv_img_size_mode_t", null, "Typeof"]]}, "carbit_updater/lvgl/src/widgets/lv_img.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_img.h"}}, "carbit_updater/lvgl/src/misc/lv_anim_timeline.h": {"lv_anim": {"type": "Variable", "def": "#include lv_anim.h", "sline": 16, "include": ["carbit_updater/lvgl/src/misc/lv_anim.h", null]}, "_lv_anim_timeline_t": {"type": "Struct", "def": "struct _lv_anim_timeline_t", "sline": 26}, "lv_anim_timeline_t": {"type": "Variable", "def": "typedef struct _lv_anim_timeline_t lv_anim_timeline_t", "sline": 28}, "lv_anim_timeline_create": {"type": "Function", "def": "lv_anim_timeline_t * lv_anim_timeline_create(void)", "sline": 38}, "lv_anim_timeline_del": {"type": "Function", "def": "void lv_anim_timeline_del(lv_anim_timeline_t * at)", "sline": 44}, "lv_anim_timeline_add": {"type": "Function", "def": "void lv_anim_timeline_add(lv_anim_timeline_t * at, uint32_t start_time, lv_anim_t * a)", "sline": 52}, "lv_anim_timeline_start": {"type": "Function", "def": "uint32_t lv_anim_timeline_start(lv_anim_timeline_t * at)", "sline": 59}, "lv_anim_timeline_stop": {"type": "Function", "def": "void lv_anim_timeline_stop(lv_anim_timeline_t * at)", "sline": 65}, "lv_anim_timeline_set_reverse": {"type": "Function", "def": "void lv_anim_timeline_set_reverse(lv_anim_timeline_t * at, bool reverse)", "sline": 72}, "lv_anim_timeline_set_progress": {"type": "Function", "def": "void lv_anim_timeline_set_progress(lv_anim_timeline_t * at, uint16_t progress)", "sline": 79}, "lv_anim_timeline_get_playtime": {"type": "Function", "def": "uint32_t lv_anim_timeline_get_playtime(lv_anim_timeline_t * at)", "sline": 86}, "lv_anim_timeline_get_reverse": {"type": "Function", "def": "bool lv_anim_timeline_get_reverse(lv_anim_timeline_t * at)", "sline": 93}, "carbit_updater/lvgl/src/misc/lv_anim_timeline.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_anim_timeline.h"}}, "carbit_updater/lvgl/tests/src/lv_test_conf.h": {"custom_tick_get": {"type": "Function", "def": "uint32_t custom_tick_get(void)", "sline": 25}, "lv_user_data_t": {"type": "Variable", "def": "typedef void * lv_user_data_t", "sline": 28}, "carbit_updater/lvgl/tests/src/lv_test_conf.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/tests/src/lv_test_conf.h"}}, "carbit_updater/lvgl/src/misc/lv_mem.c": {"lv_mem": {"type": "Variable", "def": "#include lv_mem.h", "sline": 10, "include": ["carbit_updater/lvgl/src/misc/lv_mem.h", null]}, "lv_tlsf": {"type": "Variable", "def": "#include lv_tlsf.h", "sline": 11, "include": ["carbit_updater/lvgl/src/misc/lv_tlsf.h", null]}, "lv_gc": {"type": "Variable", "def": "#include lv_gc.h", "sline": 12, "include": ["carbit_updater/lvgl/src/misc/lv_gc.h", null]}, "lv_assert": {"type": "Variable", "def": "#include lv_assert.h", "sline": 13, "include": ["carbit_updater/lvgl/src/misc/lv_assert.h", null]}, "lv_log": {"type": "Variable", "def": "#include lv_log.h", "sline": 14, "include": ["carbit_updater/lvgl/src/misc/lv_log.h", null]}, "lv_mem_walker": {"type": "Function", "def": "static void lv_mem_walker(void * ptr, size_t size, int used, void * user)", "sline": 537, "body": "{\n    LV_UNUSED(ptr);\n\n    lv_mem_monitor_t * mon_p = user;\n    if(used) {\n        mon_p->used_cnt++;\n    }\n    else {\n        mon_p->free_cnt++;\n        mon_p->free_size += size;\n        if(size > mon_p->free_biggest_size)\n            mon_p->free_biggest_size = size;\n    }\n}"}, "tlsf": {"type": "Variable", "def": "static lv_tlsf_t tlsf", "sline": 57}, "zero_mem": {"type": "Variable", "def": "static uint32_t zero_mem = ZERO_MEM_SENTINEL", "sline": 60}, "lv_mem_init": {"type": "Function", "def": "void lv_mem_init(void)", "sline": 84, "docstring": "/**", "body": "{\n#if LV_MEM_CUSTOM == 0\n\n#if LV_MEM_ADR == 0\n#ifdef LV_MEM_POOL_ALLOC\n    tlsf = lv_tlsf_create_with_pool((void *)LV_MEM_POOL_ALLOC(LV_MEM_SIZE), LV_MEM_SIZE);\n#else\n    /*Allocate a large array to store the dynamically allocated data*/\n    static LV_ATTRIBUTE_LARGE_RAM_ARRAY MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];\n    tlsf = lv_tlsf_create_with_pool((void *)work_mem_int, LV_MEM_SIZE);\n#endif\n#else\n    tlsf = lv_tlsf_create_with_pool((void *)LV_MEM_ADR, LV_MEM_SIZE);\n#endif\n#endif\n\n#if LV_MEM_ADD_JUNK\n    LV_LOG_WARN(\"LV_MEM_ADD_JUNK is enabled which makes LVGL much slower\");\n#endif\n}"}, "lv_mem_deinit": {"type": "Function", "def": "void lv_mem_deinit(void)", "sline": 110, "body": "{\n#if LV_MEM_CUSTOM == 0\n    lv_tlsf_destroy(tlsf);\n    lv_mem_init();\n#endif\n}"}, "lv_mem_alloc": {"type": "Function", "def": "void * lv_mem_alloc(size_t size)", "sline": 123, "body": "{\n    MEM_TRACE(\"allocating %lu bytes\", (unsigned long)size);\n    if(size == 0) {\n        MEM_TRACE(\"using zero_mem\");\n        return &zero_mem;\n    }\n\n#if LV_MEM_CUSTOM == 0\n    void * alloc = lv_tlsf_malloc(tlsf, size);\n#else\n    void * alloc = LV_MEM_CUSTOM_ALLOC(size);\n#endif\n\n    if(alloc == NULL) {\n        LV_LOG_ERROR(\"couldn't allocate memory (%lu bytes)\", (unsigned long)size);\n        lv_mem_monitor_t mon;\n        lv_mem_monitor(&mon);\n        LV_LOG_ERROR(\"used: %6d (%3d %%), frag: %3d %%, biggest free: %6d\",\n                     (int)(mon.total_size - mon.free_size), mon.used_pct, mon.frag_pct,\n                     (int)mon.free_biggest_size);\n    }\n#if LV_MEM_ADD_JUNK\n    else {\n        lv_memset(alloc, 0xaa, size);\n    }\n#endif\n\n    MEM_TRACE(\"allocated at %p\", alloc);\n    return alloc;\n}"}, "lv_mem_free": {"type": "Function", "def": "void lv_mem_free(void * data)", "sline": 159, "body": "{\n    MEM_TRACE(\"freeing %p\", data);\n    if(data == &zero_mem) return;\n    if(data == NULL) return;\n\n#if LV_MEM_CUSTOM == 0\n#  if LV_MEM_ADD_JUNK\n    lv_memset(data, 0xbb, lv_tlsf_block_size(data));\n#  endif\n    lv_tlsf_free(tlsf, data);\n#else\n    LV_MEM_CUSTOM_FREE(data);\n#endif\n}"}, "lv_mem_realloc": {"type": "Function", "def": "void * lv_mem_realloc(void * data_p, size_t new_size)", "sline": 182, "body": "{\n    MEM_TRACE(\"reallocating %p with %lu size\", data_p, (unsigned long)new_size);\n    if(new_size == 0) {\n        MEM_TRACE(\"using zero_mem\");\n        lv_mem_free(data_p);\n        return &zero_mem;\n    }\n\n    if(data_p == &zero_mem) return lv_mem_alloc(new_size);\n\n#if LV_MEM_CUSTOM == 0\n    void * new_p = lv_tlsf_realloc(tlsf, data_p, new_size);\n#else\n    void * new_p = LV_MEM_CUSTOM_REALLOC(data_p, new_size);\n#endif\n    if(new_p == NULL) {\n        LV_LOG_ERROR(\"couldn't allocate memory\");\n        return NULL;\n    }\n\n    MEM_TRACE(\"allocated at %p\", new_p);\n    return new_p;\n}"}, "lv_mem_test": {"type": "Function", "def": "lv_res_t lv_mem_test(void)", "sline": 207, "body": "{\n    if(zero_mem != ZERO_MEM_SENTINEL) {\n        LV_LOG_WARN(\"zero_mem is written\");\n        return LV_RES_INV;\n    }\n\n#if LV_MEM_CUSTOM == 0\n    if(lv_tlsf_check(tlsf)) {\n        LV_LOG_WARN(\"failed\");\n        return LV_RES_INV;\n    }\n\n    if(lv_tlsf_check_pool(lv_tlsf_get_pool(tlsf))) {\n        LV_LOG_WARN(\"pool failed\");\n        return LV_RES_INV;\n    }\n#endif\n    MEM_TRACE(\"passed\");\n    return LV_RES_OK;\n}"}, "lv_mem_monitor": {"type": "Function", "def": "void lv_mem_monitor(lv_mem_monitor_t * mon_p)", "sline": 234, "body": "{\n    /*Init the data*/\n    lv_memset(mon_p, 0, sizeof(lv_mem_monitor_t));\n#if LV_MEM_CUSTOM == 0\n    MEM_TRACE(\"begin\");\n\n    lv_tlsf_walk_pool(lv_tlsf_get_pool(tlsf), lv_mem_walker, mon_p);\n\n    mon_p->total_size = LV_MEM_SIZE;\n    mon_p->used_pct = 100 - (100U * mon_p->free_size) / mon_p->total_size;\n    if(mon_p->free_size > 0) {\n        mon_p->frag_pct = mon_p->free_biggest_size * 100U / mon_p->free_size;\n        mon_p->frag_pct = 100 - mon_p->frag_pct;\n    }\n    else {\n        mon_p->frag_pct = 0; /*no fragmentation if all the RAM is used*/\n    }\n\n    MEM_TRACE(\"finished\");\n#endif\n}"}, "lv_mem_buf_get": {"type": "Function", "def": "void * lv_mem_buf_get(uint32_t size)", "sline": 262, "body": "{\n    if(size == 0) return NULL;\n\n    MEM_TRACE(\"begin, getting %d bytes\", size);\n\n    /*Try to find a free buffer with suitable size*/\n    int8_t i_guess = -1;\n    for(uint8_t i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {\n        if(LV_GC_ROOT(lv_mem_buf[i]).used == 0 && LV_GC_ROOT(lv_mem_buf[i]).size >= size) {\n            if(LV_GC_ROOT(lv_mem_buf[i]).size == size) {\n                LV_GC_ROOT(lv_mem_buf[i]).used = 1;\n                return LV_GC_ROOT(lv_mem_buf[i]).p;\n            }\n            else if(i_guess < 0) {\n                i_guess = i;\n            }\n            /*If size of `i` is closer to `size` prefer it*/\n            else if(LV_GC_ROOT(lv_mem_buf[i]).size < LV_GC_ROOT(lv_mem_buf[i_guess]).size) {\n                i_guess = i;\n            }\n        }\n    }\n\n    if(i_guess >= 0) {\n        LV_GC_ROOT(lv_mem_buf[i_guess]).used = 1;\n        MEM_TRACE(\"returning already allocated buffer (buffer id: %d, address: %p)\", i_guess,\n                  LV_GC_ROOT(lv_mem_buf[i_guess]).p);\n        return LV_GC_ROOT(lv_mem_buf[i_guess]).p;\n    }\n\n    /*Reallocate a free buffer*/\n    for(uint8_t i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {\n        if(LV_GC_ROOT(lv_mem_buf[i]).used == 0) {\n            /*if this fails you probably need to increase your LV_MEM_SIZE/heap size*/\n            void * buf = lv_mem_realloc(LV_GC_ROOT(lv_mem_buf[i]).p, size);\n            LV_ASSERT_MSG(buf != NULL, \"Out of memory, can't allocate a new buffer (increase your LV_MEM_SIZE/heap size)\");\n            if(buf == NULL) return NULL;\n\n            LV_GC_ROOT(lv_mem_buf[i]).used = 1;\n            LV_GC_ROOT(lv_mem_buf[i]).size = size;\n            LV_GC_ROOT(lv_mem_buf[i]).p    = buf;\n            MEM_TRACE(\"allocated (buffer id: %d, address: %p)\", i, LV_GC_ROOT(lv_mem_buf[i]).p);\n            return LV_GC_ROOT(lv_mem_buf[i]).p;\n        }\n    }\n\n    LV_LOG_ERROR(\"no more buffers. (increase LV_MEM_BUF_MAX_NUM)\");\n    LV_ASSERT_MSG(false, \"No more buffers. Increase LV_MEM_BUF_MAX_NUM.\");\n    return NULL;\n}"}, "lv_mem_buf_release": {"type": "Function", "def": "void lv_mem_buf_release(void * p)", "sline": 318, "body": "{\n    MEM_TRACE(\"begin (address: %p)\", p);\n\n    for(uint8_t i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {\n        if(LV_GC_ROOT(lv_mem_buf[i]).p == p) {\n            LV_GC_ROOT(lv_mem_buf[i]).used = 0;\n            return;\n        }\n    }\n\n    LV_LOG_ERROR(\"p is not a known buffer\");\n}"}, "lv_mem_buf_free_all": {"type": "Function", "def": "void lv_mem_buf_free_all(void)", "sline": 335, "docstring": "/**", "body": "{\n    for(uint8_t i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {\n        if(LV_GC_ROOT(lv_mem_buf[i]).p) {\n            lv_mem_free(LV_GC_ROOT(lv_mem_buf[i]).p);\n            LV_GC_ROOT(lv_mem_buf[i]).p = NULL;\n            LV_GC_ROOT(lv_mem_buf[i]).used = 0;\n            LV_GC_ROOT(lv_mem_buf[i]).size = 0;\n        }\n    }\n}"}, "lv_memcpy": {"type": "Function", "def": "void * lv_memcpy(void * dst, const void * src, size_t len)", "sline": 354, "body": "{\n    uint8_t * d8 = dst;\n    const uint8_t * s8 = src;\n\n    lv_uintptr_t d_align = (lv_uintptr_t)d8 & ALIGN_MASK;\n    lv_uintptr_t s_align = (lv_uintptr_t)s8 & ALIGN_MASK;\n\n    /*Byte copy for unaligned memories*/\n    if(s_align != d_align) {\n        while(len > 32) {\n            REPEAT8(COPY8);\n            REPEAT8(COPY8);\n            REPEAT8(COPY8);\n            REPEAT8(COPY8);\n            len -= 32;\n        }\n        while(len) {\n            COPY8\n            len--;\n        }\n        return dst;\n    }\n\n    /*Make the memories aligned*/\n    if(d_align) {\n        d_align = ALIGN_MASK + 1 - d_align;\n        while(d_align && len) {\n            COPY8;\n            d_align--;\n            len--;\n        }\n    }\n\n    uint32_t * d32 = (uint32_t *)d8;\n    const uint32_t * s32 = (uint32_t *)s8;\n    while(len > 32) {\n        REPEAT8(COPY32)\n        len -= 32;\n    }\n\n    while(len > 4) {\n        COPY32;\n        len -= 4;\n    }\n\n    d8 = (uint8_t *)d32;\n    s8 = (const uint8_t *)s32;\n    while(len) {\n        COPY8\n        len--;\n    }\n\n    return dst;\n}"}, "lv_memset": {"type": "Function", "def": "void lv_memset(void * dst, uint8_t v, size_t len)", "sline": 416, "body": "{\n\n    uint8_t * d8 = (uint8_t *)dst;\n\n    uintptr_t d_align = (lv_uintptr_t) d8 & ALIGN_MASK;\n\n    /*Make the address aligned*/\n    if(d_align) {\n        d_align = ALIGN_MASK + 1 - d_align;\n        while(d_align && len) {\n            SET8(v);\n            len--;\n            d_align--;\n        }\n    }\n\n    uint32_t v32 = (uint32_t)v + ((uint32_t)v << 8) + ((uint32_t)v << 16) + ((uint32_t)v << 24);\n\n    uint32_t * d32 = (uint32_t *)d8;\n\n    while(len > 32) {\n        REPEAT8(SET32(v32));\n        len -= 32;\n    }\n\n    while(len > 4) {\n        SET32(v32);\n        len -= 4;\n    }\n\n    d8 = (uint8_t *)d32;\n    while(len) {\n        SET8(v);\n        len--;\n    }\n}"}, "lv_memset_00": {"type": "Function", "def": "void lv_memset_00(void * dst, size_t len)", "sline": 459, "body": "{\n    uint8_t * d8 = (uint8_t *)dst;\n    uintptr_t d_align = (lv_uintptr_t) d8 & ALIGN_MASK;\n\n    /*Make the address aligned*/\n    if(d_align) {\n        d_align = ALIGN_MASK + 1 - d_align;\n        while(d_align && len) {\n            SET8(0);\n            len--;\n            d_align--;\n        }\n    }\n\n    uint32_t * d32 = (uint32_t *)d8;\n    while(len > 32) {\n        REPEAT8(SET32(0));\n        len -= 32;\n    }\n\n    while(len > 4) {\n        SET32(0);\n        len -= 4;\n    }\n\n    d8 = (uint8_t *)d32;\n    while(len) {\n        SET8(0);\n        len--;\n    }\n}"}, "lv_memset_ff": {"type": "Function", "def": "void lv_memset_ff(void * dst, size_t len)", "sline": 497, "body": "{\n    uint8_t * d8 = (uint8_t *)dst;\n    uintptr_t d_align = (lv_uintptr_t) d8 & ALIGN_MASK;\n\n    /*Make the address aligned*/\n    if(d_align) {\n        d_align = ALIGN_MASK + 1 - d_align;\n        while(d_align && len) {\n            SET8(0xFF);\n            len--;\n            d_align--;\n        }\n    }\n\n    uint32_t * d32 = (uint32_t *)d8;\n    while(len > 32) {\n        REPEAT8(SET32(0xFFFFFFFF));\n        len -= 32;\n    }\n\n    while(len > 4) {\n        SET32(0xFFFFFFFF);\n        len -= 4;\n    }\n\n    d8 = (uint8_t *)d32;\n    while(len) {\n        SET8(0xFF);\n        len--;\n    }\n}"}, "carbit_updater/lvgl/src/misc/lv_mem.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_mem.c"}}, "carbit_updater/lvgl/src/misc/lv_color.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "lv_assert": {"type": "Variable", "def": "#include lv_assert.h", "sline": 17, "include": ["carbit_updater/lvgl/src/misc/lv_assert.h", null]}, "lv_math": {"type": "Variable", "def": "#include lv_math.h", "sline": 18, "include": ["carbit_updater/lvgl/src/misc/lv_math.h", null]}, "lv_types": {"type": "Variable", "def": "#include lv_types.h", "sline": 19, "include": ["carbit_updater/lvgl/src/misc/lv_types.h", null]}, "stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 34}, "_silence_gcc_warning": {"type": "Struct", "def": "LV_EXPORT_CONST_INT(LV_COLOR_16_SWAP)", "sline": 40}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_color.h:45:1)": {"type": "Enum", "def": "enum {\n    LV_OPA_TRANSP = 0,\n    LV_OPA_0      = 0,\n    LV_OPA_10     = 25,\n    LV_OPA_20     = 51,\n    LV_OPA_30     = 76,\n    LV_OPA_40     = 102,\n    LV_OPA_50     = 127,\n    LV_OPA_60     = 153,\n    LV_OPA_70     = 178,\n    LV_OPA_80     = 204,\n    LV_OPA_90     = 229,\n    LV_OPA_100    = 255,\n    LV_OPA_COVER  = 255,\n}", "sline": 45, "docstring": "/**"}, "lv_color1_t.full": {"type": "Variable", "def": "uint8_t full", "sline": 195, "in_struct": "lv_color1_t"}, "lv_color1_t.ch": {"type": "Variable", "def": "union {\n        uint8_t blue : 1;\n        uint8_t green : 1;\n        uint8_t red : 1;\n    } ch", "sline": 200, "in_struct": "lv_color1_t"}, "lv_color1_t": {"type": "Variable", "def": "typedef union {\n    uint8_t full; /*must be declared first to set all bits of byte via initializer list*/\n    union {\n        uint8_t blue : 1;\n        uint8_t green : 1;\n        uint8_t red : 1;\n    } ch;\n} lv_color1_t", "sline": 201}, "lv_color8_t.ch": {"type": "Variable", "def": "struct {\n        uint8_t blue : 2;\n        uint8_t green : 3;\n        uint8_t red : 3;\n    } ch", "sline": 208, "in_struct": "lv_color8_t"}, "lv_color8_t.full": {"type": "Variable", "def": "uint8_t full", "sline": 209, "in_struct": "lv_color8_t"}, "lv_color8_t": {"type": "Variable", "def": "typedef union {\n    struct {\n        uint8_t blue : 2;\n        uint8_t green : 3;\n        uint8_t red : 3;\n    } ch;\n    uint8_t full;\n} lv_color8_t", "sline": 210}, "lv_color16_t.ch": {"type": "Variable", "def": "struct {\n#if LV_COLOR_16_SWAP == 0\n        uint16_t blue : 5;\n        uint16_t green : 6;\n        uint16_t red : 5;\n#else\n        uint16_t green_h : 3;\n        uint16_t red : 5;\n        uint16_t blue : 5;\n        uint16_t green_l : 3;\n#endif\n    } ch", "sline": 224, "in_struct": "lv_color16_t"}, "lv_color16_t.full": {"type": "Variable", "def": "uint16_t full", "sline": 225, "in_struct": "lv_color16_t"}, "lv_color16_t": {"type": "Variable", "def": "typedef union {\n    struct {\n#if LV_COLOR_16_SWAP == 0\n        uint16_t blue : 5;\n        uint16_t green : 6;\n        uint16_t red : 5;\n#else\n        uint16_t green_h : 3;\n        uint16_t red : 5;\n        uint16_t blue : 5;\n        uint16_t green_l : 3;\n#endif\n    } ch;\n    uint16_t full;\n} lv_color16_t", "sline": 226}, "lv_color32_t.ch": {"type": "Variable", "def": "struct {\n        uint8_t blue;\n        uint8_t green;\n        uint8_t red;\n        uint8_t alpha;\n    } ch", "sline": 234, "in_struct": "lv_color32_t"}, "lv_color32_t.full": {"type": "Variable", "def": "uint32_t full", "sline": 235, "in_struct": "lv_color32_t"}, "lv_color32_t": {"type": "Variable", "def": "typedef union {\n    struct {\n        uint8_t blue;\n        uint8_t green;\n        uint8_t red;\n        uint8_t alpha;\n    } ch;\n    uint32_t full;\n} lv_color32_t", "sline": 236}, "lv_color_int_t": {"type": "Variable", "def": "typedef LV_CONCAT3(uint, LV_COLOR_SIZE, _t) lv_color_int_t", "sline": 238}, "lv_color_t": {"type": "Variable", "def": "typedef LV_CONCAT3(lv_color, LV_COLOR_DEPTH, _t) lv_color_t", "sline": 239, "rels": [["lv_color32_t", null, "Typeof"]]}, "lv_color_hsv_t.h": {"type": "Variable", "def": "uint16_t h", "sline": 242, "in_struct": "lv_color_hsv_t"}, "lv_color_hsv_t.s": {"type": "Variable", "def": "uint8_t s", "sline": 243, "in_struct": "lv_color_hsv_t"}, "lv_color_hsv_t.v": {"type": "Variable", "def": "uint8_t v", "sline": 244, "in_struct": "lv_color_hsv_t"}, "lv_color_hsv_t": {"type": "Variable", "def": "typedef struct {\n    uint16_t h;\n    uint8_t s;\n    uint8_t v;\n} lv_color_hsv_t", "sline": 245}, "lv_opa_t": {"type": "Variable", "def": "typedef uint8_t lv_opa_t", "sline": 249, "docstring": "//! @cond Doxygen_Suppress\n/*No idea where the guard is required but else throws warnings in the docs*/"}, "_lv_color_filter_dsc_t": {"type": "Struct", "def": "struct _lv_color_filter_dsc_t {\n    lv_color_filter_cb_t filter_cb;\n    void * user_data;\n}", "sline": 256, "body": "lv_color_filter_cb_t filter_cb\nvoid * user_data\n"}, "lv_color_filter_cb_t": {"type": "Variable", "def": "typedef lv_color_t (*lv_color_filter_cb_t)(const struct _lv_color_filter_dsc_t *, lv_color_t, lv_opa_t)", "sline": 254}, "_lv_color_filter_dsc_t.filter_cb": {"type": "Variable", "def": "lv_color_filter_cb_t filter_cb", "sline": 257, "in_struct": "_lv_color_filter_dsc_t", "rels": [["lv_color_filter_cb_t", null, "Typeof"]]}, "_lv_color_filter_dsc_t.user_data": {"type": "Variable", "def": "void * user_data", "sline": 258, "in_struct": "_lv_color_filter_dsc_t"}, "lv_color_filter_dsc_t": {"type": "Variable", "def": "typedef struct _lv_color_filter_dsc_t {\n    lv_color_filter_cb_t filter_cb;\n    void * user_data;\n} lv_color_filter_dsc_t", "sline": 259}, "lv_palette_t": {"type": "Variable", "def": "typedef enum {\n    LV_PALETTE_RED,\n    LV_PALETTE_PINK,\n    LV_PALETTE_PURPLE,\n    LV_PALETTE_DEEP_PURPLE,\n    LV_PALETTE_INDIGO,\n    LV_PALETTE_BLUE,\n    LV_PALETTE_LIGHT_BLUE,\n    LV_PALETTE_CYAN,\n    LV_PALETTE_TEAL,\n    LV_PALETTE_GREEN,\n    LV_PALETTE_LIGHT_GREEN,\n    LV_PALETTE_LIME,\n    LV_PALETTE_YELLOW,\n    LV_PALETTE_AMBER,\n    LV_PALETTE_ORANGE,\n    LV_PALETTE_DEEP_ORANGE,\n    LV_PALETTE_BROWN,\n    LV_PALETTE_BLUE_GREY,\n    LV_PALETTE_GREY,\n    _LV_PALETTE_LAST,\n    LV_PALETTE_NONE = 0xff,\n} lv_palette_t", "sline": 284}, "lv_color_to1": {"type": "Function", "def": "static inline uint8_t lv_color_to1(lv_color_t color)", "sline": 303, "body": "{\n#if LV_COLOR_DEPTH == 1\n    return color.full;\n#elif LV_COLOR_DEPTH == 8\n    if((LV_COLOR_GET_R(color) & 0x4) || (LV_COLOR_GET_G(color) & 0x4) || (LV_COLOR_GET_B(color) & 0x2)) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n#elif LV_COLOR_DEPTH == 16\n    if((LV_COLOR_GET_R(color) & 0x10) || (LV_COLOR_GET_G(color) & 0x20) || (LV_COLOR_GET_B(color) & 0x10)) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n#elif LV_COLOR_DEPTH == 32\n    if((LV_COLOR_GET_R(color) & 0x80) || (LV_COLOR_GET_G(color) & 0x80) || (LV_COLOR_GET_B(color) & 0x80)) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n#endif\n}"}, "lv_color_to8": {"type": "Function", "def": "static inline uint8_t lv_color_to8(lv_color_t color)", "sline": 331, "body": "{\n#if LV_COLOR_DEPTH == 1\n    if(color.full == 0)\n        return 0;\n    else\n        return 0xFF;\n#elif LV_COLOR_DEPTH == 8\n    return color.full;\n#elif LV_COLOR_DEPTH == 16\n    lv_color8_t ret;\n    LV_COLOR_SET_R8(ret, LV_COLOR_GET_R(color) >> 2); /*5 - 3  = 2*/\n    LV_COLOR_SET_G8(ret, LV_COLOR_GET_G(color) >> 3); /*6 - 3  = 3*/\n    LV_COLOR_SET_B8(ret, LV_COLOR_GET_B(color) >> 3); /*5 - 2  = 3*/\n    return ret.full;\n#elif LV_COLOR_DEPTH == 32\n    lv_color8_t ret;\n    LV_COLOR_SET_R8(ret, LV_COLOR_GET_R(color) >> 5); /*8 - 3  = 5*/\n    LV_COLOR_SET_G8(ret, LV_COLOR_GET_G(color) >> 5); /*8 - 3  = 5*/\n    LV_COLOR_SET_B8(ret, LV_COLOR_GET_B(color) >> 6); /*8 - 2  = 6*/\n    return ret.full;\n#endif\n}"}, "lv_color_to16": {"type": "Function", "def": "static inline uint16_t lv_color_to16(lv_color_t color)", "sline": 355, "body": "{\n#if LV_COLOR_DEPTH == 1\n    if(color.full == 0)\n        return 0;\n    else\n        return 0xFFFF;\n#elif LV_COLOR_DEPTH == 8\n    lv_color16_t ret;\n    LV_COLOR_SET_R16(ret, LV_COLOR_GET_R(color) * 4);  /*(2^5 - 1)/(2^3 - 1) = 31/7 = 4*/\n    LV_COLOR_SET_G16(ret, LV_COLOR_GET_G(color) * 9);  /*(2^6 - 1)/(2^3 - 1) = 63/7 = 9*/\n    LV_COLOR_SET_B16(ret, LV_COLOR_GET_B(color) * 10); /*(2^5 - 1)/(2^2 - 1) = 31/3 = 10*/\n    return ret.full;\n#elif LV_COLOR_DEPTH == 16\n    return color.full;\n#elif LV_COLOR_DEPTH == 32\n    lv_color16_t ret;\n    LV_COLOR_SET_R16(ret, LV_COLOR_GET_R(color) >> 3); /*8 - 5  = 3*/\n    LV_COLOR_SET_G16(ret, LV_COLOR_GET_G(color) >> 2); /*8 - 6  = 2*/\n    LV_COLOR_SET_B16(ret, LV_COLOR_GET_B(color) >> 3); /*8 - 5  = 3*/\n    return ret.full;\n#endif\n}"}, "lv_color_to32": {"type": "Function", "def": "static inline uint32_t lv_color_to32(lv_color_t color)", "sline": 379, "body": "{\n#if LV_COLOR_DEPTH == 1\n    if(color.full == 0)\n        return 0xFF000000;\n    else\n        return 0xFFFFFFFF;\n#elif LV_COLOR_DEPTH == 8\n    lv_color32_t ret;\n    LV_COLOR_SET_R32(ret, LV_COLOR_GET_R(color) * 36); /*(2^8 - 1)/(2^3 - 1) = 255/7 = 36*/\n    LV_COLOR_SET_G32(ret, LV_COLOR_GET_G(color) * 36); /*(2^8 - 1)/(2^3 - 1) = 255/7 = 36*/\n    LV_COLOR_SET_B32(ret, LV_COLOR_GET_B(color) * 85); /*(2^8 - 1)/(2^2 - 1) = 255/3 = 85*/\n    LV_COLOR_SET_A32(ret, 0xFF);\n    return ret.full;\n#elif LV_COLOR_DEPTH == 16\n    /**\n     * The floating point math for conversion is:\n     *  valueto = valuefrom * ( (2^bitsto - 1) / (float)(2^bitsfrom - 1) )\n     * The faster integer math for conversion is:\n     *  valueto = ( valuefrom * multiplier + adder ) >> divisor\n     *   multiplier = FLOOR( ( (2^bitsto - 1) << divisor ) / (float)(2^bitsfrom - 1) )\n     *\n     * Find the first divisor where ( adder >> divisor ) <= 0\n     *\n     * 5-bit to 8-bit: ( 31 * multiplier + adder ) >> divisor = 255\n     * divisor  multiplier  adder  min (0)  max (31)\n     *       0           8      7        7       255\n     *       1          16     14        7       255\n     *       2          32     28        7       255\n     *       3          65     25        3       255\n     *       4         131     19        1       255\n     *       5         263      7        0       255\n     *\n     * 6-bit to 8-bit: 255 = ( 63 * multiplier + adder ) >> divisor\n     * divisor  multiplier  adder  min (0)  max (63)\n     *       0           4      3        3       255\n     *       1           8      6        3       255\n     *       2          16     12        3       255\n     *       3          32     24        3       255\n     *       4          64     48        3       255\n     *       5         129     33        1       255\n     *       6         259      3        0       255\n     */\n\n    lv_color32_t ret;\n    LV_COLOR_SET_R32(ret, (LV_COLOR_GET_R(color) * 263 + 7) >> 5);\n    LV_COLOR_SET_G32(ret, (LV_COLOR_GET_G(color) * 259 + 3) >> 6);\n    LV_COLOR_SET_B32(ret, (LV_COLOR_GET_B(color) * 263 + 7) >> 5);\n    LV_COLOR_SET_A32(ret, 0xFF);\n    return ret.full;\n#elif LV_COLOR_DEPTH == 32\n    return color.full;\n#endif\n}"}, "lv_color_mix": {"type": "Function", "def": "static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)", "sline": 443, "body": "{\n    lv_color_t ret;\n\n#if LV_COLOR_DEPTH == 16 && LV_COLOR_16_SWAP == 0\n    /*Source: https://stackoverflow.com/a/50012418/1999969*/\n    mix = (mix + 4) >> 3;\n    uint32_t bg = (uint32_t)((uint32_t)c2.full | ((uint32_t)c2.full << 16)) &\n                  0x7E0F81F; /*0b00000111111000001111100000011111*/\n    uint32_t fg = (uint32_t)((uint32_t)c1.full | ((uint32_t)c1.full << 16)) & 0x7E0F81F;\n    uint32_t result = ((((fg - bg) * mix) >> 5) + bg) & 0x7E0F81F;\n    ret.full = (uint16_t)((result >> 16) | result);\n#elif LV_COLOR_DEPTH != 1\n    /*LV_COLOR_DEPTH == 8, 16 or 32*/\n    LV_COLOR_SET_R(ret, LV_UDIV255((uint16_t)LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *\n                                   (255 - mix) + LV_COLOR_MIX_ROUND_OFS));\n    LV_COLOR_SET_G(ret, LV_UDIV255((uint16_t)LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *\n                                   (255 - mix) + LV_COLOR_MIX_ROUND_OFS));\n    LV_COLOR_SET_B(ret, LV_UDIV255((uint16_t)LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *\n                                   (255 - mix) + LV_COLOR_MIX_ROUND_OFS));\n    LV_COLOR_SET_A(ret, 0xFF);\n#else\n    /*LV_COLOR_DEPTH == 1*/\n    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;\n#endif\n\n    return ret;\n}", "rels": [["lv_color_t", null, "Typeof"]]}, "lv_color_premult": {"type": "Function", "def": "static inline void lv_color_premult(lv_color_t c, uint8_t mix, uint16_t * out)", "sline": 472, "body": "{\n#if LV_COLOR_DEPTH != 1\n    out[0] = (uint16_t)LV_COLOR_GET_R(c) * mix;\n    out[1] = (uint16_t)LV_COLOR_GET_G(c) * mix;\n    out[2] = (uint16_t)LV_COLOR_GET_B(c) * mix;\n#else\n    (void) mix;\n    /*Pre-multiplication can't be used with 1 bpp*/\n    out[0] = LV_COLOR_GET_R(c);\n    out[1] = LV_COLOR_GET_G(c);\n    out[2] = LV_COLOR_GET_B(c);\n#endif\n\n}"}, "lv_color_mix_premult": {"type": "Function", "def": "static inline lv_color_t lv_color_mix_premult(uint16_t * premult_c1, lv_color_t c2, uint8_t mix)", "sline": 497, "body": "{\n    lv_color_t ret;\n#if LV_COLOR_DEPTH != 1\n    /*LV_COLOR_DEPTH == 8 or 32*/\n    LV_COLOR_SET_R(ret, LV_UDIV255(premult_c1[0] + LV_COLOR_GET_R(c2) * mix + LV_COLOR_MIX_ROUND_OFS));\n    LV_COLOR_SET_G(ret, LV_UDIV255(premult_c1[1] + LV_COLOR_GET_G(c2) * mix + LV_COLOR_MIX_ROUND_OFS));\n    LV_COLOR_SET_B(ret, LV_UDIV255(premult_c1[2] + LV_COLOR_GET_B(c2) * mix + LV_COLOR_MIX_ROUND_OFS));\n    LV_COLOR_SET_A(ret, 0xFF);\n#else\n    /*LV_COLOR_DEPTH == 1*/\n    /*Restore color1*/\n    lv_color_t c1;\n    LV_COLOR_SET_R(c1, premult_c1[0]);\n    LV_COLOR_SET_G(c1, premult_c1[1]);\n    LV_COLOR_SET_B(c1, premult_c1[2]);\n    ret.full = mix > LV_OPA_50 ? c2.full : c1.full;\n#endif\n\n    return ret;\n}", "rels": [["lv_color_t", null, "Typeof"]]}, "lv_color_mix_with_alpha": {"type": "Function", "def": "static inline void lv_color_mix_with_alpha(lv_color_t bg_color, lv_opa_t bg_opa,\n                                                                 lv_color_t fg_color, lv_opa_t fg_opa,\n                                                                 lv_color_t * res_color, lv_opa_t * res_opa)", "sline": 528, "body": "{\n    /*Pick the foreground if it's fully opaque or the Background is fully transparent*/\n    if(fg_opa >= LV_OPA_MAX || bg_opa <= LV_OPA_MIN) {\n        res_color->full = fg_color.full;\n        *res_opa = fg_opa;\n    }\n    /*Transparent foreground: use the Background*/\n    else if(fg_opa <= LV_OPA_MIN) {\n        res_color->full = bg_color.full;\n        *res_opa = bg_opa;\n    }\n    /*Opaque background: use simple mix*/\n    else if(bg_opa >= LV_OPA_MAX) {\n        *res_color = lv_color_mix(fg_color, bg_color, fg_opa);\n        *res_opa = LV_OPA_COVER;\n    }\n    /*Both colors have alpha. Expensive calculation need to be applied*/\n    else {\n        /*Save the parameters and the result. If they will be asked again don't compute again*/\n        static lv_opa_t fg_opa_save     = 0;\n        static lv_opa_t bg_opa_save     = 0;\n        static lv_color_t fg_color_save = _LV_COLOR_ZERO_INITIALIZER;\n        static lv_color_t bg_color_save = _LV_COLOR_ZERO_INITIALIZER;\n        static lv_color_t res_color_saved = _LV_COLOR_ZERO_INITIALIZER;\n        static lv_opa_t res_opa_saved = 0;\n\n        if(fg_opa != fg_opa_save || bg_opa != bg_opa_save || fg_color.full != fg_color_save.full ||\n           bg_color.full != bg_color_save.full) {\n            fg_opa_save        = fg_opa;\n            bg_opa_save        = bg_opa;\n            fg_color_save.full = fg_color.full;\n            bg_color_save.full = bg_color.full;\n            /*Info:\n             * https://en.wikipedia.org/wiki/Alpha_compositing#Analytical_derivation_of_the_over_operator*/\n            res_opa_saved = 255 - ((uint16_t)((uint16_t)(255 - fg_opa) * (255 - bg_opa)) >> 8);\n            LV_ASSERT(res_opa_saved != 0);\n            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved;\n            res_color_saved = lv_color_mix(fg_color, bg_color, ratio);\n\n        }\n\n        res_color->full = res_color_saved.full;\n        *res_opa = res_opa_saved;\n    }\n}"}, "lv_color_brightness": {"type": "Function", "def": "static inline uint8_t lv_color_brightness(lv_color_t color)", "sline": 584, "body": "{\n    lv_color32_t c32;\n    c32.full        = lv_color_to32(color);\n    uint16_t bright = (uint16_t)(3u * LV_COLOR_GET_R32(c32) + LV_COLOR_GET_B32(c32) + 4u * LV_COLOR_GET_G32(c32));\n    return (uint8_t)(bright >> 3);\n}"}, "lv_color_make": {"type": "Function", "def": "static inline lv_color_t lv_color_make(uint8_t r, uint8_t g, uint8_t b)", "sline": 592, "body": "{\n    return _LV_COLOR_MAKE_TYPE_HELPER LV_COLOR_MAKE(r, g, b);\n}", "rels": [["lv_color_t", null, "Typeof"]]}, "lv_color_hex": {"type": "Function", "def": "static inline lv_color_t lv_color_hex(uint32_t c)", "sline": 597, "body": "{\n    return lv_color_make((uint8_t)((c >> 16) & 0xFF), (uint8_t)((c >> 8) & 0xFF), (uint8_t)(c & 0xFF));\n}", "rels": [["lv_color_t", null, "Typeof"]]}, "lv_color_hex3": {"type": "Function", "def": "static inline lv_color_t lv_color_hex3(uint32_t c)", "sline": 602, "body": "{\n    return lv_color_make((uint8_t)(((c >> 4) & 0xF0) | ((c >> 8) & 0xF)), (uint8_t)((c & 0xF0) | ((c & 0xF0) >> 4)),\n                         (uint8_t)((c & 0xF) | ((c & 0xF) << 4)));\n}", "rels": [["lv_color_t", null, "Typeof"]]}, "lv_color_filter_dsc_init": {"type": "Function", "def": "static inline void lv_color_filter_dsc_init(lv_color_filter_dsc_t * dsc, lv_color_filter_cb_t cb)", "sline": 608, "body": "{\n    dsc->filter_cb = cb;\n}"}, "lv_color_fill": {"type": "Function", "def": "void lv_color_fill(lv_color_t * buf, lv_color_t color, uint32_t px_num)", "sline": 615}, "lv_color_lighten": {"type": "Function", "def": "lv_color_t lv_color_lighten(lv_color_t c, lv_opa_t lvl)", "sline": 618, "rels": [["lv_color_t", null, "Typeof"]]}, "lv_color_darken": {"type": "Function", "def": "lv_color_t lv_color_darken(lv_color_t c, lv_opa_t lvl)", "sline": 620, "rels": [["lv_color_t", null, "Typeof"]]}, "lv_color_change_lightness": {"type": "Function", "def": "lv_color_t lv_color_change_lightness(lv_color_t c, lv_opa_t lvl)", "sline": 622, "rels": [["lv_color_t", null, "Typeof"]]}, "lv_color_hsv_to_rgb": {"type": "Function", "def": "lv_color_t lv_color_hsv_to_rgb(uint16_t h, uint8_t s, uint8_t v)", "sline": 631, "rels": [["lv_color_t", null, "Typeof"]]}, "lv_color_rgb_to_hsv": {"type": "Function", "def": "lv_color_hsv_t lv_color_rgb_to_hsv(uint8_t r8, uint8_t g8, uint8_t b8)", "sline": 640, "rels": [["lv_color_hsv_t", null, "Typeof"]]}, "lv_color_to_hsv": {"type": "Function", "def": "lv_color_hsv_t lv_color_to_hsv(lv_color_t color)", "sline": 647, "rels": [["lv_color_hsv_t", null, "Typeof"]]}, "lv_color_chroma_key": {"type": "Function", "def": "static inline lv_color_t lv_color_chroma_key(void)", "sline": 653, "body": "{\n    return LV_COLOR_CHROMA_KEY;\n}", "rels": [["lv_color_t", null, "Typeof"]]}, "lv_palette_main": {"type": "Function", "def": "lv_color_t lv_palette_main(lv_palette_t p)", "sline": 663, "rels": [["lv_color_t", null, "Typeof"]]}, "lv_color_white": {"type": "Function", "def": "static inline lv_color_t lv_color_white(void)", "sline": 664, "docstring": "/*Source: https://vuetifyjs.com/en/styles/colors/#material-colors*/", "body": "{\n    return lv_color_make(0xff, 0xff, 0xff);\n}", "rels": [["lv_color_t", null, "Typeof"]]}, "lv_color_black": {"type": "Function", "def": "static inline lv_color_t lv_color_black(void)", "sline": 668, "body": "{\n    return lv_color_make(0x00, 0x0, 0x00);\n}", "rels": [["lv_color_t", null, "Typeof"]]}, "lv_palette_lighten": {"type": "Function", "def": "lv_color_t lv_palette_lighten(lv_palette_t p, uint8_t lvl)", "sline": 672, "rels": [["lv_color_t", null, "Typeof"]]}, "lv_palette_darken": {"type": "Function", "def": "lv_color_t lv_palette_darken(lv_palette_t p, uint8_t lvl)", "sline": 673, "rels": [["lv_color_t", null, "Typeof"]]}, "carbit_updater/lvgl/src/misc/lv_color.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_color.h"}}, "carbit_updater/lvgl/src/core/lv_obj_pos.h": {"lv_area": {"type": "Variable", "def": "#include ../misc/lv_area.h", "sline": 16}, "_lv_obj_t": {"type": "Struct", "def": "struct _lv_obj_t", "sline": 25, "docstring": "/**********************"}, "lv_layout_update_cb_t": {"type": "Variable", "def": "typedef void (*lv_layout_update_cb_t)(struct _lv_obj_t *, void * user_data)", "sline": 27}, "lv_layout_dsc_t.cb": {"type": "Variable", "def": "lv_layout_update_cb_t cb", "sline": 29, "in_struct": "lv_layout_dsc_t", "rels": [["lv_layout_update_cb_t", null, "Typeof"]]}, "lv_layout_dsc_t.user_data": {"type": "Variable", "def": "void * user_data", "sline": 30, "in_struct": "lv_layout_dsc_t"}, "lv_layout_dsc_t": {"type": "Variable", "def": "typedef struct {\n    lv_layout_update_cb_t cb;\n    void * user_data;\n} lv_layout_dsc_t", "sline": 31}, "lv_obj_set_pos": {"type": "Function", "def": "void lv_obj_set_pos(struct _lv_obj_t * obj, lv_coord_t x, lv_coord_t y)", "sline": 43}, "lv_obj_set_x": {"type": "Function", "def": "void lv_obj_set_x(struct _lv_obj_t * obj, lv_coord_t x)", "sline": 50}, "lv_obj_set_y": {"type": "Function", "def": "void lv_obj_set_y(struct _lv_obj_t * obj, lv_coord_t y)", "sline": 57}, "lv_obj_set_size": {"type": "Function", "def": "void lv_obj_set_size(struct _lv_obj_t * obj, lv_coord_t w, lv_coord_t h)", "sline": 70}, "lv_obj_refr_size": {"type": "Function", "def": "bool lv_obj_refr_size(struct _lv_obj_t * obj)", "sline": 77}, "lv_obj_set_width": {"type": "Function", "def": "void lv_obj_set_width(struct _lv_obj_t * obj, lv_coord_t w)", "sline": 89}, "lv_obj_set_height": {"type": "Function", "def": "void lv_obj_set_height(struct _lv_obj_t * obj, lv_coord_t h)", "sline": 101}, "lv_obj_set_content_width": {"type": "Function", "def": "void lv_obj_set_content_width(struct _lv_obj_t * obj, lv_coord_t w)", "sline": 108}, "lv_obj_set_content_height": {"type": "Function", "def": "void lv_obj_set_content_height(struct _lv_obj_t * obj, lv_coord_t h)", "sline": 115}, "lv_obj_set_layout": {"type": "Function", "def": "void lv_obj_set_layout(struct _lv_obj_t * obj, uint32_t layout)", "sline": 122}, "lv_obj_is_layout_positioned": {"type": "Function", "def": "bool lv_obj_is_layout_positioned(const struct _lv_obj_t * obj)", "sline": 129}, "lv_obj_mark_layout_as_dirty": {"type": "Function", "def": "void lv_obj_mark_layout_as_dirty(struct _lv_obj_t * obj)", "sline": 135}, "lv_obj_update_layout": {"type": "Function", "def": "void lv_obj_update_layout(const struct _lv_obj_t * obj)", "sline": 141}, "lv_layout_register": {"type": "Function", "def": "uint32_t lv_layout_register(lv_layout_update_cb_t cb, void * user_data)", "sline": 149}, "lv_obj_set_align": {"type": "Function", "def": "void lv_obj_set_align(struct _lv_obj_t * obj, lv_align_t align)", "sline": 156}, "lv_obj_align": {"type": "Function", "def": "void lv_obj_align(struct _lv_obj_t * obj, lv_align_t align, lv_coord_t x_ofs, lv_coord_t y_ofs)", "sline": 168}, "lv_obj_align_to": {"type": "Function", "def": "void lv_obj_align_to(struct _lv_obj_t * obj, const struct _lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs,\n                     lv_coord_t y_ofs)", "sline": 179}, "lv_obj_center": {"type": "Function", "def": "static inline void lv_obj_center(struct _lv_obj_t * obj)", "sline": 187, "body": "{\n    lv_obj_align(obj, LV_ALIGN_CENTER, 0, 0);\n}"}, "lv_obj_get_coords": {"type": "Function", "def": "void lv_obj_get_coords(const struct _lv_obj_t * obj, lv_area_t * coords)", "sline": 198}, "lv_obj_get_x": {"type": "Function", "def": "lv_coord_t lv_obj_get_x(const struct _lv_obj_t * obj)", "sline": 210}, "lv_obj_get_x2": {"type": "Function", "def": "lv_coord_t lv_obj_get_x2(const struct _lv_obj_t * obj)", "sline": 222}, "lv_obj_get_y": {"type": "Function", "def": "lv_coord_t lv_obj_get_y(const struct _lv_obj_t * obj)", "sline": 234}, "lv_obj_get_y2": {"type": "Function", "def": "lv_coord_t lv_obj_get_y2(const struct _lv_obj_t * obj)", "sline": 246}, "lv_obj_get_width": {"type": "Function", "def": "lv_coord_t lv_obj_get_width(const struct _lv_obj_t * obj)", "sline": 255}, "lv_obj_get_height": {"type": "Function", "def": "lv_coord_t lv_obj_get_height(const struct _lv_obj_t * obj)", "sline": 264}, "lv_obj_get_content_width": {"type": "Function", "def": "lv_coord_t lv_obj_get_content_width(const struct _lv_obj_t * obj)", "sline": 273}, "lv_obj_get_content_height": {"type": "Function", "def": "lv_coord_t lv_obj_get_content_height(const struct _lv_obj_t * obj)", "sline": 282}, "lv_obj_get_content_coords": {"type": "Function", "def": "void lv_obj_get_content_coords(const struct _lv_obj_t * obj, lv_area_t * area)", "sline": 291}, "lv_obj_get_self_width": {"type": "Function", "def": "lv_coord_t lv_obj_get_self_width(const struct _lv_obj_t * obj)", "sline": 300}, "lv_obj_get_self_height": {"type": "Function", "def": "lv_coord_t lv_obj_get_self_height(const struct _lv_obj_t * obj)", "sline": 309}, "lv_obj_refresh_self_size": {"type": "Function", "def": "bool lv_obj_refresh_self_size(struct _lv_obj_t * obj)", "sline": 316}, "lv_obj_refr_pos": {"type": "Function", "def": "void lv_obj_refr_pos(struct _lv_obj_t * obj)", "sline": 318}, "lv_obj_move_to": {"type": "Function", "def": "void lv_obj_move_to(struct _lv_obj_t * obj, lv_coord_t x, lv_coord_t y)", "sline": 320}, "lv_obj_move_children_by": {"type": "Function", "def": "void lv_obj_move_children_by(struct _lv_obj_t * obj, lv_coord_t x_diff, lv_coord_t y_diff, bool ignore_floating)", "sline": 323}, "lv_obj_invalidate_area": {"type": "Function", "def": "void lv_obj_invalidate_area(const struct _lv_obj_t * obj, const lv_area_t * area)", "sline": 331}, "lv_obj_invalidate": {"type": "Function", "def": "void lv_obj_invalidate(const struct _lv_obj_t * obj)", "sline": 337}, "lv_obj_area_is_visible": {"type": "Function", "def": "bool lv_obj_area_is_visible(const struct _lv_obj_t * obj, lv_area_t * area)", "sline": 345}, "lv_obj_is_visible": {"type": "Function", "def": "bool lv_obj_is_visible(const struct _lv_obj_t * obj)", "sline": 352}, "lv_obj_set_ext_click_area": {"type": "Function", "def": "void lv_obj_set_ext_click_area(struct _lv_obj_t * obj, lv_coord_t size)", "sline": 359}, "lv_obj_get_click_area": {"type": "Function", "def": "void lv_obj_get_click_area(const struct _lv_obj_t * obj, lv_area_t * area)", "sline": 367}, "lv_obj_hit_test": {"type": "Function", "def": "bool lv_obj_hit_test(struct _lv_obj_t * obj, const lv_point_t * point)", "sline": 375}, "lv_clamp_width": {"type": "Function", "def": "lv_coord_t lv_clamp_width(lv_coord_t width, lv_coord_t min_width, lv_coord_t max_width, lv_coord_t ref_width)", "sline": 385}, "lv_clamp_height": {"type": "Function", "def": "lv_coord_t lv_clamp_height(lv_coord_t height, lv_coord_t min_height, lv_coord_t max_height, lv_coord_t ref_height)", "sline": 395}, "carbit_updater/lvgl/src/core/lv_obj_pos.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_pos.h"}}, "carbit_updater/lvgl/src/misc/lv_assert.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "lv_log": {"type": "Variable", "def": "#include lv_log.h", "sline": 17, "include": ["carbit_updater/lvgl/src/misc/lv_log.h", null]}, "lv_mem": {"type": "Variable", "def": "#include lv_mem.h", "sline": 18, "include": ["carbit_updater/lvgl/src/misc/lv_mem.h", null]}, "stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 19}, "carbit_updater/lvgl/src/misc/lv_assert.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_assert.h"}}, "carbit_updater/lv_drivers/indev/keyboard.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 20}, "carbit_updater/lv_drivers/indev/keyboard.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/indev/keyboard.h"}}, "carbit_updater/lv_drivers/display/drm.c": {"drm": {"type": "Variable", "def": "#include drm.h", "sline": 9, "include": ["carbit_updater/lv_drivers/display/drm.h", null]}, "carbit_updater/lv_drivers/display/drm.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/drm.c"}}, "carbit_updater/lvgl/src/widgets/lv_label.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "stdarg": {"type": "Variable", "def": "#include stdarg.h", "sline": 20}, "lv_obj": {"type": "Variable", "def": "#include ../core/lv_obj.h", "sline": 21}, "lv_font": {"type": "Variable", "def": "#include ../font/lv_font.h", "sline": 22}, "lv_symbol_def": {"type": "Variable", "def": "#include ../font/lv_symbol_def.h", "sline": 23}, "lv_txt": {"type": "Variable", "def": "#include ../misc/lv_txt.h", "sline": 24}, "lv_draw": {"type": "Variable", "def": "#include ../draw/lv_draw.h", "sline": 25}, "_silence_gcc_warning": {"type": "Struct", "def": "LV_EXPORT_CONST_INT(LV_LABEL_TEXT_SELECTION_OFF)", "sline": 37}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_label.h:44:1)": {"type": "Enum", "def": "enum {\n    LV_LABEL_LONG_WRAP,             /**< Keep the object width, wrap the too long lines and expand the object height*/\n    LV_LABEL_LONG_DOT,              /**< Keep the size and write dots at the end if the text is too long*/\n    LV_LABEL_LONG_SCROLL,           /**< Keep the size and roll the text back and forth*/\n    LV_LABEL_LONG_SCROLL_CIRCULAR,  /**< Keep the size and roll the text circularly*/\n    LV_LABEL_LONG_CLIP,             /**< Keep the size and clip the text out of it*/\n}", "sline": 44, "docstring": "/** Long mode behaviors. Used in 'lv_label_ext_t'*/"}, "lv_label_long_mode_t": {"type": "Variable", "def": "typedef uint8_t lv_label_long_mode_t", "sline": 51}, "lv_label_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 54, "in_struct": "lv_label_t"}, "lv_label_t.text": {"type": "Variable", "def": "char * text", "sline": 55, "in_struct": "lv_label_t"}, "lv_label_t.dot": {"type": "Variable", "def": "union {\n        char * tmp_ptr; /*Pointer to the allocated memory containing the character replaced by dots*/\n        char tmp[LV_LABEL_DOT_NUM + 1]; /*Directly store the characters if <=4 characters*/\n    } dot", "sline": 59, "in_struct": "lv_label_t"}, "lv_label_t.dot_end": {"type": "Variable", "def": "uint32_t dot_end", "sline": 60, "in_struct": "lv_label_t"}, "lv_label_t.hint": {"type": "Variable", "def": "lv_draw_label_hint_t hint", "sline": 63, "in_struct": "lv_label_t"}, "lv_label_t.sel_start": {"type": "Variable", "def": "uint32_t sel_start", "sline": 67, "in_struct": "lv_label_t"}, "lv_label_t.sel_end": {"type": "Variable", "def": "uint32_t sel_end", "sline": 68, "in_struct": "lv_label_t"}, "lv_label_t.offset": {"type": "Variable", "def": "lv_point_t offset", "sline": 71, "in_struct": "lv_label_t"}, "lv_label_t.long_mode": {"type": "Variable", "def": "lv_label_long_mode_t long_mode : 3", "sline": 72, "in_struct": "lv_label_t", "rels": [["lv_label_long_mode_t", null, "Typeof"]]}, "lv_label_t.static_txt": {"type": "Variable", "def": "uint8_t static_txt : 1", "sline": 73, "in_struct": "lv_label_t"}, "lv_label_t.recolor": {"type": "Variable", "def": "uint8_t recolor : 1", "sline": 74, "in_struct": "lv_label_t"}, "lv_label_t.expand": {"type": "Variable", "def": "uint8_t expand : 1", "sline": 75, "in_struct": "lv_label_t"}, "lv_label_t.dot_tmp_alloc": {"type": "Variable", "def": "uint8_t dot_tmp_alloc : 1", "sline": 76, "in_struct": "lv_label_t"}, "lv_label_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    char * text;\n    union {\n        char * tmp_ptr; /*Pointer to the allocated memory containing the character replaced by dots*/\n        char tmp[LV_LABEL_DOT_NUM + 1]; /*Directly store the characters if <=4 characters*/\n    } dot;\n    uint32_t dot_end;  /*The real text length, used in dot mode*/\n\n#if LV_LABEL_LONG_TXT_HINT\n    lv_draw_label_hint_t hint;\n#endif\n\n#if LV_LABEL_TEXT_SELECTION\n    uint32_t sel_start;\n    uint32_t sel_end;\n#endif\n\n    lv_point_t offset; /*Text draw position offset*/\n    lv_label_long_mode_t long_mode : 3; /*Determinate what to do with the long texts*/\n    uint8_t static_txt : 1;             /*Flag to indicate the text is static*/\n    uint8_t recolor : 1;                /*Enable in-line letter re-coloring*/\n    uint8_t expand : 1;                 /*Ignore real width (used by the library with LV_LABEL_LONG_SROLL)*/\n    uint8_t dot_tmp_alloc : 1; /*1: dot_tmp has been allocated;.0: dot_tmp directly holds up to 4 bytes of characters*/\n} lv_label_t", "sline": 77}, "lv_label_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_label_class", "sline": 79}, "lv_label_create": {"type": "Function", "def": "lv_obj_t * lv_label_create(lv_obj_t * parent)", "sline": 90}, "lv_label_set_text": {"type": "Function", "def": "void lv_label_set_text(lv_obj_t * obj, const char * text)", "sline": 101}, "lv_label_set_text_fmt": {"type": "Function", "def": "void lv_label_set_text_fmt(lv_obj_t * obj, const char * fmt, ...) LV_FORMAT_ATTRIBUTE(2, 3)", "sline": 109}, "lv_label_set_text_static": {"type": "Function", "def": "void lv_label_set_text_static(lv_obj_t * obj, const char * text)", "sline": 117}, "lv_label_set_long_mode": {"type": "Function", "def": "void lv_label_set_long_mode(lv_obj_t * obj, lv_label_long_mode_t long_mode)", "sline": 125}, "lv_label_set_recolor": {"type": "Function", "def": "void lv_label_set_recolor(lv_obj_t * obj, bool en)", "sline": 133}, "lv_label_set_text_sel_start": {"type": "Function", "def": "void lv_label_set_text_sel_start(lv_obj_t * obj, uint32_t index)", "sline": 140}, "lv_label_set_text_sel_end": {"type": "Function", "def": "void lv_label_set_text_sel_end(lv_obj_t * obj, uint32_t index)", "sline": 147}, "lv_label_get_text": {"type": "Function", "def": "char * lv_label_get_text(const lv_obj_t * obj)", "sline": 158}, "lv_label_get_long_mode": {"type": "Function", "def": "lv_label_long_mode_t lv_label_get_long_mode(const lv_obj_t * obj)", "sline": 165, "rels": [["lv_label_long_mode_t", null, "Typeof"]]}, "lv_label_get_recolor": {"type": "Function", "def": "bool lv_label_get_recolor(const lv_obj_t * obj)", "sline": 172}, "lv_label_get_letter_pos": {"type": "Function", "def": "void lv_label_get_letter_pos(const lv_obj_t * obj, uint32_t char_id, lv_point_t * pos)", "sline": 181}, "lv_label_get_letter_on": {"type": "Function", "def": "uint32_t lv_label_get_letter_on(const lv_obj_t * obj, lv_point_t * pos_in)", "sline": 190}, "lv_label_is_char_under_pos": {"type": "Function", "def": "bool lv_label_is_char_under_pos(const lv_obj_t * obj, lv_point_t * pos)", "sline": 198}, "lv_label_get_text_selection_start": {"type": "Function", "def": "uint32_t lv_label_get_text_selection_start(const lv_obj_t * obj)", "sline": 205}, "lv_label_get_text_selection_end": {"type": "Function", "def": "uint32_t lv_label_get_text_selection_end(const lv_obj_t * obj)", "sline": 212}, "lv_label_ins_text": {"type": "Function", "def": "void lv_label_ins_text(lv_obj_t * obj, uint32_t pos, const char * txt)", "sline": 225}, "lv_label_cut_text": {"type": "Function", "def": "void lv_label_cut_text(lv_obj_t * obj, uint32_t pos, uint32_t cnt)", "sline": 234}, "carbit_updater/lvgl/src/widgets/lv_label.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_label.h"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_8.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_montserrat_8.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_8.c"}}, "carbit_updater/lvgl/src/draw/lv_draw_arc.c": {"lv_draw_arc": {"type": "Function", "def": "void lv_draw_arc(lv_coord_t center_x, lv_coord_t center_y, uint16_t radius,  uint16_t start_angle, uint16_t end_angle,\n                 const lv_area_t * clip_area, const lv_draw_arc_dsc_t * dsc)", "sline": 70, "body": "{\n#if LV_DRAW_COMPLEX\n    if(dsc->opa <= LV_OPA_MIN) return;\n    if(dsc->width == 0) return;\n    if(start_angle == end_angle) return;\n\n    lv_coord_t width = dsc->width;\n    if(width > radius) width = radius;\n\n    lv_draw_rect_dsc_t cir_dsc;\n    lv_draw_rect_dsc_init(&cir_dsc);\n    cir_dsc.blend_mode = dsc->blend_mode;\n    if(dsc->img_src) {\n        cir_dsc.bg_opa = LV_OPA_TRANSP;\n        cir_dsc.bg_img_src = dsc->img_src;\n        cir_dsc.bg_img_opa = dsc->opa;\n    }\n    else {\n        cir_dsc.bg_opa = dsc->opa;\n        cir_dsc.bg_color = dsc->color;\n    }\n\n    lv_area_t area_out;\n    area_out.x1 = center_x - radius;\n    area_out.y1 = center_y - radius;\n    area_out.x2 = center_x + radius - 1;  /*-1 because the center already belongs to the left/bottom part*/\n    area_out.y2 = center_y + radius - 1;\n\n    lv_area_t area_in;\n    lv_area_copy(&area_in, &area_out);\n    area_in.x1 += dsc->width;\n    area_in.y1 += dsc->width;\n    area_in.x2 -= dsc->width;\n    area_in.y2 -= dsc->width;\n\n    /*Create inner the mask*/\n    int16_t mask_in_id = LV_MASK_ID_INV;\n    lv_draw_mask_radius_param_t mask_in_param;\n    if(lv_area_get_width(&area_in) > 0 && lv_area_get_height(&area_in) > 0) {\n        lv_draw_mask_radius_init(&mask_in_param, &area_in, LV_RADIUS_CIRCLE, true);\n        mask_in_id = lv_draw_mask_add(&mask_in_param, NULL);\n    }\n\n    lv_draw_mask_radius_param_t mask_out_param;\n    lv_draw_mask_radius_init(&mask_out_param, &area_out, LV_RADIUS_CIRCLE, false);\n    int16_t mask_out_id = lv_draw_mask_add(&mask_out_param, NULL);\n\n    /*Draw a full ring*/\n    if(start_angle + 360 == end_angle || start_angle == end_angle + 360) {\n        cir_dsc.radius = LV_RADIUS_CIRCLE;\n        lv_draw_rect(&area_out, clip_area, &cir_dsc);\n\n        lv_draw_mask_remove_id(mask_out_id);\n        if(mask_in_id != LV_MASK_ID_INV) lv_draw_mask_remove_id(mask_in_id);\n\n        lv_draw_mask_free_param(&mask_out_param);\n        lv_draw_mask_free_param(&mask_in_param);\n\n        return;\n    }\n\n    while(start_angle >= 360) start_angle -= 360;\n    while(end_angle >= 360) end_angle -= 360;\n\n    lv_draw_mask_angle_param_t mask_angle_param;\n    lv_draw_mask_angle_init(&mask_angle_param, center_x, center_y, start_angle, end_angle);\n    int16_t mask_angle_id = lv_draw_mask_add(&mask_angle_param, NULL);\n\n    int32_t angle_gap;\n    if(end_angle > start_angle) {\n        angle_gap = 360 - (end_angle - start_angle);\n    }\n    else {\n        angle_gap = start_angle - end_angle;\n    }\n    if(angle_gap > SPLIT_ANGLE_GAP_LIMIT && radius > SPLIT_RADIUS_LIMIT) {\n        /*Handle each quarter individually and skip which is empty*/\n        quarter_draw_dsc_t q_dsc;\n        q_dsc.center_x = center_x;\n        q_dsc.center_y = center_y;\n        q_dsc.radius = radius;\n        q_dsc.start_angle = start_angle;\n        q_dsc.end_angle = end_angle;\n        q_dsc.start_quarter = (start_angle / 90) & 0x3;\n        q_dsc.end_quarter = (end_angle / 90) & 0x3;\n        q_dsc.width = width;\n        q_dsc.draw_dsc =  &cir_dsc;\n        q_dsc.draw_area = &area_out;\n        q_dsc.clip_area = clip_area;\n\n        draw_quarter_0(&q_dsc);\n        draw_quarter_1(&q_dsc);\n        draw_quarter_2(&q_dsc);\n        draw_quarter_3(&q_dsc);\n    }\n    else {\n        lv_draw_rect(&area_out, clip_area, &cir_dsc);\n    }\n\n    lv_draw_mask_free_param(&mask_angle_param);\n    lv_draw_mask_free_param(&mask_out_param);\n    lv_draw_mask_free_param(&mask_in_param);\n\n    lv_draw_mask_remove_id(mask_angle_id);\n    lv_draw_mask_remove_id(mask_out_id);\n    if(mask_in_id != LV_MASK_ID_INV) lv_draw_mask_remove_id(mask_in_id);\n\n    if(dsc->rounded) {\n\n        lv_draw_mask_radius_param_t mask_end_param;\n\n        lv_area_t round_area;\n        get_rounded_area(start_angle, radius, width, &round_area);\n        round_area.x1 += center_x;\n        round_area.x2 += center_x;\n        round_area.y1 += center_y;\n        round_area.y2 += center_y;\n        lv_area_t clip_area2;\n        if(_lv_area_intersect(&clip_area2, clip_area, &round_area)) {\n            lv_draw_mask_radius_init(&mask_end_param, &round_area, LV_RADIUS_CIRCLE, false);\n            int16_t mask_end_id = lv_draw_mask_add(&mask_end_param, NULL);\n\n            lv_draw_rect(&area_out, &clip_area2, &cir_dsc);\n            lv_draw_mask_remove_id(mask_end_id);\n            lv_draw_mask_free_param(&mask_end_param);\n        }\n\n        get_rounded_area(end_angle, radius, width, &round_area);\n        round_area.x1 += center_x;\n        round_area.x2 += center_x;\n        round_area.y1 += center_y;\n        round_area.y2 += center_y;\n        if(_lv_area_intersect(&clip_area2, clip_area, &round_area)) {\n            lv_draw_mask_radius_init(&mask_end_param, &round_area, LV_RADIUS_CIRCLE, false);\n            int16_t mask_end_id = lv_draw_mask_add(&mask_end_param, NULL);\n\n            lv_draw_rect(&area_out, &clip_area2, &cir_dsc);\n            lv_draw_mask_remove_id(mask_end_id);\n            lv_draw_mask_free_param(&mask_end_param);\n        }\n    }\n#else\n    LV_LOG_WARN(\"Can't draw arc with LV_DRAW_COMPLEX == 0\");\n    LV_UNUSED(center_x);\n    LV_UNUSED(center_y);\n    LV_UNUSED(radius);\n    LV_UNUSED(start_angle);\n    LV_UNUSED(end_angle);\n    LV_UNUSED(clip_area);\n    LV_UNUSED(dsc);\n#endif /*LV_DRAW_COMPLEX*/\n}"}, "lv_draw_rect": {"type": "Variable", "def": "#include lv_draw_rect.h", "sline": 10, "include": ["carbit_updater/lvgl/src/draw/lv_draw_rect.h", null]}, "lv_draw_mask": {"type": "Variable", "def": "#include lv_draw_mask.h", "sline": 11, "include": ["carbit_updater/lvgl/src/draw/lv_draw_mask.h", null]}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 12}, "lv_log": {"type": "Variable", "def": "#include ../misc/lv_log.h", "sline": 13}, "lv_mem": {"type": "Variable", "def": "#include ../misc/lv_mem.h", "sline": 14}, "quarter_draw_dsc_t.center_x": {"type": "Variable", "def": "lv_coord_t center_x", "sline": 26, "in_struct": "quarter_draw_dsc_t"}, "quarter_draw_dsc_t.center_y": {"type": "Variable", "def": "lv_coord_t center_y", "sline": 27, "in_struct": "quarter_draw_dsc_t"}, "quarter_draw_dsc_t.radius": {"type": "Variable", "def": "lv_coord_t radius", "sline": 28, "in_struct": "quarter_draw_dsc_t"}, "quarter_draw_dsc_t.start_angle": {"type": "Variable", "def": "uint16_t start_angle", "sline": 29, "in_struct": "quarter_draw_dsc_t"}, "quarter_draw_dsc_t.end_angle": {"type": "Variable", "def": "uint16_t end_angle", "sline": 30, "in_struct": "quarter_draw_dsc_t"}, "quarter_draw_dsc_t.start_quarter": {"type": "Variable", "def": "uint16_t start_quarter", "sline": 31, "in_struct": "quarter_draw_dsc_t"}, "quarter_draw_dsc_t.end_quarter": {"type": "Variable", "def": "uint16_t end_quarter", "sline": 32, "in_struct": "quarter_draw_dsc_t"}, "quarter_draw_dsc_t.width": {"type": "Variable", "def": "lv_coord_t width", "sline": 33, "in_struct": "quarter_draw_dsc_t"}, "quarter_draw_dsc_t.draw_dsc": {"type": "Variable", "def": "lv_draw_rect_dsc_t * draw_dsc", "sline": 34, "in_struct": "quarter_draw_dsc_t"}, "quarter_draw_dsc_t.draw_area": {"type": "Variable", "def": "const lv_area_t * draw_area", "sline": 35, "in_struct": "quarter_draw_dsc_t"}, "quarter_draw_dsc_t.clip_area": {"type": "Variable", "def": "const lv_area_t * clip_area", "sline": 36, "in_struct": "quarter_draw_dsc_t"}, "quarter_draw_dsc_t": {"type": "Variable", "def": "typedef struct {\n    lv_coord_t center_x;\n    lv_coord_t center_y;\n    lv_coord_t radius;\n    uint16_t start_angle;\n    uint16_t end_angle;\n    uint16_t start_quarter;\n    uint16_t end_quarter;\n    lv_coord_t width;\n    lv_draw_rect_dsc_t * draw_dsc;\n    const lv_area_t * draw_area;\n    const lv_area_t * clip_area;\n} quarter_draw_dsc_t", "sline": 37, "docstring": "/**********************"}, "draw_quarter_0": {"type": "Function", "def": "static void draw_quarter_0(quarter_draw_dsc_t * q)", "sline": 323, "body": "{\n    lv_area_t quarter_area;\n\n    if(q->start_quarter == 0 && q->end_quarter == 0 && q->start_angle < q->end_angle) {\n        /*Small arc here*/\n        quarter_area.y1 = q->center_y + ((lv_trigo_sin(q->start_angle) * (q->radius - q->width)) >> LV_TRIGO_SHIFT);\n        quarter_area.x2 = q->center_x + ((lv_trigo_sin(q->start_angle + 90) * (q->radius)) >> LV_TRIGO_SHIFT);\n\n        quarter_area.y2 = q->center_y + ((lv_trigo_sin(q->end_angle) * q->radius) >> LV_TRIGO_SHIFT);\n        quarter_area.x1 = q->center_x + ((lv_trigo_sin(q->end_angle + 90) * (q->radius - q->width)) >> LV_TRIGO_SHIFT);\n\n        bool ok = _lv_area_intersect(&quarter_area, &quarter_area, q->clip_area);\n        if(ok) lv_draw_rect(q->draw_area, &quarter_area, q->draw_dsc);\n    }\n    else if(q->start_quarter == 0 || q->end_quarter == 0) {\n        /*Start and/or end arcs here*/\n        if(q->start_quarter == 0) {\n            quarter_area.x1 = q->center_x;\n            quarter_area.y2 = q->center_y + q->radius;\n\n            quarter_area.y1 = q->center_y + ((lv_trigo_sin(q->start_angle) * (q->radius - q->width)) >> LV_TRIGO_SHIFT);\n            quarter_area.x2 = q->center_x + ((lv_trigo_sin(q->start_angle + 90) * (q->radius)) >> LV_TRIGO_SHIFT);\n\n            bool ok = _lv_area_intersect(&quarter_area, &quarter_area, q->clip_area);\n            if(ok) lv_draw_rect(q->draw_area, &quarter_area, q->draw_dsc);\n        }\n        if(q->end_quarter == 0) {\n            quarter_area.x2 = q->center_x + q->radius;\n            quarter_area.y1 = q->center_y;\n\n            quarter_area.y2 = q->center_y + ((lv_trigo_sin(q->end_angle) * q->radius) >> LV_TRIGO_SHIFT);\n            quarter_area.x1 = q->center_x + ((lv_trigo_sin(q->end_angle + 90) * (q->radius - q->width)) >> LV_TRIGO_SHIFT);\n\n            bool ok = _lv_area_intersect(&quarter_area, &quarter_area, q->clip_area);\n            if(ok) lv_draw_rect(q->draw_area, &quarter_area, q->draw_dsc);\n        }\n    }\n    else if((q->start_quarter == q->end_quarter && q->start_quarter != 0 && q->end_angle < q->start_angle) ||\n            (q->start_quarter == 2 && q->end_quarter == 1) ||\n            (q->start_quarter == 3 && q->end_quarter == 2) ||\n            (q->start_quarter == 3 && q->end_quarter == 1)) {\n        /*Arc crosses here*/\n        quarter_area.x1 = q->center_x;\n        quarter_area.y1 = q->center_y;\n        quarter_area.x2 = q->center_x + q->radius;\n        quarter_area.y2 = q->center_y + q->radius;\n\n        bool ok = _lv_area_intersect(&quarter_area, &quarter_area, q->clip_area);\n        if(ok) lv_draw_rect(q->draw_area, &quarter_area, q->draw_dsc);\n    }\n}"}, "draw_quarter_1": {"type": "Function", "def": "static void draw_quarter_1(quarter_draw_dsc_t * q)", "sline": 376, "body": "{\n    lv_area_t quarter_area;\n\n    if(q->start_quarter == 1 && q->end_quarter == 1 && q->start_angle < q->end_angle) {\n        /*Small arc here*/\n        quarter_area.y2 = q->center_y + ((lv_trigo_sin(q->start_angle) * (q->radius)) >> LV_TRIGO_SHIFT);\n        quarter_area.x2 = q->center_x + ((lv_trigo_sin(q->start_angle + 90) * (q->radius - q->width)) >> LV_TRIGO_SHIFT);\n\n        quarter_area.y1 = q->center_y + ((lv_trigo_sin(q->end_angle) * (q->radius - q->width)) >> LV_TRIGO_SHIFT);\n        quarter_area.x1 = q->center_x + ((lv_trigo_sin(q->end_angle + 90) * (q->radius)) >> LV_TRIGO_SHIFT);\n\n        bool ok = _lv_area_intersect(&quarter_area, &quarter_area, q->clip_area);\n        if(ok) lv_draw_rect(q->draw_area, &quarter_area, q->draw_dsc);\n    }\n    else if(q->start_quarter == 1 || q->end_quarter == 1) {\n        /*Start and/or end arcs here*/\n        if(q->start_quarter == 1) {\n            quarter_area.x1 = q->center_x - q->radius;\n            quarter_area.y1 = q->center_y;\n\n            quarter_area.y2 = q->center_y + ((lv_trigo_sin(q->start_angle) * (q->radius)) >> LV_TRIGO_SHIFT);\n            quarter_area.x2 = q->center_x + ((lv_trigo_sin(q->start_angle + 90) * (q->radius - q->width)) >> LV_TRIGO_SHIFT);\n\n            bool ok = _lv_area_intersect(&quarter_area, &quarter_area, q->clip_area);\n            if(ok) lv_draw_rect(q->draw_area, &quarter_area, q->draw_dsc);\n        }\n        if(q->end_quarter == 1) {\n            quarter_area.x2 = q->center_x - 1;\n            quarter_area.y2 = q->center_y + q->radius;\n\n            quarter_area.y1 = q->center_y + ((lv_trigo_sin(q->end_angle) * (q->radius - q->width)) >> LV_TRIGO_SHIFT);\n            quarter_area.x1 = q->center_x + ((lv_trigo_sin(q->end_angle + 90) * (q->radius)) >> LV_TRIGO_SHIFT);\n\n            bool ok = _lv_area_intersect(&quarter_area, &quarter_area, q->clip_area);\n            if(ok) lv_draw_rect(q->draw_area, &quarter_area, q->draw_dsc);\n        }\n    }\n    else if((q->start_quarter == q->end_quarter && q->start_quarter != 1 && q->end_angle < q->start_angle) ||\n            (q->start_quarter == 0 && q->end_quarter == 2) ||\n            (q->start_quarter == 0 && q->end_quarter == 3) ||\n            (q->start_quarter == 3 && q->end_quarter == 2)) {\n        /*Arc crosses here*/\n        quarter_area.x1 = q->center_x - q->radius;\n        quarter_area.y1 = q->center_y;\n        quarter_area.x2 = q->center_x - 1;\n        quarter_area.y2 = q->center_y + q->radius;\n\n        bool ok = _lv_area_intersect(&quarter_area, &quarter_area, q->clip_area);\n        if(ok) lv_draw_rect(q->draw_area, &quarter_area, q->draw_dsc);\n    }\n}"}, "draw_quarter_2": {"type": "Function", "def": "static void draw_quarter_2(quarter_draw_dsc_t * q)", "sline": 429, "body": "{\n    lv_area_t quarter_area;\n\n    if(q->start_quarter == 2 && q->end_quarter == 2 && q->start_angle < q->end_angle) {\n        /*Small arc here*/\n        quarter_area.x1 = q->center_x + ((lv_trigo_sin(q->start_angle + 90) * (q->radius)) >> LV_TRIGO_SHIFT);\n        quarter_area.y2 = q->center_y + ((lv_trigo_sin(q->start_angle) * (q->radius - q->width)) >> LV_TRIGO_SHIFT);\n\n        quarter_area.y1 = q->center_y + ((lv_trigo_sin(q->end_angle) * q->radius) >> LV_TRIGO_SHIFT);\n        quarter_area.x2 = q->center_x + ((lv_trigo_sin(q->end_angle + 90) * (q->radius - q->width)) >> LV_TRIGO_SHIFT);\n\n        bool ok = _lv_area_intersect(&quarter_area, &quarter_area, q->clip_area);\n        if(ok) lv_draw_rect(q->draw_area, &quarter_area, q->draw_dsc);\n    }\n    else if(q->start_quarter == 2 || q->end_quarter == 2) {\n        /*Start and/or end arcs here*/\n        if(q->start_quarter == 2) {\n            quarter_area.x2 = q->center_x - 1;\n            quarter_area.y1 = q->center_y - q->radius;\n\n            quarter_area.x1 = q->center_x + ((lv_trigo_sin(q->start_angle + 90) * (q->radius)) >> LV_TRIGO_SHIFT);\n            quarter_area.y2 = q->center_y + ((lv_trigo_sin(q->start_angle) * (q->radius - q->width)) >> LV_TRIGO_SHIFT);\n\n            bool ok = _lv_area_intersect(&quarter_area, &quarter_area, q->clip_area);\n            if(ok) lv_draw_rect(q->draw_area, &quarter_area, q->draw_dsc);\n        }\n        if(q->end_quarter == 2) {\n            quarter_area.x1 = q->center_x - q->radius;\n            quarter_area.y2 = q->center_y - 1;\n\n            quarter_area.x2 = q->center_x + ((lv_trigo_sin(q->end_angle + 90) * (q->radius - q->width)) >> LV_TRIGO_SHIFT);\n            quarter_area.y1 = q->center_y + ((lv_trigo_sin(q->end_angle) * (q->radius)) >> LV_TRIGO_SHIFT);\n\n            bool ok = _lv_area_intersect(&quarter_area, &quarter_area, q->clip_area);\n            if(ok) lv_draw_rect(q->draw_area, &quarter_area, q->draw_dsc);\n        }\n    }\n    else if((q->start_quarter == q->end_quarter && q->start_quarter != 2 && q->end_angle < q->start_angle) ||\n            (q->start_quarter == 0 && q->end_quarter == 3) ||\n            (q->start_quarter == 1 && q->end_quarter == 3) ||\n            (q->start_quarter == 1 && q->end_quarter == 0)) {\n        /*Arc crosses here*/\n        quarter_area.x1 = q->center_x - q->radius;\n        quarter_area.y1 = q->center_y - q->radius;\n        quarter_area.x2 = q->center_x - 1;\n        quarter_area.y2 = q->center_y - 1;\n\n        bool ok = _lv_area_intersect(&quarter_area, &quarter_area, q->clip_area);\n        if(ok) lv_draw_rect(q->draw_area, &quarter_area, q->draw_dsc);\n    }\n}"}, "draw_quarter_3": {"type": "Function", "def": "static void draw_quarter_3(quarter_draw_dsc_t * q)", "sline": 482, "body": "{\n    lv_area_t quarter_area;\n\n    if(q->start_quarter == 3 && q->end_quarter == 3 && q->start_angle < q->end_angle) {\n        /*Small arc here*/\n        quarter_area.x1 = q->center_x + ((lv_trigo_sin(q->start_angle + 90) * (q->radius - q->width)) >> LV_TRIGO_SHIFT);\n        quarter_area.y1 = q->center_y + ((lv_trigo_sin(q->start_angle) * (q->radius)) >> LV_TRIGO_SHIFT);\n\n        quarter_area.x2 = q->center_x + ((lv_trigo_sin(q->end_angle + 90) * (q->radius)) >> LV_TRIGO_SHIFT);\n        quarter_area.y2 = q->center_y + ((lv_trigo_sin(q->end_angle) * (q->radius - q->width)) >> LV_TRIGO_SHIFT);\n\n        bool ok = _lv_area_intersect(&quarter_area, &quarter_area, q->clip_area);\n        if(ok) lv_draw_rect(q->draw_area, &quarter_area, q->draw_dsc);\n    }\n    else if(q->start_quarter == 3 || q->end_quarter == 3) {\n        /*Start and/or end arcs here*/\n        if(q->start_quarter == 3) {\n            quarter_area.x2 = q->center_x + q->radius;\n            quarter_area.y2 = q->center_y - 1;\n\n            quarter_area.x1 = q->center_x + ((lv_trigo_sin(q->start_angle + 90) * (q->radius - q->width)) >> LV_TRIGO_SHIFT);\n            quarter_area.y1 = q->center_y + ((lv_trigo_sin(q->start_angle) * (q->radius)) >> LV_TRIGO_SHIFT);\n\n            bool ok = _lv_area_intersect(&quarter_area, &quarter_area, q->clip_area);\n            if(ok) lv_draw_rect(q->draw_area, &quarter_area, q->draw_dsc);\n        }\n        if(q->end_quarter == 3) {\n            quarter_area.x1 = q->center_x;\n            quarter_area.y1 = q->center_y - q->radius;\n\n            quarter_area.x2 = q->center_x + ((lv_trigo_sin(q->end_angle + 90) * (q->radius)) >> LV_TRIGO_SHIFT);\n            quarter_area.y2 = q->center_y + ((lv_trigo_sin(q->end_angle) * (q->radius - q->width)) >> LV_TRIGO_SHIFT);\n\n            bool ok = _lv_area_intersect(&quarter_area, &quarter_area, q->clip_area);\n            if(ok) lv_draw_rect(q->draw_area, &quarter_area, q->draw_dsc);\n        }\n    }\n    else if((q->start_quarter == q->end_quarter && q->start_quarter != 3 && q->end_angle < q->start_angle) ||\n            (q->start_quarter == 2 && q->end_quarter == 0) ||\n            (q->start_quarter == 1 && q->end_quarter == 0) ||\n            (q->start_quarter == 2 && q->end_quarter == 1)) {\n        /*Arc crosses here*/\n        quarter_area.x1 = q->center_x;\n        quarter_area.y1 = q->center_y - q->radius;\n        quarter_area.x2 = q->center_x + q->radius;\n        quarter_area.y2 = q->center_y - 1;\n\n        bool ok = _lv_area_intersect(&quarter_area, &quarter_area, q->clip_area);\n        if(ok) lv_draw_rect(q->draw_area, &quarter_area, q->draw_dsc);\n    }\n}"}, "get_rounded_area": {"type": "Function", "def": "static void get_rounded_area(int16_t angle, lv_coord_t radius, uint8_t thickness, lv_area_t * res_area)", "sline": 535, "body": "{\n    const uint8_t ps = 8;\n    const uint8_t pa = 127;\n\n    int32_t thick_half = thickness / 2;\n    uint8_t thick_corr = (thickness & 0x01) ? 0 : 1;\n\n    int32_t cir_x;\n    int32_t cir_y;\n\n    cir_x = ((radius - thick_half) * lv_trigo_sin(90 - angle)) >> (LV_TRIGO_SHIFT - ps);\n    cir_y = ((radius - thick_half) * lv_trigo_sin(angle)) >> (LV_TRIGO_SHIFT - ps);\n\n    /*Actually the center of the pixel need to be calculated so apply 1/2 px offset*/\n    if(cir_x > 0) {\n        cir_x = (cir_x - pa) >> ps;\n        res_area->x1 = cir_x - thick_half + thick_corr;\n        res_area->x2 = cir_x + thick_half;\n    }\n    else {\n        cir_x = (cir_x + pa) >> ps;\n        res_area->x1 = cir_x - thick_half;\n        res_area->x2 = cir_x + thick_half - thick_corr;\n    }\n\n    if(cir_y > 0) {\n        cir_y = (cir_y - pa) >> ps;\n        res_area->y1 = cir_y - thick_half + thick_corr;\n        res_area->y2 = cir_y + thick_half;\n    }\n    else {\n        cir_y = (cir_y + pa) >> ps;\n        res_area->y1 = cir_y - thick_half;\n        res_area->y2 = cir_y + thick_half - thick_corr;\n    }\n}"}, "lv_draw_arc_dsc_init": {"type": "Function", "def": "void lv_draw_arc_dsc_init(lv_draw_arc_dsc_t * dsc)", "sline": 62, "body": "{\n    lv_memset_00(dsc, sizeof(lv_draw_arc_dsc_t));\n    dsc->width = 1;\n    dsc->opa = LV_OPA_COVER;\n    dsc->color = lv_color_black();\n}"}, "lv_draw_arc_get_area": {"type": "Function", "def": "void lv_draw_arc_get_area(lv_coord_t x, lv_coord_t y, uint16_t radius,  uint16_t start_angle, uint16_t end_angle,\n                          lv_coord_t w, bool rounded, lv_area_t * area)", "sline": 225, "body": "{\n    lv_coord_t rout = radius;\n\n    /*Special case: full arc invalidation */\n    if(end_angle == start_angle + 360) {\n        area->x1 = x - rout;\n        area->y1 = y - rout;\n        area->x2 = x + rout;\n        area->y2 = y + rout;\n        return;\n    }\n\n    if(start_angle > 360) start_angle -= 360;\n    if(end_angle > 360) end_angle -= 360;\n\n    lv_coord_t rin = radius - w;\n    lv_coord_t extra_area = rounded ? w / 2 + 1 : 0;\n    uint8_t start_quarter = start_angle / 90;\n    uint8_t end_quarter = end_angle / 90;\n\n    /*360 deg still counts as quarter 3 (360 / 90 would be 4)*/\n    if(start_quarter == 4) start_quarter = 3;\n    if(end_quarter == 4) end_quarter = 3;\n\n    if(start_quarter == end_quarter && start_angle <= end_angle) {\n        if(start_quarter == 0) {\n            area->y1 = y + ((lv_trigo_sin(start_angle) * rin) >> LV_TRIGO_SHIFT) - extra_area;\n            area->x2 = x + ((lv_trigo_sin(start_angle + 90) * rout) >> LV_TRIGO_SHIFT) + extra_area;\n\n            area->y2 = y + ((lv_trigo_sin(end_angle) * rout) >> LV_TRIGO_SHIFT) + extra_area;\n            area->x1 = x + ((lv_trigo_sin(end_angle + 90) * rin) >> LV_TRIGO_SHIFT) - extra_area;\n        }\n        else if(start_quarter == 1) {\n            area->y2 = y + ((lv_trigo_sin(start_angle) * rout) >> LV_TRIGO_SHIFT) + extra_area;\n            area->x2 = x + ((lv_trigo_sin(start_angle + 90) * rin) >> LV_TRIGO_SHIFT) + extra_area;\n\n            area->y1 = y + ((lv_trigo_sin(end_angle) * rin) >> LV_TRIGO_SHIFT) - extra_area;\n            area->x1 = x + ((lv_trigo_sin(end_angle + 90) * rout) >> LV_TRIGO_SHIFT) - extra_area;\n        }\n        else if(start_quarter == 2) {\n            area->x1 = x + ((lv_trigo_sin(start_angle + 90) * rout) >> LV_TRIGO_SHIFT) - extra_area;\n            area->y2 = y + ((lv_trigo_sin(start_angle) * rin) >> LV_TRIGO_SHIFT) + extra_area;\n\n            area->y1 = y + ((lv_trigo_sin(end_angle) * rout) >> LV_TRIGO_SHIFT) - extra_area;\n            area->x2 = x + ((lv_trigo_sin(end_angle + 90) * rin) >> LV_TRIGO_SHIFT) + extra_area;\n        }\n        else if(start_quarter == 3) {\n            area->x1 = x + ((lv_trigo_sin(start_angle + 90) * rin) >> LV_TRIGO_SHIFT) - extra_area;\n            area->y1 = y + ((lv_trigo_sin(start_angle) * rout) >> LV_TRIGO_SHIFT) - extra_area;\n\n            area->x2 = x + ((lv_trigo_sin(end_angle + 90) * rout) >> LV_TRIGO_SHIFT) + extra_area;\n            area->y2 = y + ((lv_trigo_sin(end_angle) * rin) >> LV_TRIGO_SHIFT) + extra_area;\n        }\n    }\n    else if(start_quarter == 0 && end_quarter == 1) {\n        area->x1 = x + ((lv_trigo_sin(end_angle + 90) * rout) >> LV_TRIGO_SHIFT) - extra_area;\n        area->y1 = y + ((LV_MIN(lv_trigo_sin(end_angle),\n                                lv_trigo_sin(start_angle))  * rin) >> LV_TRIGO_SHIFT) - extra_area;\n        area->x2 = x + ((lv_trigo_sin(start_angle + 90) * rout) >> LV_TRIGO_SHIFT) + extra_area;\n        area->y2 = y + rout + extra_area;\n    }\n    else if(start_quarter == 1 && end_quarter == 2) {\n        area->x1 = x - rout - extra_area;\n        area->y1 = y + ((lv_trigo_sin(end_angle) * rout) >> LV_TRIGO_SHIFT) - extra_area;\n        area->x2 = x + ((LV_MAX(lv_trigo_sin(start_angle + 90),\n                                lv_trigo_sin(end_angle + 90)) * rin) >> LV_TRIGO_SHIFT) + extra_area;\n        area->y2 = y + ((lv_trigo_sin(start_angle) * rout) >> LV_TRIGO_SHIFT) + extra_area;\n    }\n    else if(start_quarter == 2 && end_quarter == 3) {\n        area->x1 = x + ((lv_trigo_sin(start_angle + 90) * rout) >> LV_TRIGO_SHIFT) - extra_area;\n        area->y1 = y - rout - extra_area;\n        area->x2 = x + ((lv_trigo_sin(end_angle + 90) * rout) >> LV_TRIGO_SHIFT) + extra_area;\n        area->y2 = y + (LV_MAX(lv_trigo_sin(end_angle) * rin,\n                               lv_trigo_sin(start_angle) * rin) >> LV_TRIGO_SHIFT) + extra_area;\n    }\n    else if(start_quarter == 3 && end_quarter == 0) {\n        area->x1 = x + ((LV_MIN(lv_trigo_sin(end_angle + 90),\n                                lv_trigo_sin(start_angle + 90)) * rin) >> LV_TRIGO_SHIFT) - extra_area;\n        area->y1 = y + ((lv_trigo_sin(start_angle) * rout) >> LV_TRIGO_SHIFT) - extra_area;\n        area->x2 = x + rout + extra_area;\n        area->y2 = y + ((lv_trigo_sin(end_angle) * rout) >> LV_TRIGO_SHIFT) + extra_area;\n\n    }\n    else {\n        area->x1 = x - rout;\n        area->y1 = y - rout;\n        area->x2 = x + rout;\n        area->y2 = y + rout;\n    }\n}"}, "carbit_updater/lvgl/src/draw/lv_draw_arc.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_draw_arc.c"}}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_stack_blur.c": {"lv_gpu_sdl_stack_blur": {"type": "Variable", "def": "#include lv_gpu_sdl_stack_blur.h", "sline": 9, "include": ["carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_stack_blur.h", null]}, "stack_blur_job": {"type": "Function", "def": "static void stack_blur_job(lv_opa_t * src, unsigned int w, unsigned int h, unsigned int radius, int cores, int core,\n                           int step)", "sline": 90, "body": "{\n    if(radius < 2 || radius > 254) {\n        /* Silently ignore bad radius */\n        return;\n    }\n\n    unsigned int x, y, xp, yp, i;\n    unsigned int sp;\n    unsigned int stack_start;\n    unsigned char * stack_ptr;\n\n    lv_opa_t * src_ptr;\n    lv_opa_t * dst_ptr;\n\n    unsigned long sum_r;\n    unsigned long sum_in_r;\n    unsigned long sum_out_r;\n\n    unsigned int wm = w - 1;\n    unsigned int hm = h - 1;\n    unsigned int stride = w;\n    unsigned int div = (radius * 2) + 1;\n    unsigned int mul_sum = stackblur_mul[radius];\n    unsigned char shr_sum = stackblur_shr[radius];\n    unsigned char stack[254 * 2 + 1];\n\n    if(step == 1) {\n        unsigned int minY = core * h / cores;\n        unsigned int maxY = (core + 1) * h / cores;\n\n        for(y = minY; y < maxY; y++) {\n            sum_r =\n                sum_in_r =\n                    sum_out_r = 0;\n\n            src_ptr = src + stride * y; // start of line (0,y)\n\n            for(i = 0; i <= radius; i++) {\n                stack_ptr = &stack[i];\n                stack_ptr[0] = src_ptr[0];\n                sum_r += src_ptr[0] * (i + 1);\n                sum_out_r += src_ptr[0];\n            }\n\n\n            for(i = 1; i <= radius; i++) {\n                if(i <= wm) src_ptr += 1;\n                stack_ptr = &stack[i + radius];\n                stack_ptr[0] = src_ptr[0];\n                sum_r += src_ptr[0] * (radius + 1 - i);\n                sum_in_r += src_ptr[0];\n            }\n\n\n            sp = radius;\n            xp = radius;\n            if(xp > wm) xp = wm;\n            src_ptr = src + (xp + y * w); //   img.pix_ptr(xp, y);\n            dst_ptr = src + y * stride; // img.pix_ptr(0, y);\n            for(x = 0; x < w; x++) {\n                dst_ptr[0] = LV_CLAMP((sum_r * mul_sum) >> shr_sum, 0, 255);\n                dst_ptr += 1;\n\n                sum_r -= sum_out_r;\n\n                stack_start = sp + div - radius;\n                if(stack_start >= div) stack_start -= div;\n                stack_ptr = &stack[stack_start];\n\n                sum_out_r -= stack_ptr[0];\n\n                if(xp < wm) {\n                    src_ptr += 1;\n                    ++xp;\n                }\n\n                stack_ptr[0] = src_ptr[0];\n\n                sum_in_r += src_ptr[0];\n                sum_r += sum_in_r;\n\n                ++sp;\n                if(sp >= div) sp = 0;\n                stack_ptr = &stack[sp];\n\n                sum_out_r += stack_ptr[0];\n                sum_in_r -= stack_ptr[0];\n            }\n\n        }\n    }\n\n    // step 2\n    if(step == 2) {\n        unsigned int minX = core * w / cores;\n        unsigned int maxX = (core + 1) * w / cores;\n\n        for(x = minX; x < maxX; x++) {\n            sum_r =\n                sum_in_r =\n                    sum_out_r = 0;\n\n            src_ptr = src + x; // x,0\n            for(i = 0; i <= radius; i++) {\n                stack_ptr = &stack[i];\n                stack_ptr[0] = src_ptr[0];\n                sum_r += src_ptr[0] * (i + 1);\n                sum_out_r += src_ptr[0];\n            }\n            for(i = 1; i <= radius; i++) {\n                if(i <= hm) src_ptr += stride;  // +stride\n\n                stack_ptr = &stack[i + radius];\n                stack_ptr[0] = src_ptr[0];\n                sum_r += src_ptr[0] * (radius + 1 - i);\n                sum_in_r += src_ptr[0];\n            }\n\n            sp = radius;\n            yp = radius;\n            if(yp > hm) yp = hm;\n            src_ptr = src + (x + yp * w); // img.pix_ptr(x, yp);\n            dst_ptr = src + x;               // img.pix_ptr(x, 0);\n            for(y = 0; y < h; y++) {\n                dst_ptr[0] = LV_CLAMP((sum_r * mul_sum) >> shr_sum, 0, 255);\n                dst_ptr += stride;\n\n                sum_r -= sum_out_r;\n\n                stack_start = sp + div - radius;\n                if(stack_start >= div) stack_start -= div;\n                stack_ptr = &stack[stack_start];\n\n                sum_out_r -= stack_ptr[0];\n\n                if(yp < hm) {\n                    src_ptr += stride; // stride\n                    ++yp;\n                }\n\n                stack_ptr[0] = src_ptr[0];\n\n                sum_in_r += src_ptr[0];\n                sum_r += sum_in_r;\n\n                ++sp;\n                if(sp >= div) sp = 0;\n                stack_ptr = &stack[sp];\n\n                sum_out_r += stack_ptr[0];\n                sum_in_r -= stack_ptr[0];\n            }\n        }\n    }\n}"}, "stackblur_mul": {"type": "Variable", "def": "static unsigned short const stackblur_mul[255] = {\n    512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512,\n    454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512,\n    482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456,\n    437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512,\n    497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328,\n    320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456,\n    446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335,\n    329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512,\n    505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405,\n    399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328,\n    324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271,\n    268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456,\n    451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388,\n    385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335,\n    332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292,\n    289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259\n}", "sline": 34}, "stackblur_shr": {"type": "Variable", "def": "static unsigned char const stackblur_shr[255] = {\n    9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17,\n    17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,\n    19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,\n    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,\n    21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n    21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,\n    22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n    22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23,\n    23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n    23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n    23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n    23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24\n}", "sline": 53}, "lv_stack_blur_grayscale": {"type": "Function", "def": "void lv_stack_blur_grayscale(lv_opa_t * buf, uint16_t w, uint16_t h, uint16_t r)", "sline": 80, "body": "{\n    stack_blur_job(buf, w, h, r, 1, 0, 1);\n    stack_blur_job(buf, w, h, r, 1, 0, 2);\n}"}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_stack_blur.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_stack_blur.c"}}, "carbit_updater/lvgl/src/misc/lv_templ.h": {"carbit_updater/lvgl/src/misc/lv_templ.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_templ.h"}}, "carbit_updater/lvgl/src/hal/lv_hal_tick.c": {"lv_hal_tick": {"type": "Variable", "def": "#include lv_hal_tick.h", "sline": 9, "include": ["carbit_updater/lvgl/src/hal/lv_hal_tick.h", null]}, "stddef": {"type": "Variable", "def": "#include stddef.h", "sline": 10}, "stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 13}, "lv_tick_get": {"type": "Function", "def": "uint32_t lv_tick_get(void)", "sline": 60, "body": "{\n#if LV_TICK_CUSTOM == 0\n\n    /*If `lv_tick_inc` is called from an interrupt while `sys_time` is read\n     *the result might be corrupted.\n     *This loop detects if `lv_tick_inc` was called while reading `sys_time`.\n     *If `tick_irq_flag` was cleared in `lv_tick_inc` try to read again\n     *until `tick_irq_flag` remains `1`.*/\n    uint32_t result;\n    do {\n        tick_irq_flag = 1;\n        result        = sys_time;\n    } while(!tick_irq_flag); /*Continue until see a non interrupted cycle*/\n\n    return result;\n#else\n    return LV_TICK_CUSTOM_SYS_TIME_EXPR;\n#endif\n}"}, "lv_tick_elaps": {"type": "Function", "def": "uint32_t lv_tick_elaps(uint32_t prev_tick)", "sline": 86, "body": "{\n    uint32_t act_time = lv_tick_get();\n\n    /*If there is no overflow in sys_time simple subtract*/\n    if(act_time >= prev_tick) {\n        prev_tick = act_time - prev_tick;\n    }\n    else {\n        prev_tick = UINT32_MAX - prev_tick + 1;\n        prev_tick += act_time;\n    }\n\n    return prev_tick;\n}"}, "carbit_updater/lvgl/src/hal/lv_hal_tick.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/hal/lv_hal_tick.c"}}, "carbit_updater/lvgl/src/core/lv_indev.c": {"lv_indev": {"type": "Variable", "def": "#include lv_indev.h", "sline": 9, "include": ["carbit_updater/lvgl/src/core/lv_indev.h", null]}, "lv_disp": {"type": "Variable", "def": "#include lv_disp.h", "sline": 10, "include": ["carbit_updater/lvgl/src/core/lv_disp.h", null]}, "lv_obj": {"type": "Variable", "def": "#include lv_obj.h", "sline": 11, "include": ["carbit_updater/lvgl/src/core/lv_obj.h", null]}, "lv_indev_scroll": {"type": "Variable", "def": "#include lv_indev_scroll.h", "sline": 12, "include": ["carbit_updater/lvgl/src/core/lv_indev_scroll.h", null]}, "lv_group": {"type": "Variable", "def": "#include lv_group.h", "sline": 13, "include": ["carbit_updater/lvgl/src/core/lv_group.h", null]}, "lv_refr": {"type": "Variable", "def": "#include lv_refr.h", "sline": 14, "include": ["carbit_updater/lvgl/src/core/lv_refr.h", null]}, "lv_hal_tick": {"type": "Variable", "def": "#include ../hal/lv_hal_tick.h", "sline": 16}, "lv_timer": {"type": "Variable", "def": "#include ../misc/lv_timer.h", "sline": 17}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 18}, "indev_pointer_proc": {"type": "Function", "def": "static void indev_pointer_proc(lv_indev_t * i, lv_indev_data_t * data)", "sline": 330, "body": "{\n    lv_disp_t * disp = i->driver->disp;\n    /*Save the raw points so they can be used again in _lv_indev_read*/\n    i->proc.types.pointer.last_raw_point.x = data->point.x;\n    i->proc.types.pointer.last_raw_point.y = data->point.y;\n\n    if(disp->driver->rotated == LV_DISP_ROT_180 || disp->driver->rotated == LV_DISP_ROT_270) {\n        data->point.x = disp->driver->hor_res - data->point.x - 1;\n        data->point.y = disp->driver->ver_res - data->point.y - 1;\n    }\n    if(disp->driver->rotated == LV_DISP_ROT_90 || disp->driver->rotated == LV_DISP_ROT_270) {\n        lv_coord_t tmp = data->point.y;\n        data->point.y = data->point.x;\n        data->point.x = disp->driver->ver_res - tmp - 1;\n    }\n\n    /*Simple sanity check*/\n    if(data->point.x < 0) LV_LOG_WARN(\"X is %d which is smaller than zero\", data->point.x);\n    if(data->point.x >= lv_disp_get_hor_res(i->driver->disp)) LV_LOG_WARN(\"X is %d which is greater than hor. res\",\n                                                                              data->point.x);\n    if(data->point.y < 0) LV_LOG_WARN(\"Y is %d which is smaller than zero\", data->point.y);\n    if(data->point.y >= lv_disp_get_ver_res(i->driver->disp)) LV_LOG_WARN(\"Y is %d which is greater than hor. res\",\n                                                                              data->point.y);\n\n    /*Move the cursor if set and moved*/\n    if(i->cursor != NULL &&\n       (i->proc.types.pointer.last_point.x != data->point.x || i->proc.types.pointer.last_point.y != data->point.y)) {\n        lv_obj_set_pos(i->cursor, data->point.x, data->point.y);\n    }\n\n    i->proc.types.pointer.act_point.x = data->point.x;\n    i->proc.types.pointer.act_point.y = data->point.y;\n\n    if(i->proc.state == LV_INDEV_STATE_PRESSED) {\n        indev_proc_press(&i->proc);\n    }\n    else {\n        indev_proc_release(&i->proc);\n    }\n\n    i->proc.types.pointer.last_point.x = i->proc.types.pointer.act_point.x;\n    i->proc.types.pointer.last_point.y = i->proc.types.pointer.act_point.y;\n}"}, "indev_keypad_proc": {"type": "Function", "def": "static void indev_keypad_proc(lv_indev_t * i, lv_indev_data_t * data)", "sline": 380, "body": "{\n    if(data->state == LV_INDEV_STATE_PRESSED && i->proc.wait_until_release) return;\n\n    if(i->proc.wait_until_release) {\n        i->proc.wait_until_release      = 0;\n        i->proc.pr_timestamp            = 0;\n        i->proc.long_pr_sent            = 0;\n        i->proc.types.keypad.last_state = LV_INDEV_STATE_RELEASED; /*To skip the processing of release*/\n    }\n\n    lv_group_t * g = i->group;\n    if(g == NULL) return;\n\n    indev_obj_act = lv_group_get_focused(g);\n    if(indev_obj_act == NULL) return;\n\n    /*Save the last key to compare it with the current latter on RELEASE*/\n    uint32_t prev_key = i->proc.types.keypad.last_key;\n\n    /*Save the last key.\n     *It must be done here else `lv_indev_get_key` will return the last key in events*/\n    i->proc.types.keypad.last_key = data->key;\n\n    /*Save the previous state so we can detect state changes below and also set the last state now\n     *so if any event handler on the way returns `LV_RES_INV` the last state is remembered\n     *for the next time*/\n    uint32_t prev_state             = i->proc.types.keypad.last_state;\n    i->proc.types.keypad.last_state = data->state;\n\n    /*Key press happened*/\n    if(data->state == LV_INDEV_STATE_PRESSED && prev_state == LV_INDEV_STATE_RELEASED) {\n        LV_LOG_INFO(\"%d key is pressed\", data->key);\n        i->proc.pr_timestamp = lv_tick_get();\n\n        /*Simulate a press on the object if ENTER was pressed*/\n        if(data->key == LV_KEY_ENTER) {\n            /*Send the ENTER as a normal KEY*/\n            lv_group_send_data(g, LV_KEY_ENTER);\n\n            lv_event_send(indev_obj_act, LV_EVENT_PRESSED, indev_act);\n            if(indev_reset_check(&i->proc)) return;\n        }\n        else if(data->key == LV_KEY_ESC) {\n            /*Send the ESC as a normal KEY*/\n            lv_group_send_data(g, LV_KEY_ESC);\n\n            lv_event_send(indev_obj_act, LV_EVENT_CANCEL, indev_act);\n            if(indev_reset_check(&i->proc)) return;\n        }\n        /*Move the focus on NEXT*/\n        else if(data->key == LV_KEY_NEXT) {\n            lv_group_set_editing(g, false); /*Editing is not used by KEYPAD is be sure it is disabled*/\n            lv_group_focus_next(g);\n            if(indev_reset_check(&i->proc)) return;\n        }\n        /*Move the focus on PREV*/\n        else if(data->key == LV_KEY_PREV) {\n            lv_group_set_editing(g, false); /*Editing is not used by KEYPAD is be sure it is disabled*/\n            lv_group_focus_prev(g);\n            if(indev_reset_check(&i->proc)) return;\n        }\n        /*Just send other keys to the object (e.g. 'A' or `LV_GROUP_KEY_RIGHT`)*/\n        else {\n            lv_group_send_data(g, data->key);\n        }\n    }\n    /*Pressing*/\n    else if(data->state == LV_INDEV_STATE_PRESSED && prev_state == LV_INDEV_STATE_PRESSED) {\n\n        if(data->key == LV_KEY_ENTER) {\n            lv_event_send(indev_obj_act, LV_EVENT_PRESSING, indev_act);\n            if(indev_reset_check(&i->proc)) return;\n        }\n\n        /*Long press time has elapsed?*/\n        if(i->proc.long_pr_sent == 0 && lv_tick_elaps(i->proc.pr_timestamp) > i->driver->long_press_time) {\n            i->proc.long_pr_sent = 1;\n            if(data->key == LV_KEY_ENTER) {\n                i->proc.longpr_rep_timestamp = lv_tick_get();\n                lv_event_send(indev_obj_act, LV_EVENT_LONG_PRESSED, indev_act);\n                if(indev_reset_check(&i->proc)) return;\n            }\n        }\n        /*Long press repeated time has elapsed?*/\n        else if(i->proc.long_pr_sent != 0 &&\n                lv_tick_elaps(i->proc.longpr_rep_timestamp) > i->driver->long_press_repeat_time) {\n\n            i->proc.longpr_rep_timestamp = lv_tick_get();\n\n            /*Send LONG_PRESS_REP on ENTER*/\n            if(data->key == LV_KEY_ENTER) {\n                lv_event_send(indev_obj_act, LV_EVENT_LONG_PRESSED_REPEAT, indev_act);\n                if(indev_reset_check(&i->proc)) return;\n            }\n            /*Move the focus on NEXT again*/\n            else if(data->key == LV_KEY_NEXT) {\n                lv_group_set_editing(g, false); /*Editing is not used by KEYPAD is be sure it is disabled*/\n                lv_group_focus_next(g);\n                if(indev_reset_check(&i->proc)) return;\n            }\n            /*Move the focus on PREV again*/\n            else if(data->key == LV_KEY_PREV) {\n                lv_group_set_editing(g, false); /*Editing is not used by KEYPAD is be sure it is disabled*/\n                lv_group_focus_prev(g);\n                if(indev_reset_check(&i->proc)) return;\n            }\n            /*Just send other keys again to the object (e.g. 'A' or `LV_GROUP_KEY_RIGHT)*/\n            else {\n                lv_group_send_data(g, data->key);\n                if(indev_reset_check(&i->proc)) return;\n            }\n        }\n    }\n    /*Release happened*/\n    else if(data->state == LV_INDEV_STATE_RELEASED && prev_state == LV_INDEV_STATE_PRESSED) {\n        LV_LOG_INFO(\"%d key is released\", data->key);\n        /*The user might clear the key when it was released. Always release the pressed key*/\n        data->key = prev_key;\n        if(data->key == LV_KEY_ENTER) {\n\n            lv_event_send(indev_obj_act, LV_EVENT_RELEASED, indev_act);\n            if(indev_reset_check(&i->proc)) return;\n\n            if(i->proc.long_pr_sent == 0) {\n                lv_event_send(indev_obj_act, LV_EVENT_SHORT_CLICKED, indev_act);\n                if(indev_reset_check(&i->proc)) return;\n            }\n\n            lv_event_send(indev_obj_act, LV_EVENT_CLICKED, indev_act);\n            if(indev_reset_check(&i->proc)) return;\n\n        }\n        i->proc.pr_timestamp = 0;\n        i->proc.long_pr_sent = 0;\n    }\n    indev_obj_act = NULL;\n}"}, "indev_encoder_proc": {"type": "Function", "def": "static void indev_encoder_proc(lv_indev_t * i, lv_indev_data_t * data)", "sline": 524, "body": "{\n    if(data->state == LV_INDEV_STATE_PRESSED && i->proc.wait_until_release) return;\n\n    if(i->proc.wait_until_release) {\n        i->proc.wait_until_release      = 0;\n        i->proc.pr_timestamp            = 0;\n        i->proc.long_pr_sent            = 0;\n        i->proc.types.keypad.last_state = LV_INDEV_STATE_RELEASED; /*To skip the processing of release*/\n    }\n\n    /*Save the last keys before anything else.\n     *They need to be already saved if the function returns for any reason*/\n    lv_indev_state_t last_state     = i->proc.types.keypad.last_state;\n    i->proc.types.keypad.last_state = data->state;\n    i->proc.types.keypad.last_key   = data->key;\n\n    lv_group_t * g = i->group;\n    if(g == NULL) return;\n\n    indev_obj_act = lv_group_get_focused(g);\n    if(indev_obj_act == NULL) return;\n\n    /*Process the steps they are valid only with released button*/\n    if(data->state != LV_INDEV_STATE_RELEASED) {\n        data->enc_diff = 0;\n    }\n\n    /*Refresh the focused object. It might change due to lv_group_focus_prev/next*/\n    indev_obj_act = lv_group_get_focused(g);\n    if(indev_obj_act == NULL) return;\n\n    /*Button press happened*/\n    if(data->state == LV_INDEV_STATE_PRESSED && last_state == LV_INDEV_STATE_RELEASED) {\n        LV_LOG_INFO(\"pressed\");\n\n        i->proc.pr_timestamp = lv_tick_get();\n\n        if(data->key == LV_KEY_ENTER) {\n            bool editable_or_scrollable = lv_obj_is_editable(indev_obj_act) ||\n                                          lv_obj_has_flag(indev_obj_act, LV_OBJ_FLAG_SCROLLABLE);\n            if(lv_group_get_editing(g) == true || editable_or_scrollable == false) {\n                lv_event_send(indev_obj_act, LV_EVENT_PRESSED, indev_act);\n                if(indev_reset_check(&i->proc)) return;\n            }\n        }\n        else if(data->key == LV_KEY_LEFT) {\n            /*emulate encoder left*/\n            data->enc_diff--;\n        }\n        else if(data->key == LV_KEY_RIGHT) {\n            /*emulate encoder right*/\n            data->enc_diff++;\n        }\n        else if(data->key == LV_KEY_ESC) {\n            /*Send the ESC as a normal KEY*/\n            lv_group_send_data(g, LV_KEY_ESC);\n\n            lv_event_send(indev_obj_act, LV_EVENT_CANCEL, indev_act);\n            if(indev_reset_check(&i->proc)) return;\n        }\n        /*Just send other keys to the object (e.g. 'A' or `LV_GROUP_KEY_RIGHT`)*/\n        else {\n            lv_group_send_data(g, data->key);\n        }\n    }\n    /*Pressing*/\n    else if(data->state == LV_INDEV_STATE_PRESSED && last_state == LV_INDEV_STATE_PRESSED) {\n        /*Long press*/\n        if(i->proc.long_pr_sent == 0 && lv_tick_elaps(i->proc.pr_timestamp) > i->driver->long_press_time) {\n\n            i->proc.long_pr_sent = 1;\n            i->proc.longpr_rep_timestamp = lv_tick_get();\n\n            if(data->key == LV_KEY_ENTER) {\n                bool editable_or_scrollable = lv_obj_is_editable(indev_obj_act) ||\n                                              lv_obj_has_flag(indev_obj_act, LV_OBJ_FLAG_SCROLLABLE);\n\n                /*On enter long press toggle edit mode.*/\n                if(editable_or_scrollable) {\n                    /*Don't leave edit mode if there is only one object (nowhere to navigate)*/\n                    if(lv_group_get_obj_count(g) > 1) {\n                        LV_LOG_INFO(\"toggling edit mode\");\n                        lv_group_set_editing(g, lv_group_get_editing(g) ? false : true); /*Toggle edit mode on long press*/\n                        lv_obj_clear_state(indev_obj_act, LV_STATE_PRESSED);    /*Remove the pressed state manually*/\n                    }\n                }\n                /*If not editable then just send a long press Call the ancestor's event handler*/\n                else {\n                    lv_event_send(indev_obj_act, LV_EVENT_LONG_PRESSED, indev_act);\n                    if(indev_reset_check(&i->proc)) return;\n                }\n            }\n\n            i->proc.long_pr_sent = 1;\n        }\n        /*Long press repeated time has elapsed?*/\n        else if(i->proc.long_pr_sent != 0 && lv_tick_elaps(i->proc.longpr_rep_timestamp) > i->driver->long_press_repeat_time) {\n\n            i->proc.longpr_rep_timestamp = lv_tick_get();\n\n            if(data->key == LV_KEY_ENTER) {\n                lv_event_send(indev_obj_act, LV_EVENT_LONG_PRESSED_REPEAT, indev_act);\n                if(indev_reset_check(&i->proc)) return;\n            }\n            else if(data->key == LV_KEY_LEFT) {\n                /*emulate encoder left*/\n                data->enc_diff--;\n            }\n            else if(data->key == LV_KEY_RIGHT) {\n                /*emulate encoder right*/\n                data->enc_diff++;\n            }\n            else {\n                lv_group_send_data(g, data->key);\n                if(indev_reset_check(&i->proc)) return;\n            }\n\n        }\n\n    }\n    /*Release happened*/\n    else if(data->state == LV_INDEV_STATE_RELEASED && last_state == LV_INDEV_STATE_PRESSED) {\n        LV_LOG_INFO(\"released\");\n\n        if(data->key == LV_KEY_ENTER) {\n            bool editable_or_scrollable = lv_obj_is_editable(indev_obj_act) ||\n                                          lv_obj_has_flag(indev_obj_act, LV_OBJ_FLAG_SCROLLABLE);\n\n            /*The button was released on a non-editable object. Just send enter*/\n            if(editable_or_scrollable == false) {\n                lv_event_send(indev_obj_act, LV_EVENT_RELEASED, indev_act);\n                if(indev_reset_check(&i->proc)) return;\n\n                if(i->proc.long_pr_sent == 0) lv_event_send(indev_obj_act, LV_EVENT_SHORT_CLICKED, indev_act);\n                if(indev_reset_check(&i->proc)) return;\n\n                lv_event_send(indev_obj_act, LV_EVENT_CLICKED, indev_act);\n                if(indev_reset_check(&i->proc)) return;\n\n            }\n            /*An object is being edited and the button is released.*/\n            else if(lv_group_get_editing(g)) {\n                /*Ignore long pressed enter release because it comes from mode switch*/\n                if(!i->proc.long_pr_sent || lv_group_get_obj_count(g) <= 1) {\n                    lv_event_send(indev_obj_act, LV_EVENT_RELEASED, indev_act);\n                    if(indev_reset_check(&i->proc)) return;\n\n                    lv_event_send(indev_obj_act, LV_EVENT_SHORT_CLICKED, indev_act);\n                    if(indev_reset_check(&i->proc)) return;\n\n                    lv_event_send(indev_obj_act, LV_EVENT_CLICKED, indev_act);\n                    if(indev_reset_check(&i->proc)) return;\n\n\n                    lv_group_send_data(g, LV_KEY_ENTER);\n                }\n                else {\n                    lv_obj_clear_state(indev_obj_act, LV_STATE_PRESSED);    /*Remove the pressed state manually*/\n                }\n            }\n            /*If the focused object is editable and now in navigate mode then on enter switch edit\n               mode*/\n            else if(!i->proc.long_pr_sent) {\n                LV_LOG_INFO(\"entering edit mode\");\n                lv_group_set_editing(g, true); /*Set edit mode*/\n            }\n        }\n\n        i->proc.pr_timestamp = 0;\n        i->proc.long_pr_sent = 0;\n    }\n    indev_obj_act = NULL;\n\n    /*if encoder steps or simulated steps via left/right keys*/\n    if(data->enc_diff != 0) {\n        /*In edit mode send LEFT/RIGHT keys*/\n        if(lv_group_get_editing(g)) {\n            LV_LOG_INFO(\"rotated by %+d (edit)\", data->enc_diff);\n            int32_t s;\n            if(data->enc_diff < 0) {\n                for(s = 0; s < -data->enc_diff; s++) lv_group_send_data(g, LV_KEY_LEFT);\n            }\n            else if(data->enc_diff > 0) {\n                for(s = 0; s < data->enc_diff; s++) lv_group_send_data(g, LV_KEY_RIGHT);\n            }\n        }\n        /*In navigate mode focus on the next/prev objects*/\n        else {\n            LV_LOG_INFO(\"rotated by %+d (nav)\", data->enc_diff);\n            int32_t s;\n            if(data->enc_diff < 0) {\n                for(s = 0; s < -data->enc_diff; s++) lv_group_focus_prev(g);\n            }\n            else if(data->enc_diff > 0) {\n                for(s = 0; s < data->enc_diff; s++) lv_group_focus_next(g);\n            }\n        }\n    }\n}"}, "indev_button_proc": {"type": "Function", "def": "static void indev_button_proc(lv_indev_t * i, lv_indev_data_t * data)", "sline": 731, "body": "{\n    /*Die gracefully if i->btn_points is NULL*/\n    if(i->btn_points == NULL) {\n        LV_LOG_WARN(\"btn_points is NULL\");\n        return;\n    }\n\n    lv_coord_t x = i->btn_points[data->btn_id].x;\n    lv_coord_t y = i->btn_points[data->btn_id].y;\n\n    static lv_indev_state_t prev_state = LV_INDEV_STATE_RELEASED;\n    if(prev_state != data->state) {\n        if(data->state == LV_INDEV_STATE_PRESSED) {\n            LV_LOG_INFO(\"button %d is pressed (x:%d y:%d)\", data->btn_id, x, y);\n        }\n        else {\n            LV_LOG_INFO(\"button %d is released (x:%d y:%d)\", data->btn_id, x, y);\n        }\n    }\n\n    /*If a new point comes always make a release*/\n    if(data->state == LV_INDEV_STATE_PRESSED) {\n        if(i->proc.types.pointer.last_point.x != x ||\n           i->proc.types.pointer.last_point.y != y) {\n            indev_proc_release(&i->proc);\n        }\n    }\n\n    if(indev_reset_check(&i->proc)) return;\n\n    /*Save the new points*/\n    i->proc.types.pointer.act_point.x = x;\n    i->proc.types.pointer.act_point.y = y;\n\n    if(data->state == LV_INDEV_STATE_PRESSED) indev_proc_press(&i->proc);\n    else indev_proc_release(&i->proc);\n\n    if(indev_reset_check(&i->proc)) return;\n\n    i->proc.types.pointer.last_point.x = i->proc.types.pointer.act_point.x;\n    i->proc.types.pointer.last_point.y = i->proc.types.pointer.act_point.y;\n}"}, "indev_proc_press": {"type": "Function", "def": "static void indev_proc_press(_lv_indev_proc_t * proc)", "sline": 780, "body": "{\n    LV_LOG_INFO(\"pressed at x:%d y:%d\", proc->types.pointer.act_point.x, proc->types.pointer.act_point.y);\n    indev_obj_act = proc->types.pointer.act_obj;\n\n    if(proc->wait_until_release != 0) return;\n\n    lv_disp_t * disp = indev_act->driver->disp;\n    bool new_obj_searched = false;\n\n    /*If there is no last object then search*/\n    if(indev_obj_act == NULL) {\n        indev_obj_act = lv_indev_search_obj(lv_disp_get_layer_sys(disp), &proc->types.pointer.act_point);\n        if(indev_obj_act == NULL) indev_obj_act = lv_indev_search_obj(lv_disp_get_layer_top(disp),\n                                                                          &proc->types.pointer.act_point);\n        if(indev_obj_act == NULL) indev_obj_act = lv_indev_search_obj(lv_disp_get_scr_act(disp),\n                                                                          &proc->types.pointer.act_point);\n        new_obj_searched = true;\n    }\n    /*If there is last object but it is not scrolled and not protected also search*/\n    else if(proc->types.pointer.scroll_obj == NULL &&\n            lv_obj_has_flag(indev_obj_act, LV_OBJ_FLAG_PRESS_LOCK) == false) {\n        indev_obj_act = lv_indev_search_obj(lv_disp_get_layer_sys(disp), &proc->types.pointer.act_point);\n        if(indev_obj_act == NULL) indev_obj_act = lv_indev_search_obj(lv_disp_get_layer_top(disp),\n                                                                          &proc->types.pointer.act_point);\n        if(indev_obj_act == NULL) indev_obj_act = lv_indev_search_obj(lv_disp_get_scr_act(disp),\n                                                                          &proc->types.pointer.act_point);\n        new_obj_searched = true;\n    }\n\n    /*The last object might have scroll throw. Stop it manually*/\n    if(new_obj_searched && proc->types.pointer.last_obj) {\n        proc->types.pointer.scroll_throw_vect.x = 0;\n        proc->types.pointer.scroll_throw_vect.y = 0;\n        _lv_indev_scroll_throw_handler(proc);\n        if(indev_reset_check(proc)) return;\n    }\n\n    /*If a new object was found reset some variables and send a pressed Call the ancestor's event handler*/\n    if(indev_obj_act != proc->types.pointer.act_obj) {\n        proc->types.pointer.last_point.x = proc->types.pointer.act_point.x;\n        proc->types.pointer.last_point.y = proc->types.pointer.act_point.y;\n\n        /*If a new object found the previous was lost, so send a Call the ancestor's event handler*/\n        if(proc->types.pointer.act_obj != NULL) {\n            /*Save the obj because in special cases `act_obj` can change in the Call the ancestor's event handler function*/\n            lv_obj_t * last_obj = proc->types.pointer.act_obj;\n\n            lv_event_send(last_obj, LV_EVENT_PRESS_LOST, indev_act);\n            if(indev_reset_check(proc)) return;\n        }\n\n        proc->types.pointer.act_obj  = indev_obj_act; /*Save the pressed object*/\n        proc->types.pointer.last_obj = indev_obj_act;\n\n        if(indev_obj_act != NULL) {\n            /*Save the time when the obj pressed to count long press time.*/\n            proc->pr_timestamp                 = lv_tick_get();\n            proc->long_pr_sent                 = 0;\n            proc->types.pointer.scroll_sum.x     = 0;\n            proc->types.pointer.scroll_sum.y     = 0;\n            proc->types.pointer.scroll_dir = LV_DIR_NONE;\n            proc->types.pointer.gesture_dir = LV_DIR_NONE;\n            proc->types.pointer.gesture_sent   = 0;\n            proc->types.pointer.gesture_sum.x  = 0;\n            proc->types.pointer.gesture_sum.y  = 0;\n            proc->types.pointer.vect.x         = 0;\n            proc->types.pointer.vect.y         = 0;\n\n            /*Call the ancestor's event handler about the press*/\n            lv_event_send(indev_obj_act, LV_EVENT_PRESSED, indev_act);\n            if(indev_reset_check(proc)) return;\n\n            if(indev_act->proc.wait_until_release) return;\n\n            /*Handle focus*/\n            indev_click_focus(&indev_act->proc);\n            if(indev_reset_check(proc)) return;\n\n        }\n    }\n\n    /*Calculate the vector and apply a low pass filter: new value = 0.5 * old_value + 0.5 * new_value*/\n    proc->types.pointer.vect.x = proc->types.pointer.act_point.x - proc->types.pointer.last_point.x;\n    proc->types.pointer.vect.y = proc->types.pointer.act_point.y - proc->types.pointer.last_point.y;\n\n    proc->types.pointer.scroll_throw_vect.x = (proc->types.pointer.scroll_throw_vect.x * 4) >> 3;\n    proc->types.pointer.scroll_throw_vect.y = (proc->types.pointer.scroll_throw_vect.y * 4) >> 3;\n\n    proc->types.pointer.scroll_throw_vect.x += (proc->types.pointer.vect.x * 4) >> 3;\n    proc->types.pointer.scroll_throw_vect.y += (proc->types.pointer.vect.y * 4) >> 3;\n\n    proc->types.pointer.scroll_throw_vect_ori = proc->types.pointer.scroll_throw_vect;\n\n    if(indev_obj_act) {\n        lv_event_send(indev_obj_act, LV_EVENT_PRESSING, indev_act);\n        if(indev_reset_check(proc)) return;\n\n        if(indev_act->proc.wait_until_release) return;\n\n        _lv_indev_scroll_handler(proc);\n        if(indev_reset_check(proc)) return;\n        indev_gesture(proc);\n        if(indev_reset_check(proc)) return;\n\n        /*If there is no scrolling then check for long press time*/\n        if(proc->types.pointer.scroll_obj == NULL && proc->long_pr_sent == 0) {\n            /*Call the ancestor's event handler about the long press if enough time elapsed*/\n            if(lv_tick_elaps(proc->pr_timestamp) > indev_act->driver->long_press_time) {\n                lv_event_send(indev_obj_act, LV_EVENT_LONG_PRESSED, indev_act);\n                if(indev_reset_check(proc)) return;\n\n                /*Mark the Call the ancestor's event handler sending to do not send it again*/\n                proc->long_pr_sent = 1;\n\n                /*Save the long press time stamp for the long press repeat handler*/\n                proc->longpr_rep_timestamp = lv_tick_get();\n            }\n        }\n\n        /*Send long press repeated Call the ancestor's event handler*/\n        if(proc->types.pointer.scroll_obj == NULL && proc->long_pr_sent == 1) {\n            /*Call the ancestor's event handler about the long press repeat if enough time elapsed*/\n            if(lv_tick_elaps(proc->longpr_rep_timestamp) > indev_act->driver->long_press_repeat_time) {\n                lv_event_send(indev_obj_act, LV_EVENT_LONG_PRESSED_REPEAT, indev_act);\n                if(indev_reset_check(proc)) return;\n                proc->longpr_rep_timestamp = lv_tick_get();\n            }\n        }\n    }\n}"}, "indev_proc_release": {"type": "Function", "def": "static void indev_proc_release(_lv_indev_proc_t * proc)", "sline": 916, "body": "{\n    if(proc->wait_until_release != 0) {\n        proc->types.pointer.act_obj  = NULL;\n        proc->types.pointer.last_obj = NULL;\n        proc->pr_timestamp           = 0;\n        proc->longpr_rep_timestamp   = 0;\n        proc->wait_until_release     = 0;\n    }\n    indev_obj_act = proc->types.pointer.act_obj;\n    lv_obj_t * scroll_obj = proc->types.pointer.scroll_obj;\n\n    /*Forget the act obj and send a released Call the ancestor's event handler*/\n    if(indev_obj_act) {\n        LV_LOG_INFO(\"released\");\n\n        /*Send RELEASE Call the ancestor's event handler and event*/\n        lv_event_send(indev_obj_act, LV_EVENT_RELEASED, indev_act);\n        if(indev_reset_check(proc)) return;\n\n        /*Send CLICK if no scrolling*/\n        if(scroll_obj == NULL) {\n            if(proc->long_pr_sent == 0) {\n                lv_event_send(indev_obj_act, LV_EVENT_SHORT_CLICKED, indev_act);\n                if(indev_reset_check(proc)) return;\n            }\n\n            lv_event_send(indev_obj_act, LV_EVENT_CLICKED, indev_act);\n            if(indev_reset_check(proc)) return;\n        }\n\n        proc->types.pointer.act_obj = NULL;\n        proc->pr_timestamp          = 0;\n        proc->longpr_rep_timestamp  = 0;\n\n    }\n\n    /*The reset can be set in the Call the ancestor's event handler function.\n     * In case of reset query ignore the remaining parts.*/\n    if(scroll_obj) {\n        _lv_indev_scroll_throw_handler(proc);\n        if(indev_reset_check(proc)) return;\n    }\n}"}, "indev_proc_reset_query_handler": {"type": "Function", "def": "static void indev_proc_reset_query_handler(lv_indev_t * indev)", "sline": 968, "body": "{\n    if(indev->proc.reset_query) {\n        indev->proc.types.pointer.act_obj           = NULL;\n        indev->proc.types.pointer.last_obj          = NULL;\n        indev->proc.types.pointer.scroll_obj          = NULL;\n        indev->proc.long_pr_sent                    = 0;\n        indev->proc.pr_timestamp                    = 0;\n        indev->proc.longpr_rep_timestamp            = 0;\n        indev->proc.types.pointer.scroll_sum.x        = 0;\n        indev->proc.types.pointer.scroll_sum.y        = 0;\n        indev->proc.types.pointer.scroll_dir = LV_DIR_NONE;\n        indev->proc.types.pointer.scroll_throw_vect.x = 0;\n        indev->proc.types.pointer.scroll_throw_vect.y = 0;\n        indev->proc.types.pointer.gesture_sum.x     = 0;\n        indev->proc.types.pointer.gesture_sum.y     = 0;\n        indev->proc.reset_query                     = 0;\n        indev_obj_act                               = NULL;\n    }\n}"}, "indev_click_focus": {"type": "Function", "def": "static void indev_click_focus(_lv_indev_proc_t * proc)", "sline": 993, "body": "{\n    /*Handle click focus*/\n    if(lv_obj_has_flag(indev_obj_act, LV_OBJ_FLAG_CLICK_FOCUSABLE) == false ||\n       proc->types.pointer.last_pressed == indev_obj_act)\n    {\n        return;\n    }\n\n    lv_group_t * g_act = lv_obj_get_group(indev_obj_act);\n    lv_group_t * g_prev = proc->types.pointer.last_pressed ? lv_obj_get_group(proc->types.pointer.last_pressed) : NULL;\n\n    /*If both the last and act. obj. are in the same group (or have no group)*/\n    if(g_act == g_prev) {\n        /*The objects are in a group*/\n        if(g_act) {\n            lv_group_focus_obj(indev_obj_act);\n            if(indev_reset_check(proc)) return;\n        }\n        /*The object are not in group*/\n        else {\n            if(proc->types.pointer.last_pressed) {\n                lv_event_send(proc->types.pointer.last_pressed, LV_EVENT_DEFOCUSED, indev_act);\n                if(indev_reset_check(proc)) return;\n            }\n\n            lv_event_send(indev_obj_act, LV_EVENT_FOCUSED, indev_act);\n            if(indev_reset_check(proc)) return;\n        }\n    }\n    /*The object are not in the same group (in different groups or one has no group)*/\n    else {\n        /*If the prev. obj. is not in a group then defocus it.*/\n        if(g_prev == NULL && proc->types.pointer.last_pressed) {\n            lv_event_send(proc->types.pointer.last_pressed, LV_EVENT_DEFOCUSED, indev_act);\n            if(indev_reset_check(proc)) return;\n        }\n        /*Focus on a non-group object*/\n        else {\n            if(proc->types.pointer.last_pressed) {\n                /*If the prev. object also wasn't in a group defocus it*/\n                if(g_prev == NULL) {\n                    lv_event_send(proc->types.pointer.last_pressed, LV_EVENT_DEFOCUSED, indev_act);\n                    if(indev_reset_check(proc)) return;\n                }\n                /*If the prev. object also was in a group at least \"LEAVE\" it instead of defocus*/\n                else {\n                    lv_event_send(proc->types.pointer.last_pressed, LV_EVENT_LEAVE, indev_act);\n                    if(indev_reset_check(proc)) return;\n                }\n            }\n        }\n\n        /*Focus to the act. in its group*/\n        if(g_act) {\n            lv_group_focus_obj(indev_obj_act);\n            if(indev_reset_check(proc)) return;\n        }\n        else {\n            lv_event_send(indev_obj_act, LV_EVENT_FOCUSED, indev_act);\n            if(indev_reset_check(proc)) return;\n        }\n    }\n    proc->types.pointer.last_pressed = indev_obj_act;\n}"}, "indev_gesture": {"type": "Function", "def": "void indev_gesture(_lv_indev_proc_t * proc)", "sline": 1063, "body": "{\n\n    if(proc->types.pointer.scroll_obj) return;\n    if(proc->types.pointer.gesture_sent) return;\n\n    lv_obj_t * gesture_obj = proc->types.pointer.act_obj;\n\n    /*If gesture parent is active check recursively the gesture attribute*/\n    while(gesture_obj && lv_obj_has_flag(gesture_obj, LV_OBJ_FLAG_GESTURE_BUBBLE)) {\n        gesture_obj = lv_obj_get_parent(gesture_obj);\n    }\n\n    if(gesture_obj == NULL) return;\n\n    if((LV_ABS(proc->types.pointer.vect.x) < indev_act->driver->gesture_min_velocity) &&\n       (LV_ABS(proc->types.pointer.vect.y) < indev_act->driver->gesture_min_velocity)) {\n        proc->types.pointer.gesture_sum.x = 0;\n        proc->types.pointer.gesture_sum.y = 0;\n    }\n\n    /*Count the movement by gesture*/\n    proc->types.pointer.gesture_sum.x += proc->types.pointer.vect.x;\n    proc->types.pointer.gesture_sum.y += proc->types.pointer.vect.y;\n\n    if((LV_ABS(proc->types.pointer.gesture_sum.x) > indev_act->driver->gesture_limit) ||\n       (LV_ABS(proc->types.pointer.gesture_sum.y) > indev_act->driver->gesture_limit)) {\n\n        proc->types.pointer.gesture_sent = 1;\n\n        if(LV_ABS(proc->types.pointer.gesture_sum.x) > LV_ABS(proc->types.pointer.gesture_sum.y)) {\n            if(proc->types.pointer.gesture_sum.x > 0)\n                proc->types.pointer.gesture_dir = LV_DIR_RIGHT;\n            else\n                proc->types.pointer.gesture_dir = LV_DIR_LEFT;\n        }\n        else {\n            if(proc->types.pointer.gesture_sum.y > 0)\n                proc->types.pointer.gesture_dir = LV_DIR_BOTTOM;\n            else\n                proc->types.pointer.gesture_dir = LV_DIR_TOP;\n        }\n\n        lv_event_send(gesture_obj, LV_EVENT_GESTURE, indev_act);\n        if(indev_reset_check(proc)) return;\n    }\n}"}, "indev_reset_check": {"type": "Function", "def": "static bool indev_reset_check(_lv_indev_proc_t * proc)", "sline": 1116, "body": "{\n    if(proc->reset_query) {\n        indev_obj_act = NULL;\n    }\n\n    return proc->reset_query ? true : false;\n}"}, "indev_act": {"type": "Variable", "def": "static lv_indev_t * indev_act", "sline": 48}, "indev_obj_act": {"type": "Variable", "def": "static lv_obj_t * indev_obj_act", "sline": 49}, "lv_indev_read_timer_cb": {"type": "Function", "def": "void lv_indev_read_timer_cb(lv_timer_t * timer)", "sline": 64, "body": "{\n    INDEV_TRACE(\"begin\");\n\n    lv_indev_data_t data;\n\n    indev_act = timer->user_data;\n\n    /*Read and process all indevs*/\n    if(indev_act->driver->disp == NULL) return; /*Not assigned to any displays*/\n\n    /*Handle reset query before processing the point*/\n    indev_proc_reset_query_handler(indev_act);\n\n    if(indev_act->proc.disabled) return;\n    bool continue_reading;\n    do {\n        /*Read the data*/\n        _lv_indev_read(indev_act, &data);\n        continue_reading = data.continue_reading;\n\n        /*The active object might deleted even in the read function*/\n        indev_proc_reset_query_handler(indev_act);\n        indev_obj_act = NULL;\n\n        indev_act->proc.state = data.state;\n\n        /*Save the last activity time*/\n        if(indev_act->proc.state == LV_INDEV_STATE_PRESSED) {\n            indev_act->driver->disp->last_activity_time = lv_tick_get();\n        }\n        else if(indev_act->driver->type == LV_INDEV_TYPE_ENCODER && data.enc_diff) {\n            indev_act->driver->disp->last_activity_time = lv_tick_get();\n        }\n\n        if(indev_act->driver->type == LV_INDEV_TYPE_POINTER) {\n            indev_pointer_proc(indev_act, &data);\n        }\n        else if(indev_act->driver->type == LV_INDEV_TYPE_KEYPAD) {\n            indev_keypad_proc(indev_act, &data);\n        }\n        else if(indev_act->driver->type == LV_INDEV_TYPE_ENCODER) {\n            indev_encoder_proc(indev_act, &data);\n        }\n        else if(indev_act->driver->type == LV_INDEV_TYPE_BUTTON) {\n            indev_button_proc(indev_act, &data);\n        }\n        /*Handle reset query if it happened in during processing*/\n        indev_proc_reset_query_handler(indev_act);\n    } while(continue_reading);\n\n    /*End of indev processing, so no act indev*/\n    indev_act     = NULL;\n    indev_obj_act = NULL;\n\n    INDEV_TRACE(\"finished\");\n}"}, "lv_indev_enable": {"type": "Function", "def": "void lv_indev_enable(lv_indev_t * indev, bool en)", "sline": 122, "body": "{\n    if(!indev) return;\n\n    indev->proc.disabled = en ? 0 : 1;\n}"}, "lv_indev_get_act": {"type": "Function", "def": "lv_indev_t * lv_indev_get_act(void)", "sline": 129, "body": "{\n    return indev_act;\n}"}, "lv_indev_get_type": {"type": "Function", "def": "lv_indev_type_t lv_indev_get_type(const lv_indev_t * indev)", "sline": 134, "body": "{\n    if(indev == NULL) return LV_INDEV_TYPE_NONE;\n\n    return indev->driver->type;\n}"}, "lv_indev_reset": {"type": "Function", "def": "void lv_indev_reset(lv_indev_t * indev, lv_obj_t * obj)", "sline": 141, "body": "{\n    if(indev) {\n        indev->proc.reset_query = 1;\n        if(indev_act == indev) indev_obj_act = NULL;\n        if(indev->driver->type == LV_INDEV_TYPE_POINTER || indev->driver->type == LV_INDEV_TYPE_KEYPAD) {\n            if(obj == NULL || indev->proc.types.pointer.last_pressed == obj) {\n                indev->proc.types.pointer.last_pressed = NULL;\n            }\n            if(obj == NULL || indev->proc.types.pointer.act_obj == obj) {\n                indev->proc.types.pointer.act_obj = NULL;\n            }\n            if(obj == NULL || indev->proc.types.pointer.last_obj == obj) {\n                indev->proc.types.pointer.last_obj = NULL;\n            }\n        }\n    }\n    else {\n        lv_indev_t * i = lv_indev_get_next(NULL);\n        while(i) {\n            i->proc.reset_query = 1;\n            if(i->driver->type == LV_INDEV_TYPE_POINTER || i->driver->type == LV_INDEV_TYPE_KEYPAD) {\n                if(obj == NULL || i->proc.types.pointer.last_pressed == obj) {\n                    i->proc.types.pointer.last_pressed = NULL;\n                }\n                if(obj == NULL || i->proc.types.pointer.act_obj == obj) {\n                    i->proc.types.pointer.act_obj = NULL;\n                }\n                if(obj == NULL || i->proc.types.pointer.last_obj == obj) {\n                    i->proc.types.pointer.last_obj = NULL;\n                }\n            }\n            i = lv_indev_get_next(i);\n        }\n        indev_obj_act = NULL;\n    }\n}"}, "lv_indev_reset_long_press": {"type": "Function", "def": "void lv_indev_reset_long_press(lv_indev_t * indev)", "sline": 179, "body": "{\n    indev->proc.long_pr_sent         = 0;\n    indev->proc.longpr_rep_timestamp = lv_tick_get();\n    indev->proc.pr_timestamp         = lv_tick_get();\n}"}, "lv_indev_set_cursor": {"type": "Function", "def": "void lv_indev_set_cursor(lv_indev_t * indev, lv_obj_t * cur_obj)", "sline": 186, "body": "{\n    if(indev->driver->type != LV_INDEV_TYPE_POINTER) return;\n\n    indev->cursor = cur_obj;\n    lv_obj_set_parent(indev->cursor, lv_disp_get_layer_sys(indev->driver->disp));\n    lv_obj_set_pos(indev->cursor, indev->proc.types.pointer.act_point.x, indev->proc.types.pointer.act_point.y);\n    lv_obj_clear_flag(indev->cursor, LV_OBJ_FLAG_CLICKABLE);\n    lv_obj_add_flag(indev->cursor, LV_OBJ_FLAG_IGNORE_LAYOUT | LV_OBJ_FLAG_FLOATING);\n}"}, "lv_indev_set_group": {"type": "Function", "def": "void lv_indev_set_group(lv_indev_t * indev, lv_group_t * group)", "sline": 197, "body": "{\n    if(indev->driver->type == LV_INDEV_TYPE_KEYPAD || indev->driver->type == LV_INDEV_TYPE_ENCODER) {\n        indev->group = group;\n    }\n}"}, "lv_indev_set_button_points": {"type": "Function", "def": "void lv_indev_set_button_points(lv_indev_t * indev, const lv_point_t points[])", "sline": 204, "body": "{\n    if(indev->driver->type == LV_INDEV_TYPE_BUTTON) {\n        indev->btn_points = points;\n    }\n}"}, "lv_indev_get_point": {"type": "Function", "def": "void lv_indev_get_point(const lv_indev_t * indev, lv_point_t * point)", "sline": 211, "body": "{\n    if(indev == NULL) {\n        point->x = 0;\n        point->y = 0;\n        return;\n    }\n    if(indev->driver->type != LV_INDEV_TYPE_POINTER && indev->driver->type != LV_INDEV_TYPE_BUTTON) {\n        point->x = -1;\n        point->y = -1;\n    }\n    else {\n        point->x = indev->proc.types.pointer.act_point.x;\n        point->y = indev->proc.types.pointer.act_point.y;\n    }\n}"}, "lv_indev_get_gesture_dir": {"type": "Function", "def": "lv_dir_t lv_indev_get_gesture_dir(const lv_indev_t * indev)", "sline": 228, "body": "{\n    return indev->proc.types.pointer.gesture_dir;\n}"}, "lv_indev_get_key": {"type": "Function", "def": "uint32_t lv_indev_get_key(const lv_indev_t * indev)", "sline": 233, "body": "{\n    if(indev->driver->type != LV_INDEV_TYPE_KEYPAD)\n        return 0;\n    else\n        return indev->proc.types.keypad.last_key;\n}"}, "lv_indev_get_scroll_dir": {"type": "Function", "def": "lv_dir_t lv_indev_get_scroll_dir(const lv_indev_t * indev)", "sline": 241, "body": "{\n    if(indev == NULL) return false;\n    if(indev->driver->type != LV_INDEV_TYPE_POINTER && indev->driver->type != LV_INDEV_TYPE_BUTTON) return false;\n    return indev->proc.types.pointer.scroll_dir;\n}"}, "lv_indev_get_scroll_obj": {"type": "Function", "def": "lv_obj_t * lv_indev_get_scroll_obj(const lv_indev_t * indev)", "sline": 248, "body": "{\n    if(indev == NULL) return NULL;\n    if(indev->driver->type != LV_INDEV_TYPE_POINTER && indev->driver->type != LV_INDEV_TYPE_BUTTON) return NULL;\n    return indev->proc.types.pointer.scroll_obj;\n}"}, "lv_indev_get_vect": {"type": "Function", "def": "void lv_indev_get_vect(const lv_indev_t * indev, lv_point_t * point)", "sline": 255, "body": "{\n    point->x = 0;\n    point->y = 0;\n\n    if(indev == NULL) return;\n\n    if(indev->driver->type == LV_INDEV_TYPE_POINTER || indev->driver->type == LV_INDEV_TYPE_BUTTON) {\n        point->x = indev->proc.types.pointer.vect.x;\n        point->y = indev->proc.types.pointer.vect.y;\n    }\n}"}, "lv_indev_wait_release": {"type": "Function", "def": "void lv_indev_wait_release(lv_indev_t * indev)", "sline": 268, "body": "{\n    if(indev == NULL)return;\n    indev->proc.wait_until_release = 1;\n}"}, "lv_indev_get_obj_act": {"type": "Function", "def": "lv_obj_t * lv_indev_get_obj_act(void)", "sline": 274, "body": "{\n    return indev_obj_act;\n}"}, "lv_indev_get_read_timer": {"type": "Function", "def": "lv_timer_t * lv_indev_get_read_timer(lv_disp_t * indev)", "sline": 279, "body": "{\n    if(!indev) {\n        LV_LOG_WARN(\"lv_indev_get_read_timer: indev was NULL\");\n        return NULL;\n    }\n\n    return indev->refr_timer;\n}"}, "lv_indev_search_obj": {"type": "Function", "def": "lv_obj_t * lv_indev_search_obj(lv_obj_t * obj, lv_point_t * point)", "sline": 289, "body": "{\n    lv_obj_t * found_p = NULL;\n\n    /*If the point is on this object check its children too*/\n    if(lv_obj_hit_test(obj, point)) {\n        int32_t i;\n        uint32_t child_cnt = lv_obj_get_child_cnt(obj);\n        for(i = child_cnt - 1; i >= 0; i--) {\n            lv_obj_t * child = obj->spec_attr->children[i];\n            found_p = lv_indev_search_obj(child, point);\n\n            /*If a child was found then break*/\n            if(found_p != NULL) break;\n        }\n\n        /*If then the children was not ok, and this obj is clickable\n         * and it or its parent is not hidden then save this object*/\n        if(found_p == NULL && lv_obj_has_flag(obj, LV_OBJ_FLAG_CLICKABLE)) {\n            lv_obj_t * hidden_i = obj;\n            while(hidden_i != NULL) {\n                if(lv_obj_has_flag(hidden_i, LV_OBJ_FLAG_HIDDEN) == true) break;\n                hidden_i = lv_obj_get_parent(hidden_i);\n            }\n            /*No parent found with hidden == true*/\n            if(hidden_i == NULL && (lv_obj_get_state(obj) & LV_STATE_DISABLED) == false) found_p = obj;\n        }\n    }\n\n    return found_p;\n}"}, "carbit_updater/lvgl/src/core/lv_indev.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_indev.c"}}, "carbit_updater/lvgl/src/font/lv_font_simsun_16_cjk.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_simsun_16_cjk.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_simsun_16_cjk.c"}}, "carbit_updater/lv_drivers/display/sunxig2d.h": {"carbit_updater/lv_drivers/display/sunxig2d.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/sunxig2d.h"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_28_compressed.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_montserrat_28_compressed.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_28_compressed.c"}}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_draw_blend.c": {"lv_conf_internal": {"type": "Variable", "def": "#include ../../lv_conf_internal.h", "sline": 10}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_draw_blend.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_draw_blend.c"}}, "carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar_header_arrow.h": {"lv_obj": {"type": "Variable", "def": "#include ../../../core/lv_obj.h", "sline": 16}, "lv_calendar_header_arrow_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_calendar_header_arrow_class", "sline": 26}, "lv_calendar_header_arrow_create": {"type": "Function", "def": "lv_obj_t * lv_calendar_header_arrow_create(lv_obj_t * parent)", "sline": 37}, "carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar_header_arrow.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar_header_arrow.h"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_24.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_montserrat_24.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_24.c"}}, "carbit_updater/lvgl/src/extra/widgets/msgbox/lv_msgbox.h": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 16}, "lv_msgbox_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 38, "in_struct": "lv_msgbox_t"}, "lv_msgbox_t.title": {"type": "Variable", "def": "lv_obj_t * title", "sline": 39, "in_struct": "lv_msgbox_t"}, "lv_msgbox_t.close_btn": {"type": "Variable", "def": "lv_obj_t * close_btn", "sline": 40, "in_struct": "lv_msgbox_t"}, "lv_msgbox_t.content": {"type": "Variable", "def": "lv_obj_t * content", "sline": 41, "in_struct": "lv_msgbox_t"}, "lv_msgbox_t.text": {"type": "Variable", "def": "lv_obj_t * text", "sline": 42, "in_struct": "lv_msgbox_t"}, "lv_msgbox_t.btns": {"type": "Variable", "def": "lv_obj_t * btns", "sline": 43, "in_struct": "lv_msgbox_t"}, "lv_msgbox_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    lv_obj_t * title;\n    lv_obj_t * close_btn;\n    lv_obj_t * content;\n    lv_obj_t * text;\n    lv_obj_t * btns;\n} lv_msgbox_t", "sline": 44}, "lv_msgbox_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_msgbox_class", "sline": 46}, "lv_msgbox_content_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_msgbox_content_class", "sline": 47}, "lv_msgbox_backdrop_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_msgbox_backdrop_class", "sline": 48}, "lv_msgbox_create": {"type": "Function", "def": "lv_obj_t * lv_msgbox_create(lv_obj_t * parent, const char * title, const char * txt, const char * btn_txts[],\n                            bool add_close_btn)", "sline": 63}, "lv_msgbox_get_title": {"type": "Function", "def": "lv_obj_t * lv_msgbox_get_title(lv_obj_t * obj)", "sline": 66}, "lv_msgbox_get_close_btn": {"type": "Function", "def": "lv_obj_t * lv_msgbox_get_close_btn(lv_obj_t * obj)", "sline": 68}, "lv_msgbox_get_text": {"type": "Function", "def": "lv_obj_t * lv_msgbox_get_text(lv_obj_t * obj)", "sline": 70}, "lv_msgbox_get_content": {"type": "Function", "def": "lv_obj_t * lv_msgbox_get_content(lv_obj_t * obj)", "sline": 72}, "lv_msgbox_get_btns": {"type": "Function", "def": "lv_obj_t * lv_msgbox_get_btns(lv_obj_t * obj)", "sline": 74}, "lv_msgbox_get_active_btn": {"type": "Function", "def": "uint16_t lv_msgbox_get_active_btn(lv_obj_t * mbox)", "sline": 81}, "lv_msgbox_get_active_btn_text": {"type": "Function", "def": "const char * lv_msgbox_get_active_btn_text(lv_obj_t * mbox)", "sline": 83}, "lv_msgbox_close": {"type": "Function", "def": "void lv_msgbox_close(lv_obj_t * mbox)", "sline": 85}, "lv_msgbox_close_async": {"type": "Function", "def": "void lv_msgbox_close_async(lv_obj_t * mbox)", "sline": 87}, "carbit_updater/lvgl/src/extra/widgets/msgbox/lv_msgbox.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/msgbox/lv_msgbox.h"}}, "carbit_updater/updater.c": {"stdio": {"type": "Variable", "def": "#include stdio.h", "sline": 1}, "string": {"type": "Variable", "def": "#include string.h", "sline": 2}, "unistd": {"type": "Variable", "def": "#include unistd.h", "sline": 3}, "stdlib": {"type": "Variable", "def": "#include stdlib.h", "sline": 4}, "errno": {"type": "Variable", "def": "#include errno.h", "sline": 5}, "ioctl": {"type": "Variable", "def": "#include sys/ioctl.h", "sline": 6}, "mtd-user": {"type": "Variable", "def": "#include mtd/mtd-user.h", "sline": 7}, "fcntl": {"type": "Variable", "def": "#include fcntl.h", "sline": 8}, "ctype": {"type": "Variable", "def": "#include ctype.h", "sline": 9}, "stat": {"type": "Variable", "def": "#include sys/stat.h", "sline": 10}, "reboot": {"type": "Variable", "def": "#include sys/reboot.h", "sline": 11}, "syscall": {"type": "Variable", "def": "#include sys/syscall.h", "sline": 12}, "stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 13}, "pthread": {"type": "Variable", "def": "#include pthread.h", "sline": 14}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 15}, "mman": {"type": "Variable", "def": "#include sys/mman.h", "sline": 16}, "loopbuffer": {"type": "Variable", "def": "#include loopbuffer.h", "sline": 17, "include": ["carbit_updater/loopbuffer.h", null]}, "updateui_handle_thread": {"type": "Function", "def": "extern void *updateui_handle_thread(void *arg)", "sline": 25}, "updateui_handle_step": {"type": "Function", "def": "void updateui_handle_step(int step, int state)", "sline": 26}, "update_from_bin": {"type": "Variable", "def": "static int update_from_bin = 0", "sline": 28}, "_img_name": {"type": "Variable", "def": "static char *_img_name[MAX_IMAGES] = {\n\t\"user-res\"}", "sline": 44}, "_img_index": {"type": "Variable", "def": "static int _img_index[MAX_IMAGES] = {0}", "sline": 47}, "mtd_size": {"type": "Variable", "def": "int mtd_size[MAX_IMAGES] = {0}", "sline": 58}, "total_size": {"type": "Variable", "def": "unsigned int total_size = 0", "sline": 60}, "writed_size": {"type": "Variable", "def": "unsigned int writed_size = 0", "sline": 61}, "update_done": {"type": "Variable", "def": "int update_done = 0", "sline": 62}, "mcu_update_prepare": {"type": "Function", "def": "static int mcu_update_prepare(const unsigned char *data, size_t len)", "sline": 783, "body": "{\n\tALOGD(\"=== enter MCU update preparation ===\\n\");\n#ifndef UPDATE_ALL_IMAGES\n\t// \u5907\u4efdMCU\u5347\u7ea7\u6587\u4ef6\u5230data\u76ee\u5f55\n\tFILE *fp = NULL;\n\tfp = fopen(BACKUP_MCU_BIN, \"wb\");\n\tif (!fp)\n\t{\n\t\tALOGD(\"open:wb mcu.bin failed\\n\");\n\t\treturn -1;\n\t}\n\tint ret = fwrite(data, 1, len, fp);\n\tfclose(fp);\n\tif (ret != len)\n\t{\n\t\tALOGD(\"%s:%s, write to file length %d, but %d\\n\", __FILE__, __func__, len, ret);\n\t\treturn -2;\n\t}\n\tALOGD(\"mcu.bin saved, notify MCU\\n\");\n#endif\n\t// MCU\u4e0d\u4f1a\u91cd\u542f\u4eea\u8868\uff0c\u4f7f\u7528\u5185\u5b58\u6a21\u5f0f\n\ttotal_size = len;\n\twrited_size = 0;\n\tupdateui_handle_step(1, 0);\n\t\n\tmcu_notify();\n\tALOGD(\"=== leave MCU update preparation ===\\n\");\n\treturn 0;\n}"}, "mcu_write_inst_state": {"type": "Function", "def": "void mcu_write_inst_state()", "sline": 591, "body": "{\n\tconst int size_msg = 34;\n\tuint8_t msg[size_msg];\n\tmemset(msg, 0, size_msg);\n\tmsg[0] = 0x55;\n\tmsg[1] = 0xAA;\n\tmsg[2] = size_msg - 3;\n\tmsg[3] = 0x03;\n\tmsg[31] = 0x10; // SOC\u5347\u7ea7\u4e2d\n\tuint16_t crc = Crc16(msg, size_msg - 2);\n\tmsg[size_msg - 2] = (uint8_t)(crc & 0xFF);\n\tmsg[size_msg - 1] = (uint8_t)(crc >> 8);\n\t// mcu_write(msg, size_msg);\n}"}, "mcu_write_ota": {"type": "Function", "def": "void mcu_write_ota()", "sline": 607, "docstring": "// mcu_write(msg, size_msg);", "body": "{\n\tconst int size_msg = 6;\n\tuint8_t msg[size_msg];\n\tmemset(msg, 0, size_msg);\n\tmsg[0] = 0x55;\n\tmsg[1] = 0xAA;\n\tmsg[2] = size_msg - 3;\n\tmsg[3] = 0x1F;\n\tuint16_t crc = Crc16(msg, size_msg - 2);\n\tmsg[size_msg - 2] = (uint8_t)(crc & 0xFF);\n\tmsg[size_msg - 1] = (uint8_t)(crc >> 8);\n\t// mcu_write(msg, size_msg);\n}"}, "mcu_write_ota_piece": {"type": "Function", "def": "void mcu_write_ota_piece(int size)", "sline": 622, "docstring": "// mcu_write(msg, size_msg);", "body": "{\n\tconst int size_msg = 9;\n\tuint8_t msg[size_msg];\n\t_mcu_package_piece = 64;\n\tif (size == 1)\n\t\t_mcu_package_piece = 128;\n\telse if (size == 2)\n\t\t_mcu_package_piece = 192;\n\t_mcu_package_block = (_mcu_package_size - 1) / _mcu_package_piece + 1;\n#ifdef DEBUG_APP\n\tprintf(\"total=%d, block=%d, each=%d\\n\", _mcu_package_size, _mcu_package_block, _mcu_package_piece);\n#endif\n\tmemset(msg, 0, size_msg);\n\tmsg[0] = 0x55;\n\tmsg[1] = 0xAA;\n\tmsg[2] = size_msg - 3;\n\tmsg[3] = 0xA0;\n\tmsg[4] = 0;\n\tmsg[5] = (uint8_t)(_mcu_package_block & 0xFF);\n\tmsg[6] = (uint8_t)(_mcu_package_block >> 8);\n\tuint16_t crc = Crc16(msg, size_msg - 2);\n\tmsg[size_msg - 2] = (uint8_t)(crc & 0xFF);\n\tmsg[size_msg - 1] = (uint8_t)(crc >> 8);\n\t// mcu_write(msg, size_msg);\n}"}, "mcu_write_ota_block": {"type": "Function", "def": "void mcu_write_ota_block(int index)", "sline": 649, "docstring": "// mcu_write(msg, size_msg);", "body": "{\n\t// \u7f16\u53f7\u4ece1\u5f00\u59cb\n\tint size_msg = 7, offset = _mcu_package_piece * (index - 1);\n\tif (index < _mcu_package_block)\n\t\tsize_msg += _mcu_package_piece;\n\telse\n\t\tsize_msg += (_mcu_package_size - 1) % _mcu_package_piece + 1;\n#ifdef DEBUG_APP\n\tprintf(\"block offset=%x\\tsize=%d\\n\", offset, size_msg - 7);\n#endif\n\tuint8_t msg[size_msg];\n\tmemset(msg, 0, size_msg);\n\tmsg[0] = 0x55;\n\tmsg[1] = 0xAA;\n\tmsg[2] = size_msg - 3;\n\tmsg[3] = 0xA1;\n\tmsg[4] = 0;\n\tmemcpy(msg + 5, _mcu_package + offset, size_msg - 7);\n\tuint16_t crc = Crc16(msg, size_msg - 2);\n\tmsg[size_msg - 2] = (uint8_t)(crc & 0xFF);\n\tmsg[size_msg - 1] = (uint8_t)(crc >> 8);\n\t//(msg, size_msg);\n\twrited_size += size_msg - 7;\n}"}, "mcu_write_ota_done": {"type": "Function", "def": "void mcu_write_ota_done()", "sline": 675, "body": "{\n\tconst int size_msg = 7;\n\tuint8_t msg[size_msg];\n\tmemset(msg, 0, size_msg);\n\tmsg[0] = 0x55;\n\tmsg[1] = 0xAA;\n\tmsg[2] = size_msg - 3;\n\tmsg[3] = 0xA2;\n\tmsg[4] = 0;\n\tuint16_t crc = Crc16(msg, size_msg - 2);\n\tmsg[size_msg - 2] = (uint8_t)(crc & 0xFF);\n\tmsg[size_msg - 1] = (uint8_t)(crc >> 8);\n\t// mcu_write(msg, size_msg);\n}"}, "_wait_for_mcu_ack": {"type": "Variable", "def": "static bool _wait_for_mcu_ack", "sline": 75}, "_mcu_package_size": {"type": "Variable", "def": "static int _mcu_package_size = 0", "sline": 76}, "_mcu_package_piece": {"type": "Variable", "def": "static int _mcu_package_size = 0, _mcu_package_piece = 0", "sline": 76}, "_mcu_package_block": {"type": "Variable", "def": "static int _mcu_package_size = 0, _mcu_package_piece = 0, _mcu_package_block = 0", "sline": 76}, "_mcu_package": {"type": "Variable", "def": "static uint8_t *_mcu_package", "sline": 77}, "remount_ro_done": {"type": "Function", "def": "static int remount_ro_done(void)", "sline": 86, "body": "{\n\tFILE *f;\n\tchar mount_dev[256];\n\tchar mount_dir[256];\n\tchar mount_type[256];\n\tchar mount_opts[256];\n\tint mount_freq;\n\tint mount_passno;\n\tint match;\n\tint found_rw_fs = 0;\n\n\tf = fopen(\"/proc/mounts\", \"r\");\n\tif (!f)\n\t{\n\t\t/* If we can't read /proc/mounts, just give up */\n\t\treturn 1;\n\t}\n\n\tdo\n\t{\n\t\tmatch = fscanf(f, \"%255s %255s %255s %255s %d %d\\n\",\n\t\t\t\t\t   mount_dev, mount_dir, mount_type,\n\t\t\t\t\t   mount_opts, &mount_freq, &mount_passno);\n\t\tmount_dev[255] = 0;\n\t\tmount_dir[255] = 0;\n\t\tmount_type[255] = 0;\n\t\tmount_opts[255] = 0;\n\t\tif ((match == 6) && !strncmp(mount_dev, \"/dev/block\", 10) && strstr(mount_opts, \"rw,\"))\n\t\t{\n\t\t\tfound_rw_fs = 1;\n\t\t\tbreak;\n\t\t}\n\t} while (match != EOF);\n\n\tfclose(f);\n\n\treturn !found_rw_fs;\n}"}, "remount_ro": {"type": "Function", "def": "static void remount_ro(void)", "sline": 137, "body": "{\n\tint fd, cnt = 0;\n\n\t/* Trigger the remount of the filesystems as read-only,\n\t * which also marks them clean.\n\t */\n\tfd = open(\"/proc/sysrq-trigger\", O_WRONLY);\n\tif (fd < 0)\n\t{\n\t\treturn;\n\t}\n\twrite(fd, \"u\", 1);\n\tclose(fd);\n\n\t/* Now poll /proc/mounts till it's done */\n\twhile (!remount_ro_done() && (cnt < 50))\n\t{\n\t\tusleep(100000);\n\t\tcnt++;\n\t}\n\n\treturn;\n}"}, "android_reboot": {"type": "Function", "def": "int android_reboot(void)", "sline": 162, "body": "{\n\tint ret = 0;\n\n\t// sync();\n\tremount_ro();\n\t// ret = reboot(RB_AUTOBOOT);\n\n\treturn ret;\n}"}, "writeWithCheck": {"type": "Function", "def": "static int writeWithCheck(int fd_mtd, char *buffer, int iLen, int offset)", "sline": 175, "body": "{\n\tint trycnt = 3;\n\tchar *check_buf = (char *)malloc(iLen);\n\tint ret = -1;\n\n\twhile (trycnt > 0)\n\t{\n\t\tint cnt = 3;\n\t\tint write_size = 0;\n\t\tint check_read_size = 0;\n\n\t\twrite_size = pwrite(fd_mtd, buffer, iLen, offset);\n\t\twhile (cnt > 0 && write_size != iLen)\n\t\t{\n\t\t\twrite_size = pwrite(fd_mtd, buffer, iLen, offset);\n\t\t\tcnt--;\n\t\t\tusleep(1000);\n\t\t}\n\t\t// ALOGD(\"===pwrite_size(%d) cnt(%d)===\\n\", write_size, cnt);\n\t\tfdatasync(fd_mtd);\n\t\t// \u6e05\u7a7a\u865a\u62df\u5185\u5b58\n\t\tsystem(\"echo 3 > /proc/sys/vm/drop_caches\");\n\t\tmemset(check_buf, 0, iLen);\n\t\tcheck_read_size = pread(fd_mtd, check_buf, iLen, offset);\n\t\tcnt = 3;\n\t\twhile (cnt > 0 && check_read_size != iLen)\n\t\t{\n\t\t\tmemset(check_buf, 0, iLen);\n\t\t\tcheck_read_size = pread(fd_mtd, check_buf, iLen, offset);\n\t\t\tcnt--;\n\t\t\tusleep(1000);\n\t\t}\n\t\t// ALOGD(\"===pread_size(%d) cnt(%d)===\\n\", check_read_size, cnt);\n\n\t\tif (memcmp(buffer, check_buf, iLen))\n\t\t{\n\t\t\tALOGD(\"=======check error.while write offset:%d=******trycnt:%d**********\\n\", offset, trycnt);\n\t\t\ttrycnt--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(check_buf);\n\treturn ret;\n}"}, "writeDataToMtdSpi": {"type": "Function", "def": "static int writeDataToMtdSpi(int mtd_num, FILE *src_fp, int iDataLen)", "sline": 225, "body": "{\n\tint ret = 0;\n\tchar temp[256] = {0};\n\tint pos = 0;\n\tint fd_mtd;\n\tFILE *fp_size;\n\tchar *buffer = (char *)malloc(BUF_SIZE_SPI);\n\tint mtd_sizes;\n\tchar size_str[8] = {0};\n\tlong long written_count = 0;\n\tint twrite_size = 0;\n\tint data_size = 0;\n\tint offset = 0;\n\n\tif (mtd_num <= 0)\n\t{\n\t\treturn 0;\n\t}\n\t// open mtd device\n\tsprintf(temp, \"/dev/mtdblock%d\", mtd_num);\n\tfd_mtd = open(temp, O_RDWR | O_SYNC);\n\tif (fd_mtd == ERROR)\n\t{\n\t\tret = ERROR;\n\t\tALOGE(\"open %s failed\\n\", temp);\n\t\tgoto err;\n\t}\n\n\t// get mtd size\n\tmemset(temp, 0, sizeof(temp));\n\tsprintf(temp, \"/sys/class/mtd/mtd%d/size\", mtd_num);\n\tfp_size = fopen(temp, \"r\");\n\tif (fp_size == NULL)\n\t{\n\t\tret = ERROR;\n\t\tALOGE(\"open %s failed\\n\", temp);\n\t\tgoto err;\n\t}\n\tfread(size_str, 1, 8, fp_size);\n\tmtd_sizes = atoi(size_str);\n\tmtd_sizes = mtd_sizes - (mtd_sizes % (64 * 1024)); // 64k align\n\tALOGD(\"=====write mtdblock%d=====\\n\", mtd_num);\n\tALOGD(\"mtd%d size(bytes): %d ,iDataLen:%d\\n\", mtd_num, mtd_sizes, iDataLen);\n\n\t// to update\n\twhile (1)\n\t{\n\t\tint read_size = 0;\n\t\tint write_size = 0;\n\n\t\tmemset(buffer, 0, BUF_SIZE_SPI);\n\t\tif (pos + BUF_SIZE_SPI <= iDataLen)\n\t\t{\n\n\t\t\t//memcpy(buffer, iData + pos, BUF_SIZE_SPI);\n\t\t\tint tmp = fread(buffer, 1, BUF_SIZE_SPI, src_fp);\n\t\t\tif (tmp != BUF_SIZE_SPI)\n\t\t\t{\n\t\t\t\tALOGD(\"read size(%d) < BUF_SIZE_SPI(%d)\\n\", tmp, BUF_SIZE_SPI);\n\t\t\t}\n\t\t}\n\t\telse if (pos < iDataLen)\n\t\t{\n\t\t\t//memcpy(buffer, iData + pos, iDataLen - pos);\n\t\t\tint tmp = fread(buffer, 1, iDataLen - pos, src_fp);\n\t\t\tif(tmp != iDataLen - pos)\n\t\t\t{\n\t\t\t\tALOGD(\"read size(%d) < BUF_SIZE_SPI(%d)\\n\", tmp, iDataLen - pos);\n\t\t\t}\n\t\t}\n\t\tpos += BUF_SIZE_SPI;\n\t\tread_size = BUF_SIZE_SPI;\n#if 0\n\t\twrite_size = write(fd_mtd, buffer, read_size);\n\t\tif (write_size != read_size)\n\t\t{\n\t\t\tALOGD(\"written size(%d) < read size(%d)\\n\", write_size, read_size);\n\t\t}\n#else\n\t\tret = writeWithCheck(fd_mtd, buffer, read_size, offset);\n\t\twrite_size = read_size;\n\t\toffset += read_size;\n\t\tif (ret == -1)\n\t\t\tbreak;\n#endif\n\t\twritten_count += write_size;\n\t\twrited_size += write_size;\n\t\tALOGD(\"===writed_size(%d) total_size(%d)===\\n\", writed_size, total_size);\n\t\tif (written_count >= mtd_sizes)\n\t\t{\n\t\t\tALOGD(\"over write! completed!\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tALOGD(\"====================write end============================\\n\");\n\nerr:\n\tfdatasync(fd_mtd);\n\tfsync(fd_mtd);\n\tfclose(fp_size);\n\tif (buffer)\n\t{\n\t\tfree(buffer);\n\t}\n\tALOGD(\"====== updata is over=============\\n\");\n\treturn ret;\n}"}, "parse_blockinfo": {"type": "Function", "def": "int parse_blockinfo(void)", "sline": 338, "body": "{\n\tFILE *pFile;\n\tint i;\n\tchar *p;\n\tchar mystring[66];\n\tchar str[2][20];\n\tunsigned int val[2];\n\n\tALOGD(\"=== spi nor ... ... ===\\n\");\n\tpFile = fopen(\"/proc/mtd\", \"r\");\n\n\tif (pFile == NULL)\n\t\tALOGD(\"Error opening file\\n\");\n\telse\n\t{\n\t\tmemset(mtd_size, 0, sizeof(mtd_size));\n\n\t\tint mtd_num = 0;\n\n\t\tif (fgets(mystring, 66, pFile) != NULL) // \u8df3\u8fc7\u7b2c\u4e00\u884c\n\t\t{\n\t\t\twhile (fgets(mystring, 66, pFile) != NULL)\n\t\t\t{\n\t\t\t\tALOGD(\"@%s\\n\", mystring);\n\t\t\t\tfor (i = 0; i < MAX_IMAGES; i++)\n\t\t\t\t{\n\t\t\t\t\tsscanf(mystring, \"%s%x%x%s\", str[0], val, val + 1, str[1]);\n\t\t\t\t\t// \u6309\u7167\u5206\u533a\u540d\u5b57\u5339\u914d\u7d22\u5f15\u548c\u5927\u5c0f\n\t\t\t\t\tif (strlen(str[1]) > 1 && strncmp(str[1] + 1, _img_name[i], strlen(_img_name[i])) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t_img_index[i] = mtd_num;\n\t\t\t\t\t\tmtd_size[mtd_num] = (val[0] - val[0] % (64 * 1024)); // 64k align\n\n\t\t\t\t\t\tALOGD(\"[%s %08x %08x %s]==> %d\\n\", str[0], val[0], val[1], str[1], _img_index[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmtd_num++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"}, "mcu_update_reset": {"type": "Function", "def": "static void mcu_update_reset()", "sline": 383, "body": "{\n\t_wait_for_mcu_ack = false;\n\tif (_mcu_package)\n\t\tfree(_mcu_package);\n\n#ifndef UPDATE_ALL_IMAGES\n\tif (access(BACKUP_MCU_BIN, F_OK) == F_OK)\n\t\tunlink(BACKUP_MCU_BIN);\n\tif (access(BACKUP_UPDATER, F_OK) == F_OK)\n\t\tunlink(BACKUP_UPDATER);\n\tif (access(UPDATER_LOCK_FILE, F_OK) == F_OK)\n\t{\n\t\tint delete_lock_file = unlink(UPDATER_LOCK_FILE);\n\t\tALOGD(\"mcu_update_reset delete_lock_file %s==>%d\\n\", UPDATER_LOCK_FILE, delete_lock_file);\n\t}\n#endif\n\tproperty_set(\"carbit.firmware.update.status\", \"all_done\");\n\tsync();\n\tusleep(300 * 1000);\n}"}, "ota_prepare": {"type": "Function", "def": "static void ota_prepare()", "sline": 405, "body": "{\n#ifndef UPDATE_ALL_IMAGES\n\t// \u521b\u5efa\u5347\u7ea7\u9501\u6587\u4ef6\n\tFILE *fp = fopen(UPDATER_LOCK_FILE, \"wb\");\n\tfclose(fp);\n\tALOGD(\"create %s\\n\", UPDATER_LOCK_FILE);\n#endif\n\n\tALOGD(\"stop all service\\n\");\n\tsystem(\"echo 3 > /proc/sys/vm/drop_caches\");\n\tusleep(100 * 1000);\n\tproperty_set(\"carbit.firmware.updating\", \"doing\");\n\n\tproperty_set(\"ctl.stop\", \"instrument\");\n\tproperty_set(\"ctl.stop\", \"new_instrument\");\n\tproperty_set(\"ctl.stop\", \"serialMuxd\");\n\tproperty_set(\"ctl.stop\", \"new_serialMuxd\");\n\tproperty_set(\"ctl.stop\", \"easyconnect\");\n\tproperty_set(\"ctl.stop\", \"new_easyconnect\");\n\n\tproperty_set(\"ctl.stop\", \"networkd\");\n\n\tproperty_set(\"ctl.stop\", \"wifiSupplicant\");\n\tproperty_set(\"carbit.firmware.update.progress\", \"0\");\n\tusleep(500 * 1000);\n\t// \u6e05\u7a7a\u865a\u62df\u5185\u5b58\n\tsync();\n\tusleep(100 * 1000);\n\tsystem(\"echo 3 > /proc/sys/vm/drop_caches\");\n\tusleep(100 * 1000);\n\n\t// mcu_task_init();\n\t//  \u53d1\u4e86\u624d\u4f1a\u901a\u8baf\u6b63\u5e38\n\t// mcu_write_inst_state();\n\tupdate_done = 0;\n}"}, "ota_update": {"type": "Function", "def": "static int ota_update(void)", "sline": 443, "body": "{\n\tFILE *fp = NULL;\n\tint fileLen = 0;\n\tint ret;\n\tchar buf[4];\n\tint i, pos = 0;\n\tint datalen = 0;\n\tif (update_from_bin == 0)\n\t{\n\t\tfp = fopen(RAM0_MOUNT_TARGET \"/update.img\", \"r\");\n\t\tif (!fp)\n\t\t\treturn 0;\n\n\t\tfseek(fp, 0, SEEK_END);\n\t\tfileLen = ftell(fp);\n\t\tfseek(fp, 0, SEEK_SET);\n\t}\n\telse\n\t{\n\t\tfp = fopen(RAM0_MOUNT_TARGET \"/update.bin\", \"r\");\n\t\tif (!fp)\n\t\t\treturn 0;\n\t\t//bin\u6587\u4ef6\u7684image \u4ece 64\u5b57\u8282\u5f00\u59cb\n\t\tint pos = 64;\n\t\t\n\t\tfseek(fp, pos, SEEK_SET);\n\t\tfread(buf, 1, 4, fp);\n\t\tfileLen = ((buf[0] << 24) & 0xFF000000) +\n\t\t\t\t  ((buf[1] << 16) & 0x00FF0000) +\n\t\t\t\t  ((buf[2] << 8) & 0x0000FF00) +\n\t\t\t\t  ((buf[3]) & 0x000000FF);\n\n\t\tfseek(fp, pos+4, SEEK_SET);\n\t}\n\tALOGD(\"%s:%s, fileLen is %d\\n\", __FILE__, __func__, fileLen);\n\t\n\tif (fileLen <= 0)\n\t{\n\t\treturn 0;\n\t}\n\t// \u6e05\u7a7a\u865a\u62df\u5185\u5b58\n\tsystem(\"echo 3 > /proc/sys/vm/drop_caches\");\n\tusleep(100 * 1000);\n\t\n\tpos = 0;\n\tfor (i = 0; i < MAX_IMAGES; i++)\n\t{\n\t\tfread(buf, 1, 4, fp);\n\t\tdatalen = ((buf[pos] << 24) & 0xFF000000) +\n\t\t\t\t  ((buf[pos + 1] << 16) & 0x00FF0000) +\n\t\t\t\t  ((buf[pos + 2] << 8) & 0x0000FF00) +\n\t\t\t\t  ((buf[pos + 3]) & 0x000000FF);\n\n\t\tif (datalen <= 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tpos += 4;\n\n\t\tif (writeDataToMtdSpi(_img_index[i], fp, datalen) != 0)\n\t\t{\n\t\t\tproperty_set(\"carbit.firmware.update.status\", \"app_error\");\n\t\t\tgoto err;\n\t\t}\n\t\tpos += datalen;\n\t}\n\n\tALOGD(\"=== enter UPDATE_RESET_SPI over... ... === %d --> %d\\n\",pos,fileLen);\n\tproperty_set(\"carbit.firmware.update.status\", \"app_done\");\n\t// \u7ee7\u7eed\u5904\u7406MCU\u7684\u53ef\u80fd\u6027\n\tif (pos < fileLen)\n\t{\n\t\tfread(buf, 1, 4, fp);\n\t\tdatalen = ((buf[pos] << 24) & 0xFF000000) +\n\t\t\t\t  ((buf[pos + 1] << 16) & 0x00FF0000) +\n\t\t\t\t  ((buf[pos + 2] << 8) & 0x0000FF00) +\n\t\t\t\t  ((buf[pos + 3]) & 0x000000FF);\n\t\tpos += 4;\n\t\tif (datalen >> 0x1E == 1)\n\t\t{\n\t\t\t_mcu_package_size=datalen & 0x3FFFFFFF;\n\t\t\t_mcu_package = (uint8_t *)malloc(_mcu_package_size);\n\t\t\tif(_mcu_package)\n\t\t\t{\n\t\t\t\tfread(_mcu_package, 1, _mcu_package, fp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tALOGD(\"malloc mcu failed\\n\");\t\n\t\t\t\treturn -3;\t\n\t\t\t}\n\t\t\tmcu_update_prepare(_mcu_package, _mcu_package_size);\n\t\t}\n\t}\n\telse\n\t{\n#ifndef UPDATE_ALL_IMAGES\n\t\tif (access(UPDATER_LOCK_FILE, F_OK) == F_OK)\n\t\t{\n\t\t\tint delete_lock_file = unlink(UPDATER_LOCK_FILE);\n\t\t\tALOGD(\"delete_lock_file %s==>%d\\n\", UPDATER_LOCK_FILE, delete_lock_file);\n\t\t}\n\t\tsync();\n#endif\n\t\tusleep(1000 * 1000);\n\t\tproperty_set(\"carbit.firmware.update.status\", \"all_done\");\n\t}\n\tALOGD(\"update succeed!\\n\");\t\n\tfclose(fp);\n\treturn 0;\n\nerr:\n\tfclose(fp);\n\treturn ret;\n}"}, "crc16_table": {"type": "Variable", "def": "static const unsigned short crc16_table[256] =\n\t{\n\t\t0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7, 0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,\n\t\t0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6, 0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,\n\t\t0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485, 0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,\n\t\t0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4, 0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,\n\t\t0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823, 0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,\n\t\t0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12, 0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,\n\t\t0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41, 0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,\n\t\t0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70, 0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,\n\t\t0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F, 0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,\n\t\t0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E, 0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,\n\t\t0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D, 0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,\n\t\t0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C, 0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,\n\t\t0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB, 0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,\n\t\t0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A, 0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,\n\t\t0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9, 0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,\n\t\t0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8, 0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0}", "sline": 560}, "Crc16": {"type": "Function", "def": "static unsigned short Crc16(const unsigned char *data, int len)", "sline": 578, "body": "{\n\tunsigned short crc = 0;\n\n\twhile (len > 0)\n\t{\n\t\tcrc = ((crc & 0xff) << 8) ^ crc16_table[(((crc & 0xFF00) >> 8) ^ *data) & 0xff];\n\t\tlen--;\n\t\tdata++;\n\t}\n\treturn crc;\n}"}, "mcu_ota_thread": {"type": "Function", "def": "void *mcu_ota_thread(void *p)", "sline": 691, "docstring": "// mcu_write(msg, size_msg);", "body": "{\n\tint usleep_time = 500 * 1000;\n\tint retry = 20;\n\tint i;\n\tfor (i = 0; i < retry; i++)\n\t{\n\t\tmcu_write_inst_state();\n\t\tusleep(usleep_time);\n\t}\n\tmcu_write_ota_done();\n\treturn NULL;\n}"}, "mcu_parse_data": {"type": "Function", "def": "void mcu_parse_data(uint8_t *data)", "sline": 705, "body": "{\n\tuint8_t cmd = data[3];\n#ifdef DEBUG_APP\n\tprintf(\"mcu_parse_data:%02x\\n\", cmd);\n#endif\n\tif (cmd == 0x9F)\n\t{\n\t\tALOGD(\"mcu ack=%d\\n\", data[4]);\n\t}\n\telse if (cmd == 0x20)\n\t{\n\t\tprintf(\"mcu query piece=%d\\n\", data[4]);\n\t\tmcu_write_ota_piece(data[4]);\n\t}\n\telse if (cmd == 0x21)\n\t{\n\t\tuint16_t index = data[4] | (data[5] << 8);\n\t\tprintf(\"mcu query data=%d\\n\", index);\n\t\tmcu_write_ota_block(index + 1);\n\t}\n\telse if (cmd == 0x22)\n\t{\n\t\tALOGD(\"mcu ota done=%d\\n\", data[4]);\n\t\tif (data[4] == 1)\n\t\t{\n\t\t\tmcu_update_reset();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tproperty_set(\"carbit.firmware.update.status\", \"mcu_error\");\n\t\t\tupdateui_handle_step(1, -1);\n\t\t}\n\n\t\t// start new thread, to delay 10s reboot\n\t\tpthread_t thread_id;\n\t\tpthread_create(&thread_id, NULL, mcu_ota_thread, NULL);\n\t\tpthread_detach(thread_id);\n\t}\n}"}, "mcu_parser": {"type": "Function", "def": "void mcu_parser(loopbuffer_t *buffer)", "sline": 746, "body": "{\n\twhile (loopbuffer_getSize(buffer) >= 7)\n\t{\n\t\tuint8_t header0 = loopbuffer_at(buffer, 0),\n\t\t\t\theader1 = loopbuffer_at(buffer, 1);\n\t\tif (header0 != 0x55 || header1 != 0xAA)\n\t\t{\n\t\t\tloopbuffer_Pop(buffer, 1);\n\t\t\tcontinue;\n\t\t}\n\t\tuint8_t len = loopbuffer_at(buffer, 2) + 3;\n\t\tint32_t size = loopbuffer_getSize(buffer);\n\t\tif (size < len)\n\t\t\tbreak;\n\t\tuint8_t data[len];\n\t\tloopbuffer_getData(buffer, data, len);\n\t\tuint16_t crc = data[len - 1] << 8 | data[len - 2];\n\t\tif (Crc16(data, len - 2) == crc)\n\t\t{\n\t\t\tmcu_parse_data(data);\n\t\t}\n\t}\n}"}, "mcu_notify": {"type": "Function", "def": "static int mcu_notify()", "sline": 771, "body": "{\n\tusleep(100 * 1000);\n\tmcu_write_ota();\n\t_wait_for_mcu_ack = true;\n\twhile (_wait_for_mcu_ack)\n\t{\n\t\tusleep(100 * 1000);\n\t}\n\treturn 0;\n}"}, "mcu_update_backup": {"type": "Function", "def": "static int mcu_update_backup()", "sline": 814, "body": "{\n\tALOGD(\"=== enter MCU backup ===\\n\");\n\tFILE *fp = fopen(BACKUP_MCU_BIN, \"rb\");\n\tfseek(fp, 0, SEEK_END);\n\t_mcu_package_size = ftell(fp);\n\t_mcu_package = (uint8_t *)malloc(_mcu_package_size);\n\ttotal_size = _mcu_package_size;\n\twrited_size = 0;\n\tfseek(fp, 0, SEEK_SET);\n\tfread(_mcu_package, 1, _mcu_package_size, fp);\n\tfclose(fp);\n\tmcu_notify();\n\tALOGD(\"=== leave MCU backup ===\\n\");\n\treturn 0;\n}"}, "getProcess": {"type": "Function", "def": "int getProcess()", "sline": 831, "body": "{\n\tif (total_size)\n\t{\n\t\tint progress = (int)((writed_size * 100.0) / total_size);\n\t\t// ALOGD(\"===process (%d)===\\n\", progress);\n\t\treturn progress;\n\t}\n\telse\n\t\treturn 0;\n}"}, "ifUpdateDone": {"type": "Function", "def": "int ifUpdateDone()", "sline": 843, "body": "{\n\treturn update_done;\n}"}, "main": {"type": "Function", "def": "int main(int argc, char **argv)", "sline": 848, "body": "{\n\tpthread_t updateui_tid;\n\tint i;\n\n\t// mcu_task_init();\n\t// // \u53d1\u4e86\u624d\u4f1a\u901a\u8baf\u6b63\u5e38\n\t// mcu_write_inst_state();\n\t// update_done = 0;\n\n\tif (access(BACKUP_MCU_BIN, F_OK) == F_OK)\n\t{\n\t\tALOGD(\"update mcu from \" BACKUP_MCU_BIN);\n\t\tota_prepare();\n\t\tupdateui_handle_step(1, 0);\n\t\tpthread_create(&updateui_tid, NULL, updateui_handle_thread, NULL);\n\t\tmcu_update_backup();\n\t}\n\telse\n\t{\n// #ifndef UPDATE_ALL_IMAGES\n// \t\t// \u5907\u4efd\u5230data\u4e0b\n// \t\tsystem(\"cp \" RAM0_MOUNT_TARGET \"/carbit_updater \" BACKUP_UPDATER);\n// #endif\n\t\tif (access(RAM0_MOUNT_TARGET \"/update.img\", F_OK) != 0)\n\t\t{\n\t\t\tif (access(RAM0_MOUNT_TARGET \"/update.bin\", F_OK) == 0)\n\t\t\t{\n\t\t\t\tupdate_from_bin = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tALOGD(\"the update firmware is not exist!!\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tota_prepare();\n\n\t\tparse_blockinfo();\n\t\ttotal_size = 0;\n\t\tfor (i = 0; i < MAX_IMAGES; i++)\n\t\t\ttotal_size += mtd_size[_img_index[i]];\n\t\twrited_size = 0;\n\t\tupdateui_handle_step(0, 0);\n\t\tpthread_create(&updateui_tid, NULL, updateui_handle_thread, NULL);\n\n\t\tota_update();\n\t}\n\n\tupdate_done = 1;\n\tandroid_reboot();\n\twhile (1)\n\t{\n\t\tusleep(1000 * 1000 * 10);\n\t};\n\treturn 0;\n}"}, "carbit_updater/updater.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/updater.c"}}, "carbit_updater/lvgl/tests/src/test_cases/test_checkbox.c": {"carbit_updater/lvgl/tests/src/test_cases/test_checkbox.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/tests/src/test_cases/test_checkbox.c"}}, "carbit_updater/lvgl/rt-thread/lv_rt_thread_port.c": {"carbit_updater/lvgl/rt-thread/lv_rt_thread_port.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/rt-thread/lv_rt_thread_port.c"}}, "carbit_updater/lvgl/src/extra/widgets/msgbox/lv_msgbox.c": {"lv_msgbox": {"type": "Variable", "def": "#include lv_msgbox.h", "sline": 9, "include": ["carbit_updater/lvgl/src/extra/widgets/msgbox/lv_msgbox.h", null]}, "lv_assert": {"type": "Variable", "def": "#include ../../../misc/lv_assert.h", "sline": 12}, "msgbox_close_click_event_cb": {"type": "Function", "def": "static void msgbox_close_click_event_cb(lv_event_t * e)", "sline": 202, "body": "{\n    lv_obj_t * btn = lv_event_get_target(e);\n    lv_obj_t * mbox = lv_obj_get_parent(btn);\n    lv_msgbox_close(mbox);\n}"}, "lv_msgbox_class": {"type": "Variable", "def": "const lv_obj_class_t lv_msgbox_class = {\n        .base_class = &lv_obj_class,\n        .width_def = LV_DPI_DEF * 2,\n        .height_def = LV_SIZE_CONTENT,\n        .instance_size = sizeof(lv_msgbox_t)\n}", "sline": 32}, "lv_msgbox_content_class": {"type": "Variable", "def": "const lv_obj_class_t lv_msgbox_content_class = {\n        .base_class = &lv_obj_class,\n        .width_def = LV_PCT(100),\n        .height_def = LV_SIZE_CONTENT,\n        .instance_size = sizeof(lv_obj_t)\n}", "sline": 39}, "lv_msgbox_backdrop_class": {"type": "Variable", "def": "const lv_obj_class_t lv_msgbox_backdrop_class = {\n        .base_class = &lv_obj_class,\n        .width_def = LV_PCT(100),\n        .height_def = LV_PCT(100),\n        .instance_size = sizeof(lv_obj_t)\n}", "sline": 46}, "lv_msgbox_create": {"type": "Function", "def": "lv_obj_t * lv_msgbox_create(lv_obj_t * parent, const char * title, const char * txt, const char * btn_txts[],\n                            bool add_close_btn)", "sline": 61, "body": "{\n    LV_LOG_INFO(\"begin\");\n    bool auto_parent = false;\n    if(parent == NULL) {\n        auto_parent = true;\n        parent = lv_obj_class_create_obj(&lv_msgbox_backdrop_class, lv_layer_top());\n        LV_ASSERT_MALLOC(parent);\n        lv_obj_class_init_obj(parent);\n        lv_obj_clear_flag(parent, LV_OBJ_FLAG_IGNORE_LAYOUT);\n        lv_obj_set_size(parent, LV_PCT(100), LV_PCT(100));\n    }\n\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_msgbox_class, parent);\n    LV_ASSERT_MALLOC(obj);\n    lv_obj_class_init_obj(obj);\n    if(obj == NULL) return NULL;\n    lv_msgbox_t * mbox = (lv_msgbox_t *)obj;\n\n    if(auto_parent) lv_obj_add_flag(obj, LV_MSGBOX_FLAG_AUTO_PARENT);\n\n    lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_ROW_WRAP);\n\n    bool has_title = title && strlen(title) > 0;\n\n    /*When a close button is required, we need the empty label as spacer to push the button to the right*/\n    if (add_close_btn || has_title) {\n        mbox->title = lv_label_create(obj);\n        lv_label_set_text(mbox->title, has_title ? title : \"\");\n        lv_label_set_long_mode(mbox->title, LV_LABEL_LONG_SCROLL_CIRCULAR);\n        if(add_close_btn) lv_obj_set_flex_grow(mbox->title, 1);\n        else lv_obj_set_width(mbox->title, LV_PCT(100));\n    }\n\n    if(add_close_btn) {\n        mbox->close_btn = lv_btn_create(obj);\n        lv_obj_set_ext_click_area(mbox->close_btn, LV_DPX(10));\n        lv_obj_add_event_cb(mbox->close_btn, msgbox_close_click_event_cb, LV_EVENT_CLICKED, NULL);\n        lv_obj_t * label = lv_label_create(mbox->close_btn);\n        lv_label_set_text(label, LV_SYMBOL_CLOSE);\n        const lv_font_t * font = lv_obj_get_style_text_font(mbox->close_btn, LV_PART_MAIN);\n        lv_coord_t close_btn_size = lv_font_get_line_height(font) + LV_DPX(10);\n        lv_obj_set_size(mbox->close_btn, close_btn_size, close_btn_size);\n        lv_obj_align(label, LV_ALIGN_CENTER, 0, 0);\n    }\n\n    mbox->content = lv_obj_class_create_obj(&lv_msgbox_content_class, obj);\n\n    bool has_txt = txt && strlen(txt) > 0;\n    if (has_txt) {\n        mbox->text = lv_label_create(mbox->content);\n        lv_label_set_text(mbox->text, txt);\n        lv_label_set_long_mode(mbox->text, LV_LABEL_LONG_WRAP);\n        lv_obj_set_width(mbox->text, lv_pct(100));\n    }\n\n    if(btn_txts) {\n        mbox->btns = lv_btnmatrix_create(obj);\n        lv_btnmatrix_set_map(mbox->btns, btn_txts);\n        lv_btnmatrix_set_btn_ctrl_all(mbox->btns, LV_BTNMATRIX_CTRL_CLICK_TRIG | LV_BTNMATRIX_CTRL_NO_REPEAT);\n\n        uint32_t btn_cnt = 0;\n        while(btn_txts[btn_cnt] && btn_txts[btn_cnt][0] != '\\0') {\n            btn_cnt++;\n        }\n\n        const lv_font_t * font = lv_obj_get_style_text_font(mbox->btns, LV_PART_ITEMS);\n        lv_coord_t btn_h = lv_font_get_line_height(font) + LV_DPI_DEF / 10;\n        lv_obj_set_size(mbox->btns, btn_cnt * (2 * LV_DPI_DEF / 3), btn_h);\n        lv_obj_set_style_max_width(mbox->btns, lv_pct(100), 0);\n        lv_obj_add_flag(mbox->btns, LV_OBJ_FLAG_EVENT_BUBBLE);    /*To see the event directly on the message box*/\n    }\n\n    return obj;\n}"}, "lv_msgbox_get_title": {"type": "Function", "def": "lv_obj_t * lv_msgbox_get_title(lv_obj_t * obj)", "sline": 139, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_msgbox_t * mbox = (lv_msgbox_t *)obj;\n    return mbox->title;\n}"}, "lv_msgbox_get_close_btn": {"type": "Function", "def": "lv_obj_t * lv_msgbox_get_close_btn(lv_obj_t * obj)", "sline": 146, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_msgbox_t * mbox = (lv_msgbox_t *)obj;\n    return mbox->close_btn;\n}"}, "lv_msgbox_get_text": {"type": "Function", "def": "lv_obj_t * lv_msgbox_get_text(lv_obj_t * obj)", "sline": 153, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_msgbox_t * mbox = (lv_msgbox_t *)obj;\n    return mbox->text;\n}"}, "lv_msgbox_get_content": {"type": "Function", "def": "lv_obj_t * lv_msgbox_get_content(lv_obj_t * obj)", "sline": 160, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_msgbox_t * mbox = (lv_msgbox_t *)obj;\n    return mbox->content;\n}"}, "lv_msgbox_get_btns": {"type": "Function", "def": "lv_obj_t * lv_msgbox_get_btns(lv_obj_t * obj)", "sline": 167, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_msgbox_t * mbox = (lv_msgbox_t *)obj;\n    return mbox->btns;\n}"}, "lv_msgbox_get_active_btn": {"type": "Function", "def": "uint16_t lv_msgbox_get_active_btn(lv_obj_t * mbox)", "sline": 174, "body": "{\n    lv_obj_t * btnm = lv_msgbox_get_btns(mbox);\n    return lv_btnmatrix_get_selected_btn(btnm);\n}"}, "lv_msgbox_get_active_btn_text": {"type": "Function", "def": "const char * lv_msgbox_get_active_btn_text(lv_obj_t * mbox)", "sline": 180, "body": "{\n    lv_obj_t * btnm = lv_msgbox_get_btns(mbox);\n    return lv_btnmatrix_get_btn_text(btnm, lv_btnmatrix_get_selected_btn(btnm));\n}"}, "lv_msgbox_close": {"type": "Function", "def": "void lv_msgbox_close(lv_obj_t * mbox)", "sline": 186, "body": "{\n    if(lv_obj_has_flag(mbox, LV_MSGBOX_FLAG_AUTO_PARENT)) lv_obj_del(lv_obj_get_parent(mbox));\n    else lv_obj_del(mbox);\n}"}, "lv_msgbox_close_async": {"type": "Function", "def": "void lv_msgbox_close_async(lv_obj_t * dialog)", "sline": 192, "body": "{\n    if(lv_obj_has_flag(dialog, LV_MSGBOX_FLAG_AUTO_PARENT)) lv_obj_del_async(lv_obj_get_parent(dialog));\n    else lv_obj_del_async(dialog);\n}"}, "carbit_updater/lvgl/src/extra/widgets/msgbox/lv_msgbox.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/msgbox/lv_msgbox.c"}}, "carbit_updater/lvgl/src/extra/widgets/tabview/lv_tabview.c": {"lv_tabview": {"type": "Variable", "def": "#include lv_tabview.h", "sline": 9, "include": ["carbit_updater/lvgl/src/extra/widgets/tabview/lv_tabview.h", null]}, "lv_assert": {"type": "Variable", "def": "#include ../../../misc/lv_assert.h", "sline": 12}, "lv_tabview_constructor": {"type": "Function", "def": "static void lv_tabview_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 174, "body": "{\n    LV_UNUSED(class_p);\n    lv_tabview_t * tabview = (lv_tabview_t *)obj;\n\n    tabview->tab_pos = tabpos_create;\n\n    switch(tabview->tab_pos) {\n        case LV_DIR_TOP:\n            lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_COLUMN);\n            break;\n        case LV_DIR_BOTTOM:\n            lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_COLUMN_REVERSE);\n            break;\n        case LV_DIR_LEFT:\n            lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_ROW);\n            break;\n        case LV_DIR_RIGHT:\n            lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_ROW_REVERSE);\n            break;\n    }\n\n    lv_obj_set_size(obj, LV_PCT(100), LV_PCT(100));\n\n    lv_obj_t * btnm;\n    lv_obj_t * cont;\n\n    btnm = lv_btnmatrix_create(obj);\n    cont = lv_obj_create(obj);\n\n    lv_btnmatrix_set_one_checked(btnm, true);\n    tabview->map = lv_mem_alloc(sizeof(const char *));\n    tabview->map[0] = \"\";\n    lv_btnmatrix_set_map(btnm, (const char **)tabview->map);\n    lv_obj_add_event_cb(btnm, btns_value_changed_event_cb, LV_EVENT_VALUE_CHANGED, NULL);\n    lv_obj_add_flag(btnm, LV_OBJ_FLAG_EVENT_BUBBLE);\n\n    lv_obj_add_event_cb(cont, cont_scroll_end_event_cb, LV_EVENT_ALL, NULL);\n    lv_obj_set_scrollbar_mode(cont, LV_SCROLLBAR_MODE_OFF);\n\n    switch(tabview->tab_pos) {\n        case LV_DIR_TOP:\n        case LV_DIR_BOTTOM:\n            lv_obj_set_size(btnm, LV_PCT(100), tabsize_create);\n            lv_obj_set_width(cont, LV_PCT(100));\n            lv_obj_set_flex_grow(cont, 1);\n            break;\n        case LV_DIR_LEFT:\n        case LV_DIR_RIGHT:\n            lv_obj_set_size(btnm, tabsize_create, LV_PCT(100));\n            lv_obj_set_height(cont, LV_PCT(100));\n            lv_obj_set_flex_grow(cont, 1);\n            break;\n    }\n\n    lv_group_t * g = lv_group_get_default();\n    if(g) lv_group_add_obj(g, btnm);\n\n    lv_obj_set_flex_flow(cont, LV_FLEX_FLOW_ROW);\n    lv_obj_set_scroll_snap_x(cont, LV_SCROLL_SNAP_CENTER);\n    lv_obj_add_flag(cont, LV_OBJ_FLAG_SCROLL_ONE);\n    lv_obj_clear_flag(cont, LV_OBJ_FLAG_SCROLL_ON_FOCUS);\n}"}, "lv_tabview_destructor": {"type": "Function", "def": "static void lv_tabview_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 238, "body": "{\n    LV_UNUSED(class_p);\n    lv_tabview_t * tabview = (lv_tabview_t *)obj;\n\n    uint32_t i;\n    if(tabview->tab_pos & LV_DIR_VER) {\n        for(i = 0; i < tabview->tab_cnt; i++) {\n            lv_mem_free(tabview->map[i]);\n            tabview->map[i] = NULL;\n        }\n    }\n    if(tabview->tab_pos & LV_DIR_HOR) {\n        for(i = 0; i < tabview->tab_cnt; i++) {\n            lv_mem_free(tabview->map[i * 2]);\n            tabview->map[i * 2] = NULL;\n        }\n    }\n\n\n    lv_mem_free(tabview->map);\n    tabview->map = NULL;\n}"}, "lv_tabview_event": {"type": "Function", "def": "static void lv_tabview_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 262, "body": "{\n    LV_UNUSED(class_p);\n    lv_res_t res = lv_obj_event_base(&lv_tabview_class, e);\n    if(res != LV_RES_OK) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * target = lv_event_get_target(e);\n\n    if(code == LV_EVENT_SIZE_CHANGED) {\n        lv_tabview_set_act(target, lv_tabview_get_tab_act(target), LV_ANIM_OFF);\n    }\n}"}, "btns_value_changed_event_cb": {"type": "Function", "def": "static void btns_value_changed_event_cb(lv_event_t * e)", "sline": 277, "body": "{\n    lv_obj_t * btns = lv_event_get_target(e);\n\n    lv_obj_t * tv = lv_obj_get_parent(btns);\n    uint32_t id = lv_btnmatrix_get_selected_btn(btns);\n    lv_tabview_set_act(tv, id, LV_ANIM_ON);\n}"}, "cont_scroll_end_event_cb": {"type": "Function", "def": "static void cont_scroll_end_event_cb(lv_event_t * e)", "sline": 286, "body": "{\n    lv_obj_t * cont = lv_event_get_target(e);\n    lv_event_code_t code = lv_event_get_code(e);\n\n    lv_obj_t * tv = lv_obj_get_parent(cont);\n    if(code == LV_EVENT_LAYOUT_CHANGED) {\n        lv_tabview_set_act(tv, lv_tabview_get_tab_act(tv), LV_ANIM_OFF);\n    }\n    else if(code == LV_EVENT_SCROLL_END) {\n        lv_point_t p;\n        lv_obj_get_scroll_end(cont, &p);\n\n        lv_coord_t w = lv_obj_get_content_width(cont);\n        lv_coord_t t;\n\n        if(lv_obj_get_style_base_dir(tv, LV_PART_MAIN) == LV_BASE_DIR_RTL)  t = -(p.x - w / 2) / w;\n        else t = (p.x + w / 2) / w;\n\n        if(t < 0) t = 0;\n        bool new_tab = false;\n        if(t != lv_tabview_get_tab_act(tv)) new_tab = true;\n        lv_tabview_set_act(tv, t, LV_ANIM_ON);\n\n        if(new_tab) lv_event_send(tv, LV_EVENT_VALUE_CHANGED, NULL);\n    }\n}"}, "lv_tabview_class": {"type": "Variable", "def": "const lv_obj_class_t lv_tabview_class = {\n    .constructor_cb = lv_tabview_constructor,\n    .destructor_cb = lv_tabview_destructor,\n    .event_cb = lv_tabview_event,\n    .width_def = LV_PCT(100),\n    .height_def = LV_PCT(100),\n    .base_class = &lv_obj_class,\n    .instance_size = sizeof(lv_tabview_t)\n}", "sline": 35}, "tabpos_create": {"type": "Variable", "def": "static lv_dir_t tabpos_create", "sline": 45}, "tabsize_create": {"type": "Variable", "def": "static lv_coord_t tabsize_create", "sline": 46}, "lv_tabview_create": {"type": "Function", "def": "lv_obj_t * lv_tabview_create(lv_obj_t * parent, lv_dir_t tab_pos, lv_coord_t tab_size)", "sline": 56, "body": "{\n    LV_LOG_INFO(\"begin\");\n    tabpos_create = tab_pos;\n    tabsize_create = tab_size;\n\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_tabview_class, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_tabview_add_tab": {"type": "Function", "def": "lv_obj_t * lv_tabview_add_tab(lv_obj_t * obj, const char * name)", "sline": 67, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_tabview_t * tabview = (lv_tabview_t *)obj;\n    lv_obj_t * cont = lv_tabview_get_content(obj);\n\n    lv_obj_t * page = lv_obj_create(cont);\n    lv_obj_set_size(page, LV_PCT(100), LV_PCT(100));\n    lv_obj_clear_flag(page, LV_OBJ_FLAG_CLICK_FOCUSABLE);\n    uint32_t tab_id = lv_obj_get_child_cnt(cont);\n\n    lv_obj_t * btns = lv_tabview_get_tab_btns(obj);\n\n    char ** old_map = tabview->map;\n    char ** new_map;\n\n    /*top or bottom dir*/\n    if(tabview->tab_pos & LV_DIR_VER) {\n        new_map = lv_mem_alloc((tab_id + 1) * sizeof(const char *));\n        lv_memcpy_small(new_map, old_map, sizeof(const char *) * (tab_id - 1));\n        new_map[tab_id - 1] = lv_mem_alloc(strlen(name) + 1);\n        strcpy((char *)new_map[tab_id - 1], name);\n        new_map[tab_id] = \"\";\n    }\n    /*left or right dir*/\n    else {\n        new_map = lv_mem_alloc((tab_id * 2) * sizeof(const char *));\n        lv_memcpy_small(new_map, old_map, sizeof(const char *) * (tab_id - 1) * 2);\n        if(tabview->tab_cnt == 0) {\n            new_map[0] = lv_mem_alloc(strlen(name) + 1);\n            strcpy((char *)new_map[0], name);\n            new_map[1] = \"\";\n        }\n        else {\n            new_map[tab_id * 2 - 3] = \"\\n\";\n            new_map[tab_id * 2 - 2] = lv_mem_alloc(strlen(name) + 1);\n            new_map[tab_id * 2 - 1] = \"\";\n            strcpy((char *)new_map[(tab_id * 2) - 2], name);\n        }\n    }\n    tabview->map = new_map;\n    lv_btnmatrix_set_map(btns, (const char **)new_map);\n    lv_mem_free(old_map);\n\n    lv_btnmatrix_set_btn_ctrl_all(btns, LV_BTNMATRIX_CTRL_CHECKABLE | LV_BTNMATRIX_CTRL_CLICK_TRIG |\n                                  LV_BTNMATRIX_CTRL_NO_REPEAT);\n\n    tabview->tab_cnt++;\n    if(tabview->tab_cnt == 1) {\n        lv_tabview_set_act(obj, 0, LV_ANIM_OFF);\n    }\n\n    lv_btnmatrix_set_btn_ctrl(btns, tabview->tab_cur, LV_BTNMATRIX_CTRL_CHECKED);\n\n    return page;\n}"}, "lv_tabview_set_act": {"type": "Function", "def": "void lv_tabview_set_act(lv_obj_t * obj, uint32_t id, lv_anim_enable_t anim_en)", "sline": 124, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_tabview_t * tabview = (lv_tabview_t *)obj;\n\n    if(id >= tabview->tab_cnt) {\n        id = tabview->tab_cnt - 1;\n    }\n\n    /*To be sure lv_obj_get_content_width will return valid value*/\n    lv_obj_update_layout(obj);\n\n    lv_obj_t * cont = lv_tabview_get_content(obj);\n    if(cont == NULL) return;\n    lv_coord_t gap = lv_obj_get_style_pad_column(cont, LV_PART_MAIN);\n    lv_coord_t w = lv_obj_get_content_width(cont);\n    if(lv_obj_get_style_base_dir(obj, LV_PART_MAIN) != LV_BASE_DIR_RTL) {\n        lv_obj_scroll_to_x(cont, id * (gap + w), anim_en);\n    }\n    else {\n        int32_t id_rtl = -(int32_t)id;\n        lv_obj_scroll_to_x(cont, (gap + w) * id_rtl, anim_en);\n    }\n\n    lv_obj_t * btns = lv_tabview_get_tab_btns(obj);\n    lv_btnmatrix_set_btn_ctrl(btns, id, LV_BTNMATRIX_CTRL_CHECKED);\n    tabview->tab_cur = id;\n}"}, "lv_tabview_get_tab_act": {"type": "Function", "def": "uint16_t lv_tabview_get_tab_act(lv_obj_t * obj)", "sline": 153, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_tabview_t * tabview = (lv_tabview_t *)obj;\n    return tabview->tab_cur;\n}"}, "lv_tabview_get_content": {"type": "Function", "def": "lv_obj_t * lv_tabview_get_content(lv_obj_t * tv)", "sline": 160, "body": "{\n    return lv_obj_get_child(tv, 1);\n}"}, "lv_tabview_get_tab_btns": {"type": "Function", "def": "lv_obj_t * lv_tabview_get_tab_btns(lv_obj_t * tv)", "sline": 165, "body": "{\n    return lv_obj_get_child(tv, 0);\n}"}, "carbit_updater/lvgl/src/extra/widgets/tabview/lv_tabview.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/tabview/lv_tabview.c"}}, "carbit_updater/lv_drivers/display/SSD1963.c": {"SSD1963": {"type": "Variable", "def": "#include SSD1963.h", "sline": 9, "include": ["carbit_updater/lv_drivers/display/SSD1963.h", null]}, "carbit_updater/lv_drivers/display/SSD1963.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/SSD1963.c"}}, "carbit_updater/lvgl/tests/src/test_cases/test_txt.c": {"carbit_updater/lvgl/tests/src/test_cases/test_txt.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/tests/src/test_cases/test_txt.c"}}, "carbit_updater/lvgl/src/hal/lv_hal.h": {"lv_hal_disp": {"type": "Variable", "def": "#include lv_hal_disp.h", "sline": 16, "include": ["carbit_updater/lvgl/src/hal/lv_hal_disp.h", null]}, "lv_hal_indev": {"type": "Variable", "def": "#include lv_hal_indev.h", "sline": 17, "include": ["carbit_updater/lvgl/src/hal/lv_hal_indev.h", null]}, "lv_hal_tick": {"type": "Variable", "def": "#include lv_hal_tick.h", "sline": 18, "include": ["carbit_updater/lvgl/src/hal/lv_hal_tick.h", null]}, "carbit_updater/lvgl/src/hal/lv_hal.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/hal/lv_hal.h"}}, "carbit_updater/lvgl/src/misc/lv_log.c": {"lv_log": {"type": "Variable", "def": "#include lv_log.h", "sline": 9, "include": ["carbit_updater/lvgl/src/misc/lv_log.h", null]}, "carbit_updater/lvgl/src/misc/lv_log.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_log.c"}}, "carbit_updater/lv_drivers/display/ST7565.c": {"ST7565": {"type": "Variable", "def": "#include ST7565.h", "sline": 9, "include": ["carbit_updater/lv_drivers/display/ST7565.h", null]}, "carbit_updater/lv_drivers/display/ST7565.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/ST7565.c"}}, "carbit_updater/lvgl/src/extra/widgets/lv_widgets.h": {"lv_animimg": {"type": "Variable", "def": "#include animimg/lv_animimg.h", "sline": 16, "include": ["carbit_updater/lvgl/src/extra/widgets/animimg/lv_animimg.h", null]}, "lv_calendar": {"type": "Variable", "def": "#include calendar/lv_calendar.h", "sline": 17, "include": ["carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar.h", null]}, "lv_calendar_header_arrow": {"type": "Variable", "def": "#include calendar/lv_calendar_header_arrow.h", "sline": 18, "include": ["carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar_header_arrow.h", null]}, "lv_calendar_header_dropdown": {"type": "Variable", "def": "#include calendar/lv_calendar_header_dropdown.h", "sline": 19, "include": ["carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar_header_dropdown.h", null]}, "lv_chart": {"type": "Variable", "def": "#include chart/lv_chart.h", "sline": 20, "include": ["carbit_updater/lvgl/src/extra/widgets/chart/lv_chart.h", null]}, "lv_keyboard": {"type": "Variable", "def": "#include keyboard/lv_keyboard.h", "sline": 21, "include": ["carbit_updater/lvgl/src/extra/widgets/keyboard/lv_keyboard.h", null]}, "lv_list": {"type": "Variable", "def": "#include list/lv_list.h", "sline": 22, "include": ["carbit_updater/lvgl/src/extra/widgets/list/lv_list.h", null]}, "lv_msgbox": {"type": "Variable", "def": "#include msgbox/lv_msgbox.h", "sline": 23, "include": ["carbit_updater/lvgl/src/extra/widgets/msgbox/lv_msgbox.h", null]}, "lv_meter": {"type": "Variable", "def": "#include meter/lv_meter.h", "sline": 24, "include": ["carbit_updater/lvgl/src/extra/widgets/meter/lv_meter.h", null]}, "lv_spinbox": {"type": "Variable", "def": "#include spinbox/lv_spinbox.h", "sline": 25, "include": ["carbit_updater/lvgl/src/extra/widgets/spinbox/lv_spinbox.h", null]}, "lv_spinner": {"type": "Variable", "def": "#include spinner/lv_spinner.h", "sline": 26, "include": ["carbit_updater/lvgl/src/extra/widgets/spinner/lv_spinner.h", null]}, "lv_tabview": {"type": "Variable", "def": "#include tabview/lv_tabview.h", "sline": 27, "include": ["carbit_updater/lvgl/src/extra/widgets/tabview/lv_tabview.h", null]}, "lv_tileview": {"type": "Variable", "def": "#include tileview/lv_tileview.h", "sline": 28, "include": ["carbit_updater/lvgl/src/extra/widgets/tileview/lv_tileview.h", null]}, "lv_win": {"type": "Variable", "def": "#include win/lv_win.h", "sline": 29, "include": ["carbit_updater/lvgl/src/extra/widgets/win/lv_win.h", null]}, "lv_colorwheel": {"type": "Variable", "def": "#include colorwheel/lv_colorwheel.h", "sline": 30, "include": ["carbit_updater/lvgl/src/extra/widgets/colorwheel/lv_colorwheel.h", null]}, "lv_led": {"type": "Variable", "def": "#include led/lv_led.h", "sline": 31, "include": ["carbit_updater/lvgl/src/extra/widgets/led/lv_led.h", null]}, "lv_imgbtn": {"type": "Variable", "def": "#include imgbtn/lv_imgbtn.h", "sline": 32, "include": ["carbit_updater/lvgl/src/extra/widgets/imgbtn/lv_imgbtn.h", null]}, "lv_span": {"type": "Variable", "def": "#include span/lv_span.h", "sline": 33, "include": ["carbit_updater/lvgl/src/extra/widgets/span/lv_span.h", null]}, "carbit_updater/lvgl/src/extra/widgets/lv_widgets.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/lv_widgets.h"}}, "carbit_updater/lv_drivers/indev/FT5406EE8.c": {"FT5406EE8": {"type": "Variable", "def": "#include FT5406EE8.h", "sline": 9, "include": ["carbit_updater/lv_drivers/indev/FT5406EE8.h", null]}, "carbit_updater/lv_drivers/indev/FT5406EE8.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/indev/FT5406EE8.c"}}, "carbit_updater/lvgl/src/misc/lv_timer.c": {"lv_timer": {"type": "Variable", "def": "#include lv_timer.h", "sline": 8, "include": ["carbit_updater/lvgl/src/misc/lv_timer.h", null]}, "lv_hal_tick": {"type": "Variable", "def": "#include ../hal/lv_hal_tick.h", "sline": 9}, "lv_assert": {"type": "Variable", "def": "#include lv_assert.h", "sline": 10, "include": ["carbit_updater/lvgl/src/misc/lv_assert.h", null]}, "lv_mem": {"type": "Variable", "def": "#include lv_mem.h", "sline": 11, "include": ["carbit_updater/lvgl/src/misc/lv_mem.h", null]}, "lv_ll": {"type": "Variable", "def": "#include lv_ll.h", "sline": 12, "include": ["carbit_updater/lvgl/src/misc/lv_ll.h", null]}, "lv_gc": {"type": "Variable", "def": "#include lv_gc.h", "sline": 13, "include": ["carbit_updater/lvgl/src/misc/lv_gc.h", null]}, "lv_timer_exec": {"type": "Function", "def": "static bool lv_timer_exec(lv_timer_t * timer)", "sline": 300, "body": "{\n    if(timer->paused) return false;\n\n    bool exec = false;\n    if(lv_timer_time_remaining(timer) == 0) {\n        /* Decrement the repeat count before executing the timer_cb.\n         * If any timer is deleted `if(timer->repeat_count == 0)` is not executed below\n         * but at least the repeat count is zero and the timer can be deleted in the next round*/\n        int32_t original_repeat_count = timer->repeat_count;\n        if(timer->repeat_count > 0) timer->repeat_count--;\n        timer->last_run = lv_tick_get();\n        TIMER_TRACE(\"calling timer callback: %p\", *((void **)&timer->timer_cb));\n        if(timer->timer_cb && original_repeat_count != 0) timer->timer_cb(timer);\n        TIMER_TRACE(\"timer callback %p finished\", *((void **)&timer->timer_cb));\n        LV_ASSERT_MEM_INTEGRITY();\n        exec = true;\n    }\n\n    if(timer_deleted == false) { /*The timer might be deleted by itself as well*/\n        if(timer->repeat_count == 0) { /*The repeat count is over, delete the timer*/\n            TIMER_TRACE(\"deleting timer with %p callback because the repeat count is over\", *((void **)&timer->timer_cb));\n            lv_timer_del(timer);\n        }\n    }\n\n    return exec;\n}"}, "lv_timer_time_remaining": {"type": "Function", "def": "static uint32_t lv_timer_time_remaining(lv_timer_t * timer)", "sline": 334, "body": "{\n    /*Check if at least 'period' time elapsed*/\n    uint32_t elp = lv_tick_elaps(timer->last_run);\n    if(elp >= timer->period)\n        return 0;\n    return timer->period - elp;\n}"}, "lv_timer_run": {"type": "Variable", "def": "static bool lv_timer_run", "sline": 34}, "idle_last": {"type": "Variable", "def": "static uint8_t idle_last = 0", "sline": 35}, "timer_deleted": {"type": "Variable", "def": "static bool timer_deleted", "sline": 36}, "timer_created": {"type": "Variable", "def": "static bool timer_created", "sline": 37}, "_lv_timer_core_init": {"type": "Function", "def": "void _lv_timer_core_init(void)", "sline": 55, "docstring": "/**", "body": "{\n    _lv_ll_init(&LV_GC_ROOT(_lv_timer_ll), sizeof(lv_timer_t));\n\n    /*Initially enable the lv_timer handling*/\n    lv_timer_enable(true);\n}"}, "lv_timer_handler": {"type": "Function", "def": "uint32_t lv_timer_handler(void)", "sline": 67, "body": "{\n    TIMER_TRACE(\"begin\");\n\n    /*Avoid concurrent running of the timer handler*/\n    static bool already_running = false;\n    if(already_running) {\n        TIMER_TRACE(\"already running, concurrent calls are not allow, returning\");\n        return 1;\n    }\n    already_running = true;\n\n    if(lv_timer_run == false) {\n        already_running = false; /*Release mutex*/\n        return 1;\n    }\n\n    static uint32_t idle_period_start = 0;\n    static uint32_t busy_time         = 0;\n\n    uint32_t handler_start = lv_tick_get();\n\n    if(handler_start == 0) {\n        static uint32_t run_cnt = 0;\n        run_cnt++;\n        if(run_cnt > 100) {\n            run_cnt = 0;\n            LV_LOG_WARN(\"It seems lv_tick_inc() is not called.\");\n        }\n    }\n\n    /*Run all timer from the list*/\n    lv_timer_t * next;\n    do {\n        timer_deleted             = false;\n        timer_created             = false;\n        LV_GC_ROOT(_lv_timer_act) = _lv_ll_get_head(&LV_GC_ROOT(_lv_timer_ll));\n        while(LV_GC_ROOT(_lv_timer_act)) {\n            /*The timer might be deleted if it runs only once ('repeat_count = 1')\n             *So get next element until the current is surely valid*/\n            next = _lv_ll_get_next(&LV_GC_ROOT(_lv_timer_ll), LV_GC_ROOT(_lv_timer_act));\n\n            if(lv_timer_exec(LV_GC_ROOT(_lv_timer_act))) {\n                /*If a timer was created or deleted then this or the next item might be corrupted*/\n                if(timer_created || timer_deleted) {\n                    TIMER_TRACE(\"Start from the first timer again because a timer was created or deleted\");\n                    break;\n                }\n            }\n\n            LV_GC_ROOT(_lv_timer_act) = next; /*Load the next timer*/\n        }\n    } while(LV_GC_ROOT(_lv_timer_act));\n\n    uint32_t time_till_next = LV_NO_TIMER_READY;\n    next = _lv_ll_get_head(&LV_GC_ROOT(_lv_timer_ll));\n    while(next) {\n        if(!next->paused) {\n            uint32_t delay = lv_timer_time_remaining(next);\n            if(delay < time_till_next)\n                time_till_next = delay;\n        }\n\n        next = _lv_ll_get_next(&LV_GC_ROOT(_lv_timer_ll), next); /*Find the next timer*/\n    }\n\n    busy_time += lv_tick_elaps(handler_start);\n    uint32_t idle_period_time = lv_tick_elaps(idle_period_start);\n    if(idle_period_time >= IDLE_MEAS_PERIOD) {\n        idle_last         = (busy_time * 100) / idle_period_time;  /*Calculate the busy percentage*/\n        idle_last         = idle_last > 100 ? 0 : 100 - idle_last; /*But we need idle time*/\n        busy_time         = 0;\n        idle_period_start = lv_tick_get();\n    }\n\n    already_running = false; /*Release the mutex*/\n\n    TIMER_TRACE(\"finished (%d ms until the next timer call)\", time_till_next);\n    return time_till_next;\n}"}, "lv_timer_create_basic": {"type": "Function", "def": "lv_timer_t * lv_timer_create_basic(void)", "sline": 153, "body": "{\n    return lv_timer_create(NULL, DEF_PERIOD, NULL);\n}"}, "lv_timer_create": {"type": "Function", "def": "lv_timer_t * lv_timer_create(lv_timer_cb_t timer_xcb, uint32_t period, void * user_data)", "sline": 167, "body": "{\n    lv_timer_t * new_timer = NULL;\n\n    new_timer = _lv_ll_ins_head(&LV_GC_ROOT(_lv_timer_ll));\n    LV_ASSERT_MALLOC(new_timer);\n    if(new_timer == NULL) return NULL;\n\n    new_timer->period = period;\n    new_timer->timer_cb = timer_xcb;\n    new_timer->repeat_count = -1;\n    new_timer->paused = 0;\n    new_timer->last_run = lv_tick_get();\n    new_timer->user_data = user_data;\n\n    timer_created = true;\n\n    return new_timer;\n}"}, "lv_timer_set_cb": {"type": "Function", "def": "void lv_timer_set_cb(lv_timer_t * timer, lv_timer_cb_t timer_cb)", "sline": 192, "body": "{\n    timer->timer_cb = timer_cb;\n}"}, "lv_timer_del": {"type": "Function", "def": "void lv_timer_del(lv_timer_t * timer)", "sline": 201, "body": "{\n    _lv_ll_remove(&LV_GC_ROOT(_lv_timer_ll), timer);\n    timer_deleted = true;\n\n    lv_mem_free(timer);\n}"}, "lv_timer_pause": {"type": "Function", "def": "void lv_timer_pause(lv_timer_t * timer)", "sline": 213, "body": "{\n    timer->paused = true;\n}"}, "lv_timer_resume": {"type": "Function", "def": "void lv_timer_resume(lv_timer_t * timer)", "sline": 218, "body": "{\n    timer->paused = false;\n}"}, "lv_timer_set_period": {"type": "Function", "def": "void lv_timer_set_period(lv_timer_t * timer, uint32_t period)", "sline": 228, "body": "{\n    timer->period = period;\n}"}, "lv_timer_ready": {"type": "Function", "def": "void lv_timer_ready(lv_timer_t * timer)", "sline": 237, "body": "{\n    timer->last_run = lv_tick_get() - timer->period - 1;\n}"}, "lv_timer_set_repeat_count": {"type": "Function", "def": "void lv_timer_set_repeat_count(lv_timer_t * timer, int32_t repeat_count)", "sline": 247, "body": "{\n    timer->repeat_count = repeat_count;\n}"}, "lv_timer_reset": {"type": "Function", "def": "void lv_timer_reset(lv_timer_t * timer)", "sline": 257, "body": "{\n    timer->last_run = lv_tick_get();\n}"}, "lv_timer_enable": {"type": "Function", "def": "void lv_timer_enable(bool en)", "sline": 266, "body": "{\n    lv_timer_run = en;\n}"}, "lv_timer_get_idle": {"type": "Function", "def": "uint8_t lv_timer_get_idle(void)", "sline": 275, "body": "{\n    return idle_last;\n}"}, "lv_timer_get_next": {"type": "Function", "def": "lv_timer_t * lv_timer_get_next(lv_timer_t * timer)", "sline": 285, "body": "{\n    if(timer == NULL) return _lv_ll_get_head(&LV_GC_ROOT(_lv_timer_ll));\n    else return _lv_ll_get_next(&LV_GC_ROOT(_lv_timer_ll), timer);\n}"}, "carbit_updater/lvgl/src/misc/lv_timer.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_timer.c"}}, "carbit_updater/lvgl/src/font/lv_font_fmt_txt.c": {"lv_font": {"type": "Variable", "def": "#include lv_font.h", "sline": 9, "include": ["carbit_updater/lvgl/src/font/lv_font.h", null]}, "lv_font_fmt_txt": {"type": "Variable", "def": "#include lv_font_fmt_txt.h", "sline": 10, "include": ["carbit_updater/lvgl/src/font/lv_font_fmt_txt.h", null]}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 11}, "lv_types": {"type": "Variable", "def": "#include ../misc/lv_types.h", "sline": 12}, "lv_gc": {"type": "Variable", "def": "#include ../misc/lv_gc.h", "sline": 13}, "lv_log": {"type": "Variable", "def": "#include ../misc/lv_log.h", "sline": 14}, "lv_utils": {"type": "Variable", "def": "#include ../misc/lv_utils.h", "sline": 15}, "lv_mem": {"type": "Variable", "def": "#include ../misc/lv_mem.h", "sline": 16}, "rle_state_t": {"type": "Variable", "def": "typedef enum {\n    RLE_STATE_SINGLE = 0,\n    RLE_STATE_REPEATE,\n    RLE_STATE_COUNTER,\n} rle_state_t", "sline": 29, "docstring": "/**********************"}, "get_glyph_dsc_id": {"type": "Function", "def": "static uint32_t get_glyph_dsc_id(const lv_font_t * font, uint32_t letter)", "sline": 208, "body": "{\n    if(letter == '\\0') return 0;\n\n    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *)font->dsc;\n\n    /*Check the cache first*/\n    if(fdsc->cache && letter == fdsc->cache->last_letter) return fdsc->cache->last_glyph_id;\n\n    uint16_t i;\n    for(i = 0; i < fdsc->cmap_num; i++) {\n\n        /*Relative code point*/\n        uint32_t rcp = letter - fdsc->cmaps[i].range_start;\n        if(rcp > fdsc->cmaps[i].range_length) continue;\n        uint32_t glyph_id = 0;\n        if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY) {\n            glyph_id = fdsc->cmaps[i].glyph_id_start + rcp;\n        }\n        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL) {\n            const uint8_t * gid_ofs_8 = fdsc->cmaps[i].glyph_id_ofs_list;\n            glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_8[rcp];\n        }\n        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_TINY) {\n            uint16_t key = rcp;\n            uint16_t * p = _lv_utils_bsearch(&key, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length,\n                                             sizeof(fdsc->cmaps[i].unicode_list[0]), unicode_list_compare);\n\n            if(p) {\n                lv_uintptr_t ofs = p - fdsc->cmaps[i].unicode_list;\n                glyph_id = fdsc->cmaps[i].glyph_id_start + ofs;\n            }\n        }\n        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_FULL) {\n            uint16_t key = rcp;\n            uint16_t * p = _lv_utils_bsearch(&key, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length,\n                                             sizeof(fdsc->cmaps[i].unicode_list[0]), unicode_list_compare);\n\n            if(p) {\n                lv_uintptr_t ofs = p - fdsc->cmaps[i].unicode_list;\n                const uint16_t * gid_ofs_16 = fdsc->cmaps[i].glyph_id_ofs_list;\n                glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_16[ofs];\n            }\n        }\n\n        /*Update the cache*/\n        if(fdsc->cache) {\n            fdsc->cache->last_letter = letter;\n            fdsc->cache->last_glyph_id = glyph_id;\n        }\n        return glyph_id;\n    }\n\n    if(fdsc->cache) {\n        fdsc->cache->last_letter = letter;\n        fdsc->cache->last_glyph_id = 0;\n    }\n    return 0;\n\n}"}, "get_kern_value": {"type": "Function", "def": "static int8_t get_kern_value(const lv_font_t * font, uint32_t gid_left, uint32_t gid_right)", "sline": 269, "body": "{\n    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *)font->dsc;\n\n    int8_t value = 0;\n\n    if(fdsc->kern_classes == 0) {\n        /*Kern pairs*/\n        const lv_font_fmt_txt_kern_pair_t * kdsc = fdsc->kern_dsc;\n        if(kdsc->glyph_ids_size == 0) {\n            /*Use binary search to find the kern value.\n             *The pairs are ordered left_id first, then right_id secondly.*/\n            const uint16_t * g_ids = kdsc->glyph_ids;\n            uint16_t g_id_both = (gid_right << 8) + gid_left; /*Create one number from the ids*/\n            uint16_t * kid_p = _lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 2, kern_pair_8_compare);\n\n            /*If the `g_id_both` were found get its index from the pointer*/\n            if(kid_p) {\n                lv_uintptr_t ofs = kid_p - g_ids;\n                value = kdsc->values[ofs];\n            }\n        }\n        else if(kdsc->glyph_ids_size == 1) {\n            /*Use binary search to find the kern value.\n             *The pairs are ordered left_id first, then right_id secondly.*/\n            const uint32_t * g_ids = kdsc->glyph_ids;\n            uint32_t g_id_both = (gid_right << 16) + gid_left; /*Create one number from the ids*/\n            uint32_t * kid_p = _lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 4, kern_pair_16_compare);\n\n            /*If the `g_id_both` were found get its index from the pointer*/\n            if(kid_p) {\n                lv_uintptr_t ofs = kid_p - g_ids;\n                value = kdsc->values[ofs];\n            }\n\n        }\n        else {\n            /*Invalid value*/\n        }\n    }\n    else {\n        /*Kern classes*/\n        const lv_font_fmt_txt_kern_classes_t * kdsc = fdsc->kern_dsc;\n        uint8_t left_class = kdsc->left_class_mapping[gid_left];\n        uint8_t right_class = kdsc->right_class_mapping[gid_right];\n\n        /*If class = 0, kerning not exist for that glyph\n         *else got the value form `class_pair_values` 2D array*/\n        if(left_class > 0 && right_class > 0) {\n            value = kdsc->class_pair_values[(left_class - 1) * kdsc->right_class_cnt + (right_class - 1)];\n        }\n\n    }\n    return value;\n}"}, "unicode_list_compare": {"type": "Function", "def": "static int32_t unicode_list_compare(const void * ref, const void * element)", "sline": 590, "body": "{\n    return ((int32_t)(*(uint16_t *)ref)) - ((int32_t)(*(uint16_t *)element));\n}"}, "kern_pair_8_compare": {"type": "Function", "def": "static int32_t kern_pair_8_compare(const void * ref, const void * element)", "sline": 325, "body": "{\n    const uint8_t * ref8_p = ref;\n    const uint8_t * element8_p = element;\n\n    /*If the MSB is different it will matter. If not return the diff. of the LSB*/\n    if(ref8_p[0] != element8_p[0]) return (int32_t)ref8_p[0] - element8_p[0];\n    else return (int32_t) ref8_p[1] - element8_p[1];\n\n}"}, "kern_pair_16_compare": {"type": "Function", "def": "static int32_t kern_pair_16_compare(const void * ref, const void * element)", "sline": 336, "body": "{\n    const uint16_t * ref16_p = ref;\n    const uint16_t * element16_p = element;\n\n    /*If the MSB is different it will matter. If not return the diff. of the LSB*/\n    if(ref16_p[0] != element16_p[0]) return (int32_t)ref16_p[0] - element16_p[0];\n    else return (int32_t) ref16_p[1] - element16_p[1];\n}"}, "lv_font_get_bitmap_fmt_txt": {"type": "Function", "def": "const uint8_t * lv_font_get_bitmap_fmt_txt(const lv_font_t * font, uint32_t unicode_letter)", "sline": 79, "body": "{\n    if(unicode_letter == '\\t') unicode_letter = ' ';\n\n    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *)font->dsc;\n    uint32_t gid = get_glyph_dsc_id(font, unicode_letter);\n    if(!gid) return NULL;\n\n    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];\n\n    if(fdsc->bitmap_format == LV_FONT_FMT_TXT_PLAIN) {\n        return &fdsc->glyph_bitmap[gdsc->bitmap_index];\n    }\n    /*Handle compressed bitmap*/\n    else {\n#if LV_USE_FONT_COMPRESSED\n        static size_t last_buf_size = 0;\n        if(LV_GC_ROOT(_lv_font_decompr_buf) == NULL) last_buf_size = 0;\n\n        uint32_t gsize = gdsc->box_w * gdsc->box_h;\n        if(gsize == 0) return NULL;\n\n        uint32_t buf_size = gsize;\n        /*Compute memory size needed to hold decompressed glyph, rounding up*/\n        switch(fdsc->bpp) {\n            case 1:\n                buf_size = (gsize + 7) >> 3;\n                break;\n            case 2:\n                buf_size = (gsize + 3) >> 2;\n                break;\n            case 3:\n                buf_size = (gsize + 1) >> 1;\n                break;\n            case 4:\n                buf_size = (gsize + 1) >> 1;\n                break;\n        }\n\n        if(last_buf_size < buf_size) {\n            uint8_t * tmp = lv_mem_realloc(LV_GC_ROOT(_lv_font_decompr_buf), buf_size);\n            LV_ASSERT_MALLOC(tmp);\n            if(tmp == NULL) return NULL;\n            LV_GC_ROOT(_lv_font_decompr_buf) = tmp;\n            last_buf_size = buf_size;\n        }\n\n        bool prefilter = fdsc->bitmap_format == LV_FONT_FMT_TXT_COMPRESSED ? true : false;\n        decompress(&fdsc->glyph_bitmap[gdsc->bitmap_index], LV_GC_ROOT(_lv_font_decompr_buf), gdsc->box_w, gdsc->box_h,\n                   (uint8_t)fdsc->bpp, prefilter);\n        return LV_GC_ROOT(_lv_font_decompr_buf);\n#else /*!LV_USE_FONT_COMPRESSED*/\n        LV_LOG_WARN(\"Compressed fonts is used but LV_USE_FONT_COMPRESSED is not enabled in lv_conf.h\");\n        return NULL;\n#endif\n    }\n\n    /*If not returned earlier then the letter is not found in this font*/\n    return NULL;\n}"}, "lv_font_get_glyph_dsc_fmt_txt": {"type": "Function", "def": "bool lv_font_get_glyph_dsc_fmt_txt(const lv_font_t * font, lv_font_glyph_dsc_t * dsc_out, uint32_t unicode_letter,\n                                   uint32_t unicode_letter_next)", "sline": 148, "body": "{\n    bool is_tab = false;\n    if(unicode_letter == '\\t') {\n        unicode_letter = ' ';\n        is_tab = true;\n    }\n    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *)font->dsc;\n    uint32_t gid = get_glyph_dsc_id(font, unicode_letter);\n    if(!gid) return false;\n\n    int8_t kvalue = 0;\n    if(fdsc->kern_dsc) {\n        uint32_t gid_next = get_glyph_dsc_id(font, unicode_letter_next);\n        if(gid_next) {\n            kvalue = get_kern_value(font, gid, gid_next);\n        }\n    }\n\n    /*Put together a glyph dsc*/\n    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];\n\n    int32_t kv = ((int32_t)((int32_t)kvalue * fdsc->kern_scale) >> 4);\n\n    uint32_t adv_w = gdsc->adv_w;\n    if(is_tab) adv_w *= 2;\n\n    adv_w += kv;\n    adv_w  = (adv_w + (1 << 3)) >> 4;\n\n    dsc_out->adv_w = adv_w;\n    dsc_out->box_h = gdsc->box_h;\n    dsc_out->box_w = gdsc->box_w;\n    dsc_out->ofs_x = gdsc->ofs_x;\n    dsc_out->ofs_y = gdsc->ofs_y;\n    dsc_out->bpp   = (uint8_t)fdsc->bpp;\n\n    if(is_tab) dsc_out->box_w = dsc_out->box_w * 2;\n\n    return true;\n}"}, "_lv_font_clean_up_fmt_txt": {"type": "Function", "def": "void _lv_font_clean_up_fmt_txt(void)", "sline": 194, "docstring": "/**", "body": "{\n#if LV_USE_FONT_COMPRESSED\n    if(LV_GC_ROOT(_lv_font_decompr_buf)) {\n        lv_mem_free(LV_GC_ROOT(_lv_font_decompr_buf));\n        LV_GC_ROOT(_lv_font_decompr_buf) = NULL;\n    }\n#endif\n}"}, "carbit_updater/lvgl/src/font/lv_font_fmt_txt.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_fmt_txt.c"}}, "carbit_updater/lvgl/src/font/lv_font_loader.c": {"stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 10}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 11}, "lvgl": {"type": "Variable", "def": "#include ../lvgl.h", "sline": 13}, "lv_fs": {"type": "Variable", "def": "#include ../misc/lv_fs.h", "sline": 14}, "lv_font_loader": {"type": "Variable", "def": "#include lv_font_loader.h", "sline": 15, "include": ["carbit_updater/lvgl/src/font/lv_font_loader.h", null]}, "bit_iterator_t.fp": {"type": "Variable", "def": "lv_fs_file_t * fp", "sline": 21, "in_struct": "bit_iterator_t"}, "bit_iterator_t.bit_pos": {"type": "Variable", "def": "int8_t bit_pos", "sline": 22, "in_struct": "bit_iterator_t"}, "bit_iterator_t.byte_value": {"type": "Variable", "def": "uint8_t byte_value", "sline": 23, "in_struct": "bit_iterator_t"}, "bit_iterator_t": {"type": "Variable", "def": "typedef struct {\n    lv_fs_file_t * fp;\n    int8_t bit_pos;\n    uint8_t byte_value;\n} bit_iterator_t", "sline": 24, "docstring": "/**********************"}, "font_header_bin.version": {"type": "Variable", "def": "uint32_t version", "sline": 27, "in_struct": "font_header_bin"}, "font_header_bin.tables_count": {"type": "Variable", "def": "uint16_t tables_count", "sline": 28, "in_struct": "font_header_bin"}, "font_header_bin.font_size": {"type": "Variable", "def": "uint16_t font_size", "sline": 29, "in_struct": "font_header_bin"}, "font_header_bin.ascent": {"type": "Variable", "def": "uint16_t ascent", "sline": 30, "in_struct": "font_header_bin"}, "font_header_bin.descent": {"type": "Variable", "def": "int16_t descent", "sline": 31, "in_struct": "font_header_bin"}, "font_header_bin.typo_ascent": {"type": "Variable", "def": "uint16_t typo_ascent", "sline": 32, "in_struct": "font_header_bin"}, "font_header_bin.typo_descent": {"type": "Variable", "def": "int16_t typo_descent", "sline": 33, "in_struct": "font_header_bin"}, "font_header_bin.typo_line_gap": {"type": "Variable", "def": "uint16_t typo_line_gap", "sline": 34, "in_struct": "font_header_bin"}, "font_header_bin.min_y": {"type": "Variable", "def": "int16_t min_y", "sline": 35, "in_struct": "font_header_bin"}, "font_header_bin.max_y": {"type": "Variable", "def": "int16_t max_y", "sline": 36, "in_struct": "font_header_bin"}, "font_header_bin.default_advance_width": {"type": "Variable", "def": "uint16_t default_advance_width", "sline": 37, "in_struct": "font_header_bin"}, "font_header_bin.kerning_scale": {"type": "Variable", "def": "uint16_t kerning_scale", "sline": 38, "in_struct": "font_header_bin"}, "font_header_bin.index_to_loc_format": {"type": "Variable", "def": "uint8_t index_to_loc_format", "sline": 39, "in_struct": "font_header_bin"}, "font_header_bin.glyph_id_format": {"type": "Variable", "def": "uint8_t glyph_id_format", "sline": 40, "in_struct": "font_header_bin"}, "font_header_bin.advance_width_format": {"type": "Variable", "def": "uint8_t advance_width_format", "sline": 41, "in_struct": "font_header_bin"}, "font_header_bin.bits_per_pixel": {"type": "Variable", "def": "uint8_t bits_per_pixel", "sline": 42, "in_struct": "font_header_bin"}, "font_header_bin.xy_bits": {"type": "Variable", "def": "uint8_t xy_bits", "sline": 43, "in_struct": "font_header_bin"}, "font_header_bin.wh_bits": {"type": "Variable", "def": "uint8_t wh_bits", "sline": 44, "in_struct": "font_header_bin"}, "font_header_bin.advance_width_bits": {"type": "Variable", "def": "uint8_t advance_width_bits", "sline": 45, "in_struct": "font_header_bin"}, "font_header_bin.compression_id": {"type": "Variable", "def": "uint8_t compression_id", "sline": 46, "in_struct": "font_header_bin"}, "font_header_bin.subpixels_mode": {"type": "Variable", "def": "uint8_t subpixels_mode", "sline": 47, "in_struct": "font_header_bin"}, "font_header_bin.padding": {"type": "Variable", "def": "uint8_t padding", "sline": 48, "in_struct": "font_header_bin"}, "font_header_bin.underline_position": {"type": "Variable", "def": "int16_t underline_position", "sline": 49, "in_struct": "font_header_bin"}, "font_header_bin.underline_thickness": {"type": "Variable", "def": "uint16_t underline_thickness", "sline": 50, "in_struct": "font_header_bin"}, "font_header_bin": {"type": "Struct", "def": "struct font_header_bin {\n    uint32_t version;\n    uint16_t tables_count;\n    uint16_t font_size;\n    uint16_t ascent;\n    int16_t descent;\n    uint16_t typo_ascent;\n    int16_t typo_descent;\n    uint16_t typo_line_gap;\n    int16_t min_y;\n    int16_t max_y;\n    uint16_t default_advance_width;\n    uint16_t kerning_scale;\n    uint8_t index_to_loc_format;\n    uint8_t glyph_id_format;\n    uint8_t advance_width_format;\n    uint8_t bits_per_pixel;\n    uint8_t xy_bits;\n    uint8_t wh_bits;\n    uint8_t advance_width_bits;\n    uint8_t compression_id;\n    uint8_t subpixels_mode;\n    uint8_t padding;\n    int16_t underline_position;\n    uint16_t underline_thickness;\n}", "sline": 26, "body": "uint32_t version\nuint16_t tables_count\nuint16_t font_size\nuint16_t ascent\nint16_t descent\nuint16_t typo_ascent\nint16_t typo_descent\nuint16_t typo_line_gap\nint16_t min_y\nint16_t max_y\nuint16_t default_advance_width\nuint16_t kerning_scale\nuint8_t index_to_loc_format\nuint8_t glyph_id_format\nuint8_t advance_width_format\nuint8_t bits_per_pixel\nuint8_t xy_bits\nuint8_t wh_bits\nuint8_t advance_width_bits\nuint8_t compression_id\nuint8_t subpixels_mode\nuint8_t padding\nint16_t underline_position\nuint16_t underline_thickness\n"}, "font_header_bin_t": {"type": "Variable", "def": "typedef struct font_header_bin {\n    uint32_t version;\n    uint16_t tables_count;\n    uint16_t font_size;\n    uint16_t ascent;\n    int16_t descent;\n    uint16_t typo_ascent;\n    int16_t typo_descent;\n    uint16_t typo_line_gap;\n    int16_t min_y;\n    int16_t max_y;\n    uint16_t default_advance_width;\n    uint16_t kerning_scale;\n    uint8_t index_to_loc_format;\n    uint8_t glyph_id_format;\n    uint8_t advance_width_format;\n    uint8_t bits_per_pixel;\n    uint8_t xy_bits;\n    uint8_t wh_bits;\n    uint8_t advance_width_bits;\n    uint8_t compression_id;\n    uint8_t subpixels_mode;\n    uint8_t padding;\n    int16_t underline_position;\n    uint16_t underline_thickness;\n} font_header_bin_t", "sline": 51}, "cmap_table_bin.data_offset": {"type": "Variable", "def": "uint32_t data_offset", "sline": 54, "in_struct": "cmap_table_bin"}, "cmap_table_bin.range_start": {"type": "Variable", "def": "uint32_t range_start", "sline": 55, "in_struct": "cmap_table_bin"}, "cmap_table_bin.range_length": {"type": "Variable", "def": "uint16_t range_length", "sline": 56, "in_struct": "cmap_table_bin"}, "cmap_table_bin.glyph_id_start": {"type": "Variable", "def": "uint16_t glyph_id_start", "sline": 57, "in_struct": "cmap_table_bin"}, "cmap_table_bin.data_entries_count": {"type": "Variable", "def": "uint16_t data_entries_count", "sline": 58, "in_struct": "cmap_table_bin"}, "cmap_table_bin.format_type": {"type": "Variable", "def": "uint8_t format_type", "sline": 59, "in_struct": "cmap_table_bin"}, "cmap_table_bin.padding": {"type": "Variable", "def": "uint8_t padding", "sline": 60, "in_struct": "cmap_table_bin"}, "cmap_table_bin": {"type": "Struct", "def": "struct cmap_table_bin {\n    uint32_t data_offset;\n    uint32_t range_start;\n    uint16_t range_length;\n    uint16_t glyph_id_start;\n    uint16_t data_entries_count;\n    uint8_t format_type;\n    uint8_t padding;\n}", "sline": 53, "body": "uint32_t data_offset\nuint32_t range_start\nuint16_t range_length\nuint16_t glyph_id_start\nuint16_t data_entries_count\nuint8_t format_type\nuint8_t padding\n"}, "cmap_table_bin_t": {"type": "Variable", "def": "typedef struct cmap_table_bin {\n    uint32_t data_offset;\n    uint32_t range_start;\n    uint16_t range_length;\n    uint16_t glyph_id_start;\n    uint16_t data_entries_count;\n    uint8_t format_type;\n    uint8_t padding;\n} cmap_table_bin_t", "sline": 61}, "init_bit_iterator": {"type": "Function", "def": "static bit_iterator_t init_bit_iterator(lv_fs_file_t * fp)", "sline": 185, "body": "{\n    bit_iterator_t it;\n    it.fp = fp;\n    it.bit_pos = -1;\n    it.byte_value = 0;\n    return it;\n}", "rels": [["bit_iterator_t", null, "Typeof"]]}, "lvgl_load_font": {"type": "Function", "def": "static bool lvgl_load_font(lv_fs_file_t * fp, lv_font_t * font)", "sline": 483, "body": "{\n    lv_font_fmt_txt_dsc_t * font_dsc = (lv_font_fmt_txt_dsc_t *)\n                                       lv_mem_alloc(sizeof(lv_font_fmt_txt_dsc_t));\n\n    memset(font_dsc, 0, sizeof(lv_font_fmt_txt_dsc_t));\n\n    font->dsc = font_dsc;\n\n    /*header*/\n    int32_t header_length = read_label(fp, 0, \"head\");\n    if(header_length < 0) {\n        return false;\n    }\n\n    font_header_bin_t font_header;\n    if(lv_fs_read(fp, &font_header, sizeof(font_header_bin_t), NULL) != LV_FS_RES_OK) {\n        return false;\n    }\n\n    font->base_line = -font_header.descent;\n    font->line_height = font_header.ascent - font_header.descent;\n    font->get_glyph_dsc = lv_font_get_glyph_dsc_fmt_txt;\n    font->get_glyph_bitmap = lv_font_get_bitmap_fmt_txt;\n    font->subpx = font_header.subpixels_mode;\n    font->underline_position = font_header.underline_position;\n    font->underline_thickness = font_header.underline_thickness;\n\n    font_dsc->bpp = font_header.bits_per_pixel;\n    font_dsc->kern_scale = font_header.kerning_scale;\n    font_dsc->bitmap_format = font_header.compression_id;\n\n    /*cmaps*/\n    uint32_t cmaps_start = header_length;\n    int32_t cmaps_length = load_cmaps(fp, font_dsc, cmaps_start);\n    if(cmaps_length < 0) {\n        return false;\n    }\n\n    /*loca*/\n    uint32_t loca_start = cmaps_start + cmaps_length;\n    int32_t loca_length = read_label(fp, loca_start, \"loca\");\n    if(loca_length < 0) {\n        return false;\n    }\n\n    uint32_t loca_count;\n    if(lv_fs_read(fp, &loca_count, sizeof(uint32_t), NULL) != LV_FS_RES_OK) {\n        return false;\n    }\n\n    bool failed = false;\n    uint32_t * glyph_offset = lv_mem_alloc(sizeof(uint32_t) * (loca_count + 1));\n\n    if(font_header.index_to_loc_format == 0) {\n        for(unsigned int i = 0; i < loca_count; ++i) {\n            uint16_t offset;\n            if(lv_fs_read(fp, &offset, sizeof(uint16_t), NULL) != LV_FS_RES_OK) {\n                failed = true;\n                break;\n            }\n            glyph_offset[i] = offset;\n        }\n    }\n    else if(font_header.index_to_loc_format == 1) {\n        if(lv_fs_read(fp, glyph_offset, loca_count * sizeof(uint32_t), NULL) != LV_FS_RES_OK) {\n            failed = true;\n        }\n    }\n    else {\n        LV_LOG_WARN(\"Unknown index_to_loc_format: %d.\", font_header.index_to_loc_format);\n        failed = true;\n    }\n\n    if(failed) {\n        lv_mem_free(glyph_offset);\n        return false;\n    }\n\n    /*glyph*/\n    uint32_t glyph_start = loca_start + loca_length;\n    int32_t glyph_length = load_glyph(\n                               fp, font_dsc, glyph_start, glyph_offset, loca_count, &font_header);\n\n    lv_mem_free(glyph_offset);\n\n    if(glyph_length < 0) {\n        return false;\n    }\n\n    if(font_header.tables_count < 4) {\n        font_dsc->kern_dsc = NULL;\n        font_dsc->kern_classes = 0;\n        font_dsc->kern_scale = 0;\n        return true;\n    }\n\n    uint32_t kern_start = glyph_start + glyph_length;\n\n    int32_t kern_length = load_kern(fp, font_dsc, font_header.glyph_id_format, kern_start);\n\n    return kern_length >= 0;\n}"}, "load_kern": {"type": "Function", "def": "int32_t load_kern(lv_fs_file_t * fp, lv_font_fmt_txt_dsc_t * font_dsc, uint8_t format, uint32_t start)", "sline": 587, "body": "{\n    int32_t kern_length = read_label(fp, start, \"kern\");\n    if(kern_length < 0) {\n        return -1;\n    }\n\n    uint8_t kern_format_type;\n    int32_t padding;\n    if(lv_fs_read(fp, &kern_format_type, sizeof(uint8_t), NULL) != LV_FS_RES_OK ||\n       lv_fs_read(fp, &padding, 3 * sizeof(uint8_t), NULL) != LV_FS_RES_OK) {\n        return -1;\n    }\n\n    if(0 == kern_format_type) { /*sorted pairs*/\n        lv_font_fmt_txt_kern_pair_t * kern_pair = lv_mem_alloc(sizeof(lv_font_fmt_txt_kern_pair_t));\n\n        memset(kern_pair, 0, sizeof(lv_font_fmt_txt_kern_pair_t));\n\n        font_dsc->kern_dsc = kern_pair;\n        font_dsc->kern_classes = 0;\n\n        uint32_t glyph_entries;\n        if(lv_fs_read(fp, &glyph_entries, sizeof(uint32_t), NULL) != LV_FS_RES_OK) {\n            return -1;\n        }\n\n        int ids_size;\n        if(format == 0) {\n            ids_size = sizeof(int8_t) * 2 * glyph_entries;\n        }\n        else {\n            ids_size = sizeof(int16_t) * 2 * glyph_entries;\n        }\n\n        uint8_t * glyph_ids = lv_mem_alloc(ids_size);\n        int8_t * values = lv_mem_alloc(glyph_entries);\n\n        kern_pair->glyph_ids_size = format;\n        kern_pair->pair_cnt = glyph_entries;\n        kern_pair->glyph_ids = glyph_ids;\n        kern_pair->values = values;\n\n        if(lv_fs_read(fp, glyph_ids, ids_size, NULL) != LV_FS_RES_OK) {\n            return -1;\n        }\n\n        if(lv_fs_read(fp, values, glyph_entries, NULL) != LV_FS_RES_OK) {\n            return -1;\n        }\n    }\n    else if(3 == kern_format_type) { /*array M*N of classes*/\n\n        lv_font_fmt_txt_kern_classes_t * kern_classes = lv_mem_alloc(sizeof(lv_font_fmt_txt_kern_classes_t));\n\n        memset(kern_classes, 0, sizeof(lv_font_fmt_txt_kern_classes_t));\n\n        font_dsc->kern_dsc = kern_classes;\n        font_dsc->kern_classes = 1;\n\n        uint16_t kern_class_mapping_length;\n        uint8_t kern_table_rows;\n        uint8_t kern_table_cols;\n\n        if(lv_fs_read(fp, &kern_class_mapping_length, sizeof(uint16_t), NULL) != LV_FS_RES_OK ||\n           lv_fs_read(fp, &kern_table_rows, sizeof(uint8_t), NULL) != LV_FS_RES_OK ||\n           lv_fs_read(fp, &kern_table_cols, sizeof(uint8_t), NULL) != LV_FS_RES_OK) {\n            return -1;\n        }\n\n        int kern_values_length = sizeof(int8_t) * kern_table_rows * kern_table_cols;\n\n        uint8_t * kern_left = lv_mem_alloc(kern_class_mapping_length);\n        uint8_t * kern_right = lv_mem_alloc(kern_class_mapping_length);\n        int8_t * kern_values = lv_mem_alloc(kern_values_length);\n\n        kern_classes->left_class_mapping  = kern_left;\n        kern_classes->right_class_mapping = kern_right;\n        kern_classes->left_class_cnt = kern_table_rows;\n        kern_classes->right_class_cnt = kern_table_cols;\n        kern_classes->class_pair_values = kern_values;\n\n        if(lv_fs_read(fp, kern_left, kern_class_mapping_length, NULL) != LV_FS_RES_OK ||\n           lv_fs_read(fp, kern_right, kern_class_mapping_length, NULL) != LV_FS_RES_OK ||\n           lv_fs_read(fp, kern_values, kern_values_length, NULL) != LV_FS_RES_OK) {\n            return -1;\n        }\n    }\n    else {\n        LV_LOG_WARN(\"Unknown kern_format_type: %d\", kern_format_type);\n        return -1;\n    }\n\n    return kern_length;\n}"}, "read_bits_signed": {"type": "Function", "def": "static int read_bits_signed(bit_iterator_t * it, int n_bits, lv_fs_res_t * res)", "sline": 216, "body": "{\n    unsigned int value = read_bits(it, n_bits, res);\n    if(value & (1 << (n_bits - 1))) {\n        value |= ~0u << n_bits;\n    }\n    return value;\n}"}, "read_bits": {"type": "Function", "def": "static unsigned int read_bits(bit_iterator_t * it, int n_bits, lv_fs_res_t * res)", "sline": 194, "body": "{\n    unsigned int value = 0;\n    while(n_bits--) {\n        it->byte_value = it->byte_value << 1;\n        it->bit_pos--;\n\n        if(it->bit_pos < 0) {\n            it->bit_pos = 7;\n            *res = lv_fs_read(it->fp, &(it->byte_value), 1, NULL);\n            if(*res != LV_FS_RES_OK) {\n                return 0;\n            }\n        }\n        int8_t bit = (it->byte_value & 0x80) ? 1 : 0;\n\n        value |= (bit << n_bits);\n    }\n    *res = LV_FS_RES_OK;\n    return value;\n}"}, "lv_font_load": {"type": "Function", "def": "lv_font_t * lv_font_load(const char * font_name)", "sline": 86, "body": "{\n    lv_fs_file_t file;\n    lv_fs_res_t res = lv_fs_open(&file, font_name, LV_FS_MODE_RD);\n    if(res != LV_FS_RES_OK)\n        return NULL;\n\n    lv_font_t * font = lv_mem_alloc(sizeof(lv_font_t));\n    if(font) {\n        memset(font, 0, sizeof(lv_font_t));\n        if(!lvgl_load_font(&file, font)) {\n            LV_LOG_WARN(\"Error loading font file: %s\\n\", font_name);\n            /*\n            * When `lvgl_load_font` fails it can leak some pointers.\n            * All non-null pointers can be assumed as allocated and\n            * `lv_font_free` should free them correctly.\n            */\n            lv_font_free(font);\n            font = NULL;\n        }\n    }\n\n    lv_fs_close(&file);\n\n    return font;\n}"}, "lv_font_free": {"type": "Function", "def": "void lv_font_free(lv_font_t * font)", "sline": 117, "body": "{\n    if(NULL != font) {\n        lv_font_fmt_txt_dsc_t * dsc = (lv_font_fmt_txt_dsc_t *)font->dsc;\n\n        if(NULL != dsc) {\n\n            if(dsc->kern_classes == 0) {\n                lv_font_fmt_txt_kern_pair_t * kern_dsc =\n                    (lv_font_fmt_txt_kern_pair_t *)dsc->kern_dsc;\n\n                if(NULL != kern_dsc) {\n                    if(kern_dsc->glyph_ids)\n                        lv_mem_free((void *)kern_dsc->glyph_ids);\n\n                    if(kern_dsc->values)\n                        lv_mem_free((void *)kern_dsc->values);\n\n                    lv_mem_free((void *)kern_dsc);\n                }\n            }\n            else {\n                lv_font_fmt_txt_kern_classes_t * kern_dsc =\n                    (lv_font_fmt_txt_kern_classes_t *)dsc->kern_dsc;\n\n                if(NULL != kern_dsc) {\n                    if(kern_dsc->class_pair_values)\n                        lv_mem_free((void *)kern_dsc->class_pair_values);\n\n                    if(kern_dsc->left_class_mapping)\n                        lv_mem_free((void *)kern_dsc->left_class_mapping);\n\n                    if(kern_dsc->right_class_mapping)\n                        lv_mem_free((void *)kern_dsc->right_class_mapping);\n\n                    lv_mem_free((void *)kern_dsc);\n                }\n            }\n\n            lv_font_fmt_txt_cmap_t * cmaps =\n                (lv_font_fmt_txt_cmap_t *)dsc->cmaps;\n\n            if(NULL != cmaps) {\n                for(int i = 0; i < dsc->cmap_num; ++i) {\n                    if(NULL != cmaps[i].glyph_id_ofs_list)\n                        lv_mem_free((void *)cmaps[i].glyph_id_ofs_list);\n                    if(NULL != cmaps[i].unicode_list)\n                        lv_mem_free((void *)cmaps[i].unicode_list);\n                }\n                lv_mem_free(cmaps);\n            }\n\n            if(NULL != dsc->glyph_bitmap) {\n                lv_mem_free((void *)dsc->glyph_bitmap);\n            }\n            if(NULL != dsc->glyph_dsc) {\n                lv_mem_free((void *)dsc->glyph_dsc);\n            }\n            lv_mem_free(dsc);\n        }\n        lv_mem_free(font);\n    }\n}"}, "read_label": {"type": "Function", "def": "static int read_label(lv_fs_file_t * fp, int start, const char * label)", "sline": 225, "body": "{\n    lv_fs_seek(fp, start, LV_FS_SEEK_SET);\n\n    uint32_t length;\n    char buf[4];\n\n    if(lv_fs_read(fp, &length, 4, NULL) != LV_FS_RES_OK\n       || lv_fs_read(fp, buf, 4, NULL) != LV_FS_RES_OK\n       || memcmp(label, buf, 4) != 0) {\n        LV_LOG_WARN(\"Error reading '%s' label.\", label);\n        return -1;\n    }\n\n    return length;\n}"}, "load_cmaps_tables": {"type": "Function", "def": "static bool load_cmaps_tables(lv_fs_file_t * fp, lv_font_fmt_txt_dsc_t * font_dsc,\n                              uint32_t cmaps_start, cmap_table_bin_t * cmap_table)", "sline": 242, "body": "{\n    if(lv_fs_read(fp, cmap_table, font_dsc->cmap_num * sizeof(cmap_table_bin_t), NULL) != LV_FS_RES_OK) {\n        return false;\n    }\n\n    for(unsigned int i = 0; i < font_dsc->cmap_num; ++i) {\n        lv_fs_res_t res = lv_fs_seek(fp, cmaps_start + cmap_table[i].data_offset, LV_FS_SEEK_SET);\n        if(res != LV_FS_RES_OK) {\n            return false;\n        }\n\n        lv_font_fmt_txt_cmap_t * cmap = (lv_font_fmt_txt_cmap_t *) & (font_dsc->cmaps[i]);\n\n        cmap->range_start = cmap_table[i].range_start;\n        cmap->range_length = cmap_table[i].range_length;\n        cmap->glyph_id_start = cmap_table[i].glyph_id_start;\n        cmap->type = cmap_table[i].format_type;\n\n        switch(cmap_table[i].format_type) {\n            case LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL: {\n                    uint8_t ids_size = sizeof(uint8_t) * cmap_table[i].data_entries_count;\n                    uint8_t * glyph_id_ofs_list = lv_mem_alloc(ids_size);\n\n                    cmap->glyph_id_ofs_list = glyph_id_ofs_list;\n\n                    if(lv_fs_read(fp, glyph_id_ofs_list, ids_size, NULL) != LV_FS_RES_OK) {\n                        return false;\n                    }\n\n                    cmap->list_length = cmap->range_length;\n                    break;\n                }\n            case LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY:\n                break;\n            case LV_FONT_FMT_TXT_CMAP_SPARSE_FULL:\n            case LV_FONT_FMT_TXT_CMAP_SPARSE_TINY: {\n                    uint32_t list_size = sizeof(uint16_t) * cmap_table[i].data_entries_count;\n                    uint16_t * unicode_list = (uint16_t *)lv_mem_alloc(list_size);\n\n                    cmap->unicode_list = unicode_list;\n                    cmap->list_length = cmap_table[i].data_entries_count;\n\n                    if(lv_fs_read(fp, unicode_list, list_size, NULL) != LV_FS_RES_OK) {\n                        return false;\n                    }\n\n                    if(cmap_table[i].format_type == LV_FONT_FMT_TXT_CMAP_SPARSE_FULL) {\n                        uint16_t * buf = lv_mem_alloc(sizeof(uint16_t) * cmap->list_length);\n\n                        cmap->glyph_id_ofs_list = buf;\n\n                        if(lv_fs_read(fp, buf, sizeof(uint16_t) * cmap->list_length, NULL) != LV_FS_RES_OK) {\n                            return false;\n                        }\n                    }\n                    break;\n                }\n            default:\n                LV_LOG_WARN(\"Unknown cmaps format type %d.\", cmap_table[i].format_type);\n                return false;\n        }\n    }\n    return true;\n}"}, "load_cmaps": {"type": "Function", "def": "static int32_t load_cmaps(lv_fs_file_t * fp, lv_font_fmt_txt_dsc_t * font_dsc, uint32_t cmaps_start)", "sline": 309, "body": "{\n    int32_t cmaps_length = read_label(fp, cmaps_start, \"cmap\");\n    if(cmaps_length < 0) {\n        return -1;\n    }\n\n    uint32_t cmaps_subtables_count;\n    if(lv_fs_read(fp, &cmaps_subtables_count, sizeof(uint32_t), NULL) != LV_FS_RES_OK) {\n        return -1;\n    }\n\n    lv_font_fmt_txt_cmap_t * cmaps =\n        lv_mem_alloc(cmaps_subtables_count * sizeof(lv_font_fmt_txt_cmap_t));\n\n    memset(cmaps, 0, cmaps_subtables_count * sizeof(lv_font_fmt_txt_cmap_t));\n\n    font_dsc->cmaps = cmaps;\n    font_dsc->cmap_num = cmaps_subtables_count;\n\n    cmap_table_bin_t * cmaps_tables = lv_mem_alloc(sizeof(cmap_table_bin_t) * font_dsc->cmap_num);\n\n    bool success = load_cmaps_tables(fp, font_dsc, cmaps_start, cmaps_tables);\n\n    lv_mem_free(cmaps_tables);\n\n    return success ? cmaps_length : -1;\n}"}, "load_glyph": {"type": "Function", "def": "static int32_t load_glyph(lv_fs_file_t * fp, lv_font_fmt_txt_dsc_t * font_dsc,\n                          uint32_t start, uint32_t * glyph_offset, uint32_t loca_count, font_header_bin_t * header)", "sline": 338, "body": "{\n    int32_t glyph_length = read_label(fp, start, \"glyf\");\n    if(glyph_length < 0) {\n        return -1;\n    }\n\n    lv_font_fmt_txt_glyph_dsc_t * glyph_dsc = (lv_font_fmt_txt_glyph_dsc_t *)\n                                              lv_mem_alloc(loca_count * sizeof(lv_font_fmt_txt_glyph_dsc_t));\n\n    memset(glyph_dsc, 0, loca_count * sizeof(lv_font_fmt_txt_glyph_dsc_t));\n\n    font_dsc->glyph_dsc = glyph_dsc;\n\n    int cur_bmp_size = 0;\n\n    for(unsigned int i = 0; i < loca_count; ++i) {\n        lv_font_fmt_txt_glyph_dsc_t * gdsc = &glyph_dsc[i];\n\n        lv_fs_res_t res = lv_fs_seek(fp, start + glyph_offset[i], LV_FS_SEEK_SET);\n        if(res != LV_FS_RES_OK) {\n            return -1;\n        }\n\n        bit_iterator_t bit_it = init_bit_iterator(fp);\n\n        if(header->advance_width_bits == 0) {\n            gdsc->adv_w = header->default_advance_width;\n        }\n        else {\n            gdsc->adv_w = read_bits(&bit_it, header->advance_width_bits, &res);\n            if(res != LV_FS_RES_OK) {\n                return -1;\n            }\n        }\n\n        if(header->advance_width_format == 0) {\n            gdsc->adv_w *= 16;\n        }\n\n        gdsc->ofs_x = read_bits_signed(&bit_it, header->xy_bits, &res);\n        if(res != LV_FS_RES_OK) {\n            return -1;\n        }\n\n        gdsc->ofs_y = read_bits_signed(&bit_it, header->xy_bits, &res);\n        if(res != LV_FS_RES_OK) {\n            return -1;\n        }\n\n        gdsc->box_w = read_bits(&bit_it, header->wh_bits, &res);\n        if(res != LV_FS_RES_OK) {\n            return -1;\n        }\n\n        gdsc->box_h = read_bits(&bit_it, header->wh_bits, &res);\n        if(res != LV_FS_RES_OK) {\n            return -1;\n        }\n\n        int nbits = header->advance_width_bits + 2 * header->xy_bits + 2 * header->wh_bits;\n        int next_offset = (i < loca_count - 1) ? glyph_offset[i + 1] : (uint32_t)glyph_length;\n        int bmp_size = next_offset - glyph_offset[i] - nbits / 8;\n\n        if(i == 0) {\n            gdsc->adv_w = 0;\n            gdsc->box_w = 0;\n            gdsc->box_h = 0;\n            gdsc->ofs_x = 0;\n            gdsc->ofs_y = 0;\n        }\n\n        gdsc->bitmap_index = cur_bmp_size;\n        if(gdsc->box_w * gdsc->box_h != 0) {\n            cur_bmp_size += bmp_size;\n        }\n    }\n\n    uint8_t * glyph_bmp = (uint8_t *)lv_mem_alloc(sizeof(uint8_t) * cur_bmp_size);\n\n    font_dsc->glyph_bitmap = glyph_bmp;\n\n    cur_bmp_size = 0;\n\n    for(unsigned int i = 1; i < loca_count; ++i) {\n        lv_fs_res_t res = lv_fs_seek(fp, start + glyph_offset[i], LV_FS_SEEK_SET);\n        if(res != LV_FS_RES_OK) {\n            return -1;\n        }\n        bit_iterator_t bit_it = init_bit_iterator(fp);\n\n        int nbits = header->advance_width_bits + 2 * header->xy_bits + 2 * header->wh_bits;\n\n        read_bits(&bit_it, nbits, &res);\n        if(res != LV_FS_RES_OK) {\n            return -1;\n        }\n\n        if(glyph_dsc[i].box_w * glyph_dsc[i].box_h == 0) {\n            continue;\n        }\n\n        int next_offset = (i < loca_count - 1) ? glyph_offset[i + 1] : (uint32_t)glyph_length;\n        int bmp_size = next_offset - glyph_offset[i] - nbits / 8;\n\n        if(nbits % 8 == 0) {  /*Fast path*/\n            if(lv_fs_read(fp, &glyph_bmp[cur_bmp_size], bmp_size, NULL) != LV_FS_RES_OK) {\n                return -1;\n            }\n        }\n        else {\n            for(int k = 0; k < bmp_size - 1; ++k) {\n                glyph_bmp[cur_bmp_size + k] = read_bits(&bit_it, 8, &res);\n                if(res != LV_FS_RES_OK) {\n                    return -1;\n                }\n            }\n            glyph_bmp[cur_bmp_size + bmp_size - 1] = read_bits(&bit_it, 8 - nbits % 8, &res);\n            if(res != LV_FS_RES_OK) {\n                return -1;\n            }\n\n            /*The last fragment should be on the MSB but read_bits() will place it to the LSB*/\n            glyph_bmp[cur_bmp_size + bmp_size - 1] = glyph_bmp[cur_bmp_size + bmp_size - 1] << (nbits % 8);\n\n        }\n\n        cur_bmp_size += bmp_size;\n    }\n    return glyph_length;\n}"}, "carbit_updater/lvgl/src/font/lv_font_loader.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_loader.c"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_32.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_montserrat_32.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_32.c"}}, "carbit_updater/lvgl/src/misc/lv_gc.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 17}, "lv_mem": {"type": "Variable", "def": "#include lv_mem.h", "sline": 18, "include": ["carbit_updater/lvgl/src/misc/lv_mem.h", null]}, "lv_ll": {"type": "Variable", "def": "#include lv_ll.h", "sline": 19, "include": ["carbit_updater/lvgl/src/misc/lv_ll.h", null]}, "lv_timer": {"type": "Variable", "def": "#include lv_timer.h", "sline": 20, "include": ["carbit_updater/lvgl/src/misc/lv_timer.h", null]}, "lv_types": {"type": "Variable", "def": "#include lv_types.h", "sline": 21, "include": ["carbit_updater/lvgl/src/misc/lv_types.h", null]}, "lv_img_cache": {"type": "Variable", "def": "#include ../draw/lv_img_cache.h", "sline": 22}, "lv_draw_mask": {"type": "Variable", "def": "#include ../draw/lv_draw_mask.h", "sline": 23}, "lv_obj_pos": {"type": "Variable", "def": "#include ../core/lv_obj_pos.h", "sline": 24}, "_lv_timer_ll": {"type": "Variable", "def": "", "sline": 73}, "_lv_disp_ll": {"type": "Variable", "def": "", "sline": 73}, "_lv_indev_ll": {"type": "Variable", "def": "", "sline": 73}, "_lv_fsdrv_ll": {"type": "Variable", "def": "", "sline": 73}, "_lv_anim_ll": {"type": "Variable", "def": "", "sline": 73}, "_lv_group_ll": {"type": "Variable", "def": "", "sline": 73}, "_lv_img_decoder_ll": {"type": "Variable", "def": "", "sline": 73}, "_lv_obj_style_trans_ll": {"type": "Variable", "def": "", "sline": 73}, "_lv_layout_list": {"type": "Variable", "def": "", "sline": 73}, "_lv_img_cache_single": {"type": "Variable", "def": "", "sline": 73}, "_lv_timer_act": {"type": "Variable", "def": "", "sline": 73}, "lv_mem_buf": {"type": "Variable", "def": "", "sline": 73}, "_lv_circle_cache": {"type": "Variable", "def": "", "sline": 73}, "_lv_draw_mask_list": {"type": "Variable", "def": "", "sline": 73}, "_lv_theme_default_styles": {"type": "Variable", "def": "", "sline": 73}, "_lv_gc_clear_roots": {"type": "Function", "def": "void _lv_gc_clear_roots(void)", "sline": 84}, "carbit_updater/lvgl/src/misc/lv_gc.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_gc.h"}}, "carbit_updater/lvgl/src/misc/lv_gc.c": {"lv_gc": {"type": "Variable", "def": "#include lv_gc.h", "sline": 9, "include": ["carbit_updater/lvgl/src/misc/lv_gc.h", null]}, "_lv_timer_ll": {"type": "Variable", "def": "", "sline": 28}, "_lv_disp_ll": {"type": "Variable", "def": "", "sline": 28}, "_lv_indev_ll": {"type": "Variable", "def": "", "sline": 28}, "_lv_fsdrv_ll": {"type": "Variable", "def": "", "sline": 28}, "_lv_anim_ll": {"type": "Variable", "def": "", "sline": 28}, "_lv_group_ll": {"type": "Variable", "def": "", "sline": 28}, "_lv_img_decoder_ll": {"type": "Variable", "def": "", "sline": 28}, "_lv_obj_style_trans_ll": {"type": "Variable", "def": "", "sline": 28}, "_lv_layout_list": {"type": "Variable", "def": "", "sline": 28}, "_lv_img_cache_single": {"type": "Variable", "def": "", "sline": 28}, "_lv_timer_act": {"type": "Variable", "def": "", "sline": 28}, "lv_mem_buf": {"type": "Variable", "def": "", "sline": 28}, "_lv_circle_cache": {"type": "Variable", "def": "", "sline": 28}, "_lv_draw_mask_list": {"type": "Variable", "def": "", "sline": 28}, "_lv_theme_default_styles": {"type": "Variable", "def": "", "sline": 28}, "_lv_gc_clear_roots": {"type": "Function", "def": "void _lv_gc_clear_roots(void)", "sline": 39, "body": "{\n#define LV_CLEAR_ROOT(root_type, root_name) lv_memset_00(&LV_GC_ROOT(root_name), sizeof(LV_GC_ROOT(root_name)));\n    LV_ITERATE_ROOTS(LV_CLEAR_ROOT)\n}"}, "carbit_updater/lvgl/src/misc/lv_gc.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_gc.c"}}, "carbit_updater/lv_drivers/indev/FT5406EE8.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 20}, "carbit_updater/lv_drivers/indev/FT5406EE8.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/indev/FT5406EE8.h"}}, "carbit_updater/lvgl/src/extra/libs/fsdrv/lv_fs_stdio.c": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/extra/libs/fsdrv/lv_fs_stdio.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/fsdrv/lv_fs_stdio.c"}}, "carbit_updater/lvgl/src/extra/widgets/win/lv_win.c": {"lv_win": {"type": "Variable", "def": "#include lv_win.h", "sline": 9, "include": ["carbit_updater/lvgl/src/extra/widgets/win/lv_win.h", null]}, "lv_win_constructor": {"type": "Function", "def": "static void lv_win_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 92, "body": "{\n    LV_UNUSED(class_p);\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    lv_obj_set_size(obj, lv_obj_get_width(parent), lv_obj_get_height(parent));\n    lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_COLUMN);\n\n    lv_obj_t * header = lv_obj_create(obj);\n    lv_obj_set_size(header, LV_PCT(100), create_header_height);\n    lv_obj_set_flex_flow(header, LV_FLEX_FLOW_ROW);\n    lv_obj_set_flex_align(header, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);\n\n    lv_obj_t * cont = lv_obj_create(obj);\n    lv_obj_set_flex_grow(cont, 1);\n    lv_obj_set_width(cont, LV_PCT(100));\n}"}, "lv_win_class": {"type": "Variable", "def": "const lv_obj_class_t lv_win_class = {\n    .constructor_cb = lv_win_constructor,\n    .width_def = LV_PCT(100),\n    .height_def = LV_PCT(100),\n    .base_class = &lv_obj_class,\n    .instance_size = sizeof(lv_win_t)\n}", "sline": 29}, "create_header_height": {"type": "Variable", "def": "static lv_coord_t create_header_height", "sline": 36}, "lv_win_create": {"type": "Function", "def": "lv_obj_t * lv_win_create(lv_obj_t * parent, lv_coord_t header_height)", "sline": 45, "body": "{\n    LV_LOG_INFO(\"begin\");\n    create_header_height = header_height;\n\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_win_class, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_win_add_title": {"type": "Function", "def": "lv_obj_t * lv_win_add_title(lv_obj_t * win, const char * txt)", "sline": 55, "body": "{\n    lv_obj_t * header = lv_win_get_header(win);\n    lv_obj_t * title = lv_label_create(header);\n    lv_label_set_long_mode(title, LV_LABEL_LONG_DOT);\n    lv_label_set_text(title, txt);\n    lv_obj_set_flex_grow(title, 1);\n    return title;\n}"}, "lv_win_add_btn": {"type": "Function", "def": "lv_obj_t * lv_win_add_btn(lv_obj_t * win, const void * icon, lv_coord_t btn_w)", "sline": 65, "body": "{\n    lv_obj_t * header = lv_win_get_header(win);\n    lv_obj_t * btn = lv_btn_create(header);\n    lv_obj_set_size(btn, btn_w, LV_PCT(100));\n\n    lv_obj_t * img = lv_img_create(btn);\n    lv_img_set_src(img, icon);\n    lv_obj_align(img, LV_ALIGN_CENTER, 0, 0);\n\n    return btn;\n}"}, "lv_win_get_header": {"type": "Function", "def": "lv_obj_t * lv_win_get_header(lv_obj_t * win)", "sline": 78, "body": "{\n    return lv_obj_get_child(win, 0);\n}"}, "lv_win_get_content": {"type": "Function", "def": "lv_obj_t * lv_win_get_content(lv_obj_t * win)", "sline": 83, "body": "{\n    return lv_obj_get_child(win, 1);\n}"}, "carbit_updater/lvgl/src/extra/widgets/win/lv_win.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/win/lv_win.c"}}, "carbit_updater/lvgl/src/extra/libs/bmp/lv_bmp.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../../../lv_conf_internal.h", "sline": 16}, "carbit_updater/lvgl/src/extra/libs/bmp/lv_bmp.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/bmp/lv_bmp.h"}}, "carbit_updater/lvgl/src/widgets/lv_table.c": {"lv_table": {"type": "Variable", "def": "#include lv_table.h", "sline": 9, "include": ["carbit_updater/lvgl/src/widgets/lv_table.h", null]}, "lv_indev": {"type": "Variable", "def": "#include ../core/lv_indev.h", "sline": 12}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 13}, "lv_txt": {"type": "Variable", "def": "#include ../misc/lv_txt.h", "sline": 14}, "lv_txt_ap": {"type": "Variable", "def": "#include ../misc/lv_txt_ap.h", "sline": 15}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 16}, "lv_printf": {"type": "Variable", "def": "#include ../misc/lv_printf.h", "sline": 17}, "lv_draw": {"type": "Variable", "def": "#include ../draw/lv_draw.h", "sline": 18}, "lv_table_constructor": {"type": "Function", "def": "static void lv_table_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 433, "body": "{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_table_t * table = (lv_table_t *)obj;\n\n    table->col_cnt = 1;\n    table->row_cnt = 1;\n    table->col_w = lv_mem_alloc(table->col_cnt * sizeof(table->col_w[0]));\n    table->row_h = lv_mem_alloc(table->row_cnt * sizeof(table->row_h[0]));\n    table->col_w[0] = LV_DPI_DEF;\n    table->row_h[0] = LV_DPI_DEF;\n    table->cell_data = lv_mem_realloc(table->cell_data, table->row_cnt * table->col_cnt * sizeof(char *));\n    table->cell_data[0] = NULL;\n\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}"}, "lv_table_destructor": {"type": "Function", "def": "static void lv_table_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 452, "body": "{\n    LV_UNUSED(class_p);\n    lv_table_t * table = (lv_table_t *)obj;\n    /*Free the cell texts*/\n    uint16_t i;\n    for(i = 0; i < table->col_cnt * table->row_cnt; i++) {\n        if(table->cell_data[i]) {\n            lv_mem_free(table->cell_data[i]);\n            table->cell_data[i] = NULL;\n        }\n    }\n\n    if(table->cell_data) lv_mem_free(table->cell_data);\n    if(table->row_h) lv_mem_free(table->row_h);\n    if(table->col_w) lv_mem_free(table->col_w);\n}"}, "lv_table_event": {"type": "Function", "def": "static void lv_table_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 470, "body": "{\n    LV_UNUSED(class_p);\n\n    lv_res_t res;\n\n    /*Call the ancestor's event handler*/\n    res = lv_obj_event_base(MY_CLASS, e);\n    if(res != LV_RES_OK) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_table_t * table = (lv_table_t *)obj;\n\n    if(code == LV_EVENT_STYLE_CHANGED) {\n        refr_size(obj, 0);\n    }\n    else if(code == LV_EVENT_GET_SELF_SIZE) {\n        lv_point_t * p = lv_event_get_param(e);\n        uint32_t i;\n        lv_coord_t w = 0;\n        for(i = 0; i < table->col_cnt; i++) w += table->col_w[i];\n\n        lv_coord_t h = 0;\n        for(i = 0; i < table->row_cnt; i++) h += table->row_h[i];\n\n        p->x = w - 1;\n        p->y = h - 1;\n    }\n    else if(code == LV_EVENT_PRESSED || code == LV_EVENT_PRESSING) {\n        uint16_t col;\n        uint16_t row;\n        lv_res_t pr_res = get_pressed_cell(obj, &row, &col);\n\n        if(pr_res == LV_RES_OK && (table->col_act != col || table->row_act != row)) {\n            table->col_act = col;\n            table->row_act = row;\n            lv_obj_invalidate(obj);\n        }\n    }\n    else if(code == LV_EVENT_RELEASED) {\n        lv_obj_invalidate(obj);\n        lv_indev_t * indev = lv_indev_get_act();\n        lv_obj_t * scroll_obj = lv_indev_get_scroll_obj(indev);\n        if(table->col_act != LV_TABLE_CELL_NONE && table->row_act != LV_TABLE_CELL_NONE && scroll_obj == NULL) {\n            res = lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n            if(res != LV_RES_OK) return;\n        }\n\n        lv_indev_type_t indev_type = lv_indev_get_type(lv_indev_get_act());\n        if(indev_type == LV_INDEV_TYPE_POINTER || indev_type == LV_INDEV_TYPE_BUTTON) {\n            table->col_act = LV_TABLE_CELL_NONE;\n            table->row_act = LV_TABLE_CELL_NONE;\n        }\n    }\n    else if(code == LV_EVENT_FOCUSED) {\n        lv_obj_invalidate(obj);\n    }\n    else if(code == LV_EVENT_KEY) {\n        int32_t c = *((int32_t *)lv_event_get_param(e));\n        int32_t col = table->col_act;\n        int32_t row = table->row_act;\n        if(col == LV_TABLE_CELL_NONE || row == LV_TABLE_CELL_NONE) {\n            table->col_act = 0;\n            table->row_act = 0;\n            lv_obj_invalidate(obj);\n            return;\n        }\n\n        if(col >= table->col_cnt) col = 0;\n        if(row >= table->row_cnt) row = 0;\n\n        if(c == LV_KEY_LEFT) col--;\n        else if(c == LV_KEY_RIGHT) col++;\n        else if(c == LV_KEY_UP) row--;\n        else if(c == LV_KEY_DOWN) row++;\n        else return;\n\n        if(col >= table->col_cnt) {\n            if(row < table->row_cnt - 1) {\n                col = 0;\n                row++;\n            }\n            else {\n                col = table->col_cnt - 1;\n            }\n        }\n        else if(col < 0) {\n            if(row != 0) {\n                col = table->col_cnt - 1;\n                row--;\n            }\n            else {\n                col = 0;\n            }\n        }\n\n        if(row >= table->row_cnt) {\n            row = table->row_cnt - 1;\n        }\n        else if(row < 0) {\n            row = 0;\n        }\n\n        if(table->col_act != col || table->row_act != row) {\n            table->col_act = col;\n            table->row_act = row;\n            lv_obj_invalidate(obj);\n\n            res = lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n            if(res != LV_RES_OK) return;\n        }\n    }\n    else if(code == LV_EVENT_DRAW_MAIN) {\n        draw_main(e);\n    }\n}"}, "draw_main": {"type": "Function", "def": "static void draw_main(lv_event_t * e)", "sline": 589, "body": "{\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_table_t * table = (lv_table_t *)obj;\n    const lv_area_t * clip_area_ori = lv_event_get_param(e);\n    lv_area_t clip_area;\n    if(!_lv_area_intersect(&clip_area, &obj->coords, clip_area_ori)) return;\n\n    lv_point_t txt_size;\n    lv_area_t cell_area;\n    lv_area_t txt_area;\n    lv_text_flag_t txt_flags;\n\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n    lv_coord_t bg_top = lv_obj_get_style_pad_top(obj, LV_PART_MAIN);\n    lv_coord_t bg_bottom = lv_obj_get_style_pad_bottom(obj, LV_PART_MAIN);\n    lv_coord_t bg_left = lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n    lv_coord_t bg_right = lv_obj_get_style_pad_right(obj, LV_PART_MAIN);\n\n    lv_coord_t cell_left = lv_obj_get_style_pad_left(obj, LV_PART_ITEMS);\n    lv_coord_t cell_right = lv_obj_get_style_pad_right(obj, LV_PART_ITEMS);\n    lv_coord_t cell_top = lv_obj_get_style_pad_top(obj, LV_PART_ITEMS);\n    lv_coord_t cell_bottom = lv_obj_get_style_pad_bottom(obj, LV_PART_ITEMS);\n\n    lv_state_t state_ori = obj->state;\n    obj->state = LV_STATE_DEFAULT;\n    obj->skip_trans = 1;\n    lv_draw_rect_dsc_t rect_dsc_def;\n    lv_draw_rect_dsc_t rect_dsc_act; /*Passed to the event to modify it*/\n    lv_draw_rect_dsc_init(&rect_dsc_def);\n    lv_obj_init_draw_rect_dsc(obj, LV_PART_ITEMS, &rect_dsc_def);\n\n    lv_draw_label_dsc_t label_dsc_def;\n    lv_draw_label_dsc_t label_dsc_act;  /*Passed to the event to modify it*/\n    lv_draw_label_dsc_init(&label_dsc_def);\n    lv_obj_init_draw_label_dsc(obj, LV_PART_ITEMS, &label_dsc_def);\n    obj->state = state_ori;\n    obj->skip_trans = 0;\n\n    uint16_t col;\n    uint16_t row;\n    uint16_t cell = 0;\n\n    cell_area.y2 = obj->coords.y1 + bg_top - 1 - lv_obj_get_scroll_y(obj) + border_width;\n    lv_coord_t scroll_x = lv_obj_get_scroll_x(obj) ;\n    bool rtl = lv_obj_get_style_base_dir(obj, LV_PART_MAIN) == LV_BASE_DIR_RTL ? true : false;\n\n    /*Handle custom drawer*/\n    lv_obj_draw_part_dsc_t part_draw_dsc;\n    lv_obj_draw_dsc_init(&part_draw_dsc, &clip_area);\n    part_draw_dsc.part = LV_PART_ITEMS;\n    part_draw_dsc.class_p = MY_CLASS;\n    part_draw_dsc.type = LV_TABLE_DRAW_PART_CELL;\n    part_draw_dsc.rect_dsc = &rect_dsc_act;\n    part_draw_dsc.label_dsc = &label_dsc_act;\n\n    for(row = 0; row < table->row_cnt; row++) {\n        lv_coord_t h_row = table->row_h[row];\n\n        cell_area.y1 = cell_area.y2 + 1;\n        cell_area.y2 = cell_area.y1 + h_row - 1;\n\n        if(cell_area.y1 > clip_area.y2) return;\n\n        if(rtl) cell_area.x1 = obj->coords.x2 - bg_right - 1 - scroll_x - border_width;\n        else cell_area.x2 = obj->coords.x1 + bg_left - 1 - scroll_x + border_width;\n\n        for(col = 0; col < table->col_cnt; col++) {\n            lv_table_cell_ctrl_t ctrl = 0;\n            if(table->cell_data[cell]) ctrl = table->cell_data[cell][0];\n\n            if(rtl) {\n                cell_area.x2 = cell_area.x1 - 1;\n                cell_area.x1 = cell_area.x2 - table->col_w[col] + 1;\n            }\n            else {\n                cell_area.x1 = cell_area.x2 + 1;\n                cell_area.x2 = cell_area.x1 + table->col_w[col] - 1;\n            }\n\n            uint16_t col_merge = 0;\n            for(col_merge = 0; col_merge + col < table->col_cnt - 1; col_merge++) {\n                if(table->cell_data[cell + col_merge]) {\n                    char * next_cell_data = table->cell_data[cell + col_merge];\n                    if(next_cell_data) ctrl = next_cell_data[0];\n                    if(ctrl & LV_TABLE_CELL_CTRL_MERGE_RIGHT)\n                        if(rtl) cell_area.x1 -= table->col_w[col + col_merge + 1];\n                        else cell_area.x2 += table->col_w[col + col_merge + 1];\n                    else {\n                        break;\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n\n            if(cell_area.y2 < clip_area.y1) {\n                cell += col_merge + 1;\n                col += col_merge;\n                continue;\n            }\n\n            /*Expand the cell area with a half border to avoid drawing 2 borders next to each other*/\n            lv_area_t cell_area_border;\n            lv_area_copy(&cell_area_border, &cell_area);\n            if((rect_dsc_def.border_side & LV_BORDER_SIDE_LEFT) && cell_area_border.x1 > obj->coords.x1 + bg_left) {\n                cell_area_border.x1 -= rect_dsc_def.border_width / 2;\n            }\n            if((rect_dsc_def.border_side & LV_BORDER_SIDE_TOP) && cell_area_border.y1 > obj->coords.y1 + bg_top) {\n                cell_area_border.y1 -= rect_dsc_def.border_width / 2;\n            }\n            if((rect_dsc_def.border_side & LV_BORDER_SIDE_RIGHT) && cell_area_border.x2 < obj->coords.x2 - bg_right - 1) {\n                cell_area_border.x2 += rect_dsc_def.border_width / 2 + (rect_dsc_def.border_width & 0x1);\n            }\n            if((rect_dsc_def.border_side & LV_BORDER_SIDE_BOTTOM) &&\n               cell_area_border.y2 < obj->coords.y2 - bg_bottom - 1) {\n                cell_area_border.y2 += rect_dsc_def.border_width / 2 + (rect_dsc_def.border_width & 0x1);\n            }\n\n            lv_state_t cell_state = LV_STATE_DEFAULT;\n            if(row == table->row_act && col == table->col_act) {\n                if(!(obj->state & LV_STATE_SCROLLED) && (obj->state & LV_STATE_PRESSED)) cell_state |= LV_STATE_PRESSED;\n                if(obj->state & LV_STATE_FOCUSED) cell_state |= LV_STATE_FOCUSED;\n                if(obj->state & LV_STATE_FOCUS_KEY) cell_state |= LV_STATE_FOCUS_KEY;\n                if(obj->state & LV_STATE_EDITED) cell_state |= LV_STATE_EDITED;\n            }\n\n            /*Set up the draw descriptors*/\n            if(cell_state == LV_STATE_DEFAULT) {\n                lv_memcpy(&rect_dsc_act, &rect_dsc_def, sizeof(lv_draw_rect_dsc_t));\n                lv_memcpy(&label_dsc_act, &label_dsc_def, sizeof(lv_draw_label_dsc_t));\n            }\n            /*In other cases get the styles directly without caching them*/\n            else {\n                obj->state = cell_state;\n                obj->skip_trans = 1;\n                lv_draw_rect_dsc_init(&rect_dsc_act);\n                lv_draw_label_dsc_init(&label_dsc_act);\n                lv_obj_init_draw_rect_dsc(obj, LV_PART_ITEMS, &rect_dsc_act);\n                lv_obj_init_draw_label_dsc(obj, LV_PART_ITEMS, &label_dsc_act);\n                obj->state = state_ori;\n                obj->skip_trans = 0;\n            }\n\n            part_draw_dsc.draw_area = &cell_area_border;\n            part_draw_dsc.id = row * table->col_cnt + col;\n            lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n\n            lv_draw_rect(&cell_area_border, &clip_area, &rect_dsc_act);\n\n            if(table->cell_data[cell]) {\n                txt_area.x1 = cell_area.x1 + cell_left;\n                txt_area.x2 = cell_area.x2 - cell_right;\n                txt_area.y1 = cell_area.y1 + cell_top;\n                txt_area.y2 = cell_area.y2 - cell_bottom;\n\n                /*Align the content to the middle if not cropped*/\n                bool crop = ctrl & LV_TABLE_CELL_CTRL_TEXT_CROP ? true : false;\n                if(crop) txt_flags = LV_TEXT_FLAG_EXPAND;\n                else txt_flags = LV_TEXT_FLAG_NONE;\n\n                lv_txt_get_size(&txt_size, table->cell_data[cell] + 1, label_dsc_def.font,\n                                label_dsc_act.letter_space, label_dsc_act.line_space,\n                                lv_area_get_width(&txt_area), txt_flags);\n\n                /*Align the content to the middle if not cropped*/\n                if(!crop) {\n                    txt_area.y1 = cell_area.y1 + h_row / 2 - txt_size.y / 2;\n                    txt_area.y2 = cell_area.y1 + h_row / 2 + txt_size.y / 2;\n                }\n\n                lv_area_t label_mask;\n                bool label_mask_ok;\n                label_mask_ok = _lv_area_intersect(&label_mask, &clip_area, &cell_area);\n                if(label_mask_ok) {\n                    lv_draw_label(&txt_area, &label_mask, &label_dsc_act, table->cell_data[cell] + 1, NULL);\n                }\n            }\n\n            lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n\n            cell += col_merge + 1;\n            col += col_merge;\n        }\n    }\n}"}, "get_row_height": {"type": "Function", "def": "static lv_coord_t get_row_height(lv_obj_t * obj, uint16_t row_id, const lv_font_t * font,\n                                 lv_coord_t letter_space, lv_coord_t line_space,\n                                 lv_coord_t cell_left, lv_coord_t cell_right, lv_coord_t cell_top, lv_coord_t cell_bottom)", "sline": 804, "body": "{\n    lv_table_t * table = (lv_table_t *)obj;\n    lv_point_t txt_size;\n    lv_coord_t txt_w;\n\n    uint16_t row_start = row_id * table->col_cnt;\n    uint16_t cell;\n    uint16_t col;\n    lv_coord_t h_max = lv_font_get_line_height(font) + cell_top + cell_bottom;\n\n    for(cell = row_start, col = 0; cell < row_start + table->col_cnt; cell++, col++) {\n        if(table->cell_data[cell] != NULL) {\n            txt_w              = table->col_w[col];\n            uint16_t col_merge = 0;\n            for(col_merge = 0; col_merge + col < table->col_cnt - 1; col_merge++) {\n\n                if(table->cell_data[cell + col_merge] != NULL) {\n                    lv_table_cell_ctrl_t ctrl = 0;\n                    char * next_cell_data = table->cell_data[cell + col_merge];\n                    if(next_cell_data) ctrl = next_cell_data[0];\n                    if(ctrl & LV_TABLE_CELL_CTRL_MERGE_RIGHT)\n                        txt_w += table->col_w[col + col_merge + 1];\n                    else\n                        break;\n                }\n                else {\n                    break;\n                }\n            }\n\n            lv_table_cell_ctrl_t ctrl = 0;\n            if(table->cell_data[cell]) ctrl = table->cell_data[cell][0];\n\n            /*With text crop assume 1 line*/\n            if(ctrl & LV_TABLE_CELL_CTRL_TEXT_CROP) {\n                h_max = LV_MAX(lv_font_get_line_height(font) + cell_top + cell_bottom,\n                               h_max);\n            }\n            /*Without text crop calculate the height of the text in the cell*/\n            else {\n                txt_w -= cell_left + cell_right;\n\n                lv_txt_get_size(&txt_size, table->cell_data[cell] + 1, font,\n                                letter_space, line_space, txt_w, LV_TEXT_FLAG_NONE);\n\n                h_max = LV_MAX(txt_size.y + cell_top + cell_bottom, h_max);\n                cell += col_merge;\n                col += col_merge;\n            }\n        }\n    }\n\n    return h_max;\n}"}, "refr_size": {"type": "Function", "def": "static void refr_size(lv_obj_t * obj, uint32_t strat_row)", "sline": 777, "body": "{\n    lv_table_t * table = (lv_table_t *)obj;\n\n    uint32_t i;\n\n    lv_coord_t cell_left = lv_obj_get_style_pad_left(obj, LV_PART_ITEMS);\n    lv_coord_t cell_right = lv_obj_get_style_pad_right(obj, LV_PART_ITEMS);\n    lv_coord_t cell_top = lv_obj_get_style_pad_top(obj, LV_PART_ITEMS);\n    lv_coord_t cell_bottom = lv_obj_get_style_pad_bottom(obj, LV_PART_ITEMS);\n\n    lv_coord_t letter_space = lv_obj_get_style_text_letter_space(obj, LV_PART_ITEMS);\n    lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_ITEMS);\n    const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_ITEMS);\n\n    lv_coord_t minh = lv_obj_get_style_min_height(obj, LV_PART_ITEMS);\n    lv_coord_t maxh = lv_obj_get_style_max_height(obj, LV_PART_ITEMS);\n\n    for(i = strat_row; i < table->row_cnt; i++) {\n        table->row_h[i] = get_row_height(obj, i, font, letter_space, line_space,\n                                         cell_left, cell_right, cell_top, cell_bottom);\n        table->row_h[i] = LV_CLAMP(minh, table->row_h[i], maxh);\n    }\n\n    lv_obj_refresh_self_size(obj) ;\n}"}, "get_pressed_cell": {"type": "Function", "def": "static lv_res_t get_pressed_cell(lv_obj_t * obj, uint16_t * row, uint16_t * col)", "sline": 862, "body": "{\n    lv_table_t * table = (lv_table_t *)obj;\n\n    lv_indev_type_t type = lv_indev_get_type(lv_indev_get_act());\n    if(type != LV_INDEV_TYPE_POINTER && type != LV_INDEV_TYPE_BUTTON) {\n        if(col) *col = LV_TABLE_CELL_NONE;\n        if(row) *row = LV_TABLE_CELL_NONE;\n        return LV_RES_INV;\n    }\n\n    lv_point_t p;\n    lv_indev_get_point(lv_indev_get_act(), &p);\n\n    lv_coord_t tmp;\n    if(col) {\n        lv_coord_t x = p.x + lv_obj_get_scroll_x(obj);\n\n        if(lv_obj_get_style_base_dir(obj, LV_PART_MAIN) == LV_BASE_DIR_RTL) {\n            x = obj->coords.x2 - lv_obj_get_style_pad_right(obj, LV_PART_MAIN) - x;\n        }\n        else {\n            x -= obj->coords.x1;\n            x -= lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n        }\n\n        *col = 0;\n        tmp = 0;\n        for(*col = 0; *col < table->col_cnt; (*col)++) {\n            tmp += table->col_w[*col];\n            if(x < tmp) break;\n        }\n    }\n\n    if(row) {\n        lv_coord_t y = p.y + lv_obj_get_scroll_y(obj);;\n        y -= obj->coords.y1;\n        y -= lv_obj_get_style_pad_top(obj, LV_PART_MAIN);\n\n        *row = 0;\n        tmp = 0;\n\n        for(*row = 0; *row < table->row_cnt; (*row)++) {\n            tmp += table->row_h[*row];\n            if(y < tmp) break;\n        }\n    }\n\n    return LV_RES_OK;\n}"}, "lv_table_class": {"type": "Variable", "def": "const lv_obj_class_t lv_table_class  = {\n    .constructor_cb = lv_table_constructor,\n    .destructor_cb = lv_table_destructor,\n    .event_cb = lv_table_event,\n    .width_def = LV_SIZE_CONTENT,\n    .height_def = LV_SIZE_CONTENT,\n    .base_class = &lv_obj_class,\n    .editable = LV_OBJ_CLASS_EDITABLE_TRUE,\n    .group_def = LV_OBJ_CLASS_GROUP_DEF_TRUE,\n    .instance_size = sizeof(lv_table_t),\n}", "sline": 45}, "lv_table_create": {"type": "Function", "def": "lv_obj_t * lv_table_create(lv_obj_t * parent)", "sline": 64, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_table_set_cell_value": {"type": "Function", "def": "void lv_table_set_cell_value(lv_obj_t * obj, uint16_t row, uint16_t col, const char * txt)", "sline": 76, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(txt);\n\n    lv_table_t * table = (lv_table_t *)obj;\n\n    /*Auto expand*/\n    if(col >= table->col_cnt) lv_table_set_col_cnt(obj, col + 1);\n    if(row >= table->row_cnt) lv_table_set_row_cnt(obj, row + 1);\n\n    uint32_t cell = row * table->col_cnt + col;\n    lv_table_cell_ctrl_t ctrl = 0;\n\n    /*Save the control byte*/\n    if(table->cell_data[cell]) ctrl = table->cell_data[cell][0];\n\n#if LV_USE_ARABIC_PERSIAN_CHARS\n    /*Get the size of the Arabic text and process it*/\n    size_t len_ap = _lv_txt_ap_calc_bytes_cnt(txt);\n    table->cell_data[cell] = lv_mem_realloc(table->cell_data[cell], len_ap + 1);\n    LV_ASSERT_MALLOC(table->cell_data[cell]);\n    if(table->cell_data[cell] == NULL) return;\n\n    _lv_txt_ap_proc(txt, &table->cell_data[cell][1]);\n#else\n    table->cell_data[cell] = lv_mem_realloc(table->cell_data[cell], strlen(txt) + 2); /*+1: trailing '\\0; +1: format byte*/\n    LV_ASSERT_MALLOC(table->cell_data[cell]);\n\n    strcpy(table->cell_data[cell] + 1, txt);  /*+1 to skip the format byte*/\n#endif\n\n    table->cell_data[cell][0] = ctrl;\n    refr_size(obj, row);\n\n    lv_obj_invalidate(obj);\n}"}, "lv_table_set_cell_value_fmt": {"type": "Function", "def": "void lv_table_set_cell_value_fmt(lv_obj_t * obj, uint16_t row, uint16_t col, const char * fmt, ...)", "sline": 114, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(fmt);\n\n    lv_table_t * table = (lv_table_t *)obj;\n    if(col >= table->col_cnt) {\n        LV_LOG_WARN(\"lv_table_set_cell_value: invalid column\");\n        return;\n    }\n\n    /*Auto expand*/\n    if(row >= table->row_cnt) {\n        lv_table_set_row_cnt(obj, row + 1);\n    }\n\n    uint32_t cell = row * table->col_cnt + col;\n    lv_table_cell_ctrl_t ctrl = 0;\n\n    /*Save the control byte*/\n    if(table->cell_data[cell]) ctrl = table->cell_data[cell][0];\n\n    va_list ap, ap2;\n    va_start(ap, fmt);\n    va_copy(ap2, ap);\n\n    /*Allocate space for the new text by using trick from C99 standard section 7.19.6.12*/\n    uint32_t len = lv_vsnprintf(NULL, 0, fmt, ap);\n    va_end(ap);\n\n#if LV_USE_ARABIC_PERSIAN_CHARS\n    /*Put together the text according to the format string*/\n    char * raw_txt = lv_mem_buf_get(len + 1);\n    LV_ASSERT_MALLOC(raw_txt);\n    if(raw_txt == NULL) {\n        va_end(ap2);\n        return;\n    }\n\n    lv_vsnprintf(raw_txt, len + 1, fmt, ap2);\n\n    /*Get the size of the Arabic text and process it*/\n    size_t len_ap = _lv_txt_ap_calc_bytes_cnt(raw_txt);\n    table->cell_data[cell] = lv_mem_realloc(table->cell_data[cell], len_ap + 1);\n    LV_ASSERT_MALLOC(table->cell_data[cell]);\n    if(table->cell_data[cell] == NULL) {\n        va_end(ap2);\n        return;\n    }\n    _lv_txt_ap_proc(raw_txt, &table->cell_data[cell][1]);\n\n    lv_mem_buf_release(raw_txt);\n#else\n    table->cell_data[cell] = lv_mem_realloc(table->cell_data[cell], len + 2); /*+1: trailing '\\0; +1: format byte*/\n    LV_ASSERT_MALLOC(table->cell_data[cell]);\n    if(table->cell_data[cell] == NULL) {\n        va_end(ap2);\n        return;\n    }\n\n    table->cell_data[cell][len + 1] = 0; /*Ensure NULL termination*/\n\n    lv_vsnprintf(&table->cell_data[cell][1], len + 1, fmt, ap2);\n#endif\n\n    va_end(ap2);\n\n    table->cell_data[cell][0] = ctrl;\n\n    /*Refresh the row height*/\n    lv_coord_t cell_left = lv_obj_get_style_pad_left(obj, LV_PART_ITEMS);\n    lv_coord_t cell_right = lv_obj_get_style_pad_right(obj, LV_PART_ITEMS);\n    lv_coord_t cell_top = lv_obj_get_style_pad_top(obj, LV_PART_ITEMS);\n    lv_coord_t cell_bottom = lv_obj_get_style_pad_bottom(obj, LV_PART_ITEMS);\n\n    lv_coord_t letter_space = lv_obj_get_style_text_letter_space(obj, LV_PART_ITEMS);\n    lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_ITEMS);\n    const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_ITEMS);\n\n    lv_coord_t h = get_row_height(obj, row, font, letter_space, line_space,\n                                  cell_left, cell_right, cell_top, cell_bottom);\n\n\n    lv_coord_t minh = lv_obj_get_style_min_height(obj, LV_PART_ITEMS);\n    lv_coord_t maxh = lv_obj_get_style_max_height(obj, LV_PART_ITEMS);\n\n    table->row_h[row] = LV_CLAMP(minh, h, maxh);\n\n    lv_obj_invalidate(obj);\n}"}, "lv_table_set_row_cnt": {"type": "Function", "def": "void lv_table_set_row_cnt(lv_obj_t * obj, uint16_t row_cnt)", "sline": 205, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_table_t * table = (lv_table_t *)obj;\n    uint16_t old_row_cnt = table->row_cnt;\n    table->row_cnt         = row_cnt;\n\n    table->row_h = lv_mem_realloc(table->row_h, table->row_cnt * sizeof(table->row_h[0]));\n    LV_ASSERT_MALLOC(table->row_h);\n    if(table->row_h == NULL) return;\n\n    /*Free the unused cells*/\n    if(old_row_cnt > row_cnt) {\n        uint16_t old_cell_cnt = old_row_cnt * table->col_cnt;\n        uint32_t new_cell_cnt = table->col_cnt * table->row_cnt;\n        uint32_t i;\n        for(i = new_cell_cnt; i < old_cell_cnt; i++) {\n            lv_mem_free(table->cell_data[i]);\n        }\n    }\n\n    table->cell_data = lv_mem_realloc(table->cell_data, table->row_cnt * table->col_cnt * sizeof(char *));\n    LV_ASSERT_MALLOC(table->cell_data);\n    if(table->cell_data == NULL) return;\n\n    /*Initialize the new fields*/\n    if(old_row_cnt < row_cnt) {\n        uint32_t old_cell_cnt = old_row_cnt * table->col_cnt;\n        uint32_t new_cell_cnt = table->col_cnt * table->row_cnt;\n        lv_memset_00(&table->cell_data[old_cell_cnt], (new_cell_cnt - old_cell_cnt) * sizeof(table->cell_data[0]));\n    }\n\n    refr_size(obj, 0) ;\n}"}, "lv_table_set_col_cnt": {"type": "Function", "def": "void lv_table_set_col_cnt(lv_obj_t * obj, uint16_t col_cnt)", "sline": 241, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_table_t * table = (lv_table_t *)obj;\n    uint16_t old_col_cnt = table->col_cnt;\n    table->col_cnt         = col_cnt;\n    table->col_w = lv_mem_realloc(table->col_w, col_cnt * sizeof(table->row_h[0]));\n    LV_ASSERT_MALLOC(table->col_w);\n    if(table->col_w == NULL) return;\n\n    /*Free the unused cells*/\n    if(old_col_cnt > col_cnt) {\n        uint16_t old_cell_cnt = old_col_cnt * table->row_cnt;\n        uint32_t new_cell_cnt = table->col_cnt * table->row_cnt;\n        uint32_t i;\n        for(i = new_cell_cnt; i < old_cell_cnt; i++) {\n            lv_mem_free(table->cell_data[i]);\n        }\n    }\n\n    char ** new_cell_data = lv_mem_alloc(table->row_cnt * table->col_cnt * sizeof(char *));\n    LV_ASSERT_MALLOC(new_cell_data);\n    if(new_cell_data == NULL) return;\n    uint32_t new_cell_cnt = table->col_cnt * table->row_cnt;\n    lv_memset_00(new_cell_data, new_cell_cnt * sizeof(table->cell_data[0]));\n\n    /*Initialize the new fields*/\n    if(old_col_cnt < col_cnt) {\n        uint32_t col;\n        for(col = old_col_cnt; col < col_cnt; col++) {\n            table->col_w[col] = LV_DPI_DEF;\n        }\n    }\n\n    /*The new column(s) messes up the mapping of `cell_data`*/\n    uint32_t old_col_start;\n    uint32_t new_col_start;\n    uint32_t min_col_cnt = LV_MIN(old_col_cnt, col_cnt);\n    uint32_t row;\n    for(row = 0; row < table->row_cnt; row++) {\n        old_col_start = row * old_col_cnt;\n        new_col_start = row * col_cnt;\n\n        lv_memcpy_small(&new_cell_data[new_col_start], &table->cell_data[old_col_start],\n                        sizeof(new_cell_data[0]) * min_col_cnt);\n    }\n\n    lv_mem_free(table->cell_data);\n    table->cell_data = new_cell_data;\n\n\n    refr_size(obj, 0) ;\n}"}, "lv_table_set_col_width": {"type": "Function", "def": "void lv_table_set_col_width(lv_obj_t * obj, uint16_t col_id, lv_coord_t w)", "sline": 296, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_table_t * table = (lv_table_t *)obj;\n\n    /*Auto expand*/\n    if(col_id >= table->col_cnt) lv_table_set_col_cnt(obj, col_id + 1);\n\n    table->col_w[col_id] = w;\n    refr_size(obj, 0) ;\n}"}, "lv_table_add_cell_ctrl": {"type": "Function", "def": "void lv_table_add_cell_ctrl(lv_obj_t * obj, uint16_t row, uint16_t col, lv_table_cell_ctrl_t ctrl)", "sline": 309, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_table_t * table = (lv_table_t *)obj;\n\n    /*Auto expand*/\n    if(col >= table->col_cnt) lv_table_set_col_cnt(obj, col + 1);\n    if(row >= table->row_cnt) lv_table_set_row_cnt(obj, row + 1);\n\n    uint32_t cell = row * table->col_cnt + col;\n\n    if(table->cell_data[cell] == NULL) {\n        table->cell_data[cell]    = lv_mem_alloc(2); /*+1: trailing '\\0; +1: format byte*/\n        LV_ASSERT_MALLOC(table->cell_data[cell]);\n        if(table->cell_data[cell] == NULL) return;\n\n        table->cell_data[cell][0] = 0;\n        table->cell_data[cell][1] = '\\0';\n    }\n\n    table->cell_data[cell][0] |= ctrl;\n}"}, "lv_table_clear_cell_ctrl": {"type": "Function", "def": "void lv_table_clear_cell_ctrl(lv_obj_t * obj, uint16_t row, uint16_t col, lv_table_cell_ctrl_t ctrl)", "sline": 333, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_table_t * table = (lv_table_t *)obj;\n\n    /*Auto expand*/\n    if(col >= table->col_cnt) lv_table_set_col_cnt(obj, col + 1);\n    if(row >= table->row_cnt) lv_table_set_row_cnt(obj, row + 1);\n\n    uint32_t cell = row * table->col_cnt + col;\n\n    if(table->cell_data[cell] == NULL) {\n        table->cell_data[cell]    = lv_mem_alloc(2); /*+1: trailing '\\0; +1: format byte*/\n        LV_ASSERT_MALLOC(table->cell_data[cell]);\n        if(table->cell_data[cell] == NULL) return;\n\n        table->cell_data[cell][0] = 0;\n        table->cell_data[cell][1] = '\\0';\n    }\n\n    table->cell_data[cell][0] &= (~ctrl);\n}"}, "lv_table_get_cell_value": {"type": "Function", "def": "const char * lv_table_get_cell_value(lv_obj_t * obj, uint16_t row, uint16_t col)", "sline": 361, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_table_t * table = (lv_table_t *)obj;\n    if(row >= table->row_cnt || col >= table->col_cnt) {\n        LV_LOG_WARN(\"lv_table_set_cell_value: invalid row or column\");\n        return \"\";\n    }\n    uint32_t cell = row * table->col_cnt + col;\n\n    if(table->cell_data[cell] == NULL) return \"\";\n\n    return &table->cell_data[cell][1]; /*Skip the format byte*/\n}"}, "lv_table_get_row_cnt": {"type": "Function", "def": "uint16_t lv_table_get_row_cnt(lv_obj_t * obj)", "sline": 377, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_table_t * table = (lv_table_t *)obj;\n    return table->row_cnt;\n}"}, "lv_table_get_col_cnt": {"type": "Function", "def": "uint16_t lv_table_get_col_cnt(lv_obj_t * obj)", "sline": 385, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_table_t * table = (lv_table_t *)obj;\n    return table->col_cnt;\n}"}, "lv_table_get_col_width": {"type": "Function", "def": "lv_coord_t lv_table_get_col_width(lv_obj_t * obj, uint16_t col)", "sline": 393, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_table_t * table = (lv_table_t *)obj;\n\n    if(col >= table->col_cnt) {\n        LV_LOG_WARN(\"lv_table_set_col_width: too big 'col_id'. Must be < LV_TABLE_COL_MAX.\");\n        return 0;\n    }\n\n    return table->col_w[col];\n}"}, "lv_table_has_cell_ctrl": {"type": "Function", "def": "bool lv_table_has_cell_ctrl(lv_obj_t * obj, uint16_t row, uint16_t col, lv_table_cell_ctrl_t ctrl)", "sline": 407, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_table_t * table = (lv_table_t *)obj;\n    if(row >= table->row_cnt || col >= table->col_cnt) {\n        LV_LOG_WARN(\"lv_table_get_cell_crop: invalid row or column\");\n        return false;\n    }\n    uint32_t cell = row * table->col_cnt + col;\n\n    if(table->cell_data[cell] == NULL) return false;\n    else return (table->cell_data[cell][0] & ctrl) == ctrl ? true : false;\n}"}, "lv_table_get_selected_cell": {"type": "Function", "def": "void lv_table_get_selected_cell(lv_obj_t * obj, uint16_t * row, uint16_t * col)", "sline": 422, "body": "{\n    lv_table_t * table = (lv_table_t *)obj;\n    *row = table->row_act;\n    *col = table->col_act;\n}"}, "carbit_updater/lvgl/src/widgets/lv_table.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_table.c"}}, "carbit_updater/lvgl/src/widgets/lv_dropdown.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "lv_label": {"type": "Variable", "def": "#include ../widgets/lv_label.h", "sline": 26}, "_silence_gcc_warning": {"type": "Struct", "def": "LV_EXPORT_CONST_INT(LV_DROPDOWN_POS_LAST)", "sline": 32}, "lv_dropdown_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 39, "in_struct": "lv_dropdown_t"}, "lv_dropdown_t.list": {"type": "Variable", "def": "lv_obj_t * list", "sline": 40, "in_struct": "lv_dropdown_t"}, "lv_dropdown_t.text": {"type": "Variable", "def": "const char * text", "sline": 41, "in_struct": "lv_dropdown_t"}, "lv_dropdown_t.symbol": {"type": "Variable", "def": "const void * symbol", "sline": 42, "in_struct": "lv_dropdown_t"}, "lv_dropdown_t.options": {"type": "Variable", "def": "char * options", "sline": 43, "in_struct": "lv_dropdown_t"}, "lv_dropdown_t.option_cnt": {"type": "Variable", "def": "uint16_t option_cnt", "sline": 44, "in_struct": "lv_dropdown_t"}, "lv_dropdown_t.sel_opt_id": {"type": "Variable", "def": "uint16_t sel_opt_id", "sline": 45, "in_struct": "lv_dropdown_t"}, "lv_dropdown_t.sel_opt_id_orig": {"type": "Variable", "def": "uint16_t sel_opt_id_orig", "sline": 46, "in_struct": "lv_dropdown_t"}, "lv_dropdown_t.pr_opt_id": {"type": "Variable", "def": "uint16_t pr_opt_id", "sline": 47, "in_struct": "lv_dropdown_t"}, "lv_dropdown_t.dir": {"type": "Variable", "def": "lv_dir_t dir              : 4", "sline": 48, "in_struct": "lv_dropdown_t"}, "lv_dropdown_t.static_txt": {"type": "Variable", "def": "uint8_t static_txt        : 1", "sline": 49, "in_struct": "lv_dropdown_t"}, "lv_dropdown_t.selected_highlight": {"type": "Variable", "def": "uint8_t selected_highlight: 1", "sline": 50, "in_struct": "lv_dropdown_t"}, "lv_dropdown_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    lv_obj_t * list;                /**< The dropped down list*/\n    const char * text;              /**< Text to display on the dropdown's button*/\n    const void * symbol;            /**< Arrow or other icon when the drop-down list is closed*/\n    char * options;                 /**< Options in a a '\\n' separated list*/\n    uint16_t option_cnt;            /**< Number of options*/\n    uint16_t sel_opt_id;            /**< Index of the currently selected option*/\n    uint16_t sel_opt_id_orig;       /**< Store the original index on focus*/\n    uint16_t pr_opt_id;             /**< Index of the currently pressed option*/\n    lv_dir_t dir              : 4;  /**< Direction in which the list should open*/\n    uint8_t static_txt        : 1;  /**< 1: Only a pointer is saved in `options`*/\n    uint8_t selected_highlight: 1;  /**< 1: Make the selected option highlighted in the list*/\n} lv_dropdown_t", "sline": 51}, "lv_dropdown_list_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 54, "in_struct": "lv_dropdown_list_t"}, "lv_dropdown_list_t.dropdown": {"type": "Variable", "def": "lv_obj_t * dropdown", "sline": 55, "in_struct": "lv_dropdown_list_t"}, "lv_dropdown_list_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    lv_obj_t * dropdown;\n} lv_dropdown_list_t", "sline": 56}, "lv_dropdown_class": {"type": "Variable", "def": "extern const  lv_obj_class_t lv_dropdown_class", "sline": 58}, "lv_dropdownlist_class": {"type": "Variable", "def": "extern const  lv_obj_class_t lv_dropdownlist_class", "sline": 59}, "lv_dropdown_create": {"type": "Function", "def": "lv_obj_t * lv_dropdown_create(lv_obj_t * parent)", "sline": 70}, "lv_dropdown_set_text": {"type": "Function", "def": "void lv_dropdown_set_text(lv_obj_t * obj, const char * txt)", "sline": 83}, "lv_dropdown_set_options": {"type": "Function", "def": "void lv_dropdown_set_options(lv_obj_t * obj, const char * options)", "sline": 91}, "lv_dropdown_set_options_static": {"type": "Function", "def": "void lv_dropdown_set_options_static(lv_obj_t * obj, const char * options)", "sline": 99}, "lv_dropdown_add_option": {"type": "Function", "def": "void lv_dropdown_add_option(lv_obj_t * obj, const char * option, uint32_t pos)", "sline": 107}, "lv_dropdown_clear_options": {"type": "Function", "def": "void lv_dropdown_clear_options(lv_obj_t * obj)", "sline": 113}, "lv_dropdown_set_selected": {"type": "Function", "def": "void lv_dropdown_set_selected(lv_obj_t * obj, uint16_t sel_opt)", "sline": 120}, "lv_dropdown_set_dir": {"type": "Function", "def": "void lv_dropdown_set_dir(lv_obj_t * obj, lv_dir_t dir)", "sline": 127}, "lv_dropdown_set_symbol": {"type": "Function", "def": "void lv_dropdown_set_symbol(lv_obj_t * obj, const void * symbol)", "sline": 136}, "lv_dropdown_set_selected_highlight": {"type": "Function", "def": "void lv_dropdown_set_selected_highlight(lv_obj_t * obj, bool en)", "sline": 143}, "lv_dropdown_get_list": {"type": "Function", "def": "lv_obj_t * lv_dropdown_get_list(lv_obj_t * obj)", "sline": 154}, "lv_dropdown_get_text": {"type": "Function", "def": "const char * lv_dropdown_get_text(lv_obj_t * obj)", "sline": 161}, "lv_dropdown_get_options": {"type": "Function", "def": "const char * lv_dropdown_get_options(const lv_obj_t * obj)", "sline": 168}, "lv_dropdown_get_selected": {"type": "Function", "def": "uint16_t lv_dropdown_get_selected(const lv_obj_t * obj)", "sline": 175}, "lv_dropdown_get_option_cnt": {"type": "Function", "def": "uint16_t lv_dropdown_get_option_cnt(const lv_obj_t * obj)", "sline": 182}, "lv_dropdown_get_selected_str": {"type": "Function", "def": "void lv_dropdown_get_selected_str(const lv_obj_t * obj, char * buf, uint32_t buf_size)", "sline": 190}, "lv_dropdown_get_symbol": {"type": "Function", "def": "const char * lv_dropdown_get_symbol(lv_obj_t * obj)", "sline": 197}, "lv_dropdown_get_selected_highlight": {"type": "Function", "def": "bool lv_dropdown_get_selected_highlight(lv_obj_t * obj)", "sline": 204}, "lv_dropdown_get_dir": {"type": "Function", "def": "lv_dir_t lv_dropdown_get_dir(const lv_obj_t * obj)", "sline": 211}, "lv_dropdown_open": {"type": "Function", "def": "void lv_dropdown_open(lv_obj_t * dropdown_obj)", "sline": 221}, "lv_dropdown_close": {"type": "Function", "def": "void lv_dropdown_close(lv_obj_t * obj)", "sline": 227}, "carbit_updater/lvgl/src/widgets/lv_dropdown.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_dropdown.h"}}, "carbit_updater/lvgl/src/extra/libs/freetype/lv_freetype.c": {"lv_freetype": {"type": "Variable", "def": "#include lv_freetype.h", "sline": 9, "include": ["carbit_updater/lvgl/src/extra/libs/freetype/lv_freetype.h", null]}, "carbit_updater/lvgl/src/extra/libs/freetype/lv_freetype.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/freetype/lv_freetype.c"}}, "carbit_updater/lvgl/src/lv_conf_kconfig.h": {"carbit_updater/lvgl/src/lv_conf_kconfig.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/lv_conf_kconfig.h"}}, "carbit_updater/lv_drivers/gtkdrv/gtkdrv.c": {"gtkdrv": {"type": "Variable", "def": "#include gtkdrv.h", "sline": 9, "include": ["carbit_updater/lv_drivers/gtkdrv/gtkdrv.h", null]}, "carbit_updater/lv_drivers/gtkdrv/gtkdrv.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/gtkdrv/gtkdrv.c"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_46.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_montserrat_46.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_46.c"}}, "carbit_updater/lvgl/src/widgets/lv_switch.c": {"lv_switch": {"type": "Variable", "def": "#include lv_switch.h", "sline": 9, "include": ["carbit_updater/lvgl/src/widgets/lv_switch.h", null]}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 13}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 14}, "lv_anim": {"type": "Variable", "def": "#include ../misc/lv_anim.h", "sline": 15}, "lv_indev": {"type": "Variable", "def": "#include ../core/lv_indev.h", "sline": 16}, "lv_disp": {"type": "Variable", "def": "#include ../core/lv_disp.h", "sline": 17}, "lv_img": {"type": "Variable", "def": "#include lv_img.h", "sline": 18, "include": ["carbit_updater/lvgl/src/widgets/lv_img.h", null]}, "lv_switch_constructor": {"type": "Function", "def": "static void lv_switch_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 85, "body": "{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_switch_t * sw = (lv_switch_t *)obj;\n\n    sw->anim_state = LV_SWITCH_ANIM_STATE_INV;\n\n    lv_obj_clear_flag(obj, LV_OBJ_FLAG_SCROLLABLE);\n    lv_obj_add_flag(obj, LV_OBJ_FLAG_CHECKABLE);\n    lv_obj_add_flag(obj, LV_OBJ_FLAG_SCROLL_ON_FOCUS);\n\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}"}, "lv_switch_destructor": {"type": "Function", "def": "static void lv_switch_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 101, "body": "{\n    LV_UNUSED(class_p);\n    lv_switch_t * sw = (lv_switch_t *)obj;\n\n    lv_anim_del(sw, NULL);\n}"}, "lv_switch_event": {"type": "Function", "def": "static void lv_switch_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 109, "body": "{\n    LV_UNUSED(class_p);\n\n    lv_res_t res;\n\n    /*Call the ancestor's event handler*/\n    res = lv_obj_event_base(MY_CLASS, e);\n    if(res != LV_RES_OK) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n\n    if(code == LV_EVENT_REFR_EXT_DRAW_SIZE) {\n        lv_coord_t knob_left = lv_obj_get_style_pad_left(obj,   LV_PART_KNOB);\n        lv_coord_t knob_right = lv_obj_get_style_pad_right(obj,  LV_PART_KNOB);\n        lv_coord_t knob_top = lv_obj_get_style_pad_top(obj,    LV_PART_KNOB);\n        lv_coord_t knob_bottom = lv_obj_get_style_pad_bottom(obj, LV_PART_KNOB);\n\n        /*The smaller size is the knob diameter*/\n        lv_coord_t knob_size = LV_MAX4(knob_left, knob_right, knob_bottom, knob_top);\n        knob_size += 2;         /*For rounding error*/\n        knob_size += lv_obj_calculate_ext_draw_size(obj, LV_PART_KNOB);\n\n        lv_coord_t * s = lv_event_get_param(e);\n        *s = LV_MAX(*s, knob_size);\n        *s = LV_MAX(*s, lv_obj_calculate_ext_draw_size(obj, LV_PART_INDICATOR));\n    }\n    else if(code == LV_EVENT_VALUE_CHANGED) {\n        lv_switch_trigger_anim(obj);\n        lv_obj_invalidate(obj);\n    }\n    else if(code == LV_EVENT_DRAW_MAIN) {\n        draw_main(e);\n    }\n}"}, "draw_main": {"type": "Function", "def": "static void draw_main(lv_event_t * e)", "sline": 146, "body": "{\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_switch_t * sw = (lv_switch_t *)obj;\n\n    const lv_area_t * clip_area = lv_event_get_param(e);\n    lv_base_dir_t base_dir = lv_obj_get_style_base_dir(obj, LV_PART_MAIN);\n\n    /*Calculate the indicator area*/\n    lv_coord_t bg_left = lv_obj_get_style_pad_left(obj,     LV_PART_MAIN);\n    lv_coord_t bg_right = lv_obj_get_style_pad_right(obj,   LV_PART_MAIN);\n    lv_coord_t bg_top = lv_obj_get_style_pad_top(obj,       LV_PART_MAIN);\n    lv_coord_t bg_bottom = lv_obj_get_style_pad_bottom(obj, LV_PART_MAIN);\n\n    /*Draw the indicator*/\n    /*Respect the background's padding*/\n    lv_area_t indic_area;\n    lv_area_copy(&indic_area, &obj->coords);\n    indic_area.x1 += bg_left;\n    indic_area.x2 -= bg_right;\n    indic_area.y1 += bg_top;\n    indic_area.y2 -= bg_bottom;\n\n    lv_draw_rect_dsc_t draw_indic_dsc;\n    lv_draw_rect_dsc_init(&draw_indic_dsc);\n    lv_obj_init_draw_rect_dsc(obj, LV_PART_INDICATOR, &draw_indic_dsc);\n    lv_draw_rect(&indic_area, clip_area, &draw_indic_dsc);\n\n    /*Draw the knob*/\n    lv_coord_t objh = lv_obj_get_height(obj);\n    lv_coord_t knob_size = objh;\n    lv_area_t knob_area;\n\n    lv_coord_t anim_length = obj->coords.x2 - bg_right - obj->coords.x1 - bg_left - knob_size;\n\n    lv_coord_t anim_value_x;\n\n    bool chk = lv_obj_get_state(obj) & LV_STATE_CHECKED;\n\n    if(LV_SWITCH_IS_ANIMATING(sw)) {\n        /* Use the animation's coordinate */\n        anim_value_x = (anim_length * sw->anim_state) / LV_SWITCH_ANIM_STATE_END;\n    }\n    else {\n        /* Use LV_STATE_CHECKED to decide the coordinate */\n        anim_value_x = chk ? anim_length : 0;\n    }\n\n    if(base_dir == LV_BASE_DIR_RTL) {\n        anim_value_x = anim_length - anim_value_x;\n    }\n\n    knob_area.x1 = obj->coords.x1 + bg_left + anim_value_x;\n    knob_area.x2 = knob_area.x1 + knob_size;\n\n    knob_area.y1 = obj->coords.y1 + bg_top;\n    knob_area.y2 = obj->coords.y2 - bg_bottom;\n\n    lv_coord_t knob_left = lv_obj_get_style_pad_left(obj, LV_PART_KNOB);\n    lv_coord_t knob_right = lv_obj_get_style_pad_right(obj, LV_PART_KNOB);\n    lv_coord_t knob_top = lv_obj_get_style_pad_top(obj, LV_PART_KNOB);\n    lv_coord_t knob_bottom = lv_obj_get_style_pad_bottom(obj, LV_PART_KNOB);\n\n    /*Apply the paddings on the knob area*/\n    knob_area.x1 -= knob_left;\n    knob_area.x2 += knob_right;\n    knob_area.y1 -= knob_top;\n    knob_area.y2 += knob_bottom;\n\n    lv_draw_rect_dsc_t knob_rect_dsc;\n    lv_draw_rect_dsc_init(&knob_rect_dsc);\n    lv_obj_init_draw_rect_dsc(obj, LV_PART_KNOB, &knob_rect_dsc);\n\n    lv_draw_rect(&knob_area, clip_area, &knob_rect_dsc);\n}"}, "lv_switch_anim_exec_cb": {"type": "Function", "def": "static void lv_switch_anim_exec_cb(void * var, int32_t value)", "sline": 222, "body": "{\n    lv_switch_t * sw = var;\n    sw->anim_state = value;\n    lv_obj_invalidate((lv_obj_t *)sw);\n}"}, "lv_switch_trigger_anim": {"type": "Function", "def": "static void lv_switch_trigger_anim(lv_obj_t * obj)", "sline": 243, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_switch_t * sw = (lv_switch_t *)obj;\n\n    uint32_t anim_dur_full = lv_obj_get_style_anim_time(obj, LV_PART_MAIN);\n\n    if(anim_dur_full > 0) {\n        bool chk = lv_obj_get_state(obj) & LV_STATE_CHECKED;\n        int32_t anim_start;\n        int32_t anim_end;\n        /*No animation in progress -> simply set the values*/\n        if(sw->anim_state == LV_SWITCH_ANIM_STATE_INV) {\n            anim_start = chk ? LV_SWITCH_ANIM_STATE_START : LV_SWITCH_ANIM_STATE_END;\n            anim_end   = chk ? LV_SWITCH_ANIM_STATE_END : LV_SWITCH_ANIM_STATE_START;\n        }\n        /*Animation in progress. Start from the animation end value*/\n        else {\n            anim_start = sw->anim_state;\n            anim_end   = chk ? LV_SWITCH_ANIM_STATE_END : LV_SWITCH_ANIM_STATE_START;\n        }\n        /*Calculate actual animation duration*/\n        uint32_t anim_dur = (anim_dur_full * LV_ABS(anim_start - anim_end)) / LV_SWITCH_ANIM_STATE_END;\n\n        /*Stop the previous animation if it exists*/\n        lv_anim_del(sw, NULL);\n\n        lv_anim_t a;\n        lv_anim_init(&a);\n        lv_anim_set_var(&a, sw);\n        lv_anim_set_exec_cb(&a, lv_switch_anim_exec_cb);\n        lv_anim_set_values(&a, anim_start, anim_end);\n        lv_anim_set_ready_cb(&a, lv_switch_anim_ready);\n        lv_anim_set_time(&a, anim_dur);\n        lv_anim_start(&a);\n    }\n}"}, "lv_switch_anim_ready": {"type": "Function", "def": "static void lv_switch_anim_ready(lv_anim_t * a)", "sline": 232, "docstring": "/**", "body": "{\n    lv_switch_t * sw = a->var;\n    sw->anim_state = LV_SWITCH_ANIM_STATE_INV;\n    lv_obj_invalidate((lv_obj_t *)sw);\n}"}, "lv_switch_class": {"type": "Variable", "def": "const lv_obj_class_t lv_switch_class = {\n    .constructor_cb = lv_switch_constructor,\n    .destructor_cb = lv_switch_destructor,\n    .event_cb = lv_switch_event,\n    .width_def = (4 * LV_DPI_DEF) / 10,\n    .height_def = (4 * LV_DPI_DEF) / 17,\n    .group_def = LV_OBJ_CLASS_GROUP_DEF_TRUE,\n    .instance_size = sizeof(lv_switch_t),\n    .base_class = &lv_obj_class\n}", "sline": 54}, "lv_switch_create": {"type": "Function", "def": "lv_obj_t * lv_switch_create(lv_obj_t * parent)", "sline": 73, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "carbit_updater/lvgl/src/widgets/lv_switch.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_switch.c"}}, "carbit_updater/lv_drivers/display/monitor.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 20}, "carbit_updater/lv_drivers/display/monitor.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/monitor.h"}}, "carbit_updater/lvgl/tests/src/test_fonts/font_3.c": {"carbit_updater/lvgl/tests/src/test_fonts/font_3.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/tests/src/test_fonts/font_3.c"}}, "carbit_updater/lvgl/src/font/lv_font_fmt_txt.h": {"stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 16}, "stddef": {"type": "Variable", "def": "#include stddef.h", "sline": 17}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 18}, "lv_font": {"type": "Variable", "def": "#include lv_font.h", "sline": 19, "include": ["carbit_updater/lvgl/src/font/lv_font.h", null]}, "lv_font_fmt_txt_glyph_dsc_t.bitmap_index": {"type": "Variable", "def": "uint32_t bitmap_index : 20", "sline": 32, "in_struct": "lv_font_fmt_txt_glyph_dsc_t"}, "lv_font_fmt_txt_glyph_dsc_t.adv_w": {"type": "Variable", "def": "uint32_t adv_w : 12", "sline": 33, "in_struct": "lv_font_fmt_txt_glyph_dsc_t"}, "lv_font_fmt_txt_glyph_dsc_t.box_w": {"type": "Variable", "def": "uint8_t box_w", "sline": 34, "in_struct": "lv_font_fmt_txt_glyph_dsc_t"}, "lv_font_fmt_txt_glyph_dsc_t.box_h": {"type": "Variable", "def": "uint8_t box_h", "sline": 35, "in_struct": "lv_font_fmt_txt_glyph_dsc_t"}, "lv_font_fmt_txt_glyph_dsc_t.ofs_x": {"type": "Variable", "def": "int8_t ofs_x", "sline": 36, "in_struct": "lv_font_fmt_txt_glyph_dsc_t"}, "lv_font_fmt_txt_glyph_dsc_t.ofs_y": {"type": "Variable", "def": "int8_t ofs_y", "sline": 37, "in_struct": "lv_font_fmt_txt_glyph_dsc_t"}, "lv_font_fmt_txt_glyph_dsc_t": {"type": "Variable", "def": "typedef struct {\n#if LV_FONT_FMT_TXT_LARGE == 0\n    uint32_t bitmap_index : 20;     /**< Start index of the bitmap. A font can be max 1 MB.*/\n    uint32_t adv_w : 12;            /**< Draw the next glyph after this width. 8.4 format (real_value * 16 is stored).*/\n    uint8_t box_w;                  /**< Width of the glyph's bounding box*/\n    uint8_t box_h;                  /**< Height of the glyph's bounding box*/\n    int8_t ofs_x;                   /**< x offset of the bounding box*/\n    int8_t ofs_y;                   /**< y offset of the bounding box. Measured from the top of the line*/\n#else\n    uint32_t bitmap_index;          /**< Start index of the bitmap. A font can be max 4 GB.*/\n    uint32_t adv_w;                 /**< Draw the next glyph after this width. 28.4 format (real_value * 16 is stored).*/\n    uint16_t box_w;                 /**< Width of the glyph's bounding box*/\n    uint16_t box_h;                 /**< Height of the glyph's bounding box*/\n    int16_t ofs_x;                  /**< x offset of the bounding box*/\n    int16_t ofs_y;                  /**< y offset of the bounding box. Measured from the top of the line*/\n#endif\n} lv_font_fmt_txt_glyph_dsc_t", "sline": 46, "docstring": "/** This describes a glyph.*/"}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_fmt_txt.h:49:1)": {"type": "Enum", "def": "enum {\n    LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL,\n    LV_FONT_FMT_TXT_CMAP_SPARSE_FULL,\n    LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY,\n    LV_FONT_FMT_TXT_CMAP_SPARSE_TINY,\n}", "sline": 49, "docstring": "/** Format of font character map.*/"}, "lv_font_fmt_txt_cmap_type_t": {"type": "Variable", "def": "typedef uint8_t lv_font_fmt_txt_cmap_type_t", "sline": 56}, "lv_font_fmt_txt_cmap_t.range_start": {"type": "Variable", "def": "uint32_t range_start", "sline": 65, "in_struct": "lv_font_fmt_txt_cmap_t"}, "lv_font_fmt_txt_cmap_t.range_length": {"type": "Variable", "def": "uint16_t range_length", "sline": 69, "in_struct": "lv_font_fmt_txt_cmap_t"}, "lv_font_fmt_txt_cmap_t.glyph_id_start": {"type": "Variable", "def": "uint16_t glyph_id_start", "sline": 72, "in_struct": "lv_font_fmt_txt_cmap_t"}, "lv_font_fmt_txt_cmap_t.unicode_list": {"type": "Variable", "def": "const uint16_t * unicode_list", "sline": 101, "in_struct": "lv_font_fmt_txt_cmap_t"}, "lv_font_fmt_txt_cmap_t.glyph_id_ofs_list": {"type": "Variable", "def": "const void * glyph_id_ofs_list", "sline": 106, "in_struct": "lv_font_fmt_txt_cmap_t"}, "lv_font_fmt_txt_cmap_t.list_length": {"type": "Variable", "def": "uint16_t list_length", "sline": 109, "in_struct": "lv_font_fmt_txt_cmap_t"}, "lv_font_fmt_txt_cmap_t.type": {"type": "Variable", "def": "lv_font_fmt_txt_cmap_type_t type", "sline": 112, "in_struct": "lv_font_fmt_txt_cmap_t", "rels": [["lv_font_fmt_txt_cmap_type_t", null, "Typeof"]]}, "lv_font_fmt_txt_cmap_t": {"type": "Variable", "def": "typedef struct {\n    /** First Unicode character for this range*/\n    uint32_t range_start;\n\n    /** Number of Unicode characters related to this range.\n     * Last Unicode character = range_start + range_length - 1*/\n    uint16_t range_length;\n\n    /** First glyph ID (array index of `glyph_dsc`) for this range*/\n    uint16_t glyph_id_start;\n\n    /*\n    According the specification there are 4 formats:\n        https://github.com/lvgl/lv_font_conv/blob/master/doc/font_spec.md\n\n    For simplicity introduce \"relative code point\":\n        rcp = codepoint - range_start\n\n    and a search function:\n        search a \"value\" in an \"array\" and returns the index of \"value\".\n\n    Format 0 tiny\n        unicode_list == NULL && glyph_id_ofs_list == NULL\n        glyph_id = glyph_id_start + rcp\n\n    Format 0 full\n        unicode_list == NULL && glyph_id_ofs_list != NULL\n        glyph_id = glyph_id_start + glyph_id_ofs_list[rcp]\n\n    Sparse tiny\n        unicode_list != NULL && glyph_id_ofs_list == NULL\n        glyph_id = glyph_id_start + search(unicode_list, rcp)\n\n    Sparse full\n        unicode_list != NULL && glyph_id_ofs_list != NULL\n        glyph_id = glyph_id_start + glyph_id_ofs_list[search(unicode_list, rcp)]\n    */\n\n    const uint16_t * unicode_list;\n\n    /** if(type == LV_FONT_FMT_TXT_CMAP_FORMAT0_...) it's `uint8_t *`\n     * if(type == LV_FONT_FMT_TXT_CMAP_SPARSE_...)  it's `uint16_t *`\n     */\n    const void * glyph_id_ofs_list;\n\n    /** Length of `unicode_list` and/or `glyph_id_ofs_list`*/\n    uint16_t list_length;\n\n    /** Type of this character map*/\n    lv_font_fmt_txt_cmap_type_t type;\n} lv_font_fmt_txt_cmap_t", "sline": 113}, "lv_font_fmt_txt_kern_pair_t.glyph_ids": {"type": "Variable", "def": "const void * glyph_ids", "sline": 124, "in_struct": "lv_font_fmt_txt_kern_pair_t"}, "lv_font_fmt_txt_kern_pair_t.values": {"type": "Variable", "def": "const int8_t * values", "sline": 125, "in_struct": "lv_font_fmt_txt_kern_pair_t"}, "lv_font_fmt_txt_kern_pair_t.pair_cnt": {"type": "Variable", "def": "uint32_t pair_cnt   : 30", "sline": 126, "in_struct": "lv_font_fmt_txt_kern_pair_t"}, "lv_font_fmt_txt_kern_pair_t.glyph_ids_size": {"type": "Variable", "def": "uint32_t glyph_ids_size : 2", "sline": 127, "in_struct": "lv_font_fmt_txt_kern_pair_t"}, "lv_font_fmt_txt_kern_pair_t": {"type": "Variable", "def": "typedef struct {\n    /*To get a kern value of two code points:\n       1. Get the `glyph_id_left` and `glyph_id_right` from `lv_font_fmt_txt_cmap_t\n       2. for(i = 0; i < pair_cnt * 2; i += 2)\n             if(gylph_ids[i] == glyph_id_left &&\n                gylph_ids[i+1] == glyph_id_right)\n                 return values[i / 2];\n     */\n    const void * glyph_ids;\n    const int8_t * values;\n    uint32_t pair_cnt   : 30;\n    uint32_t glyph_ids_size : 2;    /*0: `glyph_ids` is stored as `uint8_t`; 1: as `uint16_t`*/\n} lv_font_fmt_txt_kern_pair_t", "sline": 128, "docstring": "/** A simple mapping of kern values from pairs*/"}, "lv_font_fmt_txt_kern_classes_t.class_pair_values": {"type": "Variable", "def": "const int8_t * class_pair_values", "sline": 140, "in_struct": "lv_font_fmt_txt_kern_classes_t"}, "lv_font_fmt_txt_kern_classes_t.left_class_mapping": {"type": "Variable", "def": "const uint8_t * left_class_mapping", "sline": 141, "in_struct": "lv_font_fmt_txt_kern_classes_t"}, "lv_font_fmt_txt_kern_classes_t.right_class_mapping": {"type": "Variable", "def": "const uint8_t * right_class_mapping", "sline": 142, "in_struct": "lv_font_fmt_txt_kern_classes_t"}, "lv_font_fmt_txt_kern_classes_t.left_class_cnt": {"type": "Variable", "def": "uint8_t left_class_cnt", "sline": 143, "in_struct": "lv_font_fmt_txt_kern_classes_t"}, "lv_font_fmt_txt_kern_classes_t.right_class_cnt": {"type": "Variable", "def": "uint8_t right_class_cnt", "sline": 144, "in_struct": "lv_font_fmt_txt_kern_classes_t"}, "lv_font_fmt_txt_kern_classes_t": {"type": "Variable", "def": "typedef struct {\n    /*To get a kern value of two code points:\n          1. Get the `glyph_id_left` and `glyph_id_right` from `lv_font_fmt_txt_cmap_t\n          2. Get the class of the left and right glyphs as `left_class` and `right_class`\n              left_class = left_class_mapping[glyph_id_left];\n              right_class = right_class_mapping[glyph_id_right];\n          3. value = class_pair_values[(left_class-1)*right_class_cnt + (right_class-1)]\n        */\n\n    const int8_t * class_pair_values;    /*left_class_cnt * right_class_cnt value*/\n    const uint8_t * left_class_mapping;   /*Map the glyph_ids to classes: index -> glyph_id -> class_id*/\n    const uint8_t * right_class_mapping;  /*Map the glyph_ids to classes: index -> glyph_id -> class_id*/\n    uint8_t left_class_cnt;\n    uint8_t right_class_cnt;\n} lv_font_fmt_txt_kern_classes_t", "sline": 145, "docstring": "/** More complex but more optimal class based kern value storage*/"}, "lv_font_fmt_txt_bitmap_format_t": {"type": "Variable", "def": "typedef enum {\n    LV_FONT_FMT_TXT_PLAIN      = 0,\n    LV_FONT_FMT_TXT_COMPRESSED = 1,\n    LV_FONT_FMT_TXT_COMPRESSED_NO_PREFILTER = 1,\n} lv_font_fmt_txt_bitmap_format_t", "sline": 152, "docstring": "/** Bitmap formats*/"}, "lv_font_fmt_txt_glyph_cache_t.last_letter": {"type": "Variable", "def": "uint32_t last_letter", "sline": 155, "in_struct": "lv_font_fmt_txt_glyph_cache_t"}, "lv_font_fmt_txt_glyph_cache_t.last_glyph_id": {"type": "Variable", "def": "uint32_t last_glyph_id", "sline": 156, "in_struct": "lv_font_fmt_txt_glyph_cache_t"}, "lv_font_fmt_txt_glyph_cache_t": {"type": "Variable", "def": "typedef struct {\n    uint32_t last_letter;\n    uint32_t last_glyph_id;\n} lv_font_fmt_txt_glyph_cache_t", "sline": 157}, "lv_font_fmt_txt_dsc_t.glyph_bitmap": {"type": "Variable", "def": "const uint8_t * glyph_bitmap", "sline": 162, "in_struct": "lv_font_fmt_txt_dsc_t"}, "lv_font_fmt_txt_dsc_t.glyph_dsc": {"type": "Variable", "def": "const lv_font_fmt_txt_glyph_dsc_t * glyph_dsc", "sline": 165, "in_struct": "lv_font_fmt_txt_dsc_t"}, "lv_font_fmt_txt_dsc_t.cmaps": {"type": "Variable", "def": "const lv_font_fmt_txt_cmap_t * cmaps", "sline": 169, "in_struct": "lv_font_fmt_txt_dsc_t"}, "lv_font_fmt_txt_dsc_t.kern_dsc": {"type": "Variable", "def": "const void * kern_dsc", "sline": 176, "in_struct": "lv_font_fmt_txt_dsc_t"}, "lv_font_fmt_txt_dsc_t.kern_scale": {"type": "Variable", "def": "uint16_t kern_scale", "sline": 179, "in_struct": "lv_font_fmt_txt_dsc_t"}, "lv_font_fmt_txt_dsc_t.cmap_num": {"type": "Variable", "def": "uint16_t cmap_num       : 9", "sline": 182, "in_struct": "lv_font_fmt_txt_dsc_t"}, "lv_font_fmt_txt_dsc_t.bpp": {"type": "Variable", "def": "uint16_t bpp            : 4", "sline": 185, "in_struct": "lv_font_fmt_txt_dsc_t"}, "lv_font_fmt_txt_dsc_t.kern_classes": {"type": "Variable", "def": "uint16_t kern_classes   : 1", "sline": 188, "in_struct": "lv_font_fmt_txt_dsc_t"}, "lv_font_fmt_txt_dsc_t.bitmap_format": {"type": "Variable", "def": "uint16_t bitmap_format  : 2", "sline": 194, "in_struct": "lv_font_fmt_txt_dsc_t"}, "lv_font_fmt_txt_dsc_t.cache": {"type": "Variable", "def": "lv_font_fmt_txt_glyph_cache_t * cache", "sline": 197, "in_struct": "lv_font_fmt_txt_dsc_t"}, "lv_font_fmt_txt_dsc_t": {"type": "Variable", "def": "typedef struct {\n    /*The bitmaps of all glyphs*/\n    const uint8_t * glyph_bitmap;\n\n    /*Describe the glyphs*/\n    const lv_font_fmt_txt_glyph_dsc_t * glyph_dsc;\n\n    /*Map the glyphs to Unicode characters.\n     *Array of `lv_font_cmap_fmt_txt_t` variables*/\n    const lv_font_fmt_txt_cmap_t * cmaps;\n\n    /**\n     * Store kerning values.\n     * Can be  `lv_font_fmt_txt_kern_pair_t *  or `lv_font_kern_classes_fmt_txt_t *`\n     * depending on `kern_classes`\n     */\n    const void * kern_dsc;\n\n    /*Scale kern values in 12.4 format*/\n    uint16_t kern_scale;\n\n    /*Number of cmap tables*/\n    uint16_t cmap_num       : 9;\n\n    /*Bit per pixel: 1, 2, 3, 4, 8*/\n    uint16_t bpp            : 4;\n\n    /*Type of `kern_dsc`*/\n    uint16_t kern_classes   : 1;\n\n    /*\n     * storage format of the bitmap\n     * from `lv_font_fmt_txt_bitmap_format_t`\n     */\n    uint16_t bitmap_format  : 2;\n\n    /*Cache the last letter and is glyph id*/\n    lv_font_fmt_txt_glyph_cache_t * cache;\n} lv_font_fmt_txt_dsc_t", "sline": 198, "docstring": "/*Describe store additional data for fonts*/"}, "lv_font_get_bitmap_fmt_txt": {"type": "Function", "def": "const uint8_t * lv_font_get_bitmap_fmt_txt(const lv_font_t * font, uint32_t letter)", "sline": 210}, "lv_font_get_glyph_dsc_fmt_txt": {"type": "Function", "def": "bool lv_font_get_glyph_dsc_fmt_txt(const lv_font_t * font, lv_font_glyph_dsc_t * dsc_out, uint32_t unicode_letter,\n                                   uint32_t unicode_letter_next)", "sline": 220}, "_lv_font_clean_up_fmt_txt": {"type": "Function", "def": "void _lv_font_clean_up_fmt_txt(void)", "sline": 226}, "carbit_updater/lvgl/src/font/lv_font_fmt_txt.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_fmt_txt.h"}}, "carbit_updater/lvgl/src/extra/libs/sjpg/tjpgd.c": {"tjpgd": {"type": "Variable", "def": "#include tjpgd.h", "sline": 27, "include": ["carbit_updater/lvgl/src/extra/libs/sjpg/tjpgd.h", null]}, "carbit_updater/lvgl/src/extra/libs/sjpg/tjpgd.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/sjpg/tjpgd.c"}}, "carbit_updater/lvgl/src/core/lv_obj_style.h": {"stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 16}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 17}, "lv_bidi": {"type": "Variable", "def": "#include ../misc/lv_bidi.h", "sline": 18}, "lv_obj_style_gen": {"type": "Variable", "def": "#include lv_obj_style_gen.h", "sline": 197, "include": ["carbit_updater/lvgl/src/core/lv_obj_style_gen.h", null]}, "_lv_obj_t": {"type": "Struct", "def": "struct _lv_obj_t", "sline": 28, "docstring": "/*Can't include lv_obj.h because it includes this header file*/"}, "_lv_style_state_cmp_t": {"type": "Variable", "def": "typedef enum {\n    _LV_STYLE_STATE_CMP_SAME,           /*The style properties in the 2 states are identical*/\n    _LV_STYLE_STATE_CMP_DIFF_REDRAW,    /*The differences can be shown with a simple redraw*/\n    _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD,  /*The differences can be shown with a simple redraw*/\n    _LV_STYLE_STATE_CMP_DIFF_LAYOUT,    /*The differences can be shown with a simple redraw*/\n} _lv_style_state_cmp_t", "sline": 35, "docstring": "/*Can't include lv_obj.h because it includes this header file*/"}, "lv_style_selector_t": {"type": "Variable", "def": "typedef uint32_t lv_style_selector_t", "sline": 37}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h:39:9).style": {"type": "Variable", "def": "lv_style_t * style", "sline": 40, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h:39:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h:39:9).selector": {"type": "Variable", "def": "uint32_t selector : 24", "sline": 41, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h:39:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h:39:9).is_local": {"type": "Variable", "def": "uint32_t is_local : 1", "sline": 42, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h:39:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h:39:9).is_trans": {"type": "Variable", "def": "uint32_t is_trans : 1", "sline": 43, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h:39:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h:39:9)": {"type": "Struct", "def": "struct {\n    lv_style_t * style;\n    uint32_t selector : 24;\n    uint32_t is_local : 1;\n    uint32_t is_trans : 1;\n}", "sline": 39, "body": "lv_style_t * style\nuint32_t selector : 24\nuint32_t is_local : 1\nuint32_t is_trans : 1\n"}, "_lv_obj_style_t": {"type": "Variable", "def": "typedef struct {\n    lv_style_t * style;\n    uint32_t selector : 24;\n    uint32_t is_local : 1;\n    uint32_t is_trans : 1;\n} _lv_obj_style_t", "sline": 44}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h:46:9).time": {"type": "Variable", "def": "uint16_t time", "sline": 47, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h:46:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h:46:9).delay": {"type": "Variable", "def": "uint16_t delay", "sline": 48, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h:46:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h:46:9).selector": {"type": "Variable", "def": "lv_style_selector_t selector", "sline": 49, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h:46:9)", "rels": [["lv_style_selector_t", null, "Typeof"]]}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h:46:9).prop": {"type": "Variable", "def": "lv_style_prop_t prop", "sline": 50, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h:46:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h:46:9).path_cb": {"type": "Variable", "def": "lv_anim_path_cb_t path_cb", "sline": 51, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h:46:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h:46:9).user_data": {"type": "Variable", "def": "void * user_data", "sline": 53, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h:46:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h:46:9)": {"type": "Struct", "def": "struct {\n    uint16_t time;\n    uint16_t delay;\n    lv_style_selector_t selector;\n    lv_style_prop_t prop;\n    lv_anim_path_cb_t path_cb;\n#if LV_USE_USER_DATA\n    void * user_data;\n#endif\n}", "sline": 46, "body": "uint16_t time\nuint16_t delay\nlv_style_selector_t selector\nlv_style_prop_t prop\nlv_anim_path_cb_t path_cb\nvoid * user_data\n"}, "_lv_obj_style_transition_dsc_t": {"type": "Variable", "def": "typedef struct {\n    uint16_t time;\n    uint16_t delay;\n    lv_style_selector_t selector;\n    lv_style_prop_t prop;\n    lv_anim_path_cb_t path_cb;\n#if LV_USE_USER_DATA\n    void * user_data;\n#endif\n} _lv_obj_style_transition_dsc_t", "sline": 55}, "_lv_obj_style_init": {"type": "Function", "def": "void _lv_obj_style_init(void)", "sline": 65}, "lv_obj_add_style": {"type": "Function", "def": "void lv_obj_add_style(struct _lv_obj_t * obj, lv_style_t * style, lv_style_selector_t selector)", "sline": 75}, "lv_obj_remove_style": {"type": "Function", "def": "void lv_obj_remove_style(struct _lv_obj_t * obj, lv_style_t * style, lv_style_selector_t selector)", "sline": 86}, "lv_obj_remove_style_all": {"type": "Function", "def": "static inline void lv_obj_remove_style_all(struct _lv_obj_t * obj)", "sline": 92, "body": "{\n    lv_obj_remove_style(obj, NULL, LV_PART_ANY | LV_STATE_ANY);\n}"}, "lv_obj_report_style_change": {"type": "Function", "def": "void lv_obj_report_style_change(lv_style_t * style)", "sline": 102}, "lv_obj_refresh_style": {"type": "Function", "def": "void lv_obj_refresh_style(struct _lv_obj_t * obj, lv_part_t part, lv_style_prop_t prop)", "sline": 112}, "lv_obj_enable_style_refresh": {"type": "Function", "def": "void lv_obj_enable_style_refresh(bool en)", "sline": 119}, "lv_obj_get_style_prop": {"type": "Function", "def": "lv_style_value_t lv_obj_get_style_prop(const struct _lv_obj_t * obj, lv_part_t part, lv_style_prop_t prop)", "sline": 131}, "lv_obj_set_local_style_prop": {"type": "Function", "def": "void lv_obj_set_local_style_prop(struct _lv_obj_t * obj, lv_style_prop_t prop, lv_style_value_t value,\n                                 lv_style_selector_t selector)", "sline": 141}, "lv_obj_get_local_style_prop": {"type": "Function", "def": "lv_res_t lv_obj_get_local_style_prop(struct _lv_obj_t * obj, lv_style_prop_t prop, lv_style_value_t * value,\n                                     lv_style_selector_t selector)", "sline": 144}, "lv_obj_remove_local_style_prop": {"type": "Function", "def": "bool lv_obj_remove_local_style_prop(struct _lv_obj_t * obj, lv_style_prop_t prop, lv_style_selector_t selector)", "sline": 155}, "_lv_obj_style_create_transition": {"type": "Function", "def": "void _lv_obj_style_create_transition(struct _lv_obj_t * obj, lv_part_t part, lv_state_t prev_state,\n                                     lv_state_t new_state, const _lv_obj_style_transition_dsc_t * tr)", "sline": 165}, "_lv_obj_style_state_compare": {"type": "Function", "def": "_lv_style_state_cmp_t _lv_obj_style_state_compare(struct _lv_obj_t * obj, lv_state_t state1, lv_state_t state2)", "sline": 175, "rels": [["_lv_style_state_cmp_t", null, "Typeof"]]}, "lv_obj_fade_in": {"type": "Function", "def": "void lv_obj_fade_in(struct _lv_obj_t * obj, uint32_t time, uint32_t delay)", "sline": 183}, "lv_obj_fade_out": {"type": "Function", "def": "void lv_obj_fade_out(struct _lv_obj_t * obj, uint32_t time, uint32_t delay)", "sline": 191}, "lv_obj_style_get_selector_state": {"type": "Function", "def": "lv_state_t lv_obj_style_get_selector_state(lv_style_selector_t selector)", "sline": 193}, "lv_obj_style_get_selector_part": {"type": "Function", "def": "lv_part_t lv_obj_style_get_selector_part(lv_style_selector_t selector)", "sline": 195}, "lv_obj_set_style_pad_all": {"type": "Function", "def": "static inline void lv_obj_set_style_pad_all(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 199, "body": "{\n    lv_obj_set_style_pad_left(obj, value, selector);\n    lv_obj_set_style_pad_right(obj, value, selector);\n    lv_obj_set_style_pad_top(obj, value, selector);\n    lv_obj_set_style_pad_bottom(obj, value, selector);\n}"}, "lv_obj_set_style_pad_hor": {"type": "Function", "def": "static inline void lv_obj_set_style_pad_hor(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 207, "body": "{\n    lv_obj_set_style_pad_left(obj, value, selector);\n    lv_obj_set_style_pad_right(obj, value, selector);\n}"}, "lv_obj_set_style_pad_ver": {"type": "Function", "def": "static inline void lv_obj_set_style_pad_ver(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 213, "body": "{\n    lv_obj_set_style_pad_top(obj, value, selector);\n    lv_obj_set_style_pad_bottom(obj, value, selector);\n}"}, "lv_obj_set_style_pad_gap": {"type": "Function", "def": "static inline void lv_obj_set_style_pad_gap(struct _lv_obj_t * obj,  lv_coord_t value, lv_style_selector_t selector)", "sline": 219, "body": "{\n    lv_obj_set_style_pad_row(obj, value, selector);\n    lv_obj_set_style_pad_column(obj, value, selector);\n}"}, "lv_obj_set_style_size": {"type": "Function", "def": "static inline void lv_obj_set_style_size(struct _lv_obj_t * obj,  lv_coord_t value, lv_style_selector_t selector)", "sline": 225, "body": "{\n    lv_obj_set_style_width(obj, value, selector);\n    lv_obj_set_style_height(obj, value, selector);\n}"}, "lv_obj_calculate_style_text_align": {"type": "Function", "def": "lv_text_align_t lv_obj_calculate_style_text_align(const struct _lv_obj_t * obj, lv_part_t part, const char * txt)", "sline": 231}, "lv_obj_get_x_aligned": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_x_aligned(const struct _lv_obj_t * obj)", "sline": 233, "body": "{\n    return lv_obj_get_style_x(obj, LV_PART_MAIN);\n}"}, "lv_obj_get_y_aligned": {"type": "Function", "def": "static inline lv_coord_t lv_obj_get_y_aligned(const struct _lv_obj_t * obj)", "sline": 238, "body": "{\n    return lv_obj_get_style_y(obj, LV_PART_MAIN);\n}"}, "carbit_updater/lvgl/src/core/lv_obj_style.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.h"}}, "carbit_updater/lvgl/src/misc/lv_mem.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 18}, "stddef": {"type": "Variable", "def": "#include stddef.h", "sline": 19}, "string": {"type": "Variable", "def": "#include string.h", "sline": 20}, "lv_types": {"type": "Variable", "def": "#include lv_types.h", "sline": 22, "include": ["carbit_updater/lvgl/src/misc/lv_types.h", null]}, "lv_mem_monitor_t.total_size": {"type": "Variable", "def": "uint32_t total_size", "sline": 36, "in_struct": "lv_mem_monitor_t"}, "lv_mem_monitor_t.free_cnt": {"type": "Variable", "def": "uint32_t free_cnt", "sline": 37, "in_struct": "lv_mem_monitor_t"}, "lv_mem_monitor_t.free_size": {"type": "Variable", "def": "uint32_t free_size", "sline": 38, "in_struct": "lv_mem_monitor_t"}, "lv_mem_monitor_t.free_biggest_size": {"type": "Variable", "def": "uint32_t free_biggest_size", "sline": 39, "in_struct": "lv_mem_monitor_t"}, "lv_mem_monitor_t.used_cnt": {"type": "Variable", "def": "uint32_t used_cnt", "sline": 40, "in_struct": "lv_mem_monitor_t"}, "lv_mem_monitor_t.max_used": {"type": "Variable", "def": "uint32_t max_used", "sline": 41, "in_struct": "lv_mem_monitor_t"}, "lv_mem_monitor_t.used_pct": {"type": "Variable", "def": "uint8_t used_pct", "sline": 42, "in_struct": "lv_mem_monitor_t"}, "lv_mem_monitor_t.frag_pct": {"type": "Variable", "def": "uint8_t frag_pct", "sline": 43, "in_struct": "lv_mem_monitor_t"}, "lv_mem_monitor_t": {"type": "Variable", "def": "typedef struct {\n    uint32_t total_size; /**< Total heap size*/\n    uint32_t free_cnt;\n    uint32_t free_size; /**< Size of available memory*/\n    uint32_t free_biggest_size;\n    uint32_t used_cnt;\n    uint32_t max_used; /**< Max size of Heap memory used*/\n    uint8_t used_pct; /**< Percentage used*/\n    uint8_t frag_pct; /**< Amount of fragmentation*/\n} lv_mem_monitor_t", "sline": 44, "docstring": "/**"}, "lv_mem_buf_t.p": {"type": "Variable", "def": "void * p", "sline": 47, "in_struct": "lv_mem_buf_t"}, "lv_mem_buf_t.size": {"type": "Variable", "def": "uint16_t size", "sline": 48, "in_struct": "lv_mem_buf_t"}, "lv_mem_buf_t.used": {"type": "Variable", "def": "uint8_t used : 1", "sline": 49, "in_struct": "lv_mem_buf_t"}, "lv_mem_buf_t": {"type": "Variable", "def": "typedef struct {\n    void * p;\n    uint16_t size;\n    uint8_t used : 1;\n} lv_mem_buf_t", "sline": 50}, "lv_mem_buf_arr_t": {"type": "Variable", "def": "typedef lv_mem_buf_t lv_mem_buf_arr_t[LV_MEM_BUF_MAX_NUM]", "sline": 52}, "lv_mem_init": {"type": "Function", "def": "void lv_mem_init(void)", "sline": 61}, "lv_mem_deinit": {"type": "Function", "def": "void lv_mem_deinit(void)", "sline": 67}, "lv_mem_alloc": {"type": "Function", "def": "void * lv_mem_alloc(size_t size)", "sline": 74}, "lv_mem_free": {"type": "Function", "def": "void lv_mem_free(void * data)", "sline": 80}, "lv_mem_realloc": {"type": "Function", "def": "void * lv_mem_realloc(void * data_p, size_t new_size)", "sline": 89}, "lv_mem_test": {"type": "Function", "def": "lv_res_t lv_mem_test(void)", "sline": 95}, "lv_mem_monitor": {"type": "Function", "def": "void lv_mem_monitor(lv_mem_monitor_t * mon_p)", "sline": 102}, "lv_mem_buf_get": {"type": "Function", "def": "void * lv_mem_buf_get(uint32_t size)", "sline": 109}, "lv_mem_buf_release": {"type": "Function", "def": "void lv_mem_buf_release(void * p)", "sline": 115}, "lv_mem_buf_free_all": {"type": "Function", "def": "void lv_mem_buf_free_all(void)", "sline": 120}, "lv_memcpy": {"type": "Function", "def": "void * lv_memcpy(void * dst, const void * src, size_t len)", "sline": 186}, "lv_memcpy_small": {"type": "Function", "def": "static inline void * lv_memcpy_small(void * dst, const void * src, size_t len)", "sline": 194, "body": "{\n    uint8_t * d8 = (uint8_t *)dst;\n    const uint8_t * s8 = (const uint8_t *)src;\n\n    while(len) {\n        *d8 = *s8;\n        d8++;\n        s8++;\n        len--;\n    }\n\n    return dst;\n}"}, "lv_memset": {"type": "Function", "def": "void lv_memset(void * dst, uint8_t v, size_t len)", "sline": 215}, "lv_memset_00": {"type": "Function", "def": "void lv_memset_00(void * dst, size_t len)", "sline": 222}, "lv_memset_ff": {"type": "Function", "def": "void lv_memset_ff(void * dst, size_t len)", "sline": 229}, "carbit_updater/lvgl/src/misc/lv_mem.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_mem.h"}}, "carbit_updater/lv_drivers/display/R61581.c": {"R61581": {"type": "Variable", "def": "#include R61581.h", "sline": 9, "include": ["carbit_updater/lv_drivers/display/R61581.h", null]}, "carbit_updater/lv_drivers/display/R61581.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/R61581.c"}}, "carbit_updater/lvgl/src/extra/libs/fsdrv/lv_fs_posix.c": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/extra/libs/fsdrv/lv_fs_posix.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/fsdrv/lv_fs_posix.c"}}, "carbit_updater/lv_drivers/indev/mouse.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 20}, "carbit_updater/lv_drivers/indev/mouse.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/indev/mouse.h"}}, "carbit_updater/lvgl/src/extra/widgets/chart/lv_chart.h": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 16}, "_silence_gcc_warning": {"type": "Struct", "def": "LV_EXPORT_CONST_INT(LV_CHART_POINT_NONE)", "sline": 26}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/chart/lv_chart.h:35:1)": {"type": "Enum", "def": "enum {\n    LV_CHART_TYPE_NONE,     /**< Don't draw the series*/\n    LV_CHART_TYPE_LINE,     /**< Connect the points with lines*/\n    LV_CHART_TYPE_BAR,      /**< Draw columns*/\n    LV_CHART_TYPE_SCATTER,  /**< Draw points and lines in 2D (x,y coordinates)*/\n}", "sline": 35, "docstring": "/**"}, "lv_chart_type_t": {"type": "Variable", "def": "typedef uint8_t lv_chart_type_t", "sline": 41}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/chart/lv_chart.h:46:1)": {"type": "Enum", "def": "enum {\n    LV_CHART_UPDATE_MODE_SHIFT,     /**< Shift old data to the left and add the new one the right*/\n    LV_CHART_UPDATE_MODE_CIRCULAR,  /**< Add the new data in a circular way*/\n}", "sline": 46, "docstring": "/**"}, "lv_chart_update_mode_t": {"type": "Variable", "def": "typedef uint8_t lv_chart_update_mode_t", "sline": 50}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/chart/lv_chart.h:55:1)": {"type": "Enum", "def": "enum {\n    LV_CHART_AXIS_PRIMARY_Y     = 0x00,\n    LV_CHART_AXIS_SECONDARY_Y   = 0x01,\n    LV_CHART_AXIS_PRIMARY_X     = 0x02,\n    LV_CHART_AXIS_SECONDARY_X   = 0x04,\n    _LV_CHART_AXIS_LAST\n}", "sline": 55, "docstring": "/**"}, "lv_chart_axis_t": {"type": "Variable", "def": "typedef uint8_t lv_chart_axis_t", "sline": 62}, "lv_chart_series_t.x_points": {"type": "Variable", "def": "lv_coord_t * x_points", "sline": 68, "in_struct": "lv_chart_series_t"}, "lv_chart_series_t.y_points": {"type": "Variable", "def": "lv_coord_t * y_points", "sline": 69, "in_struct": "lv_chart_series_t"}, "lv_chart_series_t.color": {"type": "Variable", "def": "lv_color_t color", "sline": 70, "in_struct": "lv_chart_series_t"}, "lv_chart_series_t.start_point": {"type": "Variable", "def": "uint16_t start_point", "sline": 71, "in_struct": "lv_chart_series_t"}, "lv_chart_series_t.hidden": {"type": "Variable", "def": "uint8_t hidden : 1", "sline": 72, "in_struct": "lv_chart_series_t"}, "lv_chart_series_t.x_ext_buf_assigned": {"type": "Variable", "def": "uint8_t x_ext_buf_assigned : 1", "sline": 73, "in_struct": "lv_chart_series_t"}, "lv_chart_series_t.y_ext_buf_assigned": {"type": "Variable", "def": "uint8_t y_ext_buf_assigned : 1", "sline": 74, "in_struct": "lv_chart_series_t"}, "lv_chart_series_t.x_axis_sec": {"type": "Variable", "def": "uint8_t x_axis_sec : 1", "sline": 75, "in_struct": "lv_chart_series_t"}, "lv_chart_series_t.y_axis_sec": {"type": "Variable", "def": "uint8_t y_axis_sec : 1", "sline": 76, "in_struct": "lv_chart_series_t"}, "lv_chart_series_t": {"type": "Variable", "def": "typedef struct {\n    lv_coord_t * x_points;\n    lv_coord_t * y_points;\n    lv_color_t color;\n    uint16_t start_point;\n    uint8_t hidden : 1;\n    uint8_t x_ext_buf_assigned : 1;\n    uint8_t y_ext_buf_assigned : 1;\n    uint8_t x_axis_sec : 1;\n    uint8_t y_axis_sec : 1;\n} lv_chart_series_t", "sline": 77, "docstring": "/**"}, "lv_chart_cursor_t.pos": {"type": "Variable", "def": "lv_point_t pos", "sline": 80, "in_struct": "lv_chart_cursor_t"}, "lv_chart_cursor_t.point_id": {"type": "Variable", "def": "uint16_t point_id", "sline": 81, "in_struct": "lv_chart_cursor_t"}, "lv_chart_cursor_t.color": {"type": "Variable", "def": "lv_color_t color", "sline": 82, "in_struct": "lv_chart_cursor_t"}, "lv_chart_cursor_t.ser": {"type": "Variable", "def": "lv_chart_series_t * ser", "sline": 83, "in_struct": "lv_chart_cursor_t"}, "lv_chart_cursor_t.dir": {"type": "Variable", "def": "lv_dir_t dir", "sline": 84, "in_struct": "lv_chart_cursor_t"}, "lv_chart_cursor_t.pos_set": {"type": "Variable", "def": "uint8_t pos_set: 1", "sline": 85, "in_struct": "lv_chart_cursor_t"}, "lv_chart_cursor_t": {"type": "Variable", "def": "typedef struct {\n    lv_point_t pos;\n    uint16_t point_id;\n    lv_color_t color;\n    lv_chart_series_t * ser;\n    lv_dir_t dir;\n    uint8_t pos_set: 1; /*1: pos is set; 0: point_id is set*/\n} lv_chart_cursor_t", "sline": 86}, "lv_chart_tick_dsc_t.major_len": {"type": "Variable", "def": "lv_coord_t major_len", "sline": 89, "in_struct": "lv_chart_tick_dsc_t"}, "lv_chart_tick_dsc_t.minor_len": {"type": "Variable", "def": "lv_coord_t minor_len", "sline": 90, "in_struct": "lv_chart_tick_dsc_t"}, "lv_chart_tick_dsc_t.draw_size": {"type": "Variable", "def": "lv_coord_t draw_size", "sline": 91, "in_struct": "lv_chart_tick_dsc_t"}, "lv_chart_tick_dsc_t.minor_cnt": {"type": "Variable", "def": "uint32_t minor_cnt : 15", "sline": 92, "in_struct": "lv_chart_tick_dsc_t"}, "lv_chart_tick_dsc_t.major_cnt": {"type": "Variable", "def": "uint32_t major_cnt : 15", "sline": 93, "in_struct": "lv_chart_tick_dsc_t"}, "lv_chart_tick_dsc_t.label_en": {"type": "Variable", "def": "uint32_t label_en  : 1", "sline": 94, "in_struct": "lv_chart_tick_dsc_t"}, "lv_chart_tick_dsc_t": {"type": "Variable", "def": "typedef struct {\n    lv_coord_t major_len;\n    lv_coord_t minor_len;\n    lv_coord_t draw_size;\n    uint32_t minor_cnt : 15;\n    uint32_t major_cnt : 15;\n    uint32_t label_en  : 1;\n} lv_chart_tick_dsc_t", "sline": 95}, "lv_chart_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 99, "in_struct": "lv_chart_t"}, "lv_chart_t.series_ll": {"type": "Variable", "def": "lv_ll_t series_ll", "sline": 100, "in_struct": "lv_chart_t"}, "lv_chart_t.cursor_ll": {"type": "Variable", "def": "lv_ll_t cursor_ll", "sline": 101, "in_struct": "lv_chart_t"}, "lv_chart_t.tick": {"type": "Variable", "def": "lv_chart_tick_dsc_t tick[4]", "sline": 102, "in_struct": "lv_chart_t"}, "lv_chart_t.ymin": {"type": "Variable", "def": "lv_coord_t ymin[2]", "sline": 103, "in_struct": "lv_chart_t"}, "lv_chart_t.ymax": {"type": "Variable", "def": "lv_coord_t ymax[2]", "sline": 104, "in_struct": "lv_chart_t"}, "lv_chart_t.xmin": {"type": "Variable", "def": "lv_coord_t xmin[2]", "sline": 105, "in_struct": "lv_chart_t"}, "lv_chart_t.xmax": {"type": "Variable", "def": "lv_coord_t xmax[2]", "sline": 106, "in_struct": "lv_chart_t"}, "lv_chart_t.pressed_point_id": {"type": "Variable", "def": "uint16_t pressed_point_id", "sline": 107, "in_struct": "lv_chart_t"}, "lv_chart_t.hdiv_cnt": {"type": "Variable", "def": "uint16_t hdiv_cnt", "sline": 108, "in_struct": "lv_chart_t"}, "lv_chart_t.vdiv_cnt": {"type": "Variable", "def": "uint16_t vdiv_cnt", "sline": 109, "in_struct": "lv_chart_t"}, "lv_chart_t.point_cnt": {"type": "Variable", "def": "uint16_t point_cnt", "sline": 110, "in_struct": "lv_chart_t"}, "lv_chart_t.zoom_x": {"type": "Variable", "def": "uint16_t zoom_x", "sline": 111, "in_struct": "lv_chart_t"}, "lv_chart_t.zoom_y": {"type": "Variable", "def": "uint16_t zoom_y", "sline": 112, "in_struct": "lv_chart_t"}, "lv_chart_t.type": {"type": "Variable", "def": "lv_chart_type_t type  : 3", "sline": 113, "in_struct": "lv_chart_t", "rels": [["lv_chart_type_t", null, "Typeof"]]}, "lv_chart_t.update_mode": {"type": "Variable", "def": "lv_chart_update_mode_t update_mode : 1", "sline": 114, "in_struct": "lv_chart_t", "rels": [["lv_chart_update_mode_t", null, "Typeof"]]}, "lv_chart_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    lv_ll_t series_ll;     /**< Linked list for the series (stores lv_chart_series_t)*/\n    lv_ll_t cursor_ll;     /**< Linked list for the cursors (stores lv_chart_cursor_t)*/\n    lv_chart_tick_dsc_t tick[4];\n    lv_coord_t ymin[2];\n    lv_coord_t ymax[2];\n    lv_coord_t xmin[2];\n    lv_coord_t xmax[2];\n    uint16_t pressed_point_id;\n    uint16_t hdiv_cnt;      /**< Number of horizontal division lines*/\n    uint16_t vdiv_cnt;      /**< Number of vertical division lines*/\n    uint16_t point_cnt;    /**< Point number in a data line*/\n    uint16_t zoom_x;\n    uint16_t zoom_y;\n    lv_chart_type_t type  : 3; /**< Line or column chart*/\n    lv_chart_update_mode_t update_mode : 1;\n} lv_chart_t", "sline": 115}, "lv_chart_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_chart_class", "sline": 117}, "lv_chart_draw_part_type_t": {"type": "Variable", "def": "typedef enum {\n    LV_CHART_DRAW_PART_DIV_LINE_INIT,    /**< Used before/after drawn the div lines*/\n    LV_CHART_DRAW_PART_DIV_LINE_HOR,     /**< Used for each horizontal division lines*/\n    LV_CHART_DRAW_PART_DIV_LINE_VER,     /**< Used for each vertical division lines*/\n    LV_CHART_DRAW_PART_LINE_AND_POINT,   /**< Used on line and scatter charts for lines and points*/\n    LV_CHART_DRAW_PART_BAR,              /**< Used on bar charts for the rectangles*/\n    LV_CHART_DRAW_PART_CURSOR,           /**< Used on cursor lines and points*/\n    LV_CHART_DRAW_PART_TICK_LABEL,       /**< Used on tick lines and labels*/\n} lv_chart_draw_part_type_t", "sline": 131}, "lv_chart_create": {"type": "Function", "def": "lv_obj_t * lv_chart_create(lv_obj_t * parent)", "sline": 142}, "lv_chart_set_type": {"type": "Function", "def": "void lv_chart_set_type(lv_obj_t * obj, lv_chart_type_t type)", "sline": 149}, "lv_chart_set_point_count": {"type": "Function", "def": "void lv_chart_set_point_count(lv_obj_t * obj, uint16_t cnt)", "sline": 155}, "lv_chart_set_range": {"type": "Function", "def": "void lv_chart_set_range(lv_obj_t * obj, lv_chart_axis_t axis, lv_coord_t min, lv_coord_t max)", "sline": 164}, "lv_chart_set_update_mode": {"type": "Function", "def": "void lv_chart_set_update_mode(lv_obj_t * obj, lv_chart_update_mode_t update_mode)", "sline": 171}, "lv_chart_set_div_line_count": {"type": "Function", "def": "void lv_chart_set_div_line_count(lv_obj_t * obj, uint8_t hdiv, uint8_t vdiv)", "sline": 179}, "lv_chart_set_zoom_x": {"type": "Function", "def": "void lv_chart_set_zoom_x(lv_obj_t * obj, uint16_t zoom_x)", "sline": 186}, "lv_chart_set_zoom_y": {"type": "Function", "def": "void lv_chart_set_zoom_y(lv_obj_t * obj, uint16_t zoom_y)", "sline": 193}, "lv_chart_get_zoom_x": {"type": "Function", "def": "uint16_t lv_chart_get_zoom_x(const lv_obj_t * obj)", "sline": 200}, "lv_chart_get_zoom_y": {"type": "Function", "def": "uint16_t lv_chart_get_zoom_y(const lv_obj_t * obj)", "sline": 207}, "lv_chart_set_axis_tick": {"type": "Function", "def": "void lv_chart_set_axis_tick(lv_obj_t * obj, lv_chart_axis_t axis, lv_coord_t major_len, lv_coord_t minor_len,\n                            lv_coord_t major_cnt, lv_coord_t minor_cnt, bool label_en, lv_coord_t draw_size)", "sline": 221}, "lv_chart_get_type": {"type": "Function", "def": "lv_chart_type_t lv_chart_get_type(const lv_obj_t * obj)", "sline": 229, "rels": [["lv_chart_type_t", null, "Typeof"]]}, "lv_chart_get_point_count": {"type": "Function", "def": "uint16_t lv_chart_get_point_count(const lv_obj_t * obj)", "sline": 236}, "lv_chart_get_x_start_point": {"type": "Function", "def": "uint16_t lv_chart_get_x_start_point(const lv_obj_t * obj, lv_chart_series_t * ser)", "sline": 244}, "lv_chart_get_point_pos_by_id": {"type": "Function", "def": "void lv_chart_get_point_pos_by_id(lv_obj_t * obj, lv_chart_series_t * ser, uint16_t id, lv_point_t * p_out)", "sline": 253}, "lv_chart_refresh": {"type": "Function", "def": "void lv_chart_refresh(lv_obj_t * obj)", "sline": 259}, "lv_chart_add_series": {"type": "Function", "def": "lv_chart_series_t * lv_chart_add_series(lv_obj_t * obj, lv_color_t color, lv_chart_axis_t axis)", "sline": 272}, "lv_chart_remove_series": {"type": "Function", "def": "void lv_chart_remove_series(lv_obj_t * obj, lv_chart_series_t * series)", "sline": 279}, "lv_chart_hide_series": {"type": "Function", "def": "void lv_chart_hide_series(lv_obj_t * chart, lv_chart_series_t * series, bool hide)", "sline": 287}, "lv_chart_set_series_color": {"type": "Function", "def": "void lv_chart_set_series_color(lv_obj_t * chart, lv_chart_series_t * series, lv_color_t color)", "sline": 295}, "lv_chart_set_x_start_point": {"type": "Function", "def": "void lv_chart_set_x_start_point(lv_obj_t * obj, lv_chart_series_t * ser, uint16_t id)", "sline": 304}, "lv_chart_get_series_next": {"type": "Function", "def": "lv_chart_series_t * lv_chart_get_series_next(const lv_obj_t * chart, const lv_chart_series_t * ser)", "sline": 312}, "lv_chart_add_cursor": {"type": "Function", "def": "lv_chart_cursor_t  * lv_chart_add_cursor(lv_obj_t * obj, lv_color_t color, lv_dir_t dir)", "sline": 327}, "lv_chart_set_cursor_pos": {"type": "Function", "def": "void lv_chart_set_cursor_pos(lv_obj_t * chart, lv_chart_cursor_t * cursor, lv_point_t * pos)", "sline": 335}, "lv_chart_set_cursor_point": {"type": "Function", "def": "void lv_chart_set_cursor_point(lv_obj_t * chart, lv_chart_cursor_t * cursor, lv_chart_series_t * ser,\n                               uint16_t point_id)", "sline": 344}, "lv_chart_get_cursor_point": {"type": "Function", "def": "lv_point_t lv_chart_get_cursor_point(lv_obj_t * chart, lv_chart_cursor_t * cursor)", "sline": 353}, "lv_chart_set_all_value": {"type": "Function", "def": "void lv_chart_set_all_value(lv_obj_t * obj, lv_chart_series_t * ser, lv_coord_t value)", "sline": 365}, "lv_chart_set_next_value": {"type": "Function", "def": "void lv_chart_set_next_value(lv_obj_t * obj, lv_chart_series_t * ser, lv_coord_t value)", "sline": 373}, "lv_chart_set_next_value2": {"type": "Function", "def": "void lv_chart_set_next_value2(lv_obj_t * obj, lv_chart_series_t * ser, lv_coord_t x_value, lv_coord_t y_value)", "sline": 382}, "lv_chart_set_value_by_id": {"type": "Function", "def": "void lv_chart_set_value_by_id(lv_obj_t * obj, lv_chart_series_t * ser, uint16_t id, lv_coord_t value)", "sline": 391}, "lv_chart_set_value_by_id2": {"type": "Function", "def": "void lv_chart_set_value_by_id2(lv_obj_t * obj, lv_chart_series_t * ser, uint16_t id, lv_coord_t x_value,\n                               lv_coord_t y_value)", "sline": 402}, "lv_chart_set_ext_y_array": {"type": "Function", "def": "void lv_chart_set_ext_y_array(lv_obj_t * obj, lv_chart_series_t * ser, lv_coord_t array[])", "sline": 412}, "lv_chart_set_ext_x_array": {"type": "Function", "def": "void lv_chart_set_ext_x_array(lv_obj_t * obj, lv_chart_series_t * ser, lv_coord_t array[])", "sline": 421}, "lv_chart_get_y_array": {"type": "Function", "def": "lv_coord_t * lv_chart_get_y_array(const lv_obj_t * obj, lv_chart_series_t * ser)", "sline": 429}, "lv_chart_get_x_array": {"type": "Function", "def": "lv_coord_t * lv_chart_get_x_array(const lv_obj_t * obj, lv_chart_series_t * ser)", "sline": 437}, "lv_chart_get_pressed_point": {"type": "Function", "def": "uint32_t lv_chart_get_pressed_point(const lv_obj_t * obj)", "sline": 444}, "carbit_updater/lvgl/src/extra/widgets/chart/lv_chart.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/chart/lv_chart.h"}}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_texture_cache.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../../lv_conf_internal.h", "sline": 17}, "lv_img_decoder": {"type": "Variable", "def": "#include ../../draw/lv_img_decoder.h", "sline": 20}, "lv_area": {"type": "Variable", "def": "#include ../../misc/lv_area.h", "sline": 21}, "lv_gpu_sdl_lru": {"type": "Variable", "def": "#include lv_gpu_sdl_lru.h", "sline": 22, "include": ["carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.h", null]}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_texture_cache.h:34:9).head": {"type": "Variable", "def": "char head[8]", "sline": 35, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_texture_cache.h:34:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_texture_cache.h:34:9).texture": {"type": "Variable", "def": "SDL_Texture * texture", "sline": 36, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_texture_cache.h:34:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_texture_cache.h:34:9)": {"type": "Struct", "def": "struct {\n    char head[8];\n    SDL_Texture * texture;\n}", "sline": 34, "body": "char head[8]\nSDL_Texture * texture\n"}, "lv_gpu_sdl_dec_dsc_userdata_t": {"type": "Variable", "def": "typedef struct {\n    char head[8];\n    SDL_Texture * texture;\n} lv_gpu_sdl_dec_dsc_userdata_t", "sline": 37}, "lv_gpu_cache_key_magic_t": {"type": "Variable", "def": "typedef enum {\n    LV_GPU_CACHE_KEY_MAGIC_ARC = 0x01,\n    LV_GPU_CACHE_KEY_MAGIC_IMG = 0x11,\n    LV_GPU_CACHE_KEY_MAGIC_LINE = 0x21,\n    LV_GPU_CACHE_KEY_MAGIC_RECT_BG = 0x31,\n    LV_GPU_CACHE_KEY_MAGIC_RECT_SHADOW = 0x32,\n    LV_GPU_CACHE_KEY_MAGIC_RECT_BORDER = 0x33,\n    LV_GPU_CACHE_KEY_MAGIC_FONT = 0x41,\n    LV_GPU_CACHE_KEY_TEMP = 0xFF,\n} lv_gpu_cache_key_magic_t", "sline": 48}, "lv_gpu_sdl_cache_flag_t": {"type": "Variable", "def": "typedef enum {\n    LV_GPU_SDL_CACHE_FLAG_NONE = 0,\n    LV_GPU_SDL_CACHE_FLAG_MANAGED = 1,\n} lv_gpu_sdl_cache_flag_t", "sline": 53}, "lv_gpu_sdl_cache_key_head_img_t.magic": {"type": "Variable", "def": "lv_gpu_cache_key_magic_t magic", "sline": 56, "in_struct": "lv_gpu_sdl_cache_key_head_img_t", "rels": [["lv_gpu_cache_key_magic_t", null, "Typeof"]]}, "lv_gpu_sdl_cache_key_head_img_t.type": {"type": "Variable", "def": "lv_img_src_t type", "sline": 57, "in_struct": "lv_gpu_sdl_cache_key_head_img_t"}, "lv_gpu_sdl_cache_key_head_img_t.frame_id": {"type": "Variable", "def": "int32_t frame_id", "sline": 58, "in_struct": "lv_gpu_sdl_cache_key_head_img_t"}, "lv_gpu_sdl_cache_key_head_img_t": {"type": "Variable", "def": "typedef struct {\n    lv_gpu_cache_key_magic_t magic;\n    lv_img_src_t type;\n    int32_t frame_id;\n} lv_gpu_sdl_cache_key_head_img_t", "sline": 59}, "_lv_gpu_sdl_texture_cache_init": {"type": "Function", "def": "void _lv_gpu_sdl_texture_cache_init()", "sline": 65}, "_lv_gpu_sdl_texture_cache_deinit": {"type": "Function", "def": "void _lv_gpu_sdl_texture_cache_deinit()", "sline": 67}, "lv_gpu_draw_cache_get": {"type": "Function", "def": "SDL_Texture * lv_gpu_draw_cache_get(const void * key, size_t key_length, bool * found)", "sline": 69}, "lv_gpu_draw_cache_get_with_userdata": {"type": "Function", "def": "SDL_Texture * lv_gpu_draw_cache_get_with_userdata(const void * key, size_t key_length, bool * found, void ** userdata)", "sline": 71}, "lv_gpu_draw_cache_put": {"type": "Function", "def": "void lv_gpu_draw_cache_put(const void * key, size_t key_length, SDL_Texture * texture)", "sline": 73}, "lv_gpu_draw_cache_put_advanced": {"type": "Function", "def": "void lv_gpu_draw_cache_put_advanced(const void * key, size_t key_length, SDL_Texture * texture, void * userdata,\n                                    lv_lru_free_t userdata_free, lv_gpu_sdl_cache_flag_t flags)", "sline": 75}, "lv_gpu_temp_texture_obtain": {"type": "Function", "def": "SDL_Texture * lv_gpu_temp_texture_obtain(SDL_Renderer * renderer, lv_coord_t width, lv_coord_t height)", "sline": 78}, "lv_gpu_sdl_img_cache_key_create": {"type": "Function", "def": "lv_gpu_sdl_cache_key_head_img_t * lv_gpu_sdl_img_cache_key_create(const void * src, int32_t frame_id, size_t * size)", "sline": 80}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_texture_cache.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_texture_cache.h"}}, "carbit_updater/lvgl/src/extra/others/lv_others.h": {"lv_snapshot": {"type": "Variable", "def": "#include snapshot/lv_snapshot.h", "sline": 16, "include": ["carbit_updater/lvgl/src/extra/others/snapshot/lv_snapshot.h", null]}, "carbit_updater/lvgl/src/extra/others/lv_others.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/others/lv_others.h"}}, "carbit_updater/lv_drivers/display/sunxifb.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 20}, "lvgl": {"type": "Variable", "def": "#include lvgl/lvgl.h", "sline": 29, "include": ["carbit_updater/lvgl/lvgl.h", null]}, "sunxifb_init": {"type": "Function", "def": "void sunxifb_init(uint32_t rotated)", "sline": 43}, "sunxifb_exit": {"type": "Function", "def": "void sunxifb_exit(void)", "sline": 44}, "sunxifb_flush": {"type": "Function", "def": "void sunxifb_flush(lv_disp_drv_t * drv, const lv_area_t * area, lv_color_t * color_p)", "sline": 45}, "sunxifb_get_sizes": {"type": "Function", "def": "void sunxifb_get_sizes(uint32_t *width, uint32_t *height)", "sline": 46}, "sunxifb_alloc": {"type": "Function", "def": "void* sunxifb_alloc(size_t size, char *label)", "sline": 47}, "sunxifb_free": {"type": "Function", "def": "void sunxifb_free(void **data, char *label)", "sline": 48}, "carbit_updater/lv_drivers/display/sunxifb.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/sunxifb.h"}}, "carbit_updater/lvgl/tests/src/test_fonts/font_2.c": {"carbit_updater/lvgl/tests/src/test_fonts/font_2.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/tests/src/test_fonts/font_2.c"}}, "carbit_updater/lvgl/src/hal/lv_hal_indev.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 18}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 20}, "stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 21}, "lv_area": {"type": "Variable", "def": "#include ../misc/lv_area.h", "sline": 22}, "lv_timer": {"type": "Variable", "def": "#include ../misc/lv_timer.h", "sline": 23}, "_lv_obj_t": {"type": "Struct", "def": "struct _lv_obj_t", "sline": 55}, "_lv_disp_t": {"type": "Struct", "def": "struct _lv_disp_t", "sline": 56}, "_lv_group_t": {"type": "Struct", "def": "struct _lv_group_t", "sline": 57}, "_lv_indev_t": {"type": "Struct", "def": "struct _lv_indev_t {\n    struct _lv_indev_drv_t * driver;\n    _lv_indev_proc_t proc;\n    struct _lv_obj_t * cursor;     /**< Cursor for LV_INPUT_TYPE_POINTER*/\n    struct _lv_group_t * group;    /**< Keypad destination group*/\n    const lv_point_t * btn_points; /**< Array points assigned to the button ()screen will be pressed\n                                      here by the buttons*/\n}", "sline": 175, "docstring": "/** The main input device descriptor with driver, runtime data ('proc') and some additional", "body": "struct _lv_indev_drv_t * driver\n_lv_indev_proc_t proc\nstruct _lv_obj_t * cursor\nstruct _lv_group_t * group\nconst lv_point_t * btn_points\n"}, "_lv_indev_drv_t": {"type": "Struct", "def": "struct _lv_indev_drv_t {\n\n    /**< Input device type*/\n    lv_indev_type_t type;\n\n    /**< Function pointer to read input device data.*/\n    void (*read_cb)(struct _lv_indev_drv_t * indev_drv, lv_indev_data_t * data);\n\n    /** Called when an action happened on the input device.\n     * The second parameter is the event from `lv_event_t`*/\n    void (*feedback_cb)(struct _lv_indev_drv_t *, uint8_t);\n\n#if LV_USE_USER_DATA\n    void * user_data;\n#endif\n\n    /**< Pointer to the assigned display*/\n    struct _lv_disp_t * disp;\n\n    /**< Timer to periodically read the input device*/\n    lv_timer_t * read_timer;\n\n    /**< Number of pixels to slide before actually drag the object*/\n    uint8_t scroll_limit;\n\n    /**< Drag throw slow-down in [%]. Greater value means faster slow-down*/\n    uint8_t scroll_throw;\n\n    /**< At least this difference should be between two points to evaluate as gesture*/\n    uint8_t gesture_min_velocity;\n\n    /**< At least this difference should be to send a gesture*/\n    uint8_t gesture_limit;\n\n    /**< Long press time in milliseconds*/\n    uint16_t long_press_time;\n\n    /**< Repeated trigger period in long press [ms]*/\n    uint16_t long_press_repeat_time;\n}", "sline": 88, "docstring": "/** Initialized by the user and registered by 'lv_indev_add()'*/", "body": "lv_indev_type_t type\nvoid (*read_cb)(struct _lv_indev_drv_t * indev_drv, lv_indev_data_t * data)\nvoid (*feedback_cb)(struct _lv_indev_drv_t *, uint8_t)\nvoid * user_data\nstruct _lv_disp_t * disp\nlv_timer_t * read_timer\nuint8_t scroll_limit\nuint8_t scroll_throw\nuint8_t gesture_min_velocity\nuint8_t gesture_limit\nuint16_t long_press_time\nuint16_t long_press_repeat_time\n"}, "lv_indev_type_t": {"type": "Variable", "def": "typedef enum {\n    LV_INDEV_TYPE_NONE,    /**< Uninitialized state*/\n    LV_INDEV_TYPE_POINTER, /**< Touch pad, mouse, external button*/\n    LV_INDEV_TYPE_KEYPAD,  /**< Keypad or keyboard*/\n    LV_INDEV_TYPE_BUTTON,  /**< External (hardware button) which is assigned to a specific point of the screen*/\n    LV_INDEV_TYPE_ENCODER, /**< Encoder with only Left, Right turn and a Button*/\n} lv_indev_type_t", "sline": 68, "docstring": "/** Possible input device types*/"}, "lv_indev_state_t": {"type": "Variable", "def": "typedef enum {\n    LV_INDEV_STATE_RELEASED = 0,\n    LV_INDEV_STATE_PRESSED\n} lv_indev_state_t", "sline": 74, "docstring": "/** States for input devices*/"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/hal/lv_hal_indev.h:77:9).point": {"type": "Variable", "def": "lv_point_t point", "sline": 78, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/hal/lv_hal_indev.h:77:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/hal/lv_hal_indev.h:77:9).key": {"type": "Variable", "def": "uint32_t key", "sline": 79, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/hal/lv_hal_indev.h:77:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/hal/lv_hal_indev.h:77:9).btn_id": {"type": "Variable", "def": "uint32_t btn_id", "sline": 80, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/hal/lv_hal_indev.h:77:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/hal/lv_hal_indev.h:77:9).enc_diff": {"type": "Variable", "def": "int16_t enc_diff", "sline": 81, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/hal/lv_hal_indev.h:77:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/hal/lv_hal_indev.h:77:9).state": {"type": "Variable", "def": "lv_indev_state_t state", "sline": 83, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/hal/lv_hal_indev.h:77:9)", "rels": [["lv_indev_state_t", null, "Typeof"]]}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/hal/lv_hal_indev.h:77:9).continue_reading": {"type": "Variable", "def": "bool continue_reading", "sline": 84, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/hal/lv_hal_indev.h:77:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/hal/lv_hal_indev.h:77:9)": {"type": "Struct", "def": "struct {\n    lv_point_t point; /**< For LV_INDEV_TYPE_POINTER the currently pressed point*/\n    uint32_t key;     /**< For LV_INDEV_TYPE_KEYPAD the currently pressed key*/\n    uint32_t btn_id;  /**< For LV_INDEV_TYPE_BUTTON the currently pressed button*/\n    int16_t enc_diff; /**< For LV_INDEV_TYPE_ENCODER number of steps since the previous read*/\n\n    lv_indev_state_t state; /**< LV_INDEV_STATE_REL or LV_INDEV_STATE_PR*/\n    bool continue_reading;  /**< If set to true, the read callback is invoked again*/\n}", "sline": 77, "docstring": "/** Data structure passed to an input driver to fill*/", "body": "lv_point_t point\nuint32_t key\nuint32_t btn_id\nint16_t enc_diff\nlv_indev_state_t state\nbool continue_reading\n"}, "lv_indev_data_t": {"type": "Variable", "def": "typedef struct {\n    lv_point_t point; /**< For LV_INDEV_TYPE_POINTER the currently pressed point*/\n    uint32_t key;     /**< For LV_INDEV_TYPE_KEYPAD the currently pressed key*/\n    uint32_t btn_id;  /**< For LV_INDEV_TYPE_BUTTON the currently pressed button*/\n    int16_t enc_diff; /**< For LV_INDEV_TYPE_ENCODER number of steps since the previous read*/\n\n    lv_indev_state_t state; /**< LV_INDEV_STATE_REL or LV_INDEV_STATE_PR*/\n    bool continue_reading;  /**< If set to true, the read callback is invoked again*/\n} lv_indev_data_t", "sline": 85, "docstring": "/** Data structure passed to an input driver to fill*/"}, "_lv_indev_drv_t.type": {"type": "Variable", "def": "lv_indev_type_t type", "sline": 91, "in_struct": "_lv_indev_drv_t", "rels": [["lv_indev_type_t", null, "Typeof"]]}, "_lv_indev_drv_t.read_cb": {"type": "Variable", "def": "void (*read_cb)(struct _lv_indev_drv_t * indev_drv, lv_indev_data_t * data)", "sline": 94, "in_struct": "_lv_indev_drv_t"}, "_lv_indev_drv_t.feedback_cb": {"type": "Variable", "def": "void (*feedback_cb)(struct _lv_indev_drv_t *, uint8_t)", "sline": 98, "in_struct": "_lv_indev_drv_t"}, "_lv_indev_drv_t.user_data": {"type": "Variable", "def": "void * user_data", "sline": 101, "in_struct": "_lv_indev_drv_t"}, "_lv_indev_drv_t.disp": {"type": "Variable", "def": "struct _lv_disp_t * disp", "sline": 105, "in_struct": "_lv_indev_drv_t"}, "_lv_indev_drv_t.read_timer": {"type": "Variable", "def": "lv_timer_t * read_timer", "sline": 108, "in_struct": "_lv_indev_drv_t"}, "_lv_indev_drv_t.scroll_limit": {"type": "Variable", "def": "uint8_t scroll_limit", "sline": 111, "in_struct": "_lv_indev_drv_t"}, "_lv_indev_drv_t.scroll_throw": {"type": "Variable", "def": "uint8_t scroll_throw", "sline": 114, "in_struct": "_lv_indev_drv_t"}, "_lv_indev_drv_t.gesture_min_velocity": {"type": "Variable", "def": "uint8_t gesture_min_velocity", "sline": 117, "in_struct": "_lv_indev_drv_t"}, "_lv_indev_drv_t.gesture_limit": {"type": "Variable", "def": "uint8_t gesture_limit", "sline": 120, "in_struct": "_lv_indev_drv_t"}, "_lv_indev_drv_t.long_press_time": {"type": "Variable", "def": "uint16_t long_press_time", "sline": 123, "in_struct": "_lv_indev_drv_t"}, "_lv_indev_drv_t.long_press_repeat_time": {"type": "Variable", "def": "uint16_t long_press_repeat_time", "sline": 126, "in_struct": "_lv_indev_drv_t"}, "lv_indev_drv_t": {"type": "Variable", "def": "typedef struct _lv_indev_drv_t {\n\n    /**< Input device type*/\n    lv_indev_type_t type;\n\n    /**< Function pointer to read input device data.*/\n    void (*read_cb)(struct _lv_indev_drv_t * indev_drv, lv_indev_data_t * data);\n\n    /** Called when an action happened on the input device.\n     * The second parameter is the event from `lv_event_t`*/\n    void (*feedback_cb)(struct _lv_indev_drv_t *, uint8_t);\n\n#if LV_USE_USER_DATA\n    void * user_data;\n#endif\n\n    /**< Pointer to the assigned display*/\n    struct _lv_disp_t * disp;\n\n    /**< Timer to periodically read the input device*/\n    lv_timer_t * read_timer;\n\n    /**< Number of pixels to slide before actually drag the object*/\n    uint8_t scroll_limit;\n\n    /**< Drag throw slow-down in [%]. Greater value means faster slow-down*/\n    uint8_t scroll_throw;\n\n    /**< At least this difference should be between two points to evaluate as gesture*/\n    uint8_t gesture_min_velocity;\n\n    /**< At least this difference should be to send a gesture*/\n    uint8_t gesture_limit;\n\n    /**< Long press time in milliseconds*/\n    uint16_t long_press_time;\n\n    /**< Repeated trigger period in long press [ms]*/\n    uint16_t long_press_repeat_time;\n} lv_indev_drv_t", "sline": 127, "docstring": "/** Initialized by the user and registered by 'lv_indev_add()'*/"}, "_lv_indev_proc_t.state": {"type": "Variable", "def": "lv_indev_state_t state", "sline": 133, "in_struct": "_lv_indev_proc_t", "rels": [["lv_indev_state_t", null, "Typeof"]]}, "_lv_indev_proc_t.long_pr_sent": {"type": "Variable", "def": "uint8_t long_pr_sent : 1", "sline": 135, "in_struct": "_lv_indev_proc_t"}, "_lv_indev_proc_t.reset_query": {"type": "Variable", "def": "uint8_t reset_query : 1", "sline": 136, "in_struct": "_lv_indev_proc_t"}, "_lv_indev_proc_t.disabled": {"type": "Variable", "def": "uint8_t disabled : 1", "sline": 137, "in_struct": "_lv_indev_proc_t"}, "_lv_indev_proc_t.wait_until_release": {"type": "Variable", "def": "uint8_t wait_until_release : 1", "sline": 138, "in_struct": "_lv_indev_proc_t"}, "_lv_indev_proc_t.types": {"type": "Variable", "def": "union {\n        struct {\n            /*Pointer and button data*/\n            lv_point_t act_point; /**< Current point of input device.*/\n            lv_point_t last_point; /**< Last point of input device.*/\n            lv_point_t last_raw_point; /**< Last point read from read_cb. */\n            lv_point_t vect; /**< Difference between `act_point` and `last_point`.*/\n            lv_point_t scroll_sum; /*Count the dragged pixels to check LV_INDEV_DEF_SCROLL_LIMIT*/\n            lv_point_t scroll_throw_vect;\n            lv_point_t scroll_throw_vect_ori;\n            struct _lv_obj_t * act_obj;      /*The object being pressed*/\n            struct _lv_obj_t * last_obj;     /*The last object which was pressed*/\n            struct _lv_obj_t * scroll_obj;   /*The object being scrolled*/\n            struct _lv_obj_t * last_pressed; /*The lastly pressed object*/\n            lv_area_t scroll_area;\n\n            lv_point_t gesture_sum; /*Count the gesture pixels to check LV_INDEV_DEF_GESTURE_LIMIT*/\n            /*Flags*/\n            lv_dir_t scroll_dir : 4;\n            lv_dir_t gesture_dir : 4;\n            uint8_t gesture_sent : 1;\n        } pointer;\n        struct {\n            /*Keypad data*/\n            lv_indev_state_t last_state;\n            uint32_t last_key;\n        } keypad;\n    } types", "sline": 167, "in_struct": "_lv_indev_proc_t"}, "_lv_indev_proc_t.pr_timestamp": {"type": "Variable", "def": "uint32_t pr_timestamp", "sline": 169, "in_struct": "_lv_indev_proc_t"}, "_lv_indev_proc_t.longpr_rep_timestamp": {"type": "Variable", "def": "uint32_t longpr_rep_timestamp", "sline": 170, "in_struct": "_lv_indev_proc_t"}, "_lv_indev_proc_t": {"type": "Variable", "def": "typedef struct _lv_indev_proc_t {\n    lv_indev_state_t state; /**< Current state of the input device.*/\n    /*Flags*/\n    uint8_t long_pr_sent : 1;\n    uint8_t reset_query : 1;\n    uint8_t disabled : 1;\n    uint8_t wait_until_release : 1;\n\n    union {\n        struct {\n            /*Pointer and button data*/\n            lv_point_t act_point; /**< Current point of input device.*/\n            lv_point_t last_point; /**< Last point of input device.*/\n            lv_point_t last_raw_point; /**< Last point read from read_cb. */\n            lv_point_t vect; /**< Difference between `act_point` and `last_point`.*/\n            lv_point_t scroll_sum; /*Count the dragged pixels to check LV_INDEV_DEF_SCROLL_LIMIT*/\n            lv_point_t scroll_throw_vect;\n            lv_point_t scroll_throw_vect_ori;\n            struct _lv_obj_t * act_obj;      /*The object being pressed*/\n            struct _lv_obj_t * last_obj;     /*The last object which was pressed*/\n            struct _lv_obj_t * scroll_obj;   /*The object being scrolled*/\n            struct _lv_obj_t * last_pressed; /*The lastly pressed object*/\n            lv_area_t scroll_area;\n\n            lv_point_t gesture_sum; /*Count the gesture pixels to check LV_INDEV_DEF_GESTURE_LIMIT*/\n            /*Flags*/\n            lv_dir_t scroll_dir : 4;\n            lv_dir_t gesture_dir : 4;\n            uint8_t gesture_sent : 1;\n        } pointer;\n        struct {\n            /*Keypad data*/\n            lv_indev_state_t last_state;\n            uint32_t last_key;\n        } keypad;\n    } types;\n\n    uint32_t pr_timestamp;         /**< Pressed time stamp*/\n    uint32_t longpr_rep_timestamp; /**< Long press repeat time stamp*/\n} _lv_indev_proc_t", "sline": 171, "docstring": "/** Run time data of input devices"}, "_lv_indev_t.driver": {"type": "Variable", "def": "struct _lv_indev_drv_t * driver", "sline": 176, "in_struct": "_lv_indev_t"}, "_lv_indev_t.proc": {"type": "Variable", "def": "_lv_indev_proc_t proc", "sline": 177, "in_struct": "_lv_indev_t", "rels": [["_lv_indev_proc_t", null, "Typeof"]]}, "_lv_indev_t.cursor": {"type": "Variable", "def": "struct _lv_obj_t * cursor", "sline": 178, "in_struct": "_lv_indev_t"}, "_lv_indev_t.group": {"type": "Variable", "def": "struct _lv_group_t * group", "sline": 179, "in_struct": "_lv_indev_t"}, "_lv_indev_t.btn_points": {"type": "Variable", "def": "const lv_point_t * btn_points", "sline": 180, "in_struct": "_lv_indev_t"}, "lv_indev_t": {"type": "Variable", "def": "typedef struct _lv_indev_t {\n    struct _lv_indev_drv_t * driver;\n    _lv_indev_proc_t proc;\n    struct _lv_obj_t * cursor;     /**< Cursor for LV_INPUT_TYPE_POINTER*/\n    struct _lv_group_t * group;    /**< Keypad destination group*/\n    const lv_point_t * btn_points; /**< Array points assigned to the button ()screen will be pressed\n                                      here by the buttons*/\n} lv_indev_t", "sline": 182, "docstring": "/** The main input device descriptor with driver, runtime data ('proc') and some additional"}, "lv_indev_drv_init": {"type": "Function", "def": "void lv_indev_drv_init(struct _lv_indev_drv_t * driver)", "sline": 194}, "lv_indev_drv_register": {"type": "Function", "def": "lv_indev_t * lv_indev_drv_register(struct _lv_indev_drv_t * driver)", "sline": 201}, "lv_indev_drv_update": {"type": "Function", "def": "void lv_indev_drv_update(lv_indev_t * indev, struct _lv_indev_drv_t * new_drv)", "sline": 208}, "lv_indev_get_next": {"type": "Function", "def": "lv_indev_t * lv_indev_get_next(lv_indev_t * indev)", "sline": 216}, "_lv_indev_read": {"type": "Function", "def": "void _lv_indev_read(lv_indev_t * indev, lv_indev_data_t * data)", "sline": 223}, "carbit_updater/lvgl/src/hal/lv_hal_indev.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/hal/lv_hal_indev.h"}}, "carbit_updater/lvgl/src/core/lv_refr.h": {"lv_obj": {"type": "Variable", "def": "#include lv_obj.h", "sline": 16, "include": ["carbit_updater/lvgl/src/core/lv_obj.h", null]}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 17}, "_lv_refr_init": {"type": "Function", "def": "void _lv_refr_init(void)", "sline": 48}, "lv_refr_now": {"type": "Function", "def": "void lv_refr_now(lv_disp_t * disp)", "sline": 57}, "_lv_inv_area": {"type": "Function", "def": "void _lv_inv_area(lv_disp_t * disp, const lv_area_t * area_p)", "sline": 65}, "_lv_refr_get_disp_refreshing": {"type": "Function", "def": "lv_disp_t * _lv_refr_get_disp_refreshing(void)", "sline": 71}, "_lv_refr_set_disp_refreshing": {"type": "Function", "def": "void _lv_refr_set_disp_refreshing(lv_disp_t * disp)", "sline": 79}, "_lv_disp_refr_timer": {"type": "Function", "def": "void _lv_disp_refr_timer(lv_timer_t * timer)", "sline": 93}, "carbit_updater/lvgl/src/core/lv_refr.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_refr.h"}}, "carbit_updater/lvgl/src/widgets/lv_canvas.c": {"lv_canvas": {"type": "Variable", "def": "#include lv_canvas.h", "sline": 9, "include": ["carbit_updater/lvgl/src/widgets/lv_canvas.h", null]}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 10}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 11}, "lv_draw": {"type": "Variable", "def": "#include ../draw/lv_draw.h", "sline": 12}, "lv_refr": {"type": "Variable", "def": "#include ../core/lv_refr.h", "sline": 13}, "lv_canvas_constructor": {"type": "Function", "def": "static void lv_canvas_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 907, "body": "{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_canvas_t * canvas = (lv_canvas_t *)obj;\n\n    canvas->dsc.header.always_zero = 0;\n    canvas->dsc.header.cf          = LV_IMG_CF_TRUE_COLOR;\n    canvas->dsc.header.h           = 0;\n    canvas->dsc.header.w           = 0;\n    canvas->dsc.data_size          = 0;\n    canvas->dsc.data               = NULL;\n\n    lv_img_set_src(obj, &canvas->dsc);\n\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}"}, "lv_canvas_destructor": {"type": "Function", "def": "static void lv_canvas_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 926, "body": "{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_canvas_t * canvas = (lv_canvas_t *)obj;\n    lv_img_cache_invalidate_src(&canvas->dsc);\n}"}, "lv_canvas_class": {"type": "Variable", "def": "const lv_obj_class_t lv_canvas_class = {\n    .constructor_cb = lv_canvas_constructor,\n    .destructor_cb = lv_canvas_destructor,\n    .instance_size = sizeof(lv_canvas_t),\n    .base_class = &lv_img_class\n}", "sline": 35}, "lv_canvas_create": {"type": "Function", "def": "lv_obj_t * lv_canvas_create(lv_obj_t * parent)", "sline": 50, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_canvas_set_buffer": {"type": "Function", "def": "void lv_canvas_set_buffer(lv_obj_t * obj, void * buf, lv_coord_t w, lv_coord_t h, lv_img_cf_t cf)", "sline": 62, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(buf);\n\n    lv_canvas_t * canvas = (lv_canvas_t *)obj;\n\n    canvas->dsc.header.cf = cf;\n    canvas->dsc.header.w  = w;\n    canvas->dsc.header.h  = h;\n    canvas->dsc.data      = buf;\n\n    lv_img_set_src(obj, &canvas->dsc);\n}"}, "lv_canvas_set_px_color": {"type": "Function", "def": "void lv_canvas_set_px_color(lv_obj_t * obj, lv_coord_t x, lv_coord_t y, lv_color_t c)", "sline": 77, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_canvas_t * canvas = (lv_canvas_t *)obj;\n\n    lv_img_buf_set_px_color(&canvas->dsc, x, y, c);\n    lv_obj_invalidate(obj);\n}"}, "lv_canvas_set_px_opa": {"type": "Function", "def": "void lv_canvas_set_px_opa(lv_obj_t * obj, lv_coord_t x, lv_coord_t y, lv_opa_t opa)", "sline": 87, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_canvas_t * canvas = (lv_canvas_t *)obj;\n\n    lv_img_buf_set_px_alpha(&canvas->dsc, x, y, opa);\n    lv_obj_invalidate(obj);\n}"}, "lv_canvas_set_palette": {"type": "Function", "def": "void lv_canvas_set_palette(lv_obj_t * obj, uint8_t id, lv_color_t c)", "sline": 97, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_canvas_t * canvas = (lv_canvas_t *)obj;\n\n    lv_img_buf_set_palette(&canvas->dsc, id, c);\n    lv_obj_invalidate(obj);\n}"}, "lv_canvas_get_px": {"type": "Function", "def": "lv_color_t lv_canvas_get_px(lv_obj_t * obj, lv_coord_t x, lv_coord_t y)", "sline": 111, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_canvas_t * canvas = (lv_canvas_t *)obj;\n    lv_color_t color = lv_obj_get_style_img_recolor(obj, LV_PART_MAIN);\n\n    return lv_img_buf_get_px_color(&canvas->dsc, x, y, color);\n}"}, "lv_canvas_get_img": {"type": "Function", "def": "lv_img_dsc_t * lv_canvas_get_img(lv_obj_t * obj)", "sline": 121, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_canvas_t * canvas = (lv_canvas_t *)obj;\n    return &canvas->dsc;\n}"}, "lv_canvas_copy_buf": {"type": "Function", "def": "void lv_canvas_copy_buf(lv_obj_t * obj, const void * to_copy, lv_coord_t x, lv_coord_t y, lv_coord_t w, lv_coord_t h)", "sline": 133, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(to_copy);\n\n    lv_canvas_t * canvas = (lv_canvas_t *)obj;\n\n    if(x + w >= (lv_coord_t)canvas->dsc.header.w || y + h >= (lv_coord_t)canvas->dsc.header.h) {\n        LV_LOG_WARN(\"lv_canvas_copy_buf: x or y out of the canvas\");\n        return;\n    }\n\n    uint32_t px_size   = lv_img_cf_get_px_size(canvas->dsc.header.cf) >> 3;\n    uint32_t px        = canvas->dsc.header.w * y * px_size + x * px_size;\n    uint8_t * to_copy8 = (uint8_t *)to_copy;\n    lv_coord_t i;\n    for(i = 0; i < h; i++) {\n        lv_memcpy((void *)&canvas->dsc.data[px], to_copy8, w * px_size);\n        px += canvas->dsc.header.w * px_size;\n        to_copy8 += w * px_size;\n    }\n}"}, "lv_canvas_transform": {"type": "Function", "def": "void lv_canvas_transform(lv_obj_t * obj, lv_img_dsc_t * img, int16_t angle, uint16_t zoom, lv_coord_t offset_x,\n                         lv_coord_t offset_y,\n                         int32_t pivot_x, int32_t pivot_y, bool antialias)", "sline": 156, "body": "{\n#if LV_DRAW_COMPLEX\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(img);\n\n    lv_canvas_t * canvas = (lv_canvas_t *)obj;\n    lv_color_t color = lv_obj_get_style_img_recolor(obj, LV_PART_MAIN);\n\n    int32_t dest_width  = canvas->dsc.header.w;\n    int32_t dest_height = canvas->dsc.header.h;\n\n    int32_t x;\n    int32_t y;\n    bool ret;\n\n    lv_img_transform_dsc_t dsc;\n    dsc.cfg.angle = angle;\n    dsc.cfg.zoom = zoom;\n    dsc.cfg.src = img->data;\n    dsc.cfg.src_w = img->header.w;\n    dsc.cfg.src_h = img->header.h;\n    dsc.cfg.cf = img->header.cf;\n    dsc.cfg.pivot_x = pivot_x;\n    dsc.cfg.pivot_y = pivot_y;\n    dsc.cfg.color = color;\n    dsc.cfg.antialias = antialias;\n    _lv_img_buf_transform_init(&dsc);\n\n    for(y = -offset_y; y < dest_height - offset_y; y++) {\n        for(x = -offset_x; x < dest_width - offset_x; x++) {\n\n            ret = _lv_img_buf_transform(&dsc, x, y);\n\n            if(ret == false) continue;\n\n            if(x + offset_x >= 0 && x + offset_x < dest_width && y + offset_y >= 0 && y + offset_y < dest_height) {\n                /*If the image has no alpha channel just simple set the result color on the canvas*/\n                if(lv_img_cf_has_alpha(img->header.cf) == false) {\n                    lv_img_buf_set_px_color(&canvas->dsc, x + offset_x, y + offset_y, dsc.res.color);\n                }\n                else {\n                    lv_color_t bg_color = lv_img_buf_get_px_color(&canvas->dsc, x + offset_x, y + offset_y, dsc.cfg.color);\n\n                    /*If the canvas has no alpha but the image has mix the image's color with\n                     * canvas*/\n                    if(lv_img_cf_has_alpha(canvas->dsc.header.cf) == false) {\n                        if(dsc.res.opa < LV_OPA_MAX) dsc.res.color = lv_color_mix(dsc.res.color, bg_color, dsc.res.opa);\n                        lv_img_buf_set_px_color(&canvas->dsc, x + offset_x, y + offset_y, dsc.res.color);\n                    }\n                    /*Both the image and canvas has alpha channel. Some extra calculation is\n                       required*/\n                    else {\n                        lv_opa_t bg_opa = lv_img_buf_get_px_alpha(&canvas->dsc, x + offset_x, y + offset_y);\n                        /*Pick the foreground if it's fully opaque or the Background is fully\n                         *transparent*/\n                        if(dsc.res.opa >= LV_OPA_MAX || bg_opa <= LV_OPA_MIN) {\n                            lv_img_buf_set_px_color(&canvas->dsc, x + offset_x, y + offset_y, dsc.res.color);\n                            lv_img_buf_set_px_alpha(&canvas->dsc, x + offset_x, y + offset_y, dsc.res.opa);\n                        }\n                        /*Opaque background: use simple mix*/\n                        else if(bg_opa >= LV_OPA_MAX) {\n                            lv_img_buf_set_px_color(&canvas->dsc, x + offset_x, y + offset_y,\n                                                    lv_color_mix(dsc.res.color, bg_color, dsc.res.opa));\n                        }\n                        /*Both colors have alpha. Expensive calculation need to be applied*/\n                        else {\n\n                            /*Info:\n                             * https://en.wikipedia.org/wiki/Alpha_compositing#Analytical_derivation_of_the_over_operator*/\n                            lv_opa_t opa_res_2 = 255 - ((uint16_t)((uint16_t)(255 - dsc.res.opa) * (255 - bg_opa)) >> 8);\n                            if(opa_res_2 == 0) {\n                                opa_res_2 = 1; /*never happens, just to be sure*/\n                            }\n                            lv_opa_t ratio = (uint16_t)((uint16_t)dsc.res.opa * 255) / opa_res_2;\n\n                            lv_img_buf_set_px_color(&canvas->dsc, x + offset_x, y + offset_y,\n                                                    lv_color_mix(dsc.res.color, bg_color, ratio));\n                            lv_img_buf_set_px_alpha(&canvas->dsc, x + offset_x, y + offset_y, opa_res_2);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    lv_obj_invalidate(obj);\n#else\n    LV_UNUSED(obj);\n    LV_UNUSED(img);\n    LV_UNUSED(angle);\n    LV_UNUSED(zoom);\n    LV_UNUSED(offset_x);\n    LV_UNUSED(offset_y);\n    LV_UNUSED(pivot_x);\n    LV_UNUSED(pivot_y);\n    LV_UNUSED(antialias);\n    LV_LOG_WARN(\"Can't transform canvas with LV_DRAW_COMPLEX == 0\");\n#endif\n}"}, "lv_canvas_blur_hor": {"type": "Function", "def": "void lv_canvas_blur_hor(lv_obj_t * obj, const lv_area_t * area, uint16_t r)", "sline": 259, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    if(r == 0) return;\n\n    lv_canvas_t * canvas = (lv_canvas_t *)obj;\n\n    lv_area_t a;\n    if(area) {\n        lv_area_copy(&a, area);\n        if(a.x1 < 0) a.x1 = 0;\n        if(a.y1 < 0) a.y1 = 0;\n        if(a.x2 > canvas->dsc.header.w - 1) a.x2 = canvas->dsc.header.w - 1;\n        if(a.y2 > canvas->dsc.header.h - 1) a.y2 = canvas->dsc.header.h - 1;\n    }\n    else {\n        a.x1 = 0;\n        a.y1 = 0;\n        a.x2 = canvas->dsc.header.w - 1;\n        a.y2 = canvas->dsc.header.h - 1;\n    }\n\n    lv_color_t color = lv_obj_get_style_img_recolor(obj, LV_PART_MAIN);\n\n    uint16_t r_back = r / 2;\n    uint16_t r_front = r / 2;\n\n    if((r & 0x1) == 0) r_back--;\n\n    bool has_alpha = lv_img_cf_has_alpha(canvas->dsc.header.cf);\n\n    lv_coord_t line_w = lv_img_buf_get_img_size(canvas->dsc.header.w, 1, canvas->dsc.header.cf);\n    uint8_t * line_buf = lv_mem_buf_get(line_w);\n\n    lv_img_dsc_t line_img;\n    line_img.data = line_buf;\n    line_img.header.always_zero = 0;\n    line_img.header.w = canvas->dsc.header.w;\n    line_img.header.h = 1;\n    line_img.header.cf = canvas->dsc.header.cf;\n\n    lv_coord_t x;\n    lv_coord_t y;\n    lv_coord_t x_safe;\n\n    for(y = a.y1; y <= a.y2; y++) {\n        uint32_t asum = 0;\n        uint32_t rsum = 0;\n        uint32_t gsum = 0;\n        uint32_t bsum = 0;\n\n        lv_color_t c;\n        lv_opa_t opa = LV_OPA_TRANSP;\n        lv_memcpy(line_buf, &canvas->dsc.data[y * line_w], line_w);\n\n        for(x = a.x1 - r_back; x <= a.x1 + r_front; x++) {\n            x_safe = x < 0 ? 0 : x;\n            x_safe = x_safe > canvas->dsc.header.w - 1 ? canvas->dsc.header.w - 1 : x_safe;\n\n            c = lv_img_buf_get_px_color(&line_img, x_safe, 0, color);\n            if(has_alpha) opa = lv_img_buf_get_px_alpha(&line_img, x_safe, 0);\n\n            rsum += c.ch.red;\n#if LV_COLOR_DEPTH == 16 && LV_COLOR_16_SWAP\n            gsum += (c.ch.green_h << 3) + c.ch.green_l;\n#else\n            gsum += c.ch.green;\n#endif\n            bsum += c.ch.blue;\n            if(has_alpha) asum += opa;\n        }\n\n        /*Just to indicate that the px is visible*/\n        if(has_alpha == false) asum = LV_OPA_COVER;\n\n        for(x = a.x1; x <= a.x2; x++) {\n\n            if(asum) {\n                c.ch.red = rsum / r;\n#if LV_COLOR_DEPTH == 16 && LV_COLOR_16_SWAP\n                uint8_t gtmp = gsum / r;\n                c.ch.green_h = gtmp >> 3;\n                c.ch.green_l = gtmp & 0x7;\n#else\n                c.ch.green = gsum / r;\n#endif\n                c.ch.blue = bsum / r;\n                if(has_alpha) opa = asum / r;\n\n                lv_img_buf_set_px_color(&canvas->dsc, x, y, c);\n            }\n            if(has_alpha) lv_img_buf_set_px_alpha(&canvas->dsc, x, y, opa);\n\n            x_safe = x - r_back;\n            x_safe = x_safe < 0 ? 0 : x_safe;\n            c = lv_img_buf_get_px_color(&line_img, x_safe, 0, color);\n            if(has_alpha) opa = lv_img_buf_get_px_alpha(&line_img, x_safe, 0);\n\n            rsum -= c.ch.red;\n#if LV_COLOR_DEPTH == 16 && LV_COLOR_16_SWAP\n            gsum -= (c.ch.green_h << 3) + c.ch.green_l;\n#else\n            gsum -= c.ch.green;\n#endif\n            bsum -= c.ch.blue;\n            if(has_alpha) asum -= opa;\n\n            x_safe = x + 1 + r_front;\n            x_safe = x_safe > canvas->dsc.header.w - 1 ? canvas->dsc.header.w - 1 : x_safe;\n            c = lv_img_buf_get_px_color(&line_img, x_safe, 0, lv_color_white());\n            if(has_alpha) opa = lv_img_buf_get_px_alpha(&line_img, x_safe, 0);\n\n            rsum += c.ch.red;\n#if LV_COLOR_DEPTH == 16 && LV_COLOR_16_SWAP\n            gsum += (c.ch.green_h << 3) + c.ch.green_l;\n#else\n            gsum += c.ch.green;\n#endif\n            bsum += c.ch.blue;\n            if(has_alpha) asum += opa;\n        }\n    }\n    lv_obj_invalidate(obj);\n\n    lv_mem_buf_release(line_buf);\n}"}, "lv_canvas_blur_ver": {"type": "Function", "def": "void lv_canvas_blur_ver(lv_obj_t * obj, const lv_area_t * area, uint16_t r)", "sline": 387, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    if(r == 0) return;\n\n    lv_canvas_t * canvas = (lv_canvas_t *)obj;\n\n    lv_area_t a;\n    if(area) {\n        lv_area_copy(&a, area);\n        if(a.x1 < 0) a.x1 = 0;\n        if(a.y1 < 0) a.y1 = 0;\n        if(a.x2 > canvas->dsc.header.w - 1) a.x2 = canvas->dsc.header.w - 1;\n        if(a.y2 > canvas->dsc.header.h - 1) a.y2 = canvas->dsc.header.h - 1;\n    }\n    else {\n        a.x1 = 0;\n        a.y1 = 0;\n        a.x2 = canvas->dsc.header.w - 1;\n        a.y2 = canvas->dsc.header.h - 1;\n    }\n\n    lv_color_t color = lv_obj_get_style_img_recolor(obj, LV_PART_MAIN);\n\n    uint16_t r_back = r / 2;\n    uint16_t r_front = r / 2;\n\n    if((r & 0x1) == 0) r_back--;\n\n    bool has_alpha = lv_img_cf_has_alpha(canvas->dsc.header.cf);\n    lv_coord_t col_w = lv_img_buf_get_img_size(1, canvas->dsc.header.h, canvas->dsc.header.cf);\n    uint8_t * col_buf = lv_mem_buf_get(col_w);\n    lv_img_dsc_t line_img;\n\n    line_img.data = col_buf;\n    line_img.header.always_zero = 0;\n    line_img.header.w = 1;\n    line_img.header.h = canvas->dsc.header.h;\n    line_img.header.cf = canvas->dsc.header.cf;\n\n    lv_coord_t x;\n    lv_coord_t y;\n    lv_coord_t y_safe;\n\n    for(x = a.x1; x <= a.x2; x++) {\n        uint32_t asum = 0;\n        uint32_t rsum = 0;\n        uint32_t gsum = 0;\n        uint32_t bsum = 0;\n\n        lv_color_t c;\n        lv_opa_t opa = LV_OPA_COVER;\n\n        for(y = a.y1 - r_back; y <= a.y1 + r_front; y++) {\n            y_safe = y < 0 ? 0 : y;\n            y_safe = y_safe > canvas->dsc.header.h - 1 ? canvas->dsc.header.h - 1 : y_safe;\n\n            c = lv_img_buf_get_px_color(&canvas->dsc, x, y_safe, color);\n            if(has_alpha) opa = lv_img_buf_get_px_alpha(&canvas->dsc, x, y_safe);\n\n            lv_img_buf_set_px_color(&line_img, 0, y_safe, c);\n            if(has_alpha) lv_img_buf_set_px_alpha(&line_img, 0, y_safe, opa);\n\n            rsum += c.ch.red;\n#if LV_COLOR_DEPTH == 16 && LV_COLOR_16_SWAP\n            gsum += (c.ch.green_h << 3) + c.ch.green_l;\n#else\n            gsum += c.ch.green;\n#endif\n            bsum += c.ch.blue;\n            if(has_alpha) asum += opa;\n        }\n\n        /*Just to indicate that the px is visible*/\n        if(has_alpha == false) asum = LV_OPA_COVER;\n\n        for(y = a.y1; y <= a.y2; y++) {\n            if(asum) {\n                c.ch.red = rsum / r;\n#if LV_COLOR_DEPTH == 16 && LV_COLOR_16_SWAP\n                uint8_t gtmp = gsum / r;\n                c.ch.green_h = gtmp >> 3;\n                c.ch.green_l = gtmp & 0x7;\n#else\n                c.ch.green = gsum / r;\n#endif\n                c.ch.blue = bsum / r;\n                if(has_alpha) opa = asum / r;\n\n                lv_img_buf_set_px_color(&canvas->dsc, x, y, c);\n            }\n            if(has_alpha) lv_img_buf_set_px_alpha(&canvas->dsc, x, y, opa);\n\n            y_safe = y - r_back;\n            y_safe = y_safe < 0 ? 0 : y_safe;\n            c = lv_img_buf_get_px_color(&line_img, 0, y_safe, color);\n            if(has_alpha) opa = lv_img_buf_get_px_alpha(&line_img, 0, y_safe);\n\n            rsum -= c.ch.red;\n#if LV_COLOR_DEPTH == 16 && LV_COLOR_16_SWAP\n            gsum -= (c.ch.green_h << 3) + c.ch.green_l;\n#else\n            gsum -= c.ch.green;\n#endif\n            bsum -= c.ch.blue;\n            if(has_alpha) asum -= opa;\n\n            y_safe = y + 1 + r_front;\n            y_safe = y_safe > canvas->dsc.header.h - 1 ? canvas->dsc.header.h - 1 : y_safe;\n\n            c = lv_img_buf_get_px_color(&canvas->dsc, x, y_safe, color);\n            if(has_alpha) opa = lv_img_buf_get_px_alpha(&canvas->dsc, x, y_safe);\n\n            lv_img_buf_set_px_color(&line_img, 0, y_safe, c);\n            if(has_alpha) lv_img_buf_set_px_alpha(&line_img, 0, y_safe, opa);\n\n            rsum += c.ch.red;\n#if LV_COLOR_DEPTH == 16 && LV_COLOR_16_SWAP\n            gsum += (c.ch.green_h << 3) + c.ch.green_l;\n#else\n            gsum += c.ch.green;\n#endif\n            bsum += c.ch.blue;\n            if(has_alpha) asum += opa;\n        }\n    }\n\n    lv_obj_invalidate(obj);\n\n    lv_mem_buf_release(col_buf);\n}"}, "lv_canvas_fill_bg": {"type": "Function", "def": "void lv_canvas_fill_bg(lv_obj_t * canvas, lv_color_t color, lv_opa_t opa)", "sline": 520, "body": "{\n    LV_ASSERT_OBJ(canvas, MY_CLASS);\n\n    lv_img_dsc_t * dsc = lv_canvas_get_img(canvas);\n\n    if(dsc->header.cf == LV_IMG_CF_INDEXED_1BIT) {\n        uint32_t row_byte_cnt = (dsc->header.w + 7) >> 3;\n        /*+8 skip the palette*/\n        lv_memset((uint8_t *)dsc->data + 8, color.full ? 0xff : 0x00, row_byte_cnt * dsc->header.h);\n    }\n    else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT) {\n        uint32_t row_byte_cnt = (dsc->header.w + 7) >> 3;\n        lv_memset((uint8_t *)dsc->data, opa > LV_OPA_50 ? 0xff : 0x00, row_byte_cnt * dsc->header.h);\n    }\n    else {\n        uint32_t x;\n        uint32_t y;\n        for(y = 0; y < dsc->header.h; y++) {\n            for(x = 0; x < dsc->header.w; x++) {\n                lv_img_buf_set_px_color(dsc, x, y, color);\n                lv_img_buf_set_px_alpha(dsc, x, y, opa);\n            }\n        }\n    }\n\n    lv_obj_invalidate(canvas);\n}"}, "lv_canvas_draw_rect": {"type": "Function", "def": "void lv_canvas_draw_rect(lv_obj_t * canvas, lv_coord_t x, lv_coord_t y, lv_coord_t w, lv_coord_t h,\n                         const lv_draw_rect_dsc_t * draw_dsc)", "sline": 549, "body": "{\n    LV_ASSERT_OBJ(canvas, MY_CLASS);\n\n    lv_img_dsc_t * dsc = lv_canvas_get_img(canvas);\n\n    if(dsc->header.cf >= LV_IMG_CF_INDEXED_1BIT && dsc->header.cf <= LV_IMG_CF_INDEXED_8BIT) {\n        LV_LOG_WARN(\"lv_canvas_draw_rect: can't draw to LV_IMG_CF_INDEXED canvas\");\n        return;\n    }\n\n    /*Create a dummy display to fool the lv_draw function.\n     *It will think it draws to real screen.*/\n    lv_area_t mask;\n    mask.x1 = 0;\n    mask.x2 = dsc->header.w - 1;\n    mask.y1 = 0;\n    mask.y2 = dsc->header.h - 1;\n\n    lv_area_t coords;\n    coords.x1 = x;\n    coords.y1 = y;\n    coords.x2 = x + w - 1;\n    coords.y2 = y + h - 1;\n\n    lv_disp_t disp;\n    /*Allocate the fake driver on the stack as the entire display doesn't outlive this function*/\n    lv_disp_drv_t driver;\n    lv_memset_00(&disp, sizeof(lv_disp_t));\n    disp.driver = &driver;\n\n    lv_disp_draw_buf_t draw_buf;\n    lv_disp_draw_buf_init(&draw_buf, (void *)dsc->data, NULL, dsc->header.w * dsc->header.h);\n    lv_area_copy(&draw_buf.area, &mask);\n\n    lv_disp_drv_init(disp.driver);\n\n    disp.driver->draw_buf = &draw_buf;\n    disp.driver->hor_res = dsc->header.w;\n    disp.driver->ver_res = dsc->header.h;\n\n    lv_disp_drv_use_generic_set_px_cb(disp.driver, dsc->header.cf);\n\n    /*Disable anti-aliasing if drawing with transparent color to chroma keyed canvas*/\n    lv_color_t ctransp = LV_COLOR_CHROMA_KEY;\n    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED &&\n       draw_dsc->bg_color.full == ctransp.full) {\n        disp.driver->antialiasing = 0;\n    }\n\n    lv_disp_t * refr_ori = _lv_refr_get_disp_refreshing();\n    _lv_refr_set_disp_refreshing(&disp);\n\n    lv_draw_rect(&coords, &mask, draw_dsc);\n\n    _lv_refr_set_disp_refreshing(refr_ori);\n\n    lv_obj_invalidate(canvas);\n}"}, "lv_canvas_draw_text": {"type": "Function", "def": "void lv_canvas_draw_text(lv_obj_t * canvas, lv_coord_t x, lv_coord_t y, lv_coord_t max_w,\n                         lv_draw_label_dsc_t * draw_dsc, const char * txt)", "sline": 610, "body": "{\n    LV_ASSERT_OBJ(canvas, MY_CLASS);\n\n    lv_img_dsc_t * dsc = lv_canvas_get_img(canvas);\n\n    if(dsc->header.cf >= LV_IMG_CF_INDEXED_1BIT && dsc->header.cf <= LV_IMG_CF_INDEXED_8BIT) {\n        LV_LOG_WARN(\"lv_canvas_draw_text: can't draw to LV_IMG_CF_INDEXED canvas\");\n        return;\n    }\n\n    /*Create a dummy display to fool the lv_draw function.\n     *It will think it draws to real screen.*/\n    lv_area_t mask;\n    mask.x1 = 0;\n    mask.x2 = dsc->header.w - 1;\n    mask.y1 = 0;\n    mask.y2 = dsc->header.h - 1;\n\n    lv_area_t coords;\n    coords.x1 = x;\n    coords.y1 = y;\n    coords.x2 = x + max_w - 1;\n    coords.y2 = dsc->header.h - 1;\n\n    lv_disp_t disp;\n    /*Allocate the fake driver on the stack as the entire display doesn't outlive this function*/\n    lv_disp_drv_t driver;\n    lv_memset_00(&disp, sizeof(lv_disp_t));\n    disp.driver = &driver;\n\n    lv_disp_draw_buf_t draw_buf;\n    lv_disp_draw_buf_init(&draw_buf, (void *)dsc->data, NULL, dsc->header.w * dsc->header.h);\n    lv_area_copy(&draw_buf.area, &mask);\n\n    lv_disp_drv_init(disp.driver);\n\n    disp.driver->draw_buf = &draw_buf;\n    disp.driver->hor_res = dsc->header.w;\n    disp.driver->ver_res = dsc->header.h;\n\n    lv_disp_drv_use_generic_set_px_cb(disp.driver, dsc->header.cf);\n\n    lv_disp_t * refr_ori = _lv_refr_get_disp_refreshing();\n    _lv_refr_set_disp_refreshing(&disp);\n\n    lv_draw_label(&coords, &mask, draw_dsc, txt, NULL);\n\n    _lv_refr_set_disp_refreshing(refr_ori);\n\n    lv_obj_invalidate(canvas);\n}"}, "lv_canvas_draw_img": {"type": "Function", "def": "void lv_canvas_draw_img(lv_obj_t * canvas, lv_coord_t x, lv_coord_t y, const void * src,\n                        const lv_draw_img_dsc_t * draw_dsc)", "sline": 664, "body": "{\n    LV_ASSERT_OBJ(canvas, MY_CLASS);\n\n    lv_img_dsc_t * dsc = lv_canvas_get_img(canvas);\n\n    if(dsc->header.cf >= LV_IMG_CF_INDEXED_1BIT && dsc->header.cf <= LV_IMG_CF_INDEXED_8BIT) {\n        LV_LOG_WARN(\"lv_canvas_draw_img: can't draw to LV_IMG_CF_INDEXED canvas\");\n        return;\n    }\n\n    /*Create a dummy display to fool the lv_draw function.\n     *It will think it draws to real screen.*/\n    lv_area_t mask;\n    mask.x1 = 0;\n    mask.x2 = dsc->header.w - 1;\n    mask.y1 = 0;\n    mask.y2 = dsc->header.h - 1;\n\n    lv_img_header_t header;\n    lv_res_t res = lv_img_decoder_get_info(src, &header);\n    if(res != LV_RES_OK) {\n        LV_LOG_WARN(\"lv_canvas_draw_img: Couldn't get the image data.\");\n        return;\n    }\n\n    lv_area_t coords;\n    coords.x1 = x;\n    coords.y1 = y;\n    coords.x2 = x + header.w - 1;\n    coords.y2 = y + header.h - 1;\n\n    lv_disp_t disp;\n    /*Allocate the fake driver on the stack as the entire display doesn't outlive this function*/\n    lv_disp_drv_t driver;\n    lv_memset_00(&disp, sizeof(lv_disp_t));\n    disp.driver = &driver;\n\n    lv_disp_draw_buf_t draw_buf;\n    lv_disp_draw_buf_init(&draw_buf, (void *)dsc->data, NULL, dsc->header.w * dsc->header.h);\n    lv_area_copy(&draw_buf.area, &mask);\n\n    lv_disp_drv_init(disp.driver);\n\n    disp.driver->draw_buf = &draw_buf;\n    disp.driver->hor_res = dsc->header.w;\n    disp.driver->ver_res = dsc->header.h;\n\n    lv_disp_drv_use_generic_set_px_cb(disp.driver, dsc->header.cf);\n\n    lv_disp_t * refr_ori = _lv_refr_get_disp_refreshing();\n    _lv_refr_set_disp_refreshing(&disp);\n\n    lv_draw_img(&coords, &mask, src, draw_dsc);\n\n    _lv_refr_set_disp_refreshing(refr_ori);\n\n    lv_obj_invalidate(canvas);\n}"}, "lv_canvas_draw_line": {"type": "Function", "def": "void lv_canvas_draw_line(lv_obj_t * canvas, const lv_point_t points[], uint32_t point_cnt,\n                         const lv_draw_line_dsc_t * draw_dsc)", "sline": 725, "body": "{\n    LV_ASSERT_OBJ(canvas, MY_CLASS);\n\n    lv_img_dsc_t * dsc = lv_canvas_get_img(canvas);\n\n    if(dsc->header.cf >= LV_IMG_CF_INDEXED_1BIT && dsc->header.cf <= LV_IMG_CF_INDEXED_8BIT) {\n        LV_LOG_WARN(\"lv_canvas_draw_line: can't draw to LV_IMG_CF_INDEXED canvas\");\n        return;\n    }\n    /*Create a dummy display to fool the lv_draw function.\n     *It will think it draws to real screen.*/\n    lv_area_t mask;\n    mask.x1 = 0;\n    mask.x2 = dsc->header.w - 1;\n    mask.y1 = 0;\n    mask.y2 = dsc->header.h - 1;\n\n    lv_disp_t disp;\n    /*Allocate the fake driver on the stack as the entire display doesn't outlive this function*/\n    lv_disp_drv_t driver;\n    lv_memset_00(&disp, sizeof(lv_disp_t));\n    disp.driver = &driver;\n\n    lv_disp_draw_buf_t draw_buf;\n    lv_disp_draw_buf_init(&draw_buf, (void *)dsc->data, NULL, dsc->header.w * dsc->header.h);\n    lv_area_copy(&draw_buf.area, &mask);\n\n    lv_disp_drv_init(disp.driver);\n\n    disp.driver->draw_buf = &draw_buf;\n    disp.driver->hor_res = dsc->header.w;\n    disp.driver->ver_res = dsc->header.h;\n\n    lv_disp_drv_use_generic_set_px_cb(disp.driver, dsc->header.cf);\n\n    /*Disable anti-aliasing if drawing with transparent color to chroma keyed canvas*/\n    lv_color_t ctransp = LV_COLOR_CHROMA_KEY;\n    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED &&\n       draw_dsc->color.full == ctransp.full) {\n        disp.driver->antialiasing = 0;\n    }\n\n    lv_disp_t * refr_ori = _lv_refr_get_disp_refreshing();\n    _lv_refr_set_disp_refreshing(&disp);\n\n    uint32_t i;\n    for(i = 0; i < point_cnt - 1; i++) {\n        lv_draw_line(&points[i], &points[i + 1], &mask, draw_dsc);\n    }\n\n    _lv_refr_set_disp_refreshing(refr_ori);\n\n    lv_obj_invalidate(canvas);\n}"}, "lv_canvas_draw_polygon": {"type": "Function", "def": "void lv_canvas_draw_polygon(lv_obj_t * canvas, const lv_point_t points[], uint32_t point_cnt,\n                            const lv_draw_rect_dsc_t * draw_dsc)", "sline": 782, "body": "{\n    LV_ASSERT_OBJ(canvas, MY_CLASS);\n\n    lv_img_dsc_t * dsc = lv_canvas_get_img(canvas);\n\n    if(dsc->header.cf >= LV_IMG_CF_INDEXED_1BIT && dsc->header.cf <= LV_IMG_CF_INDEXED_8BIT) {\n        LV_LOG_WARN(\"lv_canvas_draw_polygon: can't draw to LV_IMG_CF_INDEXED canvas\");\n        return;\n    }\n\n    /*Create a dummy display to fool the lv_draw function.\n     *It will think it draws to real screen.*/\n    lv_area_t mask;\n    mask.x1 = 0;\n    mask.x2 = dsc->header.w - 1;\n    mask.y1 = 0;\n    mask.y2 = dsc->header.h - 1;\n\n    lv_disp_t disp;\n    /*Allocate the fake driver on the stack as the entire display doesn't outlive this function*/\n    lv_disp_drv_t driver;\n    lv_memset_00(&disp, sizeof(lv_disp_t));\n    disp.driver = &driver;\n\n    lv_disp_draw_buf_t draw_buf;\n    lv_disp_draw_buf_init(&draw_buf, (void *)dsc->data, NULL, dsc->header.w * dsc->header.h);\n    lv_area_copy(&draw_buf.area, &mask);\n\n    lv_disp_drv_init(disp.driver);\n\n    disp.driver->draw_buf = &draw_buf;\n    disp.driver->hor_res = dsc->header.w;\n    disp.driver->ver_res = dsc->header.h;\n\n    lv_disp_drv_use_generic_set_px_cb(disp.driver, dsc->header.cf);\n\n    /*Disable anti-aliasing if drawing with transparent color to chroma keyed canvas*/\n    lv_color_t ctransp = LV_COLOR_CHROMA_KEY;\n    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED &&\n       draw_dsc->bg_color.full == ctransp.full) {\n        disp.driver->antialiasing = 0;\n    }\n\n    lv_disp_t * refr_ori = _lv_refr_get_disp_refreshing();\n    _lv_refr_set_disp_refreshing(&disp);\n\n    lv_draw_polygon(points, point_cnt, &mask, draw_dsc);\n\n    _lv_refr_set_disp_refreshing(refr_ori);\n\n    lv_obj_invalidate(canvas);\n}"}, "lv_canvas_draw_arc": {"type": "Function", "def": "void lv_canvas_draw_arc(lv_obj_t * canvas, lv_coord_t x, lv_coord_t y, lv_coord_t r, int32_t start_angle,\n                        int32_t end_angle, const lv_draw_arc_dsc_t * draw_dsc)", "sline": 837, "body": "{\n#if LV_DRAW_COMPLEX\n    LV_ASSERT_OBJ(canvas, MY_CLASS);\n\n    lv_img_dsc_t * dsc = lv_canvas_get_img(canvas);\n\n    if(dsc->header.cf >= LV_IMG_CF_INDEXED_1BIT && dsc->header.cf <= LV_IMG_CF_INDEXED_8BIT) {\n        LV_LOG_WARN(\"lv_canvas_draw_arc: can't draw to LV_IMG_CF_INDEXED canvas\");\n        return;\n    }\n\n    /*Create a dummy display to fool the lv_draw function.\n     *It will think it draws to real screen.*/\n    lv_area_t mask;\n    mask.x1 = 0;\n    mask.x2 = dsc->header.w - 1;\n    mask.y1 = 0;\n    mask.y2 = dsc->header.h - 1;\n\n    lv_disp_t disp;\n    /*Allocate the fake driver on the stack as the entire display doesn't outlive this function*/\n    lv_disp_drv_t driver;\n    lv_memset_00(&disp, sizeof(lv_disp_t));\n    disp.driver = &driver;\n\n    lv_disp_draw_buf_t draw_buf;\n    lv_disp_draw_buf_init(&draw_buf, (void *)dsc->data, NULL, dsc->header.w * dsc->header.h);\n    lv_area_copy(&draw_buf.area, &mask);\n\n    lv_disp_drv_init(disp.driver);\n\n    disp.driver->draw_buf = &draw_buf;\n    disp.driver->hor_res = dsc->header.w;\n    disp.driver->ver_res = dsc->header.h;\n\n    lv_disp_drv_use_generic_set_px_cb(disp.driver, dsc->header.cf);\n\n    /*Disable anti-aliasing if drawing with transparent color to chroma keyed canvas*/\n    lv_color_t ctransp = LV_COLOR_CHROMA_KEY;\n    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED &&\n       draw_dsc->color.full == ctransp.full) {\n        disp.driver->antialiasing = 0;\n    }\n\n    lv_disp_t * refr_ori = _lv_refr_get_disp_refreshing();\n    _lv_refr_set_disp_refreshing(&disp);\n\n    lv_draw_arc(x, y, r,  start_angle, end_angle, &mask, draw_dsc);\n\n    _lv_refr_set_disp_refreshing(refr_ori);\n\n    lv_obj_invalidate(canvas);\n#else\n    LV_UNUSED(canvas);\n    LV_UNUSED(x);\n    LV_UNUSED(y);\n    LV_UNUSED(r);\n    LV_UNUSED(start_angle);\n    LV_UNUSED(end_angle);\n    LV_UNUSED(draw_dsc);\n    LV_LOG_WARN(\"Can't draw arc with LV_DRAW_COMPLEX == 0\");\n#endif\n}"}, "carbit_updater/lvgl/src/widgets/lv_canvas.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_canvas.c"}}, "carbit_updater/lv_drivers/display/ILI9341.c": {"ILI9341": {"type": "Variable", "def": "#include ILI9341.h", "sline": 17, "include": ["carbit_updater/lv_drivers/display/ILI9341.h", null]}, "carbit_updater/lv_drivers/display/ILI9341.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/ILI9341.c"}}, "carbit_updater/lvgl/src/extra/libs/rlottie/lv_rlottie.c": {"lv_rlottie": {"type": "Variable", "def": "#include lv_rlottie.h", "sline": 10, "include": ["carbit_updater/lvgl/src/extra/libs/rlottie/lv_rlottie.h", null]}, "carbit_updater/lvgl/src/extra/libs/rlottie/lv_rlottie.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/rlottie/lv_rlottie.c"}}, "carbit_updater/lvgl/src/draw/lv_img_cache.c": {"lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 9}, "lv_img_cache": {"type": "Variable", "def": "#include lv_img_cache.h", "sline": 10, "include": ["carbit_updater/lvgl/src/draw/lv_img_cache.h", null]}, "lv_img_decoder": {"type": "Variable", "def": "#include lv_img_decoder.h", "sline": 11, "include": ["carbit_updater/lvgl/src/draw/lv_img_decoder.h", null]}, "lv_draw_img": {"type": "Variable", "def": "#include lv_draw_img.h", "sline": 12, "include": ["carbit_updater/lvgl/src/draw/lv_draw_img.h", null]}, "lv_hal_tick": {"type": "Variable", "def": "#include ../hal/lv_hal_tick.h", "sline": 13}, "lv_gc": {"type": "Variable", "def": "#include ../misc/lv_gc.h", "sline": 14}, "_lv_img_cache_open": {"type": "Function", "def": "_lv_img_cache_entry_t * _lv_img_cache_open(const void * src, lv_color_t color, int32_t frame_id)", "sline": 63, "body": "{\n    /*Is the image cached?*/\n    _lv_img_cache_entry_t * cached_src = NULL;\n\n#if LV_IMG_CACHE_DEF_SIZE\n    if(entry_cnt == 0) {\n        LV_LOG_WARN(\"lv_img_cache_open: the cache size is 0\");\n        return NULL;\n    }\n\n    _lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);\n\n    /*Decrement all lifes. Make the entries older*/\n    uint16_t i;\n    for(i = 0; i < entry_cnt; i++) {\n        if(cache[i].life > INT32_MIN + LV_IMG_CACHE_AGING) {\n            cache[i].life -= LV_IMG_CACHE_AGING;\n        }\n    }\n\n    for(i = 0; i < entry_cnt; i++) {\n        if(color.full == cache[i].dec_dsc.color.full &&\n           frame_id == cache[i].dec_dsc.frame_id &&\n           lv_img_cache_match(src, cache[i].dec_dsc.src)) {\n            /*If opened increment its life.\n             *Image difficult to open should live longer to keep avoid frequent their recaching.\n             *Therefore increase `life` with `time_to_open`*/\n            cached_src = &cache[i];\n            cached_src->life += cached_src->dec_dsc.time_to_open * LV_IMG_CACHE_LIFE_GAIN;\n            if(cached_src->life > LV_IMG_CACHE_LIFE_LIMIT) cached_src->life = LV_IMG_CACHE_LIFE_LIMIT;\n            LV_LOG_TRACE(\"image source found in the cache\");\n            break;\n        }\n    }\n\n    /*The image is not cached then cache it now*/\n    if(cached_src) return cached_src;\n\n    /*Find an entry to reuse. Select the entry with the least life*/\n    cached_src = &cache[0];\n    for(i = 1; i < entry_cnt; i++) {\n        if(cache[i].life < cached_src->life) {\n            cached_src = &cache[i];\n        }\n    }\n\n    /*Close the decoder to reuse if it was opened (has a valid source)*/\n    if(cached_src->dec_dsc.src) {\n        lv_img_decoder_close(&cached_src->dec_dsc);\n        LV_LOG_INFO(\"image draw: cache miss, close and reuse an entry\");\n    }\n    else {\n        LV_LOG_INFO(\"image draw: cache miss, cached to an empty entry\");\n    }\n#else\n    cached_src = &LV_GC_ROOT(_lv_img_cache_single);\n#endif\n    /*Open the image and measure the time to open*/\n    uint32_t t_start  = lv_tick_get();\n    lv_res_t open_res = lv_img_decoder_open(&cached_src->dec_dsc, src, color, frame_id);\n    if(open_res == LV_RES_INV) {\n        LV_LOG_WARN(\"Image draw cannot open the image resource\");\n        lv_memset_00(cached_src, sizeof(_lv_img_cache_entry_t));\n        cached_src->life = INT32_MIN; /*Make the empty entry very \"weak\" to force its us*/\n        return NULL;\n    }\n\n    cached_src->life = 0;\n\n    /*If `time_to_open` was not set in the open function set it here*/\n    if(cached_src->dec_dsc.time_to_open == 0) {\n        cached_src->dec_dsc.time_to_open = lv_tick_elaps(t_start);\n    }\n\n    if(cached_src->dec_dsc.time_to_open == 0) cached_src->dec_dsc.time_to_open = 1;\n\n    return cached_src;\n}"}, "lv_img_cache_set_size": {"type": "Function", "def": "void lv_img_cache_set_size(uint16_t new_entry_cnt)", "sline": 149, "body": "{\n#if LV_IMG_CACHE_DEF_SIZE == 0\n    LV_UNUSED(new_entry_cnt);\n    LV_LOG_WARN(\"Can't change cache size because it's disabled by LV_IMG_CACHE_DEF_SIZE = 0\");\n#else\n    if(LV_GC_ROOT(_lv_img_cache_array) != NULL) {\n        /*Clean the cache before free it*/\n        lv_img_cache_invalidate_src(NULL);\n        lv_mem_free(LV_GC_ROOT(_lv_img_cache_array));\n    }\n\n    /*Reallocate the cache*/\n    LV_GC_ROOT(_lv_img_cache_array) = lv_mem_alloc(sizeof(_lv_img_cache_entry_t) * new_entry_cnt);\n    LV_ASSERT_MALLOC(LV_GC_ROOT(_lv_img_cache_array));\n    if(LV_GC_ROOT(_lv_img_cache_array) == NULL) {\n        entry_cnt = 0;\n        return;\n    }\n    entry_cnt = new_entry_cnt;\n\n    /*Clean the cache*/\n    lv_memset_00(LV_GC_ROOT(_lv_img_cache_array), entry_cnt * sizeof(_lv_img_cache_entry_t));\n#endif\n}"}, "lv_img_cache_invalidate_src": {"type": "Function", "def": "void lv_img_cache_invalidate_src(const void * src)", "sline": 180, "body": "{\n    LV_UNUSED(src);\n#if LV_IMG_CACHE_DEF_SIZE\n    _lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);\n\n    uint16_t i;\n    for(i = 0; i < entry_cnt; i++) {\n        if(src == NULL || lv_img_cache_match(src, cache[i].dec_dsc.src)) {\n            if(cache[i].dec_dsc.src != NULL) {\n                lv_img_decoder_close(&cache[i].dec_dsc);\n            }\n\n            lv_memset_00(&cache[i], sizeof(_lv_img_cache_entry_t));\n        }\n    }\n#endif\n}"}, "carbit_updater/lvgl/src/draw/lv_img_cache.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_img_cache.c"}}, "carbit_updater/lvgl/src/core/lv_obj_style.c": {"lv_obj": {"type": "Variable", "def": "#include lv_obj.h", "sline": 9, "include": ["carbit_updater/lvgl/src/core/lv_obj.h", null]}, "lv_disp": {"type": "Variable", "def": "#include lv_disp.h", "sline": 10, "include": ["carbit_updater/lvgl/src/core/lv_disp.h", null]}, "lv_gc": {"type": "Variable", "def": "#include ../misc/lv_gc.h", "sline": 11}, "trans_t.obj": {"type": "Variable", "def": "lv_obj_t * obj", "sline": 23, "in_struct": "trans_t"}, "trans_t.prop": {"type": "Variable", "def": "lv_style_prop_t prop", "sline": 24, "in_struct": "trans_t"}, "trans_t.selector": {"type": "Variable", "def": "lv_style_selector_t selector", "sline": 25, "in_struct": "trans_t"}, "trans_t.start_value": {"type": "Variable", "def": "lv_style_value_t start_value", "sline": 26, "in_struct": "trans_t"}, "trans_t.end_value": {"type": "Variable", "def": "lv_style_value_t end_value", "sline": 27, "in_struct": "trans_t"}, "trans_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t * obj;\n    lv_style_prop_t prop;\n    lv_style_selector_t selector;\n    lv_style_value_t start_value;\n    lv_style_value_t end_value;\n} trans_t", "sline": 28}, "cache_t": {"type": "Variable", "def": "typedef enum {\n    CACHE_ZERO = 0,\n    CACHE_TRUE = 1,\n    CACHE_UNSET = 2,\n    CACHE_255 = 3,\n    CACHE_NEED_CHECK = 4,\n} cache_t", "sline": 36}, "get_local_style": {"type": "Function", "def": "static lv_style_t * get_local_style(lv_obj_t * obj,  lv_style_selector_t selector)", "sline": 476, "body": "{\n    uint32_t i;\n    for(i = 0; i < obj->style_cnt; i++) {\n        if(obj->styles[i].is_local &&\n           obj->styles[i].selector == selector) {\n            return obj->styles[i].style;\n        }\n    }\n\n    obj->style_cnt++;\n    obj->styles = lv_mem_realloc(obj->styles, obj->style_cnt * sizeof(_lv_obj_style_t));\n    LV_ASSERT_MALLOC(obj->styles);\n\n    for(i = obj->style_cnt - 1; i > 0 ; i--) {\n        /*Copy only normal styles (not local and transition).\n         *The new local style will be added as the last local style*/\n        if(obj->styles[i - 1].is_local || obj->styles[i - 1].is_trans) break;\n        obj->styles[i] = obj->styles[i - 1];\n    }\n\n    lv_memset_00(&obj->styles[i], sizeof(_lv_obj_style_t));\n    obj->styles[i].style = lv_mem_alloc(sizeof(lv_style_t));\n    lv_style_init(obj->styles[i].style);\n    obj->styles[i].is_local = 1;\n    obj->styles[i].selector = selector;\n    return obj->styles[i].style;\n}"}, "get_trans_style": {"type": "Function", "def": "static _lv_obj_style_t * get_trans_style(lv_obj_t * obj,  lv_style_selector_t selector)", "sline": 513, "body": "{\n    uint32_t i;\n    for(i = 0; i < obj->style_cnt; i++) {\n        if(obj->styles[i].is_trans && obj->styles[i].selector == selector) break;\n    }\n\n    /*Already have a transition style for it*/\n    if(i != obj->style_cnt) return &obj->styles[i];\n\n    obj->style_cnt++;\n    obj->styles = lv_mem_realloc(obj->styles, obj->style_cnt * sizeof(_lv_obj_style_t));\n\n    for(i = obj->style_cnt - 1; i > 0 ; i--) {\n        obj->styles[i] = obj->styles[i - 1];\n    }\n\n    lv_memset_00(&obj->styles[0], sizeof(_lv_obj_style_t));\n    obj->styles[0].style = lv_mem_alloc(sizeof(lv_style_t));\n    lv_style_init(obj->styles[0].style);\n    obj->styles[0].is_trans = 1;\n    obj->styles[0].selector = selector;\n    return &obj->styles[0];\n}"}, "get_prop_core": {"type": "Function", "def": "static bool get_prop_core(const lv_obj_t * obj, lv_part_t part, lv_style_prop_t prop, lv_style_value_t * v)", "sline": 539, "body": "{\n    uint8_t group = 1 << _lv_style_get_prop_group(prop);\n    int32_t weight = -1;\n    lv_state_t state = obj->state;\n    lv_state_t state_inv = ~state;\n    lv_style_value_t value_tmp;\n    bool skip_trans = obj->skip_trans;\n    uint32_t i;\n    bool found;\n    for(i = 0; i < obj->style_cnt; i++) {\n        _lv_obj_style_t * obj_style = &obj->styles[i];\n        if(obj_style->is_trans == false) break;\n        if(skip_trans) continue;\n\n        lv_part_t part_act = lv_obj_style_get_selector_part(obj->styles[i].selector);\n\n        if(part_act != part) continue;\n        if((obj_style->style->has_group & group) == 0) continue;\n        found = lv_style_get_prop(obj_style->style, prop, &value_tmp);\n        if(found) {\n            *v = value_tmp;\n            return true;\n        }\n    }\n\n    for(; i < obj->style_cnt; i++) {\n        _lv_obj_style_t * obj_style = &obj->styles[i];\n        lv_part_t part_act = lv_obj_style_get_selector_part(obj->styles[i].selector);\n        lv_state_t state_act = lv_obj_style_get_selector_state(obj->styles[i].selector);\n        if(part_act != part) continue;\n\n        if((obj_style->style->has_group & group) == 0) continue;\n\n        /*Be sure the style not specifies other state than the requested.\n         *E.g. For HOVER+PRESS object state, HOVER style only is OK, but HOVER+FOCUS style is not*/\n        if((state_act & state_inv)) continue;\n\n        /*Check only better candidates*/\n        if(state_act <= weight) continue;\n\n        found = lv_style_get_prop(obj_style->style, prop, &value_tmp);\n\n        if(found) {\n            if(state_act == state) {\n                *v = value_tmp;\n                return true;\n            }\n            if(weight < state_act) {\n                weight = state_act;\n                *v = value_tmp;\n            }\n        }\n    }\n\n    if(weight >= 0) {\n        *v = value_tmp;\n        return true;\n    }\n    else return false;\n}"}, "apply_color_filter": {"type": "Function", "def": "static lv_style_value_t apply_color_filter(const lv_obj_t * obj, uint32_t part, lv_style_value_t v)", "sline": 601, "body": "{\n    if(obj == NULL) return v;\n    const lv_color_filter_dsc_t * f = lv_obj_get_style_color_filter_dsc(obj, part);\n    if(f && f->filter_cb) {\n        lv_opa_t f_opa = lv_obj_get_style_color_filter_opa(obj, part);\n        if(f_opa != 0) v.color = f->filter_cb(f, v.color, f_opa);\n    }\n    return v;\n}"}, "report_style_change_core": {"type": "Function", "def": "static void report_style_change_core(void * style, lv_obj_t * obj)", "sline": 617, "body": "{\n    uint32_t i;\n    for(i = 0; i < obj->style_cnt; i++) {\n        if(style == NULL || obj->styles[i].style == style) {\n            lv_obj_refresh_style(obj, LV_PART_ANY, LV_STYLE_PROP_ANY);\n            break;\n        }\n    }\n\n    uint32_t child_cnt = lv_obj_get_child_cnt(obj);\n    for(i = 0; i < child_cnt; i++) {\n        report_style_change_core(style, obj->spec_attr->children[i]);\n    }\n}"}, "refresh_children_style": {"type": "Function", "def": "static void refresh_children_style(lv_obj_t * obj)", "sline": 638, "body": "{\n    uint32_t i;\n    uint32_t child_cnt = lv_obj_get_child_cnt(obj);\n    for(i = 0; i < child_cnt; i++) {\n        lv_obj_t * child = obj->spec_attr->children[i];\n        lv_obj_invalidate(child);\n        lv_event_send(child, LV_EVENT_STYLE_CHANGED, NULL);\n        lv_obj_invalidate(child);\n\n        refresh_children_style(child); /*Check children too*/\n    }\n}"}, "trans_del": {"type": "Function", "def": "static bool trans_del(lv_obj_t * obj, lv_part_t part, lv_style_prop_t prop, trans_t * tr_limit)", "sline": 661, "body": "{\n    trans_t * tr;\n    trans_t * tr_prev;\n    bool removed = false;\n    tr = _lv_ll_get_tail(&LV_GC_ROOT(_lv_obj_style_trans_ll));\n    while(tr != NULL) {\n        if(tr == tr_limit) break;\n\n        /*'tr' might be deleted, so get the next object while 'tr' is valid*/\n        tr_prev = _lv_ll_get_prev(&LV_GC_ROOT(_lv_obj_style_trans_ll), tr);\n\n        if(tr->obj == obj && (part == tr->selector || part == LV_PART_ANY) && (prop == tr->prop || prop == LV_STYLE_PROP_ANY)) {\n            /*Remove the transitioned property from trans. style\n             *to allow changing it by normal styles*/\n            uint32_t i;\n            for(i = 0; i < obj->style_cnt; i++) {\n                if(obj->styles[i].is_trans && (part == LV_PART_ANY || obj->styles[i].selector == part)) {\n                    lv_style_remove_prop(obj->styles[i].style, tr->prop);\n                    lv_anim_del(tr, NULL);\n                    _lv_ll_remove(&LV_GC_ROOT(_lv_obj_style_trans_ll), tr);\n                    lv_mem_free(tr);\n                    removed = true;\n                }\n            }\n\n        }\n        tr = tr_prev;\n    }\n    return removed;\n}"}, "trans_anim_cb": {"type": "Function", "def": "static void trans_anim_cb(void * _tr, int32_t v)", "sline": 693, "body": "{\n    trans_t * tr = _tr;\n    lv_obj_t * obj = tr->obj;\n\n    uint32_t i;\n    for(i = 0; i < obj->style_cnt; i++) {\n        if(obj->styles[i].is_trans == 0 || obj->styles[i].selector != tr->selector) continue;\n\n        lv_style_value_t value_final;\n        switch(tr->prop) {\n\n            case LV_STYLE_BORDER_SIDE:\n            case LV_STYLE_BORDER_POST:\n            case LV_STYLE_BLEND_MODE:\n                if(v < 255) value_final.num = tr->start_value.num;\n                else value_final.num = tr->end_value.num;\n                break;\n            case LV_STYLE_TRANSITION:\n            case LV_STYLE_TEXT_FONT:\n                if(v < 255) value_final.ptr = tr->start_value.ptr;\n                else value_final.ptr = tr->end_value.ptr;\n                break;\n            case LV_STYLE_COLOR_FILTER_DSC:\n                if(tr->start_value.ptr == NULL) value_final.ptr = tr->end_value.ptr;\n                else if(tr->end_value.ptr == NULL) value_final.ptr = tr->start_value.ptr;\n                else if(v < 128) value_final.ptr = tr->start_value.ptr;\n                else value_final.ptr = tr->end_value.ptr;\n                break;\n            case LV_STYLE_BG_COLOR:\n            case LV_STYLE_BORDER_COLOR:\n            case LV_STYLE_TEXT_COLOR:\n            case LV_STYLE_SHADOW_COLOR:\n            case LV_STYLE_OUTLINE_COLOR:\n            case LV_STYLE_IMG_RECOLOR:\n                if(v <= 0) value_final.color = tr->start_value.color;\n                else if(v >= 255) value_final.color = tr->end_value.color;\n                else value_final.color = lv_color_mix(tr->end_value.color, tr->start_value.color, v);\n                break;\n\n            default:\n                if(v == 0) value_final.num = tr->start_value.num;\n                else if(v == 255) value_final.num = tr->end_value.num;\n                else value_final.num = tr->start_value.num + ((int32_t)((int32_t)(tr->end_value.num - tr->start_value.num) * v) >> 8);\n                break;\n        }\n\n        lv_style_value_t old_value;\n        bool refr = true;\n        if(lv_style_get_prop(obj->styles[i].style, tr->prop, &old_value)) {\n            if(value_final.ptr == old_value.ptr && value_final.color.full == old_value.color.full &&\n               value_final.num == old_value.num) {\n                refr = false;\n            }\n        }\n        lv_style_set_prop(obj->styles[i].style, tr->prop, value_final);\n        if(refr) lv_obj_refresh_style(tr->obj, tr->selector, tr->prop);\n        break;\n\n    }\n\n}"}, "trans_anim_start_cb": {"type": "Function", "def": "static void trans_anim_start_cb(lv_anim_t * a)", "sline": 756, "body": "{\n    trans_t * tr = a->var;\n\n    lv_part_t part = lv_obj_style_get_selector_part(tr->selector);\n    tr->start_value = lv_obj_get_style_prop(tr->obj, part, tr->prop);\n\n    /*Init prop to an invalid values to be sure `trans_del` won't delete this added `tr`*/\n    lv_style_prop_t prop_tmp = tr->prop;\n    tr->prop = LV_STYLE_PROP_INV;\n\n    /*Delete the related transitions if any*/\n    trans_del(tr->obj, part, prop_tmp, tr);\n\n    tr->prop = prop_tmp;\n\n    _lv_obj_style_t * style_trans = get_trans_style(tr->obj, tr->selector);\n    lv_style_set_prop(style_trans->style, tr->prop, tr->start_value);   /*Be sure `trans_style` has a valid value*/\n\n}"}, "trans_anim_ready_cb": {"type": "Function", "def": "static void trans_anim_ready_cb(lv_anim_t * a)", "sline": 777, "body": "{\n    trans_t * tr = a->var;\n    lv_obj_t * obj = tr->obj;\n    lv_style_prop_t prop = tr->prop;\n\n    /*Remove the transitioned property from trans. style\n     *if there no more transitions for this property\n     *It allows changing it by normal styles*/\n    bool running = false;\n    trans_t * tr_i;\n    _LV_LL_READ(&LV_GC_ROOT(_lv_obj_style_trans_ll), tr_i) {\n        if(tr_i != tr && tr_i->obj == tr->obj && tr_i->selector == tr->selector && tr_i->prop == tr->prop) {\n            running = true;\n            break;\n        }\n    }\n\n    if(!running) {\n        uint32_t i;\n        for(i = 0; i < obj->style_cnt; i++) {\n            if(obj->styles[i].is_trans && obj->styles[i].selector == tr->selector) {\n                _lv_ll_remove(&LV_GC_ROOT(_lv_obj_style_trans_ll), tr);\n                lv_mem_free(tr);\n\n                _lv_obj_style_t * obj_style = &obj->styles[i];\n                lv_style_remove_prop(obj_style->style, prop);\n\n                if(lv_style_is_empty(obj->styles[i].style)) {\n                    lv_obj_remove_style(obj, obj_style->style, obj_style->selector);\n\n                }\n                break;\n            }\n        }\n    }\n}"}, "fade_anim_cb": {"type": "Function", "def": "static void fade_anim_cb(void * obj, int32_t v)", "sline": 815, "body": "{\n    lv_obj_set_style_opa(obj, v, 0);\n}"}, "fade_in_anim_ready": {"type": "Function", "def": "static void fade_in_anim_ready(lv_anim_t * a)", "sline": 820, "body": "{\n    lv_obj_remove_local_style_prop(a->var, LV_STYLE_OPA, 0);\n}"}, "style_refr": {"type": "Variable", "def": "static bool style_refr", "sline": 61}, "_lv_obj_style_init": {"type": "Function", "def": "void _lv_obj_style_init(void)", "sline": 71, "body": "{\n    _lv_ll_init(&LV_GC_ROOT(_lv_obj_style_trans_ll), sizeof(trans_t));\n}"}, "lv_obj_add_style": {"type": "Function", "def": "void lv_obj_add_style(lv_obj_t * obj, lv_style_t * style, lv_style_selector_t selector)", "sline": 76, "body": "{\n    trans_del(obj, selector, LV_STYLE_PROP_ANY, NULL);\n\n    uint32_t i;\n    /*Go after the transition and local styles*/\n    for(i = 0; i < obj->style_cnt; i++) {\n        if(obj->styles[i].is_trans) continue;\n        if(obj->styles[i].is_local) continue;\n        break;\n    }\n\n    /*Now `i` is at the first normal style. Insert the new style before this*/\n\n    /*Allocate space for the new style and shift the rest of the style to the end*/\n    obj->style_cnt++;\n    obj->styles = lv_mem_realloc(obj->styles, obj->style_cnt * sizeof(_lv_obj_style_t));\n\n    uint32_t j;\n    for(j = obj->style_cnt - 1; j > i ; j--) {\n        obj->styles[j] = obj->styles[j - 1];\n    }\n\n    lv_memset_00(&obj->styles[i], sizeof(_lv_obj_style_t));\n    obj->styles[i].style = style;\n    obj->styles[i].selector = selector;\n\n    lv_obj_refresh_style(obj, selector, LV_STYLE_PROP_ANY);\n}"}, "lv_obj_remove_style": {"type": "Function", "def": "void lv_obj_remove_style(lv_obj_t * obj, lv_style_t * style, lv_style_selector_t selector)", "sline": 106, "body": "{\n    lv_state_t state = lv_obj_style_get_selector_state(selector);\n    lv_part_t part = lv_obj_style_get_selector_part(selector);\n    lv_style_prop_t prop = LV_STYLE_PROP_ANY;\n    if(style && style->prop_cnt == 0) prop = LV_STYLE_PROP_INV;\n\n    uint32_t i = 0;\n    bool deleted = false;\n    while(i <  obj->style_cnt) {\n        lv_state_t state_act = lv_obj_style_get_selector_state(obj->styles[i].selector);\n        lv_part_t part_act = lv_obj_style_get_selector_part(obj->styles[i].selector);\n        if((state != LV_STATE_ANY && state_act != state) ||\n           (part != LV_PART_ANY && part_act != part) ||\n           (style != NULL && style != obj->styles[i].style)) {\n            i++;\n            continue;\n        }\n\n        if(obj->styles[i].is_trans) {\n            trans_del(obj, part, LV_STYLE_PROP_ANY, NULL);\n        }\n\n        if(obj->styles[i].is_local || obj->styles[i].is_trans) {\n            lv_style_reset(obj->styles[i].style);\n            lv_mem_free(obj->styles[i].style);\n            obj->styles[i].style = NULL;\n        }\n\n        /*Shift the styles after `i` by one*/\n        uint32_t j;\n        for(j = i; j < (uint32_t)obj->style_cnt - 1 ; j++) {\n            obj->styles[j] = obj->styles[j + 1];\n        }\n\n        obj->style_cnt--;\n        obj->styles = lv_mem_realloc(obj->styles, obj->style_cnt * sizeof(_lv_obj_style_t));\n\n        deleted = true;\n        /*The style from the current `i` index is removed, so `i` points to the next style.\n         *Therefore it doesn't needs to be incremented*/\n    }\n    if(deleted && prop != LV_STYLE_PROP_INV) {\n        lv_obj_refresh_style(obj, part, prop);\n    }\n}"}, "lv_obj_report_style_change": {"type": "Function", "def": "void lv_obj_report_style_change(lv_style_t * style)", "sline": 153, "body": "{\n    if(!style_refr) return;\n    lv_disp_t * d = lv_disp_get_next(NULL);\n\n    while(d) {\n        uint32_t i;\n        for(i = 0; i < d->screen_cnt; i++) {\n            report_style_change_core(style, d->screens[i]);\n        }\n        d = lv_disp_get_next(d);\n    }\n}"}, "lv_obj_refresh_style": {"type": "Function", "def": "void lv_obj_refresh_style(lv_obj_t * obj, lv_style_selector_t selector, lv_style_prop_t prop)", "sline": 167, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    if(!style_refr) return;\n\n    lv_obj_invalidate(obj);\n\n    lv_part_t part = lv_obj_style_get_selector_part(selector);\n\n    if(prop & LV_STYLE_PROP_LAYOUT_REFR) {\n        if(part == LV_PART_ANY ||\n           part == LV_PART_MAIN ||\n           lv_obj_get_style_height(obj, 0) == LV_SIZE_CONTENT ||\n           lv_obj_get_style_width(obj, 0) == LV_SIZE_CONTENT) {\n            lv_event_send(obj, LV_EVENT_STYLE_CHANGED, NULL);\n            lv_obj_mark_layout_as_dirty(obj);\n        }\n    }\n    if((part == LV_PART_ANY || part == LV_PART_MAIN) && (prop == LV_STYLE_PROP_ANY ||\n                                                         (prop & LV_STYLE_PROP_PARENT_LAYOUT_REFR))) {\n        lv_obj_t * parent = lv_obj_get_parent(obj);\n        if(parent) lv_obj_mark_layout_as_dirty(parent);\n    }\n\n    if(prop == LV_STYLE_PROP_ANY || (prop & LV_STYLE_PROP_EXT_DRAW)) {\n        lv_obj_refresh_ext_draw_size(obj);\n    }\n    lv_obj_invalidate(obj);\n\n    if(prop == LV_STYLE_PROP_ANY ||\n       ((prop & LV_STYLE_PROP_INHERIT) && ((prop & LV_STYLE_PROP_EXT_DRAW) || (prop & LV_STYLE_PROP_LAYOUT_REFR)))) {\n        if(part != LV_PART_SCROLLBAR) {\n            refresh_children_style(obj);\n        }\n    }\n}"}, "lv_obj_enable_style_refresh": {"type": "Function", "def": "void lv_obj_enable_style_refresh(bool en)", "sline": 205, "body": "{\n    style_refr = en;\n}"}, "lv_obj_get_style_prop": {"type": "Function", "def": "lv_style_value_t lv_obj_get_style_prop(const lv_obj_t * obj, lv_part_t part, lv_style_prop_t prop)", "sline": 210, "body": "{\n    lv_style_value_t value_act;\n    bool inherit = prop & LV_STYLE_PROP_INHERIT ? true : false;\n    bool filter = prop & LV_STYLE_PROP_FILTER ? true : false;\n    if(filter) {\n        prop &= ~LV_STYLE_PROP_FILTER;\n    }\n    bool found = false;\n    while(obj) {\n        found = get_prop_core(obj, part, prop, &value_act);\n        if(found) break;\n        if(!inherit) break;\n\n        /*If not found, check the `MAIN` style first*/\n        if(part != LV_PART_MAIN) {\n            part = LV_PART_MAIN;\n            continue;\n        }\n\n        /*Check the parent too.*/\n        obj = lv_obj_get_parent(obj);\n    }\n\n    if(!found) {\n        if(part == LV_PART_MAIN && (prop == LV_STYLE_WIDTH || prop == LV_STYLE_HEIGHT)) {\n            const lv_obj_class_t * cls = obj->class_p;\n            while(cls) {\n                if(prop == LV_STYLE_WIDTH) {\n                    if(cls->width_def != 0) break;\n                }\n                else {\n                    if(cls->height_def != 0) break;\n                }\n                cls = cls->base_class;\n            }\n\n            value_act.num = prop == LV_STYLE_WIDTH ? cls->width_def : cls->height_def;\n        }\n        else {\n            value_act = lv_style_prop_get_default(prop);\n        }\n    }\n    if(filter) value_act = apply_color_filter(obj, part, value_act);\n    return value_act;\n}"}, "lv_obj_set_local_style_prop": {"type": "Function", "def": "void lv_obj_set_local_style_prop(lv_obj_t * obj, lv_style_prop_t prop, lv_style_value_t value,\n                                 lv_style_selector_t selector)", "sline": 257, "body": "{\n    lv_style_t * style = get_local_style(obj, selector);\n    lv_style_set_prop(style, prop, value);\n    lv_obj_refresh_style(obj, selector, prop);\n}"}, "lv_obj_get_local_style_prop": {"type": "Function", "def": "lv_res_t lv_obj_get_local_style_prop(lv_obj_t * obj, lv_style_prop_t prop, lv_style_value_t * value,\n                                     lv_style_selector_t selector)", "sline": 266, "body": "{\n    uint32_t i;\n    for(i = 0; i < obj->style_cnt; i++) {\n        if(obj->styles[i].is_local &&\n           obj->styles[i].selector ==  selector) {\n            return lv_style_get_prop(obj->styles[i].style, prop, value);\n        }\n    }\n\n    return LV_RES_INV;\n}"}, "lv_obj_remove_local_style_prop": {"type": "Function", "def": "bool lv_obj_remove_local_style_prop(lv_obj_t * obj, lv_style_prop_t prop, lv_style_selector_t selector)", "sline": 280, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    uint32_t i;\n    /*Find the style*/\n    for(i = 0; i < obj->style_cnt; i++) {\n        if(obj->styles[i].is_local &&\n           obj->styles[i].selector == selector) {\n            break;\n        }\n    }\n\n    /*The style is not found*/\n    if(i == obj->style_cnt) return false;\n\n    return lv_style_remove_prop(obj->styles[i].style, prop);\n}"}, "_lv_obj_style_create_transition": {"type": "Function", "def": "void _lv_obj_style_create_transition(lv_obj_t * obj, lv_part_t part, lv_state_t prev_state, lv_state_t new_state,\n                                     const _lv_obj_style_transition_dsc_t * tr_dsc)", "sline": 299, "body": "{\n    trans_t * tr;\n\n    /*Get the previous and current values*/\n    obj->skip_trans = 1;\n    obj->state = prev_state;\n    lv_style_value_t v1 = lv_obj_get_style_prop(obj, part, tr_dsc->prop);\n    obj->state = new_state;\n    lv_style_value_t v2 = lv_obj_get_style_prop(obj, part, tr_dsc->prop);\n    obj->skip_trans = 0;\n\n    if(v1.ptr == v2.ptr && v1.num == v2.num && v1.color.full == v2.color.full)  return;\n    obj->state = prev_state;\n    v1 = lv_obj_get_style_prop(obj, part, tr_dsc->prop);\n    obj->state = new_state;\n\n    _lv_obj_style_t * style_trans = get_trans_style(obj, part);\n    lv_style_set_prop(style_trans->style, tr_dsc->prop, v1);   /*Be sure `trans_style` has a valid value*/\n\n    if(tr_dsc->prop == LV_STYLE_RADIUS) {\n        if(v1.num == LV_RADIUS_CIRCLE || v2.num == LV_RADIUS_CIRCLE) {\n            lv_coord_t whalf = lv_obj_get_width(obj) / 2;\n            lv_coord_t hhalf = lv_obj_get_width(obj) / 2;\n            if(v1.num == LV_RADIUS_CIRCLE) v1.num = LV_MIN(whalf + 1, hhalf + 1);\n            if(v2.num == LV_RADIUS_CIRCLE) v2.num = LV_MIN(whalf + 1, hhalf + 1);\n        }\n    }\n\n    tr = _lv_ll_ins_head(&LV_GC_ROOT(_lv_obj_style_trans_ll));\n    LV_ASSERT_MALLOC(tr);\n    if(tr == NULL) return;\n    tr->start_value = v1;\n    tr->end_value = v2;\n\n    if(tr) {\n        tr->obj = obj;\n        tr->prop = tr_dsc->prop;\n        tr->selector = part;\n\n        lv_anim_t a;\n        lv_anim_init(&a);\n        lv_anim_set_var(&a, tr);\n        lv_anim_set_exec_cb(&a, trans_anim_cb);\n        lv_anim_set_start_cb(&a, trans_anim_start_cb);\n        lv_anim_set_ready_cb(&a, trans_anim_ready_cb);\n        lv_anim_set_values(&a, 0x00, 0xFF);\n        lv_anim_set_time(&a, tr_dsc->time);\n        lv_anim_set_delay(&a, tr_dsc->delay);\n        lv_anim_set_path_cb(&a, tr_dsc->path_cb);\n        lv_anim_set_early_apply(&a, false);\n#if LV_USE_USER_DATA\n        a.user_data = tr_dsc->user_data;\n#endif\n        lv_anim_start(&a);\n    }\n}"}, "_lv_obj_style_state_compare": {"type": "Function", "def": "_lv_style_state_cmp_t _lv_obj_style_state_compare(lv_obj_t * obj, lv_state_t state1, lv_state_t state2)", "sline": 358, "body": "{\n    _lv_style_state_cmp_t res = _LV_STYLE_STATE_CMP_SAME;\n\n    /*Are there any new styles for the new state?*/\n    uint32_t i;\n    for(i = 0; i < obj->style_cnt; i++) {\n        if(obj->styles[i].is_trans) continue;\n\n        lv_state_t state_act = lv_obj_style_get_selector_state(obj->styles[i].selector);\n        /*The style is valid for a state but not the other*/\n        bool valid1 = state_act & (~state1) ? false : true;\n        bool valid2 = state_act & (~state2) ? false : true;\n        if(valid1 != valid2) {\n            lv_style_t * style = obj->styles[i].style;\n            lv_style_value_t v;\n            /*If there is layout difference on the main part, return immediately. There is no more serious difference*/\n            bool layout_diff = false;\n            if(lv_style_get_prop(style, LV_STYLE_PAD_TOP, &v))layout_diff = true;\n            else if(lv_style_get_prop(style, LV_STYLE_PAD_BOTTOM, &v)) layout_diff = true;\n            else if(lv_style_get_prop(style, LV_STYLE_PAD_LEFT, &v)) layout_diff = true;\n            else if(lv_style_get_prop(style, LV_STYLE_PAD_RIGHT, &v)) layout_diff = true;\n            else if(lv_style_get_prop(style, LV_STYLE_PAD_COLUMN, &v)) layout_diff = true;\n            else if(lv_style_get_prop(style, LV_STYLE_PAD_ROW, &v)) layout_diff = true;\n            else if(lv_style_get_prop(style, LV_STYLE_LAYOUT, &v)) layout_diff = true;\n            else if(lv_style_get_prop(style, LV_STYLE_TRANSLATE_X, &v)) layout_diff = true;\n            else if(lv_style_get_prop(style, LV_STYLE_TRANSLATE_Y, &v)) layout_diff = true;\n            else if(lv_style_get_prop(style, LV_STYLE_WIDTH, &v)) layout_diff = true;\n            else if(lv_style_get_prop(style, LV_STYLE_HEIGHT, &v)) layout_diff = true;\n            else if(lv_style_get_prop(style, LV_STYLE_MIN_WIDTH, &v)) layout_diff = true;\n            else if(lv_style_get_prop(style, LV_STYLE_MAX_WIDTH, &v)) layout_diff = true;\n            else if(lv_style_get_prop(style, LV_STYLE_MIN_HEIGHT, &v)) layout_diff = true;\n            else if(lv_style_get_prop(style, LV_STYLE_MAX_HEIGHT, &v)) layout_diff = true;\n            else if(lv_style_get_prop(style, LV_STYLE_BORDER_WIDTH, &v)) layout_diff = true;\n            else if(lv_style_get_prop(style, LV_STYLE_TRANSFORM_ANGLE, &v)) layout_diff = true;\n            else if(lv_style_get_prop(style, LV_STYLE_TRANSFORM_ZOOM, &v)) layout_diff = true;\n\n            if(layout_diff) {\n                return _LV_STYLE_STATE_CMP_DIFF_LAYOUT;\n            }\n\n            /*Check for draw pad changes*/\n            if(lv_style_get_prop(style, LV_STYLE_TRANSFORM_WIDTH, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;\n            else if(lv_style_get_prop(style, LV_STYLE_TRANSFORM_HEIGHT, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;\n            else if(lv_style_get_prop(style, LV_STYLE_TRANSFORM_ANGLE, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;\n            else if(lv_style_get_prop(style, LV_STYLE_TRANSFORM_ZOOM, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;\n            else if(lv_style_get_prop(style, LV_STYLE_OUTLINE_OPA, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;\n            else if(lv_style_get_prop(style, LV_STYLE_OUTLINE_PAD, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;\n            else if(lv_style_get_prop(style, LV_STYLE_OUTLINE_WIDTH, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;\n            else if(lv_style_get_prop(style, LV_STYLE_SHADOW_WIDTH, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;\n            else if(lv_style_get_prop(style, LV_STYLE_SHADOW_OPA, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;\n            else if(lv_style_get_prop(style, LV_STYLE_SHADOW_OFS_X, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;\n            else if(lv_style_get_prop(style, LV_STYLE_SHADOW_OFS_Y, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;\n            else if(lv_style_get_prop(style, LV_STYLE_SHADOW_SPREAD, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;\n            else if(lv_style_get_prop(style, LV_STYLE_LINE_WIDTH, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;\n            else if(res == _LV_STYLE_STATE_CMP_SAME) res = _LV_STYLE_STATE_CMP_DIFF_REDRAW;\n        }\n    }\n\n    return res;\n}"}, "lv_obj_fade_in": {"type": "Function", "def": "void lv_obj_fade_in(lv_obj_t * obj, uint32_t time, uint32_t delay)", "sline": 420, "body": "{\n    lv_anim_t a;\n    lv_anim_init(&a);\n    lv_anim_set_var(&a, obj);\n    lv_anim_set_values(&a, LV_OPA_TRANSP, LV_OPA_COVER);\n    lv_anim_set_exec_cb(&a, fade_anim_cb);\n    lv_anim_set_ready_cb(&a, fade_in_anim_ready);\n    lv_anim_set_time(&a, time);\n    lv_anim_set_delay(&a, delay);\n    lv_anim_start(&a);\n}"}, "lv_obj_fade_out": {"type": "Function", "def": "void lv_obj_fade_out(lv_obj_t * obj, uint32_t time, uint32_t delay)", "sline": 433, "body": "{\n    lv_anim_t a;\n    lv_anim_init(&a);\n    lv_anim_set_var(&a, obj);\n    lv_anim_set_values(&a, LV_OPA_COVER, LV_OPA_TRANSP);\n    lv_anim_set_exec_cb(&a, fade_anim_cb);\n    lv_anim_set_time(&a, time);\n    lv_anim_set_delay(&a, delay);\n    lv_anim_start(&a);\n}"}, "lv_obj_style_get_selector_state": {"type": "Function", "def": "lv_state_t lv_obj_style_get_selector_state(lv_style_selector_t selector)", "sline": 445, "body": "{\n    return selector & 0xFFFF;\n}"}, "lv_obj_style_get_selector_part": {"type": "Function", "def": "lv_part_t lv_obj_style_get_selector_part(lv_style_selector_t selector)", "sline": 450, "body": "{\n    return selector & 0xFF0000;\n}"}, "lv_obj_calculate_style_text_align": {"type": "Function", "def": "lv_text_align_t lv_obj_calculate_style_text_align(const struct _lv_obj_t * obj, lv_part_t part, const char * txt)", "sline": 456, "body": "{\n    lv_text_align_t align = lv_obj_get_style_text_align(obj, part);\n    lv_base_dir_t base_dir = lv_obj_get_style_base_dir(obj, part);\n    lv_bidi_calculate_align(&align, &base_dir, txt);\n    return align;\n}"}, "carbit_updater/lvgl/src/core/lv_obj_style.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style.c"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_34.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_montserrat_34.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_34.c"}}, "carbit_updater/lvgl/src/draw/lv_draw_triangle.c": {"lv_draw_triangle": {"type": "Function", "def": "void lv_draw_triangle(const lv_point_t points[], const lv_area_t * clip_area, const lv_draw_rect_dsc_t * draw_dsc)", "sline": 43, "body": "{\n#if LV_DRAW_COMPLEX\n    lv_draw_polygon(points, 3, clip_area, draw_dsc);\n#else\n    LV_UNUSED(points);\n    LV_UNUSED(clip_area);\n    LV_UNUSED(draw_dsc);\n    LV_LOG_WARN(\"Can't draw triangle with LV_DRAW_COMPLEX == 0\");\n#endif /*LV_DRAW_COMPLEX*/\n}"}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 10}, "lv_mem": {"type": "Variable", "def": "#include ../misc/lv_mem.h", "sline": 11}, "lv_draw_polygon": {"type": "Function", "def": "void lv_draw_polygon(const lv_point_t points[], uint16_t point_cnt, const lv_area_t * clip_area,\n                     const lv_draw_rect_dsc_t * draw_dsc)", "sline": 62, "body": "{\n#if LV_DRAW_COMPLEX\n    if(point_cnt < 3) return;\n    if(points == NULL) return;\n\n    /*Join adjacent points if they are on the same coordinate*/\n    lv_point_t * p = lv_mem_buf_get(point_cnt * sizeof(lv_point_t));\n    if(p == NULL) return;\n    uint16_t i;\n    uint16_t pcnt = 0;\n    p[0] = points[0];\n    for(i = 0; i < point_cnt - 1; i++) {\n        if(points[i].x != points[i + 1].x || points[i].y != points[i + 1].y) {\n            p[pcnt] = points[i];\n            pcnt++;\n        }\n    }\n    /*The first and the last points are also adjacent*/\n    if(points[0].x != points[point_cnt - 1].x || points[0].y != points[point_cnt - 1].y) {\n        p[pcnt] = points[point_cnt - 1];\n        pcnt++;\n    }\n\n    point_cnt = pcnt;\n    if(point_cnt < 3) {\n        lv_mem_buf_release(p);\n        return;\n    }\n\n    lv_area_t poly_coords = {.x1 = LV_COORD_MAX, .y1 = LV_COORD_MAX, .x2 = LV_COORD_MIN, .y2 = LV_COORD_MIN};\n\n    for(i = 0; i < point_cnt; i++) {\n        poly_coords.x1 = LV_MIN(poly_coords.x1, p[i].x);\n        poly_coords.y1 = LV_MIN(poly_coords.y1, p[i].y);\n        poly_coords.x2 = LV_MAX(poly_coords.x2, p[i].x);\n        poly_coords.y2 = LV_MAX(poly_coords.y2, p[i].y);\n    }\n\n    bool is_common;\n    lv_area_t poly_mask;\n    is_common = _lv_area_intersect(&poly_mask, &poly_coords, clip_area);\n    if(!is_common) {\n        lv_mem_buf_release(p);\n        return;\n    }\n    /*Find the lowest point*/\n    lv_coord_t y_min = p[0].y;\n    int16_t y_min_i = 0;\n\n    for(i = 1; i < point_cnt; i++) {\n        if(p[i].y < y_min) {\n            y_min = p[i].y;\n            y_min_i = i;\n        }\n    }\n\n    lv_draw_mask_line_param_t * mp = lv_mem_buf_get(sizeof(lv_draw_mask_line_param_t) * point_cnt);\n    lv_draw_mask_line_param_t * mp_next = mp;\n\n    int32_t i_prev_left = y_min_i;\n    int32_t i_prev_right = y_min_i;\n    int32_t i_next_left;\n    int32_t i_next_right;\n    uint32_t mask_cnt = 0;\n\n    /*Get the index of the left and right points*/\n    i_next_left = y_min_i - 1;\n    if(i_next_left < 0) i_next_left = point_cnt + i_next_left;\n\n    i_next_right = y_min_i + 1;\n    if(i_next_right > point_cnt - 1) i_next_right = 0;\n\n    /**\n     * Check if the order of points is inverted or not.\n     * The normal case is when the left point is on `y_min_i - 1`\n     * Explanation:\n     *   if angle(p_left) < angle(p_right) -> inverted\n     *   dy_left/dx_left < dy_right/dx_right\n     *   dy_left * dx_right < dy_right * dx_left\n     */\n    lv_coord_t dxl = p[i_next_left].x - p[y_min_i].x;\n    lv_coord_t dxr = p[i_next_right].x - p[y_min_i].x;\n    lv_coord_t dyl = p[i_next_left].y - p[y_min_i].y;\n    lv_coord_t dyr = p[i_next_right].y - p[y_min_i].y;\n\n    bool inv = false;\n    if(dyl * dxr < dyr * dxl) inv = true;\n\n    do {\n        if(!inv) {\n            i_next_left = i_prev_left - 1;\n            if(i_next_left < 0) i_next_left = point_cnt + i_next_left;\n\n            i_next_right = i_prev_right + 1;\n            if(i_next_right > point_cnt - 1) i_next_right = 0;\n        }\n        else {\n            i_next_left = i_prev_left + 1;\n            if(i_next_left > point_cnt - 1) i_next_left = 0;\n\n            i_next_right = i_prev_right - 1;\n            if(i_next_right < 0) i_next_right = point_cnt + i_next_right;\n        }\n\n        if(p[i_next_left].y >=  p[i_prev_left].y) {\n            if(p[i_next_left].y != p[i_prev_left].y &&\n               p[i_next_left].x !=  p[i_prev_left].x) {\n                lv_draw_mask_line_points_init(mp_next, p[i_prev_left].x, p[i_prev_left].y,\n                                              p[i_next_left].x, p[i_next_left].y,\n                                              LV_DRAW_MASK_LINE_SIDE_RIGHT);\n                lv_draw_mask_add(mp_next, mp);\n                mp_next++;\n            }\n            mask_cnt++;\n            i_prev_left = i_next_left;\n        }\n\n        if(mask_cnt == point_cnt) break;\n\n        if(p[i_next_right].y >=  p[i_prev_right].y) {\n            if(p[i_next_right].y != p[i_prev_right].y &&\n               p[i_next_right].x !=  p[i_prev_right].x) {\n\n                lv_draw_mask_line_points_init(mp_next, p[i_prev_right].x, p[i_prev_right].y,\n                                              p[i_next_right].x, p[i_next_right].y,\n                                              LV_DRAW_MASK_LINE_SIDE_LEFT);\n                lv_draw_mask_add(mp_next, mp);\n                mp_next++;\n            }\n            mask_cnt++;\n            i_prev_right = i_next_right;\n        }\n\n    } while(mask_cnt < point_cnt);\n\n    lv_draw_rect(&poly_coords, clip_area, draw_dsc);\n\n    lv_draw_mask_remove_custom(mp);\n\n    lv_mem_buf_release(mp);\n    lv_mem_buf_release(p);\n#else\n    LV_UNUSED(points);\n    LV_UNUSED(point_cnt);\n    LV_UNUSED(clip_area);\n    LV_UNUSED(draw_dsc);\n    LV_LOG_WARN(\"Can't draw polygon with LV_DRAW_COMPLEX == 0\");\n#endif /*LV_DRAW_COMPLEX*/\n}"}, "carbit_updater/lvgl/src/draw/lv_draw_triangle.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_draw_triangle.c"}}, "carbit_updater/lvgl/src/extra/libs/qrcode/lv_qrcode.c": {"lv_qrcode": {"type": "Variable", "def": "#include lv_qrcode.h", "sline": 9, "include": ["carbit_updater/lvgl/src/extra/libs/qrcode/lv_qrcode.h", null]}, "carbit_updater/lvgl/src/extra/libs/qrcode/lv_qrcode.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/qrcode/lv_qrcode.c"}}, "carbit_updater/lvgl/src/font/lv_symbol_def.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 8}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_symbol_def.h:96:1)": {"type": "Enum", "def": "enum {\n    _LV_STR_SYMBOL_AUDIO,\n    _LV_STR_SYMBOL_VIDEO,\n    _LV_STR_SYMBOL_LIST,\n    _LV_STR_SYMBOL_OK,\n    _LV_STR_SYMBOL_CLOSE,\n    _LV_STR_SYMBOL_POWER,\n    _LV_STR_SYMBOL_SETTINGS,\n    _LV_STR_SYMBOL_HOME,\n    _LV_STR_SYMBOL_DOWNLOAD,\n    _LV_STR_SYMBOL_DRIVE,\n    _LV_STR_SYMBOL_REFRESH,\n    _LV_STR_SYMBOL_MUTE,\n    _LV_STR_SYMBOL_VOLUME_MID,\n    _LV_STR_SYMBOL_VOLUME_MAX,\n    _LV_STR_SYMBOL_IMAGE,\n    _LV_STR_SYMBOL_EDIT,\n    _LV_STR_SYMBOL_PREV,\n    _LV_STR_SYMBOL_PLAY,\n    _LV_STR_SYMBOL_PAUSE,\n    _LV_STR_SYMBOL_STOP,\n    _LV_STR_SYMBOL_NEXT,\n    _LV_STR_SYMBOL_EJECT,\n    _LV_STR_SYMBOL_LEFT,\n    _LV_STR_SYMBOL_RIGHT,\n    _LV_STR_SYMBOL_PLUS,\n    _LV_STR_SYMBOL_MINUS,\n    _LV_STR_SYMBOL_EYE_OPEN,\n    _LV_STR_SYMBOL_EYE_CLOSE,\n    _LV_STR_SYMBOL_WARNING,\n    _LV_STR_SYMBOL_SHUFFLE,\n    _LV_STR_SYMBOL_UP,\n    _LV_STR_SYMBOL_DOWN,\n    _LV_STR_SYMBOL_LOOP,\n    _LV_STR_SYMBOL_DIRECTORY,\n    _LV_STR_SYMBOL_UPLOAD,\n    _LV_STR_SYMBOL_CALL,\n    _LV_STR_SYMBOL_CUT,\n    _LV_STR_SYMBOL_COPY,\n    _LV_STR_SYMBOL_SAVE,\n    _LV_STR_SYMBOL_CHARGE,\n    _LV_STR_SYMBOL_PASTE,\n    _LV_STR_SYMBOL_BELL,\n    _LV_STR_SYMBOL_KEYBOARD,\n    _LV_STR_SYMBOL_GPS,\n    _LV_STR_SYMBOL_FILE,\n    _LV_STR_SYMBOL_WIFI,\n    _LV_STR_SYMBOL_BATTERY_FULL,\n    _LV_STR_SYMBOL_BATTERY_3,\n    _LV_STR_SYMBOL_BATTERY_2,\n    _LV_STR_SYMBOL_BATTERY_1,\n    _LV_STR_SYMBOL_BATTERY_EMPTY,\n    _LV_STR_SYMBOL_USB,\n    _LV_STR_SYMBOL_BLUETOOTH,\n    _LV_STR_SYMBOL_TRASH,\n    _LV_STR_SYMBOL_BACKSPACE,\n    _LV_STR_SYMBOL_SD_CARD,\n    _LV_STR_SYMBOL_NEW_LINE,\n    _LV_STR_SYMBOL_DUMMY,\n    _LV_STR_SYMBOL_BULLET,\n}", "sline": 96}, "carbit_updater/lvgl/src/font/lv_symbol_def.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_symbol_def.h"}}, "carbit_updater/lv_drivers/sdl/sdl_gpu.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 20}, "carbit_updater/lv_drivers/sdl/sdl_gpu.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/sdl/sdl_gpu.h"}}, "carbit_updater/lvgl/src/misc/lv_style.c": {"lv_style": {"type": "Variable", "def": "#include lv_style.h", "sline": 9, "include": ["carbit_updater/lvgl/src/misc/lv_style.h", null]}, "lv_mem": {"type": "Variable", "def": "#include ../misc/lv_mem.h", "sline": 10}, "lv_style_init": {"type": "Function", "def": "void lv_style_init(lv_style_t * style)", "sline": 40, "body": "{\n#if LV_USE_ASSERT_STYLE\n    if(style->sentinel == LV_STYLE_SENTINEL_VALUE && style->prop_cnt > 1) {\n        LV_LOG_WARN(\"Style might be already inited. (Potential memory leak)\");\n    }\n#endif\n\n    lv_memset_00(style, sizeof(lv_style_t));\n#if LV_USE_ASSERT_STYLE\n    style->sentinel = LV_STYLE_SENTINEL_VALUE;\n#endif\n}"}, "lv_style_reset": {"type": "Function", "def": "void lv_style_reset(lv_style_t * style)", "sline": 54, "body": "{\n    LV_ASSERT_STYLE(style);\n\n    if(style->is_const) {\n        LV_LOG_ERROR(\"Cannot reset const style\");\n        return;\n    }\n\n    if(style->prop_cnt > 1) lv_mem_free(style->v_p.values_and_props);\n    lv_memset_00(style, sizeof(lv_style_t));\n#if LV_USE_ASSERT_STYLE\n    style->sentinel = LV_STYLE_SENTINEL_VALUE;\n#endif\n\n}"}, "lv_style_register_prop": {"type": "Function", "def": "lv_style_prop_t lv_style_register_prop(void)", "sline": 71, "body": "{\n    static uint16_t act_id = (uint16_t)_LV_STYLE_LAST_BUILT_IN_PROP;\n    act_id++;\n    return act_id;\n}"}, "lv_style_remove_prop": {"type": "Function", "def": "bool lv_style_remove_prop(lv_style_t * style, lv_style_prop_t prop)", "sline": 78, "body": "{\n    LV_ASSERT_STYLE(style);\n\n    if(style->is_const) {\n        LV_LOG_ERROR(\"Cannot remove prop from const style\");\n        return false;\n    }\n\n    if(style->prop_cnt == 0)  return false;\n\n    if(style->prop_cnt == 1) {\n        if(style->prop1 == prop) {\n            style->prop1 = LV_STYLE_PROP_INV;\n            style->prop_cnt = 0;\n            return true;\n        }\n        return false;\n    }\n\n    uint8_t * tmp = style->v_p.values_and_props + style->prop_cnt * sizeof(lv_style_value_t);\n    uint16_t * old_props = (uint16_t *)tmp;\n    uint32_t i;\n    for(i = 0; i < style->prop_cnt; i++) {\n        if(old_props[i] == prop) {\n            lv_style_value_t * old_values = (lv_style_value_t *)style->v_p.values_and_props;\n\n            if(style->prop_cnt == 2) {\n                style->prop_cnt = 1;\n                style->prop1 = i == 0 ? old_props[1] : old_props[0];\n                style->v_p.value1 = i == 0 ? old_values[1] : old_values[0];\n            }\n            else {\n                size_t size = (style->prop_cnt - 1) * (sizeof(lv_style_value_t) + sizeof(uint16_t));\n                uint8_t * new_values_and_props = lv_mem_alloc(size);\n                if(new_values_and_props == NULL) return false;\n                style->v_p.values_and_props = new_values_and_props;\n                style->prop_cnt--;\n\n                tmp = new_values_and_props + style->prop_cnt * sizeof(lv_style_value_t);\n                uint16_t * new_props = (uint16_t *)tmp;\n                lv_style_value_t * new_values = (lv_style_value_t *)new_values_and_props;\n\n                uint32_t j;\n                for(i = j = 0; j <= style->prop_cnt;\n                    j++) { /*<=: because prop_cnt already reduced but all the old props. needs to be checked.*/\n                    if(old_props[j] != prop) {\n                        new_values[i] = old_values[j];\n                        new_props[i++] = old_props[j];\n                    }\n                }\n            }\n\n            lv_mem_free(old_values);\n            return true;\n        }\n    }\n\n    return false;\n}"}, "lv_style_set_prop": {"type": "Function", "def": "void lv_style_set_prop(lv_style_t * style, lv_style_prop_t prop, lv_style_value_t value)", "sline": 139, "body": "{\n    LV_ASSERT_STYLE(style);\n\n    if(style->is_const) {\n        LV_LOG_ERROR(\"Cannot set property of constant style\");\n        return;\n    }\n\n    if(style->prop_cnt > 1) {\n        uint8_t * tmp = style->v_p.values_and_props + style->prop_cnt * sizeof(lv_style_value_t);\n        uint16_t * props = (uint16_t *)tmp;\n        int32_t i;\n        for(i = style->prop_cnt - 1; i >= 0; i--) {\n            if(props[i] == prop) {\n                lv_style_value_t * values = (lv_style_value_t *)style->v_p.values_and_props;\n                values[i] = value;\n                return;\n            }\n        }\n\n        size_t size = (style->prop_cnt + 1) * (sizeof(lv_style_value_t) + sizeof(uint16_t));\n        uint8_t * values_and_props = lv_mem_realloc(style->v_p.values_and_props, size);\n        if(values_and_props == NULL) return;\n        style->v_p.values_and_props = values_and_props;\n\n        tmp = values_and_props + style->prop_cnt * sizeof(lv_style_value_t);\n        props = (uint16_t *)tmp;\n        /*Shift all props to make place for the value before them*/\n        for(i = style->prop_cnt - 1; i >= 0; i--) {\n            props[i + sizeof(lv_style_value_t) / sizeof(uint16_t)] = props[i];\n        }\n        style->prop_cnt++;\n\n        /*Go to the new position wit the props*/\n        tmp = values_and_props + style->prop_cnt * sizeof(lv_style_value_t);\n        props = (uint16_t *)tmp;\n        lv_style_value_t * values = (lv_style_value_t *)values_and_props;\n\n        /*Set the new property and value*/\n        props[style->prop_cnt - 1] = prop;\n        values[style->prop_cnt - 1] = value;\n    }\n    else if(style->prop_cnt == 1) {\n        if(style->prop1 == prop) {\n            style->v_p.value1 = value;\n            return;\n        }\n        size_t size = (style->prop_cnt + 1) * (sizeof(lv_style_value_t) + sizeof(uint16_t));\n        uint8_t * values_and_props = lv_mem_alloc(size);\n        if(values_and_props == NULL) return;\n        lv_style_value_t value_tmp = style->v_p.value1;\n        style->v_p.values_and_props = values_and_props;\n        style->prop_cnt++;\n\n        uint8_t * tmp = values_and_props + style->prop_cnt * sizeof(lv_style_value_t);\n        uint16_t * props = (uint16_t *)tmp;\n        lv_style_value_t * values = (lv_style_value_t *)values_and_props;\n        props[0] = style->prop1;\n        props[1] = prop;\n        values[0] = value_tmp;\n        values[1] = value;\n    }\n    else {\n        style->prop_cnt = 1;\n        style->prop1 = prop;\n        style->v_p.value1 = value;\n    }\n\n    uint8_t group = _lv_style_get_prop_group(prop);\n    style->has_group |= 1 << group;\n}"}, "lv_style_get_prop": {"type": "Function", "def": "lv_res_t lv_style_get_prop(lv_style_t * style, lv_style_prop_t prop, lv_style_value_t * value)", "sline": 212, "body": "{\n    return lv_style_get_prop_inlined(style, prop, value);\n}"}, "lv_style_transition_dsc_init": {"type": "Function", "def": "void lv_style_transition_dsc_init(lv_style_transition_dsc_t * tr, const lv_style_prop_t props[],\n                                  lv_anim_path_cb_t path_cb, uint32_t time, uint32_t delay, void * user_data)", "sline": 217, "body": "{\n    lv_memset_00(tr, sizeof(lv_style_transition_dsc_t));\n    tr->props = props;\n    tr->path_xcb = path_cb == NULL ? lv_anim_path_linear : path_cb;\n    tr->time = time;\n    tr->delay = delay;\n#if LV_USE_USER_DATA\n    tr->user_data = user_data;\n#else\n    LV_UNUSED(user_data);\n#endif\n}"}, "lv_style_prop_get_default": {"type": "Function", "def": "lv_style_value_t lv_style_prop_get_default(lv_style_prop_t prop)", "sline": 232, "body": "{\n    lv_style_value_t value;\n    switch(prop) {\n        case LV_STYLE_TRANSFORM_ZOOM:\n            value.num = LV_IMG_ZOOM_NONE;\n            break;\n        case LV_STYLE_BG_COLOR:\n            value.color = lv_color_white();\n            break;\n        case LV_STYLE_BG_GRAD_COLOR:\n        case LV_STYLE_BORDER_COLOR:\n        case LV_STYLE_SHADOW_COLOR:\n        case LV_STYLE_OUTLINE_COLOR:\n        case LV_STYLE_ARC_COLOR:\n        case LV_STYLE_LINE_COLOR:\n        case LV_STYLE_TEXT_COLOR:\n        case LV_STYLE_IMG_RECOLOR:\n            value.color = lv_color_black();\n            break;\n        case LV_STYLE_OPA:\n        case LV_STYLE_BORDER_OPA:\n        case LV_STYLE_TEXT_OPA:\n        case LV_STYLE_IMG_OPA:\n        case LV_STYLE_BG_IMG_OPA:\n        case LV_STYLE_OUTLINE_OPA:\n        case LV_STYLE_SHADOW_OPA:\n        case LV_STYLE_LINE_OPA:\n        case LV_STYLE_ARC_OPA:\n            value.num = LV_OPA_COVER;\n            break;\n        case LV_STYLE_BG_GRAD_STOP:\n            value.num = 255;\n            break;\n        case LV_STYLE_BORDER_SIDE:\n            value.num = LV_BORDER_SIDE_FULL;\n            break;\n        case LV_STYLE_TEXT_FONT:\n            value.ptr = LV_FONT_DEFAULT;\n            break;\n        case LV_STYLE_MAX_WIDTH:\n        case LV_STYLE_MAX_HEIGHT:\n            value.num = LV_COORD_MAX;\n            break;\n        default:\n            value.ptr = NULL;\n            value.num = 0;\n            break;\n    }\n\n    return value;\n}"}, "lv_style_is_empty": {"type": "Function", "def": "bool lv_style_is_empty(const lv_style_t * style)", "sline": 285, "body": "{\n    LV_ASSERT_STYLE(style);\n\n    return style->prop_cnt == 0 ? true : false;\n}"}, "_lv_style_get_prop_group": {"type": "Function", "def": "uint8_t _lv_style_get_prop_group(lv_style_prop_t prop)", "sline": 292, "body": "{\n    uint16_t group = (prop & 0x1FF) >> 4;\n    if(group > 7) group = 7;    /*The MSB marks all the custom properties*/\n    return (uint8_t)group;\n}"}, "carbit_updater/lvgl/src/misc/lv_style.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_style.c"}}, "carbit_updater/lvgl/src/lv_conf_internal.h": {"stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 53}, "lv_conf_kconfig": {"type": "Variable", "def": "#include lv_conf_kconfig.h", "sline": 15, "include": ["carbit_updater/lvgl/src/lv_conf_kconfig.h", null]}, "lv_conf": {"type": "Variable", "def": "#include ../../lv_conf.h", "sline": 41}, "_silence_gcc_warning": {"type": "Struct", "def": "LV_EXPORT_CONST_INT(LV_DPI_DEF)", "sline": 1922}, "carbit_updater/lvgl/src/lv_conf_internal.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/lv_conf_internal.h"}}, "carbit_updater/lv_drivers/lv_drv_conf_template.h": {"carbit_updater/lv_drivers/lv_drv_conf_template.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/lv_drv_conf_template.h"}}, "carbit_updater/lvgl/src/widgets/lv_btnmatrix.c": {"lv_btnmatrix": {"type": "Variable", "def": "#include lv_btnmatrix.h", "sline": 9, "include": ["carbit_updater/lvgl/src/widgets/lv_btnmatrix.h", null]}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 12}, "lv_indev": {"type": "Variable", "def": "#include ../core/lv_indev.h", "sline": 13}, "lv_group": {"type": "Variable", "def": "#include ../core/lv_group.h", "sline": 14}, "lv_draw": {"type": "Variable", "def": "#include ../draw/lv_draw.h", "sline": 15}, "lv_refr": {"type": "Variable", "def": "#include ../core/lv_refr.h", "sline": 16}, "lv_txt": {"type": "Variable", "def": "#include ../misc/lv_txt.h", "sline": 17}, "lv_txt_ap": {"type": "Variable", "def": "#include ../misc/lv_txt_ap.h", "sline": 18}, "lv_btnmatrix_constructor": {"type": "Function", "def": "static void lv_btnmatrix_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 356, "body": "{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n    lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;\n    btnm->btn_cnt        = 0;\n    btnm->row_cnt        = 0;\n    btnm->btn_id_sel     = LV_BTNMATRIX_BTN_NONE;\n    btnm->button_areas   = NULL;\n    btnm->ctrl_bits      = NULL;\n    btnm->map_p          = NULL;\n    btnm->one_check      = 0;\n\n    lv_btnmatrix_set_map(obj, lv_btnmatrix_def_map);\n\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}"}, "lv_btnmatrix_destructor": {"type": "Function", "def": "static void lv_btnmatrix_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 374, "body": "{\n    LV_TRACE_OBJ_CREATE(\"begin\");\n    LV_UNUSED(class_p);\n    lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;\n    lv_mem_free(btnm->button_areas);\n    lv_mem_free(btnm->ctrl_bits);\n    btnm->button_areas = NULL;\n    btnm->ctrl_bits = NULL;\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}"}, "lv_btnmatrix_event": {"type": "Function", "def": "static void lv_btnmatrix_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 386, "body": "{\n    LV_UNUSED(class_p);\n\n    lv_res_t res;\n\n    /*Call the ancestor's event handler*/\n    res = lv_obj_event_base(MY_CLASS, e);\n    if(res != LV_RES_OK) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;\n    lv_point_t p;\n\n    if(code == LV_EVENT_REFR_EXT_DRAW_SIZE) {\n        lv_coord_t * s = lv_event_get_param(e);\n        if (has_popovers_in_top_row(obj)) {\n            /*reserve one row worth of extra space to account for popovers in the top row*/\n            *s = btnm->row_cnt > 0 ? lv_obj_get_content_height(obj) / btnm->row_cnt : 0;\n        } else {\n            *s = 0;\n        }\n    }\n    if(code == LV_EVENT_STYLE_CHANGED) {\n        lv_btnmatrix_set_map(obj, btnm->map_p);\n    }\n    else if(code == LV_EVENT_SIZE_CHANGED) {\n        lv_btnmatrix_set_map(obj, btnm->map_p);\n    }\n    else if(code == LV_EVENT_PRESSED) {\n        void * param = lv_event_get_param(e);\n        invalidate_button_area(obj, btnm->btn_id_sel);\n\n        lv_indev_type_t indev_type = lv_indev_get_type(lv_indev_get_act());\n        if(indev_type == LV_INDEV_TYPE_POINTER || indev_type == LV_INDEV_TYPE_BUTTON) {\n            uint16_t btn_pr;\n            /*Search the pressed area*/\n            lv_indev_get_point(param, &p);\n            btn_pr = get_button_from_point(obj, &p);\n            /*Handle the case where there is no button there*/\n            if(btn_pr != LV_BTNMATRIX_BTN_NONE) {\n                if(button_is_inactive(btnm->ctrl_bits[btn_pr]) == false &&\n                   button_is_hidden(btnm->ctrl_bits[btn_pr]) == false) {\n                    btnm->btn_id_sel = btn_pr;\n                    invalidate_button_area(obj, btnm->btn_id_sel); /*Invalidate the new area*/\n                }\n            }\n        }\n\n        if(btnm->btn_id_sel != LV_BTNMATRIX_BTN_NONE) {\n            if(button_is_click_trig(btnm->ctrl_bits[btnm->btn_id_sel]) == false &&\n               button_is_popover(btnm->ctrl_bits[btnm->btn_id_sel]) == false &&\n               button_is_inactive(btnm->ctrl_bits[btnm->btn_id_sel]) == false &&\n               button_is_hidden(btnm->ctrl_bits[btnm->btn_id_sel]) == false) {\n                uint32_t b = btnm->btn_id_sel;\n                res        = lv_event_send(obj, LV_EVENT_VALUE_CHANGED, &b);\n                if(res != LV_RES_OK) return;\n            }\n        }\n    }\n    else if(code == LV_EVENT_PRESSING) {\n        void * param = lv_event_get_param(e);\n        uint16_t btn_pr = LV_BTNMATRIX_BTN_NONE;\n        /*Search the pressed area*/\n        lv_indev_t * indev = lv_indev_get_act();\n        lv_indev_type_t indev_type = lv_indev_get_type(indev);\n        if(indev_type == LV_INDEV_TYPE_ENCODER || indev_type == LV_INDEV_TYPE_KEYPAD) return;\n\n        lv_indev_get_point(indev, &p);\n        btn_pr = get_button_from_point(obj, &p);\n        /*Invalidate to old and the new areas*/\n        if(btn_pr != btnm->btn_id_sel) {\n            if(btnm->btn_id_sel != LV_BTNMATRIX_BTN_NONE) {\n                invalidate_button_area(obj, btnm->btn_id_sel);\n            }\n\n            btnm->btn_id_sel = btn_pr;\n\n            lv_indev_reset_long_press(param); /*Start the log press time again on the new button*/\n            if(btn_pr != LV_BTNMATRIX_BTN_NONE &&\n               button_is_inactive(btnm->ctrl_bits[btn_pr]) == false &&\n               button_is_hidden(btnm->ctrl_bits[btn_pr]) == false) {\n                invalidate_button_area(obj, btn_pr);\n                /*Send VALUE_CHANGED for the newly pressed button*/\n                if(button_is_click_trig(btnm->ctrl_bits[btn_pr]) == false &&\n                   button_is_popover(btnm->ctrl_bits[btnm->btn_id_sel]) == false) {\n                    uint32_t b = btn_pr;\n                    res = lv_event_send(obj, LV_EVENT_VALUE_CHANGED, &b);\n                    if(res != LV_RES_OK) return;\n                }\n            }\n        }\n    }\n    else if(code == LV_EVENT_RELEASED) {\n        if(btnm->btn_id_sel != LV_BTNMATRIX_BTN_NONE) {\n            /*Toggle the button if enabled*/\n            if(button_is_checkable(btnm->ctrl_bits[btnm->btn_id_sel]) &&\n               !button_is_inactive(btnm->ctrl_bits[btnm->btn_id_sel])) {\n                if(button_get_checked(btnm->ctrl_bits[btnm->btn_id_sel]) && !btnm->one_check) {\n                    btnm->ctrl_bits[btnm->btn_id_sel] &= (~LV_BTNMATRIX_CTRL_CHECKED);\n                }\n                else {\n                    btnm->ctrl_bits[btnm->btn_id_sel] |= LV_BTNMATRIX_CTRL_CHECKED;\n                }\n                if(btnm->one_check) make_one_button_checked(obj, btnm->btn_id_sel);\n            }\n\n\n            if((button_is_click_trig(btnm->ctrl_bits[btnm->btn_id_sel]) == true ||\n                button_is_popover(btnm->ctrl_bits[btnm->btn_id_sel]) == true) &&\n               button_is_inactive(btnm->ctrl_bits[btnm->btn_id_sel]) == false &&\n               button_is_hidden(btnm->ctrl_bits[btnm->btn_id_sel]) == false) {\n                uint32_t b = btnm->btn_id_sel;\n                res        = lv_event_send(obj, LV_EVENT_VALUE_CHANGED, &b);\n                if(res != LV_RES_OK) return;\n            }\n        }\n\n        /*Invalidate to old pressed area*/;\n        invalidate_button_area(obj, btnm->btn_id_sel);\n\n        lv_indev_type_t indev_type = lv_indev_get_type(lv_indev_get_act());\n        if(indev_type == LV_INDEV_TYPE_POINTER || indev_type == LV_INDEV_TYPE_BUTTON) {\n            btnm->btn_id_sel = LV_BTNMATRIX_BTN_NONE;\n        }\n    }\n    else if(code == LV_EVENT_LONG_PRESSED_REPEAT) {\n        if(btnm->btn_id_sel != LV_BTNMATRIX_BTN_NONE) {\n            if(button_is_repeat_disabled(btnm->ctrl_bits[btnm->btn_id_sel]) == false &&\n               button_is_inactive(btnm->ctrl_bits[btnm->btn_id_sel]) == false &&\n               button_is_hidden(btnm->ctrl_bits[btnm->btn_id_sel]) == false) {\n                uint32_t b = btnm->btn_id_sel;\n                res        = lv_event_send(obj, LV_EVENT_VALUE_CHANGED, &b);\n                if(res != LV_RES_OK) return;\n            }\n        }\n    }\n    else if(code == LV_EVENT_PRESS_LOST) {\n        invalidate_button_area(obj, btnm->btn_id_sel);\n        btnm->btn_id_sel = LV_BTNMATRIX_BTN_NONE;\n    }\n    else if(code == LV_EVENT_FOCUSED) {\n        lv_indev_t * indev = lv_event_get_param(e);\n        lv_indev_type_t indev_type = lv_indev_get_type(indev);\n\n        /*If not focused by an input device assume the last input device*/\n        if(indev == NULL) {\n            indev = lv_indev_get_next(NULL);\n            indev_type = lv_indev_get_type(indev);\n        }\n\n        bool editing = lv_group_get_editing(lv_obj_get_group(obj));\n        /*Focus the first button if there is not selected button*/\n        if(btnm->btn_id_sel == LV_BTNMATRIX_BTN_NONE) {\n            if(indev_type == LV_INDEV_TYPE_KEYPAD || (indev_type == LV_INDEV_TYPE_ENCODER && editing)) {\n                uint32_t b = 0;\n                if(btnm->one_check) {\n                    while(button_is_hidden(btnm->ctrl_bits[b]) || button_is_inactive(btnm->ctrl_bits[b]) ||\n                          button_is_checked(btnm->ctrl_bits[b]) == false) b++;\n                }\n                else {\n                    while(button_is_hidden(btnm->ctrl_bits[b]) || button_is_inactive(btnm->ctrl_bits[b])) b++;\n                }\n\n                btnm->btn_id_sel = b;\n            }\n            else {\n                btnm->btn_id_sel = LV_BTNMATRIX_BTN_NONE;\n            }\n        }\n    }\n    else if(code == LV_EVENT_DEFOCUSED || code == LV_EVENT_LEAVE) {\n        if(btnm->btn_id_sel != LV_BTNMATRIX_BTN_NONE) invalidate_button_area(obj, btnm->btn_id_sel);\n        btnm->btn_id_sel = LV_BTNMATRIX_BTN_NONE;\n    }\n    else if(code == LV_EVENT_KEY) {\n\n        invalidate_button_area(obj, btnm->btn_id_sel);\n\n        char c = *((char *)lv_event_get_param(e));\n        if(c == LV_KEY_RIGHT) {\n            if(btnm->btn_id_sel == LV_BTNMATRIX_BTN_NONE)  btnm->btn_id_sel = 0;\n            else btnm->btn_id_sel++;\n            if(btnm->btn_id_sel >= btnm->btn_cnt) btnm->btn_id_sel = 0;\n\n            while(button_is_hidden(btnm->ctrl_bits[btnm->btn_id_sel]) || button_is_inactive(btnm->ctrl_bits[btnm->btn_id_sel])) {\n                btnm->btn_id_sel++;\n                if(btnm->btn_id_sel >= btnm->btn_cnt) btnm->btn_id_sel = 0;\n            }\n        }\n        else if(c == LV_KEY_LEFT) {\n            if(btnm->btn_id_sel == LV_BTNMATRIX_BTN_NONE) btnm->btn_id_sel = 0;\n\n            if(btnm->btn_id_sel == 0) btnm->btn_id_sel = btnm->btn_cnt - 1;\n            else if(btnm->btn_id_sel > 0) btnm->btn_id_sel--;\n\n            while(button_is_hidden(btnm->ctrl_bits[btnm->btn_id_sel]) || button_is_inactive(btnm->ctrl_bits[btnm->btn_id_sel])) {\n                if(btnm->btn_id_sel > 0) btnm->btn_id_sel--;\n                else btnm->btn_id_sel = btnm->btn_cnt - 1;\n            }\n        }\n        else if(c == LV_KEY_DOWN) {\n            lv_coord_t col_gap = lv_obj_get_style_pad_column(obj, LV_PART_MAIN);\n            /*Find the area below the the current*/\n            if(btnm->btn_id_sel == LV_BTNMATRIX_BTN_NONE) {\n                btnm->btn_id_sel = 0;\n                while(button_is_hidden(btnm->ctrl_bits[btnm->btn_id_sel]) || button_is_inactive(btnm->ctrl_bits[btnm->btn_id_sel])) {\n                    btnm->btn_id_sel++;\n                    if(btnm->btn_id_sel >= btnm->btn_cnt) btnm->btn_id_sel = 0;\n                }\n            }\n            else {\n                uint16_t area_below;\n                lv_coord_t pr_center =\n                    btnm->button_areas[btnm->btn_id_sel].x1 + (lv_area_get_width(&btnm->button_areas[btnm->btn_id_sel]) >> 1);\n\n                for(area_below = btnm->btn_id_sel; area_below < btnm->btn_cnt; area_below++) {\n                    if(btnm->button_areas[area_below].y1 > btnm->button_areas[btnm->btn_id_sel].y1 &&\n                       pr_center >= btnm->button_areas[area_below].x1 &&\n                       pr_center <= btnm->button_areas[area_below].x2 + col_gap &&\n                       button_is_inactive(btnm->ctrl_bits[area_below]) == false &&\n                       button_is_hidden(btnm->ctrl_bits[area_below]) == false) {\n                        break;\n                    }\n                }\n\n                if(area_below < btnm->btn_cnt) btnm->btn_id_sel = area_below;\n            }\n        }\n        else if(c == LV_KEY_UP) {\n            lv_coord_t col_gap = lv_obj_get_style_pad_column(obj, LV_PART_MAIN);\n            /*Find the area below the the current*/\n            if(btnm->btn_id_sel == LV_BTNMATRIX_BTN_NONE) {\n                btnm->btn_id_sel = 0;\n                while(button_is_hidden(btnm->ctrl_bits[btnm->btn_id_sel]) || button_is_inactive(btnm->ctrl_bits[btnm->btn_id_sel])) {\n                    btnm->btn_id_sel++;\n                    if(btnm->btn_id_sel >= btnm->btn_cnt) btnm->btn_id_sel = 0;\n                }\n            }\n            else {\n                int16_t area_above;\n                lv_coord_t pr_center =\n                    btnm->button_areas[btnm->btn_id_sel].x1 + (lv_area_get_width(&btnm->button_areas[btnm->btn_id_sel]) >> 1);\n\n                for(area_above = btnm->btn_id_sel; area_above >= 0; area_above--) {\n                    if(btnm->button_areas[area_above].y1 < btnm->button_areas[btnm->btn_id_sel].y1 &&\n                       pr_center >= btnm->button_areas[area_above].x1 - col_gap &&\n                       pr_center <= btnm->button_areas[area_above].x2 &&\n                       button_is_inactive(btnm->ctrl_bits[area_above]) == false &&\n                       button_is_hidden(btnm->ctrl_bits[area_above]) == false) {\n                        break;\n                    }\n                }\n                if(area_above >= 0) btnm->btn_id_sel = area_above;\n            }\n        }\n\n        invalidate_button_area(obj, btnm->btn_id_sel);\n    }\n    else if(code == LV_EVENT_DRAW_MAIN) {\n        draw_main(e);\n    }\n\n}"}, "draw_main": {"type": "Function", "def": "static void draw_main(lv_event_t * e)", "sline": 652, "body": "{\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;\n    if(btnm->btn_cnt == 0) return;\n\n    const lv_area_t * clip_area = lv_event_get_param(e);\n    obj->skip_trans = 1;\n\n    lv_area_t area_obj;\n    lv_obj_get_coords(obj, &area_obj);\n\n    lv_area_t btn_area;\n\n    uint16_t btn_i = 0;\n    uint16_t txt_i = 0;\n\n    lv_draw_rect_dsc_t draw_rect_dsc_act;\n    lv_draw_label_dsc_t draw_label_dsc_act;\n\n    lv_draw_rect_dsc_t draw_rect_dsc_def;\n    lv_draw_label_dsc_t draw_label_dsc_def;\n\n    lv_state_t state_ori = obj->state;\n    obj->state = LV_STATE_DEFAULT;\n    obj->skip_trans = 1;\n    lv_draw_rect_dsc_init(&draw_rect_dsc_def);\n    lv_draw_label_dsc_init(&draw_label_dsc_def);\n    lv_obj_init_draw_rect_dsc(obj, LV_PART_ITEMS, &draw_rect_dsc_def);\n    lv_obj_init_draw_label_dsc(obj, LV_PART_ITEMS, &draw_label_dsc_def);\n    obj->skip_trans = 0;\n    obj->state = state_ori;\n\n    lv_coord_t ptop = lv_obj_get_style_pad_top(obj, LV_PART_MAIN);\n    lv_coord_t pbottom = lv_obj_get_style_pad_bottom(obj, LV_PART_MAIN);\n    lv_coord_t pleft = lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n    lv_coord_t pright = lv_obj_get_style_pad_right(obj, LV_PART_MAIN);\n\n#if LV_USE_ARABIC_PERSIAN_CHARS\n    const size_t txt_ap_size = 256 ;\n    char * txt_ap = lv_mem_buf_get(txt_ap_size);\n#endif\n\n    lv_obj_draw_part_dsc_t part_draw_dsc;\n    lv_obj_draw_dsc_init(&part_draw_dsc, clip_area);\n    part_draw_dsc.part = LV_PART_ITEMS;\n    part_draw_dsc.class_p = MY_CLASS;\n    part_draw_dsc.type = LV_BTNMATRIX_DRAW_PART_BTN;\n    part_draw_dsc.rect_dsc = &draw_rect_dsc_act;\n    part_draw_dsc.label_dsc = &draw_label_dsc_act;\n\n    for(btn_i = 0; btn_i < btnm->btn_cnt; btn_i++, txt_i++) {\n        /*Search the next valid text in the map*/\n        while(strcmp(btnm->map_p[txt_i], \"\\n\") == 0) {\n            txt_i++;\n        }\n\n        /*Skip hidden buttons*/\n        if(button_is_hidden(btnm->ctrl_bits[btn_i])) continue;\n\n        /*Get the state of the button*/\n        lv_state_t btn_state = LV_STATE_DEFAULT;\n        if(button_get_checked(btnm->ctrl_bits[btn_i])) btn_state |= LV_STATE_CHECKED;\n\n        if(button_is_inactive(btnm->ctrl_bits[btn_i])) btn_state |= LV_STATE_DISABLED;\n        else if(btn_i == btnm->btn_id_sel) {\n            if(state_ori & LV_STATE_PRESSED) btn_state |= LV_STATE_PRESSED;\n            if(state_ori & LV_STATE_FOCUSED) btn_state |= LV_STATE_FOCUSED;\n            if(state_ori & LV_STATE_FOCUS_KEY) btn_state |= LV_STATE_FOCUS_KEY;\n            if(state_ori & LV_STATE_EDITED) btn_state |= LV_STATE_EDITED;\n        }\n\n        /*Get the button's area*/\n        lv_area_copy(&btn_area, &btnm->button_areas[btn_i]);\n        btn_area.x1 += area_obj.x1;\n        btn_area.y1 += area_obj.y1;\n        btn_area.x2 += area_obj.x1;\n        btn_area.y2 += area_obj.y1;\n\n        /*Set up the draw descriptors*/\n        if(btn_state == LV_STATE_DEFAULT) {\n            lv_memcpy(&draw_rect_dsc_act, &draw_rect_dsc_def, sizeof(lv_draw_rect_dsc_t));\n            lv_memcpy(&draw_label_dsc_act, &draw_label_dsc_def, sizeof(lv_draw_label_dsc_t));\n        }\n        /*In other cases get the styles directly without caching them*/\n        else {\n            obj->state = btn_state;\n            obj->skip_trans = 1;\n            lv_draw_rect_dsc_init(&draw_rect_dsc_act);\n            lv_draw_label_dsc_init(&draw_label_dsc_act);\n            lv_obj_init_draw_rect_dsc(obj, LV_PART_ITEMS, &draw_rect_dsc_act);\n            lv_obj_init_draw_label_dsc(obj, LV_PART_ITEMS, &draw_label_dsc_act);\n            obj->state = state_ori;\n            obj->skip_trans = 0;\n        }\n\n        bool recolor = button_is_recolor(btnm->ctrl_bits[btn_i]);\n        if(recolor) draw_label_dsc_act.flag |= LV_TEXT_FLAG_RECOLOR;\n        else draw_label_dsc_act.flag &= ~LV_TEXT_FLAG_RECOLOR;\n\n\n        part_draw_dsc.draw_area = &btn_area;\n        part_draw_dsc.id = btn_i;\n        lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n\n        /*Remove borders on the edges if `LV_BORDER_SIDE_INTERNAL`*/\n        if(draw_rect_dsc_act.border_side & LV_BORDER_SIDE_INTERNAL) {\n            draw_rect_dsc_act.border_side = LV_BORDER_SIDE_FULL;\n            if(btn_area.x1 == obj->coords.x1 + pleft) draw_rect_dsc_act.border_side &= ~LV_BORDER_SIDE_LEFT;\n            if(btn_area.x2 == obj->coords.x2 - pright) draw_rect_dsc_act.border_side &= ~LV_BORDER_SIDE_RIGHT;\n            if(btn_area.y1 == obj->coords.y1 + ptop) draw_rect_dsc_act.border_side &= ~LV_BORDER_SIDE_TOP;\n            if(btn_area.y2 == obj->coords.y2 - pbottom) draw_rect_dsc_act.border_side &= ~LV_BORDER_SIDE_BOTTOM;\n        }\n\n        lv_coord_t btn_height = lv_area_get_height(&btn_area);\n\n        if ((btn_state & LV_STATE_PRESSED) && (btnm->ctrl_bits[btn_i] & LV_BTNMATRIX_CTRL_POPOVER)) {\n            /*Push up the upper boundary of the btn area to create the popover*/\n            btn_area.y1 -= btn_height;\n        }\n\n        /*Draw the background*/\n        lv_draw_rect(&btn_area, clip_area, &draw_rect_dsc_act);\n\n        /*Calculate the size of the text*/\n        const lv_font_t * font = draw_label_dsc_act.font;\n        lv_coord_t letter_space = draw_label_dsc_act.letter_space;\n        lv_coord_t line_space = draw_label_dsc_act.line_space;\n        const char * txt = btnm->map_p[txt_i];\n\n#if LV_USE_ARABIC_PERSIAN_CHARS\n        /*Get the size of the Arabic text and process it*/\n        size_t len_ap = _lv_txt_ap_calc_bytes_cnt(txt);\n        if(len_ap < txt_ap_size) {\n            _lv_txt_ap_proc(txt, txt_ap);\n            txt = txt_ap;\n        }\n#endif\n        lv_point_t txt_size;\n        lv_txt_get_size(&txt_size, txt, font, letter_space,\n                        line_space, lv_area_get_width(&area_obj), draw_label_dsc_act.flag);\n\n        btn_area.x1 += (lv_area_get_width(&btn_area) - txt_size.x) / 2;\n        btn_area.y1 += (lv_area_get_height(&btn_area) - txt_size.y) / 2;\n        btn_area.x2 = btn_area.x1 + txt_size.x;\n        btn_area.y2 = btn_area.y1 + txt_size.y;\n\n        if ((btn_state & LV_STATE_PRESSED) && (btnm->ctrl_bits[btn_i] & LV_BTNMATRIX_CTRL_POPOVER)) {\n            /*Push up the button text into the popover*/\n            btn_area.y1 -= btn_height / 2;\n            btn_area.y2 -= btn_height / 2;\n        }\n\n        /*Draw the text*/\n        lv_draw_label(&btn_area, clip_area, &draw_label_dsc_act, txt, NULL);\n\n        lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n    }\n\n    obj->skip_trans = 0;\n#if LV_USE_ARABIC_PERSIAN_CHARS\n    lv_mem_buf_release(txt_ap);\n#endif\n}"}, "get_button_width": {"type": "Function", "def": "static uint8_t get_button_width(lv_btnmatrix_ctrl_t ctrl_bits)", "sline": 865, "body": "{\n    uint8_t w = ctrl_bits & LV_BTNMATRIX_WIDTH_MASK;\n    return w != 0 ? w : 1;\n}"}, "button_is_hidden": {"type": "Function", "def": "static bool button_is_hidden(lv_btnmatrix_ctrl_t ctrl_bits)", "sline": 871, "body": "{\n    return (ctrl_bits & LV_BTNMATRIX_CTRL_HIDDEN) ? true : false;\n}"}, "button_is_checked": {"type": "Function", "def": "static bool button_is_checked(lv_btnmatrix_ctrl_t ctrl_bits)", "sline": 876, "body": "{\n    return (ctrl_bits & LV_BTNMATRIX_CTRL_CHECKED) ? true : false;\n}"}, "button_is_repeat_disabled": {"type": "Function", "def": "static bool button_is_repeat_disabled(lv_btnmatrix_ctrl_t ctrl_bits)", "sline": 881, "body": "{\n    return (ctrl_bits & LV_BTNMATRIX_CTRL_NO_REPEAT) ? true : false;\n}"}, "button_is_inactive": {"type": "Function", "def": "static bool button_is_inactive(lv_btnmatrix_ctrl_t ctrl_bits)", "sline": 886, "body": "{\n    return (ctrl_bits & LV_BTNMATRIX_CTRL_DISABLED) ? true : false;\n}"}, "button_is_click_trig": {"type": "Function", "def": "static bool button_is_click_trig(lv_btnmatrix_ctrl_t ctrl_bits)", "sline": 891, "body": "{\n    return (ctrl_bits & LV_BTNMATRIX_CTRL_CLICK_TRIG) ? true : false;\n}"}, "button_is_popover": {"type": "Function", "def": "static bool button_is_popover(lv_btnmatrix_ctrl_t ctrl_bits)", "sline": 896, "body": "{\n    return (ctrl_bits & LV_BTNMATRIX_CTRL_POPOVER) ? true : false;\n}"}, "button_is_checkable": {"type": "Function", "def": "static bool button_is_checkable(lv_btnmatrix_ctrl_t ctrl_bits)", "sline": 901, "body": "{\n    return (ctrl_bits & LV_BTNMATRIX_CTRL_CHECKABLE) ? true : false;\n}"}, "button_is_recolor": {"type": "Function", "def": "static bool button_is_recolor(lv_btnmatrix_ctrl_t ctrl_bits)", "sline": 911, "body": "{\n    return (ctrl_bits & LV_BTNMATRIX_CTRL_RECOLOR) ? true : false;\n}"}, "button_get_checked": {"type": "Function", "def": "static bool button_get_checked(lv_btnmatrix_ctrl_t ctrl_bits)", "sline": 906, "body": "{\n    return (ctrl_bits & LV_BTNMATRIX_CTRL_CHECKED) ? true : false;\n}"}, "get_button_from_point": {"type": "Function", "def": "static uint16_t get_button_from_point(lv_obj_t * obj, lv_point_t * p)", "sline": 921, "body": "{\n    lv_area_t obj_cords;\n    lv_area_t btn_area;\n    lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;;\n    uint16_t i;\n    lv_obj_get_coords(obj, &obj_cords);\n\n    lv_coord_t w = lv_obj_get_width(obj);\n    lv_coord_t h = lv_obj_get_height(obj);\n    lv_coord_t pleft = lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n    lv_coord_t pright = lv_obj_get_style_pad_right(obj, LV_PART_MAIN);\n    lv_coord_t ptop = lv_obj_get_style_pad_top(obj, LV_PART_MAIN);\n    lv_coord_t pbottom = lv_obj_get_style_pad_bottom(obj, LV_PART_MAIN);\n    lv_coord_t prow = lv_obj_get_style_pad_row(obj, LV_PART_MAIN);\n    lv_coord_t pcol = lv_obj_get_style_pad_column(obj, LV_PART_MAIN);\n\n    /*Get the half gap. Button look larger with this value. (+1 for rounding error)*/\n    prow = (prow / 2) + 1 + (prow & 1);\n    pcol = (pcol / 2) + 1 + (pcol & 1);\n\n    prow = LV_MIN(prow, BTN_EXTRA_CLICK_AREA_MAX);\n    pcol = LV_MIN(pcol, BTN_EXTRA_CLICK_AREA_MAX);\n    pright = LV_MIN(pright, BTN_EXTRA_CLICK_AREA_MAX);\n    ptop = LV_MIN(ptop, BTN_EXTRA_CLICK_AREA_MAX);\n    pbottom = LV_MIN(pbottom, BTN_EXTRA_CLICK_AREA_MAX);\n\n    for(i = 0; i < btnm->btn_cnt; i++) {\n        lv_area_copy(&btn_area, &btnm->button_areas[i]);\n        if(btn_area.x1 <= pleft) btn_area.x1 += obj_cords.x1 - LV_MIN(pleft, BTN_EXTRA_CLICK_AREA_MAX);\n        else btn_area.x1 += obj_cords.x1 - pcol;\n\n        if(btn_area.y1 <= ptop) btn_area.y1 += obj_cords.y1 - LV_MIN(ptop, BTN_EXTRA_CLICK_AREA_MAX);\n        else btn_area.y1 += obj_cords.y1 - prow;\n\n        if(btn_area.x2 >= w - pright - 2) btn_area.x2 += obj_cords.x1 + LV_MIN(pright,\n                                                                                   BTN_EXTRA_CLICK_AREA_MAX);  /*-2 for rounding error*/\n        else btn_area.x2 += obj_cords.x1 + pcol;\n\n        if(btn_area.y2 >= h - pbottom - 2) btn_area.y2 += obj_cords.y1 + LV_MIN(pbottom,\n                                                                                    BTN_EXTRA_CLICK_AREA_MAX); /*-2 for rounding error*/\n        else btn_area.y2 += obj_cords.y1 + prow;\n\n        if(_lv_area_is_point_on(&btn_area, p, 0) != false) {\n            break;\n        }\n    }\n\n    if(i == btnm->btn_cnt) i = LV_BTNMATRIX_BTN_NONE;\n\n    return i;\n}"}, "allocate_btn_areas_and_controls": {"type": "Function", "def": "static void allocate_btn_areas_and_controls(const lv_obj_t * obj, const char ** map)", "sline": 821, "body": "{\n    lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;\n    btnm->row_cnt = 1;\n    /*Count the buttons in the map*/\n    uint16_t btn_cnt = 0;\n    uint16_t i       = 0;\n    while(map[i] && map[i][0] != '\\0') {\n        if(strcmp(map[i], \"\\n\") != 0) { /*Do not count line breaks*/\n            btn_cnt++;\n        } else {\n            btnm->row_cnt++;\n        }\n        i++;\n    }\n\n    /*Do not allocate memory for the same amount of buttons*/\n    if(btn_cnt == btnm->btn_cnt) return;\n\n    if(btnm->button_areas != NULL) {\n        lv_mem_free(btnm->button_areas);\n        btnm->button_areas = NULL;\n    }\n    if(btnm->ctrl_bits != NULL) {\n        lv_mem_free(btnm->ctrl_bits);\n        btnm->ctrl_bits = NULL;\n    }\n\n    btnm->button_areas = lv_mem_alloc(sizeof(lv_area_t) * btn_cnt);\n    LV_ASSERT_MALLOC(btnm->button_areas);\n    btnm->ctrl_bits = lv_mem_alloc(sizeof(lv_btnmatrix_ctrl_t) * btn_cnt);\n    LV_ASSERT_MALLOC(btnm->ctrl_bits);\n    if(btnm->button_areas == NULL || btnm->ctrl_bits == NULL) btn_cnt = 0;\n\n    lv_memset_00(btnm->ctrl_bits, sizeof(lv_btnmatrix_ctrl_t) * btn_cnt);\n\n    btnm->btn_cnt = btn_cnt;\n}"}, "invalidate_button_area": {"type": "Function", "def": "static void invalidate_button_area(const lv_obj_t * obj, uint16_t btn_idx)", "sline": 974, "body": "{\n    if(btn_idx == LV_BTNMATRIX_BTN_NONE) return;\n\n    lv_area_t btn_area;\n    lv_area_t obj_area;\n\n    lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;;\n    lv_area_copy(&btn_area, &btnm->button_areas[btn_idx]);\n    lv_obj_get_coords(obj, &obj_area);\n\n    /*The buttons might have outline and shadow so make the invalidation larger with the gaps between the buttons.\n     *It assumes that the outline or shadow is smaller than the gaps*/\n    lv_coord_t row_gap = lv_obj_get_style_pad_row(obj, LV_PART_MAIN);\n    lv_coord_t col_gap = lv_obj_get_style_pad_column(obj, LV_PART_MAIN);\n\n    /*Be sure to have a minimal extra space if row/col_gap is small*/\n    lv_coord_t dpi = lv_disp_get_dpi(lv_obj_get_disp(obj));\n    row_gap = LV_MAX(row_gap, dpi / 10);\n    col_gap = LV_MAX(col_gap, dpi / 10);\n\n    /*Convert relative coordinates to absolute*/\n    btn_area.x1 += obj_area.x1 - row_gap;\n    btn_area.y1 += obj_area.y1 - col_gap;\n    btn_area.x2 += obj_area.x1 + row_gap;\n    btn_area.y2 += obj_area.y1 + col_gap;\n\n    if ((btn_idx == btnm->btn_id_sel) && (btnm->ctrl_bits[btn_idx] & LV_BTNMATRIX_CTRL_POPOVER)) {\n        /*Push up the upper boundary of the btn area to also invalidate the popover*/\n        btn_area.y1 -= lv_area_get_height(&btn_area);\n    }\n\n    lv_obj_invalidate_area(obj, &btn_area);\n}"}, "make_one_button_checked": {"type": "Function", "def": "static void make_one_button_checked(lv_obj_t * obj, uint16_t btn_idx)", "sline": 1015, "body": "{\n    /*Save whether the button was toggled*/\n    bool was_toggled = lv_btnmatrix_has_btn_ctrl(obj, btn_idx, LV_BTNMATRIX_CTRL_CHECKED);\n\n    lv_btnmatrix_clear_btn_ctrl_all(obj, LV_BTNMATRIX_CTRL_CHECKED);\n\n    if(was_toggled) lv_btnmatrix_set_btn_ctrl(obj, btn_idx, LV_BTNMATRIX_CTRL_CHECKED);\n}"}, "has_popovers_in_top_row": {"type": "Function", "def": "static bool has_popovers_in_top_row(lv_obj_t * obj)", "sline": 1030, "body": "{\n    lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;\n\n    if (btnm->row_cnt <= 0) {\n        return false;\n    }\n\n    const char ** map_row = btnm->map_p;\n    uint16_t btn_cnt = 0;\n\n    while (map_row[btn_cnt] && strcmp(map_row[btn_cnt], \"\\n\") != 0 && map_row[btn_cnt][0] != '\\0') {\n        if (button_is_popover(btnm->ctrl_bits[btn_cnt])) {\n            return true;\n        }\n        btn_cnt++;\n    }\n\n    return false;\n}"}, "lv_btnmatrix_def_map": {"type": "Variable", "def": "static const char * lv_btnmatrix_def_map[] = {\"Btn1\", \"Btn2\", \"Btn3\", \"\\n\", \"Btn4\", \"Btn5\", \"\"}", "sline": 59}, "lv_btnmatrix_class": {"type": "Variable", "def": "const lv_obj_class_t lv_btnmatrix_class = {\n    .constructor_cb = lv_btnmatrix_constructor,\n    .destructor_cb = lv_btnmatrix_destructor,\n    .event_cb = lv_btnmatrix_event,\n    .width_def = LV_DPI_DEF * 2,\n    .height_def = LV_DPI_DEF,\n    .instance_size = sizeof(lv_btnmatrix_t),\n    .editable = LV_OBJ_CLASS_EDITABLE_TRUE,\n    .group_def = LV_OBJ_CLASS_GROUP_DEF_TRUE,\n    .base_class = &lv_obj_class\n}", "sline": 61}, "lv_btnmatrix_create": {"type": "Function", "def": "lv_obj_t * lv_btnmatrix_create(lv_obj_t * parent)", "sline": 81, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_btnmatrix_set_map": {"type": "Function", "def": "void lv_btnmatrix_set_map(lv_obj_t * obj, const char * map[])", "sline": 93, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    if(map == NULL) return;\n\n    lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;\n\n    /*Analyze the map and create the required number of buttons*/\n    allocate_btn_areas_and_controls(obj, map);\n    btnm->map_p = map;\n\n    lv_base_dir_t base_dir = lv_obj_get_style_base_dir(obj, LV_PART_MAIN);\n\n    /*Set size and positions of the buttons*/\n    lv_coord_t pleft = lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n    lv_coord_t ptop = lv_obj_get_style_pad_top(obj, LV_PART_MAIN);\n    lv_coord_t prow = lv_obj_get_style_pad_row(obj, LV_PART_MAIN);\n    lv_coord_t pcol = lv_obj_get_style_pad_column(obj, LV_PART_MAIN);\n\n    lv_coord_t max_w            = lv_obj_get_content_width(obj);\n    lv_coord_t max_h            = lv_obj_get_content_height(obj);\n\n    /*Calculate the position of each row*/\n    lv_coord_t max_h_no_gap = max_h - (prow * (btnm->row_cnt - 1));\n\n    /*Count the units and the buttons in a line\n     *(A button can be 1,2,3... unit wide)*/\n    uint32_t txt_tot_i = 0; /*Act. index in the str map*/\n    uint32_t btn_tot_i = 0; /*Act. index of button areas*/\n    const char ** map_row = map;\n\n    /*Count the units and the buttons in a line*/\n    uint32_t row;\n    for(row = 0; row < btnm->row_cnt; row++) {\n        uint16_t unit_cnt = 0;           /*Number of units in a row*/\n        uint16_t btn_cnt = 0;            /*Number of buttons in a row*/\n        /*Count the buttons and units in this row*/\n        while(map_row[btn_cnt] && strcmp(map_row[btn_cnt], \"\\n\") != 0 && map_row[btn_cnt][0] != '\\0') {\n            unit_cnt += get_button_width(btnm->ctrl_bits[btn_tot_i + btn_cnt]);\n            btn_cnt++;\n        }\n\n        /*Only deal with the non empty lines*/\n        if(btn_cnt == 0) {\n            map_row = &map_row[btn_cnt + 1];       /*Set the map to the next row*/\n            continue;\n        }\n\n        lv_coord_t row_y1 = ptop + (max_h_no_gap * row) / btnm->row_cnt + row * prow;\n        lv_coord_t row_y2 = ptop + (max_h_no_gap * (row + 1)) / btnm->row_cnt + row * prow - 1;\n\n        /*Set the button size and positions*/\n        lv_coord_t max_w_no_gap = max_w - (pcol * (btn_cnt - 1));\n        if(max_w_no_gap < 0) max_w_no_gap = 0;\n\n        uint32_t row_unit_cnt = 0;  /*The current unit position in the row*/\n        uint32_t btn;\n        for(btn = 0; btn < btn_cnt; btn++, btn_tot_i++, txt_tot_i++) {\n            uint32_t btn_u = get_button_width(btnm->ctrl_bits[btn_tot_i]);\n\n            lv_coord_t btn_x1 = (max_w_no_gap * row_unit_cnt) / unit_cnt + btn * pcol;\n            lv_coord_t btn_x2 = (max_w_no_gap * (row_unit_cnt + btn_u)) / unit_cnt + btn * pcol - 1;\n\n            /*If RTL start from the right*/\n            if(base_dir == LV_BASE_DIR_RTL) {\n                lv_coord_t tmp = btn_x1;\n                btn_x1 = btn_x2;\n                btn_x2 = tmp;\n\n                btn_x1 = max_w - btn_x1;\n                btn_x2 = max_w - btn_x2;\n            }\n\n            btn_x1 += pleft;\n            btn_x2 += pleft;\n\n            lv_area_set(&btnm->button_areas[btn_tot_i], btn_x1, row_y1, btn_x2, row_y2);\n\n            row_unit_cnt += btn_u;\n        }\n\n        map_row = &map_row[btn_cnt + 1];       /*Set the map to the next line*/\n    }\n\n    /*Popovers in the top row will draw outside the widget and the extended draw size depends on\n     *the row height which may have changed when setting the new map*/\n    lv_obj_refresh_ext_draw_size(obj);\n\n    lv_obj_invalidate(obj);\n}"}, "lv_btnmatrix_set_ctrl_map": {"type": "Function", "def": "void lv_btnmatrix_set_ctrl_map(lv_obj_t * obj, const lv_btnmatrix_ctrl_t ctrl_map[])", "sline": 184, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;\n    lv_memcpy(btnm->ctrl_bits, ctrl_map, sizeof(lv_btnmatrix_ctrl_t) * btnm->btn_cnt);\n\n    lv_btnmatrix_set_map(obj, btnm->map_p);\n}"}, "lv_btnmatrix_set_selected_btn": {"type": "Function", "def": "void lv_btnmatrix_set_selected_btn(lv_obj_t * obj, uint16_t btn_id)", "sline": 194, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;\n\n    if(btn_id >= btnm->btn_cnt && btn_id != LV_BTNMATRIX_BTN_NONE) return;\n\n    invalidate_button_area(obj, btnm->btn_id_sel);\n    btnm->btn_id_sel = btn_id;\n    invalidate_button_area(obj, btn_id);\n}"}, "lv_btnmatrix_set_btn_ctrl": {"type": "Function", "def": "void lv_btnmatrix_set_btn_ctrl(lv_obj_t * obj, uint16_t btn_id, lv_btnmatrix_ctrl_t ctrl)", "sline": 207, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;;\n\n    if(btn_id >= btnm->btn_cnt) return;\n\n    if(btnm->one_check && (ctrl & LV_BTNMATRIX_CTRL_CHECKED)) {\n        lv_btnmatrix_clear_btn_ctrl_all(obj, LV_BTNMATRIX_CTRL_CHECKED);\n    }\n\n    btnm->ctrl_bits[btn_id] |= ctrl;\n    invalidate_button_area(obj, btn_id);\n\n    if (ctrl & LV_BTNMATRIX_CTRL_POPOVER) {\n        lv_obj_refresh_ext_draw_size(obj);\n    }\n}"}, "lv_btnmatrix_clear_btn_ctrl": {"type": "Function", "def": "void lv_btnmatrix_clear_btn_ctrl(lv_obj_t * obj, uint16_t btn_id, lv_btnmatrix_ctrl_t ctrl)", "sline": 227, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;;\n\n    if(btn_id >= btnm->btn_cnt) return;\n\n    btnm->ctrl_bits[btn_id] &= (~ctrl);\n    invalidate_button_area(obj, btn_id);\n\n    if (ctrl & LV_BTNMATRIX_CTRL_POPOVER) {\n        lv_obj_refresh_ext_draw_size(obj);\n    }\n}"}, "lv_btnmatrix_set_btn_ctrl_all": {"type": "Function", "def": "void lv_btnmatrix_set_btn_ctrl_all(lv_obj_t * obj, lv_btnmatrix_ctrl_t ctrl)", "sline": 243, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;;\n    uint16_t i;\n    for(i = 0; i < btnm->btn_cnt; i++) {\n        lv_btnmatrix_set_btn_ctrl(obj, i, ctrl);\n    }\n}"}, "lv_btnmatrix_clear_btn_ctrl_all": {"type": "Function", "def": "void lv_btnmatrix_clear_btn_ctrl_all(lv_obj_t * obj, lv_btnmatrix_ctrl_t ctrl)", "sline": 254, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;;\n    uint16_t i;\n    for(i = 0; i < btnm->btn_cnt; i++) {\n        lv_btnmatrix_clear_btn_ctrl(obj, i, ctrl);\n    }\n}"}, "lv_btnmatrix_set_btn_width": {"type": "Function", "def": "void lv_btnmatrix_set_btn_width(lv_obj_t * obj, uint16_t btn_id, uint8_t width)", "sline": 265, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;;\n    if(btn_id >= btnm->btn_cnt) return;\n    btnm->ctrl_bits[btn_id] &= (~LV_BTNMATRIX_WIDTH_MASK);\n    btnm->ctrl_bits[btn_id] |= (LV_BTNMATRIX_WIDTH_MASK & width);\n\n    lv_btnmatrix_set_map(obj, btnm->map_p);\n}"}, "lv_btnmatrix_set_one_checked": {"type": "Function", "def": "void lv_btnmatrix_set_one_checked(lv_obj_t * obj, bool en)", "sline": 277, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;;\n    btnm->one_check     = en;\n\n    /*If more than one button is toggled only the first one should be*/\n    make_one_button_checked(obj, 0);\n}"}, "lv_btnmatrix_get_map": {"type": "Function", "def": "const char ** lv_btnmatrix_get_map(const lv_obj_t * obj)", "sline": 292, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;;\n    return btnm->map_p;\n}"}, "lv_btnmatrix_get_selected_btn": {"type": "Function", "def": "uint16_t lv_btnmatrix_get_selected_btn(const lv_obj_t * obj)", "sline": 300, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;;\n    return btnm->btn_id_sel;\n}"}, "lv_btnmatrix_get_btn_text": {"type": "Function", "def": "const char * lv_btnmatrix_get_btn_text(const lv_obj_t * obj, uint16_t btn_id)", "sline": 308, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    if(btn_id == LV_BTNMATRIX_BTN_NONE) return NULL;\n\n    lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;\n    if(btn_id > btnm->btn_cnt) return NULL;\n\n    uint16_t txt_i = 0;\n    uint16_t btn_i = 0;\n\n    /*Search the text of btnm->btn_pr the buttons text in the map\n     *Skip \"\\n\"-s*/\n    while(btn_i != btn_id) {\n        btn_i++;\n        txt_i++;\n        if(strcmp(btnm->map_p[txt_i], \"\\n\") == 0) txt_i++;\n    }\n\n    if(btn_i == btnm->btn_cnt) return NULL;\n\n    return btnm->map_p[txt_i];\n}"}, "lv_btnmatrix_has_btn_ctrl": {"type": "Function", "def": "bool lv_btnmatrix_has_btn_ctrl(lv_obj_t * obj, uint16_t btn_id, lv_btnmatrix_ctrl_t ctrl)", "sline": 333, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;;\n    if(btn_id >= btnm->btn_cnt) return false;\n\n    return ((btnm->ctrl_bits[btn_id] & ctrl) == ctrl) ? true : false;\n}"}, "lv_btnmatrix_get_one_checked": {"type": "Function", "def": "bool lv_btnmatrix_get_one_checked(const lv_obj_t * obj)", "sline": 343, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_btnmatrix_t * btnm = (lv_btnmatrix_t *)obj;;\n\n    return btnm->one_check;\n}"}, "carbit_updater/lvgl/src/widgets/lv_btnmatrix.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_btnmatrix.c"}}, "carbit_updater/lvgl/src/draw/lv_draw_blend.h": {"lv_color": {"type": "Variable", "def": "#include ../misc/lv_color.h", "sline": 16}, "lv_area": {"type": "Variable", "def": "#include ../misc/lv_area.h", "sline": 17}, "lv_style": {"type": "Variable", "def": "#include ../misc/lv_style.h", "sline": 18}, "lv_draw_mask": {"type": "Variable", "def": "#include lv_draw_mask.h", "sline": 19, "include": ["carbit_updater/lvgl/src/draw/lv_draw_mask.h", null]}, "_lv_blend_fill": {"type": "Function", "def": "void _lv_blend_fill(const lv_area_t * clip_area, const lv_area_t * fill_area, lv_color_t color,\n                                          lv_opa_t * mask, lv_draw_mask_res_t mask_res, lv_opa_t opa, lv_blend_mode_t mode)", "sline": 34}, "_lv_blend_map": {"type": "Function", "def": "void _lv_blend_map(const lv_area_t * clip_area, const lv_area_t * map_area,\n                                         const lv_color_t * map_buf,\n                                         lv_opa_t * mask, lv_draw_mask_res_t mask_res, lv_opa_t opa, lv_blend_mode_t mode)", "sline": 37}, "carbit_updater/lvgl/src/draw/lv_draw_blend.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_draw_blend.h"}}, "carbit_updater/lvgl/src/extra/widgets/led/lv_led.c": {"lv_led": {"type": "Variable", "def": "#include lv_led.h", "sline": 9, "include": ["carbit_updater/lvgl/src/extra/widgets/led/lv_led.h", null]}, "lv_assert": {"type": "Variable", "def": "#include ../../../misc/lv_assert.h", "sline": 12}, "lv_led_constructor": {"type": "Function", "def": "static void lv_led_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 150, "body": "{\n    LV_UNUSED(class_p);\n    lv_led_t * led = (lv_led_t *)obj;\n    led->color = lv_theme_get_color_primary(obj);\n    led->bright = LV_LED_BRIGHT_MAX;\n}"}, "lv_led_event": {"type": "Function", "def": "static void lv_led_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 158, "body": "{\n    LV_UNUSED(class_p);\n\n    lv_res_t res;\n\n    /* Call the ancestor's event handler */\n    lv_event_code_t code = lv_event_get_code(e);\n    if(code != LV_EVENT_DRAW_MAIN && code != LV_EVENT_DRAW_MAIN_END) {\n        res = lv_obj_event_base(MY_CLASS, e);\n        if(res != LV_RES_OK) return;\n    }\n\n    lv_obj_t * obj = lv_event_get_target(e);\n    if(code == LV_EVENT_DRAW_MAIN) {\n        /*Make darker colors in a temporary style according to the brightness*/\n        lv_led_t * led = (lv_led_t *)obj;\n\n        lv_draw_rect_dsc_t rect_dsc;\n        lv_draw_rect_dsc_init(&rect_dsc);\n        lv_obj_init_draw_rect_dsc(obj, LV_PART_MAIN, &rect_dsc);\n\n        /*Use the original colors brightness to modify color->led*/\n        rect_dsc.bg_color = lv_color_mix(led->color, lv_color_black(), lv_color_brightness(rect_dsc.bg_color));\n        rect_dsc.bg_grad_color = lv_color_mix(led->color, lv_color_black(), lv_color_brightness(rect_dsc.bg_grad_color));\n        rect_dsc.shadow_color = lv_color_mix(led->color, lv_color_black(), lv_color_brightness(rect_dsc.shadow_color));\n        rect_dsc.border_color = lv_color_mix(led->color, lv_color_black(), lv_color_brightness(rect_dsc.border_color));\n        rect_dsc.outline_color = lv_color_mix(led->color, lv_color_black(), lv_color_brightness(rect_dsc.outline_color));\n\n        /*Mix. the color with black proportionally with brightness*/\n        rect_dsc.bg_color   = lv_color_mix(rect_dsc.bg_color, lv_color_black(), led->bright);\n        rect_dsc.bg_grad_color   = lv_color_mix(rect_dsc.bg_grad_color, lv_color_black(), led->bright);\n        rect_dsc.border_color = lv_color_mix(rect_dsc.border_color, lv_color_black(), led->bright);\n        rect_dsc.shadow_color = lv_color_mix(rect_dsc.shadow_color, lv_color_black(), led->bright);\n        rect_dsc.outline_color = lv_color_mix(rect_dsc.outline_color, lv_color_black(), led->bright);\n\n        /*Set the current shadow width according to brightness proportionally between LV_LED_BRIGHT_OFF\n         * and LV_LED_BRIGHT_ON*/\n        rect_dsc.shadow_width = ((led->bright - LV_LED_BRIGHT_MIN) * rect_dsc.shadow_width) /\n                                (LV_LED_BRIGHT_MAX - LV_LED_BRIGHT_MIN);\n        rect_dsc.shadow_spread = ((led->bright - LV_LED_BRIGHT_MIN) * rect_dsc.shadow_spread) /\n                                 (LV_LED_BRIGHT_MAX - LV_LED_BRIGHT_MIN);\n\n        const lv_area_t * clip_area = lv_event_get_param(e);\n\n        lv_obj_draw_part_dsc_t  part_draw_dsc;\n        lv_obj_draw_dsc_init(&part_draw_dsc, clip_area);\n        part_draw_dsc.draw_area = &obj->coords;\n        part_draw_dsc.class_p = MY_CLASS;\n        part_draw_dsc.type = LV_LED_DRAW_PART_RECTANGLE;\n        part_draw_dsc.rect_dsc = &rect_dsc;\n        part_draw_dsc.part = LV_PART_MAIN;\n\n        lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n        lv_draw_rect(&obj->coords, clip_area, &rect_dsc);\n        lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n    }\n}"}, "lv_led_class": {"type": "Variable", "def": "const lv_obj_class_t lv_led_class  = {\n    .base_class = &lv_obj_class,\n    .constructor_cb = lv_led_constructor,\n    .width_def = LV_DPI_DEF / 5,\n    .height_def = LV_DPI_DEF / 5,\n    .event_cb = lv_led_event,\n    .instance_size = sizeof(lv_led_t),\n}", "sline": 32}, "lv_led_create": {"type": "Function", "def": "lv_obj_t * lv_led_create(lv_obj_t * parent)", "sline": 54, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_led_set_color": {"type": "Function", "def": "void lv_led_set_color(lv_obj_t * obj, lv_color_t color)", "sline": 71, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_led_t * led = (lv_led_t *)obj;\n    led->color = color;\n    lv_obj_invalidate(obj);\n}"}, "lv_led_set_brightness": {"type": "Function", "def": "void lv_led_set_brightness(lv_obj_t * obj, uint8_t bright)", "sline": 85, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_led_t * led = (lv_led_t *)obj;\n    if(led->bright == bright) return;\n\n    led->bright = LV_CLAMP(LV_LED_BRIGHT_MIN, bright, LV_LED_BRIGHT_MAX);\n\n    /*Invalidate the object there fore it will be redrawn*/\n    lv_obj_invalidate(obj);\n}"}, "lv_led_on": {"type": "Function", "def": "void lv_led_on(lv_obj_t * led)", "sline": 102, "body": "{\n    lv_led_set_brightness(led, LV_LED_BRIGHT_MAX);\n}"}, "lv_led_off": {"type": "Function", "def": "void lv_led_off(lv_obj_t * led)", "sline": 111, "body": "{\n    lv_led_set_brightness(led, LV_LED_BRIGHT_MIN);\n}"}, "lv_led_toggle": {"type": "Function", "def": "void lv_led_toggle(lv_obj_t * obj)", "sline": 120, "body": "{\n    uint8_t bright = lv_led_get_brightness(obj);\n    if(bright > (LV_LED_BRIGHT_MIN + LV_LED_BRIGHT_MAX) >> 1)\n        lv_led_off(obj);\n    else\n        lv_led_on(obj);\n}"}, "lv_led_get_brightness": {"type": "Function", "def": "uint8_t lv_led_get_brightness(const lv_obj_t * obj)", "sline": 138, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_led_t * led = (lv_led_t *)obj;\n    return led->bright;\n}"}, "carbit_updater/lvgl/src/extra/widgets/led/lv_led.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/led/lv_led.c"}}, "carbit_updater/lvgl/src/widgets/lv_checkbox.c": {"lv_checkbox": {"type": "Variable", "def": "#include lv_checkbox.h", "sline": 9, "include": ["carbit_updater/lvgl/src/widgets/lv_checkbox.h", null]}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 12}, "lv_txt_ap": {"type": "Variable", "def": "#include ../misc/lv_txt_ap.h", "sline": 13}, "lv_group": {"type": "Variable", "def": "#include ../core/lv_group.h", "sline": 14}, "lv_draw": {"type": "Variable", "def": "#include ../draw/lv_draw.h", "sline": 15}, "lv_checkbox_constructor": {"type": "Function", "def": "static void lv_checkbox_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 118, "body": "{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_checkbox_t * cb = (lv_checkbox_t *)obj;\n\n    cb->txt = \"Check box\";\n    cb->static_txt = 1;\n    lv_obj_add_flag(obj, LV_OBJ_FLAG_CLICKABLE);\n    lv_obj_add_flag(obj, LV_OBJ_FLAG_CHECKABLE);\n    lv_obj_add_flag(obj, LV_OBJ_FLAG_SCROLL_ON_FOCUS);\n\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}"}, "lv_checkbox_destructor": {"type": "Function", "def": "static void lv_checkbox_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 134, "body": "{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_checkbox_t * cb = (lv_checkbox_t *)obj;\n    if(!cb->static_txt) {\n        lv_mem_free(cb->txt);\n        cb->txt = NULL;\n    }\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}"}, "lv_checkbox_event": {"type": "Function", "def": "static void lv_checkbox_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 147, "body": "{\n    LV_UNUSED(class_p);\n\n    lv_res_t res;\n    /*Call the ancestor's event handler*/\n    res = lv_obj_event_base(MY_CLASS, e);\n    if(res != LV_RES_OK) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n\n    if(code == LV_EVENT_PRESSED || code == LV_EVENT_RELEASED) {\n        lv_obj_invalidate(obj);\n    }\n    else if(code == LV_EVENT_GET_SELF_SIZE) {\n        lv_point_t * p = lv_event_get_param(e);\n        lv_checkbox_t * cb = (lv_checkbox_t *)obj;\n\n        const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_MAIN);\n        lv_coord_t font_h = lv_font_get_line_height(font);\n        lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);\n        lv_coord_t letter_space = lv_obj_get_style_text_letter_space(obj, LV_PART_MAIN);\n\n        lv_point_t txt_size;\n        lv_txt_get_size(&txt_size, cb->txt, font, letter_space, line_space, LV_COORD_MAX, LV_TEXT_FLAG_NONE);\n\n        lv_coord_t bg_colp = lv_obj_get_style_pad_column(obj, LV_PART_MAIN);\n        lv_coord_t marker_leftp = lv_obj_get_style_pad_left(obj, LV_PART_INDICATOR);\n        lv_coord_t marker_rightp = lv_obj_get_style_pad_right(obj, LV_PART_INDICATOR);\n        lv_coord_t marker_topp = lv_obj_get_style_pad_top(obj, LV_PART_INDICATOR);\n        lv_coord_t marker_bottomp = lv_obj_get_style_pad_bottom(obj, LV_PART_INDICATOR);\n        lv_point_t marker_size;\n        marker_size.x = font_h + marker_leftp + marker_rightp;\n        marker_size.y = font_h + marker_topp + marker_bottomp;\n\n        p->x = marker_size.x + txt_size.x + bg_colp;\n        p->y = LV_MAX(marker_size.y, txt_size.y);\n    }\n    else if(code == LV_EVENT_REFR_EXT_DRAW_SIZE) {\n        lv_coord_t * s = lv_event_get_param(e);\n        lv_coord_t m = lv_obj_calculate_ext_draw_size(obj, LV_PART_INDICATOR);\n        *s = LV_MAX(*s, m);\n    }\n    else if(code == LV_EVENT_RELEASED) {\n        uint32_t v = lv_obj_get_state(obj) & LV_STATE_CHECKED ? 1 : 0;\n        res = lv_event_send(obj, LV_EVENT_VALUE_CHANGED, &v);\n        if(res != LV_RES_OK) return;\n\n        lv_obj_invalidate(obj);\n    }\n    else if(code == LV_EVENT_DRAW_MAIN) {\n        lv_checkbox_draw(e);\n    }\n}"}, "lv_checkbox_draw": {"type": "Function", "def": "static void lv_checkbox_draw(lv_event_t * e)", "sline": 203, "body": "{\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_checkbox_t * cb = (lv_checkbox_t *)obj;\n\n    const lv_area_t * clip_area = lv_event_get_param(e);\n    const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_MAIN);\n    lv_coord_t font_h = lv_font_get_line_height(font);\n\n    lv_coord_t bg_border = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n    lv_coord_t bg_topp = lv_obj_get_style_pad_top(obj, LV_PART_MAIN) + bg_border;\n    lv_coord_t bg_leftp = lv_obj_get_style_pad_left(obj, LV_PART_MAIN) + bg_border;\n    lv_coord_t bg_colp = lv_obj_get_style_pad_column(obj, LV_PART_MAIN);\n\n    lv_coord_t marker_leftp = lv_obj_get_style_pad_left(obj, LV_PART_INDICATOR);\n    lv_coord_t marker_rightp = lv_obj_get_style_pad_right(obj, LV_PART_INDICATOR);\n    lv_coord_t marker_topp = lv_obj_get_style_pad_top(obj, LV_PART_INDICATOR);\n    lv_coord_t marker_bottomp = lv_obj_get_style_pad_bottom(obj, LV_PART_INDICATOR);\n\n    lv_coord_t transf_w = lv_obj_get_style_transform_width(obj, LV_PART_INDICATOR);\n    lv_coord_t transf_h = lv_obj_get_style_transform_height(obj, LV_PART_INDICATOR);\n\n    lv_draw_rect_dsc_t indic_dsc;\n    lv_draw_rect_dsc_init(&indic_dsc);\n    lv_obj_init_draw_rect_dsc(obj, LV_PART_INDICATOR, &indic_dsc);\n    lv_area_t marker_area;\n    marker_area.x1 = obj->coords.x1 + bg_leftp;\n    marker_area.x2 = marker_area.x1 + font_h + marker_leftp + marker_rightp - 1;\n    marker_area.y1 = obj->coords.y1 + bg_topp;\n    marker_area.y2 = marker_area.y1 + font_h + marker_topp + marker_bottomp - 1;\n\n    lv_area_t marker_area_transf;\n    lv_area_copy(&marker_area_transf, &marker_area);\n    marker_area_transf.x1 -= transf_w;\n    marker_area_transf.x2 += transf_w;\n    marker_area_transf.y1 -= transf_h;\n    marker_area_transf.y2 += transf_h;\n\n    lv_obj_draw_part_dsc_t part_draw_dsc;\n    lv_obj_draw_dsc_init(&part_draw_dsc, clip_area);\n    part_draw_dsc.rect_dsc = &indic_dsc;\n    part_draw_dsc.class_p = MY_CLASS;\n    part_draw_dsc.type = LV_CHECKBOX_DRAW_PART_BOX;\n    part_draw_dsc.draw_area = &marker_area_transf;\n    part_draw_dsc.part = LV_PART_INDICATOR;\n\n    lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n    lv_draw_rect(&marker_area_transf, clip_area, &indic_dsc);\n    lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n\n    lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);\n    lv_coord_t letter_space = lv_obj_get_style_text_letter_space(obj, LV_PART_MAIN);\n\n    lv_point_t txt_size;\n    lv_txt_get_size(&txt_size, cb->txt, font, letter_space, line_space, LV_COORD_MAX, LV_TEXT_FLAG_NONE);\n\n    lv_draw_label_dsc_t txt_dsc;\n    lv_draw_label_dsc_init(&txt_dsc);\n    lv_obj_init_draw_label_dsc(obj, LV_PART_MAIN, &txt_dsc);\n\n    lv_coord_t y_ofs = (lv_area_get_height(&marker_area) - font_h) / 2;\n    lv_area_t txt_area;\n    txt_area.x1 = marker_area.x2 + bg_colp;\n    txt_area.x2 = txt_area.x1 + txt_size.x;\n    txt_area.y1 = obj->coords.y1 + bg_topp + y_ofs;\n    txt_area.y2 = txt_area.y1 + txt_size.y;\n\n    lv_draw_label(&txt_area, clip_area, &txt_dsc, cb->txt, NULL);\n}"}, "lv_checkbox_class": {"type": "Variable", "def": "const lv_obj_class_t lv_checkbox_class = {\n    .constructor_cb = lv_checkbox_constructor,\n    .destructor_cb = lv_checkbox_destructor,\n    .event_cb = lv_checkbox_event,\n    .width_def = LV_SIZE_CONTENT,\n    .height_def = LV_SIZE_CONTENT,\n    .group_def = LV_OBJ_CLASS_GROUP_DEF_TRUE,\n    .instance_size = sizeof(lv_checkbox_t),\n    .base_class = &lv_obj_class\n}", "sline": 37}, "lv_checkbox_create": {"type": "Function", "def": "lv_obj_t * lv_checkbox_create(lv_obj_t * parent)", "sline": 56, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_checkbox_set_text": {"type": "Function", "def": "void lv_checkbox_set_text(lv_obj_t * obj, const char * txt)", "sline": 68, "body": "{\n    lv_checkbox_t * cb = (lv_checkbox_t *)obj;\n#if LV_USE_ARABIC_PERSIAN_CHARS\n    size_t len = _lv_txt_ap_calc_bytes_cnt(txt);\n#else\n    size_t len = strlen(txt);\n#endif\n\n    if(!cb->static_txt) cb->txt = lv_mem_realloc(cb->txt, len + 1);\n    else  cb->txt = lv_mem_alloc(len + 1);\n#if LV_USE_ARABIC_PERSIAN_CHARS\n    _lv_txt_ap_proc(txt, cb->txt);\n#else\n    strcpy(cb->txt, txt);\n#endif\n\n    cb->static_txt = 0;\n\n    lv_obj_refresh_self_size(obj);\n    lv_obj_invalidate(obj);\n}"}, "lv_checkbox_set_text_static": {"type": "Function", "def": "void lv_checkbox_set_text_static(lv_obj_t * obj, const char * txt)", "sline": 91, "body": "{\n    lv_checkbox_t * cb = (lv_checkbox_t *)obj;\n\n    if(!cb->static_txt) lv_mem_free(cb->txt);\n\n    cb->txt = (char *)txt;\n    cb->static_txt = 1;\n\n    lv_obj_refresh_self_size(obj);\n    lv_obj_invalidate(obj);\n}"}, "lv_checkbox_get_text": {"type": "Function", "def": "const char * lv_checkbox_get_text(const lv_obj_t * obj)", "sline": 108, "body": "{\n    lv_checkbox_t * cb = (lv_checkbox_t *)obj;\n    return cb->txt;\n}"}, "carbit_updater/lvgl/src/widgets/lv_checkbox.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_checkbox.c"}}, "carbit_updater/lvgl/src/draw/lv_img_decoder.c": {"lv_img_decoder": {"type": "Variable", "def": "#include lv_img_decoder.h", "sline": 9, "include": ["carbit_updater/lvgl/src/draw/lv_img_decoder.h", null]}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 10}, "lv_draw_img": {"type": "Variable", "def": "#include ../draw/lv_draw_img.h", "sline": 11}, "lv_ll": {"type": "Variable", "def": "#include ../misc/lv_ll.h", "sline": 12}, "lv_gc": {"type": "Variable", "def": "#include ../misc/lv_gc.h", "sline": 13}, "lv_img_decoder_built_in_data_t.f": {"type": "Variable", "def": "lv_fs_file_t f", "sline": 26, "in_struct": "lv_img_decoder_built_in_data_t"}, "lv_img_decoder_built_in_data_t.palette": {"type": "Variable", "def": "lv_color_t * palette", "sline": 27, "in_struct": "lv_img_decoder_built_in_data_t"}, "lv_img_decoder_built_in_data_t.opa": {"type": "Variable", "def": "lv_opa_t * opa", "sline": 28, "in_struct": "lv_img_decoder_built_in_data_t"}, "lv_img_decoder_built_in_data_t": {"type": "Variable", "def": "typedef struct {\n    lv_fs_file_t f;\n    lv_color_t * palette;\n    lv_opa_t * opa;\n} lv_img_decoder_built_in_data_t", "sline": 29}, "lv_img_decoder_built_in_line_true_color": {"type": "Function", "def": "static lv_res_t lv_img_decoder_built_in_line_true_color(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y,\n                                                        lv_coord_t len, uint8_t * buf)", "sline": 511, "body": "{\n    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;\n    lv_fs_res_t res;\n    uint8_t px_size = lv_img_cf_get_px_size(dsc->header.cf);\n\n    uint32_t pos = ((y * dsc->header.w + x) * px_size) >> 3;\n    pos += 4; /*Skip the header*/\n    res = lv_fs_seek(&user_data->f, pos, LV_FS_SEEK_SET);\n    if(res != LV_FS_RES_OK) {\n        LV_LOG_WARN(\"Built-in image decoder seek failed\");\n        return LV_RES_INV;\n    }\n    uint32_t btr = len * (px_size >> 3);\n    uint32_t br  = 0;\n    res = lv_fs_read(&user_data->f, buf, btr, &br);\n    if(res != LV_FS_RES_OK || btr != br) {\n        LV_LOG_WARN(\"Built-in image decoder read failed\");\n        return LV_RES_INV;\n    }\n\n    return LV_RES_OK;\n}"}, "lv_img_decoder_built_in_line_alpha": {"type": "Function", "def": "static lv_res_t lv_img_decoder_built_in_line_alpha(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y,\n                                                   lv_coord_t len, uint8_t * buf)", "sline": 536, "body": "{\n    const lv_opa_t alpha1_opa_table[2]  = {0, 255};          /*Opacity mapping with bpp = 1 (Just for compatibility)*/\n    const lv_opa_t alpha2_opa_table[4]  = {0, 85, 170, 255}; /*Opacity mapping with bpp = 2*/\n    const lv_opa_t alpha4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/\n                                           68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255\n                                          };\n\n    /*Simply fill the buffer with the color. Later only the alpha value will be modified.*/\n    lv_color_t bg_color = dsc->color;\n    lv_coord_t i;\n    for(i = 0; i < len; i++) {\n#if LV_COLOR_DEPTH == 8 || LV_COLOR_DEPTH == 1\n        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE] = bg_color.full;\n#elif LV_COLOR_DEPTH == 16\n        /*Because of Alpha byte 16 bit color can start on odd address which can cause crash*/\n        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE] = bg_color.full & 0xFF;\n        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + 1] = (bg_color.full >> 8) & 0xFF;\n#elif LV_COLOR_DEPTH == 32\n        *((uint32_t *)&buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE]) = bg_color.full;\n#else\n#error \"Invalid LV_COLOR_DEPTH. Check it in lv_conf.h\"\n#endif\n    }\n\n    const lv_opa_t * opa_table = NULL;\n    uint8_t px_size            = lv_img_cf_get_px_size(dsc->header.cf);\n    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/\n\n    lv_coord_t w = 0;\n    uint32_t ofs = 0;\n    int8_t pos   = 0;\n    switch(dsc->header.cf) {\n        case LV_IMG_CF_ALPHA_1BIT:\n            w = (dsc->header.w + 7) >> 3; /*E.g. w = 20 -> w = 2 + 1*/\n            ofs += w * y + (x >> 3); /*First pixel*/\n            pos = 7 - (x & 0x7);\n            opa_table = alpha1_opa_table;\n            break;\n        case LV_IMG_CF_ALPHA_2BIT:\n            w = (dsc->header.w + 3) >> 2; /*E.g. w = 13 -> w = 3 + 1 (bytes)*/\n            ofs += w * y + (x >> 2); /*First pixel*/\n            pos = 6 - (x & 0x3) * 2;\n            opa_table = alpha2_opa_table;\n            break;\n        case LV_IMG_CF_ALPHA_4BIT:\n            w = (dsc->header.w + 1) >> 1; /*E.g. w = 13 -> w = 6 + 1 (bytes)*/\n            ofs += w * y + (x >> 1); /*First pixel*/\n            pos = 4 - (x & 0x1) * 4;\n            opa_table = alpha4_opa_table;\n            break;\n        case LV_IMG_CF_ALPHA_8BIT:\n            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/\n            ofs += w * y + x;  /*First pixel*/\n            pos = 0;\n            break;\n    }\n\n    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;\n    uint8_t * fs_buf = lv_mem_buf_get(w);\n    if(fs_buf == NULL) return LV_RES_INV;\n\n    const uint8_t * data_tmp = NULL;\n    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {\n        const lv_img_dsc_t * img_dsc = dsc->src;\n\n        data_tmp = img_dsc->data + ofs;\n    }\n    else {\n        lv_fs_seek(&user_data->f, ofs + 4, LV_FS_SEEK_SET); /*+4 to skip the header*/\n        lv_fs_read(&user_data->f, fs_buf, w, NULL);\n        data_tmp = fs_buf;\n    }\n\n    for(i = 0; i < len; i++) {\n        uint8_t val_act = (*data_tmp >> pos) & mask;\n\n        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =\n            dsc->header.cf == LV_IMG_CF_ALPHA_8BIT ? val_act : opa_table[val_act];\n\n        pos -= px_size;\n        if(pos < 0) {\n            pos = 8 - px_size;\n            data_tmp++;\n        }\n    }\n    lv_mem_buf_release(fs_buf);\n    return LV_RES_OK;\n}"}, "lv_img_decoder_built_in_line_indexed": {"type": "Function", "def": "static lv_res_t lv_img_decoder_built_in_line_indexed(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y,\n                                                     lv_coord_t len, uint8_t * buf)", "sline": 627, "body": "{\n    uint8_t px_size = lv_img_cf_get_px_size(dsc->header.cf);\n    uint16_t mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/\n\n    lv_coord_t w = 0;\n    int8_t pos   = 0;\n    uint32_t ofs = 0;\n    switch(dsc->header.cf) {\n        case LV_IMG_CF_INDEXED_1BIT:\n            w = (dsc->header.w + 7) >> 3; /*E.g. w = 20 -> w = 2 + 1*/\n            ofs += w * y + (x >> 3); /*First pixel*/\n            ofs += 8;                /*Skip the palette*/\n            pos = 7 - (x & 0x7);\n            break;\n        case LV_IMG_CF_INDEXED_2BIT:\n            w = (dsc->header.w + 3) >> 2; /*E.g. w = 13 -> w = 3 + 1 (bytes)*/\n            ofs += w * y + (x >> 2); /*First pixel*/\n            ofs += 16;               /*Skip the palette*/\n            pos = 6 - (x & 0x3) * 2;\n            break;\n        case LV_IMG_CF_INDEXED_4BIT:\n            w = (dsc->header.w + 1) >> 1; /*E.g. w = 13 -> w = 6 + 1 (bytes)*/\n            ofs += w * y + (x >> 1); /*First pixel*/\n            ofs += 64;               /*Skip the palette*/\n            pos = 4 - (x & 0x1) * 4;\n            break;\n        case LV_IMG_CF_INDEXED_8BIT:\n            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/\n            ofs += w * y + x;  /*First pixel*/\n            ofs += 1024;       /*Skip the palette*/\n            pos = 0;\n            break;\n    }\n\n    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;\n\n    uint8_t * fs_buf = lv_mem_buf_get(w);\n    if(fs_buf == NULL) return LV_RES_INV;\n    const uint8_t * data_tmp = NULL;\n    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {\n        const lv_img_dsc_t * img_dsc = dsc->src;\n        data_tmp                     = img_dsc->data + ofs;\n    }\n    else {\n        lv_fs_seek(&user_data->f, ofs + 4, LV_FS_SEEK_SET); /*+4 to skip the header*/\n        lv_fs_read(&user_data->f, fs_buf, w, NULL);\n        data_tmp = fs_buf;\n    }\n\n    lv_coord_t i;\n    for(i = 0; i < len; i++) {\n        uint8_t val_act = (*data_tmp >> pos) & mask;\n\n        lv_color_t color = user_data->palette[val_act];\n#if LV_COLOR_DEPTH == 8 || LV_COLOR_DEPTH == 1\n        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE] = color.full;\n#elif LV_COLOR_DEPTH == 16\n        /*Because of Alpha byte 16 bit color can start on odd address which can cause crash*/\n        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE] = color.full & 0xFF;\n        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + 1] = (color.full >> 8) & 0xFF;\n#elif LV_COLOR_DEPTH == 32\n        *((uint32_t *)&buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE]) = color.full;\n#else\n#error \"Invalid LV_COLOR_DEPTH. Check it in lv_conf.h\"\n#endif\n        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] = user_data->opa[val_act];\n\n        pos -= px_size;\n        if(pos < 0) {\n            pos = 8 - px_size;\n            data_tmp++;\n        }\n    }\n    lv_mem_buf_release(fs_buf);\n    return LV_RES_OK;\n}"}, "_lv_img_decoder_init": {"type": "Function", "def": "void _lv_img_decoder_init(void)", "sline": 56, "docstring": "/**", "body": "{\n    _lv_ll_init(&LV_GC_ROOT(_lv_img_decoder_ll), sizeof(lv_img_decoder_t));\n\n    lv_img_decoder_t * decoder;\n\n    /*Create a decoder for the built in color format*/\n    decoder = lv_img_decoder_create();\n    LV_ASSERT_MALLOC(decoder);\n    if(decoder == NULL) {\n        LV_LOG_WARN(\"lv_img_decoder_init: out of memory\");\n        return;\n    }\n\n    lv_img_decoder_set_info_cb(decoder, lv_img_decoder_built_in_info);\n    lv_img_decoder_set_open_cb(decoder, lv_img_decoder_built_in_open);\n    lv_img_decoder_set_read_line_cb(decoder, lv_img_decoder_built_in_read_line);\n    lv_img_decoder_set_close_cb(decoder, lv_img_decoder_built_in_close);\n}"}, "lv_img_decoder_get_info": {"type": "Function", "def": "lv_res_t lv_img_decoder_get_info(const void * src, lv_img_header_t * header)", "sline": 83, "body": "{\n    lv_memset_00(header, sizeof(lv_img_header_t));\n\n    if(src == NULL) return LV_RES_INV;\n\n    lv_img_src_t src_type = lv_img_src_get_type(src);\n    if(src_type == LV_IMG_SRC_VARIABLE) {\n        const lv_img_dsc_t * img_dsc = src;\n        if(img_dsc->data == NULL) return LV_RES_INV;\n    }\n\n    lv_res_t res = LV_RES_INV;\n    lv_img_decoder_t * d;\n    _LV_LL_READ(&LV_GC_ROOT(_lv_img_decoder_ll), d) {\n        if(d->info_cb) {\n            res = d->info_cb(d, src, header);\n            if(res == LV_RES_OK) break;\n        }\n    }\n\n    return res;\n}"}, "lv_img_decoder_open": {"type": "Function", "def": "lv_res_t lv_img_decoder_open(lv_img_decoder_dsc_t * dsc, const void * src, lv_color_t color, int32_t frame_id)", "sline": 107, "body": "{\n    lv_memset_00(dsc, sizeof(lv_img_decoder_dsc_t));\n\n    if(src == NULL) return LV_RES_INV;\n    lv_img_src_t src_type = lv_img_src_get_type(src);\n    if(src_type == LV_IMG_SRC_VARIABLE) {\n        const lv_img_dsc_t * img_dsc = src;\n        if(img_dsc->data == NULL) return LV_RES_INV;\n    }\n\n    dsc->color    = color;\n    dsc->src_type = src_type;\n    dsc->frame_id = frame_id;\n\n    if(dsc->src_type == LV_IMG_SRC_FILE) {\n        size_t fnlen = strlen(src);\n        dsc->src = lv_mem_alloc(fnlen + 1);\n        LV_ASSERT_MALLOC(dsc->src);\n        if(dsc->src == NULL) {\n            LV_LOG_WARN(\"lv_img_decoder_open: out of memory\");\n            return LV_RES_INV;\n        }\n        strcpy((char *)dsc->src, src);\n    }\n    else {\n        dsc->src = src;\n    }\n\n    lv_res_t res = LV_RES_INV;\n\n    lv_img_decoder_t * decoder;\n    _LV_LL_READ(&LV_GC_ROOT(_lv_img_decoder_ll), decoder) {\n        /*Info and Open callbacks are required*/\n        if(decoder->info_cb == NULL || decoder->open_cb == NULL) continue;\n\n        res = decoder->info_cb(decoder, src, &dsc->header);\n        if(res != LV_RES_OK) continue;\n\n        dsc->decoder = decoder;\n        res = decoder->open_cb(decoder, dsc);\n\n        /*Opened successfully. It is a good decoder to for this image source*/\n        if(res == LV_RES_OK) return res;\n\n        /*Prepare for the next loop*/\n        lv_memset_00(&dsc->header, sizeof(lv_img_header_t));\n\n        dsc->error_msg = NULL;\n        dsc->img_data  = NULL;\n        dsc->user_data = NULL;\n        dsc->time_to_open = 0;\n    }\n\n    if(dsc->src_type == LV_IMG_SRC_FILE)\n        lv_mem_free((void *)dsc->src);\n\n    return res;\n}"}, "lv_img_decoder_read_line": {"type": "Function", "def": "lv_res_t lv_img_decoder_read_line(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y, lv_coord_t len, uint8_t * buf)", "sline": 176, "body": "{\n    lv_res_t res = LV_RES_INV;\n    if(dsc->decoder->read_line_cb) res = dsc->decoder->read_line_cb(dsc->decoder, dsc, x, y, len, buf);\n\n    return res;\n}"}, "lv_img_decoder_close": {"type": "Function", "def": "void lv_img_decoder_close(lv_img_decoder_dsc_t * dsc)", "sline": 188, "body": "{\n    if(dsc->decoder) {\n        if(dsc->decoder->close_cb) dsc->decoder->close_cb(dsc->decoder, dsc);\n\n        if(dsc->src_type == LV_IMG_SRC_FILE) {\n            lv_mem_free((void *)dsc->src);\n            dsc->src = NULL;\n        }\n    }\n}"}, "lv_img_decoder_create": {"type": "Function", "def": "lv_img_decoder_t * lv_img_decoder_create(void)", "sline": 204, "body": "{\n    lv_img_decoder_t * decoder;\n    decoder = _lv_ll_ins_head(&LV_GC_ROOT(_lv_img_decoder_ll));\n    LV_ASSERT_MALLOC(decoder);\n    if(decoder == NULL) return NULL;\n\n    lv_memset_00(decoder, sizeof(lv_img_decoder_t));\n\n    return decoder;\n}"}, "lv_img_decoder_delete": {"type": "Function", "def": "void lv_img_decoder_delete(lv_img_decoder_t * decoder)", "sline": 220, "body": "{\n    _lv_ll_remove(&LV_GC_ROOT(_lv_img_decoder_ll), decoder);\n    lv_mem_free(decoder);\n}"}, "lv_img_decoder_set_info_cb": {"type": "Function", "def": "void lv_img_decoder_set_info_cb(lv_img_decoder_t * decoder, lv_img_decoder_info_f_t info_cb)", "sline": 231, "body": "{\n    decoder->info_cb = info_cb;\n}"}, "lv_img_decoder_set_open_cb": {"type": "Function", "def": "void lv_img_decoder_set_open_cb(lv_img_decoder_t * decoder, lv_img_decoder_open_f_t open_cb)", "sline": 241, "body": "{\n    decoder->open_cb = open_cb;\n}"}, "lv_img_decoder_set_read_line_cb": {"type": "Function", "def": "void lv_img_decoder_set_read_line_cb(lv_img_decoder_t * decoder, lv_img_decoder_read_line_f_t read_line_cb)", "sline": 251, "body": "{\n    decoder->read_line_cb = read_line_cb;\n}"}, "lv_img_decoder_set_close_cb": {"type": "Function", "def": "void lv_img_decoder_set_close_cb(lv_img_decoder_t * decoder, lv_img_decoder_close_f_t close_cb)", "sline": 261, "body": "{\n    decoder->close_cb = close_cb;\n}"}, "lv_img_decoder_built_in_info": {"type": "Function", "def": "lv_res_t lv_img_decoder_built_in_info(lv_img_decoder_t * decoder, const void * src, lv_img_header_t * header)", "sline": 273, "body": "{\n    LV_UNUSED(decoder); /*Unused*/\n\n    lv_img_src_t src_type = lv_img_src_get_type(src);\n    if(src_type == LV_IMG_SRC_VARIABLE) {\n        lv_img_cf_t cf = ((lv_img_dsc_t *)src)->header.cf;\n        if(cf < CF_BUILT_IN_FIRST || cf > CF_BUILT_IN_LAST) return LV_RES_INV;\n\n        header->w  = ((lv_img_dsc_t *)src)->header.w;\n        header->h  = ((lv_img_dsc_t *)src)->header.h;\n        header->cf = ((lv_img_dsc_t *)src)->header.cf;\n    }\n    else if(src_type == LV_IMG_SRC_FILE) {\n        /*Support only \"*.bin\" files*/\n        if(strcmp(lv_fs_get_ext(src), \"bin\")) return LV_RES_INV;\n\n        lv_fs_file_t f;\n        lv_fs_res_t res = lv_fs_open(&f, src, LV_FS_MODE_RD);\n        if(res == LV_FS_RES_OK) {\n            uint32_t rn;\n            res = lv_fs_read(&f, header, sizeof(lv_img_header_t), &rn);\n            lv_fs_close(&f);\n            if(res != LV_FS_RES_OK || rn != sizeof(lv_img_header_t)) {\n                LV_LOG_WARN(\"Image get info get read file header\");\n                return LV_RES_INV;\n            }\n        }\n\n        if(header->cf < CF_BUILT_IN_FIRST || header->cf > CF_BUILT_IN_LAST) return LV_RES_INV;\n    }\n    else if(src_type == LV_IMG_SRC_SYMBOL) {\n        /*The size depend on the font but it is unknown here. It should be handled outside of the\n         *function*/\n        header->w = 1;\n        header->h = 1;\n        /*Symbols always have transparent parts. Important because of cover check in the draw\n         *function. The actual value doesn't matter because lv_draw_label will draw it*/\n        header->cf = LV_IMG_CF_ALPHA_1BIT;\n    }\n    else {\n        LV_LOG_WARN(\"Image get info found unknown src type\");\n        return LV_RES_INV;\n    }\n    return LV_RES_OK;\n}"}, "lv_img_decoder_built_in_open": {"type": "Function", "def": "lv_res_t lv_img_decoder_built_in_open(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc)", "sline": 326, "body": "{\n    /*Open the file if it's a file*/\n    if(dsc->src_type == LV_IMG_SRC_FILE) {\n        /*Support only \"*.bin\" files*/\n        if(strcmp(lv_fs_get_ext(dsc->src), \"bin\")) return LV_RES_INV;\n\n        lv_fs_file_t f;\n        lv_fs_res_t res = lv_fs_open(&f, dsc->src, LV_FS_MODE_RD);\n        if(res != LV_FS_RES_OK) {\n            LV_LOG_WARN(\"Built-in image decoder can't open the file\");\n            return LV_RES_INV;\n        }\n\n        /*If the file was open successfully save the file descriptor*/\n        if(dsc->user_data == NULL) {\n            dsc->user_data = lv_mem_alloc(sizeof(lv_img_decoder_built_in_data_t));\n            LV_ASSERT_MALLOC(dsc->user_data);\n            if(dsc->user_data == NULL) {\n                LV_LOG_ERROR(\"img_decoder_built_in_open: out of memory\");\n                lv_fs_close(&f);\n                return LV_RES_INV;\n            }\n            lv_memset_00(dsc->user_data, sizeof(lv_img_decoder_built_in_data_t));\n        }\n\n        lv_img_decoder_built_in_data_t * user_data = dsc->user_data;\n        lv_memcpy_small(&user_data->f, &f, sizeof(f));\n    }\n    else if(dsc->src_type == LV_IMG_SRC_VARIABLE) {\n        /*The variables should have valid data*/\n        if(((lv_img_dsc_t *)dsc->src)->data == NULL) {\n            return LV_RES_INV;\n        }\n    }\n\n    lv_img_cf_t cf = dsc->header.cf;\n    /*Process true color formats*/\n    if(cf == LV_IMG_CF_TRUE_COLOR || cf == LV_IMG_CF_TRUE_COLOR_ALPHA || cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {\n        if(dsc->src_type == LV_IMG_SRC_VARIABLE) {\n            /*In case of uncompressed formats the image stored in the ROM/RAM.\n             *So simply give its pointer*/\n            dsc->img_data = ((lv_img_dsc_t *)dsc->src)->data;\n            return LV_RES_OK;\n        }\n        else {\n            /*If it's a file it need to be read line by line later*/\n            return LV_RES_OK;\n        }\n    }\n    /*Process indexed images. Build a palette*/\n    else if(cf == LV_IMG_CF_INDEXED_1BIT || cf == LV_IMG_CF_INDEXED_2BIT || cf == LV_IMG_CF_INDEXED_4BIT ||\n            cf == LV_IMG_CF_INDEXED_8BIT) {\n        uint8_t px_size       = lv_img_cf_get_px_size(cf);\n        uint32_t palette_size = 1 << px_size;\n\n        /*Allocate the palette*/\n        if(dsc->user_data == NULL) {\n            dsc->user_data = lv_mem_alloc(sizeof(lv_img_decoder_built_in_data_t));\n            LV_ASSERT_MALLOC(dsc->user_data);\n            if(dsc->user_data == NULL) {\n                LV_LOG_ERROR(\"img_decoder_built_in_open: out of memory\");\n                return LV_RES_INV;\n            }\n            lv_memset_00(dsc->user_data, sizeof(lv_img_decoder_built_in_data_t));\n        }\n\n        lv_img_decoder_built_in_data_t * user_data = dsc->user_data;\n        user_data->palette                         = lv_mem_alloc(palette_size * sizeof(lv_color_t));\n        LV_ASSERT_MALLOC(user_data->palette);\n        user_data->opa                             = lv_mem_alloc(palette_size * sizeof(lv_opa_t));\n        LV_ASSERT_MALLOC(user_data->opa);\n        if(user_data->palette == NULL || user_data->opa == NULL) {\n            LV_LOG_ERROR(\"img_decoder_built_in_open: out of memory\");\n            lv_img_decoder_built_in_close(decoder, dsc);\n            return LV_RES_INV;\n        }\n\n        if(dsc->src_type == LV_IMG_SRC_FILE) {\n            /*Read the palette from file*/\n            lv_fs_seek(&user_data->f, 4, LV_FS_SEEK_SET); /*Skip the header*/\n            lv_color32_t cur_color;\n            uint32_t i;\n            for(i = 0; i < palette_size; i++) {\n                lv_fs_read(&user_data->f, &cur_color, sizeof(lv_color32_t), NULL);\n                user_data->palette[i] = lv_color_make(cur_color.ch.red, cur_color.ch.green, cur_color.ch.blue);\n                user_data->opa[i]     = cur_color.ch.alpha;\n            }\n        }\n        else {\n            /*The palette begins in the beginning of the image data. Just point to it.*/\n            lv_color32_t * palette_p = (lv_color32_t *)((lv_img_dsc_t *)dsc->src)->data;\n\n            uint32_t i;\n            for(i = 0; i < palette_size; i++) {\n                user_data->palette[i] = lv_color_make(palette_p[i].ch.red, palette_p[i].ch.green, palette_p[i].ch.blue);\n                user_data->opa[i]     = palette_p[i].ch.alpha;\n            }\n        }\n\n        return LV_RES_OK;\n    }\n    /*Alpha indexed images.*/\n    else if(cf == LV_IMG_CF_ALPHA_1BIT || cf == LV_IMG_CF_ALPHA_2BIT || cf == LV_IMG_CF_ALPHA_4BIT ||\n            cf == LV_IMG_CF_ALPHA_8BIT) {\n        return LV_RES_OK; /*Nothing to process*/\n    }\n    /*Unknown format. Can't decode it.*/\n    else {\n        /*Free the potentially allocated memories*/\n        lv_img_decoder_built_in_close(decoder, dsc);\n\n        LV_LOG_WARN(\"Image decoder open: unknown color format\");\n        return LV_RES_INV;\n    }\n}"}, "lv_img_decoder_built_in_read_line": {"type": "Function", "def": "lv_res_t lv_img_decoder_built_in_read_line(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc, lv_coord_t x,\n                                           lv_coord_t y, lv_coord_t len, uint8_t * buf)", "sline": 454, "body": "{\n    LV_UNUSED(decoder); /*Unused*/\n\n    lv_res_t res = LV_RES_INV;\n\n    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||\n       dsc->header.cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {\n        /*For TRUE_COLOR images read line required only for files.\n         *For variables the image data was returned in `open`*/\n        if(dsc->src_type == LV_IMG_SRC_FILE) {\n            res = lv_img_decoder_built_in_line_true_color(dsc, x, y, len, buf);\n        }\n    }\n    else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT || dsc->header.cf == LV_IMG_CF_ALPHA_2BIT ||\n            dsc->header.cf == LV_IMG_CF_ALPHA_4BIT || dsc->header.cf == LV_IMG_CF_ALPHA_8BIT) {\n        res = lv_img_decoder_built_in_line_alpha(dsc, x, y, len, buf);\n    }\n    else if(dsc->header.cf == LV_IMG_CF_INDEXED_1BIT || dsc->header.cf == LV_IMG_CF_INDEXED_2BIT ||\n            dsc->header.cf == LV_IMG_CF_INDEXED_4BIT || dsc->header.cf == LV_IMG_CF_INDEXED_8BIT) {\n        res = lv_img_decoder_built_in_line_indexed(dsc, x, y, len, buf);\n    }\n    else {\n        LV_LOG_WARN(\"Built-in image decoder read not supports the color format\");\n        return LV_RES_INV;\n    }\n\n    return res;\n}"}, "lv_img_decoder_built_in_close": {"type": "Function", "def": "void lv_img_decoder_built_in_close(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc)", "sline": 490, "body": "{\n    LV_UNUSED(decoder); /*Unused*/\n\n    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;\n    if(user_data) {\n        if(dsc->src_type == LV_IMG_SRC_FILE) {\n            lv_fs_close(&user_data->f);\n        }\n        if(user_data->palette) lv_mem_free(user_data->palette);\n        if(user_data->opa) lv_mem_free(user_data->opa);\n\n        lv_mem_free(user_data);\n        dsc->user_data = NULL;\n    }\n}"}, "carbit_updater/lvgl/src/draw/lv_img_decoder.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_img_decoder.c"}}, "carbit_updater/lvgl/tests/src/lv_test_indev.h": {"stdio": {"type": "Variable", "def": "#include stdio.h", "sline": 9}, "lvgl": {"type": "Variable", "def": "#include ../lvgl.h", "sline": 10}, "lv_test_mouse_read_cb": {"type": "Function", "def": "void lv_test_mouse_read_cb(lv_indev_drv_t * drv, lv_indev_data_t * data)", "sline": 12}, "lv_test_mouse_move_to": {"type": "Function", "def": "void lv_test_mouse_move_to(lv_coord_t x, lv_coord_t y)", "sline": 14}, "lv_test_mouse_move_by": {"type": "Function", "def": "void lv_test_mouse_move_by(lv_coord_t x, lv_coord_t y)", "sline": 15}, "lv_test_mouse_press": {"type": "Function", "def": "void lv_test_mouse_press(void)", "sline": 16}, "lv_test_mouse_release": {"type": "Function", "def": "void lv_test_mouse_release(void)", "sline": 17}, "lv_test_mouse_click_at": {"type": "Function", "def": "void lv_test_mouse_click_at(lv_coord_t x, lv_coord_t y)", "sline": 18}, "lv_test_keypad_read_cb": {"type": "Function", "def": "void lv_test_keypad_read_cb(lv_indev_drv_t * drv, lv_indev_data_t * data)", "sline": 20}, "lv_test_key_press": {"type": "Function", "def": "void lv_test_key_press(uint32_t k)", "sline": 22}, "lv_test_key_release": {"type": "Function", "def": "void lv_test_key_release(void)", "sline": 23}, "lv_test_key_hit": {"type": "Function", "def": "void lv_test_key_hit(uint32_t k)", "sline": 24}, "lv_test_encoder_read_cb": {"type": "Function", "def": "void lv_test_encoder_read_cb(lv_indev_drv_t * drv, lv_indev_data_t * data)", "sline": 27}, "lv_test_encoder_add_diff": {"type": "Function", "def": "void lv_test_encoder_add_diff(int32_t d)", "sline": 29}, "lv_test_encoder_turn": {"type": "Function", "def": "void lv_test_encoder_turn(int32_t d)", "sline": 30}, "lv_test_encoder_press": {"type": "Function", "def": "void lv_test_encoder_press(void)", "sline": 31}, "lv_test_encoder_release": {"type": "Function", "def": "void lv_test_encoder_release(void)", "sline": 32}, "lv_test_encoder_click": {"type": "Function", "def": "void lv_test_encoder_click(void)", "sline": 33}, "lv_test_indev_wait": {"type": "Function", "def": "void lv_test_indev_wait(uint32_t ms)", "sline": 35}, "lv_test_mouse_indev": {"type": "Variable", "def": "extern lv_indev_t * lv_test_mouse_indev", "sline": 37}, "lv_test_keypad_indev": {"type": "Variable", "def": "extern lv_indev_t * lv_test_keypad_indev", "sline": 38}, "lv_test_encoder_indev": {"type": "Variable", "def": "extern lv_indev_t * lv_test_encoder_indev", "sline": 39}, "carbit_updater/lvgl/tests/src/lv_test_indev.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/tests/src/lv_test_indev.h"}}, "carbit_updater/lvgl/src/core/lv_indev_scroll.c": {"lv_indev": {"type": "Variable", "def": "#include lv_indev.h", "sline": 9, "include": ["carbit_updater/lvgl/src/core/lv_indev.h", null]}, "lv_indev_scroll": {"type": "Variable", "def": "#include lv_indev_scroll.h", "sline": 10, "include": ["carbit_updater/lvgl/src/core/lv_indev_scroll.h", null]}, "find_scroll_obj": {"type": "Function", "def": "static lv_obj_t * find_scroll_obj(_lv_indev_proc_t * proc)", "sline": 242, "body": "{\n    lv_obj_t * obj_candidate = NULL;\n    lv_dir_t dir_candidate = LV_DIR_NONE;\n    lv_indev_t * indev_act = lv_indev_get_act();\n    lv_coord_t scroll_limit =  indev_act->driver->scroll_limit;\n\n    /*Go until find a scrollable object in the current direction\n     *More precisely:\n     * 1. Check the pressed object and all of its ancestors and try to find an object which is scrollable\n     * 2. Scrollable means it has some content out of its area\n     * 3. If an object can be scrolled into the current direction then use it (\"real match\"\")\n     * 4. If can be scrolled on the current axis (hor/ver) save it as candidate (at least show an elastic scroll effect)\n     * 5. Use the last candidate. Always the \"deepest\" parent or the object from point 3*/\n    lv_obj_t * obj_act = proc->types.pointer.act_obj;\n    while(obj_act) {\n        if(lv_obj_has_flag(obj_act, LV_OBJ_FLAG_SCROLLABLE) == false) {\n            /*If this object don't want to chain the scroll ot the parent stop searching*/\n            if(lv_obj_has_flag(obj_act, LV_OBJ_FLAG_SCROLL_CHAIN) == false) break;\n            obj_act = lv_obj_get_parent(obj_act);\n            continue;\n        }\n\n        /*Decide if it's a horizontal or vertical scroll*/\n        bool hor_en = false;\n        bool ver_en = false;\n        if(LV_ABS(proc->types.pointer.scroll_sum.x) > LV_ABS(proc->types.pointer.scroll_sum.y)) {\n            hor_en = true;\n        }\n        else {\n            ver_en = true;\n        }\n\n        /*Consider both up-down or left/right scrollable according to the current direction*/\n        bool up_en = ver_en;\n        bool down_en = ver_en;\n        bool left_en = hor_en;\n        bool right_en = hor_en;\n\n        /*The object might have disabled some directions.*/\n        lv_dir_t scroll_dir = lv_obj_get_scroll_dir(obj_act);\n        if((scroll_dir & LV_DIR_LEFT) == 0) left_en = false;\n        if((scroll_dir & LV_DIR_RIGHT) == 0) right_en = false;\n        if((scroll_dir & LV_DIR_TOP) == 0) up_en = false;\n        if((scroll_dir & LV_DIR_BOTTOM) == 0) down_en = false;\n\n        /*The object is scrollable to a direction if its content overflow in that direction.*/\n        lv_coord_t st = lv_obj_get_scroll_top(obj_act);\n        lv_coord_t sb = lv_obj_get_scroll_bottom(obj_act);\n        lv_coord_t sl = lv_obj_get_scroll_left(obj_act);\n        lv_coord_t sr = lv_obj_get_scroll_right(obj_act);\n\n        /*If this object is scrollable into the current scroll direction then save it as a candidate.\n         *It's important only to be scrollable on the current axis (hor/ver) because if the scroll\n         *is propagated to this object it can show at least elastic scroll effect.\n         *But if not hor/ver scrollable do not scroll it at all (so it's not a good candidate)*/\n        if((st > 0 || sb > 0)  &&\n           ((up_en    && proc->types.pointer.scroll_sum.y >= scroll_limit) ||\n            (down_en  && proc->types.pointer.scroll_sum.y <= - scroll_limit))) {\n            obj_candidate = obj_act;\n            dir_candidate = LV_DIR_VER;\n        }\n\n        if((sl > 0 || sr > 0)  &&\n           ((left_en    && proc->types.pointer.scroll_sum.x >=  scroll_limit) ||\n            (right_en  && proc->types.pointer.scroll_sum.x <= - scroll_limit))) {\n            obj_candidate = obj_act;\n            dir_candidate = LV_DIR_HOR;\n        }\n\n        if(st <= 0) up_en = false;\n        if(sb <= 0) down_en = false;\n        if(sl <= 0) left_en = false;\n        if(sr <= 0) right_en = false;\n\n        /*If the object really can be scrolled into the current direction the use it.*/\n        if((left_en  && proc->types.pointer.scroll_sum.x >=   scroll_limit) ||\n           (right_en && proc->types.pointer.scroll_sum.x <= - scroll_limit) ||\n           (up_en    && proc->types.pointer.scroll_sum.y >=   scroll_limit) ||\n           (down_en  && proc->types.pointer.scroll_sum.y <= - scroll_limit)) {\n            proc->types.pointer.scroll_dir = hor_en ? LV_DIR_HOR : LV_DIR_VER;\n            break;\n        }\n\n        /*If this object don't want to chain the scroll ot the parent stop searching*/\n        if(lv_obj_has_flag(obj_act, LV_OBJ_FLAG_SCROLL_CHAIN) == false) break;\n\n        /*Try the parent*/\n        obj_act = lv_obj_get_parent(obj_act);\n    }\n\n    /*Use the last candidate*/\n    if(obj_candidate) {\n        proc->types.pointer.scroll_dir = dir_candidate;\n        proc->types.pointer.scroll_obj = obj_candidate;\n        proc->types.pointer.scroll_sum.x = 0;\n        proc->types.pointer.scroll_sum.y = 0;\n    }\n\n    return obj_candidate;\n}"}, "init_scroll_limits": {"type": "Function", "def": "static void init_scroll_limits(_lv_indev_proc_t * proc)", "sline": 344, "body": "{\n    lv_obj_t * obj = proc->types.pointer.scroll_obj;\n    /*If there no STOP allow scrolling anywhere*/\n    if(lv_obj_has_flag(obj, LV_OBJ_FLAG_SCROLL_ONE) == false) {\n        lv_area_set(&proc->types.pointer.scroll_area, LV_COORD_MIN, LV_COORD_MIN, LV_COORD_MAX, LV_COORD_MAX);\n    }\n    /*With STOP limit the scrolling to the perv and next snap point*/\n    else {\n        switch(lv_obj_get_scroll_snap_y(obj)) {\n            case LV_SCROLL_SNAP_START:\n                proc->types.pointer.scroll_area.y1 = find_snap_point_y(obj, obj->coords.y1 + 1, LV_COORD_MAX, 0);\n                proc->types.pointer.scroll_area.y2 = find_snap_point_y(obj, LV_COORD_MIN, obj->coords.y1 - 1, 0);\n                break;\n            case LV_SCROLL_SNAP_END:\n                proc->types.pointer.scroll_area.y1 = find_snap_point_y(obj, obj->coords.y2, LV_COORD_MAX, 0);\n                proc->types.pointer.scroll_area.y2 = find_snap_point_y(obj, LV_COORD_MIN, obj->coords.y2, 0);\n                break;\n            case LV_SCROLL_SNAP_CENTER: {\n                    lv_coord_t y_mid = obj->coords.y1 + lv_area_get_height(&obj->coords) / 2;\n                    proc->types.pointer.scroll_area.y1 = find_snap_point_y(obj, y_mid + 1, LV_COORD_MAX, 0);\n                    proc->types.pointer.scroll_area.y2 = find_snap_point_y(obj, LV_COORD_MIN, y_mid - 1, 0);\n                    break;\n                }\n            default:\n                proc->types.pointer.scroll_area.y1 = LV_COORD_MIN;\n                proc->types.pointer.scroll_area.y2 = LV_COORD_MAX;\n                break;\n        }\n\n        switch(lv_obj_get_scroll_snap_x(obj)) {\n            case LV_SCROLL_SNAP_START:\n                proc->types.pointer.scroll_area.x1 = find_snap_point_x(obj, obj->coords.x1, LV_COORD_MAX, 0);\n                proc->types.pointer.scroll_area.x2 = find_snap_point_x(obj, LV_COORD_MIN, obj->coords.x1, 0);\n                break;\n            case LV_SCROLL_SNAP_END:\n                proc->types.pointer.scroll_area.x1 = find_snap_point_x(obj, obj->coords.x2, LV_COORD_MAX, 0);\n                proc->types.pointer.scroll_area.x2 = find_snap_point_x(obj, LV_COORD_MIN, obj->coords.x2, 0);\n                break;\n            case LV_SCROLL_SNAP_CENTER: {\n                    lv_coord_t x_mid = obj->coords.x1 + lv_area_get_width(&obj->coords) / 2;\n                    proc->types.pointer.scroll_area.x1 = find_snap_point_x(obj, x_mid + 1, LV_COORD_MAX, 0);\n                    proc->types.pointer.scroll_area.x2 = find_snap_point_x(obj, LV_COORD_MIN, x_mid - 1, 0);\n                    break;\n                }\n            default:\n                proc->types.pointer.scroll_area.x1 = LV_COORD_MIN;\n                proc->types.pointer.scroll_area.x2 = LV_COORD_MAX;\n                break;\n        }\n    }\n\n    /*Allow scrolling on the edges. It will be reverted to the edge due to snapping anyway*/\n    if(proc->types.pointer.scroll_area.x1 == 0) proc->types.pointer.scroll_area.x1 = LV_COORD_MIN;\n    if(proc->types.pointer.scroll_area.x2 == 0) proc->types.pointer.scroll_area.x2 = LV_COORD_MAX;\n    if(proc->types.pointer.scroll_area.y1 == 0) proc->types.pointer.scroll_area.y1 = LV_COORD_MIN;\n    if(proc->types.pointer.scroll_area.y2 == 0) proc->types.pointer.scroll_area.y2 = LV_COORD_MAX;\n}"}, "find_snap_point_x": {"type": "Function", "def": "static lv_coord_t find_snap_point_x(const lv_obj_t * obj, lv_coord_t min, lv_coord_t max, lv_coord_t ofs)", "sline": 412, "body": "{\n    lv_scroll_snap_t align = lv_obj_get_scroll_snap_x(obj);\n    if(align == LV_SCROLL_SNAP_NONE) return 0;\n\n    lv_coord_t dist = LV_COORD_MAX;\n\n    lv_coord_t pad_left = lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n    lv_coord_t pad_right = lv_obj_get_style_pad_right(obj, LV_PART_MAIN);\n\n    uint32_t i;\n    uint32_t child_cnt = lv_obj_get_child_cnt(obj);\n    for(i = 0; i < child_cnt; i++) {\n        lv_obj_t * child = obj->spec_attr->children[i];\n        if(lv_obj_has_flag_any(child, LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;\n        if(lv_obj_has_flag(child, LV_OBJ_FLAG_SNAPPABLE)) {\n            lv_coord_t x_child = 0;\n            lv_coord_t x_parent = 0;\n            switch(align) {\n                case LV_SCROLL_SNAP_START:\n                    x_child = child->coords.x1;\n                    x_parent = obj->coords.x1 + pad_left;\n                    break;\n                case LV_SCROLL_SNAP_END:\n                    x_child = child->coords.x2;\n                    x_parent = obj->coords.x2 - pad_right;\n                    break;\n                case LV_SCROLL_SNAP_CENTER:\n                    x_child = child->coords.x1 + lv_area_get_width(&child->coords) / 2;\n                    x_parent = obj->coords.x1 + pad_left + (lv_area_get_width(&obj->coords) - pad_left - pad_right) / 2;\n                    break;\n                default:\n                    continue;\n            }\n\n            x_child += ofs;\n            if(x_child >= min && x_child <= max) {\n                lv_coord_t x = x_child -  x_parent;\n                if(LV_ABS(x) < LV_ABS(dist)) dist = x;\n            }\n        }\n    }\n\n    return dist == LV_COORD_MAX ? 0 : -dist;\n}"}, "find_snap_point_y": {"type": "Function", "def": "static lv_coord_t find_snap_point_y(const lv_obj_t * obj, lv_coord_t min, lv_coord_t max, lv_coord_t ofs)", "sline": 467, "body": "{\n    lv_scroll_snap_t align = lv_obj_get_scroll_snap_y(obj);\n    if(align == LV_SCROLL_SNAP_NONE) return 0;\n\n    lv_coord_t dist = LV_COORD_MAX;\n\n    lv_coord_t pad_top = lv_obj_get_style_pad_top(obj, LV_PART_MAIN);\n    lv_coord_t pad_bottom = lv_obj_get_style_pad_bottom(obj, LV_PART_MAIN);\n\n    uint32_t i;\n    uint32_t child_cnt = lv_obj_get_child_cnt(obj);\n    for(i = 0; i < child_cnt; i++) {\n        lv_obj_t * child = obj->spec_attr->children[i];\n        if(lv_obj_has_flag_any(child, LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;\n        if(lv_obj_has_flag(child, LV_OBJ_FLAG_SNAPPABLE)) {\n            lv_coord_t y_child = 0;\n            lv_coord_t y_parent = 0;\n            switch(align) {\n                case LV_SCROLL_SNAP_START:\n                    y_child = child->coords.y1;\n                    y_parent = obj->coords.y1 + pad_top;\n                    break;\n                case LV_SCROLL_SNAP_END:\n                    y_child = child->coords.y2;\n                    y_parent = obj->coords.y2 - pad_bottom;\n                    break;\n                case LV_SCROLL_SNAP_CENTER:\n                    y_child = child->coords.y1 + lv_area_get_height(&child->coords) / 2;\n                    y_parent = obj->coords.y1 + pad_top + (lv_area_get_height(&obj->coords) - pad_top - pad_bottom) / 2;\n                    break;\n                default:\n                    continue;\n            }\n\n            y_child += ofs;\n            if(y_child >= min && y_child <= max) {\n                lv_coord_t y = y_child -  y_parent;\n                if(LV_ABS(y) < LV_ABS(dist)) dist = y;\n            }\n        }\n    }\n\n    return dist == LV_COORD_MAX ? 0 : -dist;\n}"}, "scroll_limit_diff": {"type": "Function", "def": "static void scroll_limit_diff(_lv_indev_proc_t * proc, lv_coord_t * diff_x, lv_coord_t * diff_y)", "sline": 513, "body": "{\n    if(diff_y) {\n        if(proc->types.pointer.scroll_sum.y + *diff_y < proc->types.pointer.scroll_area.y1) {\n            *diff_y = proc->types.pointer.scroll_area.y1 - proc->types.pointer.scroll_sum.y;\n        }\n\n        if(proc->types.pointer.scroll_sum.y + *diff_y > proc->types.pointer.scroll_area.y2) {\n            *diff_y = proc->types.pointer.scroll_area.y2 - proc->types.pointer.scroll_sum.y;\n        }\n    }\n\n    if(diff_x) {\n        if(proc->types.pointer.scroll_sum.x + *diff_x < proc->types.pointer.scroll_area.x1) {\n            *diff_x = proc->types.pointer.scroll_area.x1 - proc->types.pointer.scroll_sum.x;\n        }\n\n        if(proc->types.pointer.scroll_sum.x + *diff_x > proc->types.pointer.scroll_area.x2) {\n            *diff_x = proc->types.pointer.scroll_area.x2 - proc->types.pointer.scroll_sum.x;\n        }\n    }\n}"}, "scroll_throw_predict_y": {"type": "Function", "def": "static lv_coord_t scroll_throw_predict_y(_lv_indev_proc_t * proc)", "sline": 538, "body": "{\n    lv_coord_t y =  proc->types.pointer.scroll_throw_vect.y;\n    lv_coord_t move = 0;\n\n    lv_indev_t * indev_act = lv_indev_get_act();\n    lv_coord_t scroll_throw =  indev_act->driver->scroll_throw;\n\n    while(y) {\n        move += y;\n        y = y * (100 - scroll_throw) / 100;\n    }\n    return move;\n}"}, "scroll_throw_predict_x": {"type": "Function", "def": "static lv_coord_t scroll_throw_predict_x(_lv_indev_proc_t * proc)", "sline": 554, "body": "{\n    lv_coord_t x =  proc->types.pointer.scroll_throw_vect.x;\n    lv_coord_t move = 0;\n\n    lv_indev_t * indev_act = lv_indev_get_act();\n    lv_coord_t scroll_throw =  indev_act->driver->scroll_throw;\n\n    while(x) {\n        move += x;\n        x = x * (100 - scroll_throw) / 100;\n    }\n    return move;\n}"}, "elastic_diff": {"type": "Function", "def": "static lv_coord_t elastic_diff(lv_obj_t * scroll_obj, lv_coord_t diff, lv_coord_t scroll_start, lv_coord_t scroll_end,\n                               lv_dir_t dir)", "sline": 569, "body": "{\n    if(lv_obj_has_flag(scroll_obj, LV_OBJ_FLAG_SCROLL_ELASTIC)) {\n        /*If there is snapping in the current direction don't use the elastic factor because\n         *it's natural that the first and last items are scrolled (snapped) in.*/\n        lv_scroll_snap_t snap;\n        snap = dir == LV_DIR_HOR ? lv_obj_get_scroll_snap_x(scroll_obj) : lv_obj_get_scroll_snap_y(scroll_obj);\n\n        lv_obj_t * act_obj = lv_indev_get_obj_act();\n        lv_coord_t snap_point = 0;\n        lv_coord_t act_obj_point = 0;\n\n        if(dir == LV_DIR_HOR) {\n            lv_coord_t pad_left = lv_obj_get_style_pad_left(scroll_obj, LV_PART_MAIN);\n            lv_coord_t pad_right = lv_obj_get_style_pad_right(scroll_obj, LV_PART_MAIN);\n\n            switch(snap) {\n                case LV_SCROLL_SNAP_CENTER:\n                    snap_point = pad_left + (lv_area_get_width(&scroll_obj->coords) - pad_left - pad_right) / 2 + scroll_obj->coords.x1;\n                    act_obj_point = lv_area_get_width(&act_obj->coords) / 2 + act_obj->coords.x1;\n                    break;\n                case LV_SCROLL_SNAP_START:\n                    snap_point = scroll_obj->coords.x1 + pad_left;\n                    act_obj_point = act_obj->coords.x1;\n                    break;\n                case LV_SCROLL_SNAP_END:\n                    snap_point = scroll_obj->coords.x2 - pad_right;\n                    act_obj_point = act_obj->coords.x2;\n                    break;\n            }\n        }\n        else {\n            lv_coord_t pad_top = lv_obj_get_style_pad_top(scroll_obj, LV_PART_MAIN);\n            lv_coord_t pad_bottom = lv_obj_get_style_pad_bottom(scroll_obj, LV_PART_MAIN);\n\n            switch(snap) {\n                case LV_SCROLL_SNAP_CENTER:\n                    snap_point = pad_top + (lv_area_get_height(&scroll_obj->coords) - pad_top - pad_bottom) / 2 + scroll_obj->coords.y1;\n                    act_obj_point = lv_area_get_height(&act_obj->coords) / 2 + act_obj->coords.y1;\n                    break;\n                case LV_SCROLL_SNAP_START:\n                    snap_point = scroll_obj->coords.y1 + pad_top;\n                    act_obj_point = act_obj->coords.y1;\n                    break;\n                case LV_SCROLL_SNAP_END:\n                    snap_point = scroll_obj->coords.y2 - pad_bottom;\n                    act_obj_point = act_obj->coords.y2;\n                    break;\n            }\n        }\n\n        if(scroll_end < 0) {\n            if(snap != LV_SCROLL_SNAP_NONE && act_obj_point > snap_point) return diff;\n\n            /*Rounding*/\n            if(diff < 0) diff -= ELASTIC_SLOWNESS_FACTOR / 2;\n            if(diff > 0) diff += ELASTIC_SLOWNESS_FACTOR / 2;\n            return diff / ELASTIC_SLOWNESS_FACTOR;\n        }\n        else if(scroll_start < 0) {\n            if(snap != LV_SCROLL_SNAP_NONE && act_obj_point < snap_point) return diff;\n\n            /*Rounding*/\n            if(diff < 0) diff -= ELASTIC_SLOWNESS_FACTOR / 2;\n            if(diff > 0) diff += ELASTIC_SLOWNESS_FACTOR / 2;\n            return diff / ELASTIC_SLOWNESS_FACTOR;\n        }\n    }\n    else {\n        /*Scroll back to the boundary if required*/\n        if(scroll_end + diff < 0) diff = - scroll_end;\n        if(scroll_start - diff < 0) diff = scroll_start;\n    }\n\n    return diff;\n}"}, "_lv_indev_scroll_handler": {"type": "Function", "def": "void _lv_indev_scroll_handler(_lv_indev_proc_t * proc)", "sline": 46, "body": "{\n    lv_obj_t * scroll_obj = proc->types.pointer.scroll_obj;\n    /*If there is no scroll object yet try to find one*/\n    if(scroll_obj == NULL) {\n        proc->types.pointer.scroll_sum.x += proc->types.pointer.vect.x;\n        proc->types.pointer.scroll_sum.y += proc->types.pointer.vect.y;\n\n        scroll_obj = find_scroll_obj(proc);\n        if(scroll_obj == NULL) return;\n\n        init_scroll_limits(proc);\n\n        lv_event_send(scroll_obj, LV_EVENT_SCROLL_BEGIN, NULL);\n        if(proc->reset_query) return;\n    }\n\n    /*Set new position or scroll if the vector is not zero*/\n    if(proc->types.pointer.vect.x != 0 || proc->types.pointer.vect.y != 0) {\n        lv_coord_t diff_x = 0;\n        lv_coord_t diff_y = 0;\n\n        if(proc->types.pointer.scroll_dir == LV_DIR_HOR) {\n            lv_coord_t sr = lv_obj_get_scroll_right(scroll_obj);\n            lv_coord_t sl = lv_obj_get_scroll_left(scroll_obj);\n            diff_x = elastic_diff(scroll_obj, proc->types.pointer.vect.x, sl, sr, LV_DIR_HOR);\n        }\n        else {\n            lv_coord_t st = lv_obj_get_scroll_top(scroll_obj);\n            lv_coord_t sb = lv_obj_get_scroll_bottom(scroll_obj);\n            diff_y = elastic_diff(scroll_obj, proc->types.pointer.vect.y, st, sb, LV_DIR_VER);\n        }\n\n        lv_dir_t scroll_dir = lv_obj_get_scroll_dir(scroll_obj);\n        if((scroll_dir & LV_DIR_LEFT)   == 0 && diff_x > 0) diff_x = 0;\n        if((scroll_dir & LV_DIR_RIGHT)  == 0 && diff_x < 0) diff_x = 0;\n        if((scroll_dir & LV_DIR_TOP)    == 0 && diff_y > 0) diff_y = 0;\n        if((scroll_dir & LV_DIR_BOTTOM) == 0 && diff_y < 0) diff_y = 0;\n\n        /*Respect the scroll limit area*/\n        scroll_limit_diff(proc, &diff_x, &diff_y);\n\n        lv_obj_scroll_by(scroll_obj, diff_x, diff_y, LV_ANIM_OFF);\n        proc->types.pointer.scroll_sum.x += diff_x;\n        proc->types.pointer.scroll_sum.y += diff_y;\n    }\n}"}, "_lv_indev_scroll_throw_handler": {"type": "Function", "def": "void _lv_indev_scroll_throw_handler(_lv_indev_proc_t * proc)", "sline": 95, "body": "{\n    lv_obj_t * scroll_obj = proc->types.pointer.scroll_obj;\n    if(scroll_obj == NULL) return;\n    if(proc->types.pointer.scroll_dir == LV_DIR_NONE) return;\n\n\n    lv_indev_t * indev_act = lv_indev_get_act();\n    lv_coord_t scroll_throw =  indev_act->driver->scroll_throw;\n\n    if(lv_obj_has_flag(scroll_obj, LV_OBJ_FLAG_SCROLL_MOMENTUM) == false) {\n        proc->types.pointer.scroll_throw_vect.y = 0;\n        proc->types.pointer.scroll_throw_vect.x = 0;\n    }\n\n    lv_scroll_snap_t align_x = lv_obj_get_scroll_snap_x(scroll_obj);\n    lv_scroll_snap_t align_y = lv_obj_get_scroll_snap_y(scroll_obj);\n\n    if(proc->types.pointer.scroll_dir == LV_DIR_VER) {\n        proc->types.pointer.scroll_throw_vect.x = 0;\n        /*If no snapping \"throw\"*/\n        if(align_y == LV_SCROLL_SNAP_NONE) {\n            proc->types.pointer.scroll_throw_vect.y =\n                proc->types.pointer.scroll_throw_vect.y * (100 - scroll_throw) / 100;\n\n            lv_coord_t sb = lv_obj_get_scroll_bottom(scroll_obj);\n            lv_coord_t st = lv_obj_get_scroll_top(scroll_obj);\n\n            proc->types.pointer.scroll_throw_vect.y = elastic_diff(scroll_obj, proc->types.pointer.scroll_throw_vect.y, st, sb,\n                                                                   LV_DIR_VER);\n\n            lv_obj_scroll_by(scroll_obj, 0, proc->types.pointer.scroll_throw_vect.y, LV_ANIM_OFF);\n        }\n        /*With snapping find the nearest snap point and scroll there*/\n        else {\n            lv_coord_t diff_y = scroll_throw_predict_y(proc);\n            proc->types.pointer.scroll_throw_vect.y = 0;\n            scroll_limit_diff(proc, NULL, &diff_y);\n            lv_coord_t y = find_snap_point_y(scroll_obj, LV_COORD_MIN, LV_COORD_MAX, diff_y);\n            lv_obj_scroll_by(scroll_obj, 0, diff_y + y, LV_ANIM_ON);\n        }\n    }\n    else if(proc->types.pointer.scroll_dir == LV_DIR_HOR) {\n        proc->types.pointer.scroll_throw_vect.y = 0;\n        /*If no snapping \"throw\"*/\n        if(align_x == LV_SCROLL_SNAP_NONE) {\n            proc->types.pointer.scroll_throw_vect.x =\n                proc->types.pointer.scroll_throw_vect.x * (100 - scroll_throw) / 100;\n\n            lv_coord_t sl = lv_obj_get_scroll_left(scroll_obj);\n            lv_coord_t sr = lv_obj_get_scroll_right(scroll_obj);\n\n            proc->types.pointer.scroll_throw_vect.x = elastic_diff(scroll_obj, proc->types.pointer.scroll_throw_vect.x, sl, sr,\n                                                                   LV_DIR_HOR);\n\n            lv_obj_scroll_by(scroll_obj, proc->types.pointer.scroll_throw_vect.x, 0, LV_ANIM_OFF);\n        }\n        /*With snapping find the nearest snap point and scroll there*/\n        else {\n            lv_coord_t diff_x = scroll_throw_predict_x(proc);\n            proc->types.pointer.scroll_throw_vect.x = 0;\n            scroll_limit_diff(proc, &diff_x, NULL);\n            lv_coord_t x = find_snap_point_x(scroll_obj, LV_COORD_MIN, LV_COORD_MAX, diff_x);\n            lv_obj_scroll_by(scroll_obj, x + diff_x, 0, LV_ANIM_ON);\n        }\n    }\n\n    /*Check if the scroll has finished*/\n    if(proc->types.pointer.scroll_throw_vect.x == 0 && proc->types.pointer.scroll_throw_vect.y == 0) {\n        /*Revert if scrolled in*/\n        /*If vertically scrollable and not controlled by snap*/\n        if(align_y == LV_SCROLL_SNAP_NONE) {\n            lv_coord_t st = lv_obj_get_scroll_top(scroll_obj);\n            lv_coord_t sb = lv_obj_get_scroll_bottom(scroll_obj);\n            if(st > 0 || sb > 0) {\n                if(st < 0) {\n                    lv_obj_scroll_by(scroll_obj, 0, st, LV_ANIM_ON);\n                }\n                else if(sb < 0) {\n                    lv_obj_scroll_by(scroll_obj, 0, -sb, LV_ANIM_ON);\n                }\n            }\n        }\n\n        /*If horizontally scrollable and not controlled by snap*/\n        if(align_x == LV_SCROLL_SNAP_NONE) {\n            lv_coord_t sl = lv_obj_get_scroll_left(scroll_obj);\n            lv_coord_t sr = lv_obj_get_scroll_right(scroll_obj);\n            if(sl > 0 || sr > 0) {\n                if(sl < 0) {\n                    lv_obj_scroll_by(scroll_obj, sl, 0, LV_ANIM_ON);\n                }\n                else if(sr < 0) {\n                    lv_obj_scroll_by(scroll_obj, -sr, 0, LV_ANIM_ON);\n                }\n            }\n        }\n\n        lv_event_send(scroll_obj, LV_EVENT_SCROLL_END, indev_act);\n        if(proc->reset_query) return;\n\n        proc->types.pointer.scroll_dir = LV_DIR_NONE;\n        proc->types.pointer.scroll_obj = NULL;\n    }\n}"}, "lv_indev_scroll_throw_predict": {"type": "Function", "def": "lv_coord_t lv_indev_scroll_throw_predict(lv_indev_t * indev, lv_dir_t dir)", "sline": 207, "body": "{\n    if(indev == NULL) return 0;\n    lv_coord_t v;\n    switch(dir) {\n        case LV_DIR_VER:\n            v = indev->proc.types.pointer.scroll_throw_vect_ori.y;\n            break;\n        case LV_DIR_HOR:\n            v = indev->proc.types.pointer.scroll_throw_vect_ori.x;\n            break;\n        default:\n            return 0;\n    }\n\n    lv_coord_t scroll_throw = indev->driver->scroll_throw;\n    lv_coord_t sum = 0;\n    while(v) {\n        sum += v;\n        v = v * (100 - scroll_throw) / 100;\n    }\n\n    return sum;\n}"}, "lv_indev_scroll_get_snap_dist": {"type": "Function", "def": "void lv_indev_scroll_get_snap_dist(lv_obj_t * obj, lv_point_t * p)", "sline": 232, "body": "{\n    p->x = find_snap_point_x(obj, obj->coords.x1, obj->coords.x2, 0);\n    p->y = find_snap_point_y(obj, obj->coords.y1, obj->coords.y2, 0);\n}"}, "carbit_updater/lvgl/src/core/lv_indev_scroll.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_indev_scroll.c"}}, "carbit_updater/lv_drivers/display/sunximem.h": {"carbit_updater/lv_drivers/display/sunximem.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/sunximem.h"}}, "carbit_updater/lv_drivers/indev/evdev.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 20}, "lvgl": {"type": "Variable", "def": "#include lvgl/lvgl.h", "sline": 29, "include": ["carbit_updater/lvgl/lvgl.h", null]}, "evdev_init": {"type": "Function", "def": "void evdev_init(void)", "sline": 47}, "evdev_set_file": {"type": "Function", "def": "bool evdev_set_file(char* dev_name)", "sline": 54}, "evdev_read": {"type": "Function", "def": "void evdev_read(lv_indev_drv_t * drv, lv_indev_data_t * data)", "sline": 59}, "carbit_updater/lv_drivers/indev/evdev.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/indev/evdev.h"}}, "carbit_updater/lvgl/src/core/lv_group.c": {"stddef": {"type": "Variable", "def": "#include stddef.h", "sline": 9}, "lv_group": {"type": "Variable", "def": "#include lv_group.h", "sline": 11, "include": ["carbit_updater/lvgl/src/core/lv_group.h", null]}, "lv_gc": {"type": "Variable", "def": "#include ../misc/lv_gc.h", "sline": 12}, "lv_obj": {"type": "Variable", "def": "#include ../core/lv_obj.h", "sline": 13}, "lv_indev": {"type": "Variable", "def": "#include ../core/lv_indev.h", "sline": 14}, "focus_next_core": {"type": "Function", "def": "static void focus_next_core(lv_group_t * group, void * (*begin)(const lv_ll_t *),\n                            void * (*move)(const lv_ll_t *, const void *))", "sline": 357, "body": "{\n    if(group->frozen) return;\n\n    lv_obj_t ** obj_next     = group->obj_focus;\n    lv_obj_t ** obj_sentinel = NULL;\n    bool can_move            = true;\n    bool can_begin           = true;\n\n    for(;;) {\n        if(obj_next == NULL) {\n            if(group->wrap || obj_sentinel == NULL) {\n                if(!can_begin) return;\n                obj_next  = begin(&group->obj_ll);\n                can_move  = false;\n                can_begin = false;\n            }\n            else {\n                /*Currently focused object is the last/first in the group, keep it that way*/\n                return;\n            }\n        }\n\n        if(obj_sentinel == NULL) {\n            obj_sentinel = obj_next;\n            if(obj_sentinel == NULL) return; /*Group is empty*/\n        }\n\n        if(can_move) {\n            obj_next = move(&group->obj_ll, obj_next);\n\n            /*Give up if we walked the entire list and haven't found another visible object*/\n            if(obj_next == obj_sentinel) return;\n        }\n\n        can_move = true;\n\n        if(obj_next == NULL) continue;\n        if(lv_obj_get_state(*obj_next) & LV_STATE_DISABLED) continue;\n\n        /*Hidden objects don't receive focus.\n         *If any parent is hidden, the object is also hidden)*/\n        lv_obj_t * parent = *obj_next;\n        while(parent) {\n            if(lv_obj_has_flag(parent, LV_OBJ_FLAG_HIDDEN)) break;\n            parent = lv_obj_get_parent(parent);\n        }\n\n        if(parent && lv_obj_has_flag(parent, LV_OBJ_FLAG_HIDDEN)) continue;\n\n        /*If we got her a good candidate is found*/\n        break;\n    }\n\n    if(obj_next == group->obj_focus) return; /*There's only one visible object and it's already focused*/\n\n    if(group->obj_focus) {\n        lv_res_t res = lv_event_send(*group->obj_focus, LV_EVENT_DEFOCUSED, get_indev(group));\n        if(res != LV_RES_OK) return;\n        lv_obj_invalidate(*group->obj_focus);\n    }\n\n    group->obj_focus = obj_next;\n\n    lv_res_t res = lv_event_send(*group->obj_focus, LV_EVENT_FOCUSED, get_indev(group));\n    if(res != LV_RES_OK) return;\n\n    lv_obj_invalidate(*group->obj_focus);\n\n    if(group->focus_cb) group->focus_cb(group);\n}"}, "lv_group_refocus": {"type": "Function", "def": "static void lv_group_refocus(lv_group_t * g)", "sline": 343, "body": "{\n    /*Refocus must temporarily allow wrapping to work correctly*/\n    uint8_t temp_wrap = g->wrap;\n    g->wrap           = 1;\n\n    if(g->refocus_policy == LV_GROUP_REFOCUS_POLICY_NEXT)\n        lv_group_focus_next(g);\n    else if(g->refocus_policy == LV_GROUP_REFOCUS_POLICY_PREV)\n        lv_group_focus_prev(g);\n    /*Restore wrap property*/\n    g->wrap = temp_wrap;\n}"}, "get_indev": {"type": "Function", "def": "static lv_indev_t * get_indev(const lv_group_t * g)", "sline": 437, "body": "{\n    lv_indev_t * indev_encoder = NULL;\n    lv_indev_t * indev_group = NULL;\n    lv_indev_t * indev = lv_indev_get_next(NULL);\n    while(indev) {\n        lv_indev_type_t indev_type = lv_indev_get_type(indev);\n        if(indev->group == g) {\n            /*Prefer KEYPAD*/\n            if(indev_type == LV_INDEV_TYPE_KEYPAD) return indev;\n            if(indev_type == LV_INDEV_TYPE_ENCODER) indev_encoder = indev;\n            indev_group = indev;\n        }\n        indev = lv_indev_get_next(indev);\n    }\n\n    if(indev_encoder) return indev_encoder;\n    if(indev_group) return indev_group;\n\n    /*In lack of a better option use the first input device. (It can be NULL if there is no input device)*/\n    return lv_indev_get_next(NULL);\n}"}, "default_group": {"type": "Variable", "def": "static lv_group_t * default_group", "sline": 35}, "_lv_group_init": {"type": "Function", "def": "void _lv_group_init(void)", "sline": 45, "body": "{\n    _lv_ll_init(&LV_GC_ROOT(_lv_group_ll), sizeof(lv_group_t));\n}"}, "lv_group_create": {"type": "Function", "def": "lv_group_t * lv_group_create(void)", "sline": 50, "body": "{\n    lv_group_t * group = _lv_ll_ins_head(&LV_GC_ROOT(_lv_group_ll));\n    LV_ASSERT_MALLOC(group);\n    if(group == NULL) return NULL;\n    _lv_ll_init(&group->obj_ll, sizeof(lv_obj_t *));\n\n    group->obj_focus      = NULL;\n    group->frozen         = 0;\n    group->focus_cb       = NULL;\n    group->editing        = 0;\n    group->refocus_policy = LV_GROUP_REFOCUS_POLICY_PREV;\n    group->wrap           = 1;\n\n#if LV_USE_USER_DATA\n    group->user_data = NULL;\n#endif\n\n    return group;\n}"}, "lv_group_del": {"type": "Function", "def": "void lv_group_del(lv_group_t * group)", "sline": 71, "body": "{\n    /*Defocus the currently focused object*/\n    if(group->obj_focus != NULL) {\n        lv_event_send(*group->obj_focus, LV_EVENT_DEFOCUSED, get_indev(group));\n        lv_obj_invalidate(*group->obj_focus);\n    }\n\n    /*Remove the objects from the group*/\n    lv_obj_t ** obj;\n    _LV_LL_READ(&group->obj_ll, obj) {\n        if((*obj)->spec_attr)(*obj)->spec_attr->group_p = NULL;\n    }\n\n    _lv_ll_clear(&(group->obj_ll));\n    _lv_ll_remove(&LV_GC_ROOT(_lv_group_ll), group);\n    lv_mem_free(group);\n}"}, "lv_group_set_default": {"type": "Function", "def": "void lv_group_set_default(lv_group_t * group)", "sline": 90, "body": "{\n    default_group = group;\n}"}, "lv_group_get_default": {"type": "Function", "def": "lv_group_t * lv_group_get_default(void)", "sline": 95, "body": "{\n    return default_group;\n}"}, "lv_group_add_obj": {"type": "Function", "def": "void lv_group_add_obj(lv_group_t * group, lv_obj_t * obj)", "sline": 100, "body": "{\n    if(group == NULL) return;\n\n    LV_LOG_TRACE(\"begin\");\n\n    /*Do not add the object twice*/\n    lv_obj_t ** obj_i;\n    _LV_LL_READ(&group->obj_ll, obj_i) {\n        if((*obj_i) == obj) {\n            LV_LOG_INFO(\"the object is already added to this group\");\n            return;\n        }\n    }\n\n    /*If the object is already in a group and focused then refocus it*/\n    lv_group_t * group_cur = lv_obj_get_group(obj);\n    if(group_cur) {\n        if(obj->spec_attr->group_p && *(obj->spec_attr->group_p->obj_focus) == obj) {\n            lv_group_refocus(group_cur);\n\n            LV_LOG_INFO(\"changing object's group\");\n        }\n    }\n\n    if(obj->spec_attr == NULL) lv_obj_allocate_spec_attr(obj);\n    obj->spec_attr->group_p = group;\n\n    lv_obj_t ** next = _lv_ll_ins_tail(&group->obj_ll);\n    LV_ASSERT_MALLOC(next);\n    if(next == NULL) return;\n    *next = obj;\n\n    /*If the head and the tail is equal then there is only one object in the linked list.\n     *In this case automatically activate it*/\n    if(_lv_ll_get_head(&group->obj_ll) == next) {\n        lv_group_refocus(group);\n    }\n\n    LV_LOG_TRACE(\"finished\");\n}"}, "lv_group_swap_obj": {"type": "Function", "def": "void lv_group_swap_obj(lv_obj_t * obj1, lv_obj_t * obj2)", "sline": 142, "body": "{\n    lv_group_t * g1 = lv_obj_get_group(obj1);\n    lv_group_t * g2 = lv_obj_get_group(obj2);\n    if(g1 != g2) return;\n    if(g1 == NULL) return;\n\n    /*Do not add the object twice*/\n    lv_obj_t ** obj_i;\n    _LV_LL_READ(&g1->obj_ll, obj_i) {\n        if((*obj_i) == obj1)(*obj_i) =  obj2;\n        else if((*obj_i) == obj2)(*obj_i) =  obj1;\n    }\n\n    if(*g1->obj_focus == obj1) lv_group_focus_obj(obj2);\n    else if(*g1->obj_focus == obj2) lv_group_focus_obj(obj1);\n\n}"}, "lv_group_remove_obj": {"type": "Function", "def": "void lv_group_remove_obj(lv_obj_t * obj)", "sline": 161, "body": "{\n    lv_group_t * g = lv_obj_get_group(obj);\n    if(g == NULL) return;\n\n    LV_LOG_TRACE(\"begin\");\n\n    /*Focus on the next object*/\n    if(g->obj_focus && *g->obj_focus == obj) {\n        if(g->frozen) g->frozen = 0;\n\n        /*If this is the only object in the group then focus to nothing.*/\n        if(_lv_ll_get_head(&g->obj_ll) == g->obj_focus && _lv_ll_get_tail(&g->obj_ll) == g->obj_focus) {\n            lv_event_send(*g->obj_focus, LV_EVENT_DEFOCUSED, get_indev(g));\n        }\n        /*If there more objects in the group then focus to the next/prev object*/\n        else {\n            lv_group_refocus(g);\n        }\n    }\n\n    /*If the focuses object is still the same then it was the only object in the group but it will\n     *be deleted. Set the `obj_focus` to NULL to get back to the initial state of the group with\n     *zero objects*/\n    if(g->obj_focus && *g->obj_focus == obj) {\n        g->obj_focus = NULL;\n    }\n\n    /*Search the object and remove it from its group*/\n    lv_obj_t ** i;\n    _LV_LL_READ(&g->obj_ll, i) {\n        if(*i == obj) {\n            _lv_ll_remove(&g->obj_ll, i);\n            lv_mem_free(i);\n            if(obj->spec_attr) obj->spec_attr->group_p = NULL;\n            break;\n        }\n    }\n    LV_LOG_TRACE(\"finished\");\n}"}, "lv_group_remove_all_objs": {"type": "Function", "def": "void lv_group_remove_all_objs(lv_group_t * group)", "sline": 202, "body": "{\n    /*Defocus the currently focused object*/\n    if(group->obj_focus != NULL) {\n        lv_event_send(*group->obj_focus, LV_EVENT_DEFOCUSED, get_indev(group));\n        lv_obj_invalidate(*group->obj_focus);\n        group->obj_focus = NULL;\n    }\n\n    /*Remove the objects from the group*/\n    lv_obj_t ** obj;\n    _LV_LL_READ(&group->obj_ll, obj) {\n        if((*obj)->spec_attr)(*obj)->spec_attr->group_p = NULL;\n    }\n\n    _lv_ll_clear(&(group->obj_ll));\n}"}, "lv_group_focus_obj": {"type": "Function", "def": "void lv_group_focus_obj(lv_obj_t * obj)", "sline": 220, "body": "{\n    if(obj == NULL) return;\n    lv_group_t * g = lv_obj_get_group(obj);\n    if(g == NULL) return;\n\n    if(g->frozen != 0) return;\n\n    /*On defocus edit mode must be leaved*/\n    lv_group_set_editing(g, false);\n\n    lv_obj_t ** i;\n    _LV_LL_READ(&g->obj_ll, i) {\n        if(*i == obj) {\n            if(g->obj_focus != NULL && obj != *g->obj_focus) {  /*Do not defocus if the same object needs to be focused again*/\n                lv_res_t res = lv_event_send(*g->obj_focus, LV_EVENT_DEFOCUSED, get_indev(g));\n                if(res != LV_RES_OK) return;\n                lv_obj_invalidate(*g->obj_focus);\n            }\n\n            g->obj_focus = i;\n\n            if(g->obj_focus != NULL) {\n                if(g->focus_cb) g->focus_cb(g);\n                lv_res_t res = lv_event_send(*g->obj_focus, LV_EVENT_FOCUSED, get_indev(g));\n                if(res != LV_RES_OK) return;\n                lv_obj_invalidate(*g->obj_focus);\n            }\n            break;\n        }\n    }\n}"}, "lv_group_focus_next": {"type": "Function", "def": "void lv_group_focus_next(lv_group_t * group)", "sline": 253, "body": "{\n    focus_next_core(group, _lv_ll_get_head, _lv_ll_get_next);\n}"}, "lv_group_focus_prev": {"type": "Function", "def": "void lv_group_focus_prev(lv_group_t * group)", "sline": 258, "body": "{\n    focus_next_core(group, _lv_ll_get_tail, _lv_ll_get_prev);\n}"}, "lv_group_focus_freeze": {"type": "Function", "def": "void lv_group_focus_freeze(lv_group_t * group, bool en)", "sline": 263, "body": "{\n    if(en == false) group->frozen = 0;\n    else group->frozen = 1;\n}"}, "lv_group_send_data": {"type": "Function", "def": "lv_res_t lv_group_send_data(lv_group_t * group, uint32_t c)", "sline": 269, "body": "{\n    lv_obj_t * act = lv_group_get_focused(group);\n    if(act == NULL) return LV_RES_OK;\n    return lv_event_send(act, LV_EVENT_KEY, &c);\n}"}, "lv_group_set_focus_cb": {"type": "Function", "def": "void lv_group_set_focus_cb(lv_group_t * group, lv_group_focus_cb_t focus_cb)", "sline": 276, "body": "{\n    group->focus_cb = focus_cb;\n}"}, "lv_group_set_editing": {"type": "Function", "def": "void lv_group_set_editing(lv_group_t * group, bool edit)", "sline": 281, "body": "{\n    if(group == NULL) return;\n    uint8_t en_val = edit ? 1 : 0;\n\n    if(en_val == group->editing) return; /*Do not set the same mode again*/\n\n    group->editing     = en_val;\n    lv_obj_t * focused = lv_group_get_focused(group);\n\n    if(focused) {\n        lv_res_t res = lv_event_send(*group->obj_focus, LV_EVENT_FOCUSED, get_indev(group));\n        if(res != LV_RES_OK) return;\n\n        lv_obj_invalidate(focused);\n    }\n}"}, "lv_group_set_refocus_policy": {"type": "Function", "def": "void lv_group_set_refocus_policy(lv_group_t * group, lv_group_refocus_policy_t policy)", "sline": 299, "body": "{\n    group->refocus_policy = policy & 0x01;\n}"}, "lv_group_set_wrap": {"type": "Function", "def": "void lv_group_set_wrap(lv_group_t * group, bool en)", "sline": 304, "body": "{\n    group->wrap = en ? 1 : 0;\n}"}, "lv_group_get_focused": {"type": "Function", "def": "lv_obj_t * lv_group_get_focused(const lv_group_t * group)", "sline": 309, "body": "{\n    if(!group) return NULL;\n    if(group->obj_focus == NULL) return NULL;\n\n    return *group->obj_focus;\n}"}, "lv_group_get_focus_cb": {"type": "Function", "def": "lv_group_focus_cb_t lv_group_get_focus_cb(const lv_group_t * group)", "sline": 317, "body": "{\n    if(!group) return NULL;\n    return group->focus_cb;\n}"}, "lv_group_get_editing": {"type": "Function", "def": "bool lv_group_get_editing(const lv_group_t * group)", "sline": 323, "body": "{\n    if(!group) return false;\n    return group->editing ? true : false;\n}"}, "lv_group_get_wrap": {"type": "Function", "def": "bool lv_group_get_wrap(lv_group_t * group)", "sline": 329, "body": "{\n    if(!group) return false;\n    return group->wrap ? true : false;\n}"}, "lv_group_get_obj_count": {"type": "Function", "def": "uint32_t lv_group_get_obj_count(lv_group_t * group)", "sline": 335, "body": "{\n    return _lv_ll_get_len(&group->obj_ll);\n}"}, "carbit_updater/lvgl/src/core/lv_group.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_group.c"}}, "carbit_updater/lvgl/src/core/lv_obj_tree.h": {"stddef": {"type": "Variable", "def": "#include stddef.h", "sline": 16}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 17}, "_lv_obj_t": {"type": "Struct", "def": "struct _lv_obj_t", "sline": 28}, "_lv_obj_class_t": {"type": "Struct", "def": "struct _lv_obj_class_t", "sline": 29}, "lv_obj_tree_walk_res_t": {"type": "Variable", "def": "typedef enum {\n    LV_OBJ_TREE_WALK_NEXT,\n    LV_OBJ_TREE_WALK_SKIP_CHILDREN,\n    LV_OBJ_TREE_WALK_END,\n} lv_obj_tree_walk_res_t", "sline": 35}, "lv_obj_tree_walk_cb_t": {"type": "Variable", "def": "typedef lv_obj_tree_walk_res_t (*lv_obj_tree_walk_cb_t)(struct _lv_obj_t *, void *)", "sline": 37}, "lv_obj_del": {"type": "Function", "def": "void lv_obj_del(struct _lv_obj_t * obj)", "sline": 49}, "lv_obj_clean": {"type": "Function", "def": "void lv_obj_clean(struct _lv_obj_t * obj)", "sline": 57}, "lv_obj_del_delayed": {"type": "Function", "def": "void lv_obj_del_delayed(struct _lv_obj_t * obj, uint32_t delay_ms)", "sline": 64}, "lv_obj_del_anim_ready_cb": {"type": "Function", "def": "void lv_obj_del_anim_ready_cb(lv_anim_t * a)", "sline": 70}, "lv_obj_del_async": {"type": "Function", "def": "void lv_obj_del_async(struct _lv_obj_t * obj)", "sline": 78}, "lv_obj_set_parent": {"type": "Function", "def": "void lv_obj_set_parent(struct _lv_obj_t * obj, struct _lv_obj_t * parent)", "sline": 86}, "lv_obj_swap": {"type": "Function", "def": "void lv_obj_swap(struct _lv_obj_t * obj1, struct _lv_obj_t * obj2)", "sline": 94}, "lv_obj_move_to_index": {"type": "Function", "def": "void lv_obj_move_to_index(struct _lv_obj_t * obj, int32_t index)", "sline": 104}, "lv_obj_get_screen": {"type": "Function", "def": "struct _lv_obj_t * lv_obj_get_screen(const struct _lv_obj_t * obj)", "sline": 111}, "lv_obj_get_disp": {"type": "Function", "def": "lv_disp_t * lv_obj_get_disp(const struct _lv_obj_t * obj)", "sline": 118}, "lv_obj_get_parent": {"type": "Function", "def": "struct _lv_obj_t * lv_obj_get_parent(const struct _lv_obj_t * obj)", "sline": 125}, "lv_obj_get_child": {"type": "Function", "def": "struct _lv_obj_t * lv_obj_get_child(const struct _lv_obj_t * obj, int32_t id)", "sline": 138}, "lv_obj_get_child_cnt": {"type": "Function", "def": "uint32_t lv_obj_get_child_cnt(const struct _lv_obj_t * obj)", "sline": 145}, "lv_obj_get_index": {"type": "Function", "def": "uint32_t lv_obj_get_index(const struct _lv_obj_t * obj)", "sline": 153}, "lv_obj_tree_walk": {"type": "Function", "def": "void lv_obj_tree_walk(struct _lv_obj_t * start_obj, lv_obj_tree_walk_cb_t cb, void * user_data)", "sline": 161}, "carbit_updater/lvgl/src/core/lv_obj_tree.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_tree.h"}}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_draw_label.c": {"lv_conf_internal": {"type": "Variable", "def": "#include ../../lv_conf_internal.h", "sline": 10}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_draw_label.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_draw_label.c"}}, "carbit_updater/lvgl/src/extra/widgets/span/lv_span.h": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 16}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/span/lv_span.h:30:1)": {"type": "Enum", "def": "enum {\n    LV_SPAN_OVERFLOW_CLIP,\n    LV_SPAN_OVERFLOW_ELLIPSIS,\n}", "sline": 30, "docstring": "/**********************"}, "lv_span_overflow_t": {"type": "Variable", "def": "typedef uint8_t lv_span_overflow_t", "sline": 34}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/span/lv_span.h:36:1)": {"type": "Enum", "def": "enum {\n    LV_SPAN_MODE_FIXED,     /**< fixed the obj size*/\n    LV_SPAN_MODE_EXPAND,    /**< Expand the object size to the text size*/\n    LV_SPAN_MODE_BREAK,     /**< Keep width, break the too long lines and expand height*/\n}", "sline": 36}, "lv_span_mode_t": {"type": "Variable", "def": "typedef uint8_t lv_span_mode_t", "sline": 41}, "lv_span_t.txt": {"type": "Variable", "def": "char * txt", "sline": 44, "in_struct": "lv_span_t"}, "lv_span_t.spangroup": {"type": "Variable", "def": "lv_obj_t * spangroup", "sline": 45, "in_struct": "lv_span_t"}, "lv_span_t.style": {"type": "Variable", "def": "lv_style_t style", "sline": 46, "in_struct": "lv_span_t"}, "lv_span_t.static_flag": {"type": "Variable", "def": "uint8_t static_flag : 1", "sline": 47, "in_struct": "lv_span_t"}, "lv_span_t": {"type": "Variable", "def": "typedef struct {\n    char * txt;             /* a pointer to display text */\n    lv_obj_t * spangroup;   /* a pointer to spangroup */\n    lv_style_t style;       /* display text style */\n    uint8_t static_flag : 1;/* the text is static flag */\n} lv_span_t", "sline": 48}, "lv_spangroup_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 52, "in_struct": "lv_spangroup_t"}, "lv_spangroup_t.indent": {"type": "Variable", "def": "lv_coord_t indent", "sline": 53, "in_struct": "lv_spangroup_t"}, "lv_spangroup_t.cache_w": {"type": "Variable", "def": "lv_coord_t cache_w", "sline": 54, "in_struct": "lv_spangroup_t"}, "lv_spangroup_t.cache_h": {"type": "Variable", "def": "lv_coord_t cache_h", "sline": 55, "in_struct": "lv_spangroup_t"}, "lv_spangroup_t.child_ll": {"type": "Variable", "def": "lv_ll_t  child_ll", "sline": 56, "in_struct": "lv_spangroup_t"}, "lv_spangroup_t.mode": {"type": "Variable", "def": "uint8_t mode : 2", "sline": 57, "in_struct": "lv_spangroup_t"}, "lv_spangroup_t.overflow": {"type": "Variable", "def": "uint8_t overflow : 1", "sline": 58, "in_struct": "lv_spangroup_t"}, "lv_spangroup_t.refresh": {"type": "Variable", "def": "uint8_t refresh : 1", "sline": 59, "in_struct": "lv_spangroup_t"}, "lv_spangroup_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    lv_coord_t indent;      /* first line indent */\n    lv_coord_t cache_w;     /* the cache automatically calculates the width */\n    lv_coord_t cache_h;     /* similar cache_w */\n    lv_ll_t  child_ll;\n    uint8_t mode : 2;       /* details see lv_span_mode_t */\n    uint8_t overflow : 1;   /* details see lv_span_overflow_t */\n    uint8_t refresh : 1;    /* the spangroup need refresh cache_w and cache_h */\n} lv_spangroup_t", "sline": 60, "docstring": "/** Data of label*/"}, "lv_spangroup_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_spangroup_class", "sline": 62}, "lv_spangroup_create": {"type": "Function", "def": "lv_obj_t * lv_spangroup_create(lv_obj_t * par)", "sline": 73}, "lv_spangroup_new_span": {"type": "Function", "def": "lv_span_t * lv_spangroup_new_span(lv_obj_t * obj)", "sline": 80}, "lv_spangroup_del_span": {"type": "Function", "def": "void lv_spangroup_del_span(lv_obj_t * obj, lv_span_t * span)", "sline": 87}, "lv_span_set_text": {"type": "Function", "def": "void lv_span_set_text(lv_span_t * span, const char * text)", "sline": 98}, "lv_span_set_text_static": {"type": "Function", "def": "void lv_span_set_text_static(lv_span_t * span, const char * text)", "sline": 106}, "lv_spangroup_set_align": {"type": "Function", "def": "void lv_spangroup_set_align(lv_obj_t * obj, lv_text_align_t align)", "sline": 113}, "lv_spangroup_set_overflow": {"type": "Function", "def": "void lv_spangroup_set_overflow(lv_obj_t * obj, lv_span_overflow_t overflow)", "sline": 120}, "lv_spangroup_set_indent": {"type": "Function", "def": "void lv_spangroup_set_indent(lv_obj_t * obj, lv_coord_t indent)", "sline": 127}, "lv_spangroup_set_mode": {"type": "Function", "def": "void lv_spangroup_set_mode(lv_obj_t * obj, lv_span_mode_t mode)", "sline": 134}, "lv_spangroup_get_child": {"type": "Function", "def": "lv_span_t * lv_spangroup_get_child(const lv_obj_t * obj, int32_t id)", "sline": 152}, "lv_spangroup_get_child_cnt": {"type": "Function", "def": "uint32_t lv_spangroup_get_child_cnt(const lv_obj_t * obj)", "sline": 159}, "lv_spangroup_get_align": {"type": "Function", "def": "lv_text_align_t lv_spangroup_get_align(lv_obj_t * obj)", "sline": 166}, "lv_spangroup_get_overflow": {"type": "Function", "def": "lv_span_overflow_t lv_spangroup_get_overflow(lv_obj_t * obj)", "sline": 173, "rels": [["lv_span_overflow_t", null, "Typeof"]]}, "lv_spangroup_get_indent": {"type": "Function", "def": "lv_coord_t lv_spangroup_get_indent(lv_obj_t * obj)", "sline": 180}, "lv_spangroup_get_mode": {"type": "Function", "def": "lv_span_mode_t lv_spangroup_get_mode(lv_obj_t * obj)", "sline": 186, "rels": [["lv_span_mode_t", null, "Typeof"]]}, "lv_spangroup_get_max_line_h": {"type": "Function", "def": "lv_coord_t lv_spangroup_get_max_line_h(lv_obj_t * obj)", "sline": 192}, "lv_spangroup_get_expand_width": {"type": "Function", "def": "lv_coord_t lv_spangroup_get_expand_width(lv_obj_t * obj)", "sline": 198}, "lv_spangroup_get_expand_height": {"type": "Function", "def": "lv_coord_t lv_spangroup_get_expand_height(lv_obj_t * obj, lv_coord_t width)", "sline": 204}, "lv_spangroup_refr_mode": {"type": "Function", "def": "void lv_spangroup_refr_mode(lv_obj_t * obj)", "sline": 215}, "carbit_updater/lvgl/src/extra/widgets/span/lv_span.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/span/lv_span.h"}}, "carbit_updater/lvgl/src/extra/widgets/imgbtn/lv_imgbtn.h": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 16}, "lv_imgbtn_state_t": {"type": "Variable", "def": "typedef enum {\n    LV_IMGBTN_STATE_RELEASED,\n    LV_IMGBTN_STATE_PRESSED,\n    LV_IMGBTN_STATE_DISABLED,\n    LV_IMGBTN_STATE_CHECKED_RELEASED,\n    LV_IMGBTN_STATE_CHECKED_PRESSED,\n    LV_IMGBTN_STATE_CHECKED_DISABLED,\n    _LV_IMGBTN_STATE_NUM,\n} lv_imgbtn_state_t", "sline": 31, "docstring": "/*********************"}, "lv_imgbtn_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 38, "in_struct": "lv_imgbtn_t"}, "lv_imgbtn_t.img_src_mid": {"type": "Variable", "def": "const void * img_src_mid[_LV_IMGBTN_STATE_NUM]", "sline": 39, "in_struct": "lv_imgbtn_t"}, "lv_imgbtn_t.img_src_left": {"type": "Variable", "def": "const void * img_src_left[_LV_IMGBTN_STATE_NUM]", "sline": 40, "in_struct": "lv_imgbtn_t"}, "lv_imgbtn_t.img_src_right": {"type": "Variable", "def": "const void * img_src_right[_LV_IMGBTN_STATE_NUM]", "sline": 41, "in_struct": "lv_imgbtn_t"}, "lv_imgbtn_t.act_cf": {"type": "Variable", "def": "lv_img_cf_t act_cf", "sline": 42, "in_struct": "lv_imgbtn_t"}, "lv_imgbtn_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    const void * img_src_mid[_LV_IMGBTN_STATE_NUM];   /*Store center images to each state*/\n    const void * img_src_left[_LV_IMGBTN_STATE_NUM];  /*Store left side images to each state*/\n    const void * img_src_right[_LV_IMGBTN_STATE_NUM]; /*Store right side images to each state*/\n    lv_img_cf_t act_cf; /*Color format of the currently active image*/\n} lv_imgbtn_t", "sline": 43, "docstring": "/*Data of image button*/"}, "lv_imgbtn_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_imgbtn_class", "sline": 45}, "lv_imgbtn_create": {"type": "Function", "def": "lv_obj_t * lv_imgbtn_create(lv_obj_t * parent)", "sline": 56}, "lv_imgbtn_set_src": {"type": "Function", "def": "void lv_imgbtn_set_src(lv_obj_t * imgbtn, lv_imgbtn_state_t state, const void * src_left, const void * src_mid,\n                       const void * src_right)", "sline": 77}, "lv_imgbtn_set_state": {"type": "Function", "def": "void lv_imgbtn_set_state(lv_obj_t * imgbtn, lv_imgbtn_state_t state)", "sline": 86}, "lv_imgbtn_get_src_left": {"type": "Function", "def": "const void * lv_imgbtn_get_src_left(lv_obj_t * imgbtn, lv_imgbtn_state_t state)", "sline": 98}, "lv_imgbtn_get_src_middle": {"type": "Function", "def": "const void * lv_imgbtn_get_src_middle(lv_obj_t * imgbtn, lv_imgbtn_state_t state)", "sline": 106}, "lv_imgbtn_get_src_right": {"type": "Function", "def": "const void * lv_imgbtn_get_src_right(lv_obj_t * imgbtn, lv_imgbtn_state_t state)", "sline": 114}, "carbit_updater/lvgl/src/extra/widgets/imgbtn/lv_imgbtn.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/imgbtn/lv_imgbtn.h"}}, "carbit_updater/lv_drivers/wayland/wayland.c": {"wayland": {"type": "Variable", "def": "#include wayland.h", "sline": 9, "include": ["carbit_updater/lv_drivers/wayland/wayland.h", null]}, "carbit_updater/lv_drivers/wayland/wayland.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/wayland/wayland.c"}}, "carbit_updater/lvgl/src/extra/widgets/spinbox/lv_spinbox.h": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 16}, "lv_spinbox_t.ta": {"type": "Variable", "def": "lv_textarea_t ta", "sline": 36, "in_struct": "lv_spinbox_t"}, "lv_spinbox_t.value": {"type": "Variable", "def": "int32_t value", "sline": 38, "in_struct": "lv_spinbox_t"}, "lv_spinbox_t.range_max": {"type": "Variable", "def": "int32_t range_max", "sline": 39, "in_struct": "lv_spinbox_t"}, "lv_spinbox_t.range_min": {"type": "Variable", "def": "int32_t range_min", "sline": 40, "in_struct": "lv_spinbox_t"}, "lv_spinbox_t.step": {"type": "Variable", "def": "int32_t step", "sline": 41, "in_struct": "lv_spinbox_t"}, "lv_spinbox_t.digit_count": {"type": "Variable", "def": "uint16_t digit_count : 4", "sline": 42, "in_struct": "lv_spinbox_t"}, "lv_spinbox_t.dec_point_pos": {"type": "Variable", "def": "uint16_t dec_point_pos : 4", "sline": 43, "in_struct": "lv_spinbox_t"}, "lv_spinbox_t.rollover": {"type": "Variable", "def": "uint16_t rollover : 1", "sline": 44, "in_struct": "lv_spinbox_t"}, "lv_spinbox_t.digit_step_dir": {"type": "Variable", "def": "uint16_t digit_step_dir : 2", "sline": 45, "in_struct": "lv_spinbox_t"}, "lv_spinbox_t": {"type": "Variable", "def": "typedef struct {\n    lv_textarea_t ta;   /*Ext. of ancestor*/\n    /*New data for this type*/\n    int32_t value;\n    int32_t range_max;\n    int32_t range_min;\n    int32_t step;\n    uint16_t digit_count : 4;\n    uint16_t dec_point_pos : 4; /*if 0, there is no separator and the number is an integer*/\n    uint16_t rollover : 1;   // Set to true for rollover functionality\n    uint16_t digit_step_dir : 2; // the direction the digit will step on encoder button press when editing\n} lv_spinbox_t", "sline": 46, "docstring": "/*Data of spinbox*/"}, "lv_spinbox_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_spinbox_class", "sline": 48}, "lv_spinbox_create": {"type": "Function", "def": "lv_obj_t * lv_spinbox_create(lv_obj_t * parent)", "sline": 59}, "lv_spinbox_set_value": {"type": "Function", "def": "void lv_spinbox_set_value(lv_obj_t * obj, int32_t i)", "sline": 70}, "lv_spinbox_set_rollover": {"type": "Function", "def": "void lv_spinbox_set_rollover(lv_obj_t * obj, bool b)", "sline": 77}, "lv_spinbox_set_digit_format": {"type": "Function", "def": "void lv_spinbox_set_digit_format(lv_obj_t * obj, uint8_t digit_count, uint8_t separator_position)", "sline": 86}, "lv_spinbox_set_step": {"type": "Function", "def": "void lv_spinbox_set_step(lv_obj_t * obj, uint32_t step)", "sline": 93}, "lv_spinbox_set_range": {"type": "Function", "def": "void lv_spinbox_set_range(lv_obj_t * obj, int32_t range_min, int32_t range_max)", "sline": 101}, "lv_spinbox_set_pos": {"type": "Function", "def": "void lv_spinbox_set_pos(lv_obj_t * obj, uint8_t pos)", "sline": 108}, "lv_spinbox_set_digit_step_direction": {"type": "Function", "def": "void lv_spinbox_set_digit_step_direction(lv_obj_t * obj, lv_dir_t direction)", "sline": 115}, "lv_spinbox_get_rollover": {"type": "Function", "def": "bool lv_spinbox_get_rollover(lv_obj_t *obj)", "sline": 125}, "lv_spinbox_get_value": {"type": "Function", "def": "int32_t lv_spinbox_get_value(lv_obj_t * obj)", "sline": 132}, "lv_spinbox_get_step": {"type": "Function", "def": "int32_t lv_spinbox_get_step(lv_obj_t * obj)", "sline": 139}, "lv_spinbox_step_next": {"type": "Function", "def": "void lv_spinbox_step_next(lv_obj_t * obj)", "sline": 149}, "lv_spinbox_step_prev": {"type": "Function", "def": "void lv_spinbox_step_prev(lv_obj_t * obj)", "sline": 155}, "lv_spinbox_increment": {"type": "Function", "def": "void lv_spinbox_increment(lv_obj_t * obj)", "sline": 161}, "lv_spinbox_decrement": {"type": "Function", "def": "void lv_spinbox_decrement(lv_obj_t * obj)", "sline": 167}, "carbit_updater/lvgl/src/extra/widgets/spinbox/lv_spinbox.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/spinbox/lv_spinbox.h"}}, "carbit_updater/lvgl/src/extra/widgets/led/lv_led.h": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 16}, "lv_led_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 40, "in_struct": "lv_led_t"}, "lv_led_t.color": {"type": "Variable", "def": "lv_color_t color", "sline": 41, "in_struct": "lv_led_t"}, "lv_led_t.bright": {"type": "Variable", "def": "uint8_t bright", "sline": 42, "in_struct": "lv_led_t"}, "lv_led_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    lv_color_t color;\n    uint8_t bright;     /**< Current brightness of the LED (0..255)*/\n} lv_led_t", "sline": 43, "docstring": "/*Data of led*/"}, "lv_led_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_led_class", "sline": 45}, "lv_led_draw_part_type_t": {"type": "Variable", "def": "typedef enum {\n    LV_LED_DRAW_PART_RECTANGLE,    /**< The main rectangle*/\n} lv_led_draw_part_type_t", "sline": 53}, "lv_led_create": {"type": "Function", "def": "lv_obj_t * lv_led_create(lv_obj_t * parent)", "sline": 64}, "lv_led_set_color": {"type": "Function", "def": "void lv_led_set_color(lv_obj_t * led, lv_color_t color)", "sline": 71}, "lv_led_set_brightness": {"type": "Function", "def": "void lv_led_set_brightness(lv_obj_t * led, uint8_t bright)", "sline": 78}, "lv_led_on": {"type": "Function", "def": "void lv_led_on(lv_obj_t * led)", "sline": 84}, "lv_led_off": {"type": "Function", "def": "void lv_led_off(lv_obj_t * led)", "sline": 90}, "lv_led_toggle": {"type": "Function", "def": "void lv_led_toggle(lv_obj_t * led)", "sline": 96}, "lv_led_get_brightness": {"type": "Function", "def": "uint8_t lv_led_get_brightness(const lv_obj_t * obj)", "sline": 103}, "carbit_updater/lvgl/src/extra/widgets/led/lv_led.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/led/lv_led.h"}}, "carbit_updater/lvgl/src/misc/lv_math.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 17}, "lv_sqrt_res_t.i": {"type": "Variable", "def": "uint16_t i", "sline": 33, "in_struct": "lv_sqrt_res_t"}, "lv_sqrt_res_t.f": {"type": "Variable", "def": "uint16_t f", "sline": 34, "in_struct": "lv_sqrt_res_t"}, "lv_sqrt_res_t": {"type": "Variable", "def": "typedef struct {\n    uint16_t i;\n    uint16_t f;\n} lv_sqrt_res_t", "sline": 35}, "lv_trigo_sin": {"type": "Function", "def": "int16_t lv_trigo_sin(int16_t angle)", "sline": 47}, "lv_trigo_cos": {"type": "Function", "def": "static inline LV_ATTRIBUTE_FAST_MEM int16_t lv_trigo_cos(int16_t angle)", "sline": 49, "body": "{\n    return lv_trigo_sin(angle + 90);\n}"}, "lv_bezier3": {"type": "Function", "def": "uint32_t lv_bezier3(uint32_t t, uint32_t u0, uint32_t u1, uint32_t u2, uint32_t u3)", "sline": 65}, "lv_atan2": {"type": "Function", "def": "uint16_t lv_atan2(int x, int y)", "sline": 73}, "lv_sqrt": {"type": "Function", "def": "void lv_sqrt(uint32_t x, lv_sqrt_res_t * q, uint32_t mask)", "sline": 87}, "lv_pow": {"type": "Function", "def": "int64_t lv_pow(int64_t base, int8_t exp)", "sline": 97}, "lv_map": {"type": "Function", "def": "int32_t lv_map(int32_t x, int32_t min_in, int32_t max_in, int32_t min_out, int32_t max_out)", "sline": 108}, "lv_rand": {"type": "Function", "def": "uint32_t lv_rand(uint32_t min, uint32_t max)", "sline": 116}, "carbit_updater/lvgl/src/misc/lv_math.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_math.h"}}, "carbit_updater/lvgl/src/misc/lv_style_gen.c": {"lv_style": {"type": "Variable", "def": "#include lv_style.h", "sline": 1, "include": ["carbit_updater/lvgl/src/misc/lv_style.h", null]}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 2}, "lv_style_set_width": {"type": "Function", "def": "void lv_style_set_width(lv_style_t * style, lv_coord_t value)", "sline": 3, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_WIDTH, v);\n}"}, "lv_style_set_min_width": {"type": "Function", "def": "void lv_style_set_min_width(lv_style_t * style, lv_coord_t value)", "sline": 11, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_MIN_WIDTH, v);\n}"}, "lv_style_set_max_width": {"type": "Function", "def": "void lv_style_set_max_width(lv_style_t * style, lv_coord_t value)", "sline": 19, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_MAX_WIDTH, v);\n}"}, "lv_style_set_height": {"type": "Function", "def": "void lv_style_set_height(lv_style_t * style, lv_coord_t value)", "sline": 27, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_HEIGHT, v);\n}"}, "lv_style_set_min_height": {"type": "Function", "def": "void lv_style_set_min_height(lv_style_t * style, lv_coord_t value)", "sline": 35, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_MIN_HEIGHT, v);\n}"}, "lv_style_set_max_height": {"type": "Function", "def": "void lv_style_set_max_height(lv_style_t * style, lv_coord_t value)", "sline": 43, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_MAX_HEIGHT, v);\n}"}, "lv_style_set_x": {"type": "Function", "def": "void lv_style_set_x(lv_style_t * style, lv_coord_t value)", "sline": 51, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_X, v);\n}"}, "lv_style_set_y": {"type": "Function", "def": "void lv_style_set_y(lv_style_t * style, lv_coord_t value)", "sline": 59, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_Y, v);\n}"}, "lv_style_set_align": {"type": "Function", "def": "void lv_style_set_align(lv_style_t * style, lv_align_t value)", "sline": 67, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_ALIGN, v);\n}"}, "lv_style_set_transform_width": {"type": "Function", "def": "void lv_style_set_transform_width(lv_style_t * style, lv_coord_t value)", "sline": 75, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_TRANSFORM_WIDTH, v);\n}"}, "lv_style_set_transform_height": {"type": "Function", "def": "void lv_style_set_transform_height(lv_style_t * style, lv_coord_t value)", "sline": 83, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_TRANSFORM_HEIGHT, v);\n}"}, "lv_style_set_translate_x": {"type": "Function", "def": "void lv_style_set_translate_x(lv_style_t * style, lv_coord_t value)", "sline": 91, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_TRANSLATE_X, v);\n}"}, "lv_style_set_translate_y": {"type": "Function", "def": "void lv_style_set_translate_y(lv_style_t * style, lv_coord_t value)", "sline": 99, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_TRANSLATE_Y, v);\n}"}, "lv_style_set_transform_zoom": {"type": "Function", "def": "void lv_style_set_transform_zoom(lv_style_t * style, lv_coord_t value)", "sline": 107, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_TRANSFORM_ZOOM, v);\n}"}, "lv_style_set_transform_angle": {"type": "Function", "def": "void lv_style_set_transform_angle(lv_style_t * style, lv_coord_t value)", "sline": 115, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_TRANSFORM_ANGLE, v);\n}"}, "lv_style_set_pad_top": {"type": "Function", "def": "void lv_style_set_pad_top(lv_style_t * style, lv_coord_t value)", "sline": 123, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_PAD_TOP, v);\n}"}, "lv_style_set_pad_bottom": {"type": "Function", "def": "void lv_style_set_pad_bottom(lv_style_t * style, lv_coord_t value)", "sline": 131, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_PAD_BOTTOM, v);\n}"}, "lv_style_set_pad_left": {"type": "Function", "def": "void lv_style_set_pad_left(lv_style_t * style, lv_coord_t value)", "sline": 139, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_PAD_LEFT, v);\n}"}, "lv_style_set_pad_right": {"type": "Function", "def": "void lv_style_set_pad_right(lv_style_t * style, lv_coord_t value)", "sline": 147, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_PAD_RIGHT, v);\n}"}, "lv_style_set_pad_row": {"type": "Function", "def": "void lv_style_set_pad_row(lv_style_t * style, lv_coord_t value)", "sline": 155, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_PAD_ROW, v);\n}"}, "lv_style_set_pad_column": {"type": "Function", "def": "void lv_style_set_pad_column(lv_style_t * style, lv_coord_t value)", "sline": 163, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_PAD_COLUMN, v);\n}"}, "lv_style_set_radius": {"type": "Function", "def": "void lv_style_set_radius(lv_style_t * style, lv_coord_t value)", "sline": 171, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_RADIUS, v);\n}"}, "lv_style_set_clip_corner": {"type": "Function", "def": "void lv_style_set_clip_corner(lv_style_t * style, bool value)", "sline": 179, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_CLIP_CORNER, v);\n}"}, "lv_style_set_opa": {"type": "Function", "def": "void lv_style_set_opa(lv_style_t * style, lv_opa_t value)", "sline": 187, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_OPA, v);\n}"}, "lv_style_set_color_filter_dsc": {"type": "Function", "def": "void lv_style_set_color_filter_dsc(lv_style_t * style, const lv_color_filter_dsc_t * value)", "sline": 195, "body": "{\n    lv_style_value_t v = {\n        .ptr = value\n    };\n    lv_style_set_prop(style, LV_STYLE_COLOR_FILTER_DSC, v);\n}"}, "lv_style_set_color_filter_opa": {"type": "Function", "def": "void lv_style_set_color_filter_opa(lv_style_t * style, lv_opa_t value)", "sline": 203, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_COLOR_FILTER_OPA, v);\n}"}, "lv_style_set_anim_time": {"type": "Function", "def": "void lv_style_set_anim_time(lv_style_t * style, uint32_t value)", "sline": 211, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_ANIM_TIME, v);\n}"}, "lv_style_set_anim_speed": {"type": "Function", "def": "void lv_style_set_anim_speed(lv_style_t * style, uint32_t value)", "sline": 219, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_ANIM_SPEED, v);\n}"}, "lv_style_set_transition": {"type": "Function", "def": "void lv_style_set_transition(lv_style_t * style, const lv_style_transition_dsc_t * value)", "sline": 227, "body": "{\n    lv_style_value_t v = {\n        .ptr = value\n    };\n    lv_style_set_prop(style, LV_STYLE_TRANSITION, v);\n}"}, "lv_style_set_blend_mode": {"type": "Function", "def": "void lv_style_set_blend_mode(lv_style_t * style, lv_blend_mode_t value)", "sline": 235, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_BLEND_MODE, v);\n}"}, "lv_style_set_layout": {"type": "Function", "def": "void lv_style_set_layout(lv_style_t * style, uint16_t value)", "sline": 243, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_LAYOUT, v);\n}"}, "lv_style_set_base_dir": {"type": "Function", "def": "void lv_style_set_base_dir(lv_style_t * style, lv_base_dir_t value)", "sline": 251, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_BASE_DIR, v);\n}"}, "lv_style_set_bg_color": {"type": "Function", "def": "void lv_style_set_bg_color(lv_style_t * style, lv_color_t value)", "sline": 259, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_style_set_prop(style, LV_STYLE_BG_COLOR, v);\n}"}, "lv_style_set_bg_color_filtered": {"type": "Function", "def": "void lv_style_set_bg_color_filtered(lv_style_t * style, lv_color_t value)", "sline": 267, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_style_set_prop(style, LV_STYLE_BG_COLOR_FILTERED, v);\n}"}, "lv_style_set_bg_opa": {"type": "Function", "def": "void lv_style_set_bg_opa(lv_style_t * style, lv_opa_t value)", "sline": 275, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_BG_OPA, v);\n}"}, "lv_style_set_bg_grad_color": {"type": "Function", "def": "void lv_style_set_bg_grad_color(lv_style_t * style, lv_color_t value)", "sline": 283, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_style_set_prop(style, LV_STYLE_BG_GRAD_COLOR, v);\n}"}, "lv_style_set_bg_grad_color_filtered": {"type": "Function", "def": "void lv_style_set_bg_grad_color_filtered(lv_style_t * style, lv_color_t value)", "sline": 291, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_style_set_prop(style, LV_STYLE_BG_GRAD_COLOR_FILTERED, v);\n}"}, "lv_style_set_bg_grad_dir": {"type": "Function", "def": "void lv_style_set_bg_grad_dir(lv_style_t * style, lv_grad_dir_t value)", "sline": 299, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_BG_GRAD_DIR, v);\n}"}, "lv_style_set_bg_main_stop": {"type": "Function", "def": "void lv_style_set_bg_main_stop(lv_style_t * style, lv_coord_t value)", "sline": 307, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_BG_MAIN_STOP, v);\n}"}, "lv_style_set_bg_grad_stop": {"type": "Function", "def": "void lv_style_set_bg_grad_stop(lv_style_t * style, lv_coord_t value)", "sline": 315, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_BG_GRAD_STOP, v);\n}"}, "lv_style_set_bg_img_src": {"type": "Function", "def": "void lv_style_set_bg_img_src(lv_style_t * style, const void * value)", "sline": 323, "body": "{\n    lv_style_value_t v = {\n        .ptr = value\n    };\n    lv_style_set_prop(style, LV_STYLE_BG_IMG_SRC, v);\n}"}, "lv_style_set_bg_img_opa": {"type": "Function", "def": "void lv_style_set_bg_img_opa(lv_style_t * style, lv_opa_t value)", "sline": 331, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_BG_IMG_OPA, v);\n}"}, "lv_style_set_bg_img_recolor": {"type": "Function", "def": "void lv_style_set_bg_img_recolor(lv_style_t * style, lv_color_t value)", "sline": 339, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_style_set_prop(style, LV_STYLE_BG_IMG_RECOLOR, v);\n}"}, "lv_style_set_bg_img_recolor_filtered": {"type": "Function", "def": "void lv_style_set_bg_img_recolor_filtered(lv_style_t * style, lv_color_t value)", "sline": 347, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_style_set_prop(style, LV_STYLE_BG_IMG_RECOLOR_FILTERED, v);\n}"}, "lv_style_set_bg_img_recolor_opa": {"type": "Function", "def": "void lv_style_set_bg_img_recolor_opa(lv_style_t * style, lv_opa_t value)", "sline": 355, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_BG_IMG_RECOLOR_OPA, v);\n}"}, "lv_style_set_bg_img_tiled": {"type": "Function", "def": "void lv_style_set_bg_img_tiled(lv_style_t * style, bool value)", "sline": 363, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_BG_IMG_TILED, v);\n}"}, "lv_style_set_border_color": {"type": "Function", "def": "void lv_style_set_border_color(lv_style_t * style, lv_color_t value)", "sline": 371, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_style_set_prop(style, LV_STYLE_BORDER_COLOR, v);\n}"}, "lv_style_set_border_color_filtered": {"type": "Function", "def": "void lv_style_set_border_color_filtered(lv_style_t * style, lv_color_t value)", "sline": 379, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_style_set_prop(style, LV_STYLE_BORDER_COLOR_FILTERED, v);\n}"}, "lv_style_set_border_opa": {"type": "Function", "def": "void lv_style_set_border_opa(lv_style_t * style, lv_opa_t value)", "sline": 387, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_BORDER_OPA, v);\n}"}, "lv_style_set_border_width": {"type": "Function", "def": "void lv_style_set_border_width(lv_style_t * style, lv_coord_t value)", "sline": 395, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_BORDER_WIDTH, v);\n}"}, "lv_style_set_border_side": {"type": "Function", "def": "void lv_style_set_border_side(lv_style_t * style, lv_border_side_t value)", "sline": 403, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_BORDER_SIDE, v);\n}"}, "lv_style_set_border_post": {"type": "Function", "def": "void lv_style_set_border_post(lv_style_t * style, bool value)", "sline": 411, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_BORDER_POST, v);\n}"}, "lv_style_set_text_color": {"type": "Function", "def": "void lv_style_set_text_color(lv_style_t * style, lv_color_t value)", "sline": 419, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_style_set_prop(style, LV_STYLE_TEXT_COLOR, v);\n}"}, "lv_style_set_text_color_filtered": {"type": "Function", "def": "void lv_style_set_text_color_filtered(lv_style_t * style, lv_color_t value)", "sline": 427, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_style_set_prop(style, LV_STYLE_TEXT_COLOR_FILTERED, v);\n}"}, "lv_style_set_text_opa": {"type": "Function", "def": "void lv_style_set_text_opa(lv_style_t * style, lv_opa_t value)", "sline": 435, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_TEXT_OPA, v);\n}"}, "lv_style_set_text_font": {"type": "Function", "def": "void lv_style_set_text_font(lv_style_t * style, const lv_font_t * value)", "sline": 443, "body": "{\n    lv_style_value_t v = {\n        .ptr = value\n    };\n    lv_style_set_prop(style, LV_STYLE_TEXT_FONT, v);\n}"}, "lv_style_set_text_letter_space": {"type": "Function", "def": "void lv_style_set_text_letter_space(lv_style_t * style, lv_coord_t value)", "sline": 451, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_TEXT_LETTER_SPACE, v);\n}"}, "lv_style_set_text_line_space": {"type": "Function", "def": "void lv_style_set_text_line_space(lv_style_t * style, lv_coord_t value)", "sline": 459, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_TEXT_LINE_SPACE, v);\n}"}, "lv_style_set_text_decor": {"type": "Function", "def": "void lv_style_set_text_decor(lv_style_t * style, lv_text_decor_t value)", "sline": 467, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_TEXT_DECOR, v);\n}"}, "lv_style_set_text_align": {"type": "Function", "def": "void lv_style_set_text_align(lv_style_t * style, lv_text_align_t value)", "sline": 475, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_TEXT_ALIGN, v);\n}"}, "lv_style_set_img_opa": {"type": "Function", "def": "void lv_style_set_img_opa(lv_style_t * style, lv_opa_t value)", "sline": 483, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_IMG_OPA, v);\n}"}, "lv_style_set_img_recolor": {"type": "Function", "def": "void lv_style_set_img_recolor(lv_style_t * style, lv_color_t value)", "sline": 491, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_style_set_prop(style, LV_STYLE_IMG_RECOLOR, v);\n}"}, "lv_style_set_img_recolor_filtered": {"type": "Function", "def": "void lv_style_set_img_recolor_filtered(lv_style_t * style, lv_color_t value)", "sline": 499, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_style_set_prop(style, LV_STYLE_IMG_RECOLOR_FILTERED, v);\n}"}, "lv_style_set_img_recolor_opa": {"type": "Function", "def": "void lv_style_set_img_recolor_opa(lv_style_t * style, lv_opa_t value)", "sline": 507, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_IMG_RECOLOR_OPA, v);\n}"}, "lv_style_set_outline_width": {"type": "Function", "def": "void lv_style_set_outline_width(lv_style_t * style, lv_coord_t value)", "sline": 515, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_OUTLINE_WIDTH, v);\n}"}, "lv_style_set_outline_color": {"type": "Function", "def": "void lv_style_set_outline_color(lv_style_t * style, lv_color_t value)", "sline": 523, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_style_set_prop(style, LV_STYLE_OUTLINE_COLOR, v);\n}"}, "lv_style_set_outline_color_filtered": {"type": "Function", "def": "void lv_style_set_outline_color_filtered(lv_style_t * style, lv_color_t value)", "sline": 531, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_style_set_prop(style, LV_STYLE_OUTLINE_COLOR_FILTERED, v);\n}"}, "lv_style_set_outline_opa": {"type": "Function", "def": "void lv_style_set_outline_opa(lv_style_t * style, lv_opa_t value)", "sline": 539, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_OUTLINE_OPA, v);\n}"}, "lv_style_set_outline_pad": {"type": "Function", "def": "void lv_style_set_outline_pad(lv_style_t * style, lv_coord_t value)", "sline": 547, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_OUTLINE_PAD, v);\n}"}, "lv_style_set_shadow_width": {"type": "Function", "def": "void lv_style_set_shadow_width(lv_style_t * style, lv_coord_t value)", "sline": 555, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_SHADOW_WIDTH, v);\n}"}, "lv_style_set_shadow_ofs_x": {"type": "Function", "def": "void lv_style_set_shadow_ofs_x(lv_style_t * style, lv_coord_t value)", "sline": 563, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_SHADOW_OFS_X, v);\n}"}, "lv_style_set_shadow_ofs_y": {"type": "Function", "def": "void lv_style_set_shadow_ofs_y(lv_style_t * style, lv_coord_t value)", "sline": 571, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_SHADOW_OFS_Y, v);\n}"}, "lv_style_set_shadow_spread": {"type": "Function", "def": "void lv_style_set_shadow_spread(lv_style_t * style, lv_coord_t value)", "sline": 579, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_SHADOW_SPREAD, v);\n}"}, "lv_style_set_shadow_color": {"type": "Function", "def": "void lv_style_set_shadow_color(lv_style_t * style, lv_color_t value)", "sline": 587, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_style_set_prop(style, LV_STYLE_SHADOW_COLOR, v);\n}"}, "lv_style_set_shadow_color_filtered": {"type": "Function", "def": "void lv_style_set_shadow_color_filtered(lv_style_t * style, lv_color_t value)", "sline": 595, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_style_set_prop(style, LV_STYLE_SHADOW_COLOR_FILTERED, v);\n}"}, "lv_style_set_shadow_opa": {"type": "Function", "def": "void lv_style_set_shadow_opa(lv_style_t * style, lv_opa_t value)", "sline": 603, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_SHADOW_OPA, v);\n}"}, "lv_style_set_line_width": {"type": "Function", "def": "void lv_style_set_line_width(lv_style_t * style, lv_coord_t value)", "sline": 611, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_LINE_WIDTH, v);\n}"}, "lv_style_set_line_dash_width": {"type": "Function", "def": "void lv_style_set_line_dash_width(lv_style_t * style, lv_coord_t value)", "sline": 619, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_LINE_DASH_WIDTH, v);\n}"}, "lv_style_set_line_dash_gap": {"type": "Function", "def": "void lv_style_set_line_dash_gap(lv_style_t * style, lv_coord_t value)", "sline": 627, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_LINE_DASH_GAP, v);\n}"}, "lv_style_set_line_rounded": {"type": "Function", "def": "void lv_style_set_line_rounded(lv_style_t * style, bool value)", "sline": 635, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_LINE_ROUNDED, v);\n}"}, "lv_style_set_line_color": {"type": "Function", "def": "void lv_style_set_line_color(lv_style_t * style, lv_color_t value)", "sline": 643, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_style_set_prop(style, LV_STYLE_LINE_COLOR, v);\n}"}, "lv_style_set_line_color_filtered": {"type": "Function", "def": "void lv_style_set_line_color_filtered(lv_style_t * style, lv_color_t value)", "sline": 651, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_style_set_prop(style, LV_STYLE_LINE_COLOR_FILTERED, v);\n}"}, "lv_style_set_line_opa": {"type": "Function", "def": "void lv_style_set_line_opa(lv_style_t * style, lv_opa_t value)", "sline": 659, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_LINE_OPA, v);\n}"}, "lv_style_set_arc_width": {"type": "Function", "def": "void lv_style_set_arc_width(lv_style_t * style, lv_coord_t value)", "sline": 667, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_ARC_WIDTH, v);\n}"}, "lv_style_set_arc_rounded": {"type": "Function", "def": "void lv_style_set_arc_rounded(lv_style_t * style, bool value)", "sline": 675, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_ARC_ROUNDED, v);\n}"}, "lv_style_set_arc_color": {"type": "Function", "def": "void lv_style_set_arc_color(lv_style_t * style, lv_color_t value)", "sline": 683, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_style_set_prop(style, LV_STYLE_ARC_COLOR, v);\n}"}, "lv_style_set_arc_color_filtered": {"type": "Function", "def": "void lv_style_set_arc_color_filtered(lv_style_t * style, lv_color_t value)", "sline": 691, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_style_set_prop(style, LV_STYLE_ARC_COLOR_FILTERED, v);\n}"}, "lv_style_set_arc_opa": {"type": "Function", "def": "void lv_style_set_arc_opa(lv_style_t * style, lv_opa_t value)", "sline": 699, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_ARC_OPA, v);\n}"}, "lv_style_set_arc_img_src": {"type": "Function", "def": "void lv_style_set_arc_img_src(lv_style_t * style, const void * value)", "sline": 707, "body": "{\n    lv_style_value_t v = {\n        .ptr = value\n    };\n    lv_style_set_prop(style, LV_STYLE_ARC_IMG_SRC, v);\n}"}, "carbit_updater/lvgl/src/misc/lv_style_gen.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_style_gen.c"}}, "carbit_updater/lvgl/src/draw/lv_draw_rect.c": {"lv_draw_rect": {"type": "Function", "def": "void lv_draw_rect(const lv_area_t * coords, const lv_area_t * clip, const lv_draw_rect_dsc_t * dsc)", "sline": 101, "body": "{\n    if(lv_area_get_height(coords) < 1 || lv_area_get_width(coords) < 1) return;\n#if LV_DRAW_COMPLEX\n    draw_shadow(coords, clip, dsc);\n#endif\n\n    draw_bg(coords, clip, dsc);\n    draw_bg_img(coords, clip, dsc);\n\n    draw_border(coords, clip, dsc);\n\n    draw_outline(coords, clip, dsc);\n\n    LV_ASSERT_MEM_INTEGRITY();\n}"}, "lv_draw_blend": {"type": "Variable", "def": "#include lv_draw_blend.h", "sline": 10, "include": ["carbit_updater/lvgl/src/draw/lv_draw_blend.h", null]}, "lv_draw_mask": {"type": "Variable", "def": "#include lv_draw_mask.h", "sline": 11, "include": ["carbit_updater/lvgl/src/draw/lv_draw_mask.h", null]}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 12}, "lv_txt_ap": {"type": "Variable", "def": "#include ../misc/lv_txt_ap.h", "sline": 13}, "lv_refr": {"type": "Variable", "def": "#include ../core/lv_refr.h", "sline": 14}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 15}, "draw_bg": {"type": "Function", "def": "static void draw_bg(const lv_area_t * coords, const lv_area_t * clip_area,\n                                          const lv_draw_rect_dsc_t * dsc)", "sline": 122, "body": "{\n    if(dsc->bg_opa <= LV_OPA_MIN) return;\n\n    lv_area_t coords_bg;\n    lv_area_copy(&coords_bg, coords);\n\n    /*If the border fully covers make the bg area 1px smaller to avoid artifacts on the corners*/\n    if(dsc->border_width > 1 && dsc->border_opa >= LV_OPA_MAX && dsc->radius != 0) {\n        coords_bg.x1 += (dsc->border_side & LV_BORDER_SIDE_LEFT) ? 1 : 0;\n        coords_bg.y1 += (dsc->border_side & LV_BORDER_SIDE_TOP) ? 1 : 0;\n        coords_bg.x2 -= (dsc->border_side & LV_BORDER_SIDE_RIGHT) ? 1 : 0;\n        coords_bg.y2 -= (dsc->border_side & LV_BORDER_SIDE_BOTTOM) ? 1 : 0;\n    }\n\n    lv_opa_t opa = dsc->bg_opa >= LV_OPA_MAX ? LV_OPA_COVER : dsc->bg_opa;\n    lv_grad_dir_t grad_dir = dsc->bg_grad_dir;\n    if(dsc->bg_color.full == dsc->bg_grad_color.full) grad_dir = LV_GRAD_DIR_NONE;\n\n    bool mask_any = lv_draw_mask_is_any(&coords_bg);\n\n    /*Most simple case: just a plain rectangle*/\n    if(!mask_any && dsc->radius == 0 && (grad_dir == LV_GRAD_DIR_NONE)) {\n        _lv_blend_fill(clip_area, &coords_bg, dsc->bg_color, NULL,\n                       LV_DRAW_MASK_RES_FULL_COVER, opa, dsc->blend_mode);\n        return;\n    }\n\n    /*Complex case: there is gradient, mask, or radius*/\n#if LV_DRAW_COMPLEX == 0\n    LV_LOG_WARN(\"Can't draw complex rectangle because LV_DRAW_COMPLEX = 0\");\n#else\n    /*Get clipped fill area which is the real draw area.\n     *It is always the same or inside `fill_area`*/\n    lv_area_t draw_area;\n    if(!_lv_area_intersect(&draw_area, &coords_bg, clip_area)) return;\n\n    /*Get the real radius. Can't be larger than the half of the shortest side */\n    lv_coord_t coords_w = lv_area_get_width(&coords_bg);\n    lv_coord_t coords_h = lv_area_get_height(&coords_bg);\n    int32_t short_side = LV_MIN(coords_w, coords_h);\n    int32_t rout = LV_MIN(dsc->radius, short_side >> 1);\n\n    /*Add a radius mask if there is radius*/\n    int32_t draw_area_w = lv_area_get_width(&draw_area);\n    int16_t mask_rout_id = LV_MASK_ID_INV;\n    lv_opa_t * mask_buf = NULL;\n    lv_draw_mask_radius_param_t mask_rout_param;\n    if(rout > 0 || mask_any) {\n        mask_buf = lv_mem_buf_get(draw_area_w);\n        lv_draw_mask_radius_init(&mask_rout_param, &coords_bg, rout, false);\n        mask_rout_id = lv_draw_mask_add(&mask_rout_param, NULL);\n    }\n\n    /*In case of horizontal gradient pre-compute a line with a gradient*/\n    lv_color_t * grad_map = NULL;\n    lv_color_t * grad_map_ofs = NULL;\n    if(grad_dir == LV_GRAD_DIR_HOR) {\n        grad_map = lv_mem_buf_get(coords_w * sizeof(lv_color_t));\n        int32_t i;\n        for(i = 0; i < coords_w; i++) {\n            grad_map[i] = grad_get(dsc, coords_w, i);\n        }\n        grad_map_ofs = grad_map;\n        if(dsc->bg_grad_dir == LV_GRAD_DIR_HOR) grad_map_ofs += draw_area.x1 - coords_bg.x1;\n    }\n\n    int32_t h;\n    lv_draw_mask_res_t mask_res;\n    lv_area_t blend_area;\n    blend_area.x1 = draw_area.x1;\n    blend_area.x2 = draw_area.x2;\n\n    /*There is another mask too. Draw line by line. */\n    if(mask_any) {\n        for(h = draw_area.y1; h <= draw_area.y2; h++) {\n            blend_area.y1 = h;\n            blend_area.y2 = h;\n\n            /* Initialize the mask to opa instead of 0xFF and blend with LV_OPA_COVER.\n             * It saves calculating the final opa in _lv_blend_fill*/\n            lv_memset(mask_buf, opa, draw_area_w);\n            mask_res = lv_draw_mask_apply(mask_buf, draw_area.x1, h, draw_area_w);\n            if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;\n\n            if(grad_dir == LV_GRAD_DIR_NONE) {\n                _lv_blend_fill(clip_area, &blend_area, dsc->bg_color, mask_buf, mask_res, LV_OPA_COVER, dsc->blend_mode);\n            }\n            else if(grad_dir == LV_GRAD_DIR_HOR) {\n                _lv_blend_map(clip_area, &blend_area, grad_map_ofs, mask_buf, mask_res, LV_OPA_COVER, dsc->blend_mode);\n            }\n            else if(grad_dir == LV_GRAD_DIR_VER) {\n                lv_color_t c = grad_get(dsc, coords_h, h - coords_bg.y1);\n                _lv_blend_fill(clip_area, &blend_area, c, mask_buf, mask_res, LV_OPA_COVER, dsc->blend_mode);\n            }\n        }\n        goto bg_clean_up;\n    }\n\n\n    /* Draw the top of the rectangle line by line and mirror it to the bottom.\n     * If there is no radius this cycle won't run because `h` is always `>= h_end`*/\n    blend_area.x1 = draw_area.x1;\n    blend_area.x2 = draw_area.x2;\n    for(h = 0; h < rout; h++) {\n        lv_coord_t top_y = coords_bg.y1 + h;\n        lv_coord_t bottom_y = coords_bg.y2 - h;\n        if(top_y < draw_area.y1 && bottom_y > draw_area.y2) continue;   /*This line is clipped now*/\n\n        /* Initialize the mask to opa instead of 0xFF and blend with LV_OPA_COVER.\n         * It saves calculating the final opa in _lv_blend_fill*/\n        lv_memset(mask_buf, opa, draw_area_w);\n        mask_res = lv_draw_mask_apply(mask_buf, blend_area.x1, top_y, draw_area_w);\n\n        if(top_y >= draw_area.y1) {\n            blend_area.y1 = top_y;\n            blend_area.y2 = top_y;\n\n            if(grad_dir == LV_GRAD_DIR_NONE) {\n                _lv_blend_fill(clip_area, &blend_area, dsc->bg_color, mask_buf, mask_res, LV_OPA_COVER, dsc->blend_mode);\n            }\n            else if(grad_dir == LV_GRAD_DIR_HOR) {\n                _lv_blend_map(clip_area, &blend_area, grad_map_ofs, mask_buf, mask_res, LV_OPA_COVER, dsc->blend_mode);\n            }\n            else if(grad_dir == LV_GRAD_DIR_VER) {\n                lv_color_t c = grad_get(dsc, coords_h, top_y - coords_bg.y1);\n                _lv_blend_fill(clip_area, &blend_area, c, mask_buf, mask_res, LV_OPA_COVER, dsc->blend_mode);\n            }\n        }\n\n        if(bottom_y <= draw_area.y2) {\n            blend_area.y1 = bottom_y;\n            blend_area.y2 = bottom_y;\n\n            if(grad_dir == LV_GRAD_DIR_NONE) {\n                _lv_blend_fill(clip_area, &blend_area, dsc->bg_color, mask_buf, mask_res, LV_OPA_COVER, dsc->blend_mode);\n            }\n            else if(grad_dir == LV_GRAD_DIR_HOR) {\n                _lv_blend_map(clip_area, &blend_area, grad_map_ofs, mask_buf, mask_res, LV_OPA_COVER, dsc->blend_mode);\n            }\n            else if(grad_dir == LV_GRAD_DIR_VER) {\n                lv_color_t c = grad_get(dsc, coords_h, bottom_y - coords_bg.y1);\n                _lv_blend_fill(clip_area, &blend_area, c, mask_buf, mask_res, LV_OPA_COVER, dsc->blend_mode);\n            }\n        }\n    }\n\n    /* Draw the center of the rectangle.*/\n\n    /*If no other masks and no gradient, the center is a simple rectangle*/\n    if(!mask_any && grad_dir == LV_GRAD_DIR_NONE) {\n        blend_area.y1 = coords_bg.y1 + rout;\n        blend_area.y2 = coords_bg.y2 - rout;\n        _lv_blend_fill(clip_area, &blend_area, dsc->bg_color, mask_buf, LV_DRAW_MASK_RES_FULL_COVER, opa, dsc->blend_mode);\n    }\n    /*With gradient and/or mask draw line by line*/\n    else {\n        mask_res = LV_DRAW_MASK_RES_FULL_COVER;\n        int32_t h_end = coords_bg.y2 - rout;\n        for(h = coords_bg.y1 + rout; h <= h_end; h++) {\n            /*If there is no other mask do not apply mask as in the center there is no radius to mask*/\n            if(mask_any) {\n                lv_memset_ff(mask_buf, draw_area_w);\n                mask_res = lv_draw_mask_apply(mask_buf, draw_area.x1, h, draw_area_w);\n            }\n\n            blend_area.y1 = h;\n            blend_area.y2 = h;\n            if(grad_dir == LV_GRAD_DIR_NONE) {\n                _lv_blend_fill(clip_area, &blend_area, dsc->bg_color, mask_buf, mask_res, opa, dsc->blend_mode);\n            }\n            else if(grad_dir == LV_GRAD_DIR_HOR) {\n                _lv_blend_map(clip_area, &blend_area, grad_map_ofs, mask_buf, mask_res, opa, dsc->blend_mode);\n            }\n            else if(grad_dir == LV_GRAD_DIR_VER) {\n                lv_color_t c = grad_get(dsc, coords_h, h - coords_bg.y1);\n                _lv_blend_fill(clip_area, &blend_area, c, mask_buf, mask_res, opa, dsc->blend_mode);\n            }\n        }\n    }\n\n\nbg_clean_up:\n    if(grad_map) lv_mem_buf_release(grad_map);\n    if(mask_buf) lv_mem_buf_release(mask_buf);\n    if(mask_rout_id != LV_MASK_ID_INV) {\n        lv_draw_mask_remove_id(mask_rout_id);\n        lv_draw_mask_free_param(&mask_rout_param);\n    }\n\n#endif\n}"}, "draw_bg_img": {"type": "Function", "def": "static void draw_bg_img(const lv_area_t * coords, const lv_area_t * clip,\n                                              const lv_draw_rect_dsc_t * dsc)", "sline": 316, "body": "{\n    if(dsc->bg_img_src == NULL) return;\n    if(dsc->bg_img_opa <= LV_OPA_MIN) return;\n\n    lv_img_src_t src_type = lv_img_src_get_type(dsc->bg_img_src);\n    if(src_type == LV_IMG_SRC_SYMBOL) {\n        lv_point_t size;\n        lv_txt_get_size(&size, dsc->bg_img_src, dsc->bg_img_symbol_font, 0, 0, LV_COORD_MAX, LV_TEXT_FLAG_NONE);\n        lv_area_t a;\n        a.x1 = coords->x1 + lv_area_get_width(coords) / 2 - size.x / 2;\n        a.x2 = a.x1 + size.x - 1;\n        a.y1 = coords->y1 + lv_area_get_height(coords) / 2 - size.y / 2;\n        a.y2 = a.y1 + size.y - 1;\n\n        lv_draw_label_dsc_t label_draw_dsc;\n        lv_draw_label_dsc_init(&label_draw_dsc);\n        label_draw_dsc.font = dsc->bg_img_symbol_font;\n        label_draw_dsc.color = dsc->bg_img_recolor;\n        label_draw_dsc.opa = dsc->bg_img_opa;\n        lv_draw_label(&a, clip, &label_draw_dsc, dsc->bg_img_src, NULL);\n    }\n    else {\n        lv_img_header_t header;\n        lv_res_t res = lv_img_decoder_get_info(dsc->bg_img_src, &header);\n        if(res != LV_RES_OK) {\n            LV_LOG_WARN(\"Couldn't read the background image\");\n            return;\n        }\n\n        lv_draw_img_dsc_t img_dsc;\n        lv_draw_img_dsc_init(&img_dsc);\n        img_dsc.blend_mode = dsc->blend_mode;\n        img_dsc.recolor = dsc->bg_img_recolor;\n        img_dsc.recolor_opa = dsc->bg_img_recolor_opa;\n        img_dsc.opa = dsc->bg_img_opa;\n\n        /*Center align*/\n        if(dsc->bg_img_tiled == false) {\n            lv_area_t area;\n            area.x1 = coords->x1 + lv_area_get_width(coords) / 2 - header.w / 2;\n            area.y1 = coords->y1 + lv_area_get_height(coords) / 2 - header.h / 2;\n            area.x2 = area.x1 + header.w - 1;\n            area.y2 = area.y1 + header.h - 1;\n\n            lv_draw_img(&area, clip, dsc->bg_img_src, &img_dsc);\n        }\n        else {\n            lv_area_t area;\n            area.y1 = coords->y1;\n            area.y2 = area.y1 + header.h - 1;\n\n            for(; area.y1 <= coords->y2; area.y1 += header.h, area.y2 += header.h) {\n\n                area.x1 = coords->x1;\n                area.x2 = area.x1 + header.w - 1;\n                for(; area.x1 <= coords->x2; area.x1 += header.w, area.x2 += header.w) {\n                    lv_draw_img(&area, clip, dsc->bg_img_src, &img_dsc);\n                }\n            }\n        }\n    }\n}"}, "draw_border": {"type": "Function", "def": "static void draw_border(const lv_area_t * coords, const lv_area_t * clip,\n                                              const lv_draw_rect_dsc_t * dsc)", "sline": 381, "body": "{\n    if(dsc->border_opa <= LV_OPA_MIN) return;\n    if(dsc->border_width == 0) return;\n    if(dsc->border_side == LV_BORDER_SIDE_NONE) return;\n    if(dsc->border_post) return;\n\n    int32_t coords_w = lv_area_get_width(coords);\n    int32_t coords_h = lv_area_get_height(coords);\n    int32_t rout = dsc->radius;\n    int32_t short_side = LV_MIN(coords_w, coords_h);\n    if(rout > short_side >> 1) rout = short_side >> 1;\n\n    /*Get the inner area*/\n    lv_area_t area_inner;\n    lv_area_copy(&area_inner, coords);\n    area_inner.x1 += ((dsc->border_side & LV_BORDER_SIDE_LEFT) ? dsc->border_width : - (dsc->border_width + rout));\n    area_inner.x2 -= ((dsc->border_side & LV_BORDER_SIDE_RIGHT) ? dsc->border_width : - (dsc->border_width + rout));\n    area_inner.y1 += ((dsc->border_side & LV_BORDER_SIDE_TOP) ? dsc->border_width : - (dsc->border_width + rout));\n    area_inner.y2 -= ((dsc->border_side & LV_BORDER_SIDE_BOTTOM) ? dsc->border_width : - (dsc->border_width + rout));\n\n    lv_coord_t rin = rout - dsc->border_width;\n    if(rin < 0) rin = 0;\n\n    draw_border_generic(clip, coords, &area_inner, rout, rin, dsc->border_color, dsc->border_opa, dsc->blend_mode);\n\n}"}, "draw_outline": {"type": "Function", "def": "static void draw_outline(const lv_area_t * coords, const lv_area_t * clip, const lv_draw_rect_dsc_t * dsc)", "sline": 1041, "body": "{\n    if(dsc->outline_opa <= LV_OPA_MIN) return;\n    if(dsc->outline_width == 0) return;\n\n    lv_opa_t opa = dsc->outline_opa;\n\n    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;\n\n    /*Get the inner radius*/\n    lv_area_t area_inner;\n    lv_area_copy(&area_inner, coords);\n\n    /*Extend the outline into the background area if it's overlapping the edge*/\n    lv_coord_t pad = (dsc->outline_pad == 0 ? (dsc->outline_pad - 1) : dsc->outline_pad);\n    area_inner.x1 -= pad;\n    area_inner.y1 -= pad;\n    area_inner.x2 += pad;\n    area_inner.y2 += pad;\n\n    lv_area_t area_outer;\n    lv_area_copy(&area_outer, &area_inner);\n\n    area_outer.x1 -= dsc->outline_width;\n    area_outer.x2 += dsc->outline_width;\n    area_outer.y1 -= dsc->outline_width;\n    area_outer.y2 += dsc->outline_width;\n\n\n    int32_t inner_w = lv_area_get_width(&area_inner);\n    int32_t inner_h = lv_area_get_height(&area_inner);\n    int32_t rin = dsc->radius;\n    int32_t short_side = LV_MIN(inner_w, inner_h);\n    if(rin > short_side >> 1) rin = short_side >> 1;\n\n    lv_coord_t rout = rin + dsc->outline_width;\n\n    draw_border_generic(clip, &area_outer, &area_inner, rout, rin, dsc->outline_color, dsc->outline_opa, dsc->blend_mode);\n}"}, "draw_shadow": {"type": "Function", "def": "static void draw_shadow(const lv_area_t * coords, const lv_area_t * clip,\n                                              const lv_draw_rect_dsc_t * dsc)", "sline": 427, "body": "{\n    /*Check whether the shadow is visible*/\n    if(dsc->shadow_width == 0) return;\n    if(dsc->shadow_opa <= LV_OPA_MIN) return;\n\n    if(dsc->shadow_width == 1 && dsc->shadow_spread <= 0 &&\n       dsc->shadow_ofs_x == 0 && dsc->shadow_ofs_y == 0) {\n        return;\n    }\n\n    /*Calculate the rectangle which is blurred to get the shadow in `shadow_area`*/\n    lv_area_t core_area;\n    core_area.x1 = coords->x1  + dsc->shadow_ofs_x - dsc->shadow_spread;\n    core_area.x2 = coords->x2  + dsc->shadow_ofs_x + dsc->shadow_spread;\n    core_area.y1 = coords->y1  + dsc->shadow_ofs_y - dsc->shadow_spread;\n    core_area.y2 = coords->y2  + dsc->shadow_ofs_y + dsc->shadow_spread;\n\n    /*Calculate the bounding box of the shadow*/\n    lv_area_t shadow_area;\n    shadow_area.x1 = core_area.x1 - dsc->shadow_width / 2 - 1;\n    shadow_area.x2 = core_area.x2 + dsc->shadow_width / 2 + 1;\n    shadow_area.y1 = core_area.y1 - dsc->shadow_width / 2 - 1;\n    shadow_area.y2 = core_area.y2 + dsc->shadow_width / 2 + 1;\n\n    lv_opa_t opa = dsc->shadow_opa;\n    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;\n\n    /*Get clipped draw area which is the real draw area.\n     *It is always the same or inside `shadow_area`*/\n    lv_area_t draw_area;\n    if(!_lv_area_intersect(&draw_area, &shadow_area, clip)) return;\n\n    /*Consider 1 px smaller bg to be sure the edge will be covered by the shadow*/\n    lv_area_t bg_area;\n    lv_area_copy(&bg_area, coords);\n    lv_area_increase(&bg_area, -1, -1);\n\n    /*Get the clamped radius*/\n    int32_t r_bg = dsc->radius;\n    lv_coord_t short_side = LV_MIN(lv_area_get_width(&bg_area), lv_area_get_height(&bg_area));\n    if(r_bg > short_side >> 1) r_bg = short_side >> 1;\n\n    /*Get the clamped radius*/\n    int32_t r_sh = dsc->radius;\n    short_side = LV_MIN(lv_area_get_width(&core_area), lv_area_get_height(&core_area));\n    if(r_sh > short_side >> 1) r_sh = short_side >> 1;\n\n    /*Get how many pixels are affected by the blur on the corners*/\n    int32_t corner_size = dsc->shadow_width  + r_sh;\n\n    lv_opa_t * sh_buf;\n\n#if LV_SHADOW_CACHE_SIZE\n    if(sh_cache_size == corner_size && sh_cache_r == r_sh) {\n        /*Use the cache if available*/\n        sh_buf = lv_mem_buf_get(corner_size * corner_size);\n        lv_memcpy(sh_buf, sh_cache, corner_size * corner_size);\n    }\n    else {\n        /*A larger buffer is required for calculation*/\n        sh_buf = lv_mem_buf_get(corner_size * corner_size * sizeof(uint16_t));\n        shadow_draw_corner_buf(&core_area, (uint16_t *)sh_buf, dsc->shadow_width, r_sh);\n\n        /*Cache the corner if it fits into the cache size*/\n        if((uint32_t)corner_size * corner_size < sizeof(sh_cache)) {\n            lv_memcpy(sh_cache, sh_buf, corner_size * corner_size);\n            sh_cache_size = corner_size;\n            sh_cache_r = r_sh;\n        }\n    }\n#else\n    sh_buf = lv_mem_buf_get(corner_size * corner_size * sizeof(uint16_t));\n    shadow_draw_corner_buf(&core_area, (uint16_t *)sh_buf, dsc->shadow_width, r_sh);\n#endif\n\n    /*Skip a lot of masking if the background will cover the shadow that would be masked out*/\n    bool mask_any = lv_draw_mask_is_any(&shadow_area);\n    bool simple = true;\n    if(mask_any || dsc->bg_opa < LV_OPA_COVER) simple = false;\n\n    /*Create a radius mask to clip remove shadow on the bg area*/\n    lv_draw_mask_res_t mask_res;\n\n    lv_draw_mask_radius_param_t mask_rout_param;\n    int16_t mask_rout_id = LV_MASK_ID_INV;\n    if(!simple) {\n        lv_draw_mask_radius_init(&mask_rout_param, &bg_area, r_bg, true);\n        mask_rout_id = lv_draw_mask_add(&mask_rout_param, NULL);\n    }\n    lv_opa_t * mask_buf = lv_mem_buf_get(lv_area_get_width(&shadow_area));\n    lv_area_t blend_area;\n    lv_area_t clip_area_sub;\n    lv_opa_t ** mask_act;\n    lv_opa_t * sh_buf_tmp;\n    lv_coord_t y;\n    bool simple_sub;\n\n    lv_coord_t w_half = shadow_area.x1 + lv_area_get_width(&shadow_area) / 2;\n    lv_coord_t h_half = shadow_area.y1 + lv_area_get_height(&shadow_area) / 2;\n\n    /*Draw the corners if they are on the current clip area and not fully covered by the bg*/\n\n    /*Top right corner*/\n    blend_area.x2 = shadow_area.x2;\n    blend_area.x1 = shadow_area.x2 - corner_size + 1;\n    blend_area.y1 = shadow_area.y1;\n    blend_area.y2 = shadow_area.y1 + corner_size - 1;\n    /*Do not overdraw the top other corners*/\n    blend_area.x1 = LV_MAX(blend_area.x1, w_half);\n    blend_area.y2 = LV_MIN(blend_area.y2, h_half);\n\n    if(_lv_area_intersect(&clip_area_sub, &blend_area, clip) && !_lv_area_is_in(&clip_area_sub, &bg_area, r_bg)) {\n        lv_coord_t w = lv_area_get_width(&clip_area_sub);\n        sh_buf_tmp = sh_buf;\n        sh_buf_tmp += (clip_area_sub.y1 - shadow_area.y1) * corner_size;\n        sh_buf_tmp += clip_area_sub.x1 - (shadow_area.x2 - corner_size + 1);\n\n        /*Do not mask if out of the bg*/\n        if(simple && _lv_area_is_out(&clip_area_sub, &bg_area, r_bg)) simple_sub = true;\n        else simple_sub = simple;\n        mask_act = simple_sub ? &sh_buf_tmp : &mask_buf;\n        if(w > 0) {\n            mask_res = LV_DRAW_MASK_RES_CHANGED;    /*In simple mode it won't be overwritten*/\n            for(y = clip_area_sub.y1; y <= clip_area_sub.y2; y++) {\n                blend_area.y1 = y;\n                blend_area.y2 = y;\n\n                if(!simple_sub) {\n                    lv_memcpy(mask_buf, sh_buf_tmp, corner_size);\n                    mask_res = lv_draw_mask_apply(mask_buf, clip_area_sub.x1, y, w);\n                    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;\n                }\n                _lv_blend_fill(&clip_area_sub, &blend_area, dsc->shadow_color, *mask_act, mask_res, dsc->shadow_opa, dsc->blend_mode);\n                sh_buf_tmp += corner_size;\n            }\n        }\n    }\n\n    /*Bottom right corner.\n     *Almost the same as top right just read the lines of `sh_buf` from then end*/\n    blend_area.x2 = shadow_area.x2;\n    blend_area.x1 = shadow_area.x2 - corner_size + 1;\n    blend_area.y1 = shadow_area.y2 - corner_size + 1;\n    blend_area.y2 = shadow_area.y2;\n    /*Do not overdraw the other corners*/\n    blend_area.x1 = LV_MAX(blend_area.x1, w_half);\n    blend_area.y1 = LV_MAX(blend_area.y1, h_half + 1);\n\n    if(_lv_area_intersect(&clip_area_sub, &blend_area, clip) && !_lv_area_is_in(&clip_area_sub, &bg_area, r_bg)) {\n        lv_coord_t w = lv_area_get_width(&clip_area_sub);\n        sh_buf_tmp = sh_buf;\n        sh_buf_tmp += (blend_area.y2 - clip_area_sub.y2) * corner_size;\n        sh_buf_tmp += clip_area_sub.x1 - (shadow_area.x2 - corner_size + 1);\n        /*Do not mask if out of the bg*/\n        if(simple && _lv_area_is_out(&clip_area_sub, &bg_area, r_bg)) simple_sub = true;\n        else simple_sub = simple;\n        mask_act = simple_sub ? &sh_buf_tmp : &mask_buf;\n\n        if(w > 0) {\n            mask_res = LV_DRAW_MASK_RES_CHANGED;    /*In simple mode it won't be overwritten*/\n            for(y = clip_area_sub.y2; y >= clip_area_sub.y1; y--) {\n                blend_area.y1 = y;\n                blend_area.y2 = y;\n\n                if(!simple_sub) {\n                    lv_memcpy(mask_buf, sh_buf_tmp, corner_size);\n                    mask_res = lv_draw_mask_apply(mask_buf, clip_area_sub.x1, y, w);\n                    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;\n                }\n                _lv_blend_fill(&clip_area_sub, &blend_area, dsc->shadow_color, *mask_act, mask_res, dsc->shadow_opa, dsc->blend_mode);\n                sh_buf_tmp += corner_size;\n            }\n        }\n    }\n\n    /*Top side*/\n    blend_area.x1 = shadow_area.x1 + corner_size;\n    blend_area.x2 = shadow_area.x2 - corner_size;\n    blend_area.y1 = shadow_area.y1;\n    blend_area.y2 = shadow_area.y1 + corner_size - 1;\n    blend_area.y2 = LV_MIN(blend_area.y2, h_half);\n\n    if(_lv_area_intersect(&clip_area_sub, &blend_area, clip) && !_lv_area_is_in(&clip_area_sub, &bg_area, r_bg)) {\n        lv_coord_t w = lv_area_get_width(&clip_area_sub);\n        sh_buf_tmp = sh_buf;\n        sh_buf_tmp += (clip_area_sub.y1 - blend_area.y1) * corner_size;\n\n        /*Do not mask if out of the bg*/\n        if(simple && _lv_area_is_out(&clip_area_sub, &bg_area, r_bg)) simple_sub = true;\n        else simple_sub = simple;\n\n        if(w > 0) {\n            mask_res = LV_DRAW_MASK_RES_CHANGED;    /*In simple mode it won't be overwritten*/\n            for(y = clip_area_sub.y1; y <= clip_area_sub.y2; y++) {\n                blend_area.y1 = y;\n                blend_area.y2 = y;\n\n                if(!simple_sub) {\n                    lv_memset(mask_buf, sh_buf_tmp[0], w);\n                    mask_res = lv_draw_mask_apply(mask_buf, clip_area_sub.x1, y, w);\n                    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;\n                    _lv_blend_fill(&clip_area_sub, &blend_area, dsc->shadow_color, mask_buf, mask_res, dsc->shadow_opa, dsc->blend_mode);\n                }\n                else {\n                    lv_opa_t line_opa = opa == LV_OPA_COVER ? sh_buf_tmp[0] : (sh_buf_tmp[0] * dsc->shadow_opa) >> 8;\n                    _lv_blend_fill(&clip_area_sub, &blend_area, dsc->shadow_color, NULL, LV_DRAW_MASK_RES_FULL_COVER, line_opa,\n                                   dsc->blend_mode);\n                }\n                sh_buf_tmp += corner_size;\n            }\n        }\n    }\n\n    /*Bottom side*/\n    blend_area.x1 = shadow_area.x1 + corner_size;\n    blend_area.x2 = shadow_area.x2 - corner_size;\n    blend_area.y1 = shadow_area.y2 - corner_size + 1;\n    blend_area.y2 = shadow_area.y2;\n    blend_area.y1 = LV_MAX(blend_area.y1, h_half + 1);\n\n    if(_lv_area_intersect(&clip_area_sub, &blend_area, clip) && !_lv_area_is_in(&clip_area_sub, &bg_area, r_bg)) {\n        lv_coord_t w = lv_area_get_width(&clip_area_sub);\n        sh_buf_tmp = sh_buf;\n        sh_buf_tmp += (blend_area.y2 - clip_area_sub.y2) * corner_size;\n        if(w > 0) {\n            mask_res = LV_DRAW_MASK_RES_CHANGED;    /*In simple mode it won't be overwritten*/\n            for(y = clip_area_sub.y2; y >= clip_area_sub.y1; y--) {\n                blend_area.y1 = y;\n                blend_area.y2 = y;\n\n                /*Do not mask if out of the bg*/\n                if(simple && _lv_area_is_out(&clip_area_sub, &bg_area, r_bg)) simple_sub = true;\n                else simple_sub = simple;\n\n                if(!simple_sub) {\n                    lv_memset(mask_buf, sh_buf_tmp[0], w);\n                    mask_res = lv_draw_mask_apply(mask_buf, clip_area_sub.x1, y, w);\n                    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;\n                    _lv_blend_fill(&clip_area_sub, &blend_area, dsc->shadow_color, mask_buf, mask_res, dsc->shadow_opa, dsc->blend_mode);\n                }\n                else {\n                    lv_opa_t line_opa = opa == LV_OPA_COVER ? sh_buf_tmp[0] : (sh_buf_tmp[0] * dsc->shadow_opa) >> 8;\n                    _lv_blend_fill(&clip_area_sub, &blend_area, dsc->shadow_color, NULL, LV_DRAW_MASK_RES_FULL_COVER, line_opa,\n                                   dsc->blend_mode);\n\n                }\n                sh_buf_tmp += corner_size;\n            }\n        }\n    }\n\n    /*Right side*/\n    blend_area.x1 = shadow_area.x2 - corner_size + 1;\n    blend_area.x2 = shadow_area.x2;\n    blend_area.y1 = shadow_area.y1 + corner_size;\n    blend_area.y2 = shadow_area.y2 - corner_size;\n    /*Do not overdraw the other corners*/\n    blend_area.y1 = LV_MIN(blend_area.y1, h_half + 1);\n    blend_area.y2 = LV_MAX(blend_area.y2, h_half);\n    blend_area.x1 = LV_MAX(blend_area.x1, w_half);\n\n    if(_lv_area_intersect(&clip_area_sub, &blend_area, clip) && !_lv_area_is_in(&clip_area_sub, &bg_area, r_bg)) {\n        lv_coord_t w = lv_area_get_width(&clip_area_sub);\n        sh_buf_tmp = sh_buf;\n        sh_buf_tmp += (corner_size - 1) * corner_size;\n        sh_buf_tmp += clip_area_sub.x1 - (shadow_area.x2 - corner_size + 1);\n\n        /*Do not mask if out of the bg*/\n        if(simple && _lv_area_is_out(&clip_area_sub, &bg_area, r_bg)) simple_sub = true;\n        else simple_sub = simple;\n        mask_act = simple_sub ? &sh_buf_tmp : &mask_buf;\n\n        if(w > 0) {\n            mask_res = LV_DRAW_MASK_RES_CHANGED;    /*In simple mode it won't be overwritten*/\n            for(y = clip_area_sub.y1; y <= clip_area_sub.y2; y++) {\n                blend_area.y1 = y;\n                blend_area.y2 = y;\n\n                if(!simple_sub) {\n                    lv_memcpy(mask_buf, sh_buf_tmp, w);\n                    mask_res = lv_draw_mask_apply(mask_buf, clip_area_sub.x1, y, w);\n                    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;\n                }\n                _lv_blend_fill(&clip_area_sub, &blend_area, dsc->shadow_color, *mask_act, mask_res, dsc->shadow_opa, dsc->blend_mode);\n            }\n        }\n    }\n\n    /*Mirror the shadow corner buffer horizontally*/\n    sh_buf_tmp = sh_buf ;\n    for(y = 0; y < corner_size; y++) {\n        int32_t x;\n        lv_opa_t * start = sh_buf_tmp;\n        lv_opa_t * end = sh_buf_tmp + corner_size - 1;\n        for(x = 0; x < corner_size / 2; x++) {\n            lv_opa_t tmp = *start;\n            *start = *end;\n            *end = tmp;\n\n            start++;\n            end--;\n        }\n        sh_buf_tmp += corner_size;\n    }\n\n    /*Left side*/\n    blend_area.x1 = shadow_area.x1;\n    blend_area.x2 = shadow_area.x1 + corner_size - 1;\n    blend_area.y1 = shadow_area.y1 + corner_size;\n    blend_area.y2 = shadow_area.y2 - corner_size;\n    /*Do not overdraw the other corners*/\n    blend_area.y1 = LV_MIN(blend_area.y1, h_half + 1);\n    blend_area.y2 = LV_MAX(blend_area.y2, h_half);\n    blend_area.x2 = LV_MIN(blend_area.x2, w_half - 1);\n\n    if(_lv_area_intersect(&clip_area_sub, &blend_area, clip) && !_lv_area_is_in(&clip_area_sub, &bg_area, r_bg)) {\n        lv_coord_t w = lv_area_get_width(&clip_area_sub);\n        sh_buf_tmp = sh_buf;\n        sh_buf_tmp += (corner_size - 1) * corner_size;\n        sh_buf_tmp += clip_area_sub.x1 - blend_area.x1;\n\n        /*Do not mask if out of the bg*/\n        if(simple && _lv_area_is_out(&clip_area_sub, &bg_area, r_bg)) simple_sub = true;\n        else simple_sub = simple;\n        mask_act = simple_sub ? &sh_buf_tmp : &mask_buf;\n        if(w > 0) {\n            mask_res = LV_DRAW_MASK_RES_CHANGED;    /*In simple mode it won't be overwritten*/\n            for(y = clip_area_sub.y1; y <= clip_area_sub.y2; y++) {\n                blend_area.y1 = y;\n                blend_area.y2 = y;\n\n                if(!simple_sub) {\n                    lv_memcpy(mask_buf, sh_buf_tmp, w);\n                    mask_res = lv_draw_mask_apply(mask_buf, clip_area_sub.x1, y, w);\n                    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;\n                }\n                _lv_blend_fill(&clip_area_sub, &blend_area, dsc->shadow_color, *mask_act, mask_res, dsc->shadow_opa, dsc->blend_mode);\n            }\n        }\n    }\n\n    /*Top left corner*/\n    blend_area.x1 = shadow_area.x1;\n    blend_area.x2 = shadow_area.x1 + corner_size - 1;\n    blend_area.y1 = shadow_area.y1;\n    blend_area.y2 = shadow_area.y1 + corner_size - 1;\n    /*Do not overdraw the other corners*/\n    blend_area.x2 = LV_MIN(blend_area.x2, w_half - 1);\n    blend_area.y2 = LV_MIN(blend_area.y2, h_half);\n\n    if(_lv_area_intersect(&clip_area_sub, &blend_area, clip) && !_lv_area_is_in(&clip_area_sub, &bg_area, r_bg)) {\n        lv_coord_t w = lv_area_get_width(&clip_area_sub);\n        sh_buf_tmp = sh_buf;\n        sh_buf_tmp += (clip_area_sub.y1 - blend_area.y1) * corner_size;\n        sh_buf_tmp += clip_area_sub.x1 - blend_area.x1;\n\n        /*Do not mask if out of the bg*/\n        if(simple && _lv_area_is_out(&clip_area_sub, &bg_area, r_bg)) simple_sub = true;\n        else simple_sub = simple;\n        mask_act = simple_sub ? &sh_buf_tmp : &mask_buf;\n\n        if(w > 0) {\n            mask_res = LV_DRAW_MASK_RES_CHANGED;    /*In simple mode it won't be overwritten*/\n            for(y = clip_area_sub.y1; y <= clip_area_sub.y2; y++) {\n                blend_area.y1 = y;\n                blend_area.y2 = y;\n\n                if(!simple_sub) {\n                    lv_memcpy(mask_buf, sh_buf_tmp, corner_size);\n                    mask_res = lv_draw_mask_apply(mask_buf, clip_area_sub.x1, y, w);\n                    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;\n                }\n                _lv_blend_fill(&clip_area_sub, &blend_area, dsc->shadow_color, *mask_act, mask_res, dsc->shadow_opa, dsc->blend_mode);\n                sh_buf_tmp += corner_size;\n            }\n        }\n    }\n\n    /*Bottom left corner.\n     *Almost the same as bottom right just read the lines of `sh_buf` from then end*/\n    blend_area.x1 = shadow_area.x1 ;\n    blend_area.x2 = shadow_area.x1 + corner_size - 1;\n    blend_area.y1 = shadow_area.y2 - corner_size + 1;\n    blend_area.y2 = shadow_area.y2;\n    /*Do not overdraw the other corners*/\n    blend_area.y1 = LV_MAX(blend_area.y1, h_half + 1);\n    blend_area.x2 = LV_MIN(blend_area.x2, w_half - 1);\n\n    if(_lv_area_intersect(&clip_area_sub, &blend_area, clip) && !_lv_area_is_in(&clip_area_sub, &bg_area, r_bg)) {\n        lv_coord_t w = lv_area_get_width(&clip_area_sub);\n        sh_buf_tmp = sh_buf;\n        sh_buf_tmp += (blend_area.y2 - clip_area_sub.y2) * corner_size;\n        sh_buf_tmp += clip_area_sub.x1 - blend_area.x1;\n\n        /*Do not mask if out of the bg*/\n        if(simple && _lv_area_is_out(&clip_area_sub, &bg_area, r_bg)) simple_sub = true;\n        else simple_sub = simple;\n        mask_act = simple_sub ? &sh_buf_tmp : &mask_buf;\n        if(w > 0) {\n            mask_res = LV_DRAW_MASK_RES_CHANGED;    /*In simple mode it won't be overwritten*/\n            for(y = clip_area_sub.y2; y >= clip_area_sub.y1; y--) {\n                blend_area.y1 = y;\n                blend_area.y2 = y;\n\n                if(!simple_sub) {\n                    lv_memcpy(mask_buf, sh_buf_tmp, corner_size);\n                    mask_res = lv_draw_mask_apply(mask_buf, clip_area_sub.x1, y, w);\n                    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;\n                }\n                _lv_blend_fill(&clip_area_sub, &blend_area, dsc->shadow_color, *mask_act, mask_res, dsc->shadow_opa, dsc->blend_mode);\n                sh_buf_tmp += corner_size;\n            }\n        }\n    }\n\n    /*Draw the center rectangle.*/\n    blend_area.x1 = shadow_area.x1 + corner_size ;\n    blend_area.x2 = shadow_area.x2 - corner_size;\n    blend_area.y1 = shadow_area.y1 + corner_size;\n    blend_area.y2 = shadow_area.y2 - corner_size;\n\n    if(_lv_area_intersect(&clip_area_sub, &blend_area, clip) && !_lv_area_is_in(&clip_area_sub, &bg_area, r_bg)) {\n        lv_coord_t w = lv_area_get_width(&clip_area_sub);\n        if(w > 0) {\n            for(y = clip_area_sub.y1; y <= clip_area_sub.y2; y++) {\n                blend_area.y1 = y;\n                blend_area.y2 = y;\n\n                lv_memset_ff(mask_buf, w);\n                mask_res = lv_draw_mask_apply(mask_buf, clip_area_sub.x1, y, w);\n                _lv_blend_fill(&clip_area_sub, &blend_area, dsc->shadow_color, mask_buf, mask_res, dsc->shadow_opa, dsc->blend_mode);\n            }\n        }\n    }\n\n    if(!simple) {\n        lv_draw_mask_free_param(&mask_rout_param);\n        lv_draw_mask_remove_id(mask_rout_id);\n    }\n    lv_mem_buf_release(sh_buf);\n    lv_mem_buf_release(mask_buf);\n}"}, "shadow_draw_corner_buf": {"type": "Function", "def": "static void shadow_draw_corner_buf(const lv_area_t * coords, uint16_t * sh_buf, lv_coord_t sw,\n                                                         lv_coord_t r)", "sline": 879, "body": "{\n    int32_t sw_ori = sw;\n    int32_t size = sw_ori  + r;\n\n    lv_area_t sh_area;\n    lv_area_copy(&sh_area, coords);\n    sh_area.x2 = sw / 2 + r - 1  - ((sw & 1) ? 0 : 1);\n    sh_area.y1 = sw / 2 + 1;\n\n    sh_area.x1 = sh_area.x2 - lv_area_get_width(coords);\n    sh_area.y2 = sh_area.y1 + lv_area_get_height(coords);\n\n    lv_draw_mask_radius_param_t mask_param;\n    lv_draw_mask_radius_init(&mask_param, &sh_area, r, false);\n\n#if SHADOW_ENHANCE\n    /*Set half shadow width width because blur will be repeated*/\n    if(sw_ori == 1) sw = 1;\n    else sw = sw_ori >> 1;\n#endif\n\n    int32_t y;\n    lv_opa_t * mask_line = lv_mem_buf_get(size);\n    uint16_t * sh_ups_tmp_buf = (uint16_t *)sh_buf;\n    for(y = 0; y < size; y++) {\n        lv_memset_ff(mask_line, size);\n        lv_draw_mask_res_t mask_res = mask_param.dsc.cb(mask_line, 0, y, size, &mask_param);\n        if(mask_res == LV_DRAW_MASK_RES_TRANSP) {\n            lv_memset_00(sh_ups_tmp_buf, size * sizeof(sh_ups_tmp_buf[0]));\n        }\n        else {\n            int32_t i;\n            sh_ups_tmp_buf[0] = (mask_line[0] << SHADOW_UPSCALE_SHIFT) / sw;\n            for(i = 1; i < size; i++) {\n                if(mask_line[i] == mask_line[i - 1]) sh_ups_tmp_buf[i] = sh_ups_tmp_buf[i - 1];\n                else  sh_ups_tmp_buf[i] = (mask_line[i] << SHADOW_UPSCALE_SHIFT) / sw;\n            }\n        }\n\n        sh_ups_tmp_buf += size;\n    }\n    lv_mem_buf_release(mask_line);\n\n    lv_draw_mask_free_param(&mask_param);\n\n    if(sw == 1) {\n        int32_t i;\n        lv_opa_t * res_buf = (lv_opa_t *)sh_buf;\n        for(i = 0; i < size * size; i++) {\n            res_buf[i] = (sh_buf[i] >> SHADOW_UPSCALE_SHIFT);\n        }\n        return;\n    }\n\n    shadow_blur_corner(size, sw, sh_buf);\n\n#if SHADOW_ENHANCE == 0\n    /*The result is required in lv_opa_t not uint16_t*/\n    uint32_t x;\n    lv_opa_t * res_buf = (lv_opa_t *)sh_buf;\n    for(x = 0; x < size * size; x++) {\n        res_buf[x] = sh_buf[x];\n    }\n#else\n    sw += sw_ori & 1;\n    if(sw > 1) {\n        uint32_t i;\n        uint32_t max_v_div = (LV_OPA_COVER << SHADOW_UPSCALE_SHIFT) / sw;\n        for(i = 0; i < (uint32_t)size * size; i++) {\n            if(sh_buf[i] == 0) continue;\n            else if(sh_buf[i] == LV_OPA_COVER) sh_buf[i] = max_v_div;\n            else  sh_buf[i] = (sh_buf[i] << SHADOW_UPSCALE_SHIFT) / sw;\n        }\n\n        shadow_blur_corner(size, sw, sh_buf);\n    }\n    int32_t x;\n    lv_opa_t * res_buf = (lv_opa_t *)sh_buf;\n    for(x = 0; x < size * size; x++) {\n        res_buf[x] = sh_buf[x];\n    }\n#endif\n\n}"}, "shadow_blur_corner": {"type": "Function", "def": "static void shadow_blur_corner(lv_coord_t size, lv_coord_t sw, uint16_t * sh_ups_buf)", "sline": 966, "body": "{\n    int32_t s_left = sw >> 1;\n    int32_t s_right = (sw >> 1);\n    if((sw & 1) == 0) s_left--;\n\n    /*Horizontal blur*/\n    uint16_t * sh_ups_blur_buf = lv_mem_buf_get(size * sizeof(uint16_t));\n\n    int32_t x;\n    int32_t y;\n\n    uint16_t * sh_ups_tmp_buf = sh_ups_buf;\n\n    for(y = 0; y < size; y++) {\n        int32_t v = sh_ups_tmp_buf[size - 1] * sw;\n        for(x = size - 1; x >= 0; x--) {\n            sh_ups_blur_buf[x] = v;\n\n            /*Forget the right pixel*/\n            uint32_t right_val = 0;\n            if(x + s_right < size) right_val = sh_ups_tmp_buf[x + s_right];\n            v -= right_val;\n\n            /*Add the left pixel*/\n            uint32_t left_val;\n            if(x - s_left - 1 < 0) left_val = sh_ups_tmp_buf[0];\n            else left_val = sh_ups_tmp_buf[x - s_left - 1];\n            v += left_val;\n        }\n        lv_memcpy(sh_ups_tmp_buf, sh_ups_blur_buf, size * sizeof(uint16_t));\n        sh_ups_tmp_buf += size;\n    }\n\n    /*Vertical blur*/\n    uint32_t i;\n    uint32_t max_v = LV_OPA_COVER << SHADOW_UPSCALE_SHIFT;\n    uint32_t max_v_div = max_v / sw;\n    for(i = 0; i < (uint32_t)size * size; i++) {\n        if(sh_ups_buf[i] == 0) continue;\n        else if(sh_ups_buf[i] == max_v) sh_ups_buf[i] = max_v_div;\n        else sh_ups_buf[i] = sh_ups_buf[i] / sw;\n    }\n\n    for(x = 0; x < size; x++) {\n        sh_ups_tmp_buf = &sh_ups_buf[x];\n        int32_t v = sh_ups_tmp_buf[0] * sw;\n        for(y = 0; y < size ; y++, sh_ups_tmp_buf += size) {\n            sh_ups_blur_buf[y] = v < 0 ? 0 : (v >> SHADOW_UPSCALE_SHIFT);\n\n            /*Forget the top pixel*/\n            uint32_t top_val;\n            if(y - s_right <= 0) top_val = sh_ups_tmp_buf[0];\n            else top_val = sh_ups_buf[(y - s_right) * size + x];\n            v -= top_val;\n\n            /*Add the bottom pixel*/\n            uint32_t bottom_val;\n            if(y + s_left + 1 < size) bottom_val = sh_ups_buf[(y + s_left + 1) * size + x];\n            else bottom_val = sh_ups_buf[(size - 1) * size + x];\n            v += bottom_val;\n        }\n\n        /*Write back the result into `sh_ups_buf`*/\n        sh_ups_tmp_buf = &sh_ups_buf[x];\n        for(y = 0; y < size; y++, sh_ups_tmp_buf += size) {\n            (*sh_ups_tmp_buf) = sh_ups_blur_buf[y];\n        }\n    }\n\n    lv_mem_buf_release(sh_ups_blur_buf);\n}"}, "draw_border_generic": {"type": "Function", "def": "void draw_border_generic(const lv_area_t * clip_area, const lv_area_t * outer_area, const lv_area_t * inner_area,\n                         lv_coord_t rout, lv_coord_t rin, lv_color_t color, lv_opa_t opa, lv_blend_mode_t blend_mode)", "sline": 1081, "body": "{\n    opa = opa >= LV_OPA_COVER ? LV_OPA_COVER : opa;\n\n    bool mask_any = lv_draw_mask_is_any(outer_area);\n\n    if(!mask_any && rout == 0 && rin == 0) {\n        draw_border_simple(clip_area, outer_area, inner_area, color, opa);\n        return;\n    }\n\n#if LV_DRAW_COMPLEX\n    /*Get clipped draw area which is the real draw area.\n     *It is always the same or inside `coords`*/\n    lv_area_t draw_area;\n    if(!_lv_area_intersect(&draw_area, outer_area, clip_area)) return;\n    int32_t draw_area_w = lv_area_get_width(&draw_area);\n\n    /*Create a mask if there is a radius*/\n    lv_opa_t * mask_buf = lv_mem_buf_get(draw_area_w);\n\n    /*Create mask for the outer area*/\n    int16_t mask_rout_id = LV_MASK_ID_INV;\n    lv_draw_mask_radius_param_t mask_rout_param;\n    if(rout > 0) {\n        lv_draw_mask_radius_init(&mask_rout_param, outer_area, rout, false);\n        mask_rout_id = lv_draw_mask_add(&mask_rout_param, NULL);\n    }\n\n    /*Create mask for the inner mask*/\n    lv_draw_mask_radius_param_t mask_rin_param;\n    lv_draw_mask_radius_init(&mask_rin_param, inner_area, rin, true);\n    int16_t mask_rin_id = lv_draw_mask_add(&mask_rin_param, NULL);\n\n    int32_t h;\n    lv_draw_mask_res_t mask_res;\n    lv_area_t blend_area;\n\n    /*Calculate the x and y coordinates where the straight parts area*/\n    lv_area_t core_area;\n    core_area.x1 = LV_MAX(outer_area->x1 + rout, inner_area->x1);\n    core_area.x2 = LV_MIN(outer_area->x2 - rout, inner_area->x2);\n    core_area.y1 = LV_MAX(outer_area->y1 + rout, inner_area->y1);\n    core_area.y2 = LV_MIN(outer_area->y2 - rout, inner_area->y2);\n    lv_coord_t core_w = lv_area_get_width(&core_area);\n\n    bool top_side = outer_area->y1 <= inner_area->y1 ? true : false;\n    bool bottom_side = outer_area->y2 >= inner_area->y2 ? true : false;\n\n    /*If there is other masks, need to draw line by line*/\n    if(mask_any) {\n        blend_area.x1 = draw_area.x1;\n        blend_area.x2 = draw_area.x2;\n        for(h = draw_area.y1; h <= draw_area.y2; h++) {\n            if(!top_side && h < core_area.y1) continue;\n            if(!bottom_side && h > core_area.y2) break;\n\n            blend_area.y1 = h;\n            blend_area.y2 = h;\n\n            lv_memset_ff(mask_buf, draw_area_w);\n            mask_res = lv_draw_mask_apply(mask_buf, draw_area.x1, h, draw_area_w);\n            _lv_blend_fill(clip_area, &blend_area, color, mask_buf, mask_res, opa, blend_mode);\n        }\n\n        lv_draw_mask_free_param(&mask_rin_param);\n        lv_draw_mask_remove_id(mask_rin_id);\n        lv_draw_mask_free_param(&mask_rout_param);\n        lv_draw_mask_remove_id(mask_rout_id);\n        lv_mem_buf_release(mask_buf);\n        return;\n    }\n\n    /*No masks*/\n    bool left_side = outer_area->x1 <= inner_area->x1 ? true : false;\n    bool right_side = outer_area->x2 >= inner_area->x2 ? true : false;\n\n    bool split_hor = true;\n    if(left_side && right_side && top_side && bottom_side &&\n       core_w < SPLIT_LIMIT) {\n        split_hor = false;\n    }\n\n    /*Draw the straight lines first if they are long enough*/\n    if(top_side && split_hor) {\n        blend_area.x1 = core_area.x1;\n        blend_area.x2 = core_area.x2;\n        blend_area.y1 = outer_area->y1;\n        blend_area.y2 = inner_area->y1 - 1;\n        _lv_blend_fill(clip_area, &blend_area, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);\n    }\n\n    if(bottom_side && split_hor) {\n        blend_area.x1 = core_area.x1;\n        blend_area.x2 = core_area.x2;\n        blend_area.y1 = inner_area->y2 + 1;\n        blend_area.y2 = outer_area->y2;\n        _lv_blend_fill(clip_area, &blend_area, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);\n    }\n\n    if(left_side) {\n        blend_area.x1 = outer_area->x1;\n        blend_area.x2 = inner_area->x1 - 1;\n        blend_area.y1 = core_area.y1;\n        blend_area.y2 = core_area.y2;\n        _lv_blend_fill(clip_area, &blend_area, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);\n    }\n\n    if(right_side) {\n        blend_area.x1 = inner_area->x2 + 1;\n        blend_area.x2 = outer_area->x2;\n        blend_area.y1 = core_area.y1;\n        blend_area.y2 = core_area.y2;\n        _lv_blend_fill(clip_area, &blend_area, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);\n    }\n\n    /*Draw the corners*/\n    lv_coord_t blend_w;\n\n    /*Left and right corner together is they close to eachother*/\n    if(!split_hor) {\n        /*Calculate the top corner and mirror it to the bottom*/\n        blend_area.x1 = draw_area.x1;\n        blend_area.x2 = draw_area.x2;\n        lv_coord_t max_h = LV_MAX(rout, outer_area->y1 - inner_area->y1);\n        for(h = 0; h < max_h; h++) {\n            lv_coord_t top_y = outer_area->y1 + h;\n            lv_coord_t bottom_y = outer_area->y2 - h;\n            if(top_y < draw_area.y1 && bottom_y > draw_area.y2) continue;   /*This line is clipped now*/\n\n            lv_memset_ff(mask_buf, draw_area_w);\n            mask_res = lv_draw_mask_apply(mask_buf, blend_area.x1, top_y, draw_area_w);\n\n            if(top_y >= draw_area.y1) {\n                blend_area.y1 = top_y;\n                blend_area.y2 = top_y;\n                _lv_blend_fill(clip_area, &blend_area, color, mask_buf, mask_res, opa, blend_mode);\n            }\n\n            if(bottom_y <= draw_area.y2) {\n                blend_area.y1 = bottom_y;\n                blend_area.y2 = bottom_y;\n                _lv_blend_fill(clip_area, &blend_area, color, mask_buf, mask_res, opa, blend_mode);\n            }\n        }\n    }\n    else {\n        /*Left corners*/\n        blend_area.x1 = draw_area.x1;\n        blend_area.x2 = LV_MIN(draw_area.x2, core_area.x1 - 1);\n        blend_w = lv_area_get_width(&blend_area);\n        if(blend_w > 0) {\n            if(left_side || top_side) {\n                for(h = draw_area.y1; h < core_area.y1; h++) {\n                    blend_area.y1 = h;\n                    blend_area.y2 = h;\n\n                    lv_memset_ff(mask_buf, blend_w);\n                    mask_res = lv_draw_mask_apply(mask_buf, blend_area.x1, h, blend_w);\n                    _lv_blend_fill(clip_area, &blend_area, color, mask_buf, mask_res, opa, blend_mode);\n                }\n            }\n\n            if(left_side || bottom_side) {\n                for(h = core_area.y2 + 1; h <= draw_area.y2; h++) {\n                    blend_area.y1 = h;\n                    blend_area.y2 = h;\n\n                    lv_memset_ff(mask_buf, blend_w);\n                    mask_res = lv_draw_mask_apply(mask_buf, blend_area.x1, h, blend_w);\n                    _lv_blend_fill(clip_area, &blend_area, color, mask_buf, mask_res, opa, blend_mode);\n                }\n            }\n        }\n\n        /*Right corners*/\n        blend_area.x1 = LV_MAX(draw_area.x1, core_area.x2 + 1);\n        blend_area.x2 = draw_area.x2;\n        blend_w = lv_area_get_width(&blend_area);\n\n        if(blend_w > 0) {\n            if(right_side || top_side) {\n                for(h = draw_area.y1; h < core_area.y1; h++) {\n                    blend_area.y1 = h;\n                    blend_area.y2 = h;\n\n                    lv_memset_ff(mask_buf, blend_w);\n                    mask_res = lv_draw_mask_apply(mask_buf, blend_area.x1, h, blend_w);\n                    _lv_blend_fill(clip_area, &blend_area, color, mask_buf, mask_res, opa, blend_mode);\n                }\n            }\n\n            if(right_side || bottom_side) {\n                for(h = core_area.y2 + 1; h <= draw_area.y2; h++) {\n                    blend_area.y1 = h;\n                    blend_area.y2 = h;\n\n                    lv_memset_ff(mask_buf, blend_w);\n                    mask_res = lv_draw_mask_apply(mask_buf, blend_area.x1, h, blend_w);\n                    _lv_blend_fill(clip_area, &blend_area, color, mask_buf, mask_res, opa, blend_mode);\n                }\n            }\n        }\n    }\n\n    lv_draw_mask_free_param(&mask_rin_param);\n    lv_draw_mask_remove_id(mask_rin_id);\n    lv_draw_mask_free_param(&mask_rout_param);\n    lv_draw_mask_remove_id(mask_rout_id);\n    lv_mem_buf_release(mask_buf);\n\n#else /*LV_DRAW_COMPLEX*/\n    LV_UNUSED(blend_mode);\n#endif /*LV_DRAW_COMPLEX*/\n}"}, "draw_border_simple": {"type": "Function", "def": "static void draw_border_simple(const lv_area_t * clip, const lv_area_t * outer_area, const lv_area_t * inner_area,\n                               lv_color_t color, lv_opa_t opa)", "sline": 1298, "body": "{\n    bool top_side = outer_area->y1 <= inner_area->y1 ? true : false;\n    bool bottom_side = outer_area->y2 >= inner_area->y2 ? true : false;\n    bool left_side = outer_area->x1 <= inner_area->x1 ? true : false;\n    bool right_side = outer_area->x2 >= inner_area->x2 ? true : false;\n\n    lv_area_t a;\n    /*Top*/\n    a.x1 = outer_area->x1;\n    a.x2 = outer_area->x2;\n    a.y1 = outer_area->y1;\n    a.y2 = inner_area->y1 - 1;\n    if(top_side) {\n        _lv_blend_fill(clip, &a, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, LV_BLEND_MODE_NORMAL);\n    }\n\n    /*Bottom*/\n    a.y1 = inner_area->y2 + 1;\n    a.y2 = outer_area->y2;\n    if(bottom_side) {\n        _lv_blend_fill(clip, &a, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, LV_BLEND_MODE_NORMAL);\n    }\n\n    /*Left*/\n    a.x1 = outer_area->x1;\n    a.x2 = inner_area->x1 - 1;\n    a.y1 = (top_side) ? inner_area->y1 : outer_area->y1;\n    a.y2 = (bottom_side) ? inner_area->y2 : outer_area->y2;\n    if(left_side) {\n        _lv_blend_fill(clip, &a, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, LV_BLEND_MODE_NORMAL);\n    }\n\n    /*Right*/\n    a.x1 = inner_area->x2 + 1;\n    a.x2 = outer_area->x2;\n    if(right_side) {\n        _lv_blend_fill(clip, &a, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, LV_BLEND_MODE_NORMAL);\n    }\n\n}"}, "grad_get": {"type": "Function", "def": "static inline lv_color_t grad_get(const lv_draw_rect_dsc_t * dsc, lv_coord_t s, lv_coord_t i)", "sline": 412, "body": "{\n    int32_t min = (dsc->bg_main_color_stop * s) >> 8;\n    if(i <= min) return dsc->bg_color;\n\n    int32_t max = (dsc->bg_grad_color_stop * s) >> 8;\n    if(i >= max) return dsc->bg_grad_color;\n\n    int32_t d = dsc->bg_grad_color_stop - dsc->bg_main_color_stop;\n    d = (s * d) >> 8;\n    i -= min;\n    lv_opa_t mix = (i * 255) / d;\n    return lv_color_mix(dsc->bg_grad_color, dsc->bg_color, mix);\n}"}, "lv_draw_rect_dsc_init": {"type": "Function", "def": "void lv_draw_rect_dsc_init(lv_draw_rect_dsc_t * dsc)", "sline": 77, "body": "{\n    lv_memset_00(dsc, sizeof(lv_draw_rect_dsc_t));\n    dsc->bg_color = lv_color_white();\n    dsc->bg_grad_color = lv_color_black();\n    dsc->border_color = lv_color_black();\n    dsc->shadow_color = lv_color_black();\n    dsc->bg_grad_color_stop = 0xFF;\n    dsc->bg_img_symbol_font = LV_FONT_DEFAULT;\n    dsc->bg_opa = LV_OPA_COVER;\n    dsc->bg_img_opa = LV_OPA_COVER;\n    dsc->outline_opa = LV_OPA_COVER;\n    dsc->border_opa = LV_OPA_COVER;\n    dsc->shadow_opa = LV_OPA_COVER;\n    dsc->border_side = LV_BORDER_SIDE_FULL;\n}"}, "carbit_updater/lvgl/src/draw/lv_draw_rect.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_draw_rect.c"}}, "carbit_updater/lvgl/tests/src/test_cases/test_config.c": {"carbit_updater/lvgl/tests/src/test_cases/test_config.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/tests/src/test_cases/test_config.c"}}, "carbit_updater/loopbuffer.h": {"stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 3}, "loopbuffer.pBuffer": {"type": "Variable", "def": "uint8_t *  pBuffer", "sline": 6, "in_struct": "loopbuffer"}, "loopbuffer.m_nSize": {"type": "Variable", "def": "int32_t     m_nSize", "sline": 7, "in_struct": "loopbuffer"}, "loopbuffer.m_nPos": {"type": "Variable", "def": "int32_t     m_nPos", "sline": 8, "in_struct": "loopbuffer"}, "loopbuffer.m_nLen": {"type": "Variable", "def": "int32_t     m_nLen", "sline": 9, "in_struct": "loopbuffer"}, "loopbuffer": {"type": "Struct", "def": "struct loopbuffer\n{\n    uint8_t *  pBuffer;        //\u5faa\u73af\u7f13\u51b2\u533a\n\tint32_t     m_nSize;\t\t//\u7f13\u51b2\u533a\u5bb9\u91cf\n\tint32_t     m_nPos;\t\t\t//\u6570\u636e\u8d77\u59cb\u4f4d\u7f6e\n\tint32_t     m_nLen;\t\t\t//\u6570\u636e\u957f\u5ea6\n}", "sline": 4, "body": "uint8_t *  pBuffer\nint32_t     m_nSize\nint32_t     m_nPos\nint32_t     m_nLen\n"}, "loopbuffer_t": {"type": "Variable", "def": "typedef struct loopbuffer\n{\n    uint8_t *  pBuffer;        //\u5faa\u73af\u7f13\u51b2\u533a\n\tint32_t     m_nSize;\t\t//\u7f13\u51b2\u533a\u5bb9\u91cf\n\tint32_t     m_nPos;\t\t\t//\u6570\u636e\u8d77\u59cb\u4f4d\u7f6e\n\tint32_t     m_nLen;\t\t\t//\u6570\u636e\u957f\u5ea6\n}loopbuffer_t", "sline": 10}, "loopbuffer_create": {"type": "Function", "def": "loopbuffer_t *loopbuffer_create(int iBuffLen)", "sline": 17}, "loopbuffer_destory": {"type": "Function", "def": "void          loopbuffer_destory(loopbuffer_t * ipbuffer)", "sline": 18}, "loopbuffer_addData": {"type": "Function", "def": "int32_t         loopbuffer_addData(loopbuffer_t * pBuf,const unsigned char* pData, int nDataLength)", "sline": 19}, "loopbuffer_getSize": {"type": "Function", "def": "int32_t         loopbuffer_getSize(loopbuffer_t * pBuf)", "sline": 20}, "loopbuffer_Pop": {"type": "Function", "def": "void          loopbuffer_Pop(loopbuffer_t * pBuf,int count)", "sline": 21}, "loopbuffer_getData": {"type": "Function", "def": "int           loopbuffer_getData(loopbuffer_t * pBuf,unsigned char* pOBuf, int nLength)", "sline": 22}, "loopbuffer_at": {"type": "Function", "def": "unsigned char loopbuffer_at(loopbuffer_t * pBuf,int index)", "sline": 23}, "carbit_updater/loopbuffer.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/loopbuffer.h"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_14.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "glyph_bitmap": {"type": "Variable", "def": "static LV_ATTRIBUTE_LARGE_CONST const uint8_t glyph_bitmap[] = {\n    /* U+0020 \" \" */\n\n    /* U+0021 \"!\" */\n    0xe, 0xa0, 0xd9, 0xd, 0x90, 0xc8, 0xc, 0x80,\n    0xb7, 0xa, 0x60, 0x11, 0xb, 0x80, 0xd9,\n\n    /* U+0022 \"\\\"\" */\n    0x1f, 0x9, 0x91, 0xf0, 0x88, 0x1f, 0x8, 0x80,\n    0xf0, 0x88, 0x0, 0x0, 0x0,\n\n    /* U+0023 \"#\" */\n    0x0, 0xd, 0x20, 0x3c, 0x0, 0x0, 0xf, 0x0,\n    0x69, 0x0, 0x2f, 0xff, 0xff, 0xff, 0xf7, 0x1,\n    0x5c, 0x11, 0xa6, 0x10, 0x0, 0x69, 0x0, 0xc3,\n    0x0, 0x0, 0x88, 0x0, 0xd2, 0x0, 0x9f, 0xff,\n    0xff, 0xff, 0xf0, 0x12, 0xc5, 0x23, 0xe2, 0x20,\n    0x0, 0xd2, 0x3, 0xc0, 0x0, 0x0, 0xf0, 0x4,\n    0xb0, 0x0,\n\n    /* U+0024 \"$\" */\n    0x0, 0x0, 0x70, 0x0, 0x0, 0x0, 0xe, 0x0,\n    0x0, 0x0, 0x0, 0xe0, 0x0, 0x0, 0x19, 0xef,\n    0xea, 0x30, 0xc, 0xd6, 0xe6, 0xa7, 0x2, 0xf4,\n    0xe, 0x0, 0x0, 0x1f, 0x80, 0xe0, 0x0, 0x0,\n    0x6f, 0xef, 0x50, 0x0, 0x0, 0x16, 0xff, 0xe5,\n    0x0, 0x0, 0xe, 0xa, 0xf0, 0x1, 0x0, 0xe0,\n    0x5f, 0x13, 0xf8, 0x5e, 0x6e, 0xb0, 0x5, 0xcf,\n    0xfe, 0x91, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0,\n    0x0, 0x70, 0x0, 0x0,\n\n    /* U+0025 \"%\" */\n    0x8, 0xdd, 0x30, 0x0, 0xa7, 0x0, 0x4b, 0x2,\n    0xd0, 0x4, 0xc0, 0x0, 0x77, 0x0, 0xd0, 0x1d,\n    0x20, 0x0, 0x4b, 0x3, 0xd0, 0xa7, 0x0, 0x0,\n    0x7, 0xdc, 0x34, 0xc4, 0xcc, 0x30, 0x0, 0x0,\n    0x1d, 0x2d, 0x22, 0xd0, 0x0, 0x0, 0xa6, 0x3b,\n    0x0, 0xb3, 0x0, 0x5, 0xc0, 0x3a, 0x0, 0xa3,\n    0x0, 0x1d, 0x20, 0xd, 0x0, 0xd0, 0x0, 0xa6,\n    0x0, 0x4, 0xcc, 0x40,\n\n    /* U+0026 \"&\" */\n    0x0, 0x4d, 0xfc, 0x30, 0x0, 0x0, 0xf7, 0x18,\n    0xc0, 0x0, 0x1, 0xf2, 0x5, 0xd0, 0x0, 0x0,\n    0xbb, 0x6e, 0x40, 0x0, 0x0, 0x5f, 0xf3, 0x0,\n    0x0, 0x7, 0xe6, 0xdb, 0x3, 0x80, 0x2f, 0x30,\n    0x1d, 0xba, 0xa0, 0x5f, 0x0, 0x1, 0xdf, 0x40,\n    0x1f, 0xb4, 0x48, 0xfe, 0xc0, 0x3, 0xbf, 0xfc,\n    0x40, 0xb2, 0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+0027 \"'\" */\n    0x1f, 0x1, 0xf0, 0x1f, 0x0, 0xf0, 0x0, 0x0,\n\n    /* U+0028 \"(\" */\n    0x3, 0xf1, 0xb, 0x90, 0xf, 0x40, 0x4f, 0x0,\n    0x7d, 0x0, 0x9b, 0x0, 0xaa, 0x0, 0xaa, 0x0,\n    0x9b, 0x0, 0x7d, 0x0, 0x4f, 0x0, 0xf, 0x40,\n    0xb, 0x90, 0x3, 0xf1,\n\n    /* U+0029 \")\" */\n    0x5e, 0x0, 0xe, 0x60, 0x8, 0xc0, 0x4, 0xf0,\n    0x1, 0xf3, 0x0, 0xf5, 0x0, 0xe6, 0x0, 0xe6,\n    0x0, 0xf5, 0x1, 0xf3, 0x4, 0xf0, 0x8, 0xc0,\n    0xe, 0x60, 0x5e, 0x0,\n\n    /* U+002A \"*\" */\n    0x0, 0x93, 0x0, 0x88, 0xa6, 0xc2, 0x9, 0xfe,\n    0x40, 0x4d, 0xdd, 0xb1, 0x42, 0x93, 0x50, 0x0,\n    0x52, 0x0,\n\n    /* U+002B \"+\" */\n    0x0, 0x4, 0x50, 0x0, 0x0, 0x8, 0xa0, 0x0,\n    0x0, 0x8, 0xa0, 0x0, 0x1f, 0xff, 0xff, 0xf3,\n    0x3, 0x39, 0xb3, 0x30, 0x0, 0x8, 0xa0, 0x0,\n    0x0, 0x8, 0xa0, 0x0,\n\n    /* U+002C \",\" */\n    0x1, 0x3, 0xf6, 0x1e, 0x60, 0xe1, 0x2c, 0x0,\n\n    /* U+002D \"-\" */\n    0x0, 0x0, 0x3, 0xff, 0xf9, 0x3, 0x33, 0x10,\n\n    /* U+002E \".\" */\n    0x0, 0x3, 0xf5, 0x2e, 0x40,\n\n    /* U+002F \"/\" */\n    0x0, 0x0, 0xe, 0x40, 0x0, 0x4, 0xe0, 0x0,\n    0x0, 0x9a, 0x0, 0x0, 0xe, 0x40, 0x0, 0x4,\n    0xf0, 0x0, 0x0, 0x9a, 0x0, 0x0, 0xe, 0x40,\n    0x0, 0x3, 0xf0, 0x0, 0x0, 0x9a, 0x0, 0x0,\n    0xe, 0x50, 0x0, 0x3, 0xf0, 0x0, 0x0, 0x9a,\n    0x0, 0x0, 0xe, 0x50, 0x0, 0x3, 0xf0, 0x0,\n    0x0,\n\n    /* U+0030 \"0\" */\n    0x0, 0x4c, 0xfe, 0x70, 0x0, 0x4f, 0xb6, 0x8f,\n    0x90, 0xd, 0xb0, 0x0, 0x5f, 0x32, 0xf4, 0x0,\n    0x0, 0xe7, 0x4f, 0x20, 0x0, 0xc, 0xa4, 0xf2,\n    0x0, 0x0, 0xca, 0x2f, 0x40, 0x0, 0xe, 0x70,\n    0xdb, 0x0, 0x5, 0xf2, 0x4, 0xfb, 0x68, 0xf9,\n    0x0, 0x4, 0xcf, 0xe7, 0x0,\n\n    /* U+0031 \"1\" */\n    0xef, 0xfb, 0x44, 0xcb, 0x0, 0xab, 0x0, 0xab,\n    0x0, 0xab, 0x0, 0xab, 0x0, 0xab, 0x0, 0xab,\n    0x0, 0xab, 0x0, 0xab,\n\n    /* U+0032 \"2\" */\n    0x7, 0xdf, 0xea, 0x10, 0x8e, 0x85, 0x7e, 0xc0,\n    0x1, 0x0, 0x6, 0xf1, 0x0, 0x0, 0x6, 0xf0,\n    0x0, 0x0, 0xd, 0x90, 0x0, 0x0, 0xcc, 0x0,\n    0x0, 0x1c, 0xc0, 0x0, 0x1, 0xdb, 0x0, 0x0,\n    0x1d, 0xe5, 0x44, 0x42, 0x7f, 0xff, 0xff, 0xf9,\n\n    /* U+0033 \"3\" */\n    0x7f, 0xff, 0xff, 0xf0, 0x24, 0x44, 0x5f, 0x90,\n    0x0, 0x0, 0xbc, 0x0, 0x0, 0x9, 0xe1, 0x0,\n    0x0, 0x3f, 0xd8, 0x10, 0x0, 0x4, 0x6d, 0xd0,\n    0x0, 0x0, 0x2, 0xf4, 0x10, 0x0, 0x2, 0xf4,\n    0xbd, 0x75, 0x7d, 0xd0, 0x19, 0xdf, 0xea, 0x10,\n\n    /* U+0034 \"4\" */\n    0x0, 0x0, 0xd, 0xa0, 0x0, 0x0, 0x0, 0xac,\n    0x0, 0x0, 0x0, 0x7, 0xe1, 0x0, 0x0, 0x0,\n    0x4f, 0x40, 0x10, 0x0, 0x2, 0xf6, 0x0, 0xf5,\n    0x0, 0x1d, 0xa0, 0x0, 0xf5, 0x0, 0x7f, 0xff,\n    0xff, 0xff, 0xf3, 0x13, 0x33, 0x33, 0xf7, 0x30,\n    0x0, 0x0, 0x0, 0xf5, 0x0, 0x0, 0x0, 0x0,\n    0xf5, 0x0,\n\n    /* U+0035 \"5\" */\n    0x9, 0xff, 0xff, 0xf0, 0xa, 0xb4, 0x44, 0x40,\n    0xc, 0x80, 0x0, 0x0, 0xe, 0x70, 0x0, 0x0,\n    0xf, 0xff, 0xfc, 0x40, 0x3, 0x34, 0x5c, 0xf2,\n    0x0, 0x0, 0x0, 0xf7, 0x10, 0x0, 0x0, 0xf7,\n    0x8e, 0x85, 0x6c, 0xf1, 0x8, 0xdf, 0xfb, 0x30,\n\n    /* U+0036 \"6\" */\n    0x0, 0x2a, 0xef, 0xd5, 0x0, 0x3f, 0xd6, 0x57,\n    0x40, 0xc, 0xc0, 0x0, 0x0, 0x2, 0xf4, 0x0,\n    0x0, 0x0, 0x4f, 0x5b, 0xff, 0xa1, 0x4, 0xfe,\n    0x84, 0x5d, 0xd0, 0x3f, 0x80, 0x0, 0x3f, 0x30,\n    0xe8, 0x0, 0x3, 0xf2, 0x6, 0xf8, 0x45, 0xdc,\n    0x0, 0x5, 0xdf, 0xe9, 0x10,\n\n    /* U+0037 \"7\" */\n    0x9f, 0xff, 0xff, 0xfd, 0x9d, 0x44, 0x44, 0xe9,\n    0x9c, 0x0, 0x4, 0xf2, 0x0, 0x0, 0xb, 0xb0,\n    0x0, 0x0, 0x2f, 0x40, 0x0, 0x0, 0xad, 0x0,\n    0x0, 0x1, 0xf6, 0x0, 0x0, 0x8, 0xe0, 0x0,\n    0x0, 0xe, 0x80, 0x0, 0x0, 0x6f, 0x10, 0x0,\n\n    /* U+0038 \"8\" */\n    0x1, 0x9e, 0xfe, 0x91, 0x0, 0xbe, 0x63, 0x6e,\n    0xc0, 0xf, 0x60, 0x0, 0x6f, 0x0, 0xcc, 0x20,\n    0x2b, 0xc0, 0x2, 0xef, 0xff, 0xe2, 0x0, 0xdc,\n    0x42, 0x4c, 0xd0, 0x5f, 0x20, 0x0, 0x1f, 0x55,\n    0xf2, 0x0, 0x2, 0xf5, 0xe, 0xd5, 0x35, 0xde,\n    0x0, 0x1a, 0xef, 0xea, 0x10,\n\n    /* U+0039 \"9\" */\n    0x3, 0xbf, 0xea, 0x20, 0x2f, 0xa4, 0x4b, 0xe1,\n    0x8e, 0x0, 0x0, 0xe9, 0x9d, 0x0, 0x0, 0xdd,\n    0x4f, 0x71, 0x29, 0xff, 0x7, 0xff, 0xfc, 0x9e,\n    0x0, 0x2, 0x10, 0xac, 0x0, 0x0, 0x2, 0xf6,\n    0x7, 0x65, 0x8f, 0xb0, 0xa, 0xef, 0xd7, 0x0,\n\n    /* U+003A \":\" */\n    0x2e, 0x53, 0xf5, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x3f, 0x52, 0xe4,\n\n    /* U+003B \";\" */\n    0x2e, 0x53, 0xf5, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x2e, 0x52, 0xf6, 0xd, 0x21, 0xd0, 0x1,\n    0x0,\n\n    /* U+003C \"<\" */\n    0x0, 0x0, 0x0, 0x31, 0x0, 0x0, 0x6c, 0xf2,\n    0x1, 0x8e, 0xd6, 0x0, 0xf, 0xc3, 0x0, 0x0,\n    0xa, 0xfb, 0x40, 0x0, 0x0, 0x17, 0xee, 0x70,\n    0x0, 0x0, 0x5, 0xc3, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+003D \"=\" */\n    0x1f, 0xff, 0xff, 0xf3, 0x3, 0x33, 0x33, 0x30,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x1f, 0xff, 0xff, 0xf3, 0x3, 0x33, 0x33, 0x30,\n\n    /* U+003E \">\" */\n    0x4, 0x0, 0x0, 0x0, 0xe, 0xd7, 0x10, 0x0,\n    0x0, 0x5c, 0xf9, 0x20, 0x0, 0x0, 0x2a, 0xf2,\n    0x0, 0x3, 0xaf, 0xb1, 0x6, 0xde, 0x82, 0x0,\n    0x1c, 0x60, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+003F \"?\" */\n    0x7, 0xdf, 0xea, 0x10, 0x9e, 0x74, 0x6e, 0xc0,\n    0x1, 0x0, 0x6, 0xf0, 0x0, 0x0, 0x9, 0xc0,\n    0x0, 0x0, 0x8e, 0x20, 0x0, 0x6, 0xf2, 0x0,\n    0x0, 0x8, 0x70, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xb, 0x80, 0x0, 0x0, 0xc, 0x90, 0x0,\n\n    /* U+0040 \"@\" */\n    0x0, 0x0, 0x6c, 0xef, 0xda, 0x40, 0x0, 0x0,\n    0x3d, 0xa4, 0x10, 0x16, 0xd9, 0x0, 0x1, 0xe5,\n    0x9, 0xee, 0x98, 0xca, 0x90, 0xa, 0x80, 0xbd,\n    0x43, 0xaf, 0xc0, 0xd3, 0xf, 0x13, 0xf2, 0x0,\n    0xc, 0xc0, 0x69, 0x3c, 0x6, 0xd0, 0x0, 0x7,\n    0xc0, 0x3b, 0x4b, 0x6, 0xd0, 0x0, 0x7, 0xc0,\n    0x2c, 0x3c, 0x3, 0xf2, 0x0, 0xc, 0xc0, 0x4a,\n    0xf, 0x10, 0xbd, 0x43, 0x9e, 0xe3, 0xc5, 0xa,\n    0x80, 0x9, 0xee, 0x91, 0xcf, 0x90, 0x1, 0xe5,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3d, 0xa4,\n    0x10, 0x28, 0x0, 0x0, 0x0, 0x0, 0x7c, 0xef,\n    0xd9, 0x10, 0x0,\n\n    /* U+0041 \"A\" */\n    0x0, 0x0, 0xc, 0xf1, 0x0, 0x0, 0x0, 0x0,\n    0x3f, 0xd7, 0x0, 0x0, 0x0, 0x0, 0xb9, 0x6e,\n    0x0, 0x0, 0x0, 0x2, 0xf2, 0xe, 0x50, 0x0,\n    0x0, 0x9, 0xa0, 0x7, 0xd0, 0x0, 0x0, 0x1f,\n    0x30, 0x0, 0xf4, 0x0, 0x0, 0x7f, 0xff, 0xff,\n    0xfb, 0x0, 0x0, 0xe7, 0x33, 0x33, 0x4f, 0x20,\n    0x5, 0xf0, 0x0, 0x0, 0xc, 0x90, 0xc, 0x90,\n    0x0, 0x0, 0x6, 0xf1,\n\n    /* U+0042 \"B\" */\n    0x8f, 0xff, 0xfe, 0xc4, 0x8, 0xe3, 0x33, 0x4b,\n    0xf2, 0x8e, 0x0, 0x0, 0x1f, 0x58, 0xe0, 0x0,\n    0x18, 0xf1, 0x8f, 0xff, 0xff, 0xf8, 0x8, 0xe3,\n    0x33, 0x37, 0xf6, 0x8e, 0x0, 0x0, 0x9, 0xc8,\n    0xe0, 0x0, 0x0, 0x9d, 0x8e, 0x33, 0x34, 0x7f,\n    0x78, 0xff, 0xff, 0xfd, 0x70,\n\n    /* U+0043 \"C\" */\n    0x0, 0x7, 0xcf, 0xfb, 0x40, 0x0, 0xcf, 0x96,\n    0x6a, 0xf5, 0xa, 0xe2, 0x0, 0x0, 0x30, 0x1f,\n    0x60, 0x0, 0x0, 0x0, 0x4f, 0x20, 0x0, 0x0,\n    0x0, 0x4f, 0x20, 0x0, 0x0, 0x0, 0x1f, 0x60,\n    0x0, 0x0, 0x0, 0xa, 0xe2, 0x0, 0x0, 0x30,\n    0x1, 0xcf, 0x96, 0x6a, 0xf5, 0x0, 0x7, 0xdf,\n    0xfb, 0x40,\n\n    /* U+0044 \"D\" */\n    0x8f, 0xff, 0xfe, 0xa4, 0x0, 0x8e, 0x44, 0x46,\n    0xcf, 0x70, 0x8e, 0x0, 0x0, 0x7, 0xf3, 0x8e,\n    0x0, 0x0, 0x0, 0xda, 0x8e, 0x0, 0x0, 0x0,\n    0x9d, 0x8e, 0x0, 0x0, 0x0, 0x9d, 0x8e, 0x0,\n    0x0, 0x0, 0xda, 0x8e, 0x0, 0x0, 0x7, 0xf3,\n    0x8e, 0x44, 0x46, 0xbf, 0x70, 0x8f, 0xff, 0xfe,\n    0xa4, 0x0,\n\n    /* U+0045 \"E\" */\n    0x8f, 0xff, 0xff, 0xf6, 0x8e, 0x44, 0x44, 0x41,\n    0x8e, 0x0, 0x0, 0x0, 0x8e, 0x0, 0x0, 0x0,\n    0x8f, 0xff, 0xff, 0xc0, 0x8e, 0x33, 0x33, 0x20,\n    0x8e, 0x0, 0x0, 0x0, 0x8e, 0x0, 0x0, 0x0,\n    0x8e, 0x44, 0x44, 0x42, 0x8f, 0xff, 0xff, 0xf9,\n\n    /* U+0046 \"F\" */\n    0x8f, 0xff, 0xff, 0xf6, 0x8e, 0x44, 0x44, 0x41,\n    0x8e, 0x0, 0x0, 0x0, 0x8e, 0x0, 0x0, 0x0,\n    0x8e, 0x0, 0x0, 0x0, 0x8f, 0xff, 0xff, 0xc0,\n    0x8e, 0x33, 0x33, 0x20, 0x8e, 0x0, 0x0, 0x0,\n    0x8e, 0x0, 0x0, 0x0, 0x8e, 0x0, 0x0, 0x0,\n\n    /* U+0047 \"G\" */\n    0x0, 0x7, 0xcf, 0xfc, 0x50, 0x0, 0xcf, 0x96,\n    0x6a, 0xf6, 0xa, 0xe2, 0x0, 0x0, 0x20, 0x1f,\n    0x60, 0x0, 0x0, 0x0, 0x4f, 0x20, 0x0, 0x0,\n    0x0, 0x4f, 0x20, 0x0, 0x0, 0xb9, 0x1f, 0x60,\n    0x0, 0x0, 0xb9, 0xa, 0xe3, 0x0, 0x0, 0xb9,\n    0x0, 0xcf, 0x96, 0x6a, 0xf8, 0x0, 0x7, 0xdf,\n    0xfc, 0x60,\n\n    /* U+0048 \"H\" */\n    0x8e, 0x0, 0x0, 0x8, 0xe8, 0xe0, 0x0, 0x0,\n    0x8e, 0x8e, 0x0, 0x0, 0x8, 0xe8, 0xe0, 0x0,\n    0x0, 0x8e, 0x8f, 0xff, 0xff, 0xff, 0xe8, 0xe3,\n    0x33, 0x33, 0x9e, 0x8e, 0x0, 0x0, 0x8, 0xe8,\n    0xe0, 0x0, 0x0, 0x8e, 0x8e, 0x0, 0x0, 0x8,\n    0xe8, 0xe0, 0x0, 0x0, 0x8e,\n\n    /* U+0049 \"I\" */\n    0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,\n    0x8e, 0x8e,\n\n    /* U+004A \"J\" */\n    0x2, 0xff, 0xff, 0xc0, 0x4, 0x44, 0xbc, 0x0,\n    0x0, 0x9, 0xc0, 0x0, 0x0, 0x9c, 0x0, 0x0,\n    0x9, 0xc0, 0x0, 0x0, 0x9c, 0x0, 0x0, 0x9,\n    0xc0, 0x20, 0x0, 0xba, 0xe, 0xb5, 0x8f, 0x60,\n    0x3c, 0xfe, 0x80,\n\n    /* U+004B \"K\" */\n    0x8e, 0x0, 0x0, 0x4f, 0x50, 0x8e, 0x0, 0x4,\n    0xf6, 0x0, 0x8e, 0x0, 0x3f, 0x70, 0x0, 0x8e,\n    0x3, 0xf8, 0x0, 0x0, 0x8e, 0x2e, 0xc0, 0x0,\n    0x0, 0x8e, 0xec, 0xf6, 0x0, 0x0, 0x8f, 0xb0,\n    0x7f, 0x30, 0x0, 0x8e, 0x0, 0xa, 0xe1, 0x0,\n    0x8e, 0x0, 0x0, 0xcc, 0x0, 0x8e, 0x0, 0x0,\n    0x1e, 0xa0,\n\n    /* U+004C \"L\" */\n    0x8e, 0x0, 0x0, 0x0, 0x8e, 0x0, 0x0, 0x0,\n    0x8e, 0x0, 0x0, 0x0, 0x8e, 0x0, 0x0, 0x0,\n    0x8e, 0x0, 0x0, 0x0, 0x8e, 0x0, 0x0, 0x0,\n    0x8e, 0x0, 0x0, 0x0, 0x8e, 0x0, 0x0, 0x0,\n    0x8e, 0x44, 0x44, 0x40, 0x8f, 0xff, 0xff, 0xf2,\n\n    /* U+004D \"M\" */\n    0x8e, 0x0, 0x0, 0x0, 0x8, 0xe8, 0xf7, 0x0,\n    0x0, 0x2, 0xfe, 0x8f, 0xf1, 0x0, 0x0, 0xbf,\n    0xe8, 0xdc, 0xa0, 0x0, 0x4f, 0x9e, 0x8d, 0x2f,\n    0x30, 0xd, 0x87, 0xe8, 0xd0, 0x9c, 0x6, 0xe0,\n    0x7e, 0x8d, 0x1, 0xe7, 0xe5, 0x7, 0xe8, 0xd0,\n    0x6, 0xfc, 0x0, 0x7e, 0x8d, 0x0, 0xa, 0x20,\n    0x7, 0xe8, 0xd0, 0x0, 0x0, 0x0, 0x7e,\n\n    /* U+004E \"N\" */\n    0x8e, 0x10, 0x0, 0x8, 0xe8, 0xfc, 0x0, 0x0,\n    0x8e, 0x8f, 0xf9, 0x0, 0x8, 0xe8, 0xe6, 0xf6,\n    0x0, 0x8e, 0x8e, 0x9, 0xf3, 0x8, 0xe8, 0xe0,\n    0xc, 0xe1, 0x8e, 0x8e, 0x0, 0x1e, 0xb8, 0xe8,\n    0xe0, 0x0, 0x3f, 0xee, 0x8e, 0x0, 0x0, 0x6f,\n    0xe8, 0xe0, 0x0, 0x0, 0xae,\n\n    /* U+004F \"O\" */\n    0x0, 0x7, 0xcf, 0xeb, 0x50, 0x0, 0x0, 0xcf,\n    0x96, 0x6b, 0xf9, 0x0, 0xa, 0xe2, 0x0, 0x0,\n    0x5f, 0x60, 0x1f, 0x60, 0x0, 0x0, 0xa, 0xd0,\n    0x4f, 0x20, 0x0, 0x0, 0x6, 0xf0, 0x4f, 0x20,\n    0x0, 0x0, 0x6, 0xf0, 0x1f, 0x60, 0x0, 0x0,\n    0xa, 0xd0, 0xa, 0xe2, 0x0, 0x0, 0x5f, 0x60,\n    0x0, 0xcf, 0x96, 0x6b, 0xfa, 0x0, 0x0, 0x7,\n    0xdf, 0xeb, 0x50, 0x0,\n\n    /* U+0050 \"P\" */\n    0x8f, 0xff, 0xfd, 0x70, 0x8, 0xe4, 0x45, 0x8f,\n    0xb0, 0x8e, 0x0, 0x0, 0x5f, 0x38, 0xe0, 0x0,\n    0x1, 0xf5, 0x8e, 0x0, 0x0, 0x3f, 0x48, 0xe0,\n    0x1, 0x4d, 0xd0, 0x8f, 0xff, 0xff, 0xb2, 0x8,\n    0xe3, 0x33, 0x10, 0x0, 0x8e, 0x0, 0x0, 0x0,\n    0x8, 0xe0, 0x0, 0x0, 0x0,\n\n    /* U+0051 \"Q\" */\n    0x0, 0x7, 0xcf, 0xeb, 0x50, 0x0, 0x0, 0xcf,\n    0x96, 0x6b, 0xf9, 0x0, 0xa, 0xe2, 0x0, 0x0,\n    0x5f, 0x60, 0x1f, 0x60, 0x0, 0x0, 0xa, 0xd0,\n    0x4f, 0x20, 0x0, 0x0, 0x6, 0xf0, 0x4f, 0x20,\n    0x0, 0x0, 0x5, 0xf0, 0x1f, 0x60, 0x0, 0x0,\n    0xa, 0xd0, 0xa, 0xe2, 0x0, 0x0, 0x5f, 0x60,\n    0x1, 0xdf, 0x85, 0x5a, 0xfa, 0x0, 0x0, 0x8,\n    0xdf, 0xfc, 0x50, 0x0, 0x0, 0x0, 0x1, 0xec,\n    0x21, 0x94, 0x0, 0x0, 0x0, 0x1b, 0xff, 0xc1,\n    0x0, 0x0, 0x0, 0x0, 0x12, 0x0,\n\n    /* U+0052 \"R\" */\n    0x8f, 0xff, 0xfd, 0x70, 0x8, 0xe4, 0x45, 0x8f,\n    0xb0, 0x8e, 0x0, 0x0, 0x5f, 0x38, 0xe0, 0x0,\n    0x1, 0xf5, 0x8e, 0x0, 0x0, 0x3f, 0x38, 0xe0,\n    0x1, 0x4d, 0xd0, 0x8f, 0xff, 0xff, 0xc2, 0x8,\n    0xe3, 0x33, 0xda, 0x0, 0x8e, 0x0, 0x2, 0xf6,\n    0x8, 0xe0, 0x0, 0x5, 0xf3,\n\n    /* U+0053 \"S\" */\n    0x1, 0x9e, 0xfd, 0xa2, 0x0, 0xce, 0x64, 0x6b,\n    0x70, 0x2f, 0x40, 0x0, 0x0, 0x1, 0xf8, 0x0,\n    0x0, 0x0, 0x6, 0xfd, 0x95, 0x0, 0x0, 0x1,\n    0x6a, 0xee, 0x50, 0x0, 0x0, 0x0, 0x9f, 0x0,\n    0x20, 0x0, 0x5, 0xf1, 0x3f, 0xa5, 0x47, 0xeb,\n    0x0, 0x4b, 0xef, 0xe9, 0x10,\n\n    /* U+0054 \"T\" */\n    0xff, 0xff, 0xff, 0xff, 0x24, 0x44, 0xbd, 0x44,\n    0x40, 0x0, 0x9, 0xc0, 0x0, 0x0, 0x0, 0x9c,\n    0x0, 0x0, 0x0, 0x9, 0xc0, 0x0, 0x0, 0x0,\n    0x9c, 0x0, 0x0, 0x0, 0x9, 0xc0, 0x0, 0x0,\n    0x0, 0x9c, 0x0, 0x0, 0x0, 0x9, 0xc0, 0x0,\n    0x0, 0x0, 0x9c, 0x0, 0x0,\n\n    /* U+0055 \"U\" */\n    0x9c, 0x0, 0x0, 0xb, 0xa9, 0xc0, 0x0, 0x0,\n    0xba, 0x9c, 0x0, 0x0, 0xb, 0xa9, 0xc0, 0x0,\n    0x0, 0xba, 0x9c, 0x0, 0x0, 0xb, 0xa9, 0xc0,\n    0x0, 0x0, 0xba, 0x8e, 0x0, 0x0, 0xd, 0x94,\n    0xf4, 0x0, 0x3, 0xf5, 0xc, 0xf8, 0x68, 0xfd,\n    0x0, 0x9, 0xef, 0xe9, 0x10,\n\n    /* U+0056 \"V\" */\n    0xc, 0xb0, 0x0, 0x0, 0xa, 0xc0, 0x5f, 0x20,\n    0x0, 0x1, 0xf5, 0x0, 0xe9, 0x0, 0x0, 0x8e,\n    0x0, 0x8, 0xf0, 0x0, 0xe, 0x70, 0x0, 0x1f,\n    0x60, 0x5, 0xf1, 0x0, 0x0, 0xad, 0x0, 0xc9,\n    0x0, 0x0, 0x3, 0xf4, 0x3f, 0x30, 0x0, 0x0,\n    0xc, 0xba, 0xc0, 0x0, 0x0, 0x0, 0x5f, 0xf5,\n    0x0, 0x0, 0x0, 0x0, 0xee, 0x0, 0x0,\n\n    /* U+0057 \"W\" */\n    0x6f, 0x10, 0x0, 0xd, 0xb0, 0x0, 0x2, 0xf2,\n    0x1f, 0x60, 0x0, 0x3f, 0xf1, 0x0, 0x8, 0xd0,\n    0xb, 0xb0, 0x0, 0x8b, 0xe6, 0x0, 0xd, 0x70,\n    0x6, 0xf0, 0x0, 0xe6, 0x9b, 0x0, 0x2f, 0x20,\n    0x1, 0xf5, 0x3, 0xf1, 0x4f, 0x10, 0x8d, 0x0,\n    0x0, 0xca, 0x9, 0xb0, 0xe, 0x60, 0xd8, 0x0,\n    0x0, 0x6f, 0xe, 0x60, 0x9, 0xb2, 0xf3, 0x0,\n    0x0, 0x1f, 0x9f, 0x10, 0x4, 0xf9, 0xd0, 0x0,\n    0x0, 0xc, 0xfb, 0x0, 0x0, 0xef, 0x80, 0x0,\n    0x0, 0x7, 0xf6, 0x0, 0x0, 0x9f, 0x30, 0x0,\n\n    /* U+0058 \"X\" */\n    0x3f, 0x50, 0x0, 0xd, 0xa0, 0x8, 0xf2, 0x0,\n    0x9d, 0x0, 0x0, 0xcc, 0x4, 0xf3, 0x0, 0x0,\n    0x2f, 0x9e, 0x70, 0x0, 0x0, 0x6, 0xfc, 0x0,\n    0x0, 0x0, 0x9, 0xfe, 0x10, 0x0, 0x0, 0x4f,\n    0x4d, 0xb0, 0x0, 0x1, 0xe8, 0x2, 0xf7, 0x0,\n    0xb, 0xd0, 0x0, 0x7f, 0x20, 0x7f, 0x20, 0x0,\n    0xb, 0xd0,\n\n    /* U+0059 \"Y\" */\n    0xc, 0xb0, 0x0, 0x0, 0x9c, 0x0, 0x2f, 0x50,\n    0x0, 0x2f, 0x30, 0x0, 0x9e, 0x0, 0xc, 0x90,\n    0x0, 0x0, 0xe8, 0x5, 0xf1, 0x0, 0x0, 0x5,\n    0xf3, 0xe6, 0x0, 0x0, 0x0, 0xc, 0xfd, 0x0,\n    0x0, 0x0, 0x0, 0x3f, 0x40, 0x0, 0x0, 0x0,\n    0x2, 0xf3, 0x0, 0x0, 0x0, 0x0, 0x2f, 0x30,\n    0x0, 0x0, 0x0, 0x2, 0xf3, 0x0, 0x0,\n\n    /* U+005A \"Z\" */\n    0x4f, 0xff, 0xff, 0xff, 0x91, 0x44, 0x44, 0x4a,\n    0xf3, 0x0, 0x0, 0x3, 0xf6, 0x0, 0x0, 0x1,\n    0xea, 0x0, 0x0, 0x0, 0xcc, 0x0, 0x0, 0x0,\n    0x9e, 0x10, 0x0, 0x0, 0x6f, 0x40, 0x0, 0x0,\n    0x3f, 0x70, 0x0, 0x0, 0x1e, 0xd4, 0x44, 0x44,\n    0x36, 0xff, 0xff, 0xff, 0xfc,\n\n    /* U+005B \"[\" */\n    0x8f, 0xf6, 0x8d, 0x31, 0x8d, 0x0, 0x8d, 0x0,\n    0x8d, 0x0, 0x8d, 0x0, 0x8d, 0x0, 0x8d, 0x0,\n    0x8d, 0x0, 0x8d, 0x0, 0x8d, 0x0, 0x8d, 0x0,\n    0x8d, 0x31, 0x8f, 0xf6,\n\n    /* U+005C \"\\\\\" */\n    0x5d, 0x0, 0x0, 0x0, 0xf2, 0x0, 0x0, 0xb,\n    0x80, 0x0, 0x0, 0x6d, 0x0, 0x0, 0x1, 0xf2,\n    0x0, 0x0, 0xb, 0x80, 0x0, 0x0, 0x6d, 0x0,\n    0x0, 0x1, 0xf2, 0x0, 0x0, 0xb, 0x70, 0x0,\n    0x0, 0x6d, 0x0, 0x0, 0x1, 0xf2, 0x0, 0x0,\n    0xb, 0x70, 0x0, 0x0, 0x6d, 0x0, 0x0, 0x1,\n    0xf2,\n\n    /* U+005D \"]\" */\n    0xbf, 0xf3, 0x25, 0xf3, 0x2, 0xf3, 0x2, 0xf3,\n    0x2, 0xf3, 0x2, 0xf3, 0x2, 0xf3, 0x2, 0xf3,\n    0x2, 0xf3, 0x2, 0xf3, 0x2, 0xf3, 0x2, 0xf3,\n    0x25, 0xf3, 0xbf, 0xf3,\n\n    /* U+005E \"^\" */\n    0x0, 0xad, 0x0, 0x0, 0x1e, 0xc4, 0x0, 0x8,\n    0x85, 0xa0, 0x0, 0xe2, 0xe, 0x10, 0x5b, 0x0,\n    0x97, 0xb, 0x50, 0x2, 0xe0,\n\n    /* U+005F \"_\" */\n    0xee, 0xee, 0xee, 0xe0,\n\n    /* U+0060 \"`\" */\n    0xb, 0xc0, 0x0, 0x9, 0xb0,\n\n    /* U+0061 \"a\" */\n    0x4, 0xcf, 0xea, 0x10, 0xb, 0x74, 0x5d, 0xb0,\n    0x0, 0x0, 0x4, 0xf0, 0x4, 0xce, 0xee, 0xf2,\n    0x1f, 0x82, 0x14, 0xf2, 0x4f, 0x10, 0x4, 0xf2,\n    0x1f, 0x70, 0x3d, 0xf2, 0x4, 0xdf, 0xd7, 0xf2,\n\n    /* U+0062 \"b\" */\n    0xba, 0x0, 0x0, 0x0, 0xba, 0x0, 0x0, 0x0,\n    0xba, 0x0, 0x0, 0x0, 0xba, 0x8e, 0xfc, 0x30,\n    0xbf, 0xd5, 0x4b, 0xf3, 0xbe, 0x10, 0x0, 0xca,\n    0xba, 0x0, 0x0, 0x7e, 0xba, 0x0, 0x0, 0x7e,\n    0xbe, 0x10, 0x0, 0xca, 0xbf, 0xd5, 0x5b, 0xf3,\n    0xb9, 0x8e, 0xfc, 0x30,\n\n    /* U+0063 \"c\" */\n    0x0, 0x7d, 0xfd, 0x60, 0x9, 0xf7, 0x48, 0xf4,\n    0x2f, 0x50, 0x0, 0x20, 0x5f, 0x0, 0x0, 0x0,\n    0x5f, 0x0, 0x0, 0x0, 0x2f, 0x50, 0x0, 0x20,\n    0x9, 0xf7, 0x48, 0xf4, 0x0, 0x7d, 0xfd, 0x60,\n\n    /* U+0064 \"d\" */\n    0x0, 0x0, 0x0, 0x1f, 0x40, 0x0, 0x0, 0x1,\n    0xf4, 0x0, 0x0, 0x0, 0x1f, 0x40, 0x8, 0xef,\n    0xc4, 0xf4, 0xa, 0xf7, 0x48, 0xff, 0x42, 0xf5,\n    0x0, 0x7, 0xf4, 0x5f, 0x0, 0x0, 0x2f, 0x45,\n    0xf0, 0x0, 0x1, 0xf4, 0x2f, 0x50, 0x0, 0x6f,\n    0x40, 0xae, 0x63, 0x7e, 0xf4, 0x0, 0x8e, 0xfc,\n    0x4f, 0x40,\n\n    /* U+0065 \"e\" */\n    0x0, 0x8e, 0xfc, 0x40, 0xa, 0xd5, 0x38, 0xf4,\n    0x2f, 0x20, 0x0, 0x8c, 0x5f, 0xee, 0xee, 0xff,\n    0x5f, 0x21, 0x11, 0x11, 0x2f, 0x70, 0x0, 0x10,\n    0x9, 0xf8, 0x46, 0xe4, 0x0, 0x7d, 0xfe, 0x80,\n\n    /* U+0066 \"f\" */\n    0x0, 0x9e, 0xe3, 0x5, 0xf4, 0x41, 0x8, 0xc0,\n    0x0, 0xcf, 0xff, 0xf0, 0x29, 0xd3, 0x20, 0x8,\n    0xd0, 0x0, 0x8, 0xd0, 0x0, 0x8, 0xd0, 0x0,\n    0x8, 0xd0, 0x0, 0x8, 0xd0, 0x0, 0x8, 0xd0,\n    0x0,\n\n    /* U+0067 \"g\" */\n    0x0, 0x7e, 0xfc, 0x4e, 0x60, 0xaf, 0x74, 0x7f,\n    0xf6, 0x2f, 0x50, 0x0, 0x5f, 0x65, 0xf0, 0x0,\n    0x0, 0xf6, 0x5f, 0x0, 0x0, 0xf, 0x62, 0xf6,\n    0x0, 0x6, 0xf6, 0x9, 0xf7, 0x47, 0xff, 0x50,\n    0x7, 0xef, 0xc4, 0xf5, 0x0, 0x0, 0x0, 0x3f,\n    0x20, 0xcb, 0x64, 0x6e, 0xb0, 0x3, 0xae, 0xfd,\n    0x80, 0x0,\n\n    /* U+0068 \"h\" */\n    0xba, 0x0, 0x0, 0x0, 0xba, 0x0, 0x0, 0x0,\n    0xba, 0x0, 0x0, 0x0, 0xba, 0x8e, 0xfb, 0x20,\n    0xbf, 0xc5, 0x6d, 0xd0, 0xbe, 0x0, 0x3, 0xf2,\n    0xba, 0x0, 0x0, 0xf4, 0xba, 0x0, 0x0, 0xf5,\n    0xba, 0x0, 0x0, 0xf5, 0xba, 0x0, 0x0, 0xf5,\n    0xba, 0x0, 0x0, 0xf5,\n\n    /* U+0069 \"i\" */\n    0xba, 0xa8, 0x0, 0xba, 0xba, 0xba, 0xba, 0xba,\n    0xba, 0xba, 0xba,\n\n    /* U+006A \"j\" */\n    0x0, 0xa, 0xb0, 0x0, 0x99, 0x0, 0x0, 0x0,\n    0x0, 0xab, 0x0, 0xa, 0xb0, 0x0, 0xab, 0x0,\n    0xa, 0xb0, 0x0, 0xab, 0x0, 0xa, 0xb0, 0x0,\n    0xab, 0x0, 0xa, 0xb0, 0x0, 0xaa, 0x6, 0x4e,\n    0x71, 0xdf, 0xa0,\n\n    /* U+006B \"k\" */\n    0xba, 0x0, 0x0, 0x0, 0xba, 0x0, 0x0, 0x0,\n    0xba, 0x0, 0x0, 0x0, 0xba, 0x0, 0x1c, 0xc0,\n    0xba, 0x1, 0xcc, 0x0, 0xba, 0x1c, 0xd1, 0x0,\n    0xbb, 0xcf, 0x60, 0x0, 0xbf, 0xdb, 0xe1, 0x0,\n    0xbd, 0x11, 0xdc, 0x0, 0xba, 0x0, 0x3f, 0x70,\n    0xba, 0x0, 0x7, 0xf3,\n\n    /* U+006C \"l\" */\n    0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba,\n    0xba, 0xba, 0xba,\n\n    /* U+006D \"m\" */\n    0xb9, 0x9e, 0xfa, 0x15, 0xdf, 0xd4, 0xb, 0xfb,\n    0x45, 0xed, 0xe6, 0x4a, 0xf2, 0xbe, 0x0, 0x6,\n    0xf6, 0x0, 0xe, 0x7b, 0xa0, 0x0, 0x4f, 0x20,\n    0x0, 0xc9, 0xba, 0x0, 0x3, 0xf1, 0x0, 0xc,\n    0x9b, 0xa0, 0x0, 0x3f, 0x10, 0x0, 0xc9, 0xba,\n    0x0, 0x3, 0xf1, 0x0, 0xc, 0x9b, 0xa0, 0x0,\n    0x3f, 0x10, 0x0, 0xc9,\n\n    /* U+006E \"n\" */\n    0xb9, 0x9e, 0xfb, 0x20, 0xbf, 0xb4, 0x5d, 0xd0,\n    0xbe, 0x0, 0x3, 0xf2, 0xba, 0x0, 0x0, 0xf4,\n    0xba, 0x0, 0x0, 0xf5, 0xba, 0x0, 0x0, 0xf5,\n    0xba, 0x0, 0x0, 0xf5, 0xba, 0x0, 0x0, 0xf5,\n\n    /* U+006F \"o\" */\n    0x0, 0x7d, 0xfd, 0x60, 0x0, 0x9f, 0x74, 0x8f,\n    0x70, 0x2f, 0x50, 0x0, 0x7f, 0x5, 0xf0, 0x0,\n    0x1, 0xf3, 0x5f, 0x0, 0x0, 0x2f, 0x32, 0xf5,\n    0x0, 0x7, 0xf0, 0x9, 0xf7, 0x48, 0xf7, 0x0,\n    0x7, 0xdf, 0xd6, 0x0,\n\n    /* U+0070 \"p\" */\n    0xb9, 0x8e, 0xfc, 0x30, 0xbf, 0xc4, 0x3a, 0xf3,\n    0xbe, 0x10, 0x0, 0xca, 0xba, 0x0, 0x0, 0x7e,\n    0xba, 0x0, 0x0, 0x7e, 0xbe, 0x10, 0x0, 0xca,\n    0xbf, 0xd5, 0x5b, 0xf3, 0xba, 0x7e, 0xfc, 0x30,\n    0xba, 0x0, 0x0, 0x0, 0xba, 0x0, 0x0, 0x0,\n    0xba, 0x0, 0x0, 0x0,\n\n    /* U+0071 \"q\" */\n    0x0, 0x8e, 0xfc, 0x3f, 0x40, 0xaf, 0x74, 0x8e,\n    0xf4, 0x2f, 0x50, 0x0, 0x7f, 0x45, 0xf0, 0x0,\n    0x1, 0xf4, 0x5f, 0x0, 0x0, 0x2f, 0x42, 0xf5,\n    0x0, 0x7, 0xf4, 0xa, 0xf7, 0x48, 0xff, 0x40,\n    0x8, 0xef, 0xc4, 0xf4, 0x0, 0x0, 0x0, 0x1f,\n    0x40, 0x0, 0x0, 0x1, 0xf4, 0x0, 0x0, 0x0,\n    0x1f, 0x40,\n\n    /* U+0072 \"r\" */\n    0xb9, 0x8e, 0x4b, 0xfd, 0x71, 0xbe, 0x10, 0xb,\n    0xb0, 0x0, 0xba, 0x0, 0xb, 0xa0, 0x0, 0xba,\n    0x0, 0xb, 0xa0, 0x0,\n\n    /* U+0073 \"s\" */\n    0x5, 0xdf, 0xea, 0x13, 0xf7, 0x35, 0xa0, 0x6f,\n    0x0, 0x0, 0x1, 0xee, 0x96, 0x10, 0x1, 0x6a,\n    0xef, 0x30, 0x0, 0x0, 0xd9, 0x6c, 0x64, 0x6f,\n    0x62, 0xae, 0xfd, 0x70,\n\n    /* U+0074 \"t\" */\n    0x8, 0xd0, 0x0, 0x8, 0xd0, 0x0, 0xcf, 0xff,\n    0xf0, 0x29, 0xd3, 0x20, 0x8, 0xd0, 0x0, 0x8,\n    0xd0, 0x0, 0x8, 0xd0, 0x0, 0x8, 0xd0, 0x0,\n    0x5, 0xf5, 0x51, 0x0, 0x9f, 0xe3,\n\n    /* U+0075 \"u\" */\n    0xc8, 0x0, 0x2, 0xf3, 0xc8, 0x0, 0x2, 0xf3,\n    0xc8, 0x0, 0x2, 0xf3, 0xc8, 0x0, 0x2, 0xf3,\n    0xc9, 0x0, 0x3, 0xf3, 0xab, 0x0, 0x7, 0xf3,\n    0x5f, 0x83, 0x7e, 0xf3, 0x6, 0xdf, 0xc5, 0xf3,\n\n    /* U+0076 \"v\" */\n    0xd, 0x90, 0x0, 0xa, 0xa0, 0x6e, 0x0, 0x1,\n    0xf3, 0x0, 0xf5, 0x0, 0x7d, 0x0, 0x9, 0xc0,\n    0xe, 0x60, 0x0, 0x3f, 0x24, 0xf0, 0x0, 0x0,\n    0xc8, 0xb9, 0x0, 0x0, 0x6, 0xff, 0x30, 0x0,\n    0x0, 0xf, 0xc0, 0x0,\n\n    /* U+0077 \"w\" */\n    0xc8, 0x0, 0x6, 0xf1, 0x0, 0xd, 0x56, 0xd0,\n    0x0, 0xcf, 0x60, 0x3, 0xf0, 0x1f, 0x30, 0x2f,\n    0x9c, 0x0, 0x9a, 0x0, 0xb8, 0x7, 0xb2, 0xf1,\n    0xe, 0x40, 0x5, 0xe0, 0xd6, 0xc, 0x74, 0xe0,\n    0x0, 0xf, 0x6f, 0x0, 0x7c, 0x99, 0x0, 0x0,\n    0xaf, 0xa0, 0x1, 0xff, 0x40, 0x0, 0x5, 0xf4,\n    0x0, 0xb, 0xe0, 0x0,\n\n    /* U+0078 \"x\" */\n    0x4f, 0x30, 0x7, 0xe1, 0x9, 0xd0, 0x2f, 0x40,\n    0x0, 0xd9, 0xd9, 0x0, 0x0, 0x3f, 0xd0, 0x0,\n    0x0, 0x4f, 0xe1, 0x0, 0x1, 0xe7, 0xbb, 0x0,\n    0xb, 0xb0, 0x1e, 0x70, 0x7e, 0x10, 0x5, 0xf3,\n\n    /* U+0079 \"y\" */\n    0xd, 0x90, 0x0, 0xa, 0xa0, 0x6f, 0x0, 0x1,\n    0xf3, 0x0, 0xf6, 0x0, 0x7d, 0x0, 0x9, 0xc0,\n    0xd, 0x60, 0x0, 0x2f, 0x34, 0xf0, 0x0, 0x0,\n    0xc9, 0xa9, 0x0, 0x0, 0x5, 0xff, 0x20, 0x0,\n    0x0, 0xe, 0xc0, 0x0, 0x0, 0x0, 0xe5, 0x0,\n    0x0, 0x94, 0xad, 0x0, 0x0, 0x1b, 0xfc, 0x20,\n    0x0, 0x0,\n\n    /* U+007A \"z\" */\n    0x5f, 0xff, 0xff, 0xa1, 0x33, 0x37, 0xf4, 0x0,\n    0x1, 0xe7, 0x0, 0x0, 0xcb, 0x0, 0x0, 0x8e,\n    0x10, 0x0, 0x4f, 0x40, 0x0, 0x1e, 0xa3, 0x33,\n    0x26, 0xff, 0xff, 0xfc,\n\n    /* U+007B \"{\" */\n    0x0, 0x6e, 0xa0, 0xf, 0x92, 0x1, 0xf4, 0x0,\n    0x1f, 0x40, 0x1, 0xf4, 0x0, 0x3f, 0x30, 0x3f,\n    0xc0, 0x0, 0x6f, 0x30, 0x1, 0xf4, 0x0, 0x1f,\n    0x40, 0x1, 0xf4, 0x0, 0x1f, 0x40, 0x0, 0xfa,\n    0x20, 0x5, 0xea,\n\n    /* U+007C \"|\" */\n    0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,\n    0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,\n\n    /* U+007D \"}\" */\n    0xbe, 0x50, 0x2, 0xae, 0x0, 0x5, 0xf0, 0x0,\n    0x5f, 0x0, 0x5, 0xf0, 0x0, 0x4f, 0x10, 0x0,\n    0xdf, 0x10, 0x4f, 0x50, 0x5, 0xf0, 0x0, 0x5f,\n    0x0, 0x5, 0xf0, 0x0, 0x5f, 0x0, 0x2a, 0xe0,\n    0xb, 0xe4, 0x0,\n\n    /* U+007E \"~\" */\n    0x7, 0xec, 0x40, 0xb4, 0x1e, 0x25, 0xdf, 0xc0,\n    0x1, 0x0, 0x0, 0x0,\n\n    /* U+00B0 \"\u00b0\" */\n    0x4, 0xcc, 0x30, 0x2b, 0x1, 0xc0, 0x57, 0x0,\n    0x93, 0x2b, 0x1, 0xc0, 0x5, 0xcc, 0x30,\n\n    /* U+2022 \"\u2022\" */\n    0x6, 0xa1, 0xf, 0xf6, 0xb, 0xe2,\n\n    /* U+F001 \"\uf001\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x2, 0x7b, 0xfb, 0x0,\n    0x0, 0x0, 0x4, 0x9d, 0xff, 0xff, 0xd0, 0x0,\n    0x3, 0xaf, 0xff, 0xff, 0xff, 0xfd, 0x0, 0x0,\n    0xaf, 0xff, 0xff, 0xff, 0xdf, 0xd0, 0x0, 0xa,\n    0xff, 0xff, 0xb6, 0x10, 0xed, 0x0, 0x0, 0xaf,\n    0x94, 0x0, 0x0, 0xe, 0xd0, 0x0, 0xa, 0xf1,\n    0x0, 0x0, 0x0, 0xed, 0x0, 0x0, 0xaf, 0x10,\n    0x0, 0x0, 0xe, 0xd0, 0x0, 0xa, 0xf1, 0x0,\n    0x0, 0x45, 0xfd, 0x0, 0x0, 0xaf, 0x10, 0x1,\n    0xef, 0xff, 0xd0, 0x17, 0x9d, 0xf1, 0x0, 0x5f,\n    0xff, 0xfc, 0xe, 0xff, 0xff, 0x10, 0x0, 0xaf,\n    0xfd, 0x31, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x1,\n    0x0, 0x3, 0xbd, 0xa3, 0x0, 0x0, 0x0, 0x0,\n    0x0,\n\n    /* U+F008 \"\uf008\" */\n    0x50, 0x18, 0x88, 0x88, 0x88, 0x84, 0x5, 0xfa,\n    0xbf, 0xdd, 0xdd, 0xdd, 0xfd, 0xaf, 0xe4, 0x7f,\n    0x10, 0x0, 0x0, 0xca, 0x4e, 0xe0, 0x4f, 0x10,\n    0x0, 0x0, 0xc8, 0xe, 0xfe, 0xef, 0x10, 0x0,\n    0x0, 0xcf, 0xef, 0xe0, 0x3f, 0xee, 0xee, 0xee,\n    0xf8, 0xe, 0xf6, 0x8f, 0x76, 0x66, 0x66, 0xeb,\n    0x6f, 0xf8, 0xaf, 0x10, 0x0, 0x0, 0xcc, 0x8f,\n    0xe0, 0x3f, 0x10, 0x0, 0x0, 0xc8, 0xe, 0xfc,\n    0xdf, 0x65, 0x55, 0x55, 0xee, 0xcf, 0xc2, 0x5f,\n    0xff, 0xff, 0xff, 0xf9, 0x2c,\n\n    /* U+F00B \"\uf00b\" */\n    0x57, 0x75, 0x5, 0x77, 0x77, 0x77, 0x75, 0xff,\n    0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x2f, 0xff, 0xff, 0xff, 0xff, 0xef, 0xff, 0xe,\n    0xff, 0xff, 0xff, 0xfe, 0x1, 0x10, 0x0, 0x11,\n    0x11, 0x11, 0x10, 0xef, 0xfe, 0xe, 0xff, 0xff,\n    0xff, 0xfe, 0xff, 0xff, 0x2f, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x1f, 0xff, 0xff, 0xff, 0xff,\n    0x68, 0x87, 0x7, 0x88, 0x88, 0x88, 0x86, 0x68,\n    0x87, 0x7, 0x88, 0x88, 0x88, 0x86, 0xff, 0xff,\n    0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2f,\n    0xff, 0xff, 0xff, 0xff, 0xdf, 0xfd, 0xd, 0xff,\n    0xff, 0xff, 0xfd,\n\n    /* U+F00C \"\uf00c\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x50, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x1d, 0xf8, 0x0, 0x0,\n    0x0, 0x0, 0x1, 0xdf, 0xfd, 0x0, 0x0, 0x0,\n    0x0, 0x1d, 0xff, 0xe2, 0x2d, 0x60, 0x0, 0x1,\n    0xdf, 0xfe, 0x20, 0xdf, 0xf7, 0x0, 0x1d, 0xff,\n    0xe2, 0x0, 0x8f, 0xff, 0x71, 0xdf, 0xfe, 0x20,\n    0x0, 0x8, 0xff, 0xfe, 0xff, 0xe2, 0x0, 0x0,\n    0x0, 0x8f, 0xff, 0xfe, 0x20, 0x0, 0x0, 0x0,\n    0x8, 0xff, 0xe2, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x7d, 0x20, 0x0, 0x0, 0x0,\n\n    /* U+F00D \"\uf00d\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0x60, 0x0,\n    0xb, 0xe2, 0xef, 0xf6, 0x0, 0xbf, 0xf8, 0x4f,\n    0xff, 0x6b, 0xff, 0xd1, 0x4, 0xff, 0xff, 0xfd,\n    0x10, 0x0, 0x5f, 0xff, 0xe1, 0x0, 0x0, 0xbf,\n    0xff, 0xf6, 0x0, 0xb, 0xff, 0xdf, 0xff, 0x60,\n    0xbf, 0xfd, 0x14, 0xff, 0xf5, 0xcf, 0xd1, 0x0,\n    0x4f, 0xf6, 0x17, 0x10, 0x0, 0x3, 0x60,\n\n    /* U+F011 \"\uf011\" */\n    0x0, 0x0, 0x0, 0x11, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xff, 0x0, 0x0, 0x0, 0x0, 0x6f,\n    0x21, 0xff, 0x12, 0xf7, 0x0, 0x6, 0xff, 0x61,\n    0xff, 0x16, 0xff, 0x60, 0x1f, 0xf9, 0x1, 0xff,\n    0x10, 0x9f, 0xf1, 0x6f, 0xe0, 0x1, 0xff, 0x10,\n    0xe, 0xf6, 0xaf, 0x80, 0x1, 0xff, 0x10, 0x8,\n    0xfa, 0xcf, 0x60, 0x1, 0xff, 0x10, 0x6, 0xfc,\n    0xaf, 0x80, 0x0, 0xaa, 0x0, 0x8, 0xfb, 0x7f,\n    0xd0, 0x0, 0x0, 0x0, 0xd, 0xf7, 0x1f, 0xf8,\n    0x0, 0x0, 0x0, 0x8f, 0xf1, 0x7, 0xff, 0x91,\n    0x0, 0x2a, 0xff, 0x70, 0x0, 0x9f, 0xff, 0xee,\n    0xff, 0xf9, 0x0, 0x0, 0x5, 0xcf, 0xff, 0xfd,\n    0x50, 0x0, 0x0, 0x0, 0x2, 0x44, 0x20, 0x0,\n    0x0,\n\n    /* U+F013 \"\uf013\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xa, 0xff, 0xa0, 0x0, 0x0, 0x0, 0x0,\n    0xc, 0xff, 0xc0, 0x0, 0x0, 0x3, 0xd6, 0xdf,\n    0xff, 0xfd, 0x6d, 0x30, 0xe, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xe0, 0x5f, 0xff, 0xff, 0xaa, 0xff,\n    0xff, 0xf5, 0x1a, 0xff, 0xf4, 0x0, 0x4f, 0xff,\n    0xa1, 0x3, 0xff, 0xd0, 0x0, 0xd, 0xff, 0x30,\n    0x4, 0xff, 0xf0, 0x0, 0xf, 0xff, 0x40, 0x4f,\n    0xff, 0xfb, 0x22, 0xbf, 0xff, 0xf4, 0x2f, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xf2, 0x9, 0xfe, 0xff,\n    0xff, 0xff, 0xef, 0x90, 0x0, 0x50, 0x5e, 0xff,\n    0xe5, 0x5, 0x0, 0x0, 0x0, 0xc, 0xff, 0xc0,\n    0x0, 0x0, 0x0, 0x0, 0x4, 0x77, 0x40, 0x0,\n    0x0,\n\n    /* U+F015 \"\uf015\" */\n    0x0, 0x0, 0x0, 0x3, 0x10, 0x3, 0x41, 0x0,\n    0x0, 0x0, 0x0, 0x9f, 0xf5, 0xd, 0xf5, 0x0,\n    0x0, 0x0, 0x1b, 0xfd, 0xff, 0x8d, 0xf5, 0x0,\n    0x0, 0x2, 0xdf, 0xb1, 0x2d, 0xff, 0xf5, 0x0,\n    0x0, 0x4f, 0xf8, 0x3e, 0xc2, 0xbf, 0xf5, 0x0,\n    0x7, 0xff, 0x55, 0xff, 0xfe, 0x39, 0xfe, 0x40,\n    0x9f, 0xe3, 0x8f, 0xff, 0xff, 0xf5, 0x6f, 0xf6,\n    0xac, 0x2a, 0xff, 0xff, 0xff, 0xff, 0x73, 0xe6,\n    0x0, 0x5f, 0xff, 0xff, 0xff, 0xff, 0xf1, 0x0,\n    0x0, 0x6f, 0xff, 0xd7, 0x7f, 0xff, 0xf2, 0x0,\n    0x0, 0x6f, 0xff, 0x90, 0xd, 0xff, 0xf2, 0x0,\n    0x0, 0x6f, 0xff, 0x90, 0xd, 0xff, 0xf2, 0x0,\n    0x0, 0x4f, 0xff, 0x70, 0xb, 0xff, 0xe1, 0x0,\n\n    /* U+F019 \"\uf019\" */\n    0x0, 0x0, 0x0, 0x33, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xb, 0xff, 0xb0, 0x0, 0x0, 0x0, 0x0,\n    0xc, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0xc,\n    0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0xc, 0xff,\n    0xc0, 0x0, 0x0, 0x0, 0x0, 0xc, 0xff, 0xc0,\n    0x0, 0x0, 0x0, 0x8f, 0xff, 0xff, 0xff, 0xf8,\n    0x0, 0x0, 0x2e, 0xff, 0xff, 0xff, 0xe2, 0x0,\n    0x0, 0x2, 0xef, 0xff, 0xfe, 0x20, 0x0, 0x0,\n    0x0, 0x2d, 0xff, 0xe2, 0x0, 0x0, 0x79, 0x99,\n    0x82, 0xde, 0x28, 0x99, 0x97, 0xff, 0xff, 0xfb,\n    0x22, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa,\n    0xb3, 0xcf, 0xac, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,\n    0xca,\n\n    /* U+F01C \"\uf01c\" */\n    0x0, 0x6, 0xbb, 0xbb, 0xbb, 0xba, 0x30, 0x0,\n    0x0, 0x4f, 0xff, 0xff, 0xff, 0xff, 0xe1, 0x0,\n    0x0, 0xef, 0x30, 0x0, 0x0, 0x6, 0xfb, 0x0,\n    0x9, 0xf8, 0x0, 0x0, 0x0, 0x0, 0xcf, 0x50,\n    0x4f, 0xd0, 0x0, 0x0, 0x0, 0x0, 0x2f, 0xe1,\n    0xdf, 0x84, 0x42, 0x0, 0x0, 0x34, 0x4b, 0xf9,\n    0xff, 0xff, 0xfd, 0x0, 0x1, 0xff, 0xff, 0xfb,\n    0xff, 0xff, 0xff, 0x98, 0x8b, 0xff, 0xff, 0xfc,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfb,\n    0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6,\n\n    /* U+F021 \"\uf021\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x33, 0x0,\n    0x1, 0x8d, 0xff, 0xc6, 0x0, 0xef, 0x0, 0x4e,\n    0xff, 0xff, 0xff, 0xe4, 0xdf, 0x4, 0xff, 0xb3,\n    0x0, 0x4c, 0xff, 0xff, 0xe, 0xf9, 0x0, 0x0,\n    0x0, 0x8f, 0xff, 0x6f, 0xc0, 0x0, 0x1, 0xff,\n    0xff, 0xff, 0x8e, 0x50, 0x0, 0x1, 0xde, 0xee,\n    0xed, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x22, 0x22, 0x22, 0x0, 0x0, 0x0, 0x21, 0xff,\n    0xff, 0xff, 0x10, 0x0, 0x8, 0xf8, 0xff, 0xfb,\n    0xbc, 0x10, 0x0, 0x1e, 0xf4, 0xff, 0xfc, 0x10,\n    0x0, 0x1, 0xdf, 0xc0, 0xfe, 0xef, 0xe8, 0x44,\n    0x8e, 0xfe, 0x10, 0xfe, 0x1a, 0xff, 0xff, 0xff,\n    0xc1, 0x0, 0xfd, 0x0, 0x28, 0xbb, 0x94, 0x0,\n    0x0,\n\n    /* U+F026 \"\uf026\" */\n    0x0, 0x0, 0x2, 0x70, 0x0, 0x2, 0xef, 0x0,\n    0x2, 0xef, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0x34, 0x47, 0xff, 0xf0,\n    0x0, 0x5, 0xff, 0x0, 0x0, 0x5, 0xc0, 0x0,\n    0x0, 0x0,\n\n    /* U+F027 \"\uf027\" */\n    0x0, 0x0, 0x2, 0x70, 0x0, 0x0, 0x0, 0x2,\n    0xef, 0x0, 0x0, 0x0, 0x2, 0xef, 0xf0, 0x0,\n    0xd, 0xff, 0xff, 0xff, 0x2, 0x20, 0xff, 0xff,\n    0xff, 0xf0, 0x8e, 0x1f, 0xff, 0xff, 0xff, 0x0,\n    0xe7, 0xff, 0xff, 0xff, 0xf0, 0x3f, 0x5f, 0xff,\n    0xff, 0xff, 0x8, 0x90, 0x34, 0x47, 0xff, 0xf0,\n    0x0, 0x0, 0x0, 0x5, 0xff, 0x0, 0x0, 0x0,\n    0x0, 0x5, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0,\n\n    /* U+F028 \"\uf028\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x70, 0x0,\n    0x0, 0x0, 0x2, 0x70, 0x0, 0x5, 0xfa, 0x0,\n    0x0, 0x0, 0x2e, 0xf0, 0x0, 0x81, 0x4f, 0x60,\n    0x0, 0x2, 0xef, 0xf0, 0x1, 0xdd, 0x7, 0xf0,\n    0xdf, 0xff, 0xff, 0xf0, 0x32, 0x1e, 0x80, 0xf6,\n    0xff, 0xff, 0xff, 0xf0, 0x8e, 0x27, 0xe0, 0xb9,\n    0xff, 0xff, 0xff, 0xf0, 0xe, 0x73, 0xf1, 0x9b,\n    0xff, 0xff, 0xff, 0xf0, 0x3f, 0x54, 0xf0, 0x9a,\n    0xff, 0xff, 0xff, 0xf0, 0x89, 0xa, 0xc0, 0xd8,\n    0x34, 0x47, 0xff, 0xf0, 0x0, 0x7f, 0x43, 0xf3,\n    0x0, 0x0, 0x5f, 0xf0, 0x2, 0xf6, 0xc, 0xb0,\n    0x0, 0x0, 0x5, 0xc0, 0x0, 0x0, 0xbf, 0x10,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x9, 0xe3, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x10, 0x0,\n\n    /* U+F03E \"\uf03e\" */\n    0x37, 0x88, 0x88, 0x88, 0x88, 0x88, 0x73, 0xef,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0x32,\n    0xdf, 0xff, 0xff, 0xff, 0xff, 0xf9, 0x0, 0x7f,\n    0xff, 0xfd, 0xff, 0xff, 0xfd, 0x10, 0xcf, 0xff,\n    0xa0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfa, 0x0,\n    0x7, 0xff, 0xff, 0xf3, 0x5f, 0xa0, 0x0, 0x0,\n    0xcf, 0xff, 0x30, 0x3, 0x0, 0x0, 0x0, 0xcf,\n    0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0xcf, 0xff,\n    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xff, 0xaf, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xf9,\n\n    /* U+F043 \"\uf043\" */\n    0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x1, 0xfa,\n    0x0, 0x0, 0x0, 0x6, 0xff, 0x10, 0x0, 0x0,\n    0xd, 0xff, 0x70, 0x0, 0x0, 0x6f, 0xff, 0xf1,\n    0x0, 0x1, 0xef, 0xff, 0xfa, 0x0, 0xb, 0xff,\n    0xff, 0xff, 0x60, 0x5f, 0xff, 0xff, 0xff, 0xe0,\n    0xcf, 0xff, 0xff, 0xff, 0xf6, 0xfe, 0xbf, 0xff,\n    0xff, 0xf9, 0xfd, 0x4f, 0xff, 0xff, 0xf9, 0xbf,\n    0x49, 0xff, 0xff, 0xf5, 0x3f, 0xe5, 0x2e, 0xff,\n    0xd0, 0x6, 0xff, 0xff, 0xfd, 0x20, 0x0, 0x28,\n    0xba, 0x60, 0x0,\n\n    /* U+F048 \"\uf048\" */\n    0x4, 0x30, 0x0, 0x0, 0x31, 0x1f, 0xe0, 0x0,\n    0x6, 0xf9, 0x1f, 0xe0, 0x0, 0x7f, 0xfa, 0x1f,\n    0xe0, 0x9, 0xff, 0xfa, 0x1f, 0xe0, 0xaf, 0xff,\n    0xfa, 0x1f, 0xeb, 0xff, 0xff, 0xfa, 0x1f, 0xff,\n    0xff, 0xff, 0xfa, 0x1f, 0xff, 0xff, 0xff, 0xfa,\n    0x1f, 0xe6, 0xff, 0xff, 0xfa, 0x1f, 0xe0, 0x5f,\n    0xff, 0xfa, 0x1f, 0xe0, 0x4, 0xff, 0xfa, 0x1f,\n    0xe0, 0x0, 0x3e, 0xfa, 0xf, 0xd0, 0x0, 0x2,\n    0xd7, 0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+F04B \"\uf04b\" */\n    0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0xfb,\n    0x20, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0x90,\n    0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0xe6, 0x0,\n    0x0, 0x0, 0xff, 0xff, 0xff, 0xfc, 0x30, 0x0,\n    0xf, 0xff, 0xff, 0xff, 0xff, 0x91, 0x0, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xe6, 0xf, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xf2, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xfd, 0xf, 0xff, 0xff, 0xff, 0xff, 0xf8,\n    0x0, 0xff, 0xff, 0xff, 0xff, 0xb2, 0x0, 0xf,\n    0xff, 0xff, 0xfd, 0x40, 0x0, 0x0, 0xff, 0xff,\n    0xf7, 0x0, 0x0, 0x0, 0xf, 0xff, 0xa1, 0x0,\n    0x0, 0x0, 0x0, 0x6a, 0x40, 0x0, 0x0, 0x0,\n    0x0, 0x0,\n\n    /* U+F04C \"\uf04c\" */\n    0x14, 0x44, 0x20, 0x1, 0x44, 0x42, 0xd, 0xff,\n    0xff, 0x10, 0xdf, 0xff, 0xf1, 0xff, 0xff, 0xf3,\n    0xf, 0xff, 0xff, 0x3f, 0xff, 0xff, 0x40, 0xff,\n    0xff, 0xf4, 0xff, 0xff, 0xf4, 0xf, 0xff, 0xff,\n    0x4f, 0xff, 0xff, 0x40, 0xff, 0xff, 0xf4, 0xff,\n    0xff, 0xf4, 0xf, 0xff, 0xff, 0x4f, 0xff, 0xff,\n    0x40, 0xff, 0xff, 0xf4, 0xff, 0xff, 0xf4, 0xf,\n    0xff, 0xff, 0x4f, 0xff, 0xff, 0x40, 0xff, 0xff,\n    0xf4, 0xff, 0xff, 0xf4, 0xf, 0xff, 0xff, 0x4f,\n    0xff, 0xff, 0x30, 0xff, 0xff, 0xf3, 0x9f, 0xff,\n    0xc0, 0x9, 0xff, 0xfc, 0x0,\n\n    /* U+F04D \"\uf04d\" */\n    0x14, 0x44, 0x44, 0x44, 0x44, 0x42, 0xd, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xf1, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xf4, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x4f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf4, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0x4f, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xf4, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0x4f, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xf4, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x4f,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x9f, 0xff,\n    0xff, 0xff, 0xff, 0xfc, 0x0,\n\n    /* U+F051 \"\uf051\" */\n    0x2, 0x10, 0x0, 0x0, 0x42, 0xf, 0xe2, 0x0,\n    0x3, 0xfb, 0xf, 0xfe, 0x30, 0x4, 0xfb, 0xf,\n    0xff, 0xf4, 0x4, 0xfb, 0xf, 0xff, 0xff, 0x54,\n    0xfb, 0xf, 0xff, 0xff, 0xfa, 0xfb, 0xf, 0xff,\n    0xff, 0xff, 0xfb, 0xf, 0xff, 0xff, 0xff, 0xfb,\n    0xf, 0xff, 0xff, 0xd6, 0xfb, 0xf, 0xff, 0xfd,\n    0x14, 0xfb, 0xf, 0xff, 0xc1, 0x4, 0xfb, 0xf,\n    0xfb, 0x0, 0x4, 0xfb, 0xc, 0xa0, 0x0, 0x3,\n    0xfa, 0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+F052 \"\uf052\" */\n    0x0, 0x0, 0x0, 0x12, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x3, 0xff, 0x60, 0x0, 0x0, 0x0, 0x0,\n    0x2e, 0xff, 0xf5, 0x0, 0x0, 0x0, 0x1, 0xef,\n    0xff, 0xff, 0x40, 0x0, 0x0, 0x1d, 0xff, 0xff,\n    0xff, 0xf3, 0x0, 0x0, 0xcf, 0xff, 0xff, 0xff,\n    0xfe, 0x20, 0xa, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xe0, 0xe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf2,\n    0x3, 0x99, 0x99, 0x99, 0x99, 0x99, 0x50, 0x5,\n    0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0xf, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xf3, 0xf, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xf4, 0xb, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xd1,\n\n    /* U+F053 \"\uf053\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f,\n    0x90, 0x0, 0x0, 0x3f, 0xfc, 0x0, 0x0, 0x3f,\n    0xfd, 0x10, 0x0, 0x3f, 0xfd, 0x10, 0x0, 0x3f,\n    0xfd, 0x10, 0x0, 0x1f, 0xfd, 0x10, 0x0, 0x0,\n    0xcf, 0xf4, 0x0, 0x0, 0x0, 0xcf, 0xf4, 0x0,\n    0x0, 0x0, 0xcf, 0xf4, 0x0, 0x0, 0x0, 0xcf,\n    0xf4, 0x0, 0x0, 0x0, 0xcf, 0xe0, 0x0, 0x0,\n    0x0, 0xa4, 0x0,\n\n    /* U+F054 \"\uf054\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xcd, 0x10, 0x0,\n    0x0, 0x1f, 0xfd, 0x10, 0x0, 0x0, 0x3f, 0xfd,\n    0x10, 0x0, 0x0, 0x3f, 0xfd, 0x10, 0x0, 0x0,\n    0x3f, 0xfd, 0x10, 0x0, 0x0, 0x3f, 0xfd, 0x0,\n    0x0, 0x8, 0xff, 0x90, 0x0, 0x8, 0xff, 0x90,\n    0x0, 0x8, 0xff, 0x90, 0x0, 0x8, 0xff, 0x90,\n    0x0, 0x2, 0xff, 0x90, 0x0, 0x0, 0x7, 0x80,\n    0x0, 0x0, 0x0,\n\n    /* U+F067 \"\uf067\" */\n    0x0, 0x0, 0x4, 0x50, 0x0, 0x0, 0x0, 0x0,\n    0x2, 0xff, 0x60, 0x0, 0x0, 0x0, 0x0, 0x3f,\n    0xf7, 0x0, 0x0, 0x0, 0x0, 0x3, 0xff, 0x70,\n    0x0, 0x0, 0x0, 0x0, 0x3f, 0xf7, 0x0, 0x0,\n    0x6, 0x99, 0x9a, 0xff, 0xc9, 0x99, 0x80, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0x3d, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xf2, 0x1, 0x11, 0x3f, 0xf7,\n    0x11, 0x10, 0x0, 0x0, 0x3, 0xff, 0x70, 0x0,\n    0x0, 0x0, 0x0, 0x3f, 0xf7, 0x0, 0x0, 0x0,\n    0x0, 0x3, 0xff, 0x70, 0x0, 0x0, 0x0, 0x0,\n    0xc, 0xd3, 0x0, 0x0, 0x0,\n\n    /* U+F068 \"\uf068\" */\n    0x69, 0x99, 0x99, 0x99, 0x99, 0x98, 0xf, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xf3, 0xdf, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x20, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0,\n\n    /* U+F06E \"\uf06e\" */\n    0x0, 0x0, 0x1, 0x56, 0x64, 0x0, 0x0, 0x0,\n    0x0, 0x3, 0xbf, 0xfe, 0xef, 0xf9, 0x10, 0x0,\n    0x0, 0x7f, 0xfa, 0x10, 0x3, 0xdf, 0xe4, 0x0,\n    0x8, 0xff, 0xa0, 0x9, 0xb4, 0x1e, 0xff, 0x50,\n    0x4f, 0xff, 0x20, 0xb, 0xff, 0x26, 0xff, 0xe1,\n    0xef, 0xff, 0x9, 0xcf, 0xff, 0x63, 0xff, 0xfa,\n    0xbf, 0xff, 0x9, 0xff, 0xff, 0x54, 0xff, 0xf6,\n    0x1e, 0xff, 0x51, 0xdf, 0xfb, 0x9, 0xff, 0xb0,\n    0x3, 0xef, 0xe2, 0x4, 0x30, 0x5f, 0xfc, 0x10,\n    0x0, 0x2c, 0xff, 0x95, 0x6a, 0xff, 0x90, 0x0,\n    0x0, 0x0, 0x49, 0xdf, 0xfd, 0x92, 0x0, 0x0,\n\n    /* U+F070 \"\uf070\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xcd, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x8f, 0xf5, 0x0, 0x14, 0x66, 0x40,\n    0x0, 0x0, 0x0, 0x4, 0xef, 0xac, 0xff, 0xef,\n    0xff, 0x91, 0x0, 0x0, 0x0, 0x1c, 0xff, 0xa1,\n    0x0, 0x4d, 0xfe, 0x30, 0x0, 0x0, 0x0, 0x9f,\n    0xf5, 0xab, 0x31, 0xef, 0xf4, 0x0, 0x7, 0xb1,\n    0x5, 0xff, 0xff, 0xe1, 0x7f, 0xfe, 0x10, 0xf,\n    0xfe, 0x30, 0x2d, 0xff, 0xf5, 0x4f, 0xff, 0x90,\n    0xc, 0xff, 0xe0, 0x0, 0xaf, 0xf6, 0x5f, 0xff,\n    0x60, 0x2, 0xff, 0xf4, 0x0, 0x6, 0xff, 0xef,\n    0xfb, 0x0, 0x0, 0x4f, 0xfd, 0x10, 0x0, 0x3e,\n    0xff, 0xc0, 0x0, 0x0, 0x2, 0xdf, 0xe8, 0x54,\n    0x1, 0xbf, 0xe3, 0x0, 0x0, 0x0, 0x5, 0xae,\n    0xff, 0x60, 0x7, 0xff, 0x60, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x4e, 0xf6, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xa1,\n\n    /* U+F071 \"\uf071\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x3e, 0xd0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xc, 0xff, 0x80, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x6, 0xff, 0xff, 0x20,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xef, 0xff, 0xfb,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x8f, 0xfc, 0xcf,\n    0xf4, 0x0, 0x0, 0x0, 0x0, 0x2f, 0xfb, 0x0,\n    0xff, 0xd0, 0x0, 0x0, 0x0, 0xb, 0xff, 0xc0,\n    0xf, 0xff, 0x70, 0x0, 0x0, 0x4, 0xff, 0xfd,\n    0x1, 0xff, 0xff, 0x10, 0x0, 0x0, 0xdf, 0xff,\n    0xe0, 0x2f, 0xff, 0xfa, 0x0, 0x0, 0x7f, 0xff,\n    0xff, 0x9b, 0xff, 0xff, 0xf3, 0x0, 0x1f, 0xff,\n    0xff, 0xb0, 0xe, 0xff, 0xff, 0xc0, 0xa, 0xff,\n    0xff, 0xfe, 0x24, 0xff, 0xff, 0xff, 0x60, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa, 0x6,\n    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcb, 0x30,\n\n    /* U+F074 \"\uf074\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x7f, 0x80, 0xdd, 0xdb,\n    0x0, 0x0, 0x8d, 0xef, 0xf8, 0xff, 0xff, 0xb0,\n    0x7, 0xff, 0xff, 0xfd, 0x55, 0x6f, 0xf4, 0x6f,\n    0xf8, 0xaf, 0xe2, 0x0, 0x5, 0x74, 0xff, 0x90,\n    0x7e, 0x20, 0x0, 0x0, 0x3f, 0xfa, 0x0, 0x0,\n    0x0, 0x0, 0x2, 0xef, 0xb2, 0x50, 0x4a, 0x0,\n    0x1, 0x2e, 0xfd, 0x1d, 0xf4, 0x8f, 0xb0, 0xff,\n    0xff, 0xd1, 0xb, 0xff, 0xff, 0xfb, 0xff, 0xfe,\n    0x20, 0x0, 0xcf, 0xff, 0xfb, 0x12, 0x21, 0x0,\n    0x0, 0x2, 0x9f, 0xc0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x5b, 0x0,\n\n    /* U+F077 \"\uf077\" */\n    0x0, 0x0, 0x7, 0xa0, 0x0, 0x0, 0x0, 0x0,\n    0x8, 0xff, 0xb0, 0x0, 0x0, 0x0, 0x8, 0xff,\n    0xff, 0xb0, 0x0, 0x0, 0x8, 0xff, 0x95, 0xff,\n    0xb0, 0x0, 0x8, 0xff, 0x90, 0x5, 0xff, 0xb0,\n    0x7, 0xff, 0x90, 0x0, 0x5, 0xff, 0xb0, 0x9f,\n    0x90, 0x0, 0x0, 0x5, 0xfd, 0x0, 0x40, 0x0,\n    0x0, 0x0, 0x3, 0x10,\n\n    /* U+F078 \"\uf078\" */\n    0x4c, 0x20, 0x0, 0x0, 0x0, 0xb6, 0xb, 0xfe,\n    0x20, 0x0, 0x0, 0xcf, 0xf0, 0x2e, 0xfe, 0x20,\n    0x0, 0xcf, 0xf4, 0x0, 0x2e, 0xfe, 0x20, 0xcf,\n    0xf4, 0x0, 0x0, 0x2e, 0xfe, 0xcf, 0xf4, 0x0,\n    0x0, 0x0, 0x2e, 0xff, 0xf4, 0x0, 0x0, 0x0,\n    0x0, 0x2e, 0xf4, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x13, 0x0, 0x0, 0x0,\n\n    /* U+F079 \"\uf079\" */\n    0x0, 0x8, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xbf, 0xf3, 0x8, 0xbb, 0xbb, 0xbb,\n    0x90, 0x0, 0xb, 0xff, 0xff, 0x39, 0xff, 0xff,\n    0xff, 0xf1, 0x0, 0x8f, 0xcf, 0xcf, 0xf0, 0x0,\n    0x0, 0xa, 0xf1, 0x0, 0x38, 0x2f, 0x94, 0x80,\n    0x0, 0x0, 0xa, 0xf1, 0x0, 0x0, 0x2f, 0x90,\n    0x0, 0x0, 0x0, 0xa, 0xf1, 0x0, 0x0, 0x2f,\n    0x90, 0x0, 0x0, 0x3, 0xa, 0xf1, 0x30, 0x0,\n    0x2f, 0x90, 0x0, 0x0, 0x1f, 0xcb, 0xf8, 0xf8,\n    0x0, 0x2f, 0xeb, 0xbb, 0xbb, 0x39, 0xff, 0xff,\n    0xe2, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xb0, 0x9f,\n    0xfd, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x8, 0xd1, 0x0,\n\n    /* U+F07B \"\uf07b\" */\n    0x37, 0x88, 0x87, 0x0, 0x0, 0x0, 0x0, 0xef,\n    0xff, 0xff, 0xa0, 0x0, 0x0, 0x0, 0xff, 0xff,\n    0xff, 0xfd, 0xcc, 0xcc, 0xb6, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xaf, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xf9,\n\n    /* U+F093 \"\uf093\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x1, 0xdd, 0x10, 0x0, 0x0, 0x0, 0x0,\n    0x1d, 0xff, 0xd1, 0x0, 0x0, 0x0, 0x1, 0xdf,\n    0xff, 0xfd, 0x10, 0x0, 0x0, 0x1d, 0xff, 0xff,\n    0xff, 0xd1, 0x0, 0x0, 0x9f, 0xff, 0xff, 0xff,\n    0xf9, 0x0, 0x0, 0x1, 0x1c, 0xff, 0xc1, 0x10,\n    0x0, 0x0, 0x0, 0xc, 0xff, 0xc0, 0x0, 0x0,\n    0x0, 0x0, 0xc, 0xff, 0xc0, 0x0, 0x0, 0x0,\n    0x0, 0xc, 0xff, 0xc0, 0x0, 0x0, 0x79, 0x99,\n    0x3b, 0xff, 0xb3, 0x99, 0x97, 0xff, 0xff, 0xb2,\n    0x44, 0x2b, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xdd,\n    0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa,\n    0xb3, 0xcf, 0xac, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,\n    0xca,\n\n    /* U+F095 \"\uf095\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0xc7, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xaf, 0xff, 0xf0, 0x0,\n    0x0, 0x0, 0x0, 0x1f, 0xff, 0xfd, 0x0, 0x0,\n    0x0, 0x0, 0x6, 0xff, 0xff, 0xc0, 0x0, 0x0,\n    0x0, 0x0, 0x8, 0xff, 0xf7, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xc, 0xff, 0x30, 0x0, 0x0, 0x0,\n    0x0, 0x4, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0,\n    0x1, 0xef, 0xf3, 0x0, 0x0, 0x4a, 0x30, 0x2,\n    0xdf, 0xf8, 0x0, 0x5, 0xdf, 0xfe, 0x15, 0xef,\n    0xfb, 0x0, 0x0, 0xef, 0xff, 0xff, 0xff, 0xfa,\n    0x0, 0x0, 0xb, 0xff, 0xff, 0xff, 0xf7, 0x0,\n    0x0, 0x0, 0x7f, 0xff, 0xff, 0xa2, 0x0, 0x0,\n    0x0, 0x2, 0xba, 0x85, 0x0, 0x0, 0x0, 0x0,\n    0x0,\n\n    /* U+F0C4 \"\uf0c4\" */\n    0x4, 0x86, 0x0, 0x0, 0x0, 0x10, 0x6, 0xff,\n    0xfa, 0x0, 0x2, 0xdf, 0xd1, 0xef, 0x3c, 0xf1,\n    0x1, 0xdf, 0xfa, 0xe, 0xe0, 0xaf, 0x21, 0xdf,\n    0xfa, 0x0, 0x9f, 0xef, 0xf6, 0xdf, 0xfa, 0x0,\n    0x0, 0x8d, 0xff, 0xff, 0xfb, 0x0, 0x0, 0x0,\n    0x6, 0xff, 0xfd, 0x0, 0x0, 0x0, 0x48, 0xef,\n    0xff, 0xf6, 0x0, 0x0, 0x6f, 0xff, 0xfb, 0xff,\n    0xf6, 0x0, 0xe, 0xf3, 0xcf, 0x23, 0xff, 0xf6,\n    0x0, 0xee, 0xa, 0xf2, 0x4, 0xff, 0xf6, 0x9,\n    0xfe, 0xfc, 0x0, 0x4, 0xff, 0xf1, 0x8, 0xda,\n    0x10, 0x0, 0x2, 0x62, 0x0,\n\n    /* U+F0C5 \"\uf0c5\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x6f, 0xff, 0xf9, 0x87, 0x0, 0x0, 0x8, 0xff,\n    0xff, 0x98, 0xf7, 0x8, 0xa6, 0x8f, 0xff, 0xf9,\n    0x59, 0x90, 0xff, 0xa8, 0xff, 0xff, 0xfc, 0xcc,\n    0xf, 0xfa, 0x8f, 0xff, 0xff, 0xff, 0xf1, 0xff,\n    0xa8, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xfa, 0x8f,\n    0xff, 0xff, 0xff, 0xf1, 0xff, 0xa8, 0xff, 0xff,\n    0xff, 0xff, 0x1f, 0xfa, 0x8f, 0xff, 0xff, 0xff,\n    0xf1, 0xff, 0xa8, 0xff, 0xff, 0xff, 0xff, 0x1f,\n    0xfa, 0x7f, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xe3,\n    0x12, 0x22, 0x22, 0x21, 0xf, 0xff, 0xff, 0xff,\n    0xf9, 0x0, 0x0, 0xac, 0xcc, 0xcc, 0xcb, 0x50,\n    0x0, 0x0,\n\n    /* U+F0C7 \"\uf0c7\" */\n    0x49, 0x99, 0x99, 0x99, 0x95, 0x0, 0xe, 0xff,\n    0xff, 0xff, 0xff, 0xf6, 0x0, 0xfd, 0x22, 0x22,\n    0x22, 0x4f, 0xf6, 0xf, 0xc0, 0x0, 0x0, 0x1,\n    0xff, 0xf3, 0xfc, 0x0, 0x0, 0x0, 0x1f, 0xff,\n    0x6f, 0xc0, 0x0, 0x0, 0x2, 0xff, 0xf6, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0x6f, 0xff, 0xff,\n    0xdc, 0xff, 0xff, 0xf6, 0xff, 0xff, 0xb0, 0x5,\n    0xff, 0xff, 0x6f, 0xff, 0xf6, 0x0, 0xf, 0xff,\n    0xf6, 0xff, 0xff, 0xc0, 0x6, 0xff, 0xff, 0x6f,\n    0xff, 0xff, 0xed, 0xff, 0xff, 0xf6, 0x9f, 0xff,\n    0xff, 0xff, 0xff, 0xfd, 0x10,\n\n    /* U+F0C9 \"\uf0c9\" */\n    0xcd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0x2f, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xf3, 0x12, 0x22, 0x22,\n    0x22, 0x22, 0x22, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xde,\n    0xee, 0xee, 0xee, 0xee, 0xee, 0x20, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xd, 0xee, 0xee, 0xee, 0xee, 0xee,\n    0xe2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x30,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+F0E0 \"\uf0e0\" */\n    0x37, 0x88, 0x88, 0x88, 0x88, 0x88, 0x73, 0xef,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xef, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xfe, 0x1c, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xc1, 0xd2, 0x8f, 0xff, 0xff,\n    0xff, 0xf8, 0x2d, 0xff, 0x64, 0xef, 0xff, 0xfe,\n    0x45, 0xff, 0xff, 0xfa, 0x2b, 0xff, 0xb2, 0xaf,\n    0xff, 0xff, 0xff, 0xd3, 0x55, 0x3d, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xaf, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xf9,\n\n    /* U+F0E7 \"\uf0e7\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xff,\n    0xf0, 0x0, 0x4, 0xff, 0xff, 0xd0, 0x0, 0x6,\n    0xff, 0xff, 0x80, 0x0, 0x8, 0xff, 0xff, 0x30,\n    0x0, 0xa, 0xff, 0xff, 0xaa, 0xa6, 0xc, 0xff,\n    0xff, 0xff, 0xf8, 0xe, 0xff, 0xff, 0xff, 0xe1,\n    0xb, 0xdd, 0xdf, 0xff, 0x60, 0x0, 0x0, 0x4f,\n    0xfd, 0x0, 0x0, 0x0, 0x7f, 0xf3, 0x0, 0x0,\n    0x0, 0xbf, 0xa0, 0x0, 0x0, 0x0, 0xff, 0x10,\n    0x0, 0x0, 0x3, 0xf8, 0x0, 0x0, 0x0, 0x3,\n    0xc0, 0x0, 0x0,\n\n    /* U+F0EA \"\uf0ea\" */\n    0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x4, 0x55,\n    0xef, 0xb5, 0x52, 0x0, 0x0, 0xff, 0xfd, 0x1f,\n    0xff, 0xb0, 0x0, 0xf, 0xff, 0xff, 0xff, 0xfc,\n    0x0, 0x0, 0xff, 0xff, 0x53, 0x33, 0x20, 0x0,\n    0xf, 0xff, 0x97, 0xff, 0xfb, 0x57, 0x0, 0xff,\n    0xf8, 0xaf, 0xff, 0xc6, 0xf8, 0xf, 0xff, 0x8a,\n    0xff, 0xfc, 0x4a, 0xa1, 0xff, 0xf8, 0xaf, 0xff,\n    0xe3, 0x22, 0xf, 0xff, 0x8a, 0xff, 0xff, 0xff,\n    0xf4, 0xff, 0xf8, 0xaf, 0xff, 0xff, 0xff, 0x4f,\n    0xff, 0x8a, 0xff, 0xff, 0xff, 0xf4, 0x35, 0x52,\n    0xaf, 0xff, 0xff, 0xff, 0x40, 0x0, 0xa, 0xff,\n    0xff, 0xff, 0xf4, 0x0, 0x0, 0x7f, 0xff, 0xff,\n    0xfe, 0x20,\n\n    /* U+F0F3 \"\uf0f3\" */\n    0x0, 0x0, 0x1, 0x10, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xaf, 0x0, 0x0, 0x0, 0x0, 0x1, 0x8f,\n    0xfa, 0x30, 0x0, 0x0, 0x2, 0xef, 0xff, 0xff,\n    0x50, 0x0, 0x0, 0xbf, 0xff, 0xff, 0xff, 0x10,\n    0x0, 0x1f, 0xff, 0xff, 0xff, 0xf5, 0x0, 0x3,\n    0xff, 0xff, 0xff, 0xff, 0x70, 0x0, 0x5f, 0xff,\n    0xff, 0xff, 0xf9, 0x0, 0x8, 0xff, 0xff, 0xff,\n    0xff, 0xc0, 0x0, 0xdf, 0xff, 0xff, 0xff, 0xff,\n    0x20, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xe,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xf2, 0x2, 0x22,\n    0x22, 0x22, 0x22, 0x21, 0x0, 0x0, 0x8, 0xff,\n    0xc0, 0x0, 0x0, 0x0, 0x0, 0x9, 0xa2, 0x0,\n    0x0, 0x0,\n\n    /* U+F11C \"\uf11c\" */\n    0x5b, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xa3,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfb,\n    0xfc, 0xc, 0x30, 0xe1, 0x1d, 0xd, 0x11, 0xfc,\n    0xfc, 0xb, 0x30, 0xe0, 0x1d, 0xd, 0x10, 0xfc,\n    0xff, 0xfe, 0xff, 0xef, 0xfe, 0xfe, 0xef, 0xfc,\n    0xff, 0xf1, 0x5a, 0x8, 0x70, 0xa0, 0x5f, 0xfc,\n    0xff, 0xf3, 0x7b, 0x29, 0x92, 0xc2, 0x7f, 0xfc,\n    0xff, 0xbf, 0xcb, 0xbb, 0xbb, 0xbf, 0xcb, 0xfc,\n    0xfc, 0xb, 0x20, 0x0, 0x0, 0xd, 0x0, 0xfc,\n    0xff, 0xcf, 0xcc, 0xcc, 0xcc, 0xcf, 0xcc, 0xfb,\n    0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6,\n\n    /* U+F124 \"\uf124\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x5, 0xdf, 0xb0,\n    0x0, 0x0, 0x0, 0x0, 0x7, 0xef, 0xff, 0xd0,\n    0x0, 0x0, 0x0, 0x18, 0xff, 0xff, 0xff, 0x70,\n    0x0, 0x0, 0x29, 0xff, 0xff, 0xff, 0xff, 0x0,\n    0x0, 0x3b, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0,\n    0xa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0x0,\n    0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa0, 0x0,\n    0x4, 0x9a, 0xaa, 0xaf, 0xff, 0xff, 0x20, 0x0,\n    0x0, 0x0, 0x0, 0xe, 0xff, 0xfb, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xe, 0xff, 0xf4, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xe, 0xff, 0xc0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xe, 0xff, 0x50, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0xd, 0xfd, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x4, 0xb3, 0x0, 0x0, 0x0,\n\n    /* U+F15B \"\uf15b\" */\n    0x35, 0x55, 0x55, 0x2, 0x0, 0xf, 0xff, 0xff,\n    0xf2, 0xf4, 0x0, 0xff, 0xff, 0xff, 0x2f, 0xf4,\n    0xf, 0xff, 0xff, 0xf2, 0xff, 0xf3, 0xff, 0xff,\n    0xff, 0x32, 0x22, 0x1f, 0xff, 0xff, 0xff, 0xff,\n    0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8f, 0xff,\n    0xff, 0xff, 0xff, 0xf8, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0x8f, 0xff, 0xff, 0xff,\n    0xff, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8f,\n    0xff, 0xff, 0xff, 0xff, 0xf8, 0x8a, 0xaa, 0xaa,\n    0xaa, 0xaa, 0x30,\n\n    /* U+F1EB \"\uf1eb\" */\n    0x0, 0x0, 0x0, 0x24, 0x55, 0x31, 0x0, 0x0,\n    0x0, 0x0, 0x3, 0xaf, 0xff, 0xff, 0xff, 0xc7,\n    0x0, 0x0, 0x2, 0xbf, 0xff, 0xfe, 0xde, 0xff,\n    0xff, 0xf6, 0x0, 0x5f, 0xff, 0xb5, 0x10, 0x0,\n    0x3, 0x8e, 0xff, 0xb0, 0xdf, 0xd3, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x8f, 0xf5, 0x18, 0x0, 0x5,\n    0xae, 0xfe, 0xc8, 0x10, 0x4, 0x60, 0x0, 0x2,\n    0xdf, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0,\n    0xc, 0xff, 0x95, 0x34, 0x7d, 0xff, 0x40, 0x0,\n    0x0, 0x2, 0xa2, 0x0, 0x0, 0x0, 0x77, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x2, 0x96, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xd, 0xff, 0x50,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe, 0xff,\n    0x60, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5,\n    0xda, 0x0, 0x0, 0x0, 0x0,\n\n    /* U+F240 \"\uf240\" */\n    0x5b, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xba,\n    0x20, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0x90, 0xfc, 0x12, 0x22, 0x22, 0x22, 0x22,\n    0x22, 0xf, 0xf7, 0xfc, 0x5f, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0x2c, 0xfa, 0xfc, 0x5f, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x21, 0xfa, 0xfc, 0x5f, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0x27, 0xfa, 0xfc, 0x26,\n    0x66, 0x66, 0x66, 0x66, 0x66, 0x1f, 0xfa, 0xfe,\n    0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbf, 0xb1,\n    0xaf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0,\n\n    /* U+F241 \"\uf241\" */\n    0x5b, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xba,\n    0x20, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0x90, 0xfc, 0x12, 0x22, 0x22, 0x22, 0x21,\n    0x0, 0xf, 0xf7, 0xfc, 0x5f, 0xff, 0xff, 0xff,\n    0xf8, 0x0, 0xc, 0xfa, 0xfc, 0x5f, 0xff, 0xff,\n    0xff, 0xf8, 0x0, 0x1, 0xfa, 0xfc, 0x5f, 0xff,\n    0xff, 0xff, 0xf8, 0x0, 0x7, 0xfa, 0xfc, 0x26,\n    0x66, 0x66, 0x66, 0x63, 0x0, 0xf, 0xfa, 0xfe,\n    0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbf, 0xb1,\n    0xaf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0,\n\n    /* U+F242 \"\uf242\" */\n    0x5b, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xba,\n    0x20, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0x90, 0xfc, 0x12, 0x22, 0x22, 0x10, 0x0,\n    0x0, 0xf, 0xf7, 0xfc, 0x5f, 0xff, 0xff, 0xd0,\n    0x0, 0x0, 0xc, 0xfa, 0xfc, 0x5f, 0xff, 0xff,\n    0xd0, 0x0, 0x0, 0x1, 0xfa, 0xfc, 0x5f, 0xff,\n    0xff, 0xd0, 0x0, 0x0, 0x7, 0xfa, 0xfc, 0x26,\n    0x66, 0x66, 0x50, 0x0, 0x0, 0xf, 0xfa, 0xfe,\n    0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbf, 0xb1,\n    0xaf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0,\n\n    /* U+F243 \"\uf243\" */\n    0x5b, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xba,\n    0x20, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0x90, 0xfc, 0x12, 0x22, 0x0, 0x0, 0x0,\n    0x0, 0xf, 0xf7, 0xfc, 0x5f, 0xff, 0x30, 0x0,\n    0x0, 0x0, 0xc, 0xfa, 0xfc, 0x5f, 0xff, 0x30,\n    0x0, 0x0, 0x0, 0x1, 0xfa, 0xfc, 0x5f, 0xff,\n    0x30, 0x0, 0x0, 0x0, 0x7, 0xfa, 0xfc, 0x26,\n    0x66, 0x10, 0x0, 0x0, 0x0, 0xf, 0xfa, 0xfe,\n    0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbf, 0xb1,\n    0xaf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0,\n\n    /* U+F244 \"\uf244\" */\n    0x5b, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xba,\n    0x20, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0x90, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0xf, 0xf7, 0xfc, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0xc, 0xfa, 0xfc, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x1, 0xfa, 0xfc, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x7, 0xfa, 0xfc, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xfa, 0xfe,\n    0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbf, 0xb1,\n    0xaf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0,\n\n    /* U+F287 \"\uf287\" */\n    0x0, 0x0, 0x0, 0x0, 0x7, 0xb2, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xa, 0xdf, 0xfa, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0xa9, 0x3d, 0xf5,\n    0x0, 0x0, 0x0, 0x4, 0x40, 0x2, 0xe0, 0x0,\n    0x10, 0x0, 0x0, 0x0, 0xaf, 0xf8, 0xb, 0x60,\n    0x0, 0x0, 0x0, 0x6c, 0x30, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xf4, 0xaf, 0xf9,\n    0x0, 0xc, 0x50, 0x0, 0x0, 0x6d, 0x40, 0x5,\n    0x50, 0x0, 0x4, 0xc0, 0x0, 0x0, 0x10, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0xc4, 0x3e, 0xe8, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x2e, 0xef, 0xfa,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4f,\n    0xfa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n    0x0, 0x0, 0x0, 0x0,\n\n    /* U+F293 \"\uf293\" */\n    0x0, 0x0, 0x1, 0x10, 0x0, 0x0, 0x0, 0x7,\n    0xef, 0xff, 0xb3, 0x0, 0x0, 0xaf, 0xfd, 0x8f,\n    0xff, 0x20, 0x4, 0xff, 0xfd, 0x9, 0xff, 0xb0,\n    0xa, 0xfe, 0xfd, 0x12, 0xaf, 0xf0, 0xe, 0xf5,\n    0x5d, 0x2c, 0xe, 0xf3, 0xf, 0xff, 0x33, 0x12,\n    0x9f, 0xf5, 0xf, 0xff, 0xf3, 0x7, 0xff, 0xf6,\n    0xf, 0xff, 0xe2, 0x6, 0xff, 0xf6, 0xf, 0xfe,\n    0x24, 0x13, 0x7f, 0xf5, 0xd, 0xf5, 0x7d, 0x2c,\n    0xd, 0xf3, 0xa, 0xff, 0xfd, 0x11, 0xbf, 0xf0,\n    0x3, 0xff, 0xfe, 0xb, 0xff, 0xa0, 0x0, 0x7f,\n    0xfe, 0xbf, 0xfe, 0x10, 0x0, 0x3, 0xac, 0xdc,\n    0x81, 0x0,\n\n    /* U+F2ED \"\uf2ed\" */\n    0x0, 0x0, 0x34, 0x43, 0x0, 0x0, 0x5, 0x66,\n    0x7f, 0xff, 0xf9, 0x66, 0x50, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x35, 0x66, 0x66, 0x66, 0x66,\n    0x66, 0x50, 0x1c, 0xcc, 0xcc, 0xcc, 0xcc, 0xc4,\n    0x2, 0xff, 0xff, 0xff, 0xff, 0xff, 0x60, 0x2f,\n    0xf3, 0xfb, 0x7f, 0x6d, 0xf6, 0x2, 0xff, 0x2f,\n    0xb7, 0xf5, 0xdf, 0x60, 0x2f, 0xf2, 0xfb, 0x7f,\n    0x5d, 0xf6, 0x2, 0xff, 0x2f, 0xb7, 0xf5, 0xdf,\n    0x60, 0x2f, 0xf2, 0xfb, 0x7f, 0x5d, 0xf6, 0x2,\n    0xff, 0x2f, 0xb7, 0xf5, 0xdf, 0x60, 0x2f, 0xf3,\n    0xfb, 0x7f, 0x6d, 0xf6, 0x1, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0x50, 0x7, 0xbc, 0xcc, 0xcc, 0xcc,\n    0x90, 0x0,\n\n    /* U+F304 \"\uf304\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x20, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0x50, 0x0,\n    0x0, 0x0, 0x0, 0x2, 0xff, 0xff, 0x50, 0x0,\n    0x0, 0x0, 0x4, 0x39, 0xff, 0xfe, 0x0, 0x0,\n    0x0, 0x4, 0xff, 0x39, 0xff, 0xa0, 0x0, 0x0,\n    0x4, 0xff, 0xff, 0x39, 0xb0, 0x0, 0x0, 0x4,\n    0xff, 0xff, 0xff, 0x20, 0x0, 0x0, 0x4, 0xff,\n    0xff, 0xff, 0xb0, 0x0, 0x0, 0x4, 0xff, 0xff,\n    0xff, 0xb0, 0x0, 0x0, 0x4, 0xff, 0xff, 0xff,\n    0xb0, 0x0, 0x0, 0x4, 0xff, 0xff, 0xff, 0xb0,\n    0x0, 0x0, 0x0, 0xbf, 0xff, 0xff, 0xb0, 0x0,\n    0x0, 0x0, 0xd, 0xff, 0xff, 0xb0, 0x0, 0x0,\n    0x0, 0x0, 0xff, 0xff, 0xb0, 0x0, 0x0, 0x0,\n    0x0, 0x9, 0xa8, 0x60, 0x0, 0x0, 0x0, 0x0,\n    0x0,\n\n    /* U+F55A \"\uf55a\" */\n    0x0, 0x0, 0x17, 0x88, 0x88, 0x88, 0x88, 0x87,\n    0x40, 0x0, 0x2, 0xef, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xf4, 0x0, 0x3e, 0xff, 0xff, 0xcf, 0xff,\n    0xcf, 0xff, 0xf7, 0x3, 0xef, 0xff, 0xf9, 0x8,\n    0xf8, 0x9, 0xff, 0xf8, 0x3e, 0xff, 0xff, 0xfe,\n    0x20, 0x40, 0x2e, 0xff, 0xf8, 0xdf, 0xff, 0xff,\n    0xff, 0xe1, 0x1, 0xef, 0xff, 0xf8, 0x9f, 0xff,\n    0xff, 0xff, 0x80, 0x0, 0x8f, 0xff, 0xf8, 0x9,\n    0xff, 0xff, 0xf9, 0x2, 0xc2, 0x9, 0xff, 0xf8,\n    0x0, 0x9f, 0xff, 0xfe, 0x4e, 0xfe, 0x4e, 0xff,\n    0xf8, 0x0, 0x9, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xf7, 0x0, 0x0, 0x8f, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xc1,\n\n    /* U+F7C2 \"\uf7c2\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xef,\n    0xff, 0xff, 0xe2, 0x3, 0xfb, 0xfb, 0xce, 0xbf,\n    0xa4, 0xff, 0x1d, 0x3, 0xa1, 0xfa, 0xff, 0xf1,\n    0xd0, 0x3a, 0x1f, 0xaf, 0xff, 0xff, 0xff, 0xff,\n    0xfa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xaf, 0xff,\n    0xff, 0xff, 0xff, 0xfa, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xaf, 0xff, 0xff, 0xff, 0xff, 0xfa, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xaf, 0xff, 0xff, 0xff,\n    0xff, 0xfa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xad,\n    0xff, 0xff, 0xff, 0xff, 0xf8, 0x29, 0xaa, 0xaa,\n    0xaa, 0xa8, 0x0,\n\n    /* U+F8A2 \"\uf8a2\" */\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0xf1, 0x0,\n    0x8, 0x20, 0x0, 0x0, 0x1, 0xff, 0x10, 0xb,\n    0xf7, 0x0, 0x0, 0x0, 0x2f, 0xf1, 0xc, 0xff,\n    0x94, 0x44, 0x44, 0x45, 0xff, 0x1b, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xf1, 0x8f, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xfd, 0x0, 0x7f, 0xf7, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x6f, 0x60, 0x0,\n    0x0, 0x0, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0,\n    0x0, 0x0, 0x0\n}", "sline": 24}, "glyph_dsc": {"type": "Variable", "def": "static const lv_font_fmt_txt_glyph_dsc_t glyph_dsc[] = {\n    {.bitmap_index = 0, .adv_w = 0, .box_w = 0, .box_h = 0, .ofs_x = 0, .ofs_y = 0} /* id = 0 reserved */,\n    {.bitmap_index = 0, .adv_w = 60, .box_w = 0, .box_h = 0, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 0, .adv_w = 60, .box_w = 3, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 15, .adv_w = 88, .box_w = 5, .box_h = 5, .ofs_x = 0, .ofs_y = 5},\n    {.bitmap_index = 28, .adv_w = 157, .box_w = 10, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 78, .adv_w = 139, .box_w = 9, .box_h = 15, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 146, .adv_w = 189, .box_w = 12, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 206, .adv_w = 154, .box_w = 10, .box_h = 11, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 261, .adv_w = 47, .box_w = 3, .box_h = 5, .ofs_x = 0, .ofs_y = 5},\n    {.bitmap_index = 269, .adv_w = 75, .box_w = 4, .box_h = 14, .ofs_x = 1, .ofs_y = -3},\n    {.bitmap_index = 297, .adv_w = 76, .box_w = 4, .box_h = 14, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 325, .adv_w = 90, .box_w = 6, .box_h = 6, .ofs_x = 0, .ofs_y = 5},\n    {.bitmap_index = 343, .adv_w = 130, .box_w = 8, .box_h = 7, .ofs_x = 0, .ofs_y = 2},\n    {.bitmap_index = 371, .adv_w = 51, .box_w = 3, .box_h = 5, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 379, .adv_w = 86, .box_w = 5, .box_h = 3, .ofs_x = 0, .ofs_y = 3},\n    {.bitmap_index = 387, .adv_w = 51, .box_w = 3, .box_h = 3, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 392, .adv_w = 79, .box_w = 7, .box_h = 14, .ofs_x = -1, .ofs_y = -1},\n    {.bitmap_index = 441, .adv_w = 149, .box_w = 9, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 486, .adv_w = 83, .box_w = 4, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 506, .adv_w = 129, .box_w = 8, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 546, .adv_w = 128, .box_w = 8, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 586, .adv_w = 150, .box_w = 10, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 636, .adv_w = 129, .box_w = 8, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 676, .adv_w = 138, .box_w = 9, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 721, .adv_w = 134, .box_w = 8, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 761, .adv_w = 144, .box_w = 9, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 806, .adv_w = 138, .box_w = 8, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 846, .adv_w = 51, .box_w = 3, .box_h = 8, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 858, .adv_w = 51, .box_w = 3, .box_h = 11, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 875, .adv_w = 130, .box_w = 8, .box_h = 8, .ofs_x = 0, .ofs_y = 1},\n    {.bitmap_index = 907, .adv_w = 130, .box_w = 8, .box_h = 6, .ofs_x = 0, .ofs_y = 2},\n    {.bitmap_index = 931, .adv_w = 130, .box_w = 8, .box_h = 8, .ofs_x = 0, .ofs_y = 1},\n    {.bitmap_index = 963, .adv_w = 128, .box_w = 8, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 1003, .adv_w = 232, .box_w = 14, .box_h = 13, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 1094, .adv_w = 164, .box_w = 12, .box_h = 10, .ofs_x = -1, .ofs_y = 0},\n    {.bitmap_index = 1154, .adv_w = 170, .box_w = 9, .box_h = 10, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1199, .adv_w = 162, .box_w = 10, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 1249, .adv_w = 185, .box_w = 10, .box_h = 10, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1299, .adv_w = 150, .box_w = 8, .box_h = 10, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1339, .adv_w = 142, .box_w = 8, .box_h = 10, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1379, .adv_w = 173, .box_w = 10, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 1429, .adv_w = 182, .box_w = 9, .box_h = 10, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1474, .adv_w = 69, .box_w = 2, .box_h = 10, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1484, .adv_w = 115, .box_w = 7, .box_h = 10, .ofs_x = -1, .ofs_y = 0},\n    {.bitmap_index = 1519, .adv_w = 161, .box_w = 10, .box_h = 10, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1569, .adv_w = 133, .box_w = 8, .box_h = 10, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1609, .adv_w = 214, .box_w = 11, .box_h = 10, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1664, .adv_w = 182, .box_w = 9, .box_h = 10, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1709, .adv_w = 188, .box_w = 12, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 1769, .adv_w = 162, .box_w = 9, .box_h = 10, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1814, .adv_w = 188, .box_w = 12, .box_h = 13, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 1892, .adv_w = 163, .box_w = 9, .box_h = 10, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 1937, .adv_w = 139, .box_w = 9, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 1982, .adv_w = 131, .box_w = 9, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2027, .adv_w = 177, .box_w = 9, .box_h = 10, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2072, .adv_w = 159, .box_w = 11, .box_h = 10, .ofs_x = -1, .ofs_y = 0},\n    {.bitmap_index = 2127, .adv_w = 252, .box_w = 16, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2207, .adv_w = 151, .box_w = 10, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2257, .adv_w = 145, .box_w = 11, .box_h = 10, .ofs_x = -1, .ofs_y = 0},\n    {.bitmap_index = 2312, .adv_w = 147, .box_w = 9, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2357, .adv_w = 75, .box_w = 4, .box_h = 14, .ofs_x = 1, .ofs_y = -3},\n    {.bitmap_index = 2385, .adv_w = 79, .box_w = 7, .box_h = 14, .ofs_x = -1, .ofs_y = -1},\n    {.bitmap_index = 2434, .adv_w = 75, .box_w = 4, .box_h = 14, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 2462, .adv_w = 131, .box_w = 7, .box_h = 6, .ofs_x = 1, .ofs_y = 2},\n    {.bitmap_index = 2483, .adv_w = 112, .box_w = 7, .box_h = 1, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 2487, .adv_w = 134, .box_w = 5, .box_h = 2, .ofs_x = 1, .ofs_y = 9},\n    {.bitmap_index = 2492, .adv_w = 134, .box_w = 8, .box_h = 8, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2524, .adv_w = 153, .box_w = 8, .box_h = 11, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2568, .adv_w = 128, .box_w = 8, .box_h = 8, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2600, .adv_w = 153, .box_w = 9, .box_h = 11, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2650, .adv_w = 137, .box_w = 8, .box_h = 8, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2682, .adv_w = 79, .box_w = 6, .box_h = 11, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 2715, .adv_w = 155, .box_w = 9, .box_h = 11, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 2765, .adv_w = 153, .box_w = 8, .box_h = 11, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2809, .adv_w = 62, .box_w = 2, .box_h = 11, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2820, .adv_w = 64, .box_w = 5, .box_h = 14, .ofs_x = -2, .ofs_y = -3},\n    {.bitmap_index = 2855, .adv_w = 138, .box_w = 8, .box_h = 11, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2899, .adv_w = 62, .box_w = 2, .box_h = 11, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2910, .adv_w = 237, .box_w = 13, .box_h = 8, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2962, .adv_w = 153, .box_w = 8, .box_h = 8, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 2994, .adv_w = 142, .box_w = 9, .box_h = 8, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 3030, .adv_w = 153, .box_w = 8, .box_h = 11, .ofs_x = 1, .ofs_y = -3},\n    {.bitmap_index = 3074, .adv_w = 153, .box_w = 9, .box_h = 11, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 3124, .adv_w = 92, .box_w = 5, .box_h = 8, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 3144, .adv_w = 112, .box_w = 7, .box_h = 8, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 3172, .adv_w = 93, .box_w = 6, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 3202, .adv_w = 152, .box_w = 8, .box_h = 8, .ofs_x = 1, .ofs_y = 0},\n    {.bitmap_index = 3234, .adv_w = 125, .box_w = 9, .box_h = 8, .ofs_x = -1, .ofs_y = 0},\n    {.bitmap_index = 3270, .adv_w = 201, .box_w = 13, .box_h = 8, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 3322, .adv_w = 124, .box_w = 8, .box_h = 8, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 3354, .adv_w = 125, .box_w = 9, .box_h = 11, .ofs_x = -1, .ofs_y = -3},\n    {.bitmap_index = 3404, .adv_w = 117, .box_w = 7, .box_h = 8, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 3432, .adv_w = 79, .box_w = 5, .box_h = 14, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 3467, .adv_w = 67, .box_w = 2, .box_h = 14, .ofs_x = 1, .ofs_y = -3},\n    {.bitmap_index = 3481, .adv_w = 79, .box_w = 5, .box_h = 14, .ofs_x = 0, .ofs_y = -3},\n    {.bitmap_index = 3516, .adv_w = 130, .box_w = 8, .box_h = 3, .ofs_x = 0, .ofs_y = 3},\n    {.bitmap_index = 3528, .adv_w = 94, .box_w = 6, .box_h = 5, .ofs_x = 0, .ofs_y = 6},\n    {.bitmap_index = 3543, .adv_w = 70, .box_w = 4, .box_h = 3, .ofs_x = 0, .ofs_y = 3},\n    {.bitmap_index = 3549, .adv_w = 224, .box_w = 15, .box_h = 15, .ofs_x = -1, .ofs_y = -2},\n    {.bitmap_index = 3662, .adv_w = 224, .box_w = 14, .box_h = 11, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 3739, .adv_w = 224, .box_w = 14, .box_h = 13, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 3830, .adv_w = 224, .box_w = 14, .box_h = 11, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 3907, .adv_w = 154, .box_w = 10, .box_h = 11, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 3962, .adv_w = 224, .box_w = 14, .box_h = 15, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 4067, .adv_w = 224, .box_w = 14, .box_h = 15, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 4172, .adv_w = 252, .box_w = 16, .box_h = 13, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 4276, .adv_w = 224, .box_w = 14, .box_h = 15, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 4381, .adv_w = 252, .box_w = 16, .box_h = 11, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 4469, .adv_w = 224, .box_w = 14, .box_h = 15, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 4574, .adv_w = 112, .box_w = 7, .box_h = 12, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 4616, .adv_w = 168, .box_w = 11, .box_h = 12, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 4682, .adv_w = 252, .box_w = 16, .box_h = 14, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 4794, .adv_w = 224, .box_w = 14, .box_h = 11, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 4871, .adv_w = 154, .box_w = 10, .box_h = 15, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 4946, .adv_w = 196, .box_w = 10, .box_h = 14, .ofs_x = 1, .ofs_y = -2},\n    {.bitmap_index = 5016, .adv_w = 196, .box_w = 13, .box_h = 15, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 5114, .adv_w = 196, .box_w = 13, .box_h = 13, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 5199, .adv_w = 196, .box_w = 13, .box_h = 13, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 5284, .adv_w = 196, .box_w = 10, .box_h = 14, .ofs_x = 1, .ofs_y = -2},\n    {.bitmap_index = 5354, .adv_w = 196, .box_w = 14, .box_h = 13, .ofs_x = -1, .ofs_y = -1},\n    {.bitmap_index = 5445, .adv_w = 140, .box_w = 9, .box_h = 13, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 5504, .adv_w = 140, .box_w = 9, .box_h = 13, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 5563, .adv_w = 196, .box_w = 13, .box_h = 13, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 5648, .adv_w = 196, .box_w = 13, .box_h = 4, .ofs_x = 0, .ofs_y = 3},\n    {.bitmap_index = 5674, .adv_w = 252, .box_w = 16, .box_h = 11, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 5762, .adv_w = 280, .box_w = 18, .box_h = 15, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 5897, .adv_w = 252, .box_w = 17, .box_h = 15, .ofs_x = -1, .ofs_y = -2},\n    {.bitmap_index = 6025, .adv_w = 224, .box_w = 14, .box_h = 13, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 6116, .adv_w = 196, .box_w = 13, .box_h = 8, .ofs_x = 0, .ofs_y = 1},\n    {.bitmap_index = 6168, .adv_w = 196, .box_w = 13, .box_h = 8, .ofs_x = 0, .ofs_y = 1},\n    {.bitmap_index = 6220, .adv_w = 280, .box_w = 18, .box_h = 11, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 6319, .adv_w = 224, .box_w = 14, .box_h = 11, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 6396, .adv_w = 224, .box_w = 14, .box_h = 15, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 6501, .adv_w = 224, .box_w = 15, .box_h = 15, .ofs_x = -1, .ofs_y = -2},\n    {.bitmap_index = 6614, .adv_w = 196, .box_w = 13, .box_h = 13, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 6699, .adv_w = 196, .box_w = 13, .box_h = 15, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 6797, .adv_w = 196, .box_w = 13, .box_h = 13, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 6882, .adv_w = 196, .box_w = 13, .box_h = 12, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 6960, .adv_w = 224, .box_w = 14, .box_h = 11, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 7037, .adv_w = 140, .box_w = 10, .box_h = 15, .ofs_x = -1, .ofs_y = -2},\n    {.bitmap_index = 7112, .adv_w = 196, .box_w = 13, .box_h = 15, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 7210, .adv_w = 196, .box_w = 13, .box_h = 15, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 7308, .adv_w = 252, .box_w = 16, .box_h = 11, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 7396, .adv_w = 224, .box_w = 16, .box_h = 15, .ofs_x = -1, .ofs_y = -2},\n    {.bitmap_index = 7516, .adv_w = 168, .box_w = 11, .box_h = 15, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 7599, .adv_w = 280, .box_w = 18, .box_h = 13, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 7716, .adv_w = 280, .box_w = 18, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 7806, .adv_w = 280, .box_w = 18, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 7896, .adv_w = 280, .box_w = 18, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 7986, .adv_w = 280, .box_w = 18, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 8076, .adv_w = 280, .box_w = 18, .box_h = 10, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 8166, .adv_w = 280, .box_w = 18, .box_h = 12, .ofs_x = 0, .ofs_y = -1},\n    {.bitmap_index = 8274, .adv_w = 196, .box_w = 12, .box_h = 15, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 8364, .adv_w = 196, .box_w = 13, .box_h = 15, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 8462, .adv_w = 224, .box_w = 15, .box_h = 15, .ofs_x = -1, .ofs_y = -2},\n    {.bitmap_index = 8575, .adv_w = 280, .box_w = 18, .box_h = 11, .ofs_x = 0, .ofs_y = 0},\n    {.bitmap_index = 8674, .adv_w = 168, .box_w = 11, .box_h = 15, .ofs_x = 0, .ofs_y = -2},\n    {.bitmap_index = 8757, .adv_w = 225, .box_w = 15, .box_h = 10, .ofs_x = 0, .ofs_y = 0}\n}", "sline": 1518}, "unicode_list_1": {"type": "Variable", "def": "static const uint16_t unicode_list_1[] = {\n    0x0, 0x1f72, 0xef51, 0xef58, 0xef5b, 0xef5c, 0xef5d, 0xef61,\n    0xef63, 0xef65, 0xef69, 0xef6c, 0xef71, 0xef76, 0xef77, 0xef78,\n    0xef8e, 0xef93, 0xef98, 0xef9b, 0xef9c, 0xef9d, 0xefa1, 0xefa2,\n    0xefa3, 0xefa4, 0xefb7, 0xefb8, 0xefbe, 0xefc0, 0xefc1, 0xefc4,\n    0xefc7, 0xefc8, 0xefc9, 0xefcb, 0xefe3, 0xefe5, 0xf014, 0xf015,\n    0xf017, 0xf019, 0xf030, 0xf037, 0xf03a, 0xf043, 0xf06c, 0xf074,\n    0xf0ab, 0xf13b, 0xf190, 0xf191, 0xf192, 0xf193, 0xf194, 0xf1d7,\n    0xf1e3, 0xf23d, 0xf254, 0xf4aa, 0xf712, 0xf7f2\n}", "sline": 1683}, "cmaps": {"type": "Variable", "def": "static const lv_font_fmt_txt_cmap_t cmaps[]", "sline": 1695}, "kern_left_class_mapping": {"type": "Variable", "def": "static const uint8_t kern_left_class_mapping[] =\n{\n    0, 0, 1, 2, 0, 3, 4, 5,\n    2, 6, 7, 8, 9, 10, 9, 10,\n    11, 12, 0, 13, 14, 15, 16, 17,\n    18, 19, 12, 20, 20, 0, 0, 0,\n    21, 22, 23, 24, 25, 22, 26, 27,\n    28, 29, 29, 30, 31, 32, 29, 29,\n    22, 33, 34, 35, 3, 36, 30, 37,\n    37, 38, 39, 40, 41, 42, 43, 0,\n    44, 0, 45, 46, 47, 48, 49, 50,\n    51, 45, 52, 52, 53, 48, 45, 45,\n    46, 46, 54, 55, 56, 57, 51, 58,\n    58, 59, 58, 60, 41, 0, 0, 9,\n    61, 9, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0\n}", "sline": 1713}, "kern_right_class_mapping": {"type": "Variable", "def": "static const uint8_t kern_right_class_mapping[] =\n{\n    0, 0, 1, 2, 0, 3, 4, 5,\n    2, 6, 7, 8, 9, 10, 9, 10,\n    11, 12, 13, 14, 15, 16, 17, 12,\n    18, 19, 20, 21, 21, 0, 0, 0,\n    22, 23, 24, 25, 23, 25, 25, 25,\n    23, 25, 25, 26, 25, 25, 25, 25,\n    23, 25, 23, 25, 3, 27, 28, 29,\n    29, 30, 31, 32, 33, 34, 35, 0,\n    36, 0, 37, 38, 39, 39, 39, 0,\n    39, 38, 40, 41, 38, 38, 42, 42,\n    39, 42, 39, 42, 43, 44, 45, 46,\n    46, 47, 46, 48, 0, 0, 35, 9,\n    49, 9, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0\n}", "sline": 1738}, "kern_class_values": {"type": "Variable", "def": "static const int8_t kern_class_values[] =\n{\n    0, 1, 0, 0, 0, 0, 0, 0,\n    0, 1, 0, 0, 2, 0, 0, 0,\n    0, 2, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 1, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 1, 10, 0, 6, -5, 0, 0,\n    0, 0, -12, -13, 2, 11, 5, 4,\n    -9, 2, 11, 1, 9, 2, 7, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 13, 2, -2, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 4, 0, -7, 0, 0, 0, 0,\n    0, -4, 4, 4, 0, 0, -2, 0,\n    -2, 2, 0, -2, 0, -2, -1, -4,\n    0, 0, 0, 0, -2, 0, 0, -3,\n    -3, 0, 0, -2, 0, -4, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, -2,\n    -2, 0, -3, 0, -6, 0, -27, 0,\n    0, -4, 0, 4, 7, 0, 0, -4,\n    2, 2, 7, 4, -4, 4, 0, 0,\n    -13, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -8, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, -6, -3, -11, 0, -9,\n    -2, 0, 0, 0, 0, 0, 9, 0,\n    -7, -2, -1, 1, 0, -4, 0, 0,\n    -2, -17, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -18, -2, 9,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -9, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 7,\n    0, 2, 0, 0, -4, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 9, 2,\n    1, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    -8, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 2,\n    4, 2, 7, -2, 0, 0, 4, -2,\n    -7, -31, 2, 6, 4, 0, -3, 0,\n    8, 0, 7, 0, 7, 0, -21, 0,\n    -3, 7, 0, 7, -2, 4, 2, 0,\n    0, 1, -2, 0, 0, -4, 18, 0,\n    18, 0, 7, 0, 9, 3, 4, 7,\n    0, 0, 0, -8, 0, 0, 0, 0,\n    1, -2, 0, 2, -4, -3, -4, 2,\n    0, -2, 0, 0, 0, -9, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, -15, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 1, -12, 0, -14, 0, 0, 0,\n    0, -2, 0, 22, -3, -3, 2, 2,\n    -2, 0, -3, 2, 0, 0, -12, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, -22, 0, 2, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, -14, 0, 13, 0, 0, -8, 0,\n    7, 0, -15, -22, -15, -4, 7, 0,\n    0, -15, 0, 3, -5, 0, -3, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 6, 7, -27, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 11, 0, 2, 0, 0, 0,\n    0, 0, 2, 2, -3, -4, 0, -1,\n    -1, -2, 0, 0, -2, 0, 0, 0,\n    -4, 0, -2, 0, -5, -4, 0, -6,\n    -7, -7, -4, 0, -4, 0, -4, 0,\n    0, 0, 0, -2, 0, 0, 2, 0,\n    2, -2, 0, 1, 0, 0, 0, 2,\n    -2, 0, 0, 0, -2, 2, 2, -1,\n    0, 0, 0, -4, 0, -1, 0, 0,\n    0, 0, 0, 1, 0, 3, -2, 0,\n    -3, 0, -4, 0, 0, -2, 0, 7,\n    0, 0, -2, 0, 0, 0, 0, 0,\n    -1, 1, -2, -2, 0, 0, -2, 0,\n    -2, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, -1, -1, 0, -2, -3, 0,\n    0, 0, 0, 0, 1, 0, 0, -2,\n    0, -2, -2, -2, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -1, 0, 0,\n    0, 0, -2, -3, 0, -3, 0, -7,\n    -2, -7, 4, 0, 0, -4, 2, 4,\n    6, 0, -6, -1, -3, 0, -1, -11,\n    2, -2, 2, -12, 2, 0, 0, 1,\n    -12, 0, -12, -2, -19, -2, 0, -11,\n    0, 4, 6, 0, 3, 0, 0, 0,\n    0, 0, 0, -4, -3, 0, -7, 0,\n    0, 0, -2, 0, 0, 0, -2, 0,\n    0, 0, 0, 0, -1, -1, 0, -1,\n    -3, 0, 0, 0, 0, 0, 0, 0,\n    -2, -2, 0, -2, -3, -2, 0, 0,\n    -2, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -2, -2, 0, -3,\n    0, -2, 0, -4, 2, 0, 0, -3,\n    1, 2, 2, 0, 0, 0, 0, 0,\n    0, -2, 0, 0, 0, 0, 0, 2,\n    0, 0, -2, 0, -2, -2, -3, 0,\n    0, 0, 0, 0, 0, 0, 2, 0,\n    -2, 0, 0, 0, 0, -2, -3, 0,\n    -4, 0, 7, -2, 1, -7, 0, 0,\n    6, -11, -12, -9, -4, 2, 0, -2,\n    -15, -4, 0, -4, 0, -4, 3, -4,\n    -14, 0, -6, 0, 0, 1, -1, 2,\n    -2, 0, 2, 0, -7, -9, 0, -11,\n    -5, -5, -5, -7, -3, -6, 0, -4,\n    -6, 1, 0, 1, 0, -2, 0, 0,\n    0, 2, 0, 2, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, -2,\n    0, -1, 0, -1, -2, 0, -4, -5,\n    -5, -1, 0, -7, 0, 0, 0, 0,\n    0, 0, -2, 0, 0, 0, 0, 1,\n    -1, 0, 0, 0, 2, 0, 0, 0,\n    0, 0, 0, 0, 0, 11, 0, 0,\n    0, 0, 0, 0, 2, 0, 0, 0,\n    -2, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -4, 0, 2, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -2, 0, 0, 0,\n    -4, 0, 0, 0, 0, -11, -7, 0,\n    0, 0, -3, -11, 0, 0, -2, 2,\n    0, -6, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -4, 0, 0, -4,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 2, 0, -4, 0,\n    0, 0, 0, 3, 0, 2, -4, -4,\n    0, -2, -2, -3, 0, 0, 0, 0,\n    0, 0, -7, 0, -2, 0, -3, -2,\n    0, -5, -6, -7, -2, 0, -4, 0,\n    -7, 0, 0, 0, 0, 18, 0, 0,\n    1, 0, 0, -3, 0, 2, 0, -10,\n    0, 0, 0, 0, 0, -21, -4, 7,\n    7, -2, -9, 0, 2, -3, 0, -11,\n    -1, -3, 2, -16, -2, 3, 0, 3,\n    -8, -3, -8, -7, -9, 0, 0, -13,\n    0, 13, 0, 0, -1, 0, 0, 0,\n    -1, -1, -2, -6, -7, 0, -21, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    1, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, -2, 0, -1, -2, -3, 0, 0,\n    -4, 0, -2, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, -1, 0, -4, 0, 0, 4,\n    -1, 3, 0, -5, 2, -2, -1, -6,\n    -2, 0, -3, -2, -2, 0, -3, -4,\n    0, 0, -2, -1, -2, -4, -3, 0,\n    0, -2, 0, 2, -2, 0, -5, 0,\n    0, 0, -4, 0, -4, 0, -4, -4,\n    2, 0, 0, 0, 0, 0, 0, 0,\n    0, -4, 2, 0, -3, 0, -2, -3,\n    -7, -2, -2, -2, -1, -2, -3, -1,\n    0, 0, 0, 0, 0, -2, -2, -2,\n    0, 0, 0, 0, 3, -2, 0, -2,\n    0, 0, 0, -2, -3, -2, -2, -3,\n    -2, 0, 2, 9, -1, 0, -6, 0,\n    -2, 4, 0, -2, -9, -3, 3, 0,\n    0, -11, -4, 2, -4, 2, 0, -2,\n    -2, -7, 0, -3, 1, 0, 0, -4,\n    0, 0, 0, 2, 2, -4, -4, 0,\n    -4, -2, -3, -2, -2, 0, -4, 1,\n    -4, -4, 7, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 2, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -4, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    -2, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, -2, -2,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -3, 0, 0, -3,\n    0, 0, -2, -2, 0, 0, 0, 0,\n    -2, 0, 0, 0, 0, -1, 0, 0,\n    0, 0, 0, -2, 0, 0, 0, 0,\n    -3, 0, -4, 0, 0, 0, -7, 0,\n    2, -5, 4, 0, -2, -11, 0, 0,\n    -5, -2, 0, -9, -6, -6, 0, 0,\n    -10, -2, -9, -9, -11, 0, -6, 0,\n    2, 15, -3, 0, -5, -2, -1, -2,\n    -4, -6, -4, -8, -9, -5, -2, 0,\n    0, -2, 0, 1, 0, 0, -16, -2,\n    7, 5, -5, -8, 0, 1, -7, 0,\n    -11, -2, -2, 4, -21, -3, 1, 0,\n    0, -15, -3, -12, -2, -16, 0, 0,\n    -16, 0, 13, 1, 0, -2, 0, 0,\n    0, 0, -1, -2, -9, -2, 0, -15,\n    0, 0, 0, 0, -7, 0, -2, 0,\n    -1, -6, -11, 0, 0, -1, -3, -7,\n    -2, 0, -2, 0, 0, 0, 0, -10,\n    -2, -7, -7, -2, -4, -6, -2, -4,\n    0, -4, -2, -7, -3, 0, -3, -4,\n    -2, -4, 0, 1, 0, -2, -7, 0,\n    4, 0, -4, 0, 0, 0, 0, 3,\n    0, 2, -4, 9, 0, -2, -2, -3,\n    0, 0, 0, 0, 0, 0, -7, 0,\n    -2, 0, -3, -2, 0, -5, -6, -7,\n    -2, 0, -4, 2, 9, 0, 0, 0,\n    0, 18, 0, 0, 1, 0, 0, -3,\n    0, 2, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    -2, -4, 0, 0, 0, 0, 0, -1,\n    0, 0, 0, -2, -2, 0, 0, -4,\n    -2, 0, 0, -4, 0, 4, -1, 0,\n    0, 0, 0, 0, 0, 1, 0, 0,\n    0, 0, 3, 4, 2, -2, 0, -7,\n    -4, 0, 7, -7, -7, -4, -4, 9,\n    4, 2, -19, -2, 4, -2, 0, -2,\n    2, -2, -8, 0, -2, 2, -3, -2,\n    -7, -2, 0, 0, 7, 4, 0, -6,\n    0, -12, -3, 6, -3, -9, 1, -3,\n    -7, -7, -2, 9, 2, 0, -3, 0,\n    -6, 0, 2, 7, -5, -8, -9, -6,\n    7, 0, 1, -16, -2, 2, -4, -2,\n    -5, 0, -5, -8, -3, -3, -2, 0,\n    0, -5, -5, -2, 0, 7, 5, -2,\n    -12, 0, -12, -3, 0, -8, -13, -1,\n    -7, -4, -7, -6, 6, 0, 0, -3,\n    0, -4, -2, 0, -2, -4, 0, 4,\n    -7, 2, 0, 0, -12, 0, -2, -5,\n    -4, -2, -7, -6, -7, -5, 0, -7,\n    -2, -5, -4, -7, -2, 0, 0, 1,\n    11, -4, 0, -7, -2, 0, -2, -4,\n    -5, -6, -6, -9, -3, -4, 4, 0,\n    -3, 0, -11, -3, 1, 4, -7, -8,\n    -4, -7, 7, -2, 1, -21, -4, 4,\n    -5, -4, -8, 0, -7, -9, -3, -2,\n    -2, -2, -5, -7, -1, 0, 0, 7,\n    6, -2, -15, 0, -13, -5, 5, -9,\n    -15, -4, -8, -9, -11, -7, 4, 0,\n    0, 0, 0, -3, 0, 0, 2, -3,\n    4, 2, -4, 4, 0, 0, -7, -1,\n    0, -1, 0, 1, 1, -2, 0, 0,\n    0, 0, 0, 0, -2, 0, 0, 0,\n    0, 2, 7, 0, 0, -3, 0, 0,\n    0, 0, -2, -2, -3, 0, 0, 0,\n    1, 2, 0, 0, 0, 0, 2, 0,\n    -2, 0, 9, 0, 4, 1, 1, -3,\n    0, 4, 0, 0, 0, 2, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 7, 0, 6, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, -13, 0, -2, 4, 0, 7,\n    0, 0, 22, 3, -4, -4, 2, 2,\n    -2, 1, -11, 0, 0, 11, -13, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, -15, 9, 31, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, -13, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -4, 0, 0, -4,\n    -2, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -2, 0, -6, 0,\n    0, 1, 0, 0, 2, 29, -4, -2,\n    7, 6, -6, 2, 0, 0, 2, 2,\n    -3, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -29, 6, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, -6,\n    0, 0, 0, -6, 0, 0, 0, 0,\n    -5, -1, 0, 0, 0, -5, 0, -3,\n    0, -11, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -15, 0, 0,\n    0, 0, 1, 0, 0, 0, 0, 0,\n    0, -2, 0, 0, -4, 0, -3, 0,\n    -6, 0, 0, 0, -4, 2, -3, 0,\n    0, -6, -2, -5, 0, 0, -6, 0,\n    -2, 0, -11, 0, -2, 0, 0, -18,\n    -4, -9, -2, -8, 0, 0, -15, 0,\n    -6, -1, 0, 0, 0, 0, 0, 0,\n    0, 0, -3, -4, -2, -4, 0, 0,\n    0, 0, -5, 0, -5, 3, -2, 4,\n    0, -2, -5, -2, -4, -4, 0, -3,\n    -1, -2, 2, -6, -1, 0, 0, 0,\n    -20, -2, -3, 0, -5, 0, -2, -11,\n    -2, 0, 0, -2, -2, 0, 0, 0,\n    0, 2, 0, -2, -4, -2, 4, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 3, 0, 0, 0, 0, 0,\n    0, -5, 0, -2, 0, 0, 0, -4,\n    2, 0, 0, 0, -6, -2, -4, 0,\n    0, -6, 0, -2, 0, -11, 0, 0,\n    0, 0, -22, 0, -4, -8, -11, 0,\n    0, -15, 0, -2, -3, 0, 0, 0,\n    0, 0, 0, 0, 0, -2, -3, -1,\n    -3, 1, 0, 0, 4, -3, 0, 7,\n    11, -2, -2, -7, 3, 11, 4, 5,\n    -6, 3, 9, 3, 6, 5, 6, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 14, 11, -4, -2, 0, -2,\n    18, 10, 18, 0, 0, 0, 2, 0,\n    0, 8, 0, 0, -4, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, -2, 0,\n    0, 0, 0, 0, 0, 0, 0, 3,\n    0, 0, 0, 0, -19, -3, -2, -9,\n    -11, 0, 0, -15, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -4, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, -2,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    3, 0, 0, 0, 0, -19, -3, -2,\n    -9, -11, 0, 0, -9, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    -2, 0, 0, 0, -5, 2, 0, -2,\n    2, 4, 2, -7, 0, 0, -2, 2,\n    0, 2, 0, 0, 0, 0, -6, 0,\n    -2, -2, -4, 0, -2, -9, 0, 14,\n    -2, 0, -5, -2, 0, -2, -4, 0,\n    -2, -6, -4, -3, 0, 0, 0, -4,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, -2, 0, 0, 0, 0, 0, 0,\n    0, 0, 3, 0, 0, 0, 0, -19,\n    -3, -2, -9, -11, 0, 0, -15, 0,\n    0, 0, 0, 0, 0, 11, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    -4, 0, -7, -3, -2, 7, -2, -2,\n    -9, 1, -1, 1, -2, -6, 0, 5,\n    0, 2, 1, 2, -5, -9, -3, 0,\n    -9, -4, -6, -9, -9, 0, -4, -4,\n    -3, -3, -2, -2, -3, -2, 0, -2,\n    -1, 3, 0, 3, -2, 0, 7, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, -2, -2, -2, 0, 0,\n    -6, 0, -1, 0, -4, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    -13, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -2, -2, 0, -3,\n    0, 0, 0, 0, -2, 0, 0, -4,\n    -2, 2, 0, -4, -4, -2, 0, -6,\n    -2, -5, -2, -3, 0, -4, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, -15, 0, 7, 0, 0, -4, 0,\n    0, 0, 0, -3, 0, -2, 0, 0,\n    -1, 0, 0, -2, 0, -5, 0, 0,\n    9, -3, -7, -7, 2, 2, 2, 0,\n    -6, 2, 3, 2, 7, 2, 7, -2,\n    -6, 0, 0, -9, 0, 0, -7, -6,\n    0, 0, -4, 0, -3, -4, 0, -3,\n    0, -3, 0, -2, 3, 0, -2, -7,\n    -2, 8, 0, 0, -2, 0, -4, 0,\n    0, 3, -5, 0, 2, -2, 2, 0,\n    0, -7, 0, -2, -1, 0, -2, 2,\n    -2, 0, 0, 0, -9, -3, -5, 0,\n    -7, 0, 0, -11, 0, 8, -2, 0,\n    -4, 0, 1, 0, -2, 0, -2, -7,\n    0, -2, 2, 0, 0, 0, 0, -2,\n    0, 0, 2, -3, 1, 0, 0, -3,\n    -2, 0, -3, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -14, 0, 5, 0,\n    0, -2, 0, 0, 0, 0, 0, 0,\n    -2, -2, 0, 0, 0, 4, 0, 5,\n    0, 0, 0, 0, 0, -14, -13, 1,\n    10, 7, 4, -9, 2, 9, 0, 8,\n    0, 4, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 12, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0\n}", "sline": 1763}, "kern_classes": {"type": "Variable", "def": "static const lv_font_fmt_txt_kern_classes_t kern_classes =\n{\n    .class_pair_values   = kern_class_values,\n    .left_class_mapping  = kern_left_class_mapping,\n    .right_class_mapping = kern_right_class_mapping,\n    .left_class_cnt      = 61,\n    .right_class_cnt     = 49,\n}", "sline": 2143}, "cache": {"type": "Variable", "def": "static  lv_font_fmt_txt_glyph_cache_t cache", "sline": 2158}, "font_dsc": {"type": "Variable", "def": "static const lv_font_fmt_txt_dsc_t font_dsc = {\n#else\nstatic lv_font_fmt_txt_dsc_t font_dsc = {\n#endif\n    .glyph_bitmap = glyph_bitmap,\n    .glyph_dsc = glyph_dsc,\n    .cmaps = cmaps,\n    .kern_dsc = &kern_classes,\n    .kern_scale = 16,\n    .cmap_num = 2,\n    .bpp = 4,\n    .kern_classes = 1,\n    .bitmap_format = 0,\n#if LV_VERSION_CHECK(8, 0, 0)\n    .cache = &cache\n#endif\n}", "sline": 2159}, "lv_font_montserrat_14": {"type": "Variable", "def": "const lv_font_t lv_font_montserrat_14 = {\n#else\nlv_font_t lv_font_montserrat_14 = {\n#endif\n    .get_glyph_dsc = lv_font_get_glyph_dsc_fmt_txt,    /*Function pointer to get glyph's data*/\n    .get_glyph_bitmap = lv_font_get_bitmap_fmt_txt,    /*Function pointer to get glyph's bitmap*/\n    .line_height = 16,          /*The maximum line height required by the font*/\n    .base_line = 3,             /*Baseline measured from the bottom of the line*/\n#if !(LVGL_VERSION_MAJOR == 6 && LVGL_VERSION_MINOR == 0)\n    .subpx = LV_FONT_SUBPX_NONE,\n#endif\n#if LV_VERSION_CHECK(7, 4, 0)\n    .underline_position = -1,\n    .underline_thickness = 1,\n#endif\n    .dsc = &font_dsc           /*The custom font data. Will be accessed by `get_glyph_bitmap/dsc` */\n}", "sline": 2184}, "carbit_updater/lvgl/src/font/lv_font_montserrat_14.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_14.c"}}, "carbit_updater/lv_drivers/indev/mousewheel.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 20}, "carbit_updater/lv_drivers/indev/mousewheel.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/indev/mousewheel.h"}}, "carbit_updater/lv_conf.h": {"stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 21}, "custom_tick_get": {"type": "Function", "def": "uint32_t custom_tick_get(void)", "sline": 91}, "carbit_updater/lv_conf.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_conf.h"}}, "carbit_updater/lv_drivers/indev/XPT2046.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 20}, "carbit_updater/lv_drivers/indev/XPT2046.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/indev/XPT2046.h"}}, "carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h": {"lv_area": {"type": "Variable", "def": "#include misc/lv_area.h", "sline": 40, "include": ["carbit_updater/lvgl/src/misc/lv_area.h", null]}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9).src": {"type": "Variable", "def": "const lv_color_t * src", "sline": 91, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9).src_area": {"type": "Variable", "def": "lv_area_t src_area", "sline": 92, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9).src_width": {"type": "Variable", "def": "lv_coord_t src_width", "sline": 93, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9).src_height": {"type": "Variable", "def": "lv_coord_t src_height", "sline": 94, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9).src_stride": {"type": "Variable", "def": "uint32_t src_stride", "sline": 95, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9).dst": {"type": "Variable", "def": "const lv_color_t * dst", "sline": 97, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9).dst_area": {"type": "Variable", "def": "lv_area_t dst_area", "sline": 98, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9).dst_width": {"type": "Variable", "def": "lv_coord_t dst_width", "sline": 99, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9).dst_height": {"type": "Variable", "def": "lv_coord_t dst_height", "sline": 100, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9).dst_stride": {"type": "Variable", "def": "uint32_t dst_stride", "sline": 101, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9).opa": {"type": "Variable", "def": "lv_opa_t opa", "sline": 103, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h:89:9)": {"type": "Struct", "def": "struct {\n\n    const lv_color_t * src;  /**< Source buffer pointer (must be aligned on 32 bytes)*/\n    lv_area_t src_area;      /**< Area to be copied from source*/\n    lv_coord_t src_width;    /**< Source buffer width*/\n    lv_coord_t src_height;   /**< Source buffer height*/\n    uint32_t src_stride;     /**< Source buffer stride in bytes (must be aligned on 16 px)*/\n\n    const lv_color_t * dst;  /**< Destination buffer pointer (must be aligned on 32 bytes)*/\n    lv_area_t dst_area;      /**< Target area in destination buffer (must be the same as src_area)*/\n    lv_coord_t dst_width;    /**< Destination buffer width*/\n    lv_coord_t dst_height;   /**< Destination buffer height*/\n    uint32_t dst_stride;     /**< Destination buffer stride in bytes (must be aligned on 16 px)*/\n\n    lv_opa_t opa;            /**< Opacity - alpha mix (0 = source not copied, 255 = 100% opaque)*/\n\n}", "sline": 89, "docstring": "/**", "body": "const lv_color_t * src\nlv_area_t src_area\nlv_coord_t src_width\nlv_coord_t src_height\nuint32_t src_stride\nconst lv_color_t * dst\nlv_area_t dst_area\nlv_coord_t dst_width\nlv_coord_t dst_height\nuint32_t dst_stride\nlv_opa_t opa\n"}, "lv_gpu_nxp_vglite_blit_info_t": {"type": "Variable", "def": "typedef struct {\n\n    const lv_color_t * src;  /**< Source buffer pointer (must be aligned on 32 bytes)*/\n    lv_area_t src_area;      /**< Area to be copied from source*/\n    lv_coord_t src_width;    /**< Source buffer width*/\n    lv_coord_t src_height;   /**< Source buffer height*/\n    uint32_t src_stride;     /**< Source buffer stride in bytes (must be aligned on 16 px)*/\n\n    const lv_color_t * dst;  /**< Destination buffer pointer (must be aligned on 32 bytes)*/\n    lv_area_t dst_area;      /**< Target area in destination buffer (must be the same as src_area)*/\n    lv_coord_t dst_width;    /**< Destination buffer width*/\n    lv_coord_t dst_height;   /**< Destination buffer height*/\n    uint32_t dst_stride;     /**< Destination buffer stride in bytes (must be aligned on 16 px)*/\n\n    lv_opa_t opa;            /**< Opacity - alpha mix (0 = source not copied, 255 = 100% opaque)*/\n\n} lv_gpu_nxp_vglite_blit_info_t", "sline": 105, "docstring": "/**"}, "lv_gpu_nxp_vglite_fill": {"type": "Function", "def": "lv_res_t lv_gpu_nxp_vglite_fill(lv_color_t * dest_buf, lv_coord_t dest_width, lv_coord_t dest_height,\n                                const lv_area_t * fill_area, lv_color_t color, lv_opa_t opa)", "sline": 126}, "lv_gpu_nxp_vglite_blit": {"type": "Function", "def": "lv_res_t lv_gpu_nxp_vglite_blit(lv_gpu_nxp_vglite_blit_info_t * blit)", "sline": 135}, "carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.h"}}, "carbit_updater/lvgl/src/misc/lv_utils.c": {"stddef": {"type": "Variable", "def": "#include stddef.h", "sline": 9}, "lv_utils": {"type": "Variable", "def": "#include lv_utils.h", "sline": 11, "include": ["carbit_updater/lvgl/src/misc/lv_utils.h", null]}, "_lv_utils_bsearch": {"type": "Function", "def": "void * _lv_utils_bsearch(const void * key, const void * base, uint32_t n, uint32_t size,\n                         int32_t (*cmp)(const void * pRef, const void * pElement))", "sline": 54, "body": "{\n    const char * middle;\n    int32_t c;\n\n    for(middle = base; n != 0;) {\n        middle += (n / 2) * size;\n        if((c = (*cmp)(key, middle)) > 0) {\n            n    = (n / 2) - ((n & 1) == 0);\n            base = (middle += size);\n        }\n        else if(c < 0) {\n            n /= 2;\n            middle = base;\n        }\n        else {\n            return (char *)middle;\n        }\n    }\n    return NULL;\n}"}, "carbit_updater/lvgl/src/misc/lv_utils.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_utils.c"}}, "carbit_updater/lv_drivers/display/GC9A01.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 20}, "carbit_updater/lv_drivers/display/GC9A01.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/GC9A01.h"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_48.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_montserrat_48.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_48.c"}}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_stack_blur.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../../lv_conf_internal.h", "sline": 16}, "lv_color": {"type": "Variable", "def": "#include ../../misc/lv_color.h", "sline": 18}, "lv_stack_blur_grayscale": {"type": "Function", "def": "void lv_stack_blur_grayscale(lv_opa_t * buf, uint16_t w, uint16_t h, uint16_t r)", "sline": 32}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_stack_blur.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_stack_blur.h"}}, "carbit_updater/lvgl/src/extra/widgets/meter/lv_meter.c": {"lv_meter": {"type": "Variable", "def": "#include lv_meter.h", "sline": 9, "include": ["carbit_updater/lvgl/src/extra/widgets/meter/lv_meter.h", null]}, "lv_assert": {"type": "Variable", "def": "#include ../../../misc/lv_assert.h", "sline": 12}, "lv_meter_constructor": {"type": "Function", "def": "static void lv_meter_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 266, "body": "{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_meter_t * meter = (lv_meter_t *)obj;\n\n    _lv_ll_init(&meter->scale_ll, sizeof(lv_meter_scale_t));\n    _lv_ll_init(&meter->indicator_ll, sizeof(lv_meter_indicator_t));\n\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}"}, "lv_meter_destructor": {"type": "Function", "def": "static void lv_meter_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 279, "body": "{\n    LV_UNUSED(class_p);\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_meter_t * meter = (lv_meter_t *)obj;\n    _lv_ll_clear(&meter->indicator_ll);\n    _lv_ll_clear(&meter->scale_ll);\n\n}"}, "lv_meter_event": {"type": "Function", "def": "static void lv_meter_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 289, "body": "{\n    LV_UNUSED(class_p);\n\n    lv_res_t res = lv_obj_event_base(MY_CLASS, e);\n    if(res != LV_RES_OK) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n    if(code == LV_EVENT_DRAW_MAIN) {\n        const lv_area_t * clip_area = lv_event_get_param(e);\n        lv_area_t scale_area;\n        lv_obj_get_content_coords(obj, &scale_area);\n\n        draw_arcs(obj, clip_area, &scale_area);\n        draw_ticks_and_labels(obj, clip_area, &scale_area);\n        draw_needles(obj, clip_area, &scale_area);\n\n        lv_coord_t r_edge = lv_area_get_width(&scale_area) / 2;\n        lv_point_t scale_center;\n        scale_center.x = scale_area.x1 + r_edge;\n        scale_center.y = scale_area.y1 + r_edge;\n\n        lv_draw_rect_dsc_t mid_dsc;\n        lv_draw_rect_dsc_init(&mid_dsc);\n        lv_obj_init_draw_rect_dsc(obj, LV_PART_INDICATOR, &mid_dsc);\n        lv_coord_t w = lv_obj_get_style_width(obj, LV_PART_INDICATOR) / 2;\n        lv_coord_t h = lv_obj_get_style_height(obj, LV_PART_INDICATOR) / 2;\n        lv_area_t nm_cord;\n        nm_cord.x1 = scale_center.x - w;\n        nm_cord.y1 = scale_center.y - h;\n        nm_cord.x2 = scale_center.x + w;\n        nm_cord.y2 = scale_center.y + h;\n        lv_draw_rect(&nm_cord, clip_area, &mid_dsc);\n    }\n}"}, "draw_arcs": {"type": "Function", "def": "static void draw_arcs(lv_obj_t * obj, const lv_area_t * clip_area, const lv_area_t * scale_area)", "sline": 326, "body": "{\n    lv_meter_t * meter = (lv_meter_t *)obj;\n\n    lv_draw_arc_dsc_t arc_dsc;\n    lv_draw_arc_dsc_init(&arc_dsc);\n    arc_dsc.rounded = lv_obj_get_style_arc_rounded(obj, LV_PART_ITEMS);\n\n    lv_coord_t r_out = lv_area_get_width(scale_area) / 2 ;\n    lv_point_t scale_center;\n    scale_center.x = scale_area->x1 + r_out;\n    scale_center.y = scale_area->y1 + r_out;\n\n    lv_opa_t opa_main = lv_obj_get_style_opa(obj, LV_PART_MAIN);\n    lv_meter_indicator_t * indic;\n\n    lv_obj_draw_part_dsc_t part_draw_dsc;\n    lv_obj_draw_dsc_init(&part_draw_dsc, clip_area);\n    part_draw_dsc.arc_dsc = &arc_dsc;\n    part_draw_dsc.part = LV_PART_INDICATOR;\n    part_draw_dsc.class_p = MY_CLASS;\n    part_draw_dsc.type = LV_METER_DRAW_PART_ARC;\n\n    _LV_LL_READ_BACK(&meter->indicator_ll, indic) {\n        if(indic->type != LV_METER_INDICATOR_TYPE_ARC) continue;\n\n        arc_dsc.color = indic->type_data.arc.color;\n        arc_dsc.width = indic->type_data.arc.width;\n        arc_dsc.opa = indic->opa > LV_OPA_MAX ? opa_main : (opa_main * indic->opa) >> 8;\n\n        lv_meter_scale_t * scale = indic->scale;\n\n        int32_t start_angle = lv_map(indic->start_value, scale->min, scale->max, scale->rotation,\n                                     scale->rotation + scale->angle_range);\n        int32_t end_angle = lv_map(indic->end_value, scale->min, scale->max, scale->rotation,\n                                   scale->rotation + scale->angle_range);\n\n        part_draw_dsc.radius = r_out + indic->type_data.arc.r_mod;\n        part_draw_dsc.sub_part_ptr = indic;\n        part_draw_dsc.p1 = &scale_center;\n\n        lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n        lv_draw_arc(scale_center.x, scale_center.y, part_draw_dsc.radius, start_angle, end_angle, clip_area, &arc_dsc);\n        lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n    }\n}"}, "draw_ticks_and_labels": {"type": "Function", "def": "static void draw_ticks_and_labels(lv_obj_t * obj, const lv_area_t * clip_area, const lv_area_t * scale_area)", "sline": 373, "body": "{\n    lv_meter_t * meter    = (lv_meter_t *)obj;\n\n    lv_point_t p_center;\n    lv_coord_t r_edge = LV_MIN(lv_area_get_width(scale_area) / 2, lv_area_get_height(scale_area) / 2);\n    p_center.x = scale_area->x1 + r_edge;\n    p_center.y = scale_area->y1 + r_edge;\n\n    uint8_t i;\n\n    lv_draw_line_dsc_t line_dsc;\n    lv_draw_line_dsc_init(&line_dsc);\n    lv_obj_init_draw_line_dsc(obj, LV_PART_TICKS, &line_dsc);\n    line_dsc.raw_end = 1;\n\n    lv_draw_label_dsc_t label_dsc;\n    lv_draw_label_dsc_init(&label_dsc);\n    lv_obj_init_draw_label_dsc(obj, LV_PART_TICKS, &label_dsc);\n\n    lv_meter_scale_t * scale;\n\n    lv_draw_mask_radius_param_t inner_minor_mask;\n    lv_draw_mask_radius_param_t inner_major_mask;\n    lv_draw_mask_radius_param_t outer_mask;\n\n    lv_obj_draw_part_dsc_t part_draw_dsc;\n    lv_obj_draw_dsc_init(&part_draw_dsc, clip_area);\n    part_draw_dsc.class_p = MY_CLASS;\n    part_draw_dsc.part = LV_PART_TICKS;\n    part_draw_dsc.type = LV_METER_DRAW_PART_TICK;\n    part_draw_dsc.line_dsc = &line_dsc;\n\n    _LV_LL_READ_BACK(&meter->scale_ll, scale) {\n        part_draw_dsc.sub_part_ptr = scale;\n\n        lv_coord_t r_out = r_edge + scale->r_mod;\n        lv_coord_t r_in_minor = r_out - scale->tick_length;\n        lv_coord_t r_in_major = r_out - scale->tick_major_length;\n\n        lv_area_t area_inner_minor;\n        area_inner_minor.x1 = p_center.x - r_in_minor;\n        area_inner_minor.y1 = p_center.y - r_in_minor;\n        area_inner_minor.x2 = p_center.x + r_in_minor;\n        area_inner_minor.y2 = p_center.y + r_in_minor;\n        lv_draw_mask_radius_init(&inner_minor_mask, &area_inner_minor, LV_RADIUS_CIRCLE, true);\n\n        lv_area_t area_inner_major;\n        area_inner_major.x1 = p_center.x - r_in_major;\n        area_inner_major.y1 = p_center.y - r_in_major;\n        area_inner_major.x2 = p_center.x + r_in_major - 1;\n        area_inner_major.y2 = p_center.y + r_in_major - 1;\n        lv_draw_mask_radius_init(&inner_major_mask, &area_inner_major, LV_RADIUS_CIRCLE, true);\n\n        lv_area_t area_outer;\n        area_outer.x1 = p_center.x - r_out;\n        area_outer.y1 = p_center.y - r_out;\n        area_outer.x2 = p_center.x + r_out - 1;\n        area_outer.y2 = p_center.y + r_out - 1;\n        lv_draw_mask_radius_init(&outer_mask, &area_outer, LV_RADIUS_CIRCLE, false);\n        int16_t outer_mask_id = lv_draw_mask_add(&outer_mask, NULL);\n\n        int16_t inner_act_mask_id = LV_MASK_ID_INV; /*Will be added later*/\n\n        uint32_t minor_cnt = scale->tick_major_nth ? scale->tick_major_nth - 1 : 0xFFFF;\n        for(i = 0; i < scale->tick_cnt; i++) {\n            minor_cnt++;\n            bool major = false;\n            if(minor_cnt == scale->tick_major_nth) {\n                minor_cnt = 0;\n                major = true;\n            }\n\n            int32_t value_of_line = lv_map(i, 0, scale->tick_cnt - 1, scale->min, scale->max);\n            part_draw_dsc.value = value_of_line;\n\n            lv_color_t line_color = major ? scale->tick_major_color : scale->tick_color;\n            lv_color_t line_color_ori = line_color;\n\n            lv_coord_t line_width_ori = major ? scale->tick_major_width : scale->tick_width;\n            lv_coord_t line_width = line_width_ori;\n\n            lv_meter_indicator_t * indic;\n            _LV_LL_READ_BACK(&meter->indicator_ll, indic) {\n                if(indic->type != LV_METER_INDICATOR_TYPE_SCALE_LINES) continue;\n                if(value_of_line >= indic->start_value && value_of_line <= indic->end_value) {\n                    line_width += indic->type_data.scale_lines.width_mod;\n\n                    if(indic->type_data.scale_lines.color_start.full == indic->type_data.scale_lines.color_end.full) {\n                        line_color = indic->type_data.scale_lines.color_start;\n                    }\n                    else {\n                        lv_opa_t ratio;\n                        if(indic->type_data.scale_lines.local_grad) {\n                            ratio = lv_map(value_of_line, indic->start_value, indic->end_value, LV_OPA_TRANSP, LV_OPA_COVER);\n                        }\n                        else {\n                            ratio = lv_map(value_of_line, scale->min, scale->max, LV_OPA_TRANSP, LV_OPA_COVER);\n                        }\n                        line_color = lv_color_mix(indic->type_data.scale_lines.color_end, indic->type_data.scale_lines.color_start, ratio);\n                    }\n                }\n            }\n\n            /*`* 256` for extra precision*/\n            int32_t angle_upscale = ((i * scale->angle_range) << 8) / (scale->tick_cnt - 1);\n\n            int32_t angle_low = (angle_upscale >> 8);\n            int32_t angle_high = angle_low + 1;\n            int32_t angle_rem = angle_upscale & 0xFF;\n\n            /*Interpolate sine and cos*/\n            int32_t sin_low = lv_trigo_sin(angle_low + scale->rotation);\n            int32_t sin_high = lv_trigo_sin(angle_high + scale->rotation);\n            int32_t sin_mid = (sin_low * (256 - angle_rem) + sin_high * angle_rem) >> 8;\n\n            int32_t cos_low = lv_trigo_cos(angle_low + scale->rotation);\n            int32_t cos_high = lv_trigo_cos(angle_high + scale->rotation);\n            int32_t cos_mid = (cos_low * (256 - angle_rem) + cos_high * angle_rem) >> 8;\n\n            line_dsc.color = line_color;\n            line_dsc.width = line_width;\n            /*Use the interpolated angle to get the outer x and y coordinates.\n             *Draw a little bit longer lines to be sure the mask will clip them correctly*/\n            lv_point_t p_outer;\n            p_outer.x = (int32_t)(((int32_t)cos_mid * (r_out + line_width) + 127) >> (LV_TRIGO_SHIFT)) + p_center.x;\n            p_outer.y = (int32_t)(((int32_t)sin_mid * (r_out + line_width) + 127) >> (LV_TRIGO_SHIFT)) + p_center.y;\n\n            part_draw_dsc.p1 = &p_outer;\n            part_draw_dsc.p1 = &p_center;\n            part_draw_dsc.id = i;\n            part_draw_dsc.label_dsc = &label_dsc;\n\n            /*Draw the text*/\n            if(major) {\n                lv_draw_mask_remove_id(outer_mask_id);\n                uint32_t r_text = r_in_major - scale->label_gap;\n                lv_point_t p;\n                p.x = (int32_t)((int32_t)((int32_t)cos_mid * r_text + 127) >> LV_TRIGO_SHIFT) + p_center.x;\n                p.y = (int32_t)((int32_t)((int32_t)sin_mid * r_text + 127) >> LV_TRIGO_SHIFT) + p_center.y;\n\n                lv_draw_label_dsc_t label_dsc_tmp;\n                lv_memcpy(&label_dsc_tmp, &label_dsc, sizeof(label_dsc_tmp));\n\n                part_draw_dsc.label_dsc = &label_dsc_tmp;\n                char buf[16];\n\n                lv_snprintf(buf, sizeof(buf), \"%\" LV_PRId32, value_of_line);\n                part_draw_dsc.text = buf;\n\n                lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n\n                lv_point_t label_size;\n                lv_txt_get_size(&label_size, part_draw_dsc.text, label_dsc.font, label_dsc.letter_space, label_dsc.line_space,\n                                LV_COORD_MAX, LV_TEXT_FLAG_NONE);\n\n                lv_area_t label_cord;\n                label_cord.x1 = p.x - label_size.x / 2;\n                label_cord.y1 = p.y - label_size.y / 2;\n                label_cord.x2 = label_cord.x1 + label_size.x;\n                label_cord.y2 = label_cord.y1 + label_size.y;\n\n                lv_draw_label(&label_cord, clip_area, &label_dsc, part_draw_dsc.text, NULL);\n\n                outer_mask_id = lv_draw_mask_add(&outer_mask, NULL);\n            }\n            else {\n                part_draw_dsc.label_dsc = NULL;\n                part_draw_dsc.text = NULL;\n                lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n            }\n\n            inner_act_mask_id = lv_draw_mask_add(major ? &inner_major_mask : &inner_minor_mask, NULL);\n            lv_draw_line(&p_outer, &p_center, clip_area, &line_dsc);\n            lv_draw_mask_remove_id(inner_act_mask_id);\n            lv_event_send(obj, LV_EVENT_DRAW_MAIN_END, &part_draw_dsc);\n\n            line_dsc.color = line_color_ori;\n            line_dsc.width = line_width_ori;\n\n        }\n        lv_draw_mask_free_param(&inner_minor_mask);\n        lv_draw_mask_free_param(&inner_major_mask);\n        lv_draw_mask_free_param(&outer_mask);\n        lv_draw_mask_remove_id(outer_mask_id);\n    }\n}"}, "draw_needles": {"type": "Function", "def": "static void draw_needles(lv_obj_t * obj, const lv_area_t * clip_area, const lv_area_t * scale_area)", "sline": 562, "body": "{\n    lv_meter_t * meter = (lv_meter_t *)obj;\n\n    lv_coord_t r_edge = lv_area_get_width(scale_area) / 2;\n    lv_point_t scale_center;\n    scale_center.x = scale_area->x1 + r_edge;\n    scale_center.y = scale_area->y1 + r_edge;\n\n    lv_draw_line_dsc_t line_dsc;\n    lv_draw_line_dsc_init(&line_dsc);\n    lv_obj_init_draw_line_dsc(obj, LV_PART_ITEMS, &line_dsc);\n\n    lv_draw_img_dsc_t img_dsc;\n    lv_draw_img_dsc_init(&img_dsc);\n    lv_obj_init_draw_img_dsc(obj, LV_PART_ITEMS, &img_dsc);\n    lv_opa_t opa_main = lv_obj_get_style_opa(obj, LV_PART_MAIN);\n\n    lv_obj_draw_part_dsc_t part_draw_dsc;\n    lv_obj_draw_dsc_init(&part_draw_dsc, clip_area);\n    part_draw_dsc.class_p = MY_CLASS;\n    part_draw_dsc.p1 = &scale_center;\n\n    lv_meter_indicator_t * indic;\n    _LV_LL_READ_BACK(&meter->indicator_ll, indic) {\n        lv_meter_scale_t * scale = indic->scale;\n        part_draw_dsc.sub_part_ptr = indic;\n\n        if(indic->type == LV_METER_INDICATOR_TYPE_NEEDLE_LINE) {\n            int32_t angle = lv_map(indic->end_value, scale->min, scale->max, scale->rotation, scale->rotation + scale->angle_range);\n            lv_coord_t r_out = r_edge + scale->r_mod + indic->type_data.needle_line.r_mod;\n            lv_point_t p_end;\n            p_end.y = (lv_trigo_sin(angle) * (r_out)) / LV_TRIGO_SIN_MAX + scale_center.y;\n            p_end.x = (lv_trigo_cos(angle) * (r_out)) / LV_TRIGO_SIN_MAX + scale_center.x;\n            line_dsc.color = indic->type_data.needle_line.color;\n            line_dsc.width = indic->type_data.needle_line.width;\n            line_dsc.opa = indic->opa > LV_OPA_MAX ? opa_main : (opa_main * indic->opa) >> 8;\n\n            part_draw_dsc.id = LV_METER_DRAW_PART_NEEDLE_LINE;\n            part_draw_dsc.line_dsc = &line_dsc;\n            part_draw_dsc.p2 = &p_end;\n\n            lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n            lv_draw_line(&scale_center, &p_end, clip_area, &line_dsc);\n            lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n        }\n        else if(indic->type == LV_METER_INDICATOR_TYPE_NEEDLE_IMG) {\n            if(indic->type_data.needle_img.src == NULL) continue;\n\n            int32_t angle = lv_map(indic->end_value, scale->min, scale->max, scale->rotation, scale->rotation + scale->angle_range);\n            lv_img_header_t info;\n            lv_img_decoder_get_info(indic->type_data.needle_img.src, &info);\n            lv_area_t a;\n            a.x1 = scale_center.x - indic->type_data.needle_img.pivot.x;\n            a.y1 = scale_center.y - indic->type_data.needle_img.pivot.y;\n            a.x2 = a.x1 + info.w - 1;\n            a.y2 = a.y1 + info.h - 1;\n\n            img_dsc.opa = indic->opa > LV_OPA_MAX ? opa_main : (opa_main * indic->opa) >> 8;\n            img_dsc.pivot.x = indic->type_data.needle_img.pivot.x;\n            img_dsc.pivot.y = indic->type_data.needle_img.pivot.y;\n            angle = angle * 10;\n            if(angle > 3600) angle -= 3600;\n            img_dsc.angle = angle;\n\n            part_draw_dsc.img_dsc = &img_dsc;\n\n            lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n            lv_draw_img(&a, clip_area, indic->type_data.needle_img.src, &img_dsc);\n            lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n        }\n    }\n}"}, "inv_arc": {"type": "Function", "def": "static void inv_arc(lv_obj_t * obj, lv_meter_indicator_t * indic, int32_t old_value, int32_t new_value)", "sline": 636, "body": "{\n    bool rounded = lv_obj_get_style_arc_rounded(obj, LV_PART_ITEMS);\n\n    lv_area_t scale_area;\n    lv_obj_get_content_coords(obj, &scale_area);\n\n    lv_coord_t r_out = lv_area_get_width(&scale_area) / 2;\n    lv_point_t scale_center;\n    scale_center.x = scale_area.x1 + r_out;\n    scale_center.y = scale_area.y1 + r_out;\n\n    r_out += indic->type_data.arc.r_mod;\n\n    lv_meter_scale_t * scale = indic->scale;\n\n    int32_t start_angle = lv_map(old_value, scale->min, scale->max, scale->rotation, scale->angle_range + scale->rotation);\n    int32_t end_angle = lv_map(new_value, scale->min, scale->max, scale->rotation, scale->angle_range + scale->rotation);\n\n    lv_area_t a;\n    lv_draw_arc_get_area(scale_center.x, scale_center.y, r_out, LV_MIN(start_angle, end_angle), LV_MAX(start_angle,\n                                                                                                       end_angle), indic->type_data.arc.width, rounded, &a);\n    lv_obj_invalidate_area(obj, &a);\n}"}, "inv_line": {"type": "Function", "def": "static void inv_line(lv_obj_t * obj, lv_meter_indicator_t * indic, int32_t value)", "sline": 662, "body": "{\n    lv_area_t scale_area;\n    lv_obj_get_content_coords(obj, &scale_area);\n\n    lv_coord_t r_out = lv_area_get_width(&scale_area) / 2;\n    lv_point_t scale_center;\n    scale_center.x = scale_area.x1 + r_out;\n    scale_center.y = scale_area.y1 + r_out;\n\n    lv_meter_scale_t * scale = indic->scale;\n\n    if(indic->type == LV_METER_INDICATOR_TYPE_NEEDLE_LINE) {\n        int32_t angle = lv_map(value, scale->min, scale->max, scale->rotation, scale->rotation + scale->angle_range);\n        r_out += scale->r_mod + indic->type_data.needle_line.r_mod;\n        lv_point_t p_end;\n        p_end.y = (lv_trigo_sin(angle) * (r_out)) / LV_TRIGO_SIN_MAX + scale_center.y;\n        p_end.x = (lv_trigo_cos(angle) * (r_out)) / LV_TRIGO_SIN_MAX + scale_center.x;\n\n        lv_area_t a;\n        a.x1 = LV_MIN(scale_center.x, p_end.x) - indic->type_data.needle_line.width - 2;\n        a.y1 = LV_MIN(scale_center.y, p_end.y) - indic->type_data.needle_line.width - 2;\n        a.x2 = LV_MAX(scale_center.x, p_end.x) + indic->type_data.needle_line.width + 2;\n        a.y2 = LV_MAX(scale_center.y, p_end.y) + indic->type_data.needle_line.width + 2;\n\n        lv_obj_invalidate_area(obj, &a);\n    }\n    else if(indic->type == LV_METER_INDICATOR_TYPE_NEEDLE_IMG) {\n        int32_t angle = lv_map(value, scale->min, scale->max, scale->rotation, scale->rotation + scale->angle_range);\n        lv_img_header_t info;\n        lv_img_decoder_get_info(indic->type_data.needle_img.src, &info);\n\n        angle = angle * 10;\n        if(angle > 3600) angle -= 3600;\n\n        scale_center.x -= indic->type_data.needle_img.pivot.x;\n        scale_center.y -= indic->type_data.needle_img.pivot.y;\n        lv_area_t a;\n        _lv_img_buf_get_transformed_area(&a, info.w, info.h, angle, LV_IMG_ZOOM_NONE, &indic->type_data.needle_img.pivot);\n        a.x1 += scale_center.x - 2;\n        a.y1 += scale_center.y - 2;\n        a.x2 += scale_center.x + 2;\n        a.y2 += scale_center.y + 2;\n\n        lv_obj_invalidate_area(obj, &a);\n    }\n}"}, "lv_meter_class": {"type": "Variable", "def": "const lv_obj_class_t lv_meter_class = {\n    .constructor_cb = lv_meter_constructor,\n    .destructor_cb = lv_meter_destructor,\n    .event_cb = lv_meter_event,\n    .instance_size = sizeof(lv_meter_t),\n    .base_class = &lv_obj_class\n}", "sline": 38}, "lv_meter_create": {"type": "Function", "def": "lv_obj_t * lv_meter_create(lv_obj_t * parent)", "sline": 54, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_meter_add_scale": {"type": "Function", "def": "lv_meter_scale_t * lv_meter_add_scale(lv_obj_t * obj)", "sline": 66, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_meter_t * meter = (lv_meter_t *)obj;\n\n    lv_meter_scale_t * scale = _lv_ll_ins_head(&meter->scale_ll);\n    LV_ASSERT_MALLOC(scale);\n    lv_memset_00(scale, sizeof(lv_meter_scale_t));\n\n    scale->angle_range = 270;\n    scale->rotation = 90 + (360 - scale->angle_range) / 2;\n    scale->min = 0;\n    scale->max = 100;\n    scale->tick_cnt = 6;\n    scale->tick_length = 8;\n    scale->tick_width = 2;\n    scale->label_gap = 2;\n\n    return scale;\n}"}, "lv_meter_set_scale_ticks": {"type": "Function", "def": "void lv_meter_set_scale_ticks(lv_obj_t * obj, lv_meter_scale_t * scale, uint16_t cnt, uint16_t width, uint16_t len,\n                              lv_color_t color)", "sline": 87, "body": "{\n    scale->tick_cnt = cnt;\n    scale->tick_width = width;\n    scale->tick_length = len;\n    scale->tick_color = color;\n    lv_obj_invalidate(obj);\n}"}, "lv_meter_set_scale_major_ticks": {"type": "Function", "def": "void lv_meter_set_scale_major_ticks(lv_obj_t * obj, lv_meter_scale_t * scale, uint16_t nth, uint16_t width,\n                                    uint16_t len, lv_color_t color, int16_t label_gap)", "sline": 97, "body": "{\n    scale->tick_major_nth = nth;\n    scale->tick_major_width = width;\n    scale->tick_major_length = len;\n    scale->tick_major_color = color;\n    scale->label_gap = label_gap;\n    lv_obj_invalidate(obj);\n}"}, "lv_meter_set_scale_range": {"type": "Function", "def": "void lv_meter_set_scale_range(lv_obj_t * obj, lv_meter_scale_t * scale, int32_t min, int32_t max, uint32_t angle_range,\n                              uint32_t rotation)", "sline": 108, "body": "{\n    scale->min = min;\n    scale->max = max;\n    scale->angle_range = angle_range;\n    scale->rotation = rotation;\n    lv_obj_invalidate(obj);\n}"}, "lv_meter_add_needle_line": {"type": "Function", "def": "lv_meter_indicator_t * lv_meter_add_needle_line(lv_obj_t * obj, lv_meter_scale_t * scale, uint16_t width,\n                                                lv_color_t color, int16_t r_mod)", "sline": 122, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_meter_t * meter = (lv_meter_t *)obj;\n    lv_meter_indicator_t * indic = _lv_ll_ins_head(&meter->indicator_ll);\n    LV_ASSERT_MALLOC(indic);\n    lv_memset_00(indic, sizeof(lv_meter_indicator_t));\n    indic->scale = scale;\n    indic->opa = LV_OPA_COVER;\n\n    indic->type = LV_METER_INDICATOR_TYPE_NEEDLE_LINE;\n    indic->type_data.needle_line.width = width;\n    indic->type_data.needle_line.color = color;\n    indic->type_data.needle_line.r_mod = r_mod;\n    lv_obj_invalidate(obj);\n\n    return indic;\n}"}, "lv_meter_add_needle_img": {"type": "Function", "def": "lv_meter_indicator_t * lv_meter_add_needle_img(lv_obj_t * obj, lv_meter_scale_t * scale, const void * src,\n                                               lv_coord_t pivot_x, lv_coord_t pivot_y)", "sline": 142, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_meter_t * meter = (lv_meter_t *)obj;\n    lv_meter_indicator_t * indic = _lv_ll_ins_head(&meter->indicator_ll);\n    LV_ASSERT_MALLOC(indic);\n    lv_memset_00(indic, sizeof(lv_meter_indicator_t));\n    indic->scale = scale;\n    indic->opa = LV_OPA_COVER;\n\n    indic->type = LV_METER_INDICATOR_TYPE_NEEDLE_IMG;\n    indic->type_data.needle_img.src = src;\n    indic->type_data.needle_img.pivot.x = pivot_x;\n    indic->type_data.needle_img.pivot.y = pivot_y;\n    lv_obj_invalidate(obj);\n\n    return indic;\n}"}, "lv_meter_add_arc": {"type": "Function", "def": "lv_meter_indicator_t * lv_meter_add_arc(lv_obj_t * obj, lv_meter_scale_t * scale, uint16_t width, lv_color_t color,\n                                        int16_t r_mod)", "sline": 162, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_meter_t * meter = (lv_meter_t *)obj;\n    lv_meter_indicator_t * indic = _lv_ll_ins_head(&meter->indicator_ll);\n    LV_ASSERT_MALLOC(indic);\n    lv_memset_00(indic, sizeof(lv_meter_indicator_t));\n    indic->scale = scale;\n    indic->opa = LV_OPA_COVER;\n\n    indic->type = LV_METER_INDICATOR_TYPE_ARC;\n    indic->type_data.arc.width = width;\n    indic->type_data.arc.color = color;\n    indic->type_data.arc.r_mod = r_mod;\n\n    lv_obj_invalidate(obj);\n    return indic;\n}"}, "lv_meter_add_scale_lines": {"type": "Function", "def": "lv_meter_indicator_t * lv_meter_add_scale_lines(lv_obj_t * obj, lv_meter_scale_t * scale, lv_color_t color_start,\n                                                lv_color_t color_end, bool local, int16_t width_mod)", "sline": 182, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_meter_t * meter = (lv_meter_t *)obj;\n    lv_meter_indicator_t * indic = _lv_ll_ins_head(&meter->indicator_ll);\n    LV_ASSERT_MALLOC(indic);\n    lv_memset_00(indic, sizeof(lv_meter_indicator_t));\n    indic->scale = scale;\n    indic->opa = LV_OPA_COVER;\n\n    indic->type = LV_METER_INDICATOR_TYPE_SCALE_LINES;\n    indic->type_data.scale_lines.color_start = color_start;\n    indic->type_data.scale_lines.color_end = color_end;\n    indic->type_data.scale_lines.local_grad = local;\n    indic->type_data.scale_lines.width_mod = width_mod;\n\n    lv_obj_invalidate(obj);\n    return indic;\n}"}, "lv_meter_set_indicator_value": {"type": "Function", "def": "void lv_meter_set_indicator_value(lv_obj_t * obj, lv_meter_indicator_t * indic, int32_t value)", "sline": 207, "body": "{\n    int32_t old_start = indic->start_value;\n    int32_t old_end = indic->end_value;\n    indic->start_value = value;\n    indic->end_value = value;\n\n    if(indic->type == LV_METER_INDICATOR_TYPE_ARC) {\n        inv_arc(obj, indic, old_start, value);\n        inv_arc(obj, indic, old_end, value);\n    }\n    else if(indic->type == LV_METER_INDICATOR_TYPE_NEEDLE_IMG || indic->type == LV_METER_INDICATOR_TYPE_NEEDLE_LINE) {\n        inv_line(obj, indic, old_start);\n        inv_line(obj, indic, old_end);\n        inv_line(obj, indic, value);\n    }\n    else {\n        lv_obj_invalidate(obj);\n    }\n}"}, "lv_meter_set_indicator_start_value": {"type": "Function", "def": "void lv_meter_set_indicator_start_value(lv_obj_t * obj, lv_meter_indicator_t * indic, int32_t value)", "sline": 228, "body": "{\n    int32_t old_value = indic->start_value;\n    indic->start_value = value;\n\n    if(indic->type == LV_METER_INDICATOR_TYPE_ARC) {\n        inv_arc(obj, indic, old_value, value);\n    }\n    else if(indic->type == LV_METER_INDICATOR_TYPE_NEEDLE_IMG || indic->type == LV_METER_INDICATOR_TYPE_NEEDLE_LINE) {\n        inv_line(obj, indic, old_value);\n        inv_line(obj, indic, value);\n    }\n    else {\n        lv_obj_invalidate(obj);\n    }\n}"}, "lv_meter_set_indicator_end_value": {"type": "Function", "def": "void lv_meter_set_indicator_end_value(lv_obj_t * obj, lv_meter_indicator_t * indic, int32_t value)", "sline": 245, "body": "{\n    int32_t old_value = indic->end_value;\n    indic->end_value = value;\n\n    if(indic->type == LV_METER_INDICATOR_TYPE_ARC) {\n        inv_arc(obj, indic, old_value, value);\n    }\n    else if(indic->type == LV_METER_INDICATOR_TYPE_NEEDLE_IMG || indic->type == LV_METER_INDICATOR_TYPE_NEEDLE_LINE) {\n        inv_line(obj, indic, old_value);\n        inv_line(obj, indic, value);\n    }\n    else {\n        lv_obj_invalidate(obj);\n    }\n}"}, "carbit_updater/lvgl/src/extra/widgets/meter/lv_meter.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/meter/lv_meter.c"}}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_texture_cache.c": {"lv_conf_internal": {"type": "Variable", "def": "#include ../../lv_conf_internal.h", "sline": 10}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_texture_cache.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_texture_cache.c"}}, "carbit_updater/lvgl/tests/src/lv_test_indev.c": {"carbit_updater/lvgl/tests/src/lv_test_indev.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/tests/src/lv_test_indev.c"}}, "carbit_updater/lv_drivers/display/sunximem.c": {"sunximem": {"type": "Variable", "def": "#include sunximem.h", "sline": 9, "include": ["carbit_updater/lv_drivers/display/sunximem.h", null]}, "carbit_updater/lv_drivers/display/sunximem.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/sunximem.c"}}, "carbit_updater/lvgl/src/extra/themes/mono/lv_theme_mono.c": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 9}, "lv_theme_mono": {"type": "Variable", "def": "#include lv_theme_mono.h", "sline": 13, "include": ["carbit_updater/lvgl/src/extra/themes/mono/lv_theme_mono.h", null]}, "lv_gc": {"type": "Variable", "def": "#include ../../../misc/lv_gc.h", "sline": 14}, "my_theme_styles_t.scr": {"type": "Variable", "def": "lv_style_t scr", "sline": 34, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.card": {"type": "Variable", "def": "lv_style_t card", "sline": 35, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.scrollbar": {"type": "Variable", "def": "lv_style_t scrollbar", "sline": 36, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.btn": {"type": "Variable", "def": "lv_style_t btn", "sline": 37, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.pr": {"type": "Variable", "def": "lv_style_t pr", "sline": 38, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.inv": {"type": "Variable", "def": "lv_style_t inv", "sline": 39, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.disabled": {"type": "Variable", "def": "lv_style_t disabled", "sline": 40, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.focus": {"type": "Variable", "def": "lv_style_t focus", "sline": 41, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.edit": {"type": "Variable", "def": "lv_style_t edit", "sline": 42, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.pad_gap": {"type": "Variable", "def": "lv_style_t pad_gap", "sline": 43, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.pad_zero": {"type": "Variable", "def": "lv_style_t pad_zero", "sline": 44, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.no_radius": {"type": "Variable", "def": "lv_style_t no_radius", "sline": 45, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.radius_circle": {"type": "Variable", "def": "lv_style_t radius_circle", "sline": 46, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.large_border": {"type": "Variable", "def": "lv_style_t large_border", "sline": 47, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.large_line_space": {"type": "Variable", "def": "lv_style_t large_line_space", "sline": 48, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.underline": {"type": "Variable", "def": "lv_style_t underline", "sline": 49, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.ta_cursor": {"type": "Variable", "def": "lv_style_t ta_cursor", "sline": 51, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t": {"type": "Variable", "def": "typedef struct {\n    lv_style_t scr;\n    lv_style_t card;\n    lv_style_t scrollbar;\n    lv_style_t btn;\n    lv_style_t pr;\n    lv_style_t inv;\n    lv_style_t disabled;\n    lv_style_t focus;\n    lv_style_t edit;\n    lv_style_t pad_gap;\n    lv_style_t pad_zero;\n    lv_style_t no_radius;\n    lv_style_t radius_circle;\n    lv_style_t large_border;\n    lv_style_t large_line_space;\n    lv_style_t underline;\n#if LV_USE_TEXTAREA\n    lv_style_t ta_cursor;\n#endif\n} my_theme_styles_t", "sline": 53, "docstring": "/**********************"}, "style_init_reset": {"type": "Function", "def": "static void style_init_reset(lv_style_t * style)", "sline": 488, "body": "{\n    if(inited) lv_style_reset(style);\n    else lv_style_init(style);\n}"}, "theme_apply": {"type": "Function", "def": "static void theme_apply(lv_theme_t * th, lv_obj_t * obj)", "sline": 194, "body": "{\n    LV_UNUSED(th);\n\n    if(lv_obj_get_parent(obj) == NULL) {\n        lv_obj_add_style(obj, &styles->scr, 0);\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n        return;\n    }\n\n    if(lv_obj_check_type(obj, &lv_obj_class)) {\n#if LV_USE_TABVIEW\n        lv_obj_t * parent = lv_obj_get_parent(obj);\n        /*Tabview content area*/\n        if(lv_obj_check_type(parent, &lv_tabview_class)) {\n            return;\n        }\n        /*Tabview pages*/\n        else if(lv_obj_check_type(lv_obj_get_parent(parent), &lv_tabview_class)) {\n            lv_obj_add_style(obj, &styles->card, 0);\n            lv_obj_add_style(obj, &styles->no_radius, 0);\n            lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n            return;\n        }\n#endif\n\n#if LV_USE_WIN\n        /*Header*/\n        if(lv_obj_get_index(obj) == 0 && lv_obj_check_type(lv_obj_get_parent(obj), &lv_win_class)) {\n            lv_obj_add_style(obj, &styles->card, 0);\n            lv_obj_add_style(obj, &styles->no_radius, 0);\n            return;\n        }\n        /*Content*/\n        else if(lv_obj_get_index(obj) == 1 && lv_obj_check_type(lv_obj_get_parent(obj), &lv_win_class)) {\n            lv_obj_add_style(obj, &styles->card, 0);\n            lv_obj_add_style(obj, &styles->no_radius, 0);\n            lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n            return;\n        }\n#endif\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n    }\n#if LV_USE_BTN\n    else if(lv_obj_check_type(obj, &lv_btn_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->pr, LV_STATE_PRESSED);\n        lv_obj_add_style(obj, &styles->inv, LV_STATE_CHECKED);\n        lv_obj_add_style(obj, &styles->disabled, LV_STATE_DISABLED);\n        lv_obj_add_style(obj, &styles->focus, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->edit, LV_STATE_EDITED);\n    }\n#endif\n\n#if LV_USE_BTNMATRIX\n    else if(lv_obj_check_type(obj, &lv_btnmatrix_class)) {\n#if LV_USE_MSGBOX\n        if(lv_obj_check_type(lv_obj_get_parent(obj), &lv_msgbox_class)) {\n            lv_obj_add_style(obj, &styles->pad_gap, 0);\n            lv_obj_add_style(obj, &styles->card, LV_PART_ITEMS);\n            lv_obj_add_style(obj, &styles->pr, LV_PART_ITEMS | LV_STATE_PRESSED);\n            lv_obj_add_style(obj, &styles->disabled, LV_PART_ITEMS | LV_STATE_DISABLED);\n            lv_obj_add_style(obj, &styles->underline, LV_PART_ITEMS | LV_STATE_FOCUS_KEY);\n            lv_obj_add_style(obj, &styles->large_border, LV_PART_ITEMS | LV_STATE_FOCUS_KEY);\n            return;\n        }\n#endif\n#if LV_USE_TABVIEW\n        if(lv_obj_check_type(lv_obj_get_parent(obj), &lv_tabview_class)) {\n            lv_obj_add_style(obj, &styles->pad_gap, 0);\n            lv_obj_add_style(obj, &styles->card, LV_PART_ITEMS);\n            lv_obj_add_style(obj, &styles->pr, LV_PART_ITEMS | LV_STATE_PRESSED);\n            lv_obj_add_style(obj, &styles->inv, LV_PART_ITEMS | LV_STATE_CHECKED);\n            lv_obj_add_style(obj, &styles->disabled, LV_PART_ITEMS | LV_STATE_DISABLED);\n            lv_obj_add_style(obj, &styles->focus, LV_STATE_FOCUS_KEY);\n            lv_obj_add_style(obj, &styles->underline, LV_PART_ITEMS | LV_STATE_FOCUS_KEY);\n            lv_obj_add_style(obj, &styles->large_border, LV_PART_ITEMS | LV_STATE_FOCUS_KEY);\n            return;\n        }\n#endif\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->focus, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->card, LV_PART_ITEMS);\n        lv_obj_add_style(obj, &styles->pr, LV_PART_ITEMS | LV_STATE_PRESSED);\n        lv_obj_add_style(obj, &styles->inv, LV_PART_ITEMS | LV_STATE_CHECKED);\n        lv_obj_add_style(obj, &styles->disabled, LV_PART_ITEMS | LV_STATE_DISABLED);\n        lv_obj_add_style(obj, &styles->underline, LV_PART_ITEMS | LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->large_border, LV_PART_ITEMS | LV_STATE_FOCUS_KEY);\n    }\n#endif\n\n#if LV_USE_BAR\n    else if(lv_obj_check_type(obj, &lv_bar_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->pad_zero, 0);\n        lv_obj_add_style(obj, &styles->inv, LV_PART_INDICATOR);\n        lv_obj_add_style(obj, &styles->focus, LV_STATE_FOCUS_KEY);\n    }\n#endif\n\n#if LV_USE_SLIDER\n    else if(lv_obj_check_type(obj, &lv_slider_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->pad_zero, 0);\n        lv_obj_add_style(obj, &styles->inv, LV_PART_INDICATOR);\n        lv_obj_add_style(obj, &styles->card, LV_PART_KNOB);\n        lv_obj_add_style(obj, &styles->radius_circle, LV_PART_KNOB);\n        lv_obj_add_style(obj, &styles->focus, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->edit, LV_STATE_EDITED);\n    }\n#endif\n\n#if LV_USE_TABLE\n    else if(lv_obj_check_type(obj, &lv_table_class)) {\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n        lv_obj_add_style(obj, &styles->card, LV_PART_ITEMS);\n        lv_obj_add_style(obj, &styles->no_radius, LV_PART_ITEMS);\n        lv_obj_add_style(obj, &styles->pr, LV_PART_ITEMS | LV_STATE_PRESSED);\n        lv_obj_add_style(obj, &styles->focus, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->inv, LV_PART_ITEMS | LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->edit, LV_STATE_EDITED);\n    }\n#endif\n\n#if LV_USE_CHECKBOX\n    else if(lv_obj_check_type(obj, &lv_checkbox_class)) {\n        lv_obj_add_style(obj, &styles->pad_gap, LV_PART_MAIN);\n        lv_obj_add_style(obj, &styles->card, LV_PART_INDICATOR);\n        lv_obj_add_style(obj, &styles->disabled, LV_PART_INDICATOR | LV_STATE_DISABLED);\n        lv_obj_add_style(obj, &styles->inv, LV_PART_INDICATOR | LV_STATE_CHECKED);\n        lv_obj_add_style(obj, &styles->pr, LV_PART_INDICATOR | LV_STATE_PRESSED);\n        lv_obj_add_style(obj, &styles->focus, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->edit, LV_STATE_EDITED);\n    }\n#endif\n\n#if LV_USE_SWITCH\n    else if(lv_obj_check_type(obj, &lv_switch_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->radius_circle, 0);\n        lv_obj_add_style(obj, &styles->pad_zero, 0);\n        lv_obj_add_style(obj, &styles->inv, LV_PART_INDICATOR);\n        lv_obj_add_style(obj, &styles->radius_circle, LV_PART_INDICATOR);\n        lv_obj_add_style(obj, &styles->card, LV_PART_KNOB);\n        lv_obj_add_style(obj, &styles->radius_circle, LV_PART_KNOB);\n        lv_obj_add_style(obj, &styles->pad_zero, LV_PART_KNOB);\n        lv_obj_add_style(obj, &styles->focus, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->edit, LV_STATE_EDITED);\n    }\n#endif\n\n#if LV_USE_CHART\n    else if(lv_obj_check_type(obj, &lv_chart_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n        lv_obj_add_style(obj, &styles->card, LV_PART_ITEMS);\n        lv_obj_add_style(obj, &styles->card, LV_PART_TICKS);\n        lv_obj_add_style(obj, &styles->card, LV_PART_CURSOR);\n        lv_obj_add_style(obj, &styles->focus, LV_STATE_FOCUS_KEY);\n    }\n#endif\n\n#if LV_USE_ROLLER\n    else if(lv_obj_check_type(obj, &lv_roller_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->large_line_space, 0);\n        lv_obj_add_style(obj, &styles->inv, LV_PART_SELECTED);\n        lv_obj_add_style(obj, &styles->focus, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->edit, LV_STATE_EDITED);\n    }\n#endif\n\n#if LV_USE_DROPDOWN\n    else if(lv_obj_check_type(obj, &lv_dropdown_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->pr, LV_STATE_PRESSED);\n        lv_obj_add_style(obj, &styles->focus, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->edit, LV_STATE_EDITED);\n    }\n    else if(lv_obj_check_type(obj, &lv_dropdownlist_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->large_line_space, 0);\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n        lv_obj_add_style(obj, &styles->inv, LV_PART_SELECTED | LV_STATE_CHECKED);\n        lv_obj_add_style(obj, &styles->pr, LV_PART_SELECTED | LV_STATE_PRESSED);\n        lv_obj_add_style(obj, &styles->focus, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->edit, LV_STATE_EDITED);\n    }\n#endif\n\n#if LV_USE_ARC\n    else if(lv_obj_check_type(obj, &lv_arc_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->inv, LV_PART_INDICATOR);\n        lv_obj_add_style(obj, &styles->pad_zero, LV_PART_INDICATOR);\n        lv_obj_add_style(obj, &styles->card, LV_PART_KNOB);\n        lv_obj_add_style(obj, &styles->radius_circle, LV_PART_KNOB);\n        lv_obj_add_style(obj, &styles->focus, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->edit, LV_STATE_EDITED);\n    }\n#endif\n\n#if LV_USE_METER\n    else if(lv_obj_check_type(obj, &lv_meter_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n    }\n#endif\n\n#if LV_USE_TEXTAREA\n    else if(lv_obj_check_type(obj, &lv_textarea_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n        lv_obj_add_style(obj, &styles->ta_cursor, LV_PART_CURSOR | LV_STATE_FOCUSED);\n        lv_obj_add_style(obj, &styles->focus, LV_STATE_FOCUSED);\n        lv_obj_add_style(obj, &styles->edit, LV_STATE_EDITED);\n    }\n#endif\n\n#if LV_USE_CALENDAR\n    else if(lv_obj_check_type(obj, &lv_calendar_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->no_radius, 0);\n        lv_obj_add_style(obj, &styles->pr, LV_PART_ITEMS | LV_STATE_PRESSED);\n        lv_obj_add_style(obj, &styles->disabled, LV_PART_ITEMS | LV_STATE_DISABLED);\n        lv_obj_add_style(obj, &styles->focus, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->edit, LV_STATE_EDITED);\n        lv_obj_add_style(obj, &styles->large_border, LV_PART_ITEMS | LV_STATE_FOCUS_KEY);\n    }\n#endif\n\n#if LV_USE_KEYBOARD\n    else if(lv_obj_check_type(obj, &lv_keyboard_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->card, LV_PART_ITEMS);\n        lv_obj_add_style(obj, &styles->pr, LV_PART_ITEMS | LV_STATE_PRESSED);\n        lv_obj_add_style(obj, &styles->inv, LV_PART_ITEMS | LV_STATE_CHECKED);\n        lv_obj_add_style(obj, &styles->focus, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->edit, LV_STATE_EDITED);\n        lv_obj_add_style(obj, &styles->large_border, LV_PART_ITEMS | LV_STATE_EDITED);\n    }\n#endif\n#if LV_USE_LIST\n    else if(lv_obj_check_type(obj, &lv_list_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n        return;\n    }\n    else if(lv_obj_check_type(obj, &lv_list_text_class)) {\n\n    }\n    else if(lv_obj_check_type(obj, &lv_list_btn_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->pr, LV_STATE_PRESSED);\n        lv_obj_add_style(obj, &styles->focus, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->large_border, LV_STATE_EDITED);\n\n    }\n#endif\n#if LV_USE_MSGBOX\n    else if(lv_obj_check_type(obj, &lv_msgbox_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        return;\n    }\n#endif\n#if LV_USE_SPINBOX\n    else if(lv_obj_check_type(obj, &lv_spinbox_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->inv, LV_PART_CURSOR);\n        lv_obj_add_style(obj, &styles->focus, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->edit, LV_STATE_EDITED);\n    }\n#endif\n#if LV_USE_TILEVIEW\n    else if(lv_obj_check_type(obj, &lv_tileview_class)) {\n        lv_obj_add_style(obj, &styles->scr, 0);\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n    }\n    else if(lv_obj_check_type(obj, &lv_tileview_tile_class)) {\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n    }\n#endif\n\n#if LV_USE_LED\n    else if(lv_obj_check_type(obj, &lv_led_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n    }\n#endif\n}"}, "styles": {"type": "Variable", "def": "static my_theme_styles_t * styles", "sline": 65}, "theme": {"type": "Variable", "def": "static lv_theme_t theme", "sline": 66}, "inited": {"type": "Function", "def": "static bool inited", "sline": 67}, "style_init": {"type": "Function", "def": "static void style_init(bool dark_bg, const lv_font_t * font)", "sline": 77, "body": "{\n    style_init_reset(&styles->scrollbar);\n    lv_style_set_bg_opa(&styles->scrollbar, LV_OPA_COVER);\n    lv_style_set_bg_color(&styles->scrollbar, COLOR_FG);\n    lv_style_set_width(&styles->scrollbar,  PAD_DEF);\n\n    style_init_reset(&styles->scr);\n    lv_style_set_bg_opa(&styles->scr, LV_OPA_COVER);\n    lv_style_set_bg_color(&styles->scr, COLOR_BG);\n    lv_style_set_text_color(&styles->scr, COLOR_FG);\n    lv_style_set_pad_row(&styles->scr, PAD_DEF);\n    lv_style_set_pad_column(&styles->scr, PAD_DEF);\n    lv_style_set_text_font(&styles->scr, font);\n\n    style_init_reset(&styles->card);\n    lv_style_set_bg_opa(&styles->card, LV_OPA_COVER);\n    lv_style_set_bg_color(&styles->card, COLOR_BG);\n    lv_style_set_border_color(&styles->card, COLOR_FG);\n    lv_style_set_radius(&styles->card, 2);\n    lv_style_set_border_width(&styles->card, BORDER_W_NORMAL);\n    lv_style_set_pad_all(&styles->card, PAD_DEF);\n    lv_style_set_pad_gap(&styles->card, PAD_DEF);\n    lv_style_set_text_color(&styles->card, COLOR_FG);\n    lv_style_set_line_width(&styles->card, 2);\n    lv_style_set_line_color(&styles->card, COLOR_FG);\n    lv_style_set_arc_width(&styles->card, 2);\n    lv_style_set_arc_color(&styles->card, COLOR_FG);\n    lv_style_set_outline_color(&styles->card, COLOR_FG);\n    lv_style_set_anim_time(&styles->card, 300);\n\n    style_init_reset(&styles->pr);\n    lv_style_set_border_width(&styles->pr, BORDER_W_PR);\n\n    style_init_reset(&styles->inv);\n    lv_style_set_bg_opa(&styles->inv, LV_OPA_COVER);\n    lv_style_set_bg_color(&styles->inv, COLOR_FG);\n    lv_style_set_border_color(&styles->inv, COLOR_BG);\n    lv_style_set_line_color(&styles->inv, COLOR_BG);\n    lv_style_set_arc_color(&styles->inv, COLOR_BG);\n    lv_style_set_text_color(&styles->inv, COLOR_BG);\n    lv_style_set_outline_color(&styles->inv, COLOR_BG);\n\n    style_init_reset(&styles->disabled);\n    lv_style_set_border_width(&styles->disabled, BORDER_W_DIS);\n\n    style_init_reset(&styles->focus);\n    lv_style_set_outline_width(&styles->focus, 1);\n    lv_style_set_outline_pad(&styles->focus, BORDER_W_FOCUS);\n\n    style_init_reset(&styles->edit);\n    lv_style_set_outline_width(&styles->edit, BORDER_W_EDIT);\n\n    style_init_reset(&styles->large_border);\n    lv_style_set_border_width(&styles->large_border, BORDER_W_EDIT);\n\n    style_init_reset(&styles->pad_gap);\n    lv_style_set_pad_gap(&styles->pad_gap, PAD_DEF);\n\n    style_init_reset(&styles->pad_zero);\n    lv_style_set_pad_all(&styles->pad_zero, 0);\n    lv_style_set_pad_gap(&styles->pad_zero, 0);\n\n    style_init_reset(&styles->no_radius);\n    lv_style_set_radius(&styles->no_radius, 0);\n\n    style_init_reset(&styles->radius_circle);\n    lv_style_set_radius(&styles->radius_circle, LV_RADIUS_CIRCLE);\n\n    style_init_reset(&styles->large_line_space);\n    lv_style_set_text_line_space(&styles->large_line_space, 6);\n\n    style_init_reset(&styles->underline);\n    lv_style_set_text_decor(&styles->underline, LV_TEXT_DECOR_UNDERLINE);\n\n#if LV_USE_TEXTAREA\n    style_init_reset(&styles->ta_cursor);\n    lv_style_set_border_side(&styles->ta_cursor, LV_BORDER_SIDE_LEFT);\n    lv_style_set_border_color(&styles->ta_cursor, COLOR_FG);\n    lv_style_set_border_width(&styles->ta_cursor, 2);\n    lv_style_set_bg_opa(&styles->ta_cursor, LV_OPA_TRANSP);\n    lv_style_set_anim_time(&styles->ta_cursor, 500);\n#endif\n}"}, "lv_theme_mono_init": {"type": "Function", "def": "lv_theme_t * lv_theme_mono_init(lv_disp_t * disp, bool dark_bg, const lv_font_t * font)", "sline": 167, "body": "{\n\n    /*This trick is required only to avoid the garbage collection of\n     *styles' data if LVGL is used in a binding (e.g. Micropython)\n     *In a general case styles could be in simple `static lv_style_t my_style...` variables*/\n    if(!inited) {\n        LV_GC_ROOT(_lv_theme_default_styles) = lv_mem_alloc(sizeof(my_theme_styles_t));\n        styles = (my_theme_styles_t *)LV_GC_ROOT(_lv_theme_default_styles);\n    }\n\n    theme.disp = disp;\n    theme.font_small = LV_FONT_DEFAULT;\n    theme.font_normal = LV_FONT_DEFAULT;\n    theme.font_large = LV_FONT_DEFAULT;\n    theme.apply_cb = theme_apply;\n\n    style_init(dark_bg, font);\n\n    inited = true;\n\n    if(disp == NULL || lv_disp_get_theme(disp) == &theme) lv_obj_report_style_change(NULL);\n\n    return (lv_theme_t *)&theme;\n}"}, "carbit_updater/lvgl/src/extra/themes/mono/lv_theme_mono.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/themes/mono/lv_theme_mono.c"}}, "carbit_updater/lvgl/src/extra/libs/sjpg/lv_sjpg.c": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 48}, "carbit_updater/lvgl/src/extra/libs/sjpg/lv_sjpg.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/sjpg/lv_sjpg.c"}}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_mask.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../../lv_conf_internal.h", "sline": 17}, "lv_area": {"type": "Variable", "def": "#include ../../misc/lv_area.h", "sline": 21}, "lv_color": {"type": "Variable", "def": "#include ../../misc/lv_color.h", "sline": 22}, "lv_draw_mask_dump": {"type": "Function", "def": "lv_opa_t * lv_draw_mask_dump(const lv_area_t * coords, const int16_t * ids, int16_t ids_count)", "sline": 37}, "lv_sdl_create_mask_surface": {"type": "Function", "def": "SDL_Surface * lv_sdl_create_mask_surface(lv_opa_t * pixels, lv_coord_t width, lv_coord_t height, lv_coord_t stride)", "sline": 39}, "lv_sdl_create_mask_texture": {"type": "Function", "def": "SDL_Texture * lv_sdl_create_mask_texture(SDL_Renderer * renderer, lv_opa_t * pixels, lv_coord_t width,\n                                         lv_coord_t height, lv_coord_t stride)", "sline": 41}, "lv_sdl_apply_mask_surface": {"type": "Function", "def": "SDL_Surface * lv_sdl_apply_mask_surface(const lv_area_t * coords, const int16_t * ids, int16_t ids_count)", "sline": 44}, "lv_sdl_gen_mask_texture": {"type": "Function", "def": "SDL_Texture *\nlv_sdl_gen_mask_texture(SDL_Renderer * renderer, const lv_area_t * coords, const int16_t * ids, int16_t ids_count)", "sline": 47}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_mask.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_mask.h"}}, "carbit_updater/lvgl/tests/src/test_fonts/font_1.c": {"carbit_updater/lvgl/tests/src/test_fonts/font_1.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/tests/src/test_fonts/font_1.c"}}, "carbit_updater/lvgl/tests/unity/unity_internals.h": {"carbit_updater/lvgl/tests/unity/unity_internals.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/tests/unity/unity_internals.h"}}, "carbit_updater/lvgl/src/extra/themes/mono/lv_theme_mono.h": {"lv_obj": {"type": "Variable", "def": "#include ../../../core/lv_obj.h", "sline": 16}, "lv_theme_mono_init": {"type": "Function", "def": "lv_theme_t * lv_theme_mono_init(lv_disp_t * disp, bool dark_bg, const lv_font_t * font)", "sline": 39}, "carbit_updater/lvgl/src/extra/themes/mono/lv_theme_mono.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/themes/mono/lv_theme_mono.h"}}, "carbit_updater/lvgl/src/extra/libs/freetype/lv_freetype.h": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 15}, "carbit_updater/lvgl/src/extra/libs/freetype/lv_freetype.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/freetype/lv_freetype.h"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_18.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_montserrat_18.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_18.c"}}, "carbit_updater/lvgl/src/hal/lv_hal_disp.c": {"stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 11}, "stddef": {"type": "Variable", "def": "#include stddef.h", "sline": 12}, "lv_hal": {"type": "Variable", "def": "#include lv_hal.h", "sline": 13, "include": ["carbit_updater/lvgl/src/hal/lv_hal.h", null]}, "lv_mem": {"type": "Variable", "def": "#include ../misc/lv_mem.h", "sline": 14}, "lv_gc": {"type": "Variable", "def": "#include ../misc/lv_gc.h", "sline": 15}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 16}, "lv_obj": {"type": "Variable", "def": "#include ../core/lv_obj.h", "sline": 17}, "lv_refr": {"type": "Variable", "def": "#include ../core/lv_refr.h", "sline": 18}, "lv_theme": {"type": "Variable", "def": "#include ../core/lv_theme.h", "sline": 19}, "lv_theme_default": {"type": "Variable", "def": "#include ../extra/themes/default/lv_theme_default.h", "sline": 21}, "invalidate_layout_cb": {"type": "Function", "def": "static lv_obj_tree_walk_res_t invalidate_layout_cb(lv_obj_t * obj, void * user_data)", "sline": 559, "body": "{\n    LV_UNUSED(user_data);\n    lv_obj_mark_layout_as_dirty(obj);\n    return LV_OBJ_TREE_WALK_NEXT;\n}"}, "set_px_true_color_alpha": {"type": "Function", "def": "static void set_px_true_color_alpha(lv_disp_drv_t * disp_drv, uint8_t * buf, lv_coord_t buf_w, lv_coord_t x,\n                                    lv_coord_t y,\n                                    lv_color_t color, lv_opa_t opa)", "sline": 636, "body": "{\n    (void) disp_drv; /*Unused*/\n\n    if(opa <= LV_OPA_MIN) return;\n    lv_img_dsc_t d;\n    d.data = buf;\n    d.header.always_zero = 0;\n    d.header.h = 1;    /*Doesn't matter*/;\n    d.header.w = buf_w;\n    d.header.cf = LV_IMG_CF_TRUE_COLOR_ALPHA;\n\n    lv_color_t bg_color = lv_img_buf_get_px_color(&d, x, y, lv_color_black());\n    lv_opa_t bg_opa = lv_img_buf_get_px_alpha(&d, x, y);\n\n    lv_opa_t res_opa;\n    lv_color_t res_color;\n\n    lv_color_mix_with_alpha(bg_color, bg_opa, color, opa, &res_color, &res_opa);\n\n    lv_img_buf_set_px_alpha(&d, x, y, res_opa);\n    lv_img_buf_set_px_color(&d, x, y, res_color);\n}"}, "set_px_cb_alpha1": {"type": "Function", "def": "static void set_px_cb_alpha1(lv_disp_drv_t * disp_drv, uint8_t * buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,\n                             lv_color_t color, lv_opa_t opa)", "sline": 566, "body": "{\n    (void) disp_drv; /*Unused*/\n\n    if(opa <= LV_OPA_MIN) return;\n    lv_img_dsc_t d;\n    d.data = buf;\n    d.header.w = buf_w;\n    d.header.cf = LV_IMG_CF_ALPHA_1BIT;\n\n    set_px_alpha_generic(&d, x, y, color, opa);\n}"}, "set_px_cb_alpha2": {"type": "Function", "def": "static void set_px_cb_alpha2(lv_disp_drv_t * disp_drv, uint8_t * buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,\n                             lv_color_t color, lv_opa_t opa)", "sline": 580, "body": "{\n    (void) disp_drv; /*Unused*/\n\n    if(opa <= LV_OPA_MIN) return;\n    lv_img_dsc_t d;\n    d.data = buf;\n    d.header.w = buf_w;\n    d.header.cf = LV_IMG_CF_ALPHA_2BIT;\n\n    set_px_alpha_generic(&d, x, y, color, opa);\n}"}, "set_px_cb_alpha4": {"type": "Function", "def": "static void set_px_cb_alpha4(lv_disp_drv_t * disp_drv, uint8_t * buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,\n                             lv_color_t color, lv_opa_t opa)", "sline": 594, "body": "{\n    (void) disp_drv; /*Unused*/\n\n    if(opa <= LV_OPA_MIN) return;\n    lv_img_dsc_t d;\n    d.data = buf;\n    d.header.w = buf_w;\n    d.header.cf = LV_IMG_CF_ALPHA_4BIT;\n\n    set_px_alpha_generic(&d, x, y, color, opa);\n}"}, "set_px_cb_alpha8": {"type": "Function", "def": "static void set_px_cb_alpha8(lv_disp_drv_t * disp_drv, uint8_t * buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,\n                             lv_color_t color, lv_opa_t opa)", "sline": 608, "body": "{\n    (void) disp_drv; /*Unused*/\n\n    if(opa <= LV_OPA_MIN) return;\n    lv_img_dsc_t d;\n    d.data = buf;\n    d.header.w = buf_w;\n    d.header.cf = LV_IMG_CF_ALPHA_8BIT;\n\n    set_px_alpha_generic(&d, x, y, color, opa);\n}"}, "set_px_alpha_generic": {"type": "Function", "def": "static void set_px_alpha_generic(lv_img_dsc_t * d, lv_coord_t x, lv_coord_t y, lv_color_t color, lv_opa_t opa)", "sline": 622, "body": "{\n    d->header.always_zero = 0;\n    d->header.h = 1;    /*Doesn't matter*/\n\n    uint8_t br = lv_color_brightness(color);\n    if(opa < LV_OPA_MAX) {\n        uint8_t bg = lv_img_buf_get_px_alpha(d, x, y);\n        br = (uint16_t)((uint16_t)br * opa + (bg * (255 - opa))) >> 8;\n    }\n\n    lv_img_buf_set_px_alpha(d, x, y, br);\n}"}, "disp_def": {"type": "Variable", "def": "static lv_disp_t * disp_def", "sline": 58}, "lv_disp_drv_init": {"type": "Function", "def": "void lv_disp_drv_init(lv_disp_drv_t * driver)", "sline": 74, "body": "{\n    lv_memset_00(driver, sizeof(lv_disp_drv_t));\n\n    driver->hor_res          = 320;\n    driver->ver_res          = 240;\n    driver->physical_hor_res = -1;\n    driver->physical_ver_res = -1;\n    driver->offset_x         = 0;\n    driver->offset_y         = 0;\n    driver->antialiasing     = LV_COLOR_DEPTH > 8 ? 1 : 0;\n    driver->screen_transp    = LV_COLOR_SCREEN_TRANSP;\n    driver->dpi              = LV_DPI_DEF;\n    driver->color_chroma_key = LV_COLOR_CHROMA_KEY;\n}"}, "lv_disp_draw_buf_init": {"type": "Function", "def": "void lv_disp_draw_buf_init(lv_disp_draw_buf_t * draw_buf, void * buf1, void * buf2, uint32_t size_in_px_cnt)", "sline": 105, "body": "{\n    lv_memset_00(draw_buf, sizeof(lv_disp_draw_buf_t));\n\n    draw_buf->buf1    = buf1;\n    draw_buf->buf2    = buf2;\n    draw_buf->buf_act = draw_buf->buf1;\n    draw_buf->size    = size_in_px_cnt;\n}"}, "lv_disp_drv_register": {"type": "Function", "def": "lv_disp_t * lv_disp_drv_register(lv_disp_drv_t * driver)", "sline": 121, "body": "{\n    lv_disp_t * disp = _lv_ll_ins_head(&LV_GC_ROOT(_lv_disp_ll));\n    if(!disp) {\n        LV_ASSERT_MALLOC(disp);\n        return NULL;\n    }\n\n    lv_memset_00(disp, sizeof(lv_disp_t));\n\n    disp->driver = driver;\n\n    lv_disp_t * disp_def_tmp = disp_def;\n    disp_def                 = disp; /*Temporarily change the default screen to create the default screens on the\n                                        new display*/\n    /*Create a refresh timer*/\n    disp->refr_timer = lv_timer_create(_lv_disp_refr_timer, LV_DISP_DEF_REFR_PERIOD, disp);\n    LV_ASSERT_MALLOC(disp->refr_timer);\n    if(disp->refr_timer == NULL) {\n        lv_mem_free(disp);\n        return NULL;\n    }\n\n    if(driver->full_refresh && driver->draw_buf->size < (uint32_t)driver->hor_res * driver->ver_res) {\n        driver->full_refresh = 0;\n        LV_LOG_WARN(\"full_refresh requires at least screen sized draw buffer(s)\");\n    }\n\n    disp->bg_color = lv_color_white();\n#if LV_COLOR_SCREEN_TRANSP\n    disp->bg_opa = LV_OPA_TRANSP;\n#else\n    disp->bg_opa = LV_OPA_COVER;\n#endif\n\n#if LV_USE_THEME_DEFAULT\n    if(lv_theme_default_is_inited() == false) {\n        disp->theme = lv_theme_default_init(disp, lv_palette_main(LV_PALETTE_BLUE), lv_palette_main(LV_PALETTE_RED),\n                                            LV_THEME_DEFAULT_DARK, LV_FONT_DEFAULT);\n    } else {\n        disp->theme = lv_theme_default_get();\n    }\n#endif\n\n    disp->act_scr   = lv_obj_create(NULL); /*Create a default screen on the display*/\n    disp->top_layer = lv_obj_create(NULL); /*Create top layer on the display*/\n    disp->sys_layer = lv_obj_create(NULL); /*Create sys layer on the display*/\n    lv_obj_remove_style_all(disp->top_layer);\n    lv_obj_remove_style_all(disp->sys_layer);\n    lv_obj_clear_flag(disp->top_layer, LV_OBJ_FLAG_CLICKABLE);\n    lv_obj_clear_flag(disp->sys_layer, LV_OBJ_FLAG_CLICKABLE);\n\n    lv_obj_set_scrollbar_mode(disp->top_layer, LV_SCROLLBAR_MODE_OFF);\n    lv_obj_set_scrollbar_mode(disp->sys_layer, LV_SCROLLBAR_MODE_OFF);\n\n    lv_obj_invalidate(disp->act_scr);\n\n    disp_def = disp_def_tmp; /*Revert the default display*/\n    if(disp_def == NULL) disp_def = disp; /*Initialize the default display*/\n\n    lv_timer_ready(disp->refr_timer); /*Be sure the screen will be refreshed immediately on start up*/\n\n    return disp;\n}"}, "lv_disp_drv_update": {"type": "Function", "def": "void lv_disp_drv_update(lv_disp_t * disp, lv_disp_drv_t * new_drv)", "sline": 191, "body": "{\n    disp->driver = new_drv;\n\n    if(disp->driver->full_refresh &&\n       disp->driver->draw_buf->size < (uint32_t)disp->driver->hor_res * disp->driver->ver_res) {\n        disp->driver->full_refresh = 0;\n        LV_LOG_WARN(\"full_refresh requires at least screen sized draw buffer(s)\");\n    }\n\n    lv_coord_t w = lv_disp_get_hor_res(disp);\n    lv_coord_t h = lv_disp_get_ver_res(disp);\n    uint32_t i;\n    for(i = 0; i < disp->screen_cnt; i++) {\n        lv_area_t prev_coords;\n        lv_obj_get_coords(disp->screens[i], &prev_coords);\n        lv_area_set_width(&disp->screens[i]->coords, w);\n        lv_area_set_height(&disp->screens[i]->coords, h);\n        lv_event_send(disp->screens[i], LV_EVENT_SIZE_CHANGED, &prev_coords);\n    }\n\n    /*\n     * This method is usually called upon orientation change, thus the screen is now a\n     * different size.\n     * The object invalidated its previous area. That area is now out of the screen area\n     * so we reset all invalidated areas and invalidate the active screen's new area only.\n     */\n    lv_memset_00(disp->inv_areas, sizeof(disp->inv_areas));\n    lv_memset_00(disp->inv_area_joined, sizeof(disp->inv_area_joined));\n    disp->inv_p = 0;\n    if(disp->act_scr != NULL) lv_obj_invalidate(disp->act_scr);\n\n    lv_obj_tree_walk(NULL, invalidate_layout_cb, NULL);\n\n    if(disp->driver->drv_update_cb) disp->driver->drv_update_cb(disp->driver);\n}"}, "lv_disp_remove": {"type": "Function", "def": "void lv_disp_remove(lv_disp_t * disp)", "sline": 232, "body": "{\n    bool was_default = false;\n    if(disp == lv_disp_get_default()) was_default = true;\n\n    /*Detach the input devices*/\n    lv_indev_t * indev;\n    indev = lv_indev_get_next(NULL);\n    while(indev) {\n        if(indev->driver->disp == disp) {\n            indev->driver->disp = NULL;\n        }\n        indev = lv_indev_get_next(indev);\n    }\n\n    /** delete screen and other obj */\n    if(disp->sys_layer) {\n        lv_obj_del(disp->sys_layer);\n        disp->sys_layer = NULL;\n    }\n    if(disp->top_layer) {\n        lv_obj_del(disp->top_layer);\n        disp->top_layer = NULL;\n    }\n    while(disp->screen_cnt != 0) {\n        /*Delete the screenst*/\n        lv_obj_del(disp->screens[0]);\n    }\n\n    _lv_ll_remove(&LV_GC_ROOT(_lv_disp_ll), disp);\n    lv_timer_del(disp->refr_timer);\n    lv_mem_free(disp);\n\n    if(was_default) lv_disp_set_default(_lv_ll_get_head(&LV_GC_ROOT(_lv_disp_ll)));\n}"}, "lv_disp_set_default": {"type": "Function", "def": "void lv_disp_set_default(lv_disp_t * disp)", "sline": 272, "body": "{\n    disp_def = disp;\n}"}, "lv_disp_get_default": {"type": "Function", "def": "lv_disp_t * lv_disp_get_default(void)", "sline": 281, "body": "{\n    return disp_def;\n}"}, "lv_disp_get_hor_res": {"type": "Function", "def": "lv_coord_t lv_disp_get_hor_res(lv_disp_t * disp)", "sline": 291, "body": "{\n    if(disp == NULL) disp = lv_disp_get_default();\n\n    if(disp == NULL) {\n        return 0;\n    }\n    else {\n        switch(disp->driver->rotated) {\n            case LV_DISP_ROT_90:\n            case LV_DISP_ROT_270:\n                return disp->driver->ver_res;\n            default:\n                return disp->driver->hor_res;\n        }\n    }\n}"}, "lv_disp_get_ver_res": {"type": "Function", "def": "lv_coord_t lv_disp_get_ver_res(lv_disp_t * disp)", "sline": 314, "body": "{\n    if(disp == NULL) disp = lv_disp_get_default();\n\n    if(disp == NULL) {\n        return 0;\n    }\n    else {\n        switch(disp->driver->rotated) {\n            case LV_DISP_ROT_90:\n            case LV_DISP_ROT_270:\n                return disp->driver->hor_res;\n            default:\n                return disp->driver->ver_res;\n        }\n    }\n}"}, "lv_disp_get_physical_hor_res": {"type": "Function", "def": "lv_coord_t lv_disp_get_physical_hor_res(lv_disp_t * disp)", "sline": 337, "body": "{\n    if(disp == NULL) disp = lv_disp_get_default();\n\n    if(disp == NULL) {\n        return 0;\n    }\n    else {\n        switch(disp->driver->rotated) {\n            case LV_DISP_ROT_90:\n            case LV_DISP_ROT_270:\n                return disp->driver->physical_ver_res > 0 ? disp->driver->physical_ver_res : disp->driver->ver_res;\n            default:\n                return disp->driver->physical_hor_res > 0 ? disp->driver->physical_hor_res : disp->driver->hor_res;\n        }\n    }\n}"}, "lv_disp_get_physical_ver_res": {"type": "Function", "def": "lv_coord_t lv_disp_get_physical_ver_res(lv_disp_t * disp)", "sline": 360, "body": "{\n    if(disp == NULL) disp = lv_disp_get_default();\n\n    if(disp == NULL) {\n        return 0;\n    }\n    else {\n        switch(disp->driver->rotated) {\n            case LV_DISP_ROT_90:\n            case LV_DISP_ROT_270:\n                return disp->driver->physical_hor_res > 0 ? disp->driver->physical_hor_res : disp->driver->hor_res;\n            default:\n                return disp->driver->physical_ver_res > 0 ? disp->driver->physical_ver_res : disp->driver->ver_res;\n        }\n    }\n}"}, "lv_disp_get_offset_x": {"type": "Function", "def": "lv_coord_t lv_disp_get_offset_x(lv_disp_t * disp)", "sline": 383, "body": "{\n    if(disp == NULL) disp = lv_disp_get_default();\n\n    if(disp == NULL) {\n        return 0;\n    }\n    else {\n        switch(disp->driver->rotated) {\n            case LV_DISP_ROT_90:\n                return disp->driver->offset_y;\n            case LV_DISP_ROT_180:\n                return lv_disp_get_physical_hor_res(disp) - disp->driver->offset_x;\n            case LV_DISP_ROT_270:\n                return lv_disp_get_physical_hor_res(disp) - disp->driver->offset_y;\n            default:\n                return disp->driver->offset_x;\n        }\n    }\n}"}, "lv_disp_get_offset_y": {"type": "Function", "def": "lv_coord_t lv_disp_get_offset_y(lv_disp_t * disp)", "sline": 409, "body": "{\n    if(disp == NULL) disp = lv_disp_get_default();\n\n    if(disp == NULL) {\n        return 0;\n    }\n    else {\n        switch(disp->driver->rotated) {\n            case LV_DISP_ROT_90:\n                return disp->driver->offset_x;\n            case LV_DISP_ROT_180:\n                return lv_disp_get_physical_ver_res(disp) - disp->driver->offset_y;\n            case LV_DISP_ROT_270:\n                return lv_disp_get_physical_ver_res(disp) - disp->driver->offset_x;\n            default:\n                return disp->driver->offset_y;\n        }\n    }\n}"}, "lv_disp_get_antialiasing": {"type": "Function", "def": "bool lv_disp_get_antialiasing(lv_disp_t * disp)", "sline": 435, "body": "{\n    if(disp == NULL) disp = lv_disp_get_default();\n    if(disp == NULL) return false;\n\n    return disp->driver->antialiasing ? true : false;\n}"}, "lv_disp_get_dpi": {"type": "Function", "def": "lv_coord_t lv_disp_get_dpi(const lv_disp_t * disp)", "sline": 448, "body": "{\n    if(disp == NULL) disp = lv_disp_get_default();\n    if(disp == NULL) return LV_DPI_DEF;  /*Do not return 0 because it might be a divider*/\n    return disp->driver->dpi;\n}"}, "lv_disp_flush_ready": {"type": "Function", "def": "void lv_disp_flush_ready(lv_disp_drv_t * disp_drv)", "sline": 459, "body": "{\n    /*If the screen is transparent initialize it when the flushing is ready*/\n#if LV_COLOR_SCREEN_TRANSP\n    if(disp_drv->screen_transp) {\n        lv_memset_00(disp_drv->draw_buf->buf_act, disp_drv->draw_buf->size * sizeof(lv_color32_t));\n    }\n#endif\n\n    disp_drv->draw_buf->flushing = 0;\n    disp_drv->draw_buf->flushing_last = 0;\n}"}, "lv_disp_flush_is_last": {"type": "Function", "def": "bool lv_disp_flush_is_last(lv_disp_drv_t * disp_drv)", "sline": 478, "body": "{\n    return disp_drv->draw_buf->flushing_last;\n}"}, "lv_disp_get_next": {"type": "Function", "def": "lv_disp_t * lv_disp_get_next(lv_disp_t * disp)", "sline": 488, "body": "{\n    if(disp == NULL)\n        return _lv_ll_get_head(&LV_GC_ROOT(_lv_disp_ll));\n    else\n        return _lv_ll_get_next(&LV_GC_ROOT(_lv_disp_ll), disp);\n}"}, "lv_disp_get_draw_buf": {"type": "Function", "def": "lv_disp_draw_buf_t * lv_disp_get_draw_buf(lv_disp_t * disp)", "sline": 501, "body": "{\n    return disp->driver->draw_buf;\n}"}, "lv_disp_set_rotation": {"type": "Function", "def": "void lv_disp_set_rotation(lv_disp_t * disp, lv_disp_rot_t rotation)", "sline": 511, "body": "{\n    if(disp == NULL) disp = lv_disp_get_default();\n    if(disp == NULL) return;\n\n    disp->driver->rotated = rotation;\n    lv_disp_drv_update(disp, disp->driver);\n}"}, "lv_disp_get_rotation": {"type": "Function", "def": "lv_disp_rot_t lv_disp_get_rotation(lv_disp_t * disp)", "sline": 525, "body": "{\n    if(disp == NULL) disp = lv_disp_get_default();\n    if(disp == NULL) return LV_DISP_ROT_NONE;\n    return disp->driver->rotated;\n}"}, "lv_disp_drv_use_generic_set_px_cb": {"type": "Function", "def": "void lv_disp_drv_use_generic_set_px_cb(lv_disp_drv_t * disp_drv, lv_img_cf_t cf)", "sline": 532, "body": "{\n    switch(cf) {\n        case LV_IMG_CF_TRUE_COLOR_ALPHA:\n            disp_drv->set_px_cb = set_px_true_color_alpha;\n            break;\n        case LV_IMG_CF_ALPHA_1BIT:\n            disp_drv->set_px_cb = set_px_cb_alpha1;\n            break;\n        case LV_IMG_CF_ALPHA_2BIT:\n            disp_drv->set_px_cb = set_px_cb_alpha2;\n            break;\n        case LV_IMG_CF_ALPHA_4BIT:\n            disp_drv->set_px_cb = set_px_cb_alpha4;\n            break;\n        case LV_IMG_CF_ALPHA_8BIT:\n            disp_drv->set_px_cb = set_px_cb_alpha8;\n            break;\n        default:\n            disp_drv->set_px_cb = NULL;\n    }\n}"}, "carbit_updater/lvgl/src/hal/lv_hal_disp.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/hal/lv_hal_disp.c"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_38.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_montserrat_38.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_38.c"}}, "carbit_updater/lvgl/src/widgets/lv_objx_templ.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 23}, "carbit_updater/lvgl/src/widgets/lv_objx_templ.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_objx_templ.h"}}, "carbit_updater/lvgl/src/extra/widgets/tileview/lv_tileview.h": {"lv_obj": {"type": "Variable", "def": "#include ../../../core/lv_obj.h", "sline": 16}, "lv_tileview_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 28, "in_struct": "lv_tileview_t"}, "lv_tileview_t.tile_act": {"type": "Variable", "def": "lv_obj_t * tile_act", "sline": 29, "in_struct": "lv_tileview_t"}, "lv_tileview_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    lv_obj_t * tile_act;\n} lv_tileview_t", "sline": 30, "docstring": "/**********************"}, "lv_tileview_tile_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 33, "in_struct": "lv_tileview_tile_t"}, "lv_tileview_tile_t.dir": {"type": "Variable", "def": "lv_dir_t dir", "sline": 34, "in_struct": "lv_tileview_tile_t"}, "lv_tileview_tile_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    lv_dir_t dir;\n} lv_tileview_tile_t", "sline": 35}, "lv_tileview_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_tileview_class", "sline": 37}, "lv_tileview_tile_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_tileview_tile_class", "sline": 38}, "lv_tileview_create": {"type": "Function", "def": "lv_obj_t * lv_tileview_create(lv_obj_t * parent)", "sline": 49}, "lv_tileview_add_tile": {"type": "Function", "def": "lv_obj_t * lv_tileview_add_tile(lv_obj_t * tv, uint8_t row_id, uint8_t col_id, lv_dir_t dir)", "sline": 51}, "lv_obj_set_tile": {"type": "Function", "def": "void lv_obj_set_tile(lv_obj_t * tv, lv_obj_t * tile_obj, lv_anim_enable_t anim_en)", "sline": 53}, "lv_obj_set_tile_id": {"type": "Function", "def": "void lv_obj_set_tile_id(lv_obj_t * tv, uint32_t col_id, uint32_t row_id, lv_anim_enable_t anim_en)", "sline": 54}, "lv_tileview_get_tile_act": {"type": "Function", "def": "lv_obj_t * lv_tileview_get_tile_act(lv_obj_t * obj)", "sline": 56}, "carbit_updater/lvgl/src/extra/widgets/tileview/lv_tileview.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/tileview/lv_tileview.h"}}, "carbit_updater/lvgl/src/core/lv_obj.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "stddef": {"type": "Variable", "def": "#include stddef.h", "sline": 18}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 19}, "lv_style": {"type": "Variable", "def": "#include ../misc/lv_style.h", "sline": 20}, "lv_types": {"type": "Variable", "def": "#include ../misc/lv_types.h", "sline": 21}, "lv_area": {"type": "Variable", "def": "#include ../misc/lv_area.h", "sline": 22}, "lv_color": {"type": "Variable", "def": "#include ../misc/lv_color.h", "sline": 23}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 24}, "lv_hal": {"type": "Variable", "def": "#include ../hal/lv_hal.h", "sline": 25}, "lv_obj_tree": {"type": "Variable", "def": "#include lv_obj_tree.h", "sline": 130, "include": ["carbit_updater/lvgl/src/core/lv_obj_tree.h", null]}, "lv_obj_pos": {"type": "Variable", "def": "#include lv_obj_pos.h", "sline": 131, "include": ["carbit_updater/lvgl/src/core/lv_obj_pos.h", null]}, "lv_obj_scroll": {"type": "Variable", "def": "#include lv_obj_scroll.h", "sline": 132, "include": ["carbit_updater/lvgl/src/core/lv_obj_scroll.h", null]}, "lv_obj_style": {"type": "Variable", "def": "#include lv_obj_style.h", "sline": 133, "include": ["carbit_updater/lvgl/src/core/lv_obj_style.h", null]}, "lv_obj_draw": {"type": "Variable", "def": "#include lv_obj_draw.h", "sline": 134, "include": ["carbit_updater/lvgl/src/core/lv_obj_draw.h", null]}, "lv_obj_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_obj_class", "sline": 142}, "lv_event": {"type": "Variable", "def": "#include lv_event.h", "sline": 136, "include": ["carbit_updater/lvgl/src/core/lv_event.h", null]}, "lv_group": {"type": "Variable", "def": "#include lv_group.h", "sline": 137, "include": ["carbit_updater/lvgl/src/core/lv_group.h", null]}, "_lv_obj_t": {"type": "Struct", "def": "struct _lv_obj_t {\n    const lv_obj_class_t * class_p;\n    struct _lv_obj_t * parent;\n    _lv_obj_spec_attr_t * spec_attr;\n    _lv_obj_style_t * styles;\n#if LV_USE_USER_DATA\n    void * user_data;\n#endif\n    lv_area_t coords;\n    lv_obj_flag_t flags;\n    lv_state_t state;\n    uint16_t layout_inv : 1;\n    uint16_t scr_layout_inv : 1;\n    uint16_t skip_trans : 1;\n    uint16_t style_cnt  : 6;\n    uint16_t h_layout   : 1;\n    uint16_t w_layout   : 1;\n}", "sline": 166, "body": "const lv_obj_class_t * class_p\nstruct _lv_obj_t * parent\n_lv_obj_spec_attr_t * spec_attr\n_lv_obj_style_t * styles\nvoid * user_data\nlv_area_t coords\nlv_obj_flag_t flags\nlv_state_t state\nuint16_t layout_inv : 1\nuint16_t scr_layout_inv : 1\nuint16_t skip_trans : 1\nuint16_t style_cnt  : 6\nuint16_t h_layout   : 1\nuint16_t w_layout   : 1\n"}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj.h:41:1)": {"type": "Enum", "def": "enum {\n    LV_STATE_DEFAULT     =  0x0000,\n    LV_STATE_CHECKED     =  0x0001,\n    LV_STATE_FOCUSED     =  0x0002,\n    LV_STATE_FOCUS_KEY   =  0x0004,\n    LV_STATE_EDITED      =  0x0008,\n    LV_STATE_HOVERED     =  0x0010,\n    LV_STATE_PRESSED     =  0x0020,\n    LV_STATE_SCROLLED    =  0x0040,\n    LV_STATE_DISABLED    =  0x0080,\n\n    LV_STATE_USER_1      =  0x1000,\n    LV_STATE_USER_2      =  0x2000,\n    LV_STATE_USER_3      =  0x4000,\n    LV_STATE_USER_4      =  0x8000,\n\n    LV_STATE_ANY = 0xFFFF,    /**< Special value can be used in some functions to target all states*/\n}", "sline": 41}, "lv_state_t": {"type": "Variable", "def": "typedef uint16_t lv_state_t", "sline": 60}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj.h:68:1)": {"type": "Enum", "def": "enum {\n    LV_PART_MAIN         = 0x000000,   /**< A background like rectangle*/\n    LV_PART_SCROLLBAR    = 0x010000,   /**< The scrollbar(s)*/\n    LV_PART_INDICATOR    = 0x020000,   /**< Indicator, e.g. for slider, bar, switch, or the tick box of the checkbox*/\n    LV_PART_KNOB         = 0x030000,   /**< Like handle to grab to adjust the value*/\n    LV_PART_SELECTED     = 0x040000,   /**< Indicate the currently selected option or section*/\n    LV_PART_ITEMS        = 0x050000,   /**< Used if the widget has multiple similar elements (e.g. table cells)*/\n    LV_PART_TICKS        = 0x060000,   /**< Ticks on scale e.g. for a chart or meter*/\n    LV_PART_CURSOR       = 0x070000,   /**< Mark a specific place e.g. for text area's cursor or on a chart*/\n\n    LV_PART_CUSTOM_FIRST = 0x080000,    /**< Extension point for custom widgets*/\n\n    LV_PART_ANY          = 0x0F0000,    /**< Special value can be used in some functions to target all parts*/\n}", "sline": 68}, "lv_part_t": {"type": "Variable", "def": "typedef uint32_t lv_part_t", "sline": 83}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj.h:89:1)": {"type": "Enum", "def": "enum {\n    LV_OBJ_FLAG_HIDDEN          = (1L << 0),  /**< Make the object hidden. (Like it wasn't there at all)*/\n    LV_OBJ_FLAG_CLICKABLE       = (1L << 1),  /**< Make the object clickable by the input devices*/\n    LV_OBJ_FLAG_CLICK_FOCUSABLE = (1L << 2),  /**< Add focused state to the object when clicked*/\n    LV_OBJ_FLAG_CHECKABLE       = (1L << 3),  /**< Toggle checked state when the object is clicked*/\n    LV_OBJ_FLAG_SCROLLABLE      = (1L << 4),  /**< Make the object scrollable*/\n    LV_OBJ_FLAG_SCROLL_ELASTIC  = (1L << 5),  /**< Allow scrolling inside but with slower speed*/\n    LV_OBJ_FLAG_SCROLL_MOMENTUM = (1L << 6),  /**< Make the object scroll further when \"thrown\"*/\n    LV_OBJ_FLAG_SCROLL_ONE      = (1L << 7),  /**< Allow scrolling only one snappable children*/\n    LV_OBJ_FLAG_SCROLL_CHAIN    = (1L << 8),  /**< Allow propagating the scroll to a parent*/\n    LV_OBJ_FLAG_SCROLL_ON_FOCUS = (1L << 9),  /**< Automatically scroll object to make it visible when focused*/\n    LV_OBJ_FLAG_SNAPPABLE       = (1L << 10), /**< If scroll snap is enabled on the parent it can snap to this object*/\n    LV_OBJ_FLAG_PRESS_LOCK      = (1L << 11), /**< Keep the object pressed even if the press slid from the object*/\n    LV_OBJ_FLAG_EVENT_BUBBLE    = (1L << 12), /**< Propagate the events to the parent too*/\n    LV_OBJ_FLAG_GESTURE_BUBBLE  = (1L << 13), /**< Propagate the gestures to the parent*/\n    LV_OBJ_FLAG_ADV_HITTEST     = (1L << 14), /**< Allow performing more accurate hit (click) test. E.g. consider rounded corners.*/\n    LV_OBJ_FLAG_IGNORE_LAYOUT   = (1L << 15), /**< Make the object position-able by the layouts*/\n    LV_OBJ_FLAG_FLOATING        = (1L << 16), /**< Do not scroll the object when the parent scrolls and ignore layout*/\n\n    LV_OBJ_FLAG_LAYOUT_1        = (1L << 23), /**< Custom flag, free to use by layouts*/\n    LV_OBJ_FLAG_LAYOUT_2        = (1L << 24), /**< Custom flag, free to use by layouts*/\n\n    LV_OBJ_FLAG_WIDGET_1        = (1L << 25), /**< Custom flag, free to use by widget*/\n    LV_OBJ_FLAG_WIDGET_2        = (1L << 26), /**< Custom flag, free to use by widget*/\n    LV_OBJ_FLAG_USER_1          = (1L << 27), /**< Custom flag, free to use by user*/\n    LV_OBJ_FLAG_USER_2          = (1L << 28), /**< Custom flag, free to use by user*/\n    LV_OBJ_FLAG_USER_3          = (1L << 29), /**< Custom flag, free to use by user*/\n    LV_OBJ_FLAG_USER_4          = (1L << 30), /**< Custom flag, free to use by user*/\n}", "sline": 89}, "lv_obj_flag_t": {"type": "Variable", "def": "typedef uint32_t lv_obj_flag_t", "sline": 118}, "lv_obj_draw_part_type_t": {"type": "Variable", "def": "typedef enum {\n    LV_OBJ_DRAW_PART_RECTANGLE,  /**< The main rectangle*/\n    LV_OBJ_DRAW_PART_BORDER_POST,/**< The border if style_border_post = true*/\n    LV_OBJ_DRAW_PART_SCROLLBAR,  /**< The scrollbar*/\n} lv_obj_draw_part_type_t", "sline": 128}, "_lv_obj_spec_attr_t.children": {"type": "Variable", "def": "struct _lv_obj_t ** children", "sline": 149, "in_struct": "_lv_obj_spec_attr_t"}, "_lv_obj_spec_attr_t.child_cnt": {"type": "Variable", "def": "uint32_t child_cnt", "sline": 150, "in_struct": "_lv_obj_spec_attr_t"}, "_lv_obj_spec_attr_t.group_p": {"type": "Variable", "def": "lv_group_t * group_p", "sline": 151, "in_struct": "_lv_obj_spec_attr_t"}, "_lv_obj_spec_attr_t.event_dsc": {"type": "Variable", "def": "struct _lv_event_dsc_t * event_dsc", "sline": 153, "in_struct": "_lv_obj_spec_attr_t"}, "_lv_obj_spec_attr_t.scroll": {"type": "Variable", "def": "lv_point_t scroll", "sline": 154, "in_struct": "_lv_obj_spec_attr_t"}, "_lv_obj_spec_attr_t.ext_click_pad": {"type": "Variable", "def": "lv_coord_t ext_click_pad", "sline": 156, "in_struct": "_lv_obj_spec_attr_t"}, "_lv_obj_spec_attr_t.ext_draw_size": {"type": "Variable", "def": "lv_coord_t ext_draw_size", "sline": 157, "in_struct": "_lv_obj_spec_attr_t"}, "_lv_obj_spec_attr_t.scrollbar_mode": {"type": "Variable", "def": "lv_scrollbar_mode_t scrollbar_mode : 2", "sline": 159, "in_struct": "_lv_obj_spec_attr_t"}, "_lv_obj_spec_attr_t.scroll_snap_x": {"type": "Variable", "def": "lv_scroll_snap_t scroll_snap_x : 2", "sline": 160, "in_struct": "_lv_obj_spec_attr_t"}, "_lv_obj_spec_attr_t.scroll_snap_y": {"type": "Variable", "def": "lv_scroll_snap_t scroll_snap_y : 2", "sline": 161, "in_struct": "_lv_obj_spec_attr_t"}, "_lv_obj_spec_attr_t.scroll_dir": {"type": "Variable", "def": "lv_dir_t scroll_dir : 4", "sline": 162, "in_struct": "_lv_obj_spec_attr_t"}, "_lv_obj_spec_attr_t.event_dsc_cnt": {"type": "Variable", "def": "uint8_t event_dsc_cnt", "sline": 163, "in_struct": "_lv_obj_spec_attr_t"}, "_lv_obj_spec_attr_t": {"type": "Variable", "def": "typedef struct {\n    struct _lv_obj_t ** children;       /**< Store the pointer of the children in an array.*/\n    uint32_t child_cnt;                 /**< Number of children*/\n    lv_group_t * group_p;\n\n    struct _lv_event_dsc_t * event_dsc; /**< Dynamically allocated event callback and user data array*/\n    lv_point_t scroll;                  /**< The current X/Y scroll offset*/\n\n    lv_coord_t ext_click_pad;           /**< Extra click padding in all direction*/\n    lv_coord_t ext_draw_size;           /**< EXTend the size in every direction for drawing.*/\n\n    lv_scrollbar_mode_t scrollbar_mode : 2; /**< How to display scrollbars*/\n    lv_scroll_snap_t scroll_snap_x : 2;     /**< Where to align the snappable children horizontally*/\n    lv_scroll_snap_t scroll_snap_y : 2;     /**< Where to align the snappable children vertically*/\n    lv_dir_t scroll_dir : 4;                /**< The allowed scroll direction(s)*/\n    uint8_t event_dsc_cnt;                  /**< Number of event callbacks stored in `event_dsc` array*/\n} _lv_obj_spec_attr_t", "sline": 164}, "_lv_obj_t.class_p": {"type": "Variable", "def": "const lv_obj_class_t * class_p", "sline": 167, "in_struct": "_lv_obj_t"}, "_lv_obj_t.parent": {"type": "Variable", "def": "struct _lv_obj_t * parent", "sline": 168, "in_struct": "_lv_obj_t"}, "_lv_obj_t.spec_attr": {"type": "Variable", "def": "_lv_obj_spec_attr_t * spec_attr", "sline": 169, "in_struct": "_lv_obj_t"}, "_lv_obj_t.styles": {"type": "Variable", "def": "_lv_obj_style_t * styles", "sline": 170, "in_struct": "_lv_obj_t"}, "_lv_obj_t.user_data": {"type": "Variable", "def": "void * user_data", "sline": 172, "in_struct": "_lv_obj_t"}, "_lv_obj_t.coords": {"type": "Variable", "def": "lv_area_t coords", "sline": 174, "in_struct": "_lv_obj_t"}, "_lv_obj_t.flags": {"type": "Variable", "def": "lv_obj_flag_t flags", "sline": 175, "in_struct": "_lv_obj_t", "rels": [["lv_obj_flag_t", null, "Typeof"]]}, "_lv_obj_t.state": {"type": "Variable", "def": "lv_state_t state", "sline": 176, "in_struct": "_lv_obj_t", "rels": [["lv_state_t", null, "Typeof"]]}, "_lv_obj_t.layout_inv": {"type": "Variable", "def": "uint16_t layout_inv : 1", "sline": 177, "in_struct": "_lv_obj_t"}, "_lv_obj_t.scr_layout_inv": {"type": "Variable", "def": "uint16_t scr_layout_inv : 1", "sline": 178, "in_struct": "_lv_obj_t"}, "_lv_obj_t.skip_trans": {"type": "Variable", "def": "uint16_t skip_trans : 1", "sline": 179, "in_struct": "_lv_obj_t"}, "_lv_obj_t.style_cnt": {"type": "Variable", "def": "uint16_t style_cnt  : 6", "sline": 180, "in_struct": "_lv_obj_t"}, "_lv_obj_t.h_layout": {"type": "Variable", "def": "uint16_t h_layout   : 1", "sline": 181, "in_struct": "_lv_obj_t"}, "_lv_obj_t.w_layout": {"type": "Variable", "def": "uint16_t w_layout   : 1", "sline": 182, "in_struct": "_lv_obj_t"}, "lv_obj_t": {"type": "Variable", "def": "typedef struct _lv_obj_t {\n    const lv_obj_class_t * class_p;\n    struct _lv_obj_t * parent;\n    _lv_obj_spec_attr_t * spec_attr;\n    _lv_obj_style_t * styles;\n#if LV_USE_USER_DATA\n    void * user_data;\n#endif\n    lv_area_t coords;\n    lv_obj_flag_t flags;\n    lv_state_t state;\n    uint16_t layout_inv : 1;\n    uint16_t scr_layout_inv : 1;\n    uint16_t skip_trans : 1;\n    uint16_t style_cnt  : 6;\n    uint16_t h_layout   : 1;\n    uint16_t w_layout   : 1;\n} lv_obj_t", "sline": 183}, "lv_init": {"type": "Function", "def": "void lv_init(void)", "sline": 194}, "lv_deinit": {"type": "Function", "def": "void lv_deinit(void)", "sline": 202}, "lv_is_initialized": {"type": "Function", "def": "bool lv_is_initialized(void)", "sline": 209}, "lv_obj_create": {"type": "Function", "def": "lv_obj_t * lv_obj_create(lv_obj_t * parent)", "sline": 216}, "lv_obj_add_flag": {"type": "Function", "def": "void lv_obj_add_flag(lv_obj_t * obj, lv_obj_flag_t f)", "sline": 228}, "lv_obj_clear_flag": {"type": "Function", "def": "void lv_obj_clear_flag(lv_obj_t * obj, lv_obj_flag_t f)", "sline": 235}, "lv_obj_add_state": {"type": "Function", "def": "void lv_obj_add_state(lv_obj_t * obj, lv_state_t state)", "sline": 244}, "lv_obj_clear_state": {"type": "Function", "def": "void lv_obj_clear_state(lv_obj_t * obj, lv_state_t state)", "sline": 252}, "lv_obj_set_user_data": {"type": "Function", "def": "static inline void lv_obj_set_user_data(lv_obj_t * obj, void * user_data)", "sline": 260, "body": "{\n    obj->user_data = user_data;\n}"}, "lv_obj_has_flag": {"type": "Function", "def": "bool lv_obj_has_flag(const lv_obj_t * obj, lv_obj_flag_t f)", "sline": 276}, "lv_obj_has_flag_any": {"type": "Function", "def": "bool lv_obj_has_flag_any(const lv_obj_t * obj, lv_obj_flag_t f)", "sline": 284}, "lv_obj_get_state": {"type": "Function", "def": "lv_state_t lv_obj_get_state(const lv_obj_t * obj)", "sline": 291, "rels": [["lv_state_t", null, "Typeof"]]}, "lv_obj_has_state": {"type": "Function", "def": "bool lv_obj_has_state(const lv_obj_t * obj, lv_state_t state)", "sline": 299}, "lv_obj_get_group": {"type": "Function", "def": "void * lv_obj_get_group(const lv_obj_t * obj)", "sline": 306}, "lv_obj_get_user_data": {"type": "Function", "def": "static inline void * lv_obj_get_user_data(lv_obj_t * obj)", "sline": 314, "body": "{\n    return obj->user_data;\n}"}, "lv_obj_allocate_spec_attr": {"type": "Function", "def": "void lv_obj_allocate_spec_attr(lv_obj_t * obj)", "sline": 328}, "lv_obj_check_type": {"type": "Function", "def": "bool lv_obj_check_type(const lv_obj_t * obj, const lv_obj_class_t * class_p)", "sline": 336}, "lv_obj_has_class": {"type": "Function", "def": "bool lv_obj_has_class(const lv_obj_t * obj, const lv_obj_class_t * class_p)", "sline": 345}, "lv_obj_get_class": {"type": "Function", "def": "const lv_obj_class_t * lv_obj_get_class(const lv_obj_t * obj)", "sline": 352}, "lv_obj_is_valid": {"type": "Function", "def": "bool lv_obj_is_valid(const lv_obj_t * obj)", "sline": 359}, "lv_obj_dpx": {"type": "Function", "def": "static inline lv_coord_t lv_obj_dpx(const lv_obj_t * obj, lv_coord_t n)", "sline": 370, "body": "{\n    return _LV_DPX_CALC(lv_disp_get_dpi(lv_obj_get_disp(obj)), n);\n}"}, "carbit_updater/lvgl/src/core/lv_obj.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj.h"}}, "carbit_updater/lvgl/src/misc/lv_txt.c": {"stdarg": {"type": "Variable", "def": "#include stdarg.h", "sline": 9}, "lv_txt": {"type": "Variable", "def": "#include lv_txt.h", "sline": 10, "include": ["carbit_updater/lvgl/src/misc/lv_txt.h", null]}, "lv_txt_ap": {"type": "Variable", "def": "#include lv_txt_ap.h", "sline": 11, "include": ["carbit_updater/lvgl/src/misc/lv_txt_ap.h", null]}, "lv_math": {"type": "Variable", "def": "#include lv_math.h", "sline": 12, "include": ["carbit_updater/lvgl/src/misc/lv_math.h", null]}, "lv_log": {"type": "Variable", "def": "#include lv_log.h", "sline": 13, "include": ["carbit_updater/lvgl/src/misc/lv_log.h", null]}, "lv_mem": {"type": "Variable", "def": "#include lv_mem.h", "sline": 14, "include": ["carbit_updater/lvgl/src/misc/lv_mem.h", null]}, "lv_assert": {"type": "Variable", "def": "#include lv_assert.h", "sline": 15, "include": ["carbit_updater/lvgl/src/misc/lv_assert.h", null]}, "lv_txt_utf8_size": {"type": "Function", "def": "static uint8_t lv_txt_utf8_size(const char * str)", "sline": 495, "body": "{\n    if(LV_IS_ASCII(str[0]))\n        return 1;\n    else if(LV_IS_2BYTES_UTF8_CODE(str[0]))\n        return 2;\n    else if(LV_IS_3BYTES_UTF8_CODE(str[0]))\n        return 3;\n    else if(LV_IS_4BYTES_UTF8_CODE(str[0]))\n        return 4;\n    return 0;\n}"}, "lv_txt_unicode_to_utf8": {"type": "Function", "def": "static uint32_t lv_txt_unicode_to_utf8(uint32_t letter_uni)", "sline": 513, "body": "{\n    if(letter_uni < 128) return letter_uni;\n    uint8_t bytes[4];\n\n    if(letter_uni < 0x0800) {\n        bytes[0] = ((letter_uni >> 6) & 0x1F) | 0xC0;\n        bytes[1] = ((letter_uni >> 0) & 0x3F) | 0x80;\n        bytes[2] = 0;\n        bytes[3] = 0;\n    }\n    else if(letter_uni < 0x010000) {\n        bytes[0] = ((letter_uni >> 12) & 0x0F) | 0xE0;\n        bytes[1] = ((letter_uni >> 6) & 0x3F) | 0x80;\n        bytes[2] = ((letter_uni >> 0) & 0x3F) | 0x80;\n        bytes[3] = 0;\n    }\n    else if(letter_uni < 0x110000) {\n        bytes[0] = ((letter_uni >> 18) & 0x07) | 0xF0;\n        bytes[1] = ((letter_uni >> 12) & 0x3F) | 0x80;\n        bytes[2] = ((letter_uni >> 6) & 0x3F) | 0x80;\n        bytes[3] = ((letter_uni >> 0) & 0x3F) | 0x80;\n    }\n\n    uint32_t * res_p = (uint32_t *)bytes;\n    return *res_p;\n}"}, "lv_txt_utf8_conv_wc": {"type": "Function", "def": "static uint32_t lv_txt_utf8_conv_wc(uint32_t c)", "sline": 546, "body": "{\n#if LV_BIG_ENDIAN_SYSTEM == 0\n    /*Swap the bytes (UTF-8 is big endian, but the MCUs are little endian)*/\n    if((c & 0x80) != 0) {\n        uint32_t swapped;\n        uint8_t c8[4];\n        lv_memcpy_small(c8, &c, 4);\n        swapped = (c8[0] << 24) + (c8[1] << 16) + (c8[2] << 8) + (c8[3]);\n        uint8_t i;\n        for(i = 0; i < 4; i++) {\n            if((swapped & 0xFF) == 0)\n                swapped = (swapped >> 8); /*Ignore leading zeros (they were in the end originally)*/\n        }\n        c = swapped;\n    }\n#endif\n    return c;\n}"}, "lv_txt_utf8_next": {"type": "Function", "def": "static uint32_t lv_txt_utf8_next(const char * txt, uint32_t * i)", "sline": 574, "body": "{\n    /**\n     * Unicode to UTF-8\n     * 00000000 00000000 00000000 0xxxxxxx -> 0xxxxxxx\n     * 00000000 00000000 00000yyy yyxxxxxx -> 110yyyyy 10xxxxxx\n     * 00000000 00000000 zzzzyyyy yyxxxxxx -> 1110zzzz 10yyyyyy 10xxxxxx\n     * 00000000 000wwwzz zzzzyyyy yyxxxxxx -> 11110www 10zzzzzz 10yyyyyy 10xxxxxx\n     */\n\n    uint32_t result = 0;\n\n    /*Dummy 'i' pointer is required*/\n    uint32_t i_tmp = 0;\n    if(i == NULL) i = &i_tmp;\n\n    /*Normal ASCII*/\n    if(LV_IS_ASCII(txt[*i])) {\n        result = txt[*i];\n        (*i)++;\n    }\n    /*Real UTF-8 decode*/\n    else {\n        /*2 bytes UTF-8 code*/\n        if(LV_IS_2BYTES_UTF8_CODE(txt[*i])) {\n            result = (uint32_t)(txt[*i] & 0x1F) << 6;\n            (*i)++;\n            if(LV_IS_INVALID_UTF8_CODE(txt[*i])) return 0;\n            result += (txt[*i] & 0x3F);\n            (*i)++;\n        }\n        /*3 bytes UTF-8 code*/\n        else if(LV_IS_3BYTES_UTF8_CODE(txt[*i])) {\n            result = (uint32_t)(txt[*i] & 0x0F) << 12;\n            (*i)++;\n\n            if(LV_IS_INVALID_UTF8_CODE(txt[*i])) return 0;\n            result += (uint32_t)(txt[*i] & 0x3F) << 6;\n            (*i)++;\n\n            if(LV_IS_INVALID_UTF8_CODE(txt[*i])) return 0;\n            result += (txt[*i] & 0x3F);\n            (*i)++;\n        }\n        /*4 bytes UTF-8 code*/\n        else if(LV_IS_4BYTES_UTF8_CODE(txt[*i])) {\n            result = (uint32_t)(txt[*i] & 0x07) << 18;\n            (*i)++;\n\n            if(LV_IS_INVALID_UTF8_CODE(txt[*i])) return 0;\n            result += (uint32_t)(txt[*i] & 0x3F) << 12;\n            (*i)++;\n\n            if(LV_IS_INVALID_UTF8_CODE(txt[*i])) return 0;\n            result += (uint32_t)(txt[*i] & 0x3F) << 6;\n            (*i)++;\n\n            if(LV_IS_INVALID_UTF8_CODE(txt[*i])) return 0;\n            result += txt[*i] & 0x3F;\n            (*i)++;\n        }\n        else {\n            (*i)++; /*Not UTF-8 char. Go the next.*/\n        }\n    }\n    return result;\n}"}, "lv_txt_utf8_prev": {"type": "Function", "def": "static uint32_t lv_txt_utf8_prev(const char * txt, uint32_t * i)", "sline": 649, "body": "{\n    uint8_t c_size;\n    uint8_t cnt = 0;\n\n    /*Try to find a !0 long UTF-8 char by stepping one character back*/\n    (*i)--;\n    do {\n        if(cnt >= 4) return 0; /*No UTF-8 char found before the initial*/\n\n        c_size = _lv_txt_encoded_size(&txt[*i]);\n        if(c_size == 0) {\n            if(*i != 0)\n                (*i)--;\n            else\n                return 0;\n        }\n        cnt++;\n    } while(c_size == 0);\n\n    uint32_t i_tmp  = *i;\n    uint32_t letter = _lv_txt_encoded_next(txt, &i_tmp); /*Character found, get it*/\n\n    return letter;\n}"}, "lv_txt_utf8_get_byte_id": {"type": "Function", "def": "static uint32_t lv_txt_utf8_get_byte_id(const char * txt, uint32_t utf8_id)", "sline": 682, "body": "{\n    uint32_t i;\n    uint32_t byte_cnt = 0;\n    for(i = 0; i < utf8_id && txt[byte_cnt] != '\\0'; i++) {\n        uint8_t c_size = _lv_txt_encoded_size(&txt[byte_cnt]);\n        /* If the char was invalid tell it's 1 byte long*/\n        byte_cnt += c_size ? c_size : 1;\n    }\n\n    return byte_cnt;\n}"}, "lv_txt_utf8_get_char_id": {"type": "Function", "def": "static uint32_t lv_txt_utf8_get_char_id(const char * txt, uint32_t byte_id)", "sline": 702, "body": "{\n    uint32_t i        = 0;\n    uint32_t char_cnt = 0;\n\n    while(i < byte_id) {\n        _lv_txt_encoded_next(txt, &i); /*'i' points to the next letter so use the prev. value*/\n        char_cnt++;\n    }\n\n    return char_cnt;\n}"}, "lv_txt_utf8_get_length": {"type": "Function", "def": "static uint32_t lv_txt_utf8_get_length(const char * txt)", "sline": 721, "body": "{\n    uint32_t len = 0;\n    uint32_t i   = 0;\n\n    while(txt[i] != '\\0') {\n        _lv_txt_encoded_next(txt, &i);\n        len++;\n    }\n\n    return len;\n}"}, "_lv_txt_encoded_size": {"type": "Variable", "def": "uint8_t (*_lv_txt_encoded_size)(const char *)                   = lv_txt_utf8_size", "sline": 57, "rels": [["lv_txt_utf8_size", null, "Assign"]]}, "_lv_txt_unicode_to_encoded": {"type": "Variable", "def": "uint32_t (*_lv_txt_unicode_to_encoded)(uint32_t)                = lv_txt_unicode_to_utf8", "sline": 58, "rels": [["lv_txt_unicode_to_utf8", null, "Assign"]]}, "_lv_txt_encoded_conv_wc": {"type": "Variable", "def": "uint32_t (*_lv_txt_encoded_conv_wc)(uint32_t)                   = lv_txt_utf8_conv_wc", "sline": 59, "rels": [["lv_txt_utf8_conv_wc", null, "Assign"]]}, "_lv_txt_encoded_next": {"type": "Variable", "def": "uint32_t (*_lv_txt_encoded_next)(const char *, uint32_t *)      = lv_txt_utf8_next", "sline": 60, "rels": [["lv_txt_utf8_next", null, "Assign"]]}, "_lv_txt_encoded_prev": {"type": "Variable", "def": "uint32_t (*_lv_txt_encoded_prev)(const char *, uint32_t *)      = lv_txt_utf8_prev", "sline": 61, "rels": [["lv_txt_utf8_prev", null, "Assign"]]}, "_lv_txt_encoded_get_byte_id": {"type": "Variable", "def": "uint32_t (*_lv_txt_encoded_get_byte_id)(const char *, uint32_t) = lv_txt_utf8_get_byte_id", "sline": 62, "rels": [["lv_txt_utf8_get_byte_id", null, "Assign"]]}, "_lv_txt_encoded_get_char_id": {"type": "Variable", "def": "uint32_t (*_lv_txt_encoded_get_char_id)(const char *, uint32_t) = lv_txt_utf8_get_char_id", "sline": 63, "rels": [["lv_txt_utf8_get_char_id", null, "Assign"]]}, "_lv_txt_get_encoded_length": {"type": "Variable", "def": "uint32_t (*_lv_txt_get_encoded_length)(const char *)            = lv_txt_utf8_get_length", "sline": 64, "rels": [["lv_txt_utf8_get_length", null, "Assign"]]}, "lv_txt_get_size": {"type": "Function", "def": "void lv_txt_get_size(lv_point_t * size_res, const char * text, const lv_font_t * font, lv_coord_t letter_space,\n                     lv_coord_t line_space, lv_coord_t max_width, lv_text_flag_t flag)", "sline": 91, "body": "{\n    size_res->x = 0;\n    size_res->y = 0;\n\n    if(text == NULL) return;\n    if(font == NULL) return;\n\n    if(flag & LV_TEXT_FLAG_EXPAND) max_width = LV_COORD_MAX;\n\n    uint32_t line_start     = 0;\n    uint32_t new_line_start = 0;\n    uint16_t letter_height = lv_font_get_line_height(font);\n\n    /*Calc. the height and longest line*/\n    while(text[line_start] != '\\0') {\n        new_line_start += _lv_txt_get_next_line(&text[line_start], font, letter_space, max_width, flag);\n\n        if((unsigned long)size_res->y + (unsigned long)letter_height + (unsigned long)line_space > LV_MAX_OF(lv_coord_t)) {\n            LV_LOG_WARN(\"lv_txt_get_size: integer overflow while calculating text height\");\n            return;\n        }\n        else {\n            size_res->y += letter_height;\n            size_res->y += line_space;\n        }\n\n        /*Calculate the longest line*/\n        lv_coord_t act_line_length = lv_txt_get_width(&text[line_start], new_line_start - line_start, font, letter_space,\n                                                      flag);\n\n        size_res->x = LV_MAX(act_line_length, size_res->x);\n        line_start  = new_line_start;\n    }\n\n    /*Make the text one line taller if the last character is '\\n' or '\\r'*/\n    if((line_start != 0) && (text[line_start - 1] == '\\n' || text[line_start - 1] == '\\r')) {\n        size_res->y += letter_height + line_space;\n    }\n\n    /*Correction with the last line space or set the height manually if the text is empty*/\n    if(size_res->y == 0)\n        size_res->y = letter_height;\n    else\n        size_res->y -= line_space;\n}"}, "lv_txt_get_next_word": {"type": "Function", "def": "static uint32_t lv_txt_get_next_word(const char * txt, const lv_font_t * font,\n                                     lv_coord_t letter_space, lv_coord_t max_width,\n                                     lv_text_flag_t flag, uint32_t * word_w_ptr, lv_text_cmd_state_t * cmd_state, bool force)", "sline": 170, "body": "{\n    if(txt == NULL || txt[0] == '\\0') return 0;\n    if(font == NULL) return 0;\n\n    if(flag & LV_TEXT_FLAG_EXPAND) max_width = LV_COORD_MAX;\n\n    uint32_t i = 0, i_next = 0, i_next_next = 0;  /*Iterating index into txt*/\n    uint32_t letter = 0;      /*Letter at i*/\n    uint32_t letter_next = 0; /*Letter at i_next*/\n    lv_coord_t letter_w;\n    lv_coord_t cur_w = 0;  /*Pixel Width of transversed string*/\n    uint32_t word_len = 0;   /*Number of characters in the transversed word*/\n    uint32_t break_index = NO_BREAK_FOUND; /*only used for \"long\" words*/\n    uint32_t break_letter_count = 0; /*Number of characters up to the long word break point*/\n\n    letter = _lv_txt_encoded_next(txt, &i_next);\n    i_next_next = i_next;\n\n    /*Obtain the full word, regardless if it fits or not in max_width*/\n    while(txt[i] != '\\0') {\n        letter_next = _lv_txt_encoded_next(txt, &i_next_next);\n        word_len++;\n\n        /*Handle the recolor command*/\n        if((flag & LV_TEXT_FLAG_RECOLOR) != 0) {\n            if(_lv_txt_is_cmd(cmd_state, letter) != false) {\n                i = i_next;\n                i_next = i_next_next;\n                letter = letter_next;\n                continue;   /*Skip the letter if it is part of a command*/\n            }\n        }\n\n        letter_w = lv_font_get_glyph_width(font, letter, letter_next);\n        cur_w += letter_w;\n\n        if(letter_w > 0) {\n            cur_w += letter_space;\n        }\n\n        /*Test if this character fits within max_width*/\n        if(break_index == NO_BREAK_FOUND && (cur_w - letter_space) > max_width) {\n            break_index = i;\n            break_letter_count = word_len - 1;\n            /*break_index is now pointing at the character that doesn't fit*/\n        }\n\n        /*Check for new line chars and breakchars*/\n        if(letter == '\\n' || letter == '\\r' || _lv_txt_is_break_char(letter)) {\n            /*Update the output width on the first character if it fits.\n             *Must do this here in case first letter is a break character.*/\n            if(i == 0 && break_index == NO_BREAK_FOUND && word_w_ptr != NULL) *word_w_ptr = cur_w;\n            word_len--;\n            break;\n        }\n\n        /*Update the output width*/\n        if(word_w_ptr != NULL && break_index == NO_BREAK_FOUND) *word_w_ptr = cur_w;\n\n        i = i_next;\n        i_next = i_next_next;\n        letter = letter_next;\n    }\n\n    /*Entire Word fits in the provided space*/\n    if(break_index == NO_BREAK_FOUND) {\n        if(word_len == 0 || (letter == '\\r' && letter_next == '\\n')) i = i_next;\n        return i;\n    }\n\n#if LV_TXT_LINE_BREAK_LONG_LEN > 0\n    /*Word doesn't fit in provided space, but isn't \"long\"*/\n    if(word_len < LV_TXT_LINE_BREAK_LONG_LEN) {\n        if(force) return break_index;\n        if(word_w_ptr != NULL) *word_w_ptr = 0; /*Return no word*/\n        return 0;\n    }\n\n    /*Word is \"long,\" but insufficient amounts can fit in provided space*/\n    if(break_letter_count < LV_TXT_LINE_BREAK_LONG_PRE_MIN_LEN) {\n        if(force) return break_index;\n        if(word_w_ptr != NULL) *word_w_ptr = 0;\n        return 0;\n    }\n\n    /*Word is a \"long\", but letters may need to be better distributed*/\n    {\n        i = break_index;\n        int32_t n_move = LV_TXT_LINE_BREAK_LONG_POST_MIN_LEN - (word_len - break_letter_count);\n        /*Move pointer \"i\" backwards*/\n        for(; n_move > 0; n_move--) {\n            _lv_txt_encoded_prev(txt, &i);\n            // TODO: it would be appropriate to update the returned word width here\n            // However, in current usage, this doesn't impact anything.\n        }\n    }\n    return i;\n#else\n    if(force) return break_index;\n    if(word_w_ptr != NULL) *word_w_ptr = 0; /*Return no word*/\n    (void) break_letter_count;\n    return 0;\n#endif\n}"}, "_lv_txt_get_next_line": {"type": "Function", "def": "uint32_t _lv_txt_get_next_line(const char * txt, const lv_font_t * font,\n                               lv_coord_t letter_space, lv_coord_t max_width, lv_text_flag_t flag)", "sline": 278, "body": "{\n    if(txt == NULL) return 0;\n    if(txt[0] == '\\0') return 0;\n    if(font == NULL) return 0;\n\n    /*If max_width doesn't mater simply find the new line character\n     *without thinking about word wrapping*/\n    if((flag & LV_TEXT_FLAG_EXPAND) || (flag & LV_TEXT_FLAG_FIT)) {\n        uint32_t i;\n        for(i = 0; txt[i] != '\\n' && txt[i] != '\\r' && txt[i] != '\\0'; i++) {\n            /*Just find the new line chars or string ends by incrementing `i`*/\n        }\n        if(txt[i] != '\\0') i++;    /*To go beyond `\\n`*/\n        return i;\n    }\n\n    if(flag & LV_TEXT_FLAG_EXPAND) max_width = LV_COORD_MAX;\n    lv_text_cmd_state_t cmd_state = LV_TEXT_CMD_STATE_WAIT;\n    uint32_t i = 0;                                        /*Iterating index into txt*/\n\n    while(txt[i] != '\\0' && max_width > 0) {\n        uint32_t word_w = 0;\n        uint32_t advance = lv_txt_get_next_word(&txt[i], font, letter_space, max_width, flag, &word_w, &cmd_state, i == 0);\n        max_width -= word_w;\n\n        if(advance == 0) {\n            if(i == 0) _lv_txt_encoded_next(txt, &i); // prevent inf loops\n            break;\n        }\n\n        i += advance;\n\n        if(txt[0] == '\\n' || txt[0] == '\\r') break;\n\n        if(txt[i] == '\\n' || txt[i] == '\\r') {\n            i++;  /*Include the following newline in the current line*/\n            break;\n        }\n\n    }\n\n    /*Always step at least one to avoid infinite loops*/\n    if(i == 0) {\n        _lv_txt_encoded_next(txt, &i);\n    }\n\n    return i;\n}"}, "lv_txt_get_width": {"type": "Function", "def": "lv_coord_t lv_txt_get_width(const char * txt, uint32_t length, const lv_font_t * font, lv_coord_t letter_space,\n                            lv_text_flag_t flag)", "sline": 329, "body": "{\n    if(txt == NULL) return 0;\n    if(font == NULL) return 0;\n    if(txt[0] == '\\0') return 0;\n\n    uint32_t i                   = 0;\n    lv_coord_t width             = 0;\n    lv_text_cmd_state_t cmd_state = LV_TEXT_CMD_STATE_WAIT;\n\n    if(length != 0) {\n        while(i < length) {\n            uint32_t letter;\n            uint32_t letter_next;\n            _lv_txt_encoded_letter_next_2(txt, &letter, &letter_next, &i);\n\n            if((flag & LV_TEXT_FLAG_RECOLOR) != 0) {\n                if(_lv_txt_is_cmd(&cmd_state, letter) != false) {\n                    continue;\n                }\n            }\n\n            lv_coord_t char_width = lv_font_get_glyph_width(font, letter, letter_next);\n            if(char_width > 0) {\n                width += char_width;\n                width += letter_space;\n            }\n        }\n\n        if(width > 0) {\n            width -= letter_space; /*Trim the last letter space. Important if the text is center\n                                      aligned*/\n        }\n    }\n\n    return width;\n}"}, "_lv_txt_is_cmd": {"type": "Function", "def": "bool _lv_txt_is_cmd(lv_text_cmd_state_t * state, uint32_t c)", "sline": 368, "body": "{\n    bool ret = false;\n\n    if(c == (uint32_t)LV_TXT_COLOR_CMD[0]) {\n        if(*state == LV_TEXT_CMD_STATE_WAIT) { /*Start char*/\n            *state = LV_TEXT_CMD_STATE_PAR;\n            ret    = true;\n        }\n        /*Other start char in parameter is escaped cmd. char*/\n        else if(*state == LV_TEXT_CMD_STATE_PAR) {\n            *state = LV_TEXT_CMD_STATE_WAIT;\n        }\n        /*Command end*/\n        else if(*state == LV_TEXT_CMD_STATE_IN) {\n            *state = LV_TEXT_CMD_STATE_WAIT;\n            ret    = true;\n        }\n    }\n\n    /*Skip the color parameter and wait the space after it*/\n    if(*state == LV_TEXT_CMD_STATE_PAR) {\n        if(c == ' ') {\n            *state = LV_TEXT_CMD_STATE_IN; /*After the parameter the text is in the command*/\n        }\n        ret = true;\n    }\n\n    return ret;\n}"}, "_lv_txt_ins": {"type": "Function", "def": "void _lv_txt_ins(char * txt_buf, uint32_t pos, const char * ins_txt)", "sline": 399, "body": "{\n    if(txt_buf == NULL || ins_txt == NULL) return;\n\n    size_t old_len = strlen(txt_buf);\n    size_t ins_len = strlen(ins_txt);\n    if(ins_len == 0) return;\n\n    size_t new_len = ins_len + old_len;\n    pos              = _lv_txt_encoded_get_byte_id(txt_buf, pos); /*Convert to byte index instead of letter index*/\n\n    /*Copy the second part into the end to make place to text to insert*/\n    size_t i;\n    for(i = new_len; i >= pos + ins_len; i--) {\n        txt_buf[i] = txt_buf[i - ins_len];\n    }\n\n    /*Copy the text into the new space*/\n    lv_memcpy_small(txt_buf + pos, ins_txt, ins_len);\n}"}, "_lv_txt_cut": {"type": "Function", "def": "void _lv_txt_cut(char * txt, uint32_t pos, uint32_t len)", "sline": 420, "body": "{\n    if(txt == NULL) return;\n\n    size_t old_len = strlen(txt);\n\n    pos = _lv_txt_encoded_get_byte_id(txt, pos); /*Convert to byte index instead of letter index*/\n    len = _lv_txt_encoded_get_byte_id(&txt[pos], len);\n\n    /*Copy the second part into the end to make place to text to insert*/\n    uint32_t i;\n    for(i = pos; i <= old_len - len; i++) {\n        txt[i] = txt[i + len];\n    }\n}"}, "_lv_txt_set_text_vfmt": {"type": "Function", "def": "char * _lv_txt_set_text_vfmt(const char * fmt, va_list ap)", "sline": 436, "body": "{\n    /*Allocate space for the new text by using trick from C99 standard section 7.19.6.12*/\n    va_list ap_copy;\n    va_copy(ap_copy, ap);\n    uint32_t len = lv_vsnprintf(NULL, 0, fmt, ap_copy);\n    va_end(ap_copy);\n\n    char * text = 0;\n#if LV_USE_ARABIC_PERSIAN_CHARS\n    /*Put together the text according to the format string*/\n    char * raw_txt = lv_mem_buf_get(len + 1);\n    LV_ASSERT_MALLOC(raw_txt);\n    if(raw_txt == NULL) {\n        return NULL;\n    }\n\n    lv_vsnprintf(raw_txt, len + 1, fmt, ap);\n\n    /*Get the size of the Arabic text and process it*/\n    size_t len_ap = _lv_txt_ap_calc_bytes_cnt(raw_txt);\n    text = lv_mem_alloc(len_ap + 1);\n    LV_ASSERT_MALLOC(text);\n    if(text == NULL) {\n        return NULL;\n    }\n    _lv_txt_ap_proc(raw_txt, text);\n\n    lv_mem_buf_release(raw_txt);\n#else\n    text = lv_mem_alloc(len + 1);\n    LV_ASSERT_MALLOC(text);\n    if(text == NULL) {\n        return NULL;\n    }\n    text[len] = 0; /*Ensure NULL termination*/\n\n    lv_vsnprintf(text, len + 1, fmt, ap);\n#endif\n\n    return text;\n}"}, "_lv_txt_encoded_letter_next_2": {"type": "Function", "def": "void _lv_txt_encoded_letter_next_2(const char * txt, uint32_t * letter, uint32_t * letter_next, uint32_t * ofs)", "sline": 479, "body": "{\n    *letter = _lv_txt_encoded_next(txt, ofs);\n    *letter_next = *letter != '\\0' ? _lv_txt_encoded_next(&txt[*ofs], NULL) : 0;\n}"}, "carbit_updater/lvgl/src/misc/lv_txt.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_txt.c"}}, "carbit_updater/lvgl/tests/src/test_cases/test_arc.c": {"carbit_updater/lvgl/tests/src/test_cases/test_arc.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/tests/src/test_cases/test_arc.c"}}, "carbit_updater/lvgl/src/misc/lv_anim.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 18}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 19}, "stddef": {"type": "Variable", "def": "#include stddef.h", "sline": 20}, "_silence_gcc_warning": {"type": "Struct", "def": "LV_EXPORT_CONST_INT(LV_ANIM_PLAYTIME_INFINITE)", "sline": 30}, "lv_anim_enable_t": {"type": "Variable", "def": "typedef enum {\n    LV_ANIM_OFF,\n    LV_ANIM_ON,\n} lv_anim_enable_t", "sline": 40, "docstring": "/** Can be used to indicate if animations are enabled or disabled in a case*/"}, "_lv_anim_t": {"type": "Struct", "def": "struct _lv_anim_t {\n    void * var;                          /**<Variable to animate*/\n    lv_anim_exec_xcb_t exec_cb;          /**< Function to execute to animate*/\n    lv_anim_start_cb_t start_cb;         /**< Call it when the animation is starts (considering `delay`)*/\n    lv_anim_ready_cb_t ready_cb;         /**< Call it when the animation is ready*/\n    lv_anim_get_value_cb_t get_value_cb; /**< Get the current value in relative mode*/\n#if LV_USE_USER_DATA\n    void * user_data; /**< Custom user data*/\n#endif\n    lv_anim_path_cb_t path_cb;         /**< Describe the path (curve) of animations*/\n    int32_t start_value;               /**< Start value*/\n    int32_t current_value;             /**< Current value*/\n    int32_t end_value;                 /**< End value*/\n    int32_t time;                /**< Animation time in ms*/\n    int32_t act_time;            /**< Current time in animation. Set to negative to make delay.*/\n    uint32_t playback_delay;     /**< Wait before play back*/\n    uint32_t playback_time;      /**< Duration of playback animation*/\n    uint32_t repeat_delay;       /**< Wait before repeat*/\n    uint16_t repeat_cnt;         /**< Repeat count for the animation*/\n    uint8_t early_apply  : 1;    /**< 1: Apply start value immediately even is there is `delay`*/\n\n    /*Animation system use these - user shouldn't set*/\n    uint8_t playback_now : 1; /**< Play back is in progress*/\n    uint8_t run_round : 1;    /**< Indicates the animation has run in this round*/\n    uint8_t start_cb_called : 1;    /**< Indicates that the `start_cb` was already called*/\n}", "sline": 69, "docstring": "/** Describes an animation*/", "body": "void * var\nlv_anim_exec_xcb_t exec_cb\nlv_anim_start_cb_t start_cb\nlv_anim_ready_cb_t ready_cb\nlv_anim_get_value_cb_t get_value_cb\nvoid * user_data\nlv_anim_path_cb_t path_cb\nint32_t start_value\nint32_t current_value\nint32_t end_value\nint32_t time\nint32_t act_time\nuint32_t playback_delay\nuint32_t playback_time\nuint32_t repeat_delay\nuint16_t repeat_cnt\nuint8_t early_apply  : 1\nuint8_t playback_now : 1\nuint8_t run_round : 1\nuint8_t start_cb_called : 1\n"}, "lv_anim_path_cb_t": {"type": "Variable", "def": "typedef int32_t (*lv_anim_path_cb_t)(const struct _lv_anim_t *)", "sline": 45, "docstring": "/** Get the current value during an animation*/"}, "lv_anim_exec_xcb_t": {"type": "Variable", "def": "typedef void (*lv_anim_exec_xcb_t)(void *, int32_t)", "sline": 53}, "lv_anim_custom_exec_cb_t": {"type": "Variable", "def": "typedef void (*lv_anim_custom_exec_cb_t)(struct _lv_anim_t *, int32_t)", "sline": 57, "docstring": "/** Same as `lv_anim_exec_xcb_t` but receives `lv_anim_t *` as the first parameter."}, "lv_anim_ready_cb_t": {"type": "Variable", "def": "typedef void (*lv_anim_ready_cb_t)(struct _lv_anim_t *)", "sline": 60, "docstring": "/** Callback to call when the animation is ready*/"}, "lv_anim_start_cb_t": {"type": "Variable", "def": "typedef void (*lv_anim_start_cb_t)(struct _lv_anim_t *)", "sline": 63, "docstring": "/** Callback to call when the animation really stars (considering `delay`)*/"}, "lv_anim_get_value_cb_t": {"type": "Variable", "def": "typedef int32_t (*lv_anim_get_value_cb_t)(struct _lv_anim_t *)", "sline": 66, "docstring": "/** Callback used when the animation values are relative to get the current value*/"}, "_lv_anim_t.var": {"type": "Variable", "def": "void * var", "sline": 70, "in_struct": "_lv_anim_t"}, "_lv_anim_t.exec_cb": {"type": "Variable", "def": "lv_anim_exec_xcb_t exec_cb", "sline": 71, "in_struct": "_lv_anim_t", "rels": [["lv_anim_exec_xcb_t", null, "Typeof"]]}, "_lv_anim_t.start_cb": {"type": "Variable", "def": "lv_anim_start_cb_t start_cb", "sline": 72, "in_struct": "_lv_anim_t", "rels": [["lv_anim_start_cb_t", null, "Typeof"]]}, "_lv_anim_t.ready_cb": {"type": "Variable", "def": "lv_anim_ready_cb_t ready_cb", "sline": 73, "in_struct": "_lv_anim_t", "rels": [["lv_anim_ready_cb_t", null, "Typeof"]]}, "_lv_anim_t.get_value_cb": {"type": "Variable", "def": "lv_anim_get_value_cb_t get_value_cb", "sline": 74, "in_struct": "_lv_anim_t", "rels": [["lv_anim_get_value_cb_t", null, "Typeof"]]}, "_lv_anim_t.user_data": {"type": "Variable", "def": "void * user_data", "sline": 76, "in_struct": "_lv_anim_t"}, "_lv_anim_t.path_cb": {"type": "Variable", "def": "lv_anim_path_cb_t path_cb", "sline": 78, "in_struct": "_lv_anim_t", "rels": [["lv_anim_path_cb_t", null, "Typeof"]]}, "_lv_anim_t.start_value": {"type": "Variable", "def": "int32_t start_value", "sline": 79, "in_struct": "_lv_anim_t"}, "_lv_anim_t.current_value": {"type": "Variable", "def": "int32_t current_value", "sline": 80, "in_struct": "_lv_anim_t"}, "_lv_anim_t.end_value": {"type": "Variable", "def": "int32_t end_value", "sline": 81, "in_struct": "_lv_anim_t"}, "_lv_anim_t.time": {"type": "Variable", "def": "int32_t time", "sline": 82, "in_struct": "_lv_anim_t"}, "_lv_anim_t.act_time": {"type": "Variable", "def": "int32_t act_time", "sline": 83, "in_struct": "_lv_anim_t"}, "_lv_anim_t.playback_delay": {"type": "Variable", "def": "uint32_t playback_delay", "sline": 84, "in_struct": "_lv_anim_t"}, "_lv_anim_t.playback_time": {"type": "Variable", "def": "uint32_t playback_time", "sline": 85, "in_struct": "_lv_anim_t"}, "_lv_anim_t.repeat_delay": {"type": "Variable", "def": "uint32_t repeat_delay", "sline": 86, "in_struct": "_lv_anim_t"}, "_lv_anim_t.repeat_cnt": {"type": "Variable", "def": "uint16_t repeat_cnt", "sline": 87, "in_struct": "_lv_anim_t"}, "_lv_anim_t.early_apply": {"type": "Variable", "def": "uint8_t early_apply  : 1", "sline": 88, "in_struct": "_lv_anim_t"}, "_lv_anim_t.playback_now": {"type": "Variable", "def": "uint8_t playback_now : 1", "sline": 91, "in_struct": "_lv_anim_t"}, "_lv_anim_t.run_round": {"type": "Variable", "def": "uint8_t run_round : 1", "sline": 92, "in_struct": "_lv_anim_t"}, "_lv_anim_t.start_cb_called": {"type": "Variable", "def": "uint8_t start_cb_called : 1", "sline": 93, "in_struct": "_lv_anim_t"}, "lv_anim_t": {"type": "Variable", "def": "typedef struct _lv_anim_t {\n    void * var;                          /**<Variable to animate*/\n    lv_anim_exec_xcb_t exec_cb;          /**< Function to execute to animate*/\n    lv_anim_start_cb_t start_cb;         /**< Call it when the animation is starts (considering `delay`)*/\n    lv_anim_ready_cb_t ready_cb;         /**< Call it when the animation is ready*/\n    lv_anim_get_value_cb_t get_value_cb; /**< Get the current value in relative mode*/\n#if LV_USE_USER_DATA\n    void * user_data; /**< Custom user data*/\n#endif\n    lv_anim_path_cb_t path_cb;         /**< Describe the path (curve) of animations*/\n    int32_t start_value;               /**< Start value*/\n    int32_t current_value;             /**< Current value*/\n    int32_t end_value;                 /**< End value*/\n    int32_t time;                /**< Animation time in ms*/\n    int32_t act_time;            /**< Current time in animation. Set to negative to make delay.*/\n    uint32_t playback_delay;     /**< Wait before play back*/\n    uint32_t playback_time;      /**< Duration of playback animation*/\n    uint32_t repeat_delay;       /**< Wait before repeat*/\n    uint16_t repeat_cnt;         /**< Repeat count for the animation*/\n    uint8_t early_apply  : 1;    /**< 1: Apply start value immediately even is there is `delay`*/\n\n    /*Animation system use these - user shouldn't set*/\n    uint8_t playback_now : 1; /**< Play back is in progress*/\n    uint8_t run_round : 1;    /**< Indicates the animation has run in this round*/\n    uint8_t start_cb_called : 1;    /**< Indicates that the `start_cb` was already called*/\n} lv_anim_t", "sline": 94, "docstring": "/** Describes an animation*/"}, "_lv_anim_core_init": {"type": "Function", "def": "void _lv_anim_core_init(void)", "sline": 103}, "lv_anim_init": {"type": "Function", "def": "void lv_anim_init(lv_anim_t * a)", "sline": 114}, "lv_anim_set_var": {"type": "Function", "def": "static inline void lv_anim_set_var(lv_anim_t * a, void * var)", "sline": 121, "body": "{\n    a->var = var;\n}"}, "lv_anim_set_exec_cb": {"type": "Function", "def": "static inline void lv_anim_set_exec_cb(lv_anim_t * a, lv_anim_exec_xcb_t exec_cb)", "sline": 133, "body": "{\n    a->exec_cb = exec_cb;\n}"}, "lv_anim_set_time": {"type": "Function", "def": "static inline void lv_anim_set_time(lv_anim_t * a, uint32_t duration)", "sline": 143, "body": "{\n    a->time = duration;\n}"}, "lv_anim_set_delay": {"type": "Function", "def": "static inline void lv_anim_set_delay(lv_anim_t * a, uint32_t delay)", "sline": 153, "body": "{\n    a->act_time = -(int32_t)(delay);\n}"}, "lv_anim_set_values": {"type": "Function", "def": "static inline void lv_anim_set_values(lv_anim_t * a, int32_t start, int32_t end)", "sline": 164, "body": "{\n    a->start_value = start;\n    a->current_value = start;\n    a->end_value = end;\n}"}, "lv_anim_set_custom_exec_cb": {"type": "Function", "def": "static inline void lv_anim_set_custom_exec_cb(lv_anim_t * a, lv_anim_custom_exec_cb_t exec_cb)", "sline": 180, "body": "{\n    a->var     = a;\n    a->exec_cb = (lv_anim_exec_xcb_t)exec_cb;\n}"}, "lv_anim_set_path_cb": {"type": "Function", "def": "static inline void lv_anim_set_path_cb(lv_anim_t * a, lv_anim_path_cb_t path_cb)", "sline": 191, "body": "{\n    a->path_cb = path_cb;\n}"}, "lv_anim_set_start_cb": {"type": "Function", "def": "static inline void lv_anim_set_start_cb(lv_anim_t * a, lv_anim_start_cb_t start_cb)", "sline": 201, "body": "{\n    a->start_cb = start_cb;\n}"}, "lv_anim_set_get_value_cb": {"type": "Function", "def": "static inline void lv_anim_set_get_value_cb(lv_anim_t * a, lv_anim_get_value_cb_t get_value_cb)", "sline": 212, "body": "{\n    a->get_value_cb = get_value_cb;\n}"}, "lv_anim_set_ready_cb": {"type": "Function", "def": "static inline void lv_anim_set_ready_cb(lv_anim_t * a, lv_anim_ready_cb_t ready_cb)", "sline": 222, "body": "{\n    a->ready_cb = ready_cb;\n}"}, "lv_anim_set_playback_time": {"type": "Function", "def": "static inline void lv_anim_set_playback_time(lv_anim_t * a, uint32_t time)", "sline": 232, "body": "{\n    a->playback_time = time;\n}"}, "lv_anim_set_playback_delay": {"type": "Function", "def": "static inline void lv_anim_set_playback_delay(lv_anim_t * a, uint32_t delay)", "sline": 242, "body": "{\n    a->playback_delay = delay;\n}"}, "lv_anim_set_repeat_count": {"type": "Function", "def": "static inline void lv_anim_set_repeat_count(lv_anim_t * a, uint16_t cnt)", "sline": 252, "body": "{\n    a->repeat_cnt = cnt;\n}"}, "lv_anim_set_repeat_delay": {"type": "Function", "def": "static inline void lv_anim_set_repeat_delay(lv_anim_t * a, uint32_t delay)", "sline": 262, "body": "{\n    a->repeat_delay = delay;\n}"}, "lv_anim_set_early_apply": {"type": "Function", "def": "static inline void lv_anim_set_early_apply(lv_anim_t * a, bool en)", "sline": 273, "body": "{\n    a->early_apply = en;\n}"}, "lv_anim_set_user_data": {"type": "Function", "def": "static inline void lv_anim_set_user_data(lv_anim_t * a, void * user_data)", "sline": 284, "body": "{\n    a->user_data = user_data;\n}"}, "lv_anim_start": {"type": "Function", "def": "lv_anim_t * lv_anim_start(const lv_anim_t * a)", "sline": 295}, "lv_anim_get_delay": {"type": "Function", "def": "static inline uint32_t lv_anim_get_delay(lv_anim_t * a)", "sline": 302, "body": "{\n    return -a->act_time;\n}"}, "lv_anim_get_playtime": {"type": "Function", "def": "uint32_t lv_anim_get_playtime(lv_anim_t * a)", "sline": 312}, "lv_anim_get_user_data": {"type": "Function", "def": "static inline void * lv_anim_get_user_data(lv_anim_t * a)", "sline": 320, "body": "{\n    return a->user_data;\n}"}, "lv_anim_del": {"type": "Function", "def": "bool lv_anim_del(void * var, lv_anim_exec_xcb_t exec_cb)", "sline": 333}, "lv_anim_del_all": {"type": "Function", "def": "void lv_anim_del_all(void)", "sline": 338}, "lv_anim_get": {"type": "Function", "def": "lv_anim_t * lv_anim_get(void * var, lv_anim_exec_xcb_t exec_cb)", "sline": 346}, "lv_anim_custom_del": {"type": "Function", "def": "static inline bool lv_anim_custom_del(lv_anim_t * a, lv_anim_custom_exec_cb_t exec_cb)", "sline": 359, "body": "{\n    return lv_anim_del(a ? a->var : NULL, (lv_anim_exec_xcb_t)exec_cb);\n}"}, "lv_anim_custom_get": {"type": "Function", "def": "static inline lv_anim_t * lv_anim_custom_get(lv_anim_t * a, lv_anim_custom_exec_cb_t exec_cb)", "sline": 373, "body": "{\n    return lv_anim_get(a ? a->var : NULL, (lv_anim_exec_xcb_t)exec_cb);\n}"}, "lv_anim_count_running": {"type": "Function", "def": "uint16_t lv_anim_count_running(void)", "sline": 382}, "lv_anim_speed_to_time": {"type": "Function", "def": "uint32_t lv_anim_speed_to_time(uint32_t speed, int32_t start, int32_t end)", "sline": 391}, "lv_anim_refr_now": {"type": "Function", "def": "void lv_anim_refr_now(void)", "sline": 399}, "lv_anim_path_linear": {"type": "Function", "def": "int32_t lv_anim_path_linear(const lv_anim_t * a)", "sline": 406}, "lv_anim_path_ease_in": {"type": "Function", "def": "int32_t lv_anim_path_ease_in(const lv_anim_t * a)", "sline": 413}, "lv_anim_path_ease_out": {"type": "Function", "def": "int32_t lv_anim_path_ease_out(const lv_anim_t * a)", "sline": 420}, "lv_anim_path_ease_in_out": {"type": "Function", "def": "int32_t lv_anim_path_ease_in_out(const lv_anim_t * a)", "sline": 427}, "lv_anim_path_overshoot": {"type": "Function", "def": "int32_t lv_anim_path_overshoot(const lv_anim_t * a)", "sline": 434}, "lv_anim_path_bounce": {"type": "Function", "def": "int32_t lv_anim_path_bounce(const lv_anim_t * a)", "sline": 441}, "lv_anim_path_step": {"type": "Function", "def": "int32_t lv_anim_path_step(const lv_anim_t * a)", "sline": 449}, "carbit_updater/lvgl/src/misc/lv_anim.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_anim.h"}}, "carbit_updater/lv_drivers/indev/XPT2046.c": {"XPT2046": {"type": "Variable", "def": "#include XPT2046.h", "sline": 9, "include": ["carbit_updater/lv_drivers/indev/XPT2046.h", null]}, "carbit_updater/lv_drivers/indev/XPT2046.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/indev/XPT2046.c"}}, "carbit_updater/lv_drivers/indev/libinput_drv.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 20}, "carbit_updater/lv_drivers/indev/libinput_drv.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/indev/libinput_drv.h"}}, "carbit_updater/lvgl/src/misc/lv_templ.c": {"_keep_pedantic_happy": {"type": "Variable", "def": "typedef int _keep_pedantic_happy", "sline": 20, "docstring": "/*This typedef exists purely to keep -Wpedantic happy when the file is empty.*/\n/*It can be removed.*/"}, "carbit_updater/lvgl/src/misc/lv_templ.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_templ.c"}}, "carbit_updater/lvgl/src/core/lv_obj_scroll.c": {"lv_obj_scroll": {"type": "Variable", "def": "#include lv_obj_scroll.h", "sline": 9, "include": ["carbit_updater/lvgl/src/core/lv_obj_scroll.h", null]}, "lv_obj": {"type": "Variable", "def": "#include lv_obj.h", "sline": 10, "include": ["carbit_updater/lvgl/src/core/lv_obj.h", null]}, "lv_indev": {"type": "Variable", "def": "#include lv_indev.h", "sline": 11, "include": ["carbit_updater/lvgl/src/core/lv_indev.h", null]}, "lv_disp": {"type": "Variable", "def": "#include lv_disp.h", "sline": 12, "include": ["carbit_updater/lvgl/src/core/lv_disp.h", null]}, "lv_indev_scroll": {"type": "Variable", "def": "#include lv_indev_scroll.h", "sline": 13, "include": ["carbit_updater/lvgl/src/core/lv_indev_scroll.h", null]}, "scroll_by_raw": {"type": "Function", "def": "static void scroll_by_raw(lv_obj_t * obj, lv_coord_t x, lv_coord_t y)", "sline": 615, "body": "{\n    if(x == 0 && y == 0) return;\n\n    lv_obj_allocate_spec_attr(obj);\n\n    obj->spec_attr->scroll.x += x;\n    obj->spec_attr->scroll.y += y;\n\n    lv_obj_move_children_by(obj, x, y, true);\n    lv_res_t res = lv_event_send(obj, LV_EVENT_SCROLL, NULL);\n    if(res != LV_RES_OK) return;\n    lv_obj_invalidate(obj);\n}"}, "scroll_x_anim": {"type": "Function", "def": "static void scroll_x_anim(void * obj, int32_t v)", "sline": 630, "body": "{\n    scroll_by_raw(obj, v + lv_obj_get_scroll_x(obj), 0);\n}"}, "scroll_y_anim": {"type": "Function", "def": "static void scroll_y_anim(void * obj, int32_t v)", "sline": 635, "body": "{\n    scroll_by_raw(obj, 0, v + lv_obj_get_scroll_y(obj));\n}"}, "scroll_anim_ready_cb": {"type": "Function", "def": "static void scroll_anim_ready_cb(lv_anim_t * a)", "sline": 640, "body": "{\n    lv_event_send(a->var, LV_EVENT_SCROLL_END, NULL);\n}"}, "scroll_area_into_view": {"type": "Function", "def": "static void scroll_area_into_view(const lv_area_t * area, lv_obj_t * child, lv_point_t * scroll_value,\n                                  lv_anim_enable_t anim_en)", "sline": 645, "body": "{\n    lv_obj_t * parent = lv_obj_get_parent(child);\n    if(!lv_obj_has_flag(parent, LV_OBJ_FLAG_SCROLLABLE)) return;\n\n    lv_dir_t scroll_dir = lv_obj_get_scroll_dir(parent);\n    lv_coord_t snap_goal = 0;\n    lv_coord_t act = 0;\n    const lv_area_t * area_tmp;\n\n    lv_coord_t y_scroll = 0;\n    lv_scroll_snap_t snap_y = lv_obj_get_scroll_snap_y(parent);\n    if(snap_y != LV_SCROLL_SNAP_NONE) area_tmp = &child->coords;\n    else area_tmp = area;\n\n    lv_coord_t border_width = lv_obj_get_style_border_width(parent, LV_PART_MAIN);\n    lv_coord_t ptop = lv_obj_get_style_pad_top(parent, LV_PART_MAIN) + border_width;\n    lv_coord_t pbottom = lv_obj_get_style_pad_bottom(parent, LV_PART_MAIN) + border_width;\n    lv_coord_t top_diff = parent->coords.y1 + ptop - area_tmp->y1 - scroll_value->y;\n    lv_coord_t bottom_diff = -(parent->coords.y2 - pbottom - area_tmp->y2 - scroll_value->y);\n    lv_coord_t parent_h = lv_obj_get_height(parent) - ptop - pbottom;\n    if((top_diff >= 0 && bottom_diff >= 0)) y_scroll = 0;\n    else if(top_diff > 0) {\n        y_scroll = top_diff;\n        /*Do not let scrolling in*/\n        lv_coord_t st = lv_obj_get_scroll_top(parent);\n        if(st - y_scroll < 0) y_scroll = 0;\n    }\n    else if(bottom_diff > 0) {\n        y_scroll = -bottom_diff;\n        /*Do not let scrolling in*/\n        lv_coord_t sb = lv_obj_get_scroll_bottom(parent);\n        if(sb + y_scroll < 0) y_scroll = 0;\n    }\n\n    switch(snap_y) {\n        case LV_SCROLL_SNAP_START:\n            snap_goal = parent->coords.y1 + ptop;\n            act = area_tmp->y1 + y_scroll;\n            y_scroll += snap_goal - act;\n            break;\n        case LV_SCROLL_SNAP_END:\n            snap_goal = parent->coords.y2 - pbottom;\n            act = area_tmp->y2 + y_scroll;\n            y_scroll += snap_goal - act;\n            break;\n        case LV_SCROLL_SNAP_CENTER:\n            snap_goal = parent->coords.y1 + ptop + parent_h / 2;\n            act = lv_area_get_height(area_tmp) / 2 + area_tmp->y1 + y_scroll;\n            y_scroll += snap_goal - act;\n            break;\n    }\n\n    lv_coord_t x_scroll = 0;\n    lv_scroll_snap_t snap_x = lv_obj_get_scroll_snap_x(parent);\n    if(snap_x != LV_SCROLL_SNAP_NONE) area_tmp = &child->coords;\n    else area_tmp = area;\n\n    lv_coord_t pleft = lv_obj_get_style_pad_left(parent, LV_PART_MAIN) + border_width;\n    lv_coord_t pright = lv_obj_get_style_pad_right(parent, LV_PART_MAIN) + border_width;\n    lv_coord_t left_diff = parent->coords.x1 + pleft - area_tmp->x1 - scroll_value->x;\n    lv_coord_t right_diff = -(parent->coords.x2 - pright - area_tmp->x2 - scroll_value->x);\n    if((left_diff >= 0 && right_diff >= 0)) x_scroll = 0;\n    else if(left_diff > 0) {\n        x_scroll = left_diff;\n        /*Do not let scrolling in*/\n        lv_coord_t sl = lv_obj_get_scroll_left(parent);\n        if(sl + x_scroll > 0) x_scroll = 0;\n    }\n    else if(right_diff > 0) {\n        x_scroll = -right_diff;\n        /*Do not let scrolling in*/\n        lv_coord_t sr = lv_obj_get_scroll_right(parent);\n        if(sr + x_scroll < 0) x_scroll = 0;\n    }\n\n    lv_coord_t parent_w = lv_obj_get_width(parent) - pleft - pright;\n    switch(snap_x) {\n        case LV_SCROLL_SNAP_START:\n            snap_goal = parent->coords.x1 + pleft;\n            act = area_tmp->x1 + x_scroll;\n            x_scroll += snap_goal - act;\n            break;\n        case LV_SCROLL_SNAP_END:\n            snap_goal = parent->coords.x2 - pright;\n            act = area_tmp->x2 + x_scroll;\n            x_scroll += snap_goal - act;\n            break;\n        case LV_SCROLL_SNAP_CENTER:\n            snap_goal = parent->coords.x1 + pleft + parent_w / 2;\n            act = lv_area_get_width(area_tmp) / 2 + area_tmp->x1 + x_scroll;\n            x_scroll += snap_goal - act;\n            break;\n    }\n\n    /*Remove any pending scroll animations.*/\n    bool y_del = lv_anim_del(parent, scroll_y_anim);\n    bool x_del = lv_anim_del(parent, scroll_x_anim);\n    if(y_del || x_del) {\n        lv_res_t res;\n        res = lv_event_send(parent, LV_EVENT_SCROLL_END, NULL);\n        if(res != LV_RES_OK) return;\n    }\n\n    if((scroll_dir & LV_DIR_LEFT) == 0 && x_scroll < 0) x_scroll = 0;\n    if((scroll_dir & LV_DIR_RIGHT) == 0 && x_scroll > 0) x_scroll = 0;\n    if((scroll_dir & LV_DIR_TOP) == 0 && y_scroll < 0) y_scroll = 0;\n    if((scroll_dir & LV_DIR_BOTTOM) == 0 && y_scroll > 0) y_scroll = 0;\n\n    scroll_value->x += anim_en == LV_ANIM_OFF ? 0 : x_scroll;\n    scroll_value->y += anim_en == LV_ANIM_OFF ? 0 : y_scroll;\n    lv_obj_scroll_by(parent, x_scroll, y_scroll, anim_en);\n}"}, "lv_obj_set_scrollbar_mode": {"type": "Function", "def": "void lv_obj_set_scrollbar_mode(lv_obj_t * obj, lv_scrollbar_mode_t mode)", "sline": 57, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_obj_allocate_spec_attr(obj);\n\n    if(obj->spec_attr->scrollbar_mode == mode) return;\n    obj->spec_attr->scrollbar_mode = mode;\n    lv_obj_invalidate(obj);\n}"}, "lv_obj_set_scroll_dir": {"type": "Function", "def": "void lv_obj_set_scroll_dir(lv_obj_t * obj, lv_dir_t dir)", "sline": 68, "body": "{\n    lv_obj_allocate_spec_attr(obj);\n\n    if(dir != obj->spec_attr->scroll_dir) {\n        obj->spec_attr->scroll_dir = dir;\n    }\n}"}, "lv_obj_set_scroll_snap_x": {"type": "Function", "def": "void lv_obj_set_scroll_snap_x(lv_obj_t * obj, lv_scroll_snap_t align)", "sline": 77, "body": "{\n    lv_obj_allocate_spec_attr(obj);\n    obj->spec_attr->scroll_snap_x = align;\n}"}, "lv_obj_set_scroll_snap_y": {"type": "Function", "def": "void lv_obj_set_scroll_snap_y(lv_obj_t * obj, lv_scroll_snap_t align)", "sline": 83, "body": "{\n    lv_obj_allocate_spec_attr(obj);\n    obj->spec_attr->scroll_snap_y = align;\n}"}, "lv_obj_get_scrollbar_mode": {"type": "Function", "def": "lv_scrollbar_mode_t lv_obj_get_scrollbar_mode(const lv_obj_t * obj)", "sline": 93, "body": "{\n    if(obj->spec_attr) return obj->spec_attr->scrollbar_mode;\n    else return LV_SCROLLBAR_MODE_AUTO;\n}"}, "lv_obj_get_scroll_dir": {"type": "Function", "def": "lv_dir_t lv_obj_get_scroll_dir(const lv_obj_t * obj)", "sline": 99, "body": "{\n    if(obj->spec_attr) return obj->spec_attr->scroll_dir;\n    else return LV_DIR_ALL;\n}"}, "lv_obj_get_scroll_snap_x": {"type": "Function", "def": "lv_scroll_snap_t lv_obj_get_scroll_snap_x(const lv_obj_t * obj)", "sline": 105, "body": "{\n    if(obj->spec_attr) return obj->spec_attr->scroll_snap_x;\n    else return LV_SCROLL_SNAP_NONE;\n}"}, "lv_obj_get_scroll_snap_y": {"type": "Function", "def": "lv_scroll_snap_t lv_obj_get_scroll_snap_y(const lv_obj_t * obj)", "sline": 111, "body": "{\n    if(obj->spec_attr) return obj->spec_attr->scroll_snap_y;\n    else return LV_SCROLL_SNAP_NONE;\n}"}, "lv_obj_get_scroll_x": {"type": "Function", "def": "lv_coord_t lv_obj_get_scroll_x(const lv_obj_t * obj)", "sline": 117, "body": "{\n    if(obj->spec_attr == NULL) return 0;\n    return -obj->spec_attr->scroll.x;\n}"}, "lv_obj_get_scroll_y": {"type": "Function", "def": "lv_coord_t lv_obj_get_scroll_y(const lv_obj_t * obj)", "sline": 123, "body": "{\n    if(obj->spec_attr == NULL) return 0;\n    return -obj->spec_attr->scroll.y;\n}"}, "lv_obj_get_scroll_top": {"type": "Function", "def": "lv_coord_t lv_obj_get_scroll_top(lv_obj_t * obj)", "sline": 129, "body": "{\n    if(obj->spec_attr == NULL) return 0;\n    return -obj->spec_attr->scroll.y;\n}"}, "lv_obj_get_scroll_bottom": {"type": "Function", "def": "lv_coord_t lv_obj_get_scroll_bottom(lv_obj_t * obj)", "sline": 135, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_coord_t child_res = LV_COORD_MIN;\n    uint32_t i;\n    uint32_t child_cnt = lv_obj_get_child_cnt(obj);\n    for(i = 0; i < child_cnt; i++) {\n        lv_obj_t * child = obj->spec_attr->children[i];\n        if(lv_obj_has_flag_any(child,  LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;\n        child_res = LV_MAX(child_res, child->coords.y2);\n    }\n\n    lv_coord_t pad_top = lv_obj_get_style_pad_top(obj, LV_PART_MAIN);\n    lv_coord_t pad_bottom = lv_obj_get_style_pad_bottom(obj, LV_PART_MAIN);\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n\n    if(child_res != LV_COORD_MIN) {\n        child_res -= (obj->coords.y2 - pad_bottom - border_width);\n    }\n\n    lv_coord_t self_h = lv_obj_get_self_height(obj);\n    self_h = self_h - (lv_obj_get_height(obj) - pad_top - pad_bottom - 2 * border_width);\n    self_h -= lv_obj_get_scroll_y(obj);\n    return LV_MAX(child_res, self_h);\n}"}, "lv_obj_get_scroll_left": {"type": "Function", "def": "lv_coord_t lv_obj_get_scroll_left(lv_obj_t * obj)", "sline": 162, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    /*Normally can't scroll the object out on the left.\n     *So simply use the current scroll position as \"left size\"*/\n    if(lv_obj_get_style_base_dir(obj, LV_PART_MAIN) != LV_BASE_DIR_RTL) {\n        if(obj->spec_attr == NULL) return 0;\n        return -obj->spec_attr->scroll.x;\n    }\n\n    /*With RTL base direction scrolling the left is normal so find the left most coordinate*/\n    lv_coord_t pad_right = lv_obj_get_style_pad_right(obj, LV_PART_MAIN);\n    lv_coord_t pad_left = lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n\n    lv_coord_t child_res = 0;\n\n    uint32_t i;\n    lv_coord_t x1 = LV_COORD_MAX;\n    uint32_t child_cnt = lv_obj_get_child_cnt(obj);\n    for(i = 0; i < child_cnt; i++) {\n        lv_obj_t * child = obj->spec_attr->children[i];\n        if(lv_obj_has_flag_any(child,  LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;\n        x1 = LV_MIN(x1, child->coords.x1);\n\n    }\n\n    if(x1 != LV_COORD_MAX) {\n        child_res = x1;\n        child_res = (obj->coords.x1 + pad_left + border_width) - child_res;\n    }\n    else {\n        child_res = LV_COORD_MIN;\n    }\n\n    lv_coord_t self_w = lv_obj_get_self_width(obj);\n    self_w = self_w - (lv_obj_get_width(obj) - pad_right - pad_left - 2 * border_width);\n    self_w += lv_obj_get_scroll_x(obj);\n\n    return LV_MAX(child_res, self_w);\n}"}, "lv_obj_get_scroll_right": {"type": "Function", "def": "lv_coord_t lv_obj_get_scroll_right(lv_obj_t * obj)", "sline": 205, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    /*With RTL base dir can't scroll to the object out on the right.\n     *So simply use the current scroll position as \"right size\"*/\n    if(lv_obj_get_style_base_dir(obj, LV_PART_MAIN) == LV_BASE_DIR_RTL) {\n        if(obj->spec_attr == NULL) return 0;\n        return obj->spec_attr->scroll.x;\n    }\n\n    /*With other base direction (LTR) scrolling to the right is normal so find the right most coordinate*/\n    lv_coord_t child_res = LV_COORD_MIN;\n    uint32_t i;\n    uint32_t child_cnt = lv_obj_get_child_cnt(obj);\n    for(i = 0; i < child_cnt; i++) {\n        lv_obj_t * child = obj->spec_attr->children[i];\n        if(lv_obj_has_flag_any(child,  LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;\n        child_res = LV_MAX(child_res, child->coords.x2);\n    }\n\n    lv_coord_t pad_right = lv_obj_get_style_pad_right(obj, LV_PART_MAIN);\n    lv_coord_t pad_left = lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n\n    if(child_res != LV_COORD_MIN) {\n        child_res -= (obj->coords.x2 - pad_right - border_width);\n    }\n\n    lv_coord_t self_w;\n    self_w = lv_obj_get_self_width(obj);\n    self_w = self_w - (lv_obj_get_width(obj) - pad_right - pad_left - 2 * border_width);\n    self_w -= lv_obj_get_scroll_x(obj);\n    return LV_MAX(child_res, self_w);\n}"}, "lv_obj_get_scroll_end": {"type": "Function", "def": "void lv_obj_get_scroll_end(struct _lv_obj_t  * obj, lv_point_t * end)", "sline": 241, "body": "{\n    lv_anim_t * a;\n    a = lv_anim_get(obj, scroll_x_anim);\n    end->x = a ? -a->end_value : lv_obj_get_scroll_x(obj);\n\n    a = lv_anim_get(obj, scroll_y_anim);\n    end->y = a ? -a->end_value : lv_obj_get_scroll_y(obj);\n}"}, "lv_obj_scroll_by": {"type": "Function", "def": "void lv_obj_scroll_by(lv_obj_t * obj, lv_coord_t x, lv_coord_t y, lv_anim_enable_t anim_en)", "sline": 255, "body": "{\n    if(x == 0 && y == 0) return;\n    if(anim_en == LV_ANIM_ON) {\n        lv_disp_t * d = lv_obj_get_disp(obj);\n        lv_anim_t a;\n        lv_anim_init(&a);\n        lv_anim_set_var(&a, obj);\n        lv_anim_set_ready_cb(&a, scroll_anim_ready_cb);\n\n        if(x) {\n            uint32_t t = lv_anim_speed_to_time((lv_disp_get_hor_res(d) * 2) >> 2, 0, x);\n            if(t < SCROLL_ANIM_TIME_MIN) t = SCROLL_ANIM_TIME_MIN;\n            if(t > SCROLL_ANIM_TIME_MAX) t = SCROLL_ANIM_TIME_MAX;\n            lv_anim_set_time(&a, t);\n            lv_coord_t sx = lv_obj_get_scroll_x(obj);\n            lv_anim_set_values(&a, -sx, -sx + x);\n            lv_anim_set_exec_cb(&a, scroll_x_anim);\n            lv_anim_set_path_cb(&a, lv_anim_path_ease_out);\n\n            lv_res_t res;\n            res = lv_event_send(obj, LV_EVENT_SCROLL_BEGIN, &a);\n            if(res != LV_RES_OK) return;\n            lv_anim_start(&a);\n        }\n\n        if(y) {\n            uint32_t t = lv_anim_speed_to_time((lv_disp_get_ver_res(d) * 2) >> 2, 0, y);\n            if(t < SCROLL_ANIM_TIME_MIN) t = SCROLL_ANIM_TIME_MIN;\n            if(t > SCROLL_ANIM_TIME_MAX) t = SCROLL_ANIM_TIME_MAX;\n            lv_anim_set_time(&a, t);\n            lv_coord_t sy = lv_obj_get_scroll_y(obj);\n            lv_anim_set_values(&a, -sy, -sy + y);\n            lv_anim_set_exec_cb(&a,  scroll_y_anim);\n            lv_anim_set_path_cb(&a, lv_anim_path_ease_out);\n\n            lv_res_t res;\n            res = lv_event_send(obj, LV_EVENT_SCROLL_BEGIN, &a);\n            if(res != LV_RES_OK) return;\n            lv_anim_start(&a);\n        }\n    }\n    else {\n        /*Remove pending animations*/\n        bool y_del = lv_anim_del(obj, scroll_y_anim);\n        bool x_del = lv_anim_del(obj, scroll_x_anim);\n        scroll_by_raw(obj, x, y);\n        if(y_del || x_del) {\n            lv_res_t res;\n            res = lv_event_send(obj, LV_EVENT_SCROLL_END, NULL);\n            if(res != LV_RES_OK) return;\n        }\n    }\n}"}, "lv_obj_scroll_to": {"type": "Function", "def": "void lv_obj_scroll_to(lv_obj_t * obj, lv_coord_t x, lv_coord_t y, lv_anim_enable_t anim_en)", "sline": 310, "body": "{\n    lv_obj_scroll_to_x(obj, x, anim_en);\n    lv_obj_scroll_to_y(obj, y, anim_en);\n}"}, "lv_obj_scroll_to_x": {"type": "Function", "def": "void lv_obj_scroll_to_x(lv_obj_t * obj, lv_coord_t x, lv_anim_enable_t anim_en)", "sline": 316, "body": "{\n    lv_anim_del(obj, scroll_x_anim);\n\n    /*Don't let scroll more then naturally possible by the size of the content*/\n    if(lv_obj_get_style_base_dir(obj, LV_PART_MAIN) != LV_BASE_DIR_RTL) {\n        if(x < 0) x = 0;\n        if(x > 0) {\n            lv_coord_t  scroll_max = lv_obj_get_scroll_left(obj) + lv_obj_get_scroll_right(obj);\n            if(scroll_max < 0) scroll_max = 0;\n\n            if(x > scroll_max) x = scroll_max;\n        }\n    }\n    else {\n        if(x > 0) x = 0;\n        if(x < 0) {\n            lv_coord_t  scroll_max = lv_obj_get_scroll_left(obj) + lv_obj_get_scroll_right(obj);\n            if(scroll_max < 0) scroll_max = 0;\n\n            if(x < -scroll_max) x = -scroll_max;\n        }\n    }\n\n    lv_coord_t scroll_x = lv_obj_get_scroll_x(obj);\n    lv_coord_t diff = -x + scroll_x;\n\n    lv_obj_scroll_by(obj, diff, 0, anim_en);\n}"}, "lv_obj_scroll_to_y": {"type": "Function", "def": "void lv_obj_scroll_to_y(lv_obj_t * obj, lv_coord_t y, lv_anim_enable_t anim_en)", "sline": 346, "body": "{\n    lv_anim_del(obj, scroll_y_anim);\n\n    /*Don't let scroll more then naturally possible by the size of the content*/\n    if(y < 0) y = 0;\n    if(y > 0) {\n        lv_coord_t  scroll_max = lv_obj_get_scroll_top(obj) + lv_obj_get_scroll_bottom(obj);\n        if(scroll_max < 0) scroll_max = 0;\n        if(y > scroll_max) y = scroll_max;\n    }\n\n    lv_coord_t scroll_y = lv_obj_get_scroll_y(obj);\n    lv_coord_t diff = -y + scroll_y;\n\n    lv_obj_scroll_by(obj, 0, diff, anim_en);\n}"}, "lv_obj_scroll_to_view": {"type": "Function", "def": "void lv_obj_scroll_to_view(lv_obj_t * obj, lv_anim_enable_t anim_en)", "sline": 364, "body": "{\n    /*Be sure the screens layout is correct*/\n    lv_obj_update_layout(obj);\n\n    lv_point_t p = {0, 0};\n    scroll_area_into_view(&obj->coords, obj, &p, anim_en);\n}"}, "lv_obj_scroll_to_view_recursive": {"type": "Function", "def": "void lv_obj_scroll_to_view_recursive(lv_obj_t * obj, lv_anim_enable_t anim_en)", "sline": 373, "body": "{\n    /*Be sure the screens layout is correct*/\n    lv_obj_update_layout(obj);\n\n    lv_point_t p = {0, 0};\n    lv_obj_t * child = obj;\n    lv_obj_t * parent = lv_obj_get_parent(child);\n    while(parent) {\n        scroll_area_into_view(&obj->coords, child, &p, anim_en);\n        child = parent;\n        parent = lv_obj_get_parent(parent);\n    }\n}"}, "lv_obj_is_scrolling": {"type": "Function", "def": "bool lv_obj_is_scrolling(const lv_obj_t * obj)", "sline": 388, "body": "{\n    lv_indev_t * indev = lv_indev_get_next(NULL);\n    while(indev) {\n        if(lv_indev_get_scroll_obj(indev) == obj) return true;\n        indev = lv_indev_get_next(indev);\n    }\n\n    return false;\n}"}, "lv_obj_update_snap": {"type": "Function", "def": "void lv_obj_update_snap(lv_obj_t * obj, lv_anim_enable_t anim_en)", "sline": 399, "body": "{\n    lv_obj_update_layout(obj);\n    lv_point_t p;\n    lv_indev_scroll_get_snap_dist(obj, &p);\n    lv_obj_scroll_by(obj, p.x, p.y, anim_en);\n}"}, "lv_obj_get_scrollbar_area": {"type": "Function", "def": "void lv_obj_get_scrollbar_area(lv_obj_t * obj, lv_area_t * hor_area, lv_area_t * ver_area)", "sline": 407, "body": "{\n    lv_area_set(hor_area, 0, 0, -1, -1);\n    lv_area_set(ver_area, 0, 0, -1, -1);\n\n    if(lv_obj_has_flag(obj, LV_OBJ_FLAG_SCROLLABLE) == false) return;\n\n    lv_dir_t sm = lv_obj_get_scrollbar_mode(obj);\n    if(sm == LV_SCROLLBAR_MODE_OFF)  return;\n\n    /*If there is no indev scrolling this object but `mode==active` return*/\n    lv_indev_t * indev = lv_indev_get_next(NULL);\n    if(sm == LV_SCROLLBAR_MODE_ACTIVE) {\n        while(indev) {\n            if(lv_indev_get_scroll_obj(indev) == obj) break;\n            indev = lv_indev_get_next(indev);\n        }\n        if(indev == NULL)  return;\n    }\n\n    lv_coord_t st = lv_obj_get_scroll_top(obj);\n    lv_coord_t sb = lv_obj_get_scroll_bottom(obj);\n    lv_coord_t sl = lv_obj_get_scroll_left(obj);\n    lv_coord_t sr = lv_obj_get_scroll_right(obj);\n\n    lv_dir_t dir = lv_obj_get_scroll_dir(obj);\n\n    bool ver_draw = false;\n    if((dir & LV_DIR_VER) &&\n       ((sm == LV_SCROLLBAR_MODE_ON) ||\n        (sm == LV_SCROLLBAR_MODE_AUTO && (st > 0 || sb > 0)) ||\n        (sm == LV_SCROLLBAR_MODE_ACTIVE && lv_indev_get_scroll_dir(indev) == LV_DIR_VER))) {\n        ver_draw = true;\n    }\n\n\n    bool hor_draw = false;\n    if((dir & LV_DIR_HOR) &&\n       ((sm == LV_SCROLLBAR_MODE_ON) ||\n        (sm == LV_SCROLLBAR_MODE_AUTO && (sl > 0 || sr > 0)) ||\n        (sm == LV_SCROLLBAR_MODE_ACTIVE && lv_indev_get_scroll_dir(indev) == LV_DIR_HOR))) {\n        hor_draw = true;\n    }\n\n    if(!hor_draw && !ver_draw) return;\n\n    bool rtl = lv_obj_get_style_base_dir(obj, LV_PART_SCROLLBAR) == LV_BASE_DIR_RTL ? true : false;\n\n    lv_coord_t end_space = lv_obj_get_style_pad_top(obj, LV_PART_SCROLLBAR);\n    lv_coord_t side_space = lv_obj_get_style_pad_right(obj, LV_PART_SCROLLBAR);\n    lv_coord_t tickness = lv_obj_get_style_width(obj, LV_PART_SCROLLBAR);\n\n    lv_coord_t obj_h = lv_obj_get_height(obj);\n    lv_coord_t obj_w = lv_obj_get_width(obj);\n\n    lv_coord_t ver_reg_space = ver_draw ? tickness + side_space : 0;\n    lv_coord_t hor_req_space = hor_draw ? tickness + side_space : 0;\n    lv_coord_t rem;\n\n    if(lv_obj_get_style_bg_opa(obj, LV_PART_SCROLLBAR) < LV_OPA_MIN &&\n       lv_obj_get_style_border_opa(obj, LV_PART_SCROLLBAR) < LV_OPA_MIN) {\n        return;\n    }\n\n    /*Draw horizontal scrollbar if the mode is ON or can be scrolled in this direction*/\n    lv_coord_t content_h = obj_h + st + sb;\n    if(ver_draw && content_h) {\n        ver_area->y1 = obj->coords.y1;\n        ver_area->y2 = obj->coords.y2;\n        if(rtl) {\n            ver_area->x1 = obj->coords.x1 + side_space;\n            ver_area->x2 = ver_area->x1 + tickness - 1;\n        }\n        else {\n            ver_area->x2 = obj->coords.x2 - side_space;\n            ver_area->x1 = ver_area->x2 - tickness + 1;\n        }\n\n        lv_coord_t sb_h = ((obj_h - end_space * 2 - hor_req_space) * obj_h) / content_h;\n        sb_h = LV_MAX(sb_h, SCROLLBAR_MIN_SIZE);\n        rem = (obj_h - end_space * 2 - hor_req_space) -\n              sb_h;  /*Remaining size from the scrollbar track that is not the scrollbar itself*/\n        lv_coord_t scroll_h = content_h - obj_h; /*The size of the content which can be really scrolled*/\n        if(scroll_h <= 0) {\n            ver_area->y1 = obj->coords.y1 + end_space;\n            ver_area->y2 = obj->coords.y2 - end_space - hor_req_space - 1;\n        }\n        else {\n            lv_coord_t sb_y = (rem * sb) / scroll_h;\n            sb_y = rem - sb_y;\n\n            ver_area->y1 = obj->coords.y1 + sb_y + end_space;\n            ver_area->y2 = ver_area->y1 + sb_h - 1;\n            if(ver_area->y1 < obj->coords.y1 + end_space) {\n                ver_area->y1 = obj->coords.y1 + end_space;\n                if(ver_area->y1 + SCROLLBAR_MIN_SIZE > ver_area->y2)ver_area->y2 = ver_area->y1 + SCROLLBAR_MIN_SIZE;\n            }\n            if(ver_area->y2 > obj->coords.y2 - hor_req_space - end_space) {\n                ver_area->y2 = obj->coords.y2 - hor_req_space - end_space;\n                if(ver_area->y2 - SCROLLBAR_MIN_SIZE < ver_area->y1)ver_area->y1 = ver_area->y2 - SCROLLBAR_MIN_SIZE;\n            }\n        }\n    }\n\n    /*Draw horizontal scrollbar if the mode is ON or can be scrolled in this direction*/\n    lv_coord_t content_w = obj_w + sl + sr;\n    if(hor_draw && content_w) {\n        hor_area->y2 = obj->coords.y2 - side_space;\n        hor_area->y1 = hor_area->y2 - tickness + 1;\n        hor_area->x1 = obj->coords.x1;\n        hor_area->x2 = obj->coords.x2;\n\n        lv_coord_t sb_w = ((obj_w - end_space * 2 - ver_reg_space) * obj_w) / content_w;\n        sb_w = LV_MAX(sb_w, SCROLLBAR_MIN_SIZE);\n        rem = (obj_w - end_space * 2 - ver_reg_space) -\n              sb_w;  /*Remaining size from the scrollbar track that is not the scrollbar itself*/\n        lv_coord_t scroll_w = content_w - obj_w; /*The size of the content which can be really scrolled*/\n        if(scroll_w <= 0) {\n            if(rtl) {\n                hor_area->x1 = obj->coords.x1 + end_space + ver_reg_space - 1;\n                hor_area->x2 = obj->coords.x2 - end_space;\n            }\n            else {\n                hor_area->x1 = obj->coords.x1 + end_space;\n                hor_area->x2 = obj->coords.x2 - end_space - ver_reg_space - 1;\n            }\n        }\n        else {\n            lv_coord_t sb_x = (rem * sr) / scroll_w;\n            sb_x = rem - sb_x;\n\n            if(rtl) {\n                hor_area->x1 = obj->coords.x1 + sb_x + end_space + ver_reg_space;\n                hor_area->x2 = hor_area->x1 + sb_w - 1;\n                if(hor_area->x1 < obj->coords.x1 + end_space + ver_reg_space) {\n                    hor_area->x1 = obj->coords.x1 + end_space + ver_reg_space;\n                    if(hor_area->x1 + SCROLLBAR_MIN_SIZE > hor_area->x2) hor_area->x2 = hor_area->x1 + SCROLLBAR_MIN_SIZE;\n                }\n                if(hor_area->x2 > obj->coords.x2 - end_space) {\n                    hor_area->x2 = obj->coords.x2 - end_space;\n                    if(hor_area->x2 - SCROLLBAR_MIN_SIZE < hor_area->x1) hor_area->x1 = hor_area->x2 - SCROLLBAR_MIN_SIZE;\n                }\n            }\n            else {\n                hor_area->x1 = obj->coords.x1 + sb_x + end_space;\n                hor_area->x2 = hor_area->x1 + sb_w - 1;\n                if(hor_area->x1 < obj->coords.x1 + end_space) {\n                    hor_area->x1 = obj->coords.x1 + end_space;\n                    if(hor_area->x1 + SCROLLBAR_MIN_SIZE > hor_area->x2) hor_area->x2 = hor_area->x1 + SCROLLBAR_MIN_SIZE;\n                }\n                if(hor_area->x2 > obj->coords.x2 - ver_reg_space - end_space) {\n                    hor_area->x2 = obj->coords.x2 - ver_reg_space - end_space;\n                    if(hor_area->x2 - SCROLLBAR_MIN_SIZE < hor_area->x1) hor_area->x1 = hor_area->x2 - SCROLLBAR_MIN_SIZE;\n                }\n            }\n        }\n    }\n}"}, "lv_obj_scrollbar_invalidate": {"type": "Function", "def": "void lv_obj_scrollbar_invalidate(lv_obj_t * obj)", "sline": 566, "body": "{\n    lv_area_t hor_area;\n    lv_area_t ver_area;\n    lv_obj_get_scrollbar_area(obj, &hor_area, &ver_area);\n\n    if(lv_area_get_size(&hor_area) <= 0 && lv_area_get_size(&ver_area) <= 0) return;\n\n    if(lv_area_get_size(&hor_area) > 0) lv_obj_invalidate_area(obj, &hor_area);\n    if(lv_area_get_size(&ver_area) > 0) lv_obj_invalidate_area(obj, &ver_area);\n}"}, "lv_obj_readjust_scroll": {"type": "Function", "def": "void lv_obj_readjust_scroll(lv_obj_t * obj, lv_anim_enable_t anim_en)", "sline": 578, "body": "{\n    /*Be sure the bottom side is not remains scrolled in*/\n    /*With snapping the content can't be scrolled in*/\n    if(lv_obj_get_scroll_snap_y(obj) == LV_SCROLL_SNAP_NONE) {\n        lv_coord_t st = lv_obj_get_scroll_top(obj);\n        lv_coord_t sb = lv_obj_get_scroll_bottom(obj);\n        if(sb < 0 && st > 0) {\n            sb = LV_MIN(st, -sb);\n            lv_obj_scroll_by(obj, 0, sb, anim_en);\n        }\n    }\n\n    if(lv_obj_get_scroll_snap_x(obj) == LV_SCROLL_SNAP_NONE) {\n        lv_coord_t sl = lv_obj_get_scroll_left(obj);\n        lv_coord_t sr = lv_obj_get_scroll_right(obj);\n        if(lv_obj_get_style_base_dir(obj, LV_PART_MAIN) != LV_BASE_DIR_RTL) {\n            /*Be sure the left side is not remains scrolled in*/\n            if(sr < 0 && sl > 0) {\n                sr = LV_MIN(sl, -sr);\n                lv_obj_scroll_by(obj, sr, 0, anim_en);\n            }\n        }\n        else {\n            /*Be sure the right side is not remains scrolled in*/\n            if(sl < 0 && sr > 0) {\n                sr = LV_MIN(sr, -sl);\n                lv_obj_scroll_by(obj, sl, 0, anim_en);\n            }\n        }\n    }\n}"}, "carbit_updater/lvgl/src/core/lv_obj_scroll.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_scroll.c"}}, "carbit_updater/lvgl/src/widgets/lv_roller.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "lv_obj": {"type": "Variable", "def": "#include ../core/lv_obj.h", "sline": 20}, "lv_label": {"type": "Variable", "def": "#include lv_label.h", "sline": 21, "include": ["carbit_updater/lvgl/src/widgets/lv_label.h", null]}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_roller.h:32:1)": {"type": "Enum", "def": "enum {\n    LV_ROLLER_MODE_NORMAL, /**< Normal mode (roller ends at the end of the options).*/\n    LV_ROLLER_MODE_INFINITE, /**< Infinite mode (roller can be scrolled forever).*/\n}", "sline": 32, "docstring": "/** Roller mode.*/"}, "lv_roller_mode_t": {"type": "Variable", "def": "typedef uint8_t lv_roller_mode_t", "sline": 37}, "lv_roller_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 40, "in_struct": "lv_roller_t"}, "lv_roller_t.option_cnt": {"type": "Variable", "def": "uint16_t option_cnt", "sline": 41, "in_struct": "lv_roller_t"}, "lv_roller_t.sel_opt_id": {"type": "Variable", "def": "uint16_t sel_opt_id", "sline": 42, "in_struct": "lv_roller_t"}, "lv_roller_t.sel_opt_id_ori": {"type": "Variable", "def": "uint16_t sel_opt_id_ori", "sline": 43, "in_struct": "lv_roller_t"}, "lv_roller_t.mode": {"type": "Variable", "def": "lv_roller_mode_t mode : 1", "sline": 44, "in_struct": "lv_roller_t", "rels": [["lv_roller_mode_t", null, "Typeof"]]}, "lv_roller_t.moved": {"type": "Variable", "def": "uint32_t moved : 1", "sline": 45, "in_struct": "lv_roller_t"}, "lv_roller_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    uint16_t option_cnt;          /**< Number of options*/\n    uint16_t sel_opt_id;          /**< Index of the current option*/\n    uint16_t sel_opt_id_ori;      /**< Store the original index on focus*/\n    lv_roller_mode_t mode : 1;\n    uint32_t moved : 1;\n} lv_roller_t", "sline": 46}, "lv_roller_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_roller_class", "sline": 48}, "lv_roller_create": {"type": "Function", "def": "lv_obj_t * lv_roller_create(lv_obj_t * parent)", "sline": 60}, "lv_roller_set_options": {"type": "Function", "def": "void lv_roller_set_options(lv_obj_t * obj, const char * options, lv_roller_mode_t mode)", "sline": 72}, "lv_roller_set_selected": {"type": "Function", "def": "void lv_roller_set_selected(lv_obj_t * obj, uint16_t sel_opt, lv_anim_enable_t anim)", "sline": 80}, "lv_roller_set_visible_row_count": {"type": "Function", "def": "void lv_roller_set_visible_row_count(lv_obj_t * obj, uint8_t row_cnt)", "sline": 87}, "lv_roller_get_selected": {"type": "Function", "def": "uint16_t lv_roller_get_selected(const lv_obj_t * obj)", "sline": 98}, "lv_roller_get_selected_str": {"type": "Function", "def": "void lv_roller_get_selected_str(const lv_obj_t * obj, char * buf, uint32_t buf_size)", "sline": 106}, "lv_roller_get_options": {"type": "Function", "def": "const char * lv_roller_get_options(const lv_obj_t * obj)", "sline": 114}, "lv_roller_get_option_cnt": {"type": "Function", "def": "uint16_t lv_roller_get_option_cnt(const lv_obj_t * obj)", "sline": 121}, "carbit_updater/lvgl/src/widgets/lv_roller.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_roller.h"}}, "carbit_updater/lv_drivers/display/sunxig2d.c": {"sunxig2d": {"type": "Variable", "def": "#include sunxig2d.h", "sline": 9, "include": ["carbit_updater/lv_drivers/display/sunxig2d.h", null]}, "carbit_updater/lv_drivers/display/sunxig2d.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/sunxig2d.c"}}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.c": {"lv_conf_internal": {"type": "Variable", "def": "#include ../../lv_conf_internal.h", "sline": 10}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_lru.c"}}, "carbit_updater/lvgl/src/core/lv_indev.h": {"lv_obj": {"type": "Variable", "def": "#include lv_obj.h", "sline": 16, "include": ["carbit_updater/lvgl/src/core/lv_obj.h", null]}, "lv_hal_indev": {"type": "Variable", "def": "#include ../hal/lv_hal_indev.h", "sline": 17}, "lv_group": {"type": "Variable", "def": "#include lv_group.h", "sline": 18, "include": ["carbit_updater/lvgl/src/core/lv_group.h", null]}, "lv_indev_read_timer_cb": {"type": "Function", "def": "void lv_indev_read_timer_cb(lv_timer_t * timer)", "sline": 36}, "lv_indev_enable": {"type": "Function", "def": "void lv_indev_enable(lv_indev_t * indev, bool en)", "sline": 39}, "lv_indev_get_act": {"type": "Function", "def": "lv_indev_t * lv_indev_get_act(void)", "sline": 46}, "lv_indev_get_type": {"type": "Function", "def": "lv_indev_type_t lv_indev_get_type(const lv_indev_t * indev)", "sline": 53}, "lv_indev_reset": {"type": "Function", "def": "void lv_indev_reset(lv_indev_t * indev, lv_obj_t * obj)", "sline": 60}, "lv_indev_reset_long_press": {"type": "Function", "def": "void lv_indev_reset_long_press(lv_indev_t * indev)", "sline": 66}, "lv_indev_set_cursor": {"type": "Function", "def": "void lv_indev_set_cursor(lv_indev_t * indev, lv_obj_t * cur_obj)", "sline": 73}, "lv_indev_set_group": {"type": "Function", "def": "void lv_indev_set_group(lv_indev_t * indev, lv_group_t * group)", "sline": 80}, "lv_indev_set_button_points": {"type": "Function", "def": "void lv_indev_set_button_points(lv_indev_t * indev, const lv_point_t points[])", "sline": 88}, "lv_indev_get_point": {"type": "Function", "def": "void lv_indev_get_point(const lv_indev_t * indev, lv_point_t * point)", "sline": 95}, "lv_indev_get_gesture_dir": {"type": "Function", "def": "lv_dir_t lv_indev_get_gesture_dir(const lv_indev_t * indev)", "sline": 102}, "lv_indev_get_key": {"type": "Function", "def": "uint32_t lv_indev_get_key(const lv_indev_t * indev)", "sline": 109}, "lv_indev_get_scroll_dir": {"type": "Function", "def": "lv_dir_t lv_indev_get_scroll_dir(const lv_indev_t * indev)", "sline": 118}, "lv_indev_get_scroll_obj": {"type": "Function", "def": "lv_obj_t * lv_indev_get_scroll_obj(const lv_indev_t * indev)", "sline": 126}, "lv_indev_get_vect": {"type": "Function", "def": "void lv_indev_get_vect(const lv_indev_t * indev, lv_point_t * point)", "sline": 134}, "lv_indev_wait_release": {"type": "Function", "def": "void lv_indev_wait_release(lv_indev_t * indev)", "sline": 140}, "lv_indev_get_obj_act": {"type": "Function", "def": "lv_obj_t * lv_indev_get_obj_act(void)", "sline": 146}, "lv_indev_get_read_timer": {"type": "Function", "def": "lv_timer_t * lv_indev_get_read_timer(lv_disp_t * indev)", "sline": 154}, "lv_indev_search_obj": {"type": "Function", "def": "lv_obj_t * lv_indev_search_obj(lv_obj_t * obj, lv_point_t * point)", "sline": 162}, "carbit_updater/lvgl/src/core/lv_indev.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_indev.h"}}, "carbit_updater/lvgl/src/misc/lv_txt_ap.c": {"stddef": {"type": "Variable", "def": "#include stddef.h", "sline": 9}, "lv_bidi": {"type": "Variable", "def": "#include lv_bidi.h", "sline": 10, "include": ["carbit_updater/lvgl/src/misc/lv_bidi.h", null]}, "lv_txt": {"type": "Variable", "def": "#include lv_txt.h", "sline": 11, "include": ["carbit_updater/lvgl/src/misc/lv_txt.h", null]}, "lv_txt_ap": {"type": "Variable", "def": "#include lv_txt_ap.h", "sline": 12, "include": ["carbit_updater/lvgl/src/misc/lv_txt_ap.h", null]}, "lv_mem": {"type": "Variable", "def": "#include lv_mem.h", "sline": 13, "include": ["carbit_updater/lvgl/src/misc/lv_mem.h", null]}, "lv_draw": {"type": "Variable", "def": "#include ../draw/lv_draw.h", "sline": 14}, "ap_chars_map_t.char_offset": {"type": "Variable", "def": "uint8_t char_offset", "sline": 24, "in_struct": "ap_chars_map_t"}, "ap_chars_map_t.char_end_form": {"type": "Variable", "def": "uint16_t char_end_form", "sline": 25, "in_struct": "ap_chars_map_t"}, "ap_chars_map_t.char_begining_form_offset": {"type": "Variable", "def": "int8_t char_begining_form_offset", "sline": 26, "in_struct": "ap_chars_map_t"}, "ap_chars_map_t.char_middle_form_offset": {"type": "Variable", "def": "int8_t char_middle_form_offset", "sline": 27, "in_struct": "ap_chars_map_t"}, "ap_chars_map_t.char_isolated_form_offset": {"type": "Variable", "def": "int8_t char_isolated_form_offset", "sline": 28, "in_struct": "ap_chars_map_t"}, "ap_chars_map_t.ap_chars_conjunction": {"type": "Variable", "def": "struct {\n        uint8_t conj_to_previous;\n        uint8_t conj_to_next;\n    } ap_chars_conjunction", "sline": 32, "in_struct": "ap_chars_map_t"}, "ap_chars_map_t": {"type": "Variable", "def": "typedef struct {\n    uint8_t char_offset;\n    uint16_t char_end_form;\n    int8_t char_begining_form_offset;\n    int8_t char_middle_form_offset;\n    int8_t char_isolated_form_offset;\n    struct {\n        uint8_t conj_to_previous;\n        uint8_t conj_to_next;\n    } ap_chars_conjunction;\n} ap_chars_map_t", "sline": 33, "docstring": "/**********************"}, "carbit_updater/lvgl/src/misc/lv_txt_ap.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_txt_ap.c"}}, "carbit_updater/lvgl/src/misc/lv_async.c": {"lv_async": {"type": "Variable", "def": "#include lv_async.h", "sline": 10, "include": ["carbit_updater/lvgl/src/misc/lv_async.h", null]}, "lv_mem": {"type": "Variable", "def": "#include lv_mem.h", "sline": 11, "include": ["carbit_updater/lvgl/src/misc/lv_mem.h", null]}, "lv_timer": {"type": "Variable", "def": "#include lv_timer.h", "sline": 12, "include": ["carbit_updater/lvgl/src/misc/lv_timer.h", null]}, "_lv_async_info_t.cb": {"type": "Variable", "def": "lv_async_cb_t cb", "sline": 23, "in_struct": "_lv_async_info_t"}, "_lv_async_info_t.user_data": {"type": "Variable", "def": "void * user_data", "sline": 24, "in_struct": "_lv_async_info_t"}, "_lv_async_info_t": {"type": "Struct", "def": "struct _lv_async_info_t {\n    lv_async_cb_t cb;\n    void * user_data;\n}", "sline": 22, "body": "lv_async_cb_t cb\nvoid * user_data\n"}, "lv_async_info_t": {"type": "Variable", "def": "typedef struct _lv_async_info_t {\n    lv_async_cb_t cb;\n    void * user_data;\n} lv_async_info_t", "sline": 25}, "lv_async_timer_cb": {"type": "Function", "def": "static void lv_async_timer_cb(lv_timer_t * timer)", "sline": 72, "body": "{\n    lv_async_info_t * info = (lv_async_info_t *)timer->user_data;\n\n    info->cb(info->user_data);\n    lv_mem_free(info);\n}"}, "lv_async_call": {"type": "Function", "def": "lv_res_t lv_async_call(lv_async_cb_t async_xcb, void * user_data)", "sline": 45, "body": "{\n    /*Allocate an info structure*/\n    lv_async_info_t * info = lv_mem_alloc(sizeof(lv_async_info_t));\n\n    if(info == NULL)\n        return LV_RES_INV;\n\n    /*Create a new timer*/\n    lv_timer_t * timer = lv_timer_create(lv_async_timer_cb, 0, info);\n\n    if(timer == NULL) {\n        lv_mem_free(info);\n        return LV_RES_INV;\n    }\n\n    info->cb = async_xcb;\n    info->user_data = user_data;\n\n    lv_timer_set_repeat_count(timer, 1);\n    return LV_RES_OK;\n}"}, "carbit_updater/lvgl/src/misc/lv_async.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_async.c"}}, "carbit_updater/lvgl/tests/src/test_cases/test_obj_tree.c": {"carbit_updater/lvgl/tests/src/test_cases/test_obj_tree.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/tests/src/test_cases/test_obj_tree.c"}}, "carbit_updater/updateui.c": {"errno": {"type": "Variable", "def": "#include errno.h", "sline": 1}, "fcntl": {"type": "Variable", "def": "#include fcntl.h", "sline": 2}, "getopt": {"type": "Variable", "def": "#include getopt.h", "sline": 3}, "string": {"type": "Variable", "def": "#include string.h", "sline": 4}, "stdlib": {"type": "Variable", "def": "#include stdlib.h", "sline": 5}, "stdio": {"type": "Variable", "def": "#include stdio.h", "sline": 6}, "mman": {"type": "Variable", "def": "#include sys/mman.h", "sline": 7}, "ioctl": {"type": "Variable", "def": "#include sys/ioctl.h", "sline": 8}, "socket": {"type": "Variable", "def": "#include sys/socket.h", "sline": 9}, "un": {"type": "Variable", "def": "#include sys/un.h", "sline": 10}, "uio": {"type": "Variable", "def": "#include sys/uio.h", "sline": 11}, "stat": {"type": "Variable", "def": "#include sys/stat.h", "sline": 12}, "types": {"type": "Variable", "def": "#include sys/types.h", "sline": 13}, "unistd": {"type": "Variable", "def": "#include unistd.h", "sline": 14}, "pthread": {"type": "Variable", "def": "#include pthread.h", "sline": 15}, "lvgl": {"type": "Variable", "def": "#include lvgl/lvgl.h", "sline": 18, "include": ["carbit_updater/lvgl/lvgl.h", null]}, "sunxifb": {"type": "Variable", "def": "#include lv_drivers/display/sunxifb.h", "sline": 19, "include": ["carbit_updater/lv_drivers/display/sunxifb.h", null]}, "evdev": {"type": "Variable", "def": "#include lv_drivers/indev/evdev.h", "sline": 20, "include": ["carbit_updater/lv_drivers/indev/evdev.h", null]}, "properties": {"type": "Variable", "def": "#include properties.h", "sline": 21, "include": ["carbit_updater/include/properties.h", null]}, "custom_tick_get": {"type": "Function", "def": "uint32_t custom_tick_get(void)", "sline": 25, "body": "{\n    uint32_t start_ms = 0;\n    struct timespec now;\n    clock_gettime(CLOCK_MONOTONIC, &now);\n    start_ms = now.tv_sec * 1000 + now.tv_nsec / 1000000;\n    return start_ms;\n}"}, "mcu_write_inst_state": {"type": "Function", "def": "extern void mcu_write_inst_state()", "sline": 34}, "getProcess": {"type": "Function", "def": "extern int getProcess()", "sline": 35}, "ifUpdateDone": {"type": "Function", "def": "extern int ifUpdateDone()", "sline": 36}, "getLanguage": {"type": "Function", "def": "int getLanguage()", "sline": 162, "body": "{\n    char value[256];\n    memset(value, 0, 256);\n    property_get(\"carbit.instrument.language\", value, \"none\");\n    if (!strcmp(value, \"ENGLISH\") )\n    {\n        lang = 1;\n    }\n    else if (!strcmp(value, \"SPANISH\") )\n    {\n        lang = 2;\n    }\n    else\n    {\n        lang = 0;\n    }\n\n    return lang;\n}"}, "update_font_32": {"type": "Variable", "def": "", "sline": 38}, "_progress": {"type": "Variable", "def": "static lv_obj_t *_progress", "sline": 39}, "_label": {"type": "Variable", "def": "static lv_obj_t *_progress, *_label", "sline": 39}, "_text_label": {"type": "Variable", "def": "static lv_obj_t *_progress, *_label, *_text_label", "sline": 39}, "lang": {"type": "Variable", "def": "static int lang = 0", "sline": 40}, "curr_step": {"type": "Variable", "def": "static int lang = 0, curr_step = 0", "sline": 40}, "curr_state": {"type": "Variable", "def": "static int lang = 0, curr_step = 0, curr_state = 0", "sline": 40}, "carbit_update_text_t": {"type": "Variable", "def": "typedef enum\n{\n    TEXT_UPDATING_APP = 0,\n    TEXT_UPDATING_MCU,\n    TEXT_UPDATE_APP_FAIL,\n    TEXT_UPDATE_MCU_FAIL,\n    TEXT_UPDATE_DONE,\n\n    TEXT_LAST\n} carbit_update_text_t", "sline": 55}, "_text_local": {"type": "Variable", "def": "static char *_text_local[3][TEXT_LAST] =\n    {\n        {\n            \"\u6b63\u5728\u5347\u7ea7APP,\u8bf7\u52ff\u65ad\u7535\",\n            \"\u6b63\u5728\u5347\u7ea7MCU,\u8bf7\u52ff\u65ad\u7535\",\n            \"APP\u5347\u7ea7Failed...\",\n            \"MCU\u5347\u7ea7Failed...\",\n            \"\u5347\u7ea7\u5df2\u5b8c\u6210,\u8bf7\u65ad\u7535\u91cd\u542f\"\n         },\n#ifdef VER_CRCP07         \n        {\n            \"Upgrading APP,\\n please do not power off\",\n            \"Upgrading MCU, \\nplease do not power off\",\n            \"APP upgrade Failed\u2026\",\n            \"MCU upgrade Failed\u2026\",\n            \"The upgrade is complete,\\n please power off and restart\"\n         },\n         {\n            \"Est\u00e1 actualizando la APP,\\n por favor no apagues\",\n            \"Est\u00e1 actualizando la MCU,\\n por favor no apagues\",\n            \"APP actualiza fallida...\",\n            \"MCU actualiza fallida...\",\n            \"La actualizaci\u00f3n est\u00e1 completa,\\n por favor apague y reinicie\",\n\n         }\n#else\n        {\n            \"Upgrading APP, please do not power off\",\n            \"Upgrading MCU, please do not power off\",\n            \"APP upgrade Failed\u2026\",\n            \"MCU upgrade Failed\u2026\",\n            \"The upgrade is complete, please power off and restart\"\n         },\n         {\n            \"Est\u00e1 actualizando la APP, por favor no apagues\",\n            \"Est\u00e1 actualizando la MCU, por favor no apagues\",\n            \"APP actualiza fallida...\",\n            \"MCU actualiza fallida...\",\n            \"La actualizaci\u00f3n est\u00e1 completa, por favor apague y reinicie\",\n         }\n#endif         \n    }", "sline": 73}, "create_page_upgrade": {"type": "Function", "def": "lv_obj_t *create_page_upgrade()", "sline": 116, "body": "{\n    lv_obj_t *page = lv_obj_create(NULL);\n    lv_obj_set_size(page, LV_HOR_RES_MAX, LV_VER_RES_MAX);\n    ALOGD(\"create_page_upgrade >>>>> width:%d,height:%d\", LV_HOR_RES_MAX, LV_VER_RES_MAX);\n    lv_obj_set_style_bg_opa(page, LV_OPA_COVER, 0);\n    lv_obj_set_style_bg_color(page, lv_color_white(), 0);\n\n    _progress = lv_arc_create(page);\n    lv_obj_set_size(_progress, 200, 200);\n    lv_arc_set_bg_angles(_progress, 0, 360);\n    lv_arc_set_start_angle(_progress, 0);\n    lv_arc_set_end_angle(_progress, 0);\n    lv_arc_set_rotation(_progress, 90);\n    lv_obj_set_style_arc_color(_progress, lv_color_hex(0xe0e0e0), 0);\n    lv_obj_set_style_arc_width(_progress, 12, 0);\n    lv_obj_set_style_arc_color(_progress, lv_color_hex(0x2196f3), LV_PART_INDICATOR);\n    lv_obj_set_style_arc_width(_progress, 12, LV_PART_INDICATOR);\n    lv_obj_remove_style(_progress, NULL, LV_PART_KNOB);\n    lv_obj_clear_flag(_progress, LV_OBJ_FLAG_CLICKABLE);\n    lv_obj_align(_progress, LV_ALIGN_CENTER, 0, -50);\n\n    _label = lv_label_create(page);\n    lv_obj_set_width(_label, 400);\n    lv_obj_set_style_text_align(_label, LV_TEXT_ALIGN_CENTER, 0);\n    lv_obj_set_style_text_color(_label, lv_color_black(), 0);\n    lv_obj_set_style_text_font(_label, &update_font_32, 0);\n    // lv_obj_align_to(_label, _progress, LV_ALIGN_OUT_BOTTOM_MID, 0, 10);\n    lv_obj_align_to(_label, _progress, LV_ALIGN_CENTER, 0, -10);\n    lv_label_set_text(_label, \"0%%\");\n\n    _text_label = lv_label_create(page);\n    lv_obj_set_size(_text_label, 600, 100);\n#ifdef VER_CRCP07\n    lv_obj_align(_text_label, LV_ALIGN_CENTER, 0, 110);\n    ALOGD(\"create_page_upgrade LV_ALIGN_CENTER:110\");\n#else\n    lv_obj_set_pos(_text_label, 100, 320);\n#endif\n    lv_obj_set_style_text_align(_text_label, LV_TEXT_ALIGN_CENTER, 0);\n    lv_obj_set_style_text_color(_text_label, lv_color_black(), 0);\n    lv_obj_set_style_text_font(_text_label, &update_font_32, 0);\n    lv_label_set_text(_text_label, _text_local[lang][TEXT_UPDATING_APP]);\n    return page;\n}"}, "update_upgrade_progress": {"type": "Function", "def": "void update_upgrade_progress()", "sline": 182, "body": "{\n    int progress = getProcess();\n    if (progress > 100)\n        progress = 100;\n    if (progress >= 100 && !ifUpdateDone())\n        progress = 99;\n    if (_progress)\n    {\n        lv_arc_set_end_angle(_progress, progress * 360 / 100);\n    }\n\n    if (_label)\n    {\n        if (ifUpdateDone())\n        {\n            if (progress >= 100)\n                lv_label_set_text(_text_label, _text_local[lang][TEXT_UPDATE_DONE]);\n        }\n        lv_label_set_text_fmt(_label, \"%d %%\", progress);\n    }\n    \n    char value[64]={0};    \n    sprintf(value,\"%d\",progress);\n    property_set(\"carbit.firmware.update.progress\",value);\n\n}"}, "updateui_handle_step": {"type": "Function", "def": "void updateui_handle_step(int step, int state)", "sline": 209, "body": "{\n    // \u8bbe\u7f6e\u5347\u7ea7\u8fc7\u7a0b\n    curr_step = step;\n    curr_state = state;\n}"}, "open_brightness": {"type": "Function", "def": "static void open_brightness(int value)", "sline": 215, "body": "{\n  char buf[16] = {0};\n  snprintf(buf, sizeof(buf), \"%d\", value);\n  int len = strlen(buf);\n  int fd = open(\"/sys/class/backlight/rk28_bl/brightness\", O_RDWR);\n  write(fd, buf, len);\n  close(fd);\n}"}, "ui_showing": {"type": "Variable", "def": "int ui_showing = 0", "sline": 224}, "upgrade_page": {"type": "Variable", "def": "lv_obj_t *upgrade_page", "sline": 225}, "updateui_handle_thread": {"type": "Function", "def": "void *updateui_handle_thread(void *arg)", "sline": 226, "body": "{\n    int cnt = 0;\n     /*LittlevGL init*/\n    lv_init();\n\n    uint32_t rotated = LV_DISP_ROT_NONE;\n\n    /*Linux frame buffer device init*/\n    sunxifb_init(rotated);\n\n    /*A buffer for LittlevGL to draw the screen's content*/\n    static uint32_t width, height;\n    sunxifb_get_sizes(&width, &height);\n\n    static lv_color_t *buf;\n    buf = (lv_color_t*) sunxifb_alloc(width * height * sizeof(lv_color_t),\n            \"lv_examples\");\n\n    if (buf == NULL) {\n        sunxifb_exit();\n        printf(\"malloc draw buffer fail\\n\");\n        return 0;\n    }\n\n    /*Initialize a descriptor for the buffer*/\n    static lv_disp_draw_buf_t disp_buf;\n    lv_disp_draw_buf_init(&disp_buf, buf, NULL, width * height);\n\n    /*Initialize and register a display driver*/\n    static lv_disp_drv_t disp_drv;\n    lv_disp_drv_init(&disp_drv);\n    disp_drv.draw_buf   = &disp_buf;\n    disp_drv.flush_cb   = sunxifb_flush;\n    disp_drv.hor_res    = width;\n    disp_drv.ver_res    = height;\n    disp_drv.rotated    = rotated;\n#ifndef USE_SUNXIFB_G2D_ROTATE\n    if (rotated != LV_DISP_ROT_NONE)\n        disp_drv.sw_rotate = 1;\n#endif\n    lv_disp_drv_register(&disp_drv);\n\n    evdev_init();\n    static lv_indev_drv_t indev_drv;\n    lv_indev_drv_init(&indev_drv);                /*Basic initialization*/\n    indev_drv.type =LV_INDEV_TYPE_POINTER;        /*See below.*/\n    indev_drv.read_cb = evdev_read;               /*See below.*/\n    /*Register the driver in LVGL and save the created input device object*/\n    lv_indev_t * evdev_indev = lv_indev_drv_register(&indev_drv);\n\n    getLanguage();\n    upgrade_page = create_page_upgrade();\n    lv_scr_load(upgrade_page);\n    int index, last_step = -1, last_state = 0, last_mcu_notify = 0;\n    while (1)\n    {\n        if (last_step != curr_step)\n        {\n            last_step = curr_step;\n            if (curr_step == UPDATE_STEP_MCU)\n                index = TEXT_UPDATING_MCU;\n            else\n                index = TEXT_UPDATING_APP;\n            lv_label_set_text(_text_label, _text_local[lang][index]);\n        }\n        if (last_state != curr_state)\n        {\n            last_state = curr_state;\n            if (curr_state == UPDATE_STATE_FAIL)\n            {\n                if (curr_step == UPDATE_STEP_MCU)\n                    index = TEXT_UPDATE_MCU_FAIL;\n                else\n                    index = TEXT_UPDATE_APP_FAIL;\n                lv_label_set_text(_text_label, _text_local[lang][index]);\n            }\n        }\n        update_upgrade_progress();\n        lv_task_handler();\n        usleep(1000 * 5);\n        last_mcu_notify++;\n        if (last_mcu_notify > 100)\n        {\n            last_mcu_notify = 0;\n            mcu_write_inst_state();\n        }\n    }\n\n    pthread_exit(NULL);\n    return NULL;\n}"}, "carbit_updater/updateui.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/updateui.c"}}, "carbit_updater/lv_drv_conf.h": {"lv_conf": {"type": "Variable", "def": "#include lv_conf.h", "sline": 16, "include": ["carbit_updater/lv_conf.h", null]}, "carbit_updater/lv_drv_conf.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drv_conf.h"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_36.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_montserrat_36.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_36.c"}}, "carbit_updater/lvgl/rt-thread/lv_rt_thread_conf.h": {"carbit_updater/lvgl/rt-thread/lv_rt_thread_conf.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/rt-thread/lv_rt_thread_conf.h"}}, "carbit_updater/lvgl/src/extra/libs/gif/gifdec.h": {"stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 4}, "lv_fs": {"type": "Variable", "def": "#include ../../../misc/lv_fs.h", "sline": 5}, "carbit_updater/lvgl/src/extra/libs/gif/gifdec.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/gif/gifdec.h"}}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_draw_line.c": {"lv_conf_internal": {"type": "Variable", "def": "#include ../../lv_conf_internal.h", "sline": 12}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_draw_line.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_draw_line.c"}}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_utils.c": {"lv_conf_internal": {"type": "Variable", "def": "#include ../../lv_conf_internal.h", "sline": 9}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_utils.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_utils.c"}}, "carbit_updater/lvgl/src/misc/lv_fs.c": {"lv_fs": {"type": "Variable", "def": "#include lv_fs.h", "sline": 9, "include": ["carbit_updater/lvgl/src/misc/lv_fs.h", null]}, "string": {"type": "Variable", "def": "#include string.h", "sline": 11}, "lv_assert": {"type": "Variable", "def": "#include lv_assert.h", "sline": 12, "include": ["carbit_updater/lvgl/src/misc/lv_assert.h", null]}, "lv_ll": {"type": "Variable", "def": "#include lv_ll.h", "sline": 13, "include": ["carbit_updater/lvgl/src/misc/lv_ll.h", null]}, "lv_gc": {"type": "Variable", "def": "#include lv_gc.h", "sline": 14, "include": ["carbit_updater/lvgl/src/misc/lv_gc.h", null]}, "lv_fs_get_real_path": {"type": "Function", "def": "static const char * lv_fs_get_real_path(const char * path)", "sline": 369, "body": "{\n    path++; /*Ignore the driver letter*/\n    if(*path == ':') path++;\n\n    return path;\n}"}, "_lv_fs_init": {"type": "Function", "def": "void _lv_fs_init(void)", "sline": 50, "body": "{\n    _lv_ll_init(&LV_GC_ROOT(_lv_fsdrv_ll), sizeof(lv_fs_drv_t *));\n}"}, "lv_fs_is_ready": {"type": "Function", "def": "bool lv_fs_is_ready(char letter)", "sline": 55, "body": "{\n    lv_fs_drv_t * drv = lv_fs_get_drv(letter);\n\n    if(drv == NULL) return false; /*An unknown driver in not ready*/\n\n    if(drv->ready_cb == NULL) return true; /*Assume the driver is always ready if no handler provided*/\n\n    return drv->ready_cb(drv);\n}"}, "lv_fs_open": {"type": "Function", "def": "lv_fs_res_t lv_fs_open(lv_fs_file_t * file_p, const char * path, lv_fs_mode_t mode)", "sline": 66, "body": "{\n    if(path == NULL) {\n        LV_LOG_WARN(\"Can't open file: path is NULL\");\n        return LV_FS_RES_INV_PARAM;\n    }\n\n    char letter = path[0];\n    lv_fs_drv_t * drv = lv_fs_get_drv(letter);\n\n    if(drv == NULL) {\n        LV_LOG_WARN(\"Can't open file (%s): unknown driver letter\", path);\n        return LV_FS_RES_NOT_EX;\n    }\n\n    if(drv->ready_cb) {\n        if(drv->ready_cb(drv) == false) {\n            LV_LOG_WARN(\"Can't open file (%s): driver not ready\", path);\n            return LV_FS_RES_HW_ERR;\n        }\n    }\n\n    if(drv->open_cb == NULL) {\n        LV_LOG_WARN(\"Can't open file (%s): open function not exists\", path);\n        return LV_FS_RES_NOT_IMP;\n    }\n\n    const char * real_path = lv_fs_get_real_path(path);\n    void * file_d = drv->open_cb(drv, real_path, mode);\n\n    if(file_d == NULL || file_d == (void *)(-1)) {\n        return LV_FS_RES_UNKNOWN;\n    }\n\n    file_p->drv = drv;\n    file_p->file_d = file_d;\n\n    return LV_FS_RES_OK;\n}"}, "lv_fs_close": {"type": "Function", "def": "lv_fs_res_t lv_fs_close(lv_fs_file_t * file_p)", "sline": 106, "body": "{\n    if(file_p->drv == NULL) {\n        return LV_FS_RES_INV_PARAM;\n    }\n\n    if(file_p->drv->close_cb == NULL) {\n        return LV_FS_RES_NOT_IMP;\n    }\n\n    lv_fs_res_t res = file_p->drv->close_cb(file_p->drv, file_p->file_d);\n\n    file_p->file_d = NULL;\n    file_p->drv    = NULL;\n\n    return res;\n}"}, "lv_fs_read": {"type": "Function", "def": "lv_fs_res_t lv_fs_read(lv_fs_file_t * file_p, void * buf, uint32_t btr, uint32_t * br)", "sline": 124, "body": "{\n    if(br != NULL) *br = 0;\n    if(file_p->drv == NULL) return LV_FS_RES_INV_PARAM;\n    if(file_p->drv->read_cb == NULL) return LV_FS_RES_NOT_IMP;\n\n    uint32_t br_tmp = 0;\n    lv_fs_res_t res = file_p->drv->read_cb(file_p->drv, file_p->file_d, buf, btr, &br_tmp);\n    if(br != NULL) *br = br_tmp;\n\n    return res;\n}"}, "lv_fs_write": {"type": "Function", "def": "lv_fs_res_t lv_fs_write(lv_fs_file_t * file_p, const void * buf, uint32_t btw, uint32_t * bw)", "sline": 137, "body": "{\n    if(bw != NULL) *bw = 0;\n\n    if(file_p->drv == NULL) {\n        return LV_FS_RES_INV_PARAM;\n    }\n\n    if(file_p->drv->write_cb == NULL) {\n        return LV_FS_RES_NOT_IMP;\n    }\n\n    uint32_t bw_tmp = 0;\n    lv_fs_res_t res = file_p->drv->write_cb(file_p->drv, file_p->file_d, buf, btw, &bw_tmp);\n    if(bw != NULL) *bw = bw_tmp;\n\n    return res;\n}"}, "lv_fs_seek": {"type": "Function", "def": "lv_fs_res_t lv_fs_seek(lv_fs_file_t * file_p, uint32_t pos, lv_fs_whence_t whence)", "sline": 156, "body": "{\n    if(file_p->drv == NULL) {\n        return LV_FS_RES_INV_PARAM;\n    }\n\n    if(file_p->drv->seek_cb == NULL) {\n        return LV_FS_RES_NOT_IMP;\n    }\n\n    return file_p->drv->seek_cb(file_p->drv, file_p->file_d, pos, whence);\n}"}, "lv_fs_tell": {"type": "Function", "def": "lv_fs_res_t lv_fs_tell(lv_fs_file_t * file_p, uint32_t * pos)", "sline": 169, "body": "{\n    *pos = 0;\n\n    if(file_p->drv == NULL) {\n        return LV_FS_RES_INV_PARAM;\n    }\n\n    if(file_p->drv->tell_cb == NULL) {\n        return LV_FS_RES_NOT_IMP;\n    }\n\n    return file_p->drv->tell_cb(file_p->drv, file_p->file_d, pos);\n}"}, "lv_fs_dir_open": {"type": "Function", "def": "lv_fs_res_t lv_fs_dir_open(lv_fs_dir_t * rddir_p, const char * path)", "sline": 184, "body": "{\n    if(path == NULL) return LV_FS_RES_INV_PARAM;\n\n    char letter = path[0];\n    lv_fs_drv_t * drv = lv_fs_get_drv(letter);\n\n    if(drv == NULL) {\n        return LV_FS_RES_NOT_EX;\n    }\n\n    if(drv->ready_cb) {\n        if(drv->ready_cb(drv) == false) {\n            return LV_FS_RES_HW_ERR;\n        }\n    }\n\n    if(drv->dir_open_cb == NULL) {\n        return LV_FS_RES_NOT_IMP;\n    }\n\n    const char * real_path = lv_fs_get_real_path(path);\n    void * dir_d = drv->dir_open_cb(drv, real_path);\n\n    if(dir_d == NULL || dir_d == (void *)(-1)) {\n        return LV_FS_RES_UNKNOWN;\n    }\n\n    rddir_p->drv = drv;\n    rddir_p->dir_d = dir_d;\n\n    return LV_FS_RES_OK;\n}"}, "lv_fs_dir_read": {"type": "Function", "def": "lv_fs_res_t lv_fs_dir_read(lv_fs_dir_t * rddir_p, char * fn)", "sline": 218, "body": "{\n    fn[0] = '\\0';\n\n    if(rddir_p->drv == NULL || rddir_p->dir_d == NULL) {\n        return LV_FS_RES_INV_PARAM;\n    }\n\n    if(rddir_p->drv->dir_read_cb == NULL) {\n        return LV_FS_RES_NOT_IMP;\n    }\n\n    return rddir_p->drv->dir_read_cb(rddir_p->drv, rddir_p->dir_d, fn);\n}"}, "lv_fs_dir_close": {"type": "Function", "def": "lv_fs_res_t lv_fs_dir_close(lv_fs_dir_t * rddir_p)", "sline": 233, "body": "{\n    if(rddir_p->drv == NULL || rddir_p->dir_d == NULL) {\n        return LV_FS_RES_INV_PARAM;\n    }\n\n    if(rddir_p->drv->dir_close_cb == NULL) {\n        return LV_FS_RES_NOT_IMP;\n    }\n\n    lv_fs_res_t res = rddir_p->drv->dir_close_cb(rddir_p->drv, rddir_p->dir_d);\n\n    rddir_p->dir_d = NULL;\n    rddir_p->drv   = NULL;\n\n    return res;\n}"}, "lv_fs_drv_init": {"type": "Function", "def": "void lv_fs_drv_init(lv_fs_drv_t * drv)", "sline": 251, "body": "{\n    lv_memset_00(drv, sizeof(lv_fs_drv_t));\n}"}, "lv_fs_drv_register": {"type": "Function", "def": "void lv_fs_drv_register(lv_fs_drv_t * drv_p)", "sline": 256, "body": "{\n    /*Save the new driver*/\n    lv_fs_drv_t ** new_drv;\n    new_drv = _lv_ll_ins_head(&LV_GC_ROOT(_lv_fsdrv_ll));\n    LV_ASSERT_MALLOC(new_drv);\n    if(new_drv == NULL) return;\n\n    *new_drv = drv_p;\n}"}, "lv_fs_get_drv": {"type": "Function", "def": "lv_fs_drv_t * lv_fs_get_drv(char letter)", "sline": 267, "body": "{\n    lv_fs_drv_t ** drv;\n\n    _LV_LL_READ(&LV_GC_ROOT(_lv_fsdrv_ll), drv) {\n        if((*drv)->letter == letter) {\n            return *drv;\n        }\n    }\n\n    return NULL;\n}"}, "lv_fs_get_letters": {"type": "Function", "def": "char * lv_fs_get_letters(char * buf)", "sline": 280, "body": "{\n    lv_fs_drv_t ** drv;\n    uint8_t i = 0;\n\n    _LV_LL_READ(&LV_GC_ROOT(_lv_fsdrv_ll), drv) {\n        buf[i] = (*drv)->letter;\n        i++;\n    }\n\n    buf[i] = '\\0';\n\n    return buf;\n}"}, "lv_fs_get_ext": {"type": "Function", "def": "const char * lv_fs_get_ext(const char * fn)", "sline": 295, "body": "{\n    size_t i;\n    for(i = strlen(fn); i > 0; i--) {\n        if(fn[i - 1] == '.') {\n            return &fn[i];\n        }\n        else if(fn[i - 1] == '/' || fn[i - 1] == '\\\\') {\n            return \"\"; /*No extension if a '\\' or '/' found*/\n        }\n    }\n\n    return \"\"; /*Empty string if no '.' in the file name.*/\n}"}, "lv_fs_up": {"type": "Function", "def": "char * lv_fs_up(char * path)", "sline": 310, "body": "{\n    size_t len = strlen(path);\n    if(len == 0) return path;\n\n    len--; /*Go before the trailing '\\0'*/\n\n    /*Ignore trailing '/' or '\\'*/\n    while(path[len] == '/' || path[len] == '\\\\') {\n        path[len] = '\\0';\n        if(len > 0)\n            len--;\n        else\n            return path;\n    }\n\n    size_t i;\n    for(i = len; i > 0; i--) {\n        if(path[i - 1] == '/' || path[i - 1] == '\\\\') {\n            path[i - 1] = '\\0';\n            break;\n        }\n    }\n\n    return path;\n}"}, "lv_fs_get_last": {"type": "Function", "def": "const char * lv_fs_get_last(const char * path)", "sline": 337, "body": "{\n    size_t len = strlen(path);\n    if(len == 0) return path;\n\n    len--; /*Go before the trailing '\\0'*/\n\n    /*Ignore trailing '/' or '\\'*/\n    while(path[len] == '/' || path[len] == '\\\\') {\n        if(len > 0)\n            len--;\n        else\n            return path;\n    }\n\n    size_t i;\n    for(i = len; i > 0; i--) {\n        if(path[i - 1] == '/' || path[i - 1] == '\\\\') break;\n    }\n\n    return &path[i];\n}"}, "carbit_updater/lvgl/src/misc/lv_fs.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_fs.c"}}, "carbit_updater/lvgl/src/draw/lv_draw_img.c": {"lv_draw_img": {"type": "Function", "def": "void lv_draw_img(const lv_area_t * coords, const lv_area_t * mask, const void * src, const lv_draw_img_dsc_t * dsc)", "sline": 78, "body": "{\n    if(src == NULL) {\n        LV_LOG_WARN(\"Image draw: src is NULL\");\n        show_error(coords, mask, \"No\\ndata\");\n        return;\n    }\n\n    if(dsc->opa <= LV_OPA_MIN) return;\n\n    lv_res_t res;\n    res = lv_img_draw_core(coords, mask, src, dsc);\n\n    if(res == LV_RES_INV) {\n        LV_LOG_WARN(\"Image draw error\");\n        show_error(coords, mask, \"No\\ndata\");\n        return;\n    }\n}"}, "lv_img_cache": {"type": "Variable", "def": "#include lv_img_cache.h", "sline": 10, "include": ["carbit_updater/lvgl/src/draw/lv_img_cache.h", null]}, "lv_hal_disp": {"type": "Variable", "def": "#include ../hal/lv_hal_disp.h", "sline": 11}, "lv_log": {"type": "Variable", "def": "#include ../misc/lv_log.h", "sline": 12}, "lv_refr": {"type": "Variable", "def": "#include ../core/lv_refr.h", "sline": 13}, "lv_mem": {"type": "Variable", "def": "#include ../misc/lv_mem.h", "sline": 14}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 15}, "lv_img_draw_core": {"type": "Function", "def": "static lv_res_t lv_img_draw_core(const lv_area_t * coords, const lv_area_t * clip_area,\n                                                       const void * src,\n                                                       const lv_draw_img_dsc_t * draw_dsc)", "sline": 239, "body": "{\n    if(draw_dsc->opa <= LV_OPA_MIN) return LV_RES_OK;\n\n    _lv_img_cache_entry_t * cdsc = _lv_img_cache_open(src, draw_dsc->recolor, draw_dsc->frame_id);\n\n    if(cdsc == NULL) return LV_RES_INV;\n\n    bool chroma_keyed = lv_img_cf_is_chroma_keyed(cdsc->dec_dsc.header.cf);\n    bool alpha_byte   = lv_img_cf_has_alpha(cdsc->dec_dsc.header.cf);\n\n    if(cdsc->dec_dsc.error_msg != NULL) {\n        LV_LOG_WARN(\"Image draw error\");\n\n        show_error(coords, clip_area, cdsc->dec_dsc.error_msg);\n    }\n    /*The decoder could open the image and gave the entire uncompressed image.\n     *Just draw it!*/\n    else if(cdsc->dec_dsc.img_data) {\n        lv_area_t map_area_rot;\n        lv_area_copy(&map_area_rot, coords);\n        if(draw_dsc->angle || draw_dsc->zoom != LV_IMG_ZOOM_NONE) {\n            int32_t w = lv_area_get_width(coords);\n            int32_t h = lv_area_get_height(coords);\n\n            _lv_img_buf_get_transformed_area(&map_area_rot, w, h, draw_dsc->angle, draw_dsc->zoom, &draw_dsc->pivot);\n\n            map_area_rot.x1 += coords->x1;\n            map_area_rot.y1 += coords->y1;\n            map_area_rot.x2 += coords->x1;\n            map_area_rot.y2 += coords->y1;\n        }\n\n        lv_area_t mask_com; /*Common area of mask and coords*/\n        bool union_ok;\n        union_ok = _lv_area_intersect(&mask_com, clip_area, &map_area_rot);\n        /*Out of mask. There is nothing to draw so the image is drawn successfully.*/\n        if(union_ok == false) {\n            draw_cleanup(cdsc);\n            return LV_RES_OK;\n        }\n\n        lv_draw_map(coords, &mask_com, cdsc->dec_dsc.img_data, draw_dsc, chroma_keyed, alpha_byte);\n    }\n    /*The whole uncompressed image is not available. Try to read it line-by-line*/\n    else {\n        lv_area_t mask_com; /*Common area of mask and coords*/\n        bool union_ok;\n        union_ok = _lv_area_intersect(&mask_com, clip_area, coords);\n        /*Out of mask. There is nothing to draw so the image is drawn successfully.*/\n        if(union_ok == false) {\n            draw_cleanup(cdsc);\n            return LV_RES_OK;\n        }\n\n        int32_t width = lv_area_get_width(&mask_com);\n\n        uint8_t  * buf = lv_mem_buf_get(lv_area_get_width(&mask_com) *\n                                        LV_IMG_PX_SIZE_ALPHA_BYTE);  /*+1 because of the possible alpha byte*/\n\n        lv_area_t line;\n        lv_area_copy(&line, &mask_com);\n        lv_area_set_height(&line, 1);\n        int32_t x = mask_com.x1 - coords->x1;\n        int32_t y = mask_com.y1 - coords->y1;\n        int32_t row;\n        lv_res_t read_res;\n        for(row = mask_com.y1; row <= mask_com.y2; row++) {\n            lv_area_t mask_line;\n            union_ok = _lv_area_intersect(&mask_line, clip_area, &line);\n            if(union_ok == false) continue;\n\n            read_res = lv_img_decoder_read_line(&cdsc->dec_dsc, x, y, width, buf);\n            if(read_res != LV_RES_OK) {\n                lv_img_decoder_close(&cdsc->dec_dsc);\n                LV_LOG_WARN(\"Image draw can't read the line\");\n                lv_mem_buf_release(buf);\n                draw_cleanup(cdsc);\n                return LV_RES_INV;\n            }\n\n            lv_draw_map(&line, &mask_line, buf, draw_dsc, chroma_keyed, alpha_byte);\n            line.y1++;\n            line.y2++;\n            y++;\n        }\n        lv_mem_buf_release(buf);\n    }\n\n    draw_cleanup(cdsc);\n    return LV_RES_OK;\n}"}, "lv_draw_map": {"type": "Function", "def": "static void lv_draw_map(const lv_area_t * map_area, const lv_area_t * clip_area,\n                                              const uint8_t * map_p,\n                                              const lv_draw_img_dsc_t * draw_dsc,\n                                              bool chroma_key, bool alpha_byte)", "sline": 343, "body": "{\n    /*Use the clip area as draw area*/\n    lv_area_t draw_area;\n    lv_area_copy(&draw_area, clip_area);\n\n    lv_disp_t * disp = _lv_refr_get_disp_refreshing();\n    lv_disp_draw_buf_t * draw_buf = lv_disp_get_draw_buf(disp);\n    const lv_area_t * disp_area = &draw_buf->area;\n\n    /*Now `draw_area` has absolute coordinates.\n     *Make it relative to `disp_area` to simplify draw to `disp_buf`*/\n    draw_area.x1 -= disp_area->x1;\n    draw_area.y1 -= disp_area->y1;\n    draw_area.x2 -= disp_area->x1;\n    draw_area.y2 -= disp_area->y1;\n\n    bool mask_any = lv_draw_mask_is_any(clip_area);\n\n    /*The simplest case just copy the pixels into the draw_buf*/\n    if(!mask_any && draw_dsc->angle == 0 && draw_dsc->zoom == LV_IMG_ZOOM_NONE &&\n       chroma_key == false && alpha_byte == false && draw_dsc->recolor_opa == LV_OPA_TRANSP) {\n#if LV_USE_SUNXIFB_G2D_BLIT\n        if (lv_area_get_width(&draw_area) * lv_area_get_height(&draw_area)\n                >= sunxifb_g2d_get_limit(SUNXI_G2D_LIMIT_BLIT)) {\n            if (!sunxifb_g2d_blit(draw_buf->buf_act, disp_area, &draw_area,\n                    (lv_color_t*) map_p, map_area, draw_dsc->opa))\n                return;\n        }\n#endif /* LV_USE_SUNXIFB_G2D_BLIT */\n        _lv_blend_map(clip_area, map_area, (lv_color_t *)map_p, NULL, LV_DRAW_MASK_RES_FULL_COVER, draw_dsc->opa,\n                      draw_dsc->blend_mode);\n    }\n\n#if LV_USE_GPU_NXP_PXP\n    /*Simple case without masking and transformations*/\n    else if(!mask_any && draw_dsc->angle == 0 && draw_dsc->zoom == LV_IMG_ZOOM_NONE && alpha_byte == false &&\n            chroma_key == true && draw_dsc->recolor_opa == LV_OPA_TRANSP) { /*copy with color keying (+ alpha)*/\n        lv_gpu_nxp_pxp_enable_color_key();\n        _lv_blend_map(clip_area, map_area, (lv_color_t *)map_p, NULL, LV_DRAW_MASK_RES_FULL_COVER, draw_dsc->opa,\n                      draw_dsc->blend_mode);\n        lv_gpu_nxp_pxp_disable_color_key();\n    }\n    else if(!mask_any && draw_dsc->angle == 0 && draw_dsc->zoom == LV_IMG_ZOOM_NONE && alpha_byte == false &&\n            chroma_key == false && draw_dsc->recolor_opa != LV_OPA_TRANSP) { /*copy with recolor (+ alpha)*/\n        lv_gpu_nxp_pxp_enable_recolor(draw_dsc->recolor, draw_dsc->recolor_opa);\n        _lv_blend_map(clip_area, map_area, (lv_color_t *)map_p, NULL, LV_DRAW_MASK_RES_FULL_COVER, draw_dsc->opa,\n                      draw_dsc->blend_mode);\n        lv_gpu_nxp_pxp_disable_recolor();\n    }\n#endif\n    /*In the other cases every pixel need to be checked one-by-one*/\n    else {\n        //#if LV_DRAW_COMPLEX\n        /*The pixel size in byte is different if an alpha byte is added too*/\n        uint8_t px_size_byte = alpha_byte ? LV_IMG_PX_SIZE_ALPHA_BYTE : sizeof(lv_color_t);\n\n        /*Go to the first displayed pixel of the map*/\n        int32_t map_w = lv_area_get_width(map_area);\n        const uint8_t * map_buf_tmp = map_p;\n        map_buf_tmp += map_w * (draw_area.y1 - (map_area->y1 - disp_area->y1)) * px_size_byte;\n        map_buf_tmp += (draw_area.x1 - (map_area->x1 - disp_area->x1)) * px_size_byte;\n\n        lv_color_t c;\n        lv_color_t chroma_keyed_color = LV_COLOR_CHROMA_KEY;\n        uint32_t px_i = 0;\n\n        const uint8_t * map_px;\n\n        lv_coord_t draw_area_h = lv_area_get_height(&draw_area);\n        lv_coord_t draw_area_w = lv_area_get_width(&draw_area);\n\n        lv_area_t blend_area;\n        blend_area.x1 = draw_area.x1 + disp_area->x1;\n        blend_area.x2 = blend_area.x1 + draw_area_w - 1;\n        blend_area.y1 = disp_area->y1 + draw_area.y1;\n        blend_area.y2 = blend_area.y1;\n\n        bool transform = draw_dsc->angle != 0 || draw_dsc->zoom != LV_IMG_ZOOM_NONE ? true : false;\n        /*Simple ARGB image. Handle it as special case because it's very common*/\n        if(!mask_any && !transform && !chroma_key && draw_dsc->recolor_opa == LV_OPA_TRANSP && alpha_byte) {\n#if LV_USE_GPU_STM32_DMA2D && LV_COLOR_DEPTH == 32\n            /*Blend ARGB images directly*/\n            if(lv_area_get_size(&draw_area) > 240) {\n                int32_t disp_w = lv_area_get_width(disp_area);\n                lv_color_t * disp_buf = draw_buf->buf_act;\n                lv_color_t * disp_buf_first = disp_buf + disp_w * draw_area.y1 + draw_area.x1;\n                lv_gpu_stm32_dma2d_blend(disp_buf_first, disp_w, (const lv_color_t *)map_buf_tmp, draw_dsc->opa, map_w, draw_area_w,\n                                         draw_area_h);\n                return;\n            }\n#elif LV_USE_SUNXIFB_G2D_BLEND\n            if (draw_area_w * draw_area_h >= sunxifb_g2d_get_limit(SUNXI_G2D_LIMIT_BLEND)) {\n                if (!sunxifb_g2d_blend(draw_buf->buf_act, disp_area, &draw_area,\n                        (lv_color_t*) map_p, map_area, draw_dsc->opa, chroma_key))\n                    return;\n            }\n#endif\n            uint32_t hor_res = (uint32_t) lv_disp_get_hor_res(disp);\n            uint32_t mask_buf_size = lv_area_get_size(&draw_area) > (uint32_t) hor_res ? hor_res : lv_area_get_size(&draw_area);\n            lv_color_t * map2 = lv_mem_buf_get(mask_buf_size * sizeof(lv_color_t));\n            lv_opa_t * mask_buf = lv_mem_buf_get(mask_buf_size);\n\n            int32_t x;\n            int32_t y;\n            for(y = 0; y < draw_area_h; y++) {\n                map_px = map_buf_tmp;\n                for(x = 0; x < draw_area_w; x++, map_px += px_size_byte, px_i++) {\n                    lv_opa_t px_opa = map_px[LV_IMG_PX_SIZE_ALPHA_BYTE - 1];\n                    mask_buf[px_i] = px_opa;\n                    if(px_opa) {\n#if LV_COLOR_DEPTH == 8 || LV_COLOR_DEPTH == 1\n                        map2[px_i].full =  map_px[0];\n#elif LV_COLOR_DEPTH == 16\n                        map2[px_i].full =  map_px[0] + (map_px[1] << 8);\n#elif LV_COLOR_DEPTH == 32\n                        map2[px_i].full =  *((uint32_t *)map_px);\n#endif\n                    }\n#if LV_COLOR_DEPTH == 32\n                    map2[px_i].ch.alpha = 0xFF;\n#endif\n                }\n\n                map_buf_tmp += map_w * px_size_byte;\n                if(px_i + draw_area_w < mask_buf_size) {\n                    blend_area.y2 ++;\n                }\n                else {\n                    _lv_blend_map(clip_area, &blend_area, map2, mask_buf, LV_DRAW_MASK_RES_CHANGED, draw_dsc->opa, draw_dsc->blend_mode);\n\n                    blend_area.y1 = blend_area.y2 + 1;\n                    blend_area.y2 = blend_area.y1;\n\n                    px_i = 0;\n                }\n            }\n            /*Flush the last part*/\n            if(blend_area.y1 != blend_area.y2) {\n                blend_area.y2--;\n                _lv_blend_map(clip_area, &blend_area, map2, mask_buf, LV_DRAW_MASK_RES_CHANGED, draw_dsc->opa, draw_dsc->blend_mode);\n            }\n\n            lv_mem_buf_release(mask_buf);\n            lv_mem_buf_release(map2);\n        }\n        /*Most complicated case: transform or other mask or chroma keyed*/\n        else {\n#if LV_USE_SUNXIFB_G2D_BLEND\n            if (!mask_any && draw_dsc->angle == 0 && draw_dsc->zoom == LV_IMG_ZOOM_NONE\n                    && chroma_key && draw_dsc->recolor_opa == LV_OPA_TRANSP) {\n                if (draw_area_w * draw_area_h >= sunxifb_g2d_get_limit(SUNXI_G2D_LIMIT_BLEND)) {\n                    if (!sunxifb_g2d_blend(draw_buf->buf_act, disp_area,\n                            &draw_area, (lv_color_t*) map_p, map_area,\n                            draw_dsc->opa, chroma_key))\n                        return;\n                }\n            }\n#endif\n#if LV_USE_SUNXIFB_G2D_SCALE\n            if (!mask_any && draw_dsc->angle == 0 && draw_dsc->zoom != LV_IMG_ZOOM_NONE\n                    && !chroma_key && draw_dsc->recolor_opa == LV_OPA_TRANSP) {\n                if (draw_area_w * draw_area_h >= sunxifb_g2d_get_limit(SUNXI_G2D_LIMIT_SCALE)) {\n                    if (!sunxifb_g2d_scale(draw_buf->buf_act, disp_area,\n                            &draw_area, (lv_color_t*) map_p, map_area,\n                            draw_dsc->opa, draw_dsc->zoom, &draw_dsc->pivot))\n                        return;\n                }\n            }\n#endif\n            /*Build the image and a mask line-by-line*/\n            uint32_t hor_res = (uint32_t) lv_disp_get_hor_res(disp);\n            uint32_t mask_buf_size = lv_area_get_size(&draw_area) > hor_res ? hor_res : lv_area_get_size(&draw_area);\n            lv_color_t * map2 = lv_mem_buf_get(mask_buf_size * sizeof(lv_color_t));\n            lv_opa_t * mask_buf = lv_mem_buf_get(mask_buf_size);\n\n#if LV_DRAW_COMPLEX\n            lv_img_transform_dsc_t trans_dsc;\n            lv_memset_00(&trans_dsc, sizeof(lv_img_transform_dsc_t));\n            if(transform) {\n                lv_img_cf_t cf = LV_IMG_CF_TRUE_COLOR;\n                if(alpha_byte) cf = LV_IMG_CF_TRUE_COLOR_ALPHA;\n                else if(chroma_key) cf = LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED;\n\n                trans_dsc.cfg.angle = draw_dsc->angle;\n                trans_dsc.cfg.zoom = draw_dsc->zoom;\n                trans_dsc.cfg.src = map_p;\n                trans_dsc.cfg.src_w = map_w;\n                trans_dsc.cfg.src_h = lv_area_get_height(map_area);;\n                trans_dsc.cfg.cf = cf;\n                trans_dsc.cfg.pivot_x = draw_dsc->pivot.x;\n                trans_dsc.cfg.pivot_y = draw_dsc->pivot.y;\n                trans_dsc.cfg.color = draw_dsc->recolor;\n                trans_dsc.cfg.antialias = draw_dsc->antialias;\n\n                _lv_img_buf_transform_init(&trans_dsc);\n            }\n#endif\n            uint16_t recolor_premult[3] = {0};\n            lv_opa_t recolor_opa_inv = 255 - draw_dsc->recolor_opa;\n            if(draw_dsc->recolor_opa != 0) {\n                lv_color_premult(draw_dsc->recolor, draw_dsc->recolor_opa, recolor_premult);\n            }\n\n            lv_draw_mask_res_t mask_res;\n            mask_res = (alpha_byte || chroma_key || draw_dsc->angle ||\n                        draw_dsc->zoom != LV_IMG_ZOOM_NONE) ? LV_DRAW_MASK_RES_CHANGED : LV_DRAW_MASK_RES_FULL_COVER;\n\n            /*Prepare the `mask_buf`if there are other masks*/\n            if(mask_any) {\n                lv_memset_ff(mask_buf, mask_buf_size);\n            }\n\n            int32_t x;\n            int32_t y;\n#if LV_DRAW_COMPLEX\n            int32_t rot_y = disp_area->y1 + draw_area.y1 - map_area->y1;\n#endif\n            for(y = 0; y < draw_area_h; y++) {\n                map_px = map_buf_tmp;\n#if LV_DRAW_COMPLEX\n                uint32_t px_i_start = px_i;\n                int32_t rot_x = disp_area->x1 + draw_area.x1 - map_area->x1;\n#endif\n\n                for(x = 0; x < draw_area_w; x++, map_px += px_size_byte, px_i++) {\n\n#if LV_DRAW_COMPLEX\n                    if(transform) {\n\n                        /*Transform*/\n                        bool ret;\n                        ret = _lv_img_buf_transform(&trans_dsc, rot_x + x, rot_y + y);\n                        if(ret == false) {\n                            mask_buf[px_i] = LV_OPA_TRANSP;\n                            continue;\n                        }\n                        else {\n                            mask_buf[px_i] = trans_dsc.res.opa;\n                            c.full = trans_dsc.res.color.full;\n                        }\n                    }\n                    /*No transform*/\n                    else\n#endif\n                    {\n                        if(alpha_byte) {\n                            lv_opa_t px_opa = map_px[LV_IMG_PX_SIZE_ALPHA_BYTE - 1];\n                            mask_buf[px_i] = px_opa;\n                            if(px_opa == 0) {\n#if  LV_COLOR_DEPTH == 32\n                                map2[px_i].full = 0;\n#endif\n                                continue;\n                            }\n                        }\n                        else {\n                            mask_buf[px_i] = 0xFF;\n                        }\n\n#if LV_COLOR_DEPTH == 1\n                        c.full = map_px[0];\n#elif LV_COLOR_DEPTH == 8\n                        c.full =  map_px[0];\n#elif LV_COLOR_DEPTH == 16\n                        c.full =  map_px[0] + (map_px[1] << 8);\n#elif LV_COLOR_DEPTH == 32\n                        c.full =  *((uint32_t *)map_px);\n                        c.ch.alpha = 0xFF;\n#endif\n                        if(chroma_key) {\n                            if(c.full == chroma_keyed_color.full) {\n                                mask_buf[px_i] = LV_OPA_TRANSP;\n#if  LV_COLOR_DEPTH == 32\n                                map2[px_i].full = 0;\n#endif\n                                continue;\n                            }\n                        }\n\n                    }\n                    if(draw_dsc->recolor_opa != 0) {\n                        c = lv_color_mix_premult(recolor_premult, c, recolor_opa_inv);\n                    }\n\n                    map2[px_i].full = c.full;\n                }\n#if LV_DRAW_COMPLEX\n                /*Apply the masks if any*/\n                if(mask_any) {\n                    lv_draw_mask_res_t mask_res_sub;\n                    mask_res_sub = lv_draw_mask_apply(mask_buf + px_i_start, draw_area.x1 + draw_buf->area.x1,\n                                                      y + draw_area.y1 + draw_buf->area.y1,\n                                                      draw_area_w);\n                    if(mask_res_sub == LV_DRAW_MASK_RES_TRANSP) {\n                        lv_memset_00(mask_buf + px_i_start, draw_area_w);\n                        mask_res = LV_DRAW_MASK_RES_CHANGED;\n                    }\n                    else if(mask_res_sub == LV_DRAW_MASK_RES_CHANGED) {\n                        mask_res = LV_DRAW_MASK_RES_CHANGED;\n                    }\n                }\n#endif\n\n                map_buf_tmp += map_w * px_size_byte;\n                if(px_i + draw_area_w < mask_buf_size) {\n                    blend_area.y2 ++;\n                }\n                else {\n\n                    _lv_blend_map(clip_area, &blend_area, map2, mask_buf, mask_res, draw_dsc->opa, draw_dsc->blend_mode);\n\n                    blend_area.y1 = blend_area.y2 + 1;\n                    blend_area.y2 = blend_area.y1;\n\n                    px_i = 0;\n                    mask_res = (alpha_byte || chroma_key || draw_dsc->angle ||\n                                draw_dsc->zoom != LV_IMG_ZOOM_NONE) ? LV_DRAW_MASK_RES_CHANGED : LV_DRAW_MASK_RES_FULL_COVER;\n\n                    /*Prepare the `mask_buf`if there are other masks*/\n                    if(mask_any) {\n                        lv_memset_ff(mask_buf, mask_buf_size);\n                    }\n                }\n            }\n\n            /*Flush the last part*/\n            if(blend_area.y1 != blend_area.y2) {\n                blend_area.y2--;\n                _lv_blend_map(clip_area, &blend_area, map2, mask_buf, mask_res, draw_dsc->opa, draw_dsc->blend_mode);\n            }\n\n            lv_mem_buf_release(mask_buf);\n            lv_mem_buf_release(map2);\n        }\n    }\n}"}, "show_error": {"type": "Function", "def": "static void show_error(const lv_area_t * coords, const lv_area_t * clip_area, const char * msg)", "sline": 684, "body": "{\n    lv_draw_rect_dsc_t rect_dsc;\n    lv_draw_rect_dsc_init(&rect_dsc);\n    rect_dsc.bg_color = lv_color_white();\n    lv_draw_rect(coords, clip_area, &rect_dsc);\n\n    lv_draw_label_dsc_t label_dsc;\n    lv_draw_label_dsc_init(&label_dsc);\n    lv_draw_label(coords, clip_area, &label_dsc, msg, NULL);\n}"}, "draw_cleanup": {"type": "Function", "def": "static void draw_cleanup(_lv_img_cache_entry_t * cache)", "sline": 696, "body": "{\n    /*Automatically close images with no caching*/\n#if LV_IMG_CACHE_DEF_SIZE == 0\n    lv_img_decoder_close(&cache->dec_dsc);\n#else\n    LV_UNUSED(cache);\n#endif\n}"}, "lv_draw_img_dsc_init": {"type": "Function", "def": "void lv_draw_img_dsc_init(lv_draw_img_dsc_t * dsc)", "sline": 61, "body": "{\n    lv_memset_00(dsc, sizeof(lv_draw_img_dsc_t));\n    dsc->recolor = lv_color_black();\n    dsc->opa = LV_OPA_COVER;\n    dsc->zoom = LV_IMG_ZOOM_NONE;\n    dsc->antialias = LV_COLOR_DEPTH > 8 ? 1 : 0;\n}"}, "lv_img_cf_get_px_size": {"type": "Function", "def": "uint8_t lv_img_cf_get_px_size(lv_img_cf_t cf)", "sline": 104, "body": "{\n    uint8_t px_size = 0;\n\n    switch(cf) {\n        case LV_IMG_CF_UNKNOWN:\n        case LV_IMG_CF_RAW:\n            px_size = 0;\n            break;\n        case LV_IMG_CF_TRUE_COLOR:\n        case LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED:\n            px_size = LV_COLOR_SIZE;\n            break;\n        case LV_IMG_CF_TRUE_COLOR_ALPHA:\n            px_size = LV_IMG_PX_SIZE_ALPHA_BYTE << 3;\n            break;\n        case LV_IMG_CF_INDEXED_1BIT:\n        case LV_IMG_CF_ALPHA_1BIT:\n            px_size = 1;\n            break;\n        case LV_IMG_CF_INDEXED_2BIT:\n        case LV_IMG_CF_ALPHA_2BIT:\n            px_size = 2;\n            break;\n        case LV_IMG_CF_INDEXED_4BIT:\n        case LV_IMG_CF_ALPHA_4BIT:\n            px_size = 4;\n            break;\n        case LV_IMG_CF_INDEXED_8BIT:\n        case LV_IMG_CF_ALPHA_8BIT:\n            px_size = 8;\n            break;\n        default:\n            px_size = 0;\n            break;\n    }\n\n    return px_size;\n}"}, "lv_img_cf_is_chroma_keyed": {"type": "Function", "def": "bool lv_img_cf_is_chroma_keyed(lv_img_cf_t cf)", "sline": 149, "body": "{\n    bool is_chroma_keyed = false;\n\n    switch(cf) {\n        case LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED:\n        case LV_IMG_CF_RAW_CHROMA_KEYED:\n        case LV_IMG_CF_INDEXED_1BIT:\n        case LV_IMG_CF_INDEXED_2BIT:\n        case LV_IMG_CF_INDEXED_4BIT:\n        case LV_IMG_CF_INDEXED_8BIT:\n            is_chroma_keyed = true;\n            break;\n\n        default:\n            is_chroma_keyed = false;\n            break;\n    }\n\n    return is_chroma_keyed;\n}"}, "lv_img_cf_has_alpha": {"type": "Function", "def": "bool lv_img_cf_has_alpha(lv_img_cf_t cf)", "sline": 176, "body": "{\n    bool has_alpha = false;\n\n    switch(cf) {\n        case LV_IMG_CF_TRUE_COLOR_ALPHA:\n        case LV_IMG_CF_RAW_ALPHA:\n        case LV_IMG_CF_INDEXED_1BIT:\n        case LV_IMG_CF_INDEXED_2BIT:\n        case LV_IMG_CF_INDEXED_4BIT:\n        case LV_IMG_CF_INDEXED_8BIT:\n        case LV_IMG_CF_ALPHA_1BIT:\n        case LV_IMG_CF_ALPHA_2BIT:\n        case LV_IMG_CF_ALPHA_4BIT:\n        case LV_IMG_CF_ALPHA_8BIT:\n            has_alpha = true;\n            break;\n        default:\n            has_alpha = false;\n            break;\n    }\n\n    return has_alpha;\n}"}, "lv_img_src_get_type": {"type": "Function", "def": "lv_img_src_t lv_img_src_get_type(const void * src)", "sline": 209, "body": "{\n    lv_img_src_t img_src_type = LV_IMG_SRC_UNKNOWN;\n\n    if(src == NULL) return img_src_type;\n    const uint8_t * u8_p = src;\n\n    /*The first byte shows the type of the image source*/\n    if(u8_p[0] >= 0x20 && u8_p[0] <= 0x7F) {\n        img_src_type = LV_IMG_SRC_FILE; /*If it's an ASCII character then it's file name*/\n    }\n    else if(u8_p[0] >= 0x80) {\n        img_src_type = LV_IMG_SRC_SYMBOL; /*Symbols begins after 0x7F*/\n    }\n    else {\n        img_src_type = LV_IMG_SRC_VARIABLE; /*`lv_img_dsc_t` is draw to the first byte < 0x20*/\n    }\n\n    if(LV_IMG_SRC_UNKNOWN == img_src_type) {\n        LV_LOG_WARN(\"lv_img_src_get_type: unknown image type\");\n    }\n\n    return img_src_type;\n}"}, "carbit_updater/lvgl/src/draw/lv_draw_img.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_draw_img.c"}}, "carbit_updater/lvgl/src/gpu/lv_gpu_stm32_dma2d.h": {"lv_area": {"type": "Variable", "def": "#include ../misc/lv_area.h", "sline": 16}, "lv_color": {"type": "Variable", "def": "#include ../misc/lv_color.h", "sline": 17}, "lv_hal_disp": {"type": "Variable", "def": "#include ../hal/lv_hal_disp.h", "sline": 18}, "lv_gpu_stm32_dma2d_init": {"type": "Function", "def": "void lv_gpu_stm32_dma2d_init(void)", "sline": 41}, "lv_gpu_stm32_dma2d_fill": {"type": "Function", "def": "void lv_gpu_stm32_dma2d_fill(lv_color_t * buf, lv_coord_t buf_w, lv_color_t color, lv_coord_t fill_w,\n                             lv_coord_t fill_h)", "sline": 52}, "lv_gpu_stm32_dma2d_fill_mask": {"type": "Function", "def": "void lv_gpu_stm32_dma2d_fill_mask(lv_color_t * buf, lv_coord_t buf_w, lv_color_t color, const lv_opa_t * mask,\n                                  lv_opa_t opa, lv_coord_t fill_w, lv_coord_t fill_h)", "sline": 66}, "lv_gpu_stm32_dma2d_copy": {"type": "Function", "def": "void lv_gpu_stm32_dma2d_copy(lv_color_t * buf, lv_coord_t buf_w, const lv_color_t * map, lv_coord_t map_w,\n                             lv_coord_t copy_w, lv_coord_t copy_h)", "sline": 79}, "lv_gpu_stm32_dma2d_blend": {"type": "Function", "def": "void lv_gpu_stm32_dma2d_blend(lv_color_t * buf, lv_coord_t buf_w, const lv_color_t * map, lv_opa_t opa,\n                              lv_coord_t map_w, lv_coord_t copy_w, lv_coord_t copy_h)", "sline": 92}, "lv_gpu_stm32_dma2d_wait_cb": {"type": "Function", "def": "void lv_gpu_stm32_dma2d_wait_cb(lv_disp_drv_t * drv)", "sline": 99}, "carbit_updater/lvgl/src/gpu/lv_gpu_stm32_dma2d.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_stm32_dma2d.h"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_12_subpx.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_montserrat_12_subpx.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_12_subpx.c"}}, "carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar_header_dropdown.c": {"lv_calendar_header_dropdown": {"type": "Variable", "def": "#include lv_calendar_header_dropdown.h", "sline": 9, "include": ["carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar_header_dropdown.h", null]}, "lv_calendar": {"type": "Variable", "def": "#include lv_calendar.h", "sline": 12, "include": ["carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar.h", null]}, "lv_dropdown": {"type": "Variable", "def": "#include ../../../widgets/lv_dropdown.h", "sline": 13}, "lv_flex": {"type": "Variable", "def": "#include ../../layouts/flex/lv_flex.h", "sline": 14}, "my_constructor": {"type": "Function", "def": "static void my_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 73, "body": "{\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    LV_UNUSED(class_p);\n\n    lv_obj_t * calendar = lv_obj_get_parent(obj);\n    lv_obj_move_to_index(obj, 0);\n    lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_ROW);\n\n    lv_obj_t * year_dd = lv_dropdown_create(obj);\n    lv_dropdown_set_options(year_dd, year_list);\n    lv_obj_add_event_cb(year_dd, year_event_cb, LV_EVENT_VALUE_CHANGED, calendar);\n    lv_obj_set_flex_grow(year_dd, 1);\n\n    lv_obj_t * month_dd = lv_dropdown_create(obj);\n    lv_dropdown_set_options(month_dd, month_list);\n    lv_obj_add_event_cb(month_dd, month_event_cb, LV_EVENT_VALUE_CHANGED, calendar);\n    lv_obj_set_flex_grow(month_dd, 1);\n\n    lv_obj_add_event_cb(obj, value_changed_event_cb, LV_EVENT_VALUE_CHANGED, NULL);\n    /*Refresh the drop downs*/\n    lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n}"}, "year_event_cb": {"type": "Function", "def": "static void year_event_cb(lv_event_t * e)", "sline": 113, "body": "{\n    lv_obj_t * dropdown = lv_event_get_target(e);\n    lv_obj_t * calendar = lv_event_get_user_data(e);\n\n    uint16_t sel = lv_dropdown_get_selected(dropdown);\n\n    const lv_calendar_date_t * d;\n    d = lv_calendar_get_showed_date(calendar);\n    lv_calendar_date_t newd = *d;\n    newd.year = 2023 - sel;\n\n    lv_calendar_set_showed_date(calendar, newd.year, newd.month);\n}"}, "month_event_cb": {"type": "Function", "def": "static void month_event_cb(lv_event_t * e)", "sline": 98, "body": "{\n    lv_obj_t * dropdown = lv_event_get_target(e);\n    lv_obj_t * calendar = lv_event_get_user_data(e);\n\n    uint16_t sel = lv_dropdown_get_selected(dropdown);\n\n    const lv_calendar_date_t * d;\n    d = lv_calendar_get_showed_date(calendar);\n    lv_calendar_date_t newd = *d;\n    newd.month = sel + 1;\n\n    lv_calendar_set_showed_date(calendar, newd.year, newd.month);\n}"}, "value_changed_event_cb": {"type": "Function", "def": "static void value_changed_event_cb(lv_event_t * e)", "sline": 128, "body": "{\n    lv_obj_t * header = lv_event_get_target(e);\n    lv_obj_t * calendar = lv_obj_get_parent(header);\n    const lv_calendar_date_t * cur_date = lv_calendar_get_showed_date(calendar);\n\n    lv_obj_t * year_dd = lv_obj_get_child(header, 0);\n    lv_dropdown_set_selected(year_dd, 2023 - cur_date->year);\n\n    lv_obj_t * month_dd = lv_obj_get_child(header, 1);\n    lv_dropdown_set_selected(month_dd, cur_date->month - 1);\n}"}, "lv_calendar_header_dropdown_class": {"type": "Variable", "def": "const lv_obj_class_t lv_calendar_header_dropdown_class = {\n    .base_class = &lv_obj_class,\n    .width_def = LV_PCT(100),\n    .height_def = LV_SIZE_CONTENT,\n    .constructor_cb = my_constructor\n}", "sline": 35}, "month_list": {"type": "Variable", "def": "static const char * month_list = \"01\\n02\\n03\\n04\\n05\\n06\\n07\\n08\\n09\\n10\\n11\\n12\"", "sline": 42}, "year_list": {"type": "Variable", "def": "static const char * year_list = {\n    \"2023\\n2022\\n2021\\n\"\n    \"2020\\n2019\\n2018\\n2017\\n2016\\n2015\\n2014\\n2013\\n2012\\n2011\\n2010\\n2009\\n2008\\n2007\\n2006\\n2005\\n2004\\n2003\\n2002\\n2001\\n\"\n    \"2000\\n1999\\n1998\\n1997\\n1996\\n1995\\n1994\\n1993\\n1992\\n1991\\n1990\\n1989\\n1988\\n1987\\n1986\\n1985\\n1984\\n1983\\n1982\\n1981\\n\"\n    \"1980\\n1979\\n1978\\n1977\\n1976\\n1975\\n1974\\n1973\\n1972\\n1971\\n1970\\n1969\\n1968\\n1967\\n1966\\n1965\\n1964\\n1963\\n1962\\n1961\\n\"\n    \"1960\\n1959\\n1958\\n1957\\n1956\\n1955\\n1954\\n1953\\n1952\\n1951\\n1950\\n1949\\n1948\\n1947\\n1946\\n1945\\n1944\\n1943\\n1942\\n1941\\n\"\n    \"1940\\n1939\\n1938\\n1937\\n1936\\n1935\\n1934\\n1933\\n1932\\n1931\\n1930\\n1929\\n1928\\n1927\\n1926\\n1925\\n1924\\n1923\\n1922\\n1921\\n\"\n    \"1920\\n1919\\n1918\\n1917\\n1916\\n1915\\n1914\\n1913\\n1912\\n1911\\n1910\\n1909\\n1908\\n1907\\n1906\\n1905\\n1904\\n1903\\n1902\\n1901\"\n}", "sline": 43}, "lv_calendar_header_dropdown_create": {"type": "Function", "def": "lv_obj_t * lv_calendar_header_dropdown_create(lv_obj_t * parent)", "sline": 61, "body": "{\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_calendar_header_dropdown_class, parent);\n    lv_obj_class_init_obj(obj);\n\n    return obj;\n}"}, "carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar_header_dropdown.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar_header_dropdown.c"}}, "carbit_updater/lvgl/src/core/lv_obj_class.c": {"lv_obj": {"type": "Variable", "def": "#include lv_obj.h", "sline": 9, "include": ["carbit_updater/lvgl/src/core/lv_obj.h", null]}, "lv_theme": {"type": "Variable", "def": "#include lv_theme.h", "sline": 10, "include": ["carbit_updater/lvgl/src/core/lv_theme.h", null]}, "lv_obj_construct": {"type": "Function", "def": "static void lv_obj_construct(lv_obj_t * obj)", "sline": 174, "body": "{\n    const lv_obj_class_t * original_class_p = obj->class_p;\n\n    if(obj->class_p->base_class) {\n        /*Don't let the descendant methods run during constructing the ancestor type*/\n        obj->class_p = obj->class_p->base_class;\n\n        /*Construct the base first*/\n        lv_obj_construct(obj);\n    }\n\n    /*Restore the original class*/\n    obj->class_p = original_class_p;\n\n    if(obj->class_p->constructor_cb) obj->class_p->constructor_cb(obj->class_p, obj);\n}"}, "get_instance_size": {"type": "Function", "def": "static uint32_t get_instance_size(const lv_obj_class_t * class_p)", "sline": 192, "body": "{\n    /*Find a base in which instance size is set*/\n    const lv_obj_class_t * base = class_p;\n    while(base && base->instance_size == 0) base = base->base_class;\n\n    if(base == NULL) return 0;  /*Never happens: set at least in `lv_obj` class*/\n\n    return base->instance_size;\n}"}, "lv_obj_class_create_obj": {"type": "Function", "def": "lv_obj_t * lv_obj_class_create_obj(const lv_obj_class_t * class_p, lv_obj_t * parent)", "sline": 43, "body": "{\n    LV_TRACE_OBJ_CREATE(\"Creating object with %p class on %p parent\", (void *)class_p, (void *)parent);\n    uint32_t s = get_instance_size(class_p);\n    lv_obj_t * obj = lv_mem_alloc(s);\n    if(obj == NULL) return NULL;\n    lv_memset_00(obj, s);\n    obj->class_p = class_p;\n    obj->parent = parent;\n\n    /*Create a screen*/\n    if(parent == NULL) {\n        LV_TRACE_OBJ_CREATE(\"creating a screen\");\n        lv_disp_t * disp = lv_disp_get_default();\n        if(!disp) {\n            LV_LOG_WARN(\"No display created to so far. No place to assign the new screen\");\n            return NULL;\n        }\n\n        if(disp->screens == NULL) {\n            disp->screens = lv_mem_alloc(sizeof(lv_obj_t *));\n            disp->screens[0] = obj;\n            disp->screen_cnt = 1;\n        }\n        else {\n            disp->screen_cnt++;\n            disp->screens = lv_mem_realloc(disp->screens, sizeof(lv_obj_t *) * disp->screen_cnt);\n            disp->screens[disp->screen_cnt - 1] = obj;\n        }\n\n        /*Set coordinates to full screen size*/\n        obj->coords.x1 = 0;\n        obj->coords.y1 = 0;\n        obj->coords.x2 = lv_disp_get_hor_res(NULL) - 1;\n        obj->coords.y2 = lv_disp_get_ver_res(NULL) - 1;\n    }\n    /*Create a normal object*/\n    else {\n        LV_TRACE_OBJ_CREATE(\"creating normal object\");\n        LV_ASSERT_OBJ(parent, MY_CLASS);\n        if(parent->spec_attr == NULL) {\n            lv_obj_allocate_spec_attr(parent);\n        }\n\n        if(parent->spec_attr->children == NULL) {\n            parent->spec_attr->children = lv_mem_alloc(sizeof(lv_obj_t *));\n            parent->spec_attr->children[0] = obj;\n            parent->spec_attr->child_cnt = 1;\n        }\n        else {\n            parent->spec_attr->child_cnt++;\n            parent->spec_attr->children = lv_mem_realloc(parent->spec_attr->children,\n                                                         sizeof(lv_obj_t *) * parent->spec_attr->child_cnt);\n            parent->spec_attr->children[parent->spec_attr->child_cnt - 1] = obj;\n        }\n    }\n\n    return obj;\n}"}, "lv_obj_class_init_obj": {"type": "Function", "def": "void lv_obj_class_init_obj(lv_obj_t * obj)", "sline": 103, "body": "{\n    lv_obj_mark_layout_as_dirty(obj);\n    lv_obj_enable_style_refresh(false);\n\n    lv_theme_apply(obj);\n    lv_obj_construct(obj);\n\n    lv_obj_enable_style_refresh(true);\n    lv_obj_refresh_style(obj, LV_PART_ANY, LV_STYLE_PROP_ANY);\n\n    lv_obj_refresh_self_size(obj);\n\n    lv_group_t * def_group = lv_group_get_default();\n    if(def_group && lv_obj_is_group_def(obj)) {\n        lv_group_add_obj(def_group, obj);\n    }\n\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    if(parent) {\n        /*Call the ancestor's event handler to the parent to notify it about the new child.\n         *Also triggers layout update*/\n        lv_event_send(parent, LV_EVENT_CHILD_CHANGED, obj);\n        lv_event_send(parent, LV_EVENT_CHILD_CREATED, obj);\n\n        /*Invalidate the area if not screen created*/\n        lv_obj_invalidate(obj);\n    }\n}"}, "_lv_obj_destruct": {"type": "Function", "def": "void _lv_obj_destruct(lv_obj_t * obj)", "sline": 133, "body": "{\n    if(obj->class_p->destructor_cb) obj->class_p->destructor_cb(obj->class_p, obj);\n\n    if(obj->class_p->base_class) {\n        /*Don't let the descendant methods run during destructing the ancestor type*/\n        obj->class_p = obj->class_p->base_class;\n\n        /*Call the base class's destructor too*/\n        _lv_obj_destruct(obj);\n    }\n}"}, "lv_obj_is_editable": {"type": "Function", "def": "bool lv_obj_is_editable(lv_obj_t * obj)", "sline": 146, "body": "{\n    const lv_obj_class_t * class_p = obj->class_p;\n\n    /*Find a base in which editable is set*/\n    while(class_p && class_p->editable == LV_OBJ_CLASS_EDITABLE_INHERIT) class_p = class_p->base_class;\n\n    if(class_p == NULL) return false;\n\n    return class_p->editable == LV_OBJ_CLASS_EDITABLE_TRUE ? true : false;\n}"}, "lv_obj_is_group_def": {"type": "Function", "def": "bool lv_obj_is_group_def(lv_obj_t * obj)", "sline": 158, "body": "{\n    const lv_obj_class_t * class_p = obj->class_p;\n\n    /*Find a base in which group_def is set*/\n    while(class_p && class_p->group_def == LV_OBJ_CLASS_GROUP_DEF_INHERIT) class_p = class_p->base_class;\n\n    if(class_p == NULL) return false;\n\n    return class_p->group_def == LV_OBJ_CLASS_GROUP_DEF_TRUE ? true : false;\n}"}, "carbit_updater/lvgl/src/core/lv_obj_class.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_class.c"}}, "carbit_updater/lvgl/src/widgets/lv_textarea.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "lv_obj": {"type": "Variable", "def": "#include ../core/lv_obj.h", "sline": 25}, "lv_label": {"type": "Variable", "def": "#include lv_label.h", "sline": 26, "include": ["carbit_updater/lvgl/src/widgets/lv_label.h", null]}, "_silence_gcc_warning": {"type": "Struct", "def": "LV_EXPORT_CONST_INT(LV_TEXTAREA_CURSOR_LAST)", "sline": 33}, "lv_textarea_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 41, "in_struct": "lv_textarea_t"}, "lv_textarea_t.label": {"type": "Variable", "def": "lv_obj_t * label", "sline": 42, "in_struct": "lv_textarea_t"}, "lv_textarea_t.placeholder_txt": {"type": "Variable", "def": "char * placeholder_txt", "sline": 43, "in_struct": "lv_textarea_t"}, "lv_textarea_t.pwd_tmp": {"type": "Variable", "def": "char * pwd_tmp", "sline": 44, "in_struct": "lv_textarea_t"}, "lv_textarea_t.accepted_chars": {"type": "Variable", "def": "const char * accepted_chars", "sline": 45, "in_struct": "lv_textarea_t"}, "lv_textarea_t.max_length": {"type": "Variable", "def": "uint32_t max_length", "sline": 46, "in_struct": "lv_textarea_t"}, "lv_textarea_t.pwd_show_time": {"type": "Variable", "def": "uint16_t pwd_show_time", "sline": 47, "in_struct": "lv_textarea_t"}, "lv_textarea_t.cursor": {"type": "Variable", "def": "struct {\n        lv_coord_t valid_x;        /*Used when stepping up/down to a shorter line.\n                                    *(Used by the library)*/\n        uint32_t pos;              /*The current cursor position\n                                    *(0: before 1st letter; 1: before 2nd letter ...)*/\n        lv_area_t area;            /*Cursor area relative to the Text Area*/\n        uint32_t txt_byte_pos;     /*Byte index of the letter after (on) the cursor*/\n        uint8_t show : 1;          /*Cursor is visible now or not (Handled by the library)*/\n        uint8_t click_pos : 1;     /*1: Enable positioning the cursor by clicking the text area*/\n    } cursor", "sline": 57, "in_struct": "lv_textarea_t"}, "lv_textarea_t.sel_start": {"type": "Variable", "def": "uint32_t sel_start", "sline": 59, "in_struct": "lv_textarea_t"}, "lv_textarea_t.sel_end": {"type": "Variable", "def": "uint32_t sel_end", "sline": 60, "in_struct": "lv_textarea_t"}, "lv_textarea_t.text_sel_in_prog": {"type": "Variable", "def": "uint8_t text_sel_in_prog : 1", "sline": 61, "in_struct": "lv_textarea_t"}, "lv_textarea_t.text_sel_en": {"type": "Variable", "def": "uint8_t text_sel_en : 1", "sline": 62, "in_struct": "lv_textarea_t"}, "lv_textarea_t.pwd_mode": {"type": "Variable", "def": "uint8_t pwd_mode : 1", "sline": 64, "in_struct": "lv_textarea_t"}, "lv_textarea_t.one_line": {"type": "Variable", "def": "uint8_t one_line : 1", "sline": 65, "in_struct": "lv_textarea_t"}, "lv_textarea_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    lv_obj_t * label;            /*Label of the text area*/\n    char * placeholder_txt;      /*Place holder label. only visible if text is an empty string*/\n    char * pwd_tmp;              /*Used to store the original text in password mode*/\n    const char * accepted_chars; /*Only these characters will be accepted. NULL: accept all*/\n    uint32_t max_length;         /*The max. number of characters. 0: no limit*/\n    uint16_t pwd_show_time;      /*Time to show characters in password mode before change them to '*'*/\n    struct {\n        lv_coord_t valid_x;        /*Used when stepping up/down to a shorter line.\n                                    *(Used by the library)*/\n        uint32_t pos;              /*The current cursor position\n                                    *(0: before 1st letter; 1: before 2nd letter ...)*/\n        lv_area_t area;            /*Cursor area relative to the Text Area*/\n        uint32_t txt_byte_pos;     /*Byte index of the letter after (on) the cursor*/\n        uint8_t show : 1;          /*Cursor is visible now or not (Handled by the library)*/\n        uint8_t click_pos : 1;     /*1: Enable positioning the cursor by clicking the text area*/\n    } cursor;\n#if LV_LABEL_TEXT_SELECTION\n    uint32_t sel_start;  /*Temporary values for text selection*/\n    uint32_t sel_end;\n    uint8_t text_sel_in_prog : 1; /*User is in process of selecting*/\n    uint8_t text_sel_en : 1;      /*Text can be selected on this text area*/\n#endif\n    uint8_t pwd_mode : 1; /*Replace characters with '*'*/\n    uint8_t one_line : 1; /*One line mode (ignore line breaks)*/\n} lv_textarea_t", "sline": 66, "docstring": "/*Data of text area*/"}, "lv_textarea_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_textarea_class", "sline": 68}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_textarea.h:70:1)": {"type": "Enum", "def": "enum {\n    LV_PART_TEXTAREA_PLACEHOLDER = LV_PART_CUSTOM_FIRST,\n}", "sline": 70}, "lv_textarea_create": {"type": "Function", "def": "lv_obj_t * lv_textarea_create(lv_obj_t * parent)", "sline": 83}, "lv_textarea_add_char": {"type": "Function", "def": "void lv_textarea_add_char(lv_obj_t * obj, uint32_t c)", "sline": 95}, "lv_textarea_add_text": {"type": "Function", "def": "void lv_textarea_add_text(lv_obj_t * obj, const char * txt)", "sline": 102}, "lv_textarea_del_char": {"type": "Function", "def": "void lv_textarea_del_char(lv_obj_t * obj)", "sline": 108}, "lv_textarea_del_char_forward": {"type": "Function", "def": "void lv_textarea_del_char_forward(lv_obj_t * obj)", "sline": 114}, "lv_textarea_set_text": {"type": "Function", "def": "void lv_textarea_set_text(lv_obj_t * obj, const char * txt)", "sline": 125}, "lv_textarea_set_placeholder_text": {"type": "Function", "def": "void lv_textarea_set_placeholder_text(lv_obj_t * obj, const char * txt)", "sline": 132}, "lv_textarea_set_cursor_pos": {"type": "Function", "def": "void lv_textarea_set_cursor_pos(lv_obj_t * obj, int32_t pos)", "sline": 141}, "lv_textarea_set_cursor_click_pos": {"type": "Function", "def": "void lv_textarea_set_cursor_click_pos(lv_obj_t * obj, bool en)", "sline": 148}, "lv_textarea_set_password_mode": {"type": "Function", "def": "void lv_textarea_set_password_mode(lv_obj_t * obj, bool en)", "sline": 155}, "lv_textarea_set_one_line": {"type": "Function", "def": "void lv_textarea_set_one_line(lv_obj_t * obj, bool en)", "sline": 162}, "lv_textarea_set_accepted_chars": {"type": "Function", "def": "void lv_textarea_set_accepted_chars(lv_obj_t * obj, const char * list)", "sline": 169}, "lv_textarea_set_max_length": {"type": "Function", "def": "void lv_textarea_set_max_length(lv_obj_t * obj, uint32_t num)", "sline": 176}, "lv_textarea_set_insert_replace": {"type": "Function", "def": "void lv_textarea_set_insert_replace(lv_obj_t * obj, const char * txt)", "sline": 185}, "lv_textarea_set_text_selection": {"type": "Function", "def": "void lv_textarea_set_text_selection(lv_obj_t * obj, bool en)", "sline": 192}, "lv_textarea_set_password_show_time": {"type": "Function", "def": "void lv_textarea_set_password_show_time(lv_obj_t * obj, uint16_t time)", "sline": 199}, "lv_textarea_set_align": {"type": "Function", "def": "void lv_textarea_set_align(lv_obj_t * obj, lv_text_align_t align)", "sline": 209}, "lv_textarea_get_text": {"type": "Function", "def": "const char * lv_textarea_get_text(const lv_obj_t * obj)", "sline": 220}, "lv_textarea_get_placeholder_text": {"type": "Function", "def": "const char * lv_textarea_get_placeholder_text(lv_obj_t * obj)", "sline": 227}, "lv_textarea_get_label": {"type": "Function", "def": "lv_obj_t * lv_textarea_get_label(const lv_obj_t * obj)", "sline": 234}, "lv_textarea_get_cursor_pos": {"type": "Function", "def": "uint32_t lv_textarea_get_cursor_pos(const lv_obj_t * obj)", "sline": 241}, "lv_textarea_get_cursor_click_pos": {"type": "Function", "def": "bool lv_textarea_get_cursor_click_pos(lv_obj_t * obj)", "sline": 248}, "lv_textarea_get_password_mode": {"type": "Function", "def": "bool lv_textarea_get_password_mode(const lv_obj_t * obj)", "sline": 255}, "lv_textarea_get_one_line": {"type": "Function", "def": "bool lv_textarea_get_one_line(const lv_obj_t * obj)", "sline": 262}, "lv_textarea_get_accepted_chars": {"type": "Function", "def": "const char * lv_textarea_get_accepted_chars(lv_obj_t * obj)", "sline": 269}, "lv_textarea_get_max_length": {"type": "Function", "def": "uint32_t lv_textarea_get_max_length(lv_obj_t * obj)", "sline": 276}, "lv_textarea_text_is_selected": {"type": "Function", "def": "bool lv_textarea_text_is_selected(const lv_obj_t * obj)", "sline": 283}, "lv_textarea_get_text_selection": {"type": "Function", "def": "bool lv_textarea_get_text_selection(lv_obj_t * obj)", "sline": 290}, "lv_textarea_get_password_show_time": {"type": "Function", "def": "uint16_t lv_textarea_get_password_show_time(lv_obj_t * obj)", "sline": 297}, "lv_textarea_clear_selection": {"type": "Function", "def": "void lv_textarea_clear_selection(lv_obj_t * obj)", "sline": 307}, "lv_textarea_cursor_right": {"type": "Function", "def": "void lv_textarea_cursor_right(lv_obj_t * obj)", "sline": 313}, "lv_textarea_cursor_left": {"type": "Function", "def": "void lv_textarea_cursor_left(lv_obj_t * obj)", "sline": 319}, "lv_textarea_cursor_down": {"type": "Function", "def": "void lv_textarea_cursor_down(lv_obj_t * obj)", "sline": 325}, "lv_textarea_cursor_up": {"type": "Function", "def": "void lv_textarea_cursor_up(lv_obj_t * obj)", "sline": 331}, "carbit_updater/lvgl/src/widgets/lv_textarea.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_textarea.h"}}, "carbit_updater/lvgl/src/gpu/lv_gpu_sdl.c": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 11}, "carbit_updater/lvgl/src/gpu/lv_gpu_sdl.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_sdl.c"}}, "carbit_updater/lvgl/tests/unity/unity_support.c": {"carbit_updater/lvgl/tests/unity/unity_support.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/tests/unity/unity_support.c"}}, "carbit_updater/lvgl/src/hal/lv_hal_indev.c": {"lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 11}, "lv_hal_indev": {"type": "Variable", "def": "#include ../hal/lv_hal_indev.h", "sline": 12}, "lv_indev": {"type": "Variable", "def": "#include ../core/lv_indev.h", "sline": 13}, "lv_mem": {"type": "Variable", "def": "#include ../misc/lv_mem.h", "sline": 14}, "lv_gc": {"type": "Variable", "def": "#include ../misc/lv_gc.h", "sline": 15}, "lv_hal_disp": {"type": "Variable", "def": "#include lv_hal_disp.h", "sline": 16, "include": ["carbit_updater/lvgl/src/hal/lv_hal_disp.h", null]}, "lv_indev_drv_init": {"type": "Function", "def": "void lv_indev_drv_init(lv_indev_drv_t * driver)", "sline": 57, "body": "{\n    lv_memset_00(driver, sizeof(lv_indev_drv_t));\n\n    driver->type                 = LV_INDEV_TYPE_NONE;\n    driver->scroll_limit         = LV_INDEV_DEF_SCROLL_LIMIT;\n    driver->scroll_throw         = LV_INDEV_DEF_SCROLL_THROW;\n    driver->long_press_time      = LV_INDEV_DEF_LONG_PRESS_TIME;\n    driver->long_press_repeat_time  = LV_INDEV_DEF_LONG_PRESS_REP_TIME;\n    driver->gesture_limit        = LV_INDEV_DEF_GESTURE_LIMIT;\n    driver->gesture_min_velocity = LV_INDEV_DEF_GESTURE_MIN_VELOCITY;\n}"}, "lv_indev_drv_register": {"type": "Function", "def": "lv_indev_t * lv_indev_drv_register(lv_indev_drv_t * driver)", "sline": 76, "body": "{\n\n    if(driver->disp == NULL) driver->disp = lv_disp_get_default();\n\n    if(driver->disp == NULL) {\n        LV_LOG_WARN(\"lv_indev_drv_register: no display registered hence can't attach the indev to \"\n                    \"a display\");\n        return NULL;\n    }\n\n    lv_indev_t * indev = _lv_ll_ins_head(&LV_GC_ROOT(_lv_indev_ll));\n    if(!indev) {\n        LV_ASSERT_MALLOC(indev);\n        return NULL;\n    }\n\n    lv_memset_00(indev, sizeof(lv_indev_t));\n    indev->driver = driver;\n\n    indev->proc.reset_query  = 1;\n    indev->driver->read_timer = lv_timer_create(lv_indev_read_timer_cb, LV_INDEV_DEF_READ_PERIOD, indev);\n\n    return indev;\n}"}, "lv_indev_drv_update": {"type": "Function", "def": "void lv_indev_drv_update(lv_indev_t * indev, lv_indev_drv_t * new_drv)", "sline": 107, "body": "{\n    indev->driver = new_drv;\n}"}, "lv_indev_get_next": {"type": "Function", "def": "lv_indev_t * lv_indev_get_next(lv_indev_t * indev)", "sline": 118, "body": "{\n    if(indev == NULL)\n        return _lv_ll_get_head(&LV_GC_ROOT(_lv_indev_ll));\n    else\n        return _lv_ll_get_next(&LV_GC_ROOT(_lv_indev_ll), indev);\n}"}, "_lv_indev_read": {"type": "Function", "def": "void _lv_indev_read(lv_indev_t * indev, lv_indev_data_t * data)", "sline": 131, "body": "{\n    lv_memset_00(data, sizeof(lv_indev_data_t));\n\n    /* For touchpad sometimes users don't set the last pressed coordinate on release.\n     * So be sure a coordinates are initialized to the last point */\n    if(indev->driver->type == LV_INDEV_TYPE_POINTER) {\n        data->point.x = indev->proc.types.pointer.last_raw_point.x;\n        data->point.y = indev->proc.types.pointer.last_raw_point.y;\n    }\n    /*Similarly set at least the last key in case of the user doesn't set it on release*/\n    else if(indev->driver->type == LV_INDEV_TYPE_KEYPAD) {\n        data->key = indev->proc.types.keypad.last_key;\n    }\n    /*For compatibility assume that used button was enter (encoder push)*/\n    else if(indev->driver->type == LV_INDEV_TYPE_ENCODER) {\n        data->key = LV_KEY_ENTER;\n    }\n\n    if(indev->driver->read_cb) {\n        INDEV_TRACE(\"calling indev_read_cb\");\n        indev->driver->read_cb(indev->driver, data);\n    }\n    else {\n        LV_LOG_WARN(\"indev_read_cb is not registered\");\n    }\n}"}, "carbit_updater/lvgl/src/hal/lv_hal_indev.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/hal/lv_hal_indev.c"}}, "carbit_updater/lvgl/src/gpu/lv_gpu_nxp_pxp_osa.c": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 34}, "lv_log": {"type": "Variable", "def": "#include ../misc/lv_log.h", "sline": 35}, "carbit_updater/lvgl/src/gpu/lv_gpu_nxp_pxp_osa.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_pxp_osa.c"}}, "carbit_updater/lvgl/src/extra/libs/fsdrv/lv_fsdrv.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../../../lv_conf_internal.h", "sline": 16}, "carbit_updater/lvgl/src/extra/libs/fsdrv/lv_fsdrv.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/fsdrv/lv_fsdrv.h"}}, "carbit_updater/lvgl/src/extra/layouts/flex/lv_flex.c": {"lv_layouts": {"type": "Variable", "def": "#include ../lv_layouts.h", "sline": 9}, "flex_t.main_place": {"type": "Variable", "def": "lv_flex_align_t main_place", "sline": 21, "in_struct": "flex_t"}, "flex_t.cross_place": {"type": "Variable", "def": "lv_flex_align_t cross_place", "sline": 22, "in_struct": "flex_t"}, "flex_t.track_place": {"type": "Variable", "def": "lv_flex_align_t track_place", "sline": 23, "in_struct": "flex_t"}, "flex_t.row": {"type": "Variable", "def": "uint8_t row : 1", "sline": 24, "in_struct": "flex_t"}, "flex_t.wrap": {"type": "Variable", "def": "uint8_t wrap : 1", "sline": 25, "in_struct": "flex_t"}, "flex_t.rev": {"type": "Variable", "def": "uint8_t rev : 1", "sline": 26, "in_struct": "flex_t"}, "flex_t": {"type": "Variable", "def": "typedef struct {\n    lv_flex_align_t main_place;\n    lv_flex_align_t cross_place;\n    lv_flex_align_t track_place;\n    uint8_t row : 1;\n    uint8_t wrap : 1;\n    uint8_t rev : 1;\n} flex_t", "sline": 27, "docstring": "/**********************"}, "grow_dsc_t.item": {"type": "Variable", "def": "lv_obj_t * item", "sline": 30, "in_struct": "grow_dsc_t"}, "grow_dsc_t.min_size": {"type": "Variable", "def": "lv_coord_t min_size", "sline": 31, "in_struct": "grow_dsc_t"}, "grow_dsc_t.max_size": {"type": "Variable", "def": "lv_coord_t max_size", "sline": 32, "in_struct": "grow_dsc_t"}, "grow_dsc_t.final_size": {"type": "Variable", "def": "lv_coord_t final_size", "sline": 33, "in_struct": "grow_dsc_t"}, "grow_dsc_t.grow_value": {"type": "Variable", "def": "uint32_t grow_value", "sline": 34, "in_struct": "grow_dsc_t"}, "grow_dsc_t.clamped": {"type": "Variable", "def": "uint32_t clamped : 1", "sline": 35, "in_struct": "grow_dsc_t"}, "grow_dsc_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t * item;\n    lv_coord_t min_size;\n    lv_coord_t max_size;\n    lv_coord_t final_size;\n    uint32_t grow_value;\n    uint32_t clamped : 1;\n} grow_dsc_t", "sline": 36}, "track_t.track_cross_size": {"type": "Variable", "def": "lv_coord_t track_cross_size", "sline": 39, "in_struct": "track_t"}, "track_t.track_main_size": {"type": "Variable", "def": "lv_coord_t track_main_size", "sline": 40, "in_struct": "track_t"}, "track_t.track_fix_main_size": {"type": "Variable", "def": "lv_coord_t track_fix_main_size", "sline": 41, "in_struct": "track_t"}, "track_t.item_cnt": {"type": "Variable", "def": "uint32_t item_cnt", "sline": 42, "in_struct": "track_t"}, "track_t.grow_dsc": {"type": "Variable", "def": "grow_dsc_t * grow_dsc", "sline": 43, "in_struct": "track_t"}, "track_t.grow_item_cnt": {"type": "Variable", "def": "uint32_t grow_item_cnt", "sline": 44, "in_struct": "track_t"}, "track_t.grow_dsc_calc": {"type": "Variable", "def": "uint32_t grow_dsc_calc : 1", "sline": 45, "in_struct": "track_t"}, "track_t": {"type": "Variable", "def": "typedef struct {\n    lv_coord_t track_cross_size;\n    lv_coord_t track_main_size;         /*For all items*/\n    lv_coord_t track_fix_main_size;     /*For non grow items*/\n    uint32_t item_cnt;\n    grow_dsc_t * grow_dsc;\n    uint32_t grow_item_cnt;\n    uint32_t grow_dsc_calc : 1;\n} track_t", "sline": 46}, "flex_update": {"type": "Function", "def": "static void flex_update(lv_obj_t * cont, void * user_data)", "sline": 209, "body": "{\n    LV_LOG_INFO(\"update %p container\", (void *)cont);\n    LV_UNUSED(user_data);\n\n    flex_t f;\n    lv_flex_flow_t flow = lv_obj_get_style_flex_flow(cont, LV_PART_MAIN);\n    f.row = flow & _LV_FLEX_COLUMN ? 0 : 1;\n    f.wrap = flow & _LV_FLEX_WRAP ? 1 : 0;\n    f.rev = flow & _LV_FLEX_REVERSE ? 1 : 0;\n    f.main_place = lv_obj_get_style_flex_main_place(cont, LV_PART_MAIN);\n    f.cross_place = lv_obj_get_style_flex_cross_place(cont, LV_PART_MAIN);\n    f.track_place = lv_obj_get_style_flex_track_place(cont, LV_PART_MAIN);\n\n    bool rtl = lv_obj_get_style_base_dir(cont, LV_PART_MAIN) == LV_BASE_DIR_RTL ? true : false;\n    lv_coord_t track_gap = !f.row ? lv_obj_get_style_pad_column(cont, LV_PART_MAIN) : lv_obj_get_style_pad_row(cont,\n                                                                                                               LV_PART_MAIN);\n    lv_coord_t item_gap = f.row ? lv_obj_get_style_pad_column(cont, LV_PART_MAIN) : lv_obj_get_style_pad_row(cont,\n                                                                                                             LV_PART_MAIN);\n    lv_coord_t max_main_size = (f.row ? lv_obj_get_content_width(cont) : lv_obj_get_content_height(cont));\n    lv_coord_t border_width = lv_obj_get_style_border_width(cont, LV_PART_MAIN);\n    lv_coord_t abs_y = cont->coords.y1 + lv_obj_get_style_pad_top(cont,\n                                                                  LV_PART_MAIN) + border_width - lv_obj_get_scroll_y(cont);\n    lv_coord_t abs_x = cont->coords.x1 + lv_obj_get_style_pad_left(cont,\n                                                                   LV_PART_MAIN) + border_width - lv_obj_get_scroll_x(cont);\n\n    lv_flex_align_t track_cross_place = f.track_place;\n    lv_coord_t * cross_pos = (f.row ? &abs_y : &abs_x);\n\n    lv_coord_t w_set = lv_obj_get_style_width(cont, LV_PART_MAIN);\n    lv_coord_t h_set = lv_obj_get_style_height(cont, LV_PART_MAIN);\n\n    /*Content sized objects should squeezed the gap between the children, therefore any alignment will look like `START`*/\n    if((f.row && h_set == LV_SIZE_CONTENT && cont->h_layout == 0) ||\n       (!f.row && w_set == LV_SIZE_CONTENT && cont->w_layout == 0)) {\n        track_cross_place = LV_FLEX_ALIGN_START;\n    }\n\n    if(rtl && !f.row) {\n        if(track_cross_place == LV_FLEX_ALIGN_START) track_cross_place = LV_FLEX_ALIGN_END;\n        else if(track_cross_place == LV_FLEX_ALIGN_END) track_cross_place = LV_FLEX_ALIGN_START;\n    }\n\n    lv_coord_t total_track_cross_size = 0;\n    lv_coord_t gap = 0;\n    uint32_t track_cnt = 0;\n    int32_t track_first_item;\n    int32_t next_track_first_item;\n\n    if(track_cross_place != LV_FLEX_ALIGN_START) {\n        track_first_item = f.rev ? cont->spec_attr->child_cnt - 1 : 0;\n        track_t t;\n        while(track_first_item < (int32_t)cont->spec_attr->child_cnt && track_first_item >= 0) {\n            /*Search the first item of the next row*/\n            t.grow_dsc_calc = 0;\n            next_track_first_item = find_track_end(cont, &f, track_first_item, max_main_size, item_gap, &t);\n            total_track_cross_size += t.track_cross_size + track_gap;\n            track_cnt++;\n            track_first_item = next_track_first_item;\n        }\n\n        if(track_cnt) total_track_cross_size -= track_gap;   /*No gap after the last track*/\n\n        /*Place the tracks to get the start position*/\n        lv_coord_t max_cross_size = (f.row ? lv_obj_get_content_height(cont) : lv_obj_get_content_width(cont));\n        place_content(track_cross_place, max_cross_size, total_track_cross_size, track_cnt, cross_pos, &gap);\n    }\n\n    track_first_item =  f.rev ? cont->spec_attr->child_cnt - 1 : 0;\n\n    if(rtl && !f.row) {\n        *cross_pos += total_track_cross_size;\n    }\n\n    while(track_first_item < (int32_t)cont->spec_attr->child_cnt && track_first_item >= 0) {\n        track_t t;\n        t.grow_dsc_calc = 1;\n        /*Search the first item of the next row*/\n        next_track_first_item = find_track_end(cont, &f, track_first_item, max_main_size, item_gap, &t);\n\n        if(rtl && !f.row) {\n            *cross_pos -= t.track_cross_size;\n        }\n        children_repos(cont, &f, track_first_item, next_track_first_item, abs_x, abs_y, max_main_size, item_gap, &t);\n        track_first_item = next_track_first_item;\n        lv_mem_buf_release(t.grow_dsc);\n        t.grow_dsc = NULL;\n        if(rtl && !f.row) {\n            *cross_pos -= gap + track_gap;\n        }\n        else {\n            *cross_pos += t.track_cross_size + gap + track_gap;\n        }\n    }\n    LV_ASSERT_MEM_INTEGRITY();\n\n    if(w_set == LV_SIZE_CONTENT || h_set == LV_SIZE_CONTENT) {\n        lv_obj_refr_size(cont);\n    }\n\n    lv_event_send(cont, LV_EVENT_LAYOUT_CHANGED, NULL);\n\n    LV_TRACE_LAYOUT(\"finished\");\n}"}, "find_track_end": {"type": "Function", "def": "static int32_t find_track_end(lv_obj_t * cont, flex_t * f, int32_t item_start_id, lv_coord_t max_main_size,\n                              lv_coord_t item_gap, track_t * t)", "sline": 317, "docstring": "/**", "body": "{\n    lv_coord_t w_set = lv_obj_get_style_width(cont, LV_PART_MAIN);\n    lv_coord_t h_set = lv_obj_get_style_height(cont, LV_PART_MAIN);\n\n    /*Can't wrap if the size if auto (i.e. the size depends on the children)*/\n    if(f->wrap && ((f->row && w_set == LV_SIZE_CONTENT) || (!f->row && h_set == LV_SIZE_CONTENT))) {\n        f->wrap = false;\n    }\n    lv_coord_t(*get_main_size)(const lv_obj_t *) = (f->row ? lv_obj_get_width : lv_obj_get_height);\n    lv_coord_t(*get_cross_size)(const lv_obj_t *) = (!f->row ? lv_obj_get_width : lv_obj_get_height);\n\n    t->track_main_size = 0;\n    t->track_fix_main_size = 0;\n    t->grow_item_cnt = 0;\n    t->track_cross_size = 0;\n    t->item_cnt = 0;\n    t->grow_dsc = NULL;\n\n    int32_t item_id = item_start_id;\n\n    lv_obj_t * item = lv_obj_get_child(cont, item_id);\n    while(item) {\n        if(item_id != item_start_id && lv_obj_has_flag(item, LV_OBJ_FLAG_FLEX_IN_NEW_TRACK)) break;\n\n        if(!lv_obj_has_flag_any(item, LV_OBJ_FLAG_IGNORE_LAYOUT | LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) {\n            uint8_t grow_value = lv_obj_get_style_flex_grow(item, LV_PART_MAIN);\n            if(grow_value) {\n                t->grow_item_cnt++;\n                t->track_fix_main_size += item_gap;\n                if(t->grow_dsc_calc) {\n                    grow_dsc_t * new_dsc = lv_mem_buf_get(sizeof(grow_dsc_t) * (t->grow_item_cnt));\n                    LV_ASSERT_MALLOC(new_dsc);\n                    if(new_dsc == NULL) return item_id;\n\n                    if(t->grow_dsc) {\n                        lv_memcpy(new_dsc, t->grow_dsc, sizeof(grow_dsc_t) * (t->grow_item_cnt - 1));\n                        lv_mem_buf_release(t->grow_dsc);\n                    }\n                    new_dsc[t->grow_item_cnt - 1].item = item;\n                    new_dsc[t->grow_item_cnt - 1].min_size = f->row ? lv_obj_get_style_min_width(item,\n                                                                                                 LV_PART_MAIN) : lv_obj_get_style_min_height(item, LV_PART_MAIN);\n                    new_dsc[t->grow_item_cnt - 1].max_size = f->row ? lv_obj_get_style_max_width(item,\n                                                                                                 LV_PART_MAIN) : lv_obj_get_style_max_height(item, LV_PART_MAIN);\n                    new_dsc[t->grow_item_cnt - 1].grow_value = grow_value;\n                    new_dsc[t->grow_item_cnt - 1].clamped = 0;\n                    t->grow_dsc = new_dsc;\n                }\n            }\n            else {\n                lv_coord_t item_size = get_main_size(item);\n                if(f->wrap && t->track_fix_main_size + item_size > max_main_size) break;\n                t->track_fix_main_size += item_size + item_gap;\n            }\n\n\n            t->track_cross_size = LV_MAX(get_cross_size(item), t->track_cross_size);\n            t->item_cnt++;\n        }\n\n        item_id += f->rev ? -1 : +1;\n        if(item_id < 0) break;\n        item = lv_obj_get_child(cont, item_id);\n    }\n\n    if(t->track_fix_main_size > 0) t->track_fix_main_size -= item_gap; /*There is no gap after the last item*/\n\n    /*If there is at least one \"grow item\" the track takes the full space*/\n    t->track_main_size = t->grow_item_cnt ? max_main_size : t->track_fix_main_size;\n\n    /*Have at least one item in a row*/\n    if(item && item_id == item_start_id) {\n        item = cont->spec_attr->children[item_id];\n        get_next_item(cont, f->rev, &item_id);\n        if(item) {\n            t->track_cross_size = get_cross_size(item);\n            t->track_main_size = get_main_size(item);\n            t->item_cnt = 1;\n        }\n    }\n\n    return item_id;\n}"}, "children_repos": {"type": "Function", "def": "static void children_repos(lv_obj_t * cont, flex_t * f, int32_t item_first_id, int32_t item_last_id, lv_coord_t abs_x,\n                           lv_coord_t abs_y, lv_coord_t max_main_size, lv_coord_t item_gap, track_t * t)", "sline": 405, "docstring": "/**", "body": "{\n    void (*area_set_main_size)(lv_area_t *, lv_coord_t) = (f->row ? lv_area_set_width : lv_area_set_height);\n    lv_coord_t (*area_get_main_size)(const lv_area_t *) = (f->row ? lv_area_get_width : lv_area_get_height);\n    lv_coord_t (*area_get_cross_size)(const lv_area_t *) = (!f->row ? lv_area_get_width : lv_area_get_height);\n\n    /*Calculate the size of grow items first*/\n    uint32_t i;\n    bool grow_reiterate  = true;\n    while(grow_reiterate) {\n        grow_reiterate = false;\n        lv_coord_t grow_value_sum = 0;\n        lv_coord_t grow_max_size = t->track_main_size - t->track_fix_main_size;\n        for(i = 0; i < t->grow_item_cnt; i++) {\n            if(t->grow_dsc[i].clamped == 0) {\n                grow_value_sum += t->grow_dsc[i].grow_value;\n            }\n            else {\n                grow_max_size -= t->grow_dsc[i].final_size;\n            }\n        }\n        lv_coord_t grow_unit;\n\n        for(i = 0; i < t->grow_item_cnt; i++) {\n            if(t->grow_dsc[i].clamped == 0) {\n                grow_unit = grow_max_size / grow_value_sum;\n                lv_coord_t size = grow_unit * t->grow_dsc[i].grow_value;\n                lv_coord_t size_clamp = LV_CLAMP(t->grow_dsc[i].min_size, size, t->grow_dsc[i].max_size);\n\n                if(size_clamp != size) {\n                    t->grow_dsc[i].clamped = 1;\n                    grow_reiterate = true;\n                }\n                t->grow_dsc[i].final_size = size_clamp;\n                grow_value_sum -= t->grow_dsc[i].grow_value;\n                grow_max_size  -= t->grow_dsc[i].final_size;\n            }\n        }\n    }\n\n\n    bool rtl = lv_obj_get_style_base_dir(cont, LV_PART_MAIN) == LV_BASE_DIR_RTL ? true : false;\n\n    lv_coord_t main_pos = 0;\n\n    lv_coord_t place_gap = 0;\n    place_content(f->main_place, max_main_size, t->track_main_size, t->item_cnt, &main_pos, &place_gap);\n    if(f->row && rtl) main_pos += lv_obj_get_content_width(cont);\n\n    lv_obj_t * item = lv_obj_get_child(cont, item_first_id);\n    /*Reposition the children*/\n    while(item && item_first_id != item_last_id) {\n        if(lv_obj_has_flag_any(item, LV_OBJ_FLAG_IGNORE_LAYOUT | LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) {\n            item = get_next_item(cont, f->rev, &item_first_id);\n            continue;\n        }\n        lv_coord_t grow_size = lv_obj_get_style_flex_grow(item, LV_PART_MAIN);\n        if(grow_size) {\n            lv_coord_t s = 0;\n            for(i = 0; i < t->grow_item_cnt; i++) {\n                if(t->grow_dsc[i].item == item) {\n                    s = t->grow_dsc[i].final_size;\n                    break;\n                }\n            }\n\n            if(f->row) item->w_layout = 1;\n            else item->h_layout = 1;\n\n            if(s != area_get_main_size(&item->coords)) {\n                lv_obj_invalidate(item);\n\n                lv_area_t old_coords;\n                lv_area_copy(&old_coords, &item->coords);\n                area_set_main_size(&item->coords, s);\n                lv_event_send(item, LV_EVENT_SIZE_CHANGED, &old_coords);\n                lv_event_send(lv_obj_get_parent(item), LV_EVENT_CHILD_CHANGED, item);\n                lv_obj_invalidate(item);\n            }\n        }\n        else {\n            item->w_layout = 0;\n            item->h_layout = 0;\n        }\n\n        lv_coord_t cross_pos = 0;\n        switch(f->cross_place) {\n            case LV_FLEX_ALIGN_CENTER:\n                /*Round up the cross size to avoid rounding error when dividing by 2\n                 *The issue comes up e,g, with column direction with center cross direction if an element's width changes*/\n                cross_pos = (((t->track_cross_size + 1) & (~1)) - area_get_cross_size(&item->coords)) / 2;\n                break;\n            case LV_FLEX_ALIGN_END:\n                cross_pos = t->track_cross_size - area_get_cross_size(&item->coords);\n                break;\n            default:\n                break;\n        }\n\n        if(f->row && rtl) main_pos -= area_get_main_size(&item->coords);\n\n\n        /*Handle percentage value of translate*/\n        lv_coord_t tr_x = lv_obj_get_style_translate_x(item, LV_PART_MAIN);\n        lv_coord_t tr_y = lv_obj_get_style_translate_y(item, LV_PART_MAIN);\n        lv_coord_t w = lv_obj_get_width(item);\n        lv_coord_t h = lv_obj_get_height(item);\n        if(LV_COORD_IS_PCT(tr_x)) tr_x = (w * LV_COORD_GET_PCT(tr_x)) / 100;\n        if(LV_COORD_IS_PCT(tr_y)) tr_y = (h * LV_COORD_GET_PCT(tr_y)) / 100;\n\n        lv_coord_t diff_x = abs_x - item->coords.x1 + tr_x;\n        lv_coord_t diff_y = abs_y - item->coords.y1 + tr_y;\n        diff_x += f->row ? main_pos : cross_pos;\n        diff_y += f->row ? cross_pos : main_pos;\n\n        if(diff_x || diff_y) {\n            lv_obj_invalidate(item);\n            item->coords.x1 += diff_x;\n            item->coords.x2 += diff_x;\n            item->coords.y1 += diff_y;\n            item->coords.y2 += diff_y;\n            lv_obj_invalidate(item);\n            lv_obj_move_children_by(item, diff_x, diff_y, true);\n        }\n\n        if(!(f->row && rtl)) main_pos += area_get_main_size(&item->coords) + item_gap + place_gap;\n        else main_pos -= item_gap + place_gap;\n\n        item = get_next_item(cont, f->rev, &item_first_id);\n    }\n}"}, "place_content": {"type": "Function", "def": "static void place_content(lv_flex_align_t place, lv_coord_t max_size, lv_coord_t content_size, lv_coord_t item_cnt,\n                          lv_coord_t * start_pos, lv_coord_t * gap)", "sline": 541, "docstring": "/**", "body": "{\n    if(item_cnt <= 1) {\n        switch(place) {\n            case LV_FLEX_ALIGN_SPACE_BETWEEN:\n            case LV_FLEX_ALIGN_SPACE_AROUND:\n            case LV_FLEX_ALIGN_SPACE_EVENLY:\n                place = LV_FLEX_ALIGN_CENTER;\n                break;\n            default:\n                break;\n        }\n    }\n\n    switch(place) {\n        case LV_FLEX_ALIGN_CENTER:\n            *gap = 0;\n            *start_pos += (max_size - content_size) / 2;\n            break;\n        case LV_FLEX_ALIGN_END:\n            *gap = 0;\n            *start_pos += max_size - content_size;\n            break;\n        case LV_FLEX_ALIGN_SPACE_BETWEEN:\n            *gap = (lv_coord_t)(max_size - content_size) / (lv_coord_t)(item_cnt - 1);\n            break;\n        case LV_FLEX_ALIGN_SPACE_AROUND:\n            *gap += (lv_coord_t)(max_size - content_size) / (lv_coord_t)(item_cnt);\n            *start_pos += *gap / 2;\n            break;\n        case LV_FLEX_ALIGN_SPACE_EVENLY:\n            *gap = (lv_coord_t)(max_size - content_size) / (lv_coord_t)(item_cnt + 1);\n            *start_pos += *gap;\n            break;\n        default:\n            *gap = 0;\n    }\n}"}, "get_next_item": {"type": "Function", "def": "static lv_obj_t * get_next_item(lv_obj_t * cont, bool rev, int32_t * item_id)", "sline": 581, "body": "{\n    if(rev) {\n        (*item_id)--;\n        if(*item_id >= 0) return cont->spec_attr->children[*item_id];\n        else return NULL;\n    }\n    else {\n        (*item_id)++;\n        if((*item_id) < (int32_t)cont->spec_attr->child_cnt) return cont->spec_attr->children[*item_id];\n        else return NULL;\n    }\n}"}, "LV_LAYOUT_FLEX": {"type": "Variable", "def": "uint32_t LV_LAYOUT_FLEX", "sline": 68}, "LV_STYLE_FLEX_FLOW": {"type": "Variable", "def": "lv_style_prop_t LV_STYLE_FLEX_FLOW", "sline": 69}, "LV_STYLE_FLEX_MAIN_PLACE": {"type": "Variable", "def": "lv_style_prop_t LV_STYLE_FLEX_MAIN_PLACE", "sline": 70}, "LV_STYLE_FLEX_CROSS_PLACE": {"type": "Variable", "def": "lv_style_prop_t LV_STYLE_FLEX_CROSS_PLACE", "sline": 71}, "LV_STYLE_FLEX_TRACK_PLACE": {"type": "Variable", "def": "lv_style_prop_t LV_STYLE_FLEX_TRACK_PLACE", "sline": 72}, "LV_STYLE_FLEX_GROW": {"type": "Variable", "def": "lv_style_prop_t LV_STYLE_FLEX_GROW", "sline": 73}, "lv_flex_init": {"type": "Function", "def": "void lv_flex_init(void)", "sline": 92, "body": "{\n    LV_LAYOUT_FLEX = lv_layout_register(flex_update, NULL);\n\n    LV_STYLE_FLEX_FLOW = lv_style_register_prop();\n    LV_STYLE_FLEX_MAIN_PLACE = lv_style_register_prop() | LV_STYLE_PROP_LAYOUT_REFR;\n    LV_STYLE_FLEX_CROSS_PLACE = lv_style_register_prop() | LV_STYLE_PROP_LAYOUT_REFR;\n    LV_STYLE_FLEX_TRACK_PLACE = lv_style_register_prop() | LV_STYLE_PROP_LAYOUT_REFR;\n}"}, "lv_obj_set_flex_flow": {"type": "Function", "def": "void lv_obj_set_flex_flow(lv_obj_t * obj, lv_flex_flow_t flow)", "sline": 102, "body": "{\n    lv_obj_set_style_flex_flow(obj, flow, 0);\n    lv_obj_set_style_layout(obj, LV_LAYOUT_FLEX, 0);\n}"}, "lv_obj_set_flex_align": {"type": "Function", "def": "void lv_obj_set_flex_align(lv_obj_t * obj, lv_flex_align_t main_place, lv_flex_align_t cross_place,\n                           lv_flex_align_t track_place)", "sline": 108, "body": "{\n    lv_obj_set_style_flex_main_place(obj, main_place, 0);\n    lv_obj_set_style_flex_cross_place(obj, cross_place, 0);\n    lv_obj_set_style_flex_track_place(obj, track_place, 0);\n    lv_obj_set_style_layout(obj, LV_LAYOUT_FLEX, 0);\n}"}, "lv_obj_set_flex_grow": {"type": "Function", "def": "void lv_obj_set_flex_grow(lv_obj_t * obj, uint8_t grow)", "sline": 117, "body": "{\n    lv_obj_set_style_flex_grow(obj, grow, 0);\n    lv_obj_mark_layout_as_dirty(lv_obj_get_parent(obj));\n}"}, "lv_style_set_flex_flow": {"type": "Function", "def": "void lv_style_set_flex_flow(lv_style_t * style, lv_flex_flow_t value)", "sline": 124, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_FLEX_FLOW, v);\n}"}, "lv_style_set_flex_main_place": {"type": "Function", "def": "void lv_style_set_flex_main_place(lv_style_t * style, lv_flex_align_t value)", "sline": 132, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_FLEX_MAIN_PLACE, v);\n}"}, "lv_style_set_flex_cross_place": {"type": "Function", "def": "void lv_style_set_flex_cross_place(lv_style_t * style, lv_flex_align_t value)", "sline": 140, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_FLEX_CROSS_PLACE, v);\n}"}, "lv_style_set_flex_track_place": {"type": "Function", "def": "void lv_style_set_flex_track_place(lv_style_t * style, lv_flex_align_t value)", "sline": 148, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_FLEX_TRACK_PLACE, v);\n}"}, "lv_style_set_flex_grow": {"type": "Function", "def": "void lv_style_set_flex_grow(lv_style_t * style, uint8_t value)", "sline": 156, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_FLEX_GROW, v);\n}"}, "lv_obj_set_style_flex_flow": {"type": "Function", "def": "void lv_obj_set_style_flex_flow(lv_obj_t * obj, lv_flex_flow_t value, lv_style_selector_t selector)", "sline": 165, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t) value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_FLEX_FLOW, v, selector);\n}"}, "lv_obj_set_style_flex_main_place": {"type": "Function", "def": "void lv_obj_set_style_flex_main_place(lv_obj_t * obj, lv_flex_align_t value, lv_style_selector_t selector)", "sline": 173, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t) value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_FLEX_MAIN_PLACE, v, selector);\n}"}, "lv_obj_set_style_flex_cross_place": {"type": "Function", "def": "void lv_obj_set_style_flex_cross_place(lv_obj_t * obj, lv_flex_align_t value, lv_style_selector_t selector)", "sline": 181, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t) value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_FLEX_CROSS_PLACE, v, selector);\n}"}, "lv_obj_set_style_flex_track_place": {"type": "Function", "def": "void lv_obj_set_style_flex_track_place(lv_obj_t * obj, lv_flex_align_t value, lv_style_selector_t selector)", "sline": 189, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t) value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_FLEX_TRACK_PLACE, v, selector);\n}"}, "lv_obj_set_style_flex_grow": {"type": "Function", "def": "void lv_obj_set_style_flex_grow(lv_obj_t * obj, uint8_t value, lv_style_selector_t selector)", "sline": 197, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t) value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_FLEX_GROW, v, selector);\n}"}, "carbit_updater/lvgl/src/extra/layouts/flex/lv_flex.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/layouts/flex/lv_flex.c"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_26.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_montserrat_26.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_26.c"}}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_draw_rect.c": {"lv_conf_internal": {"type": "Variable", "def": "#include ../../lv_conf_internal.h", "sline": 10}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_draw_rect.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_draw_rect.c"}}, "carbit_updater/lvgl/src/extra/themes/lv_themes.h": {"lv_theme_default": {"type": "Variable", "def": "#include default/lv_theme_default.h", "sline": 16, "include": ["carbit_updater/lvgl/src/extra/themes/default/lv_theme_default.h", null]}, "lv_theme_mono": {"type": "Variable", "def": "#include mono/lv_theme_mono.h", "sline": 17, "include": ["carbit_updater/lvgl/src/extra/themes/mono/lv_theme_mono.h", null]}, "lv_theme_basic": {"type": "Variable", "def": "#include basic/lv_theme_basic.h", "sline": 18, "include": ["carbit_updater/lvgl/src/extra/themes/basic/lv_theme_basic.h", null]}, "carbit_updater/lvgl/src/extra/themes/lv_themes.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/themes/lv_themes.h"}}, "carbit_updater/lvgl/src/extra/widgets/span/lv_span.c": {"lv_span": {"type": "Variable", "def": "#include lv_span.h", "sline": 9, "include": ["carbit_updater/lvgl/src/extra/widgets/span/lv_span.h", null]}, "lv_assert": {"type": "Variable", "def": "#include ../../../misc/lv_assert.h", "sline": 13}, "lv_snippet_t.span": {"type": "Variable", "def": "lv_span_t * span", "sline": 24, "in_struct": "lv_snippet_t"}, "lv_snippet_t.txt": {"type": "Variable", "def": "const char * txt", "sline": 25, "in_struct": "lv_snippet_t"}, "lv_snippet_t.font": {"type": "Variable", "def": "const lv_font_t * font", "sline": 26, "in_struct": "lv_snippet_t"}, "lv_snippet_t.bytes": {"type": "Variable", "def": "uint16_t   bytes", "sline": 27, "in_struct": "lv_snippet_t"}, "lv_snippet_t.txt_w": {"type": "Variable", "def": "lv_coord_t txt_w", "sline": 28, "in_struct": "lv_snippet_t"}, "lv_snippet_t.line_h": {"type": "Variable", "def": "lv_coord_t line_h", "sline": 29, "in_struct": "lv_snippet_t"}, "lv_snippet_t.letter_space": {"type": "Variable", "def": "lv_coord_t letter_space", "sline": 30, "in_struct": "lv_snippet_t"}, "lv_snippet_t": {"type": "Variable", "def": "typedef struct {\n    lv_span_t * span;\n    const char * txt;\n    const lv_font_t * font;\n    uint16_t   bytes;\n    lv_coord_t txt_w;\n    lv_coord_t line_h;\n    lv_coord_t letter_space;\n} lv_snippet_t", "sline": 31, "docstring": "/**********************"}, "_snippet_stack.stack": {"type": "Variable", "def": "lv_snippet_t    stack[LV_SPAN_SNIPPET_STACK_SIZE]", "sline": 34, "in_struct": "_snippet_stack"}, "_snippet_stack.index": {"type": "Variable", "def": "uint16_t        index", "sline": 35, "in_struct": "_snippet_stack"}, "_snippet_stack": {"type": "Struct", "def": "struct _snippet_stack {\n    lv_snippet_t    stack[LV_SPAN_SNIPPET_STACK_SIZE];\n    uint16_t        index;\n}", "sline": 33, "body": "lv_snippet_t    stack[LV_SPAN_SNIPPET_STACK_SIZE]\nuint16_t        index\n"}, "lv_spangroup_destructor": {"type": "Function", "def": "static void lv_spangroup_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 584, "body": "{\n    LV_UNUSED(class_p);\n    lv_spangroup_t * spans = (lv_spangroup_t *)obj;\n    lv_span_t * cur_span = _lv_ll_get_head(&spans->child_ll);\n    while(cur_span) {\n        _lv_ll_remove(&spans->child_ll, cur_span);\n        if(cur_span->txt && cur_span->static_flag == 0) {\n            lv_mem_free(cur_span->txt);\n        }\n        lv_style_reset(&cur_span->style);\n        lv_mem_free(cur_span);\n        cur_span = _lv_ll_get_head(&spans->child_ll);\n    }\n}"}, "lv_spangroup_constructor": {"type": "Function", "def": "static void lv_spangroup_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 571, "body": "{\n    LV_UNUSED(class_p);\n    lv_spangroup_t * spans = (lv_spangroup_t *)obj;\n    _lv_ll_init(&spans->child_ll, sizeof(lv_span_t));\n    spans->indent = 0;\n    spans->mode = LV_SPAN_MODE_EXPAND;\n    spans->overflow = LV_SPAN_OVERFLOW_CLIP;\n    spans->cache_w = 0;\n    spans->cache_h = 0;\n    spans->refresh = 1;\n}"}, "lv_spangroup_event": {"type": "Function", "def": "static void lv_spangroup_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 600, "body": "{\n    LV_UNUSED(class_p);\n\n    /* Call the ancestor's event handler */\n    if(lv_obj_event_base(MY_CLASS, e) != LV_RES_OK) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_spangroup_t * spans = (lv_spangroup_t *)obj;\n\n    if(code == LV_EVENT_DRAW_MAIN) {\n        draw_main(e);\n    }\n    else if(code == LV_EVENT_STYLE_CHANGED) {\n        refresh_self_size(obj);\n    }\n    else if(code == LV_EVENT_SIZE_CHANGED) {\n        refresh_self_size(obj);\n    }\n    else if(code == LV_EVENT_GET_SELF_SIZE) {\n        lv_coord_t width = 0;\n        lv_coord_t height = 0;\n        lv_point_t * self_size = lv_event_get_param(e);\n\n        if(spans->mode == LV_SPAN_MODE_EXPAND) {\n            if(spans->refresh) {\n                spans->cache_w = lv_spangroup_get_expand_width(obj);\n                spans->cache_h = lv_spangroup_get_max_line_h(obj);\n                spans->refresh = 0;\n            }\n            width = spans->cache_w;\n            height = spans->cache_h;\n        }\n        else if(spans->mode == LV_SPAN_MODE_BREAK) {\n            width = lv_obj_get_content_width(obj);\n            if(self_size->y >= 0) {\n                if(width != spans->cache_w || spans->refresh) {\n                    height = lv_spangroup_get_expand_height(obj, width);\n                    spans->cache_w = width;\n                    spans->cache_h = height;\n                    spans->refresh = 0;\n                }\n                else {\n                    height = spans->cache_h;\n                }\n            }\n        }\n        else if(spans->mode == LV_SPAN_MODE_FIXED) {\n            width =  self_size->x >= 0 ? lv_obj_get_content_width(obj) : 0;\n            height = self_size->y >= 0 ? lv_obj_get_content_height(obj) : 0;\n        }\n        self_size->x = LV_MAX(self_size->x, width);\n        self_size->y = LV_MAX(self_size->y, height);\n    }\n}"}, "draw_main": {"type": "Function", "def": "static void draw_main(lv_event_t * e)", "sline": 657, "body": "{\n    lv_obj_t * obj = lv_event_get_target(e);\n    const lv_area_t * clip_area = lv_event_get_param(e);\n\n    lv_area_t txt_coords;\n    lv_obj_get_content_coords(obj, &txt_coords);\n\n    lv_draw_span(obj, &txt_coords, clip_area);\n}"}, "refresh_self_size": {"type": "Function", "def": "static void refresh_self_size(lv_obj_t * obj)", "sline": 1098, "body": "{\n    lv_spangroup_t * spans = (lv_spangroup_t *)obj;\n    spans->refresh = 1;\n    lv_obj_refresh_self_size(obj);\n    lv_obj_invalidate(obj);\n}"}, "lv_span_get_style_text_font": {"type": "Function", "def": "static const lv_font_t * lv_span_get_style_text_font(lv_obj_t * par, lv_span_t * span)", "sline": 720, "body": "{\n    const lv_font_t * font;\n    lv_style_value_t value;\n    lv_res_t res = lv_style_get_prop(&span->style, LV_STYLE_TEXT_FONT, &value);\n    if(res != LV_RES_OK) {\n        font = lv_obj_get_style_text_font(par, LV_PART_MAIN);\n    }\n    else {\n        font = (const lv_font_t *)value.ptr;\n    }\n    return font;\n}"}, "lv_span_get_style_text_letter_space": {"type": "Function", "def": "static lv_coord_t lv_span_get_style_text_letter_space(lv_obj_t * par, lv_span_t * span)", "sline": 734, "body": "{\n    lv_coord_t letter_space;\n    lv_style_value_t value;\n    lv_res_t res = lv_style_get_prop(&span->style, LV_STYLE_TEXT_LETTER_SPACE, &value);\n    if(res != LV_RES_OK) {\n        letter_space = lv_obj_get_style_text_letter_space(par, LV_PART_MAIN);\n    }\n    else {\n        letter_space = (lv_coord_t)value.num;\n    }\n    return letter_space;\n}"}, "lv_span_get_style_text_color": {"type": "Function", "def": "static lv_color_t lv_span_get_style_text_color(lv_obj_t * par, lv_span_t * span)", "sline": 748, "body": "{\n    lv_style_value_t value;\n    lv_res_t res = lv_style_get_prop(&span->style, LV_STYLE_TEXT_COLOR, &value);\n    if(res != LV_RES_OK) {\n        value.color = lv_obj_get_style_text_color(par, LV_PART_MAIN);\n    }\n    return value.color;\n}"}, "lv_span_get_style_text_opa": {"type": "Function", "def": "static lv_opa_t lv_span_get_style_text_opa(lv_obj_t * par, lv_span_t * span)", "sline": 758, "body": "{\n    lv_opa_t opa;\n    lv_style_value_t value;\n    lv_res_t res = lv_style_get_prop(&span->style, LV_STYLE_TEXT_OPA, &value);\n    if(res != LV_RES_OK) {\n        opa = (lv_opa_t)lv_obj_get_style_text_opa(par, LV_PART_MAIN);\n    }\n    else {\n        opa = (lv_opa_t)value.num;\n    }\n    return opa;\n}"}, "lv_span_get_style_text_blend_mode": {"type": "Function", "def": "static lv_blend_mode_t lv_span_get_style_text_blend_mode(lv_obj_t * par, lv_span_t * span)", "sline": 772, "body": "{\n    lv_blend_mode_t mode;\n    lv_style_value_t value;\n    lv_res_t res = lv_style_get_prop(&span->style, LV_STYLE_BLEND_MODE, &value);\n    if(res != LV_RES_OK) {\n        mode = (lv_blend_mode_t)lv_obj_get_style_blend_mode(par, LV_PART_MAIN);\n    }\n    else {\n        mode = (lv_blend_mode_t)value.num;\n    }\n    return mode;\n}"}, "lv_span_get_style_text_decor": {"type": "Function", "def": "static int32_t lv_span_get_style_text_decor(lv_obj_t * par, lv_span_t * span)", "sline": 786, "body": "{\n    int32_t decor;\n    lv_style_value_t value;\n    lv_res_t res = lv_style_get_prop(&span->style, LV_STYLE_TEXT_DECOR, &value);\n    if(res != LV_RES_OK) {\n        decor = (lv_text_decor_t)lv_obj_get_style_text_decor(par, LV_PART_MAIN);;\n    }\n    else {\n        decor = (int32_t)value.num;\n    }\n    return decor;\n}"}, "span_text_check": {"type": "Function", "def": "static inline void span_text_check(const char ** text)", "sline": 800, "body": "{\n    if(*text == NULL) {\n        *text = \"\";\n        LV_LOG_ERROR(\"occur an error that span text == NULL\");\n    }\n}"}, "lv_draw_span": {"type": "Function", "def": "static void lv_draw_span(lv_obj_t * obj, const lv_area_t * coords, const lv_area_t * mask)", "sline": 831, "body": "{\n    /* return if no draw area */\n    lv_area_t clipped_area;\n    bool clip_ok = _lv_area_intersect(&clipped_area, coords, mask);\n    if(!clip_ok) return;\n\n    lv_spangroup_t * spans = (lv_spangroup_t *)obj;\n\n    /* return if not span */\n    if(_lv_ll_get_head(&spans->child_ll) == NULL) {\n        return;\n    }\n\n    /* init draw variable */\n    lv_text_flag_t txt_flag = LV_TEXT_FLAG_NONE;\n    lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);;\n    lv_coord_t max_width = lv_area_get_width(coords);\n    lv_coord_t indent = convert_indent_pct(obj, max_width);\n    lv_coord_t max_w  = max_width - indent; /* first line need minus indent */\n    lv_opa_t obj_opa = lv_obj_get_style_opa(obj, LV_PART_MAIN);\n\n    /* coords of draw span-txt */\n    lv_point_t txt_pos;\n    txt_pos.y = coords->y1;\n    txt_pos.x = coords->x1 + indent; /* first line need add indent */\n\n    lv_span_t * cur_span = _lv_ll_get_head(&spans->child_ll);\n    const char * cur_txt = cur_span->txt;\n    span_text_check(&cur_txt);\n    uint32_t cur_txt_ofs = 0;\n    lv_snippet_t snippet;   /* use to save cur_span info and push it to stack */\n    memset(&snippet, 0, sizeof(snippet));\n\n    bool is_first_line = true;\n    /* the loop control how many lines need to draw */\n    while(cur_span) {\n        bool is_end_line = false;\n        bool ellipsis_valid = false;\n        lv_coord_t max_line_h = 0;  /* the max height of span-font when a line have a lot of span */\n        lv_snippet_clear();\n\n        /* the loop control to find a line and push the relevant span info into stack  */\n        while(1) {\n            /* switch to the next span when current is end */\n            if(cur_txt[cur_txt_ofs] == '\\0') {\n                cur_span = _lv_ll_get_next(&spans->child_ll, cur_span);\n                if(cur_span == NULL) break;\n                cur_txt = cur_span->txt;\n                span_text_check(&cur_txt);\n                cur_txt_ofs = 0;\n                /* maybe also cur_txt[cur_txt_ofs] == '\\0' */\n                continue;\n            }\n\n            /* init span info to snippet. */\n            if(cur_txt_ofs == 0) {\n                snippet.span = cur_span;\n                snippet.font = lv_span_get_style_text_font(obj, cur_span);\n                snippet.letter_space = lv_span_get_style_text_letter_space(obj, cur_span);\n                snippet.line_h = lv_font_get_line_height(snippet.font) + line_space;\n            }\n\n            if(spans->overflow == LV_SPAN_OVERFLOW_ELLIPSIS) {\n                /* curretn line span txt overflow, don't push */\n                if(txt_pos.y + snippet.line_h - line_space > coords->y2 + 1) {\n                    ellipsis_valid = true;\n                    is_end_line = true;\n                    break;\n                }\n            }\n\n            /* get current span text line info */\n            uint32_t next_ofs = 0;\n            lv_coord_t use_width = 0;\n            bool isfill = lv_txt_get_snippet(&cur_txt[cur_txt_ofs], snippet.font, snippet.letter_space,\n                                             max_w, txt_flag, &use_width, &next_ofs);\n\n            if(isfill) {\n                lv_coord_t next_line_h = snippet.line_h;\n                if(cur_txt[cur_txt_ofs + next_ofs] == '\\0') {\n                    next_line_h = 0;\n                    lv_span_t * next_span = _lv_ll_get_next(&spans->child_ll, cur_span);\n                    if(next_span) { /* have the next line */\n                        next_line_h = lv_font_get_line_height(lv_span_get_style_text_font(obj, next_span)) + line_space;\n                    }\n                }\n                lv_coord_t cur_line_h = max_line_h < snippet.line_h ? snippet.line_h : max_line_h;\n                if(txt_pos.y + cur_line_h + next_line_h - line_space > coords->y2 + 1) { /* for overflow if is end line. */\n                    if(cur_txt[cur_txt_ofs + next_ofs] != '\\0') {\n                        next_ofs = strlen(&cur_txt[cur_txt_ofs]);\n                        use_width = lv_txt_get_width(&cur_txt[cur_txt_ofs], next_ofs, snippet.font, snippet.letter_space, txt_flag);\n                        ellipsis_valid = spans->overflow == LV_SPAN_OVERFLOW_ELLIPSIS ? true : false;\n                        is_end_line = true;\n                    }\n                }\n                else if(next_ofs > 0 && lv_get_snippet_cnt() > 0) {\n                    /* break word deal width */\n                    uint32_t letter = (uint32_t)cur_txt[cur_txt_ofs + next_ofs - 1];\n                    if(!(letter == '\\0' || letter == '\\n' || letter == '\\r' || _lv_txt_is_break_char(letter))) {\n                        letter = (uint32_t)cur_txt[cur_txt_ofs + next_ofs];\n                        if(!(letter == '\\0' || letter == '\\n'  || letter == '\\r' || _lv_txt_is_break_char(letter))) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            snippet.txt = &cur_txt[cur_txt_ofs];\n            snippet.bytes = next_ofs;\n            snippet.txt_w = use_width;\n            cur_txt_ofs += next_ofs;\n            if(max_line_h < snippet.line_h) {\n                max_line_h = snippet.line_h;\n            }\n\n            lv_snippet_push(&snippet);\n            max_w = max_w - use_width - snippet.letter_space;\n            if(isfill || max_w <= 0) {\n                break;\n            }\n        }\n\n        /* start current line deal width */\n\n        uint16_t item_cnt = lv_get_snippet_cnt();\n        if(item_cnt == 0) {     /* break if stack is empty */\n            break;\n        }\n\n        /*Go the first visible line*/\n        if(txt_pos.y + max_line_h < mask->y1) {\n            goto Next_line_init;\n        }\n\n        /* align deal with */\n        lv_text_align_t align = lv_obj_get_style_text_align(obj, LV_PART_MAIN);\n        if(align != LV_TEXT_ALIGN_LEFT) {\n            lv_coord_t align_ofs = 0;\n            lv_coord_t txts_w = is_first_line ? indent : 0;\n            for(int i = 0; i < item_cnt; i++) {\n                lv_snippet_t * pinfo = lv_get_snippet(i);\n                txts_w = txts_w + pinfo->txt_w + pinfo->letter_space;\n            }\n            txts_w -= lv_get_snippet(item_cnt - 1)->letter_space;\n            align_ofs = max_width > txts_w ? max_width - txts_w : 0;\n            if(align == LV_TEXT_ALIGN_CENTER) {\n                align_ofs = align_ofs >> 1;\n            }\n            txt_pos.x += align_ofs;\n        }\n\n        /* draw line letters */\n        for(int i = 0; i < item_cnt; i++) {\n            lv_snippet_t * pinfo = lv_get_snippet(i);\n\n            /* bidi deal with:todo */\n            const char * bidi_txt = pinfo->txt;\n\n            lv_point_t pos;\n            pos.x = txt_pos.x;\n            pos.y = txt_pos.y + max_line_h - pinfo->line_h;\n            lv_color_t letter_color = lv_span_get_style_text_color(obj, pinfo->span);\n            lv_opa_t letter_opa = lv_span_get_style_text_opa(obj, pinfo->span);\n            if(obj_opa < LV_OPA_MAX) {\n                letter_opa = (uint16_t)((uint16_t)letter_opa * obj_opa) >> 8;\n            }\n            lv_blend_mode_t blend_mode = lv_span_get_style_text_blend_mode(obj, pinfo->span);\n            uint32_t txt_bytes = pinfo->bytes;\n\n            /* overflow */\n            uint16_t dot_letter_w = 0;\n            uint16_t dot_width = 0;\n            if(ellipsis_valid) {\n                dot_letter_w = lv_font_get_glyph_width(pinfo->font, '.', '.');\n                dot_width = dot_letter_w * 3;\n            }\n            lv_coord_t ellipsis_width = coords->x1 + max_width - dot_width;\n\n            uint32_t j = 0;\n            while(j < txt_bytes) {\n                /* skip invalid fields */\n                if(pos.x > clipped_area.x2) {\n                    break;\n                }\n                uint32_t letter      = _lv_txt_encoded_next(bidi_txt, &j);\n                uint32_t letter_next = _lv_txt_encoded_next(&bidi_txt[j], NULL);\n                int32_t letter_w = lv_font_get_glyph_width(pinfo->font, letter, letter_next);\n\n                /* skip invalid fields */\n                if(pos.x + letter_w + pinfo->letter_space < clipped_area.x1) {\n                    if(letter_w > 0) {\n                        pos.x = pos.x + letter_w + pinfo->letter_space;\n                    }\n                    continue;\n                }\n\n                if(ellipsis_valid && pos.x + letter_w + pinfo->letter_space > ellipsis_width) {\n                    for(int ell = 0; ell < 3; ell++) {\n                        lv_draw_letter(&pos, &clipped_area, pinfo->font, '.', letter_color, letter_opa, blend_mode);\n                        pos.x = pos.x + dot_letter_w + pinfo->letter_space;\n                    }\n                    if(pos.x <= ellipsis_width) {\n                        pos.x = ellipsis_width + 1;\n                    }\n                    break;\n                }\n                else {\n                    lv_draw_letter(&pos, &clipped_area, pinfo->font, letter, letter_color, letter_opa, blend_mode);\n                    if(letter_w > 0) {\n                        pos.x = pos.x + letter_w + pinfo->letter_space;\n                    }\n                }\n            }\n\n            if(ellipsis_valid && i == item_cnt - 1 && pos.x <= ellipsis_width) {\n                for(int ell = 0; ell < 3; ell++) {\n                    lv_draw_letter(&pos, &clipped_area, pinfo->font, '.', letter_color, letter_opa, blend_mode);\n                    pos.x = pos.x + dot_letter_w + pinfo->letter_space;\n                }\n            }\n\n            /* draw decor */\n            lv_text_decor_t decor = lv_span_get_style_text_decor(obj, pinfo->span);\n            if(decor != LV_TEXT_DECOR_NONE) {\n                lv_draw_line_dsc_t line_dsc;\n                lv_draw_line_dsc_init(&line_dsc);\n                line_dsc.color = letter_color;\n                line_dsc.width = pinfo->font->underline_thickness ? pinfo->font->underline_thickness : 1;\n                line_dsc.opa = letter_opa;\n                line_dsc.blend_mode = blend_mode;\n\n                if(decor & LV_TEXT_DECOR_STRIKETHROUGH) {\n                    lv_point_t p1;\n                    lv_point_t p2;\n                    p1.x = txt_pos.x;\n                    p1.y = pos.y + ((pinfo->line_h - line_space) >> 1)  + (line_dsc.width >> 1);\n                    p2.x = pos.x;\n                    p2.y = p1.y;\n                    lv_draw_line(&p1, &p2, mask, &line_dsc);\n                }\n\n                if(decor & LV_TEXT_DECOR_UNDERLINE) {\n                    lv_point_t p1;\n                    lv_point_t p2;\n                    p1.x = txt_pos.x;\n                    p1.y = pos.y + pinfo->line_h - line_space - pinfo->font->base_line - pinfo->font->underline_position;\n                    p2.x = pos.x;\n                    p2.y = p1.y;\n                    lv_draw_line(&p1, &p2, &clipped_area, &line_dsc);\n                }\n            }\n            txt_pos.x = pos.x;\n        }\n\nNext_line_init:\n        /* next line init */\n        is_first_line = false;\n        txt_pos.x = coords->x1;\n        txt_pos.y += max_line_h;\n        if(is_end_line || txt_pos.y > clipped_area.y2 + 1) {\n            return;\n        }\n        max_w = max_width;\n    }\n}"}, "lv_txt_get_snippet": {"type": "Function", "def": "static bool lv_txt_get_snippet(const char * txt, const lv_font_t * font,\n                               lv_coord_t letter_space, lv_coord_t max_width, lv_text_flag_t flag,\n                               lv_coord_t * use_width, uint32_t * end_ofs)", "sline": 671, "docstring": "/**", "body": "{\n    if(txt == NULL || txt[0] == '\\0') {\n        *end_ofs = 0;\n        *use_width = 0;\n        return false;\n    }\n\n    uint32_t ofs = _lv_txt_get_next_line(txt, font, letter_space, max_width, flag);\n    lv_coord_t width = lv_txt_get_width(txt, ofs, font, letter_space, flag);\n    *end_ofs = ofs;\n    *use_width = width;\n\n    if(txt[ofs] == '\\0' && width < max_width) {\n        return false;\n    }\n    else {\n        return true;\n    }\n}"}, "lv_snippet_clear": {"type": "Function", "def": "static void lv_snippet_clear(void)", "sline": 715, "body": "{\n    snippet_stack.index = 0;\n}"}, "lv_get_snippet_cnt": {"type": "Function", "def": "static uint16_t lv_get_snippet_cnt(void)", "sline": 705, "body": "{\n    return snippet_stack.index;\n}"}, "lv_snippet_push": {"type": "Function", "def": "static void lv_snippet_push(lv_snippet_t * item)", "sline": 694, "body": "{\n    if(snippet_stack.index < LV_SPAN_SNIPPET_STACK_SIZE) {\n        memcpy(&snippet_stack.stack[snippet_stack.index], item, sizeof(lv_snippet_t));\n        snippet_stack.index++;\n    }\n    else {\n        LV_LOG_ERROR(\"span draw stack overflow, please set LV_SPAN_SNIPPET_STACK_SIZE too larger\");\n    }\n}"}, "lv_get_snippet": {"type": "Function", "def": "static lv_snippet_t * lv_get_snippet(uint16_t index)", "sline": 710, "body": "{\n    return &snippet_stack.stack[index];\n}"}, "convert_indent_pct": {"type": "Function", "def": "static lv_coord_t convert_indent_pct(lv_obj_t * obj, lv_coord_t width)", "sline": 808, "body": "{\n    lv_spangroup_t * spans = (lv_spangroup_t *)obj;\n\n    lv_coord_t indent = spans->indent;\n    if(LV_COORD_IS_PCT(spans->indent)) {\n        if(spans->mode == LV_SPAN_MODE_EXPAND) {\n            indent = 0;\n        }\n        else {\n            indent = (width * LV_COORD_GET_PCT(spans->indent)) / 100;\n        }\n    }\n\n    return indent;\n}"}, "snippet_stack": {"type": "Variable", "def": "static struct _snippet_stack snippet_stack", "sline": 69}, "lv_spangroup_class": {"type": "Variable", "def": "const lv_obj_class_t lv_spangroup_class  = {\n    .base_class = &lv_obj_class,\n    .constructor_cb = lv_spangroup_constructor,\n    .destructor_cb = lv_spangroup_destructor,\n    .event_cb = lv_spangroup_event,\n    .instance_size = sizeof(lv_spangroup_t),\n    .width_def = LV_SIZE_CONTENT,\n    .height_def = LV_SIZE_CONTENT,\n}", "sline": 71}, "lv_spangroup_create": {"type": "Function", "def": "lv_obj_t * lv_spangroup_create(lv_obj_t * par)", "sline": 94, "body": "{\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_spangroup_class, par);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_spangroup_new_span": {"type": "Function", "def": "lv_span_t * lv_spangroup_new_span(lv_obj_t * obj)", "sline": 106, "body": "{\n    if(obj == NULL) {\n        return NULL;\n    }\n\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spangroup_t * spans = (lv_spangroup_t *)obj;\n    lv_span_t * span = _lv_ll_ins_tail(&spans->child_ll);\n    LV_ASSERT_MALLOC(span);\n\n    lv_style_init(&span->style);\n    span->txt = (char *)\"\";\n    span->static_flag = 1;\n    span->spangroup = obj;\n\n    refresh_self_size(obj);\n\n    return span;\n}"}, "lv_spangroup_del_span": {"type": "Function", "def": "void lv_spangroup_del_span(lv_obj_t * obj, lv_span_t * span)", "sline": 132, "body": "{\n    if(obj == NULL || span == NULL) {\n        return;\n    }\n\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spangroup_t * spans = (lv_spangroup_t *)obj;\n    lv_span_t * cur_span;\n    _LV_LL_READ(&spans->child_ll, cur_span) {\n        if(cur_span == span) {\n            _lv_ll_remove(&spans->child_ll, cur_span);\n            if(cur_span->txt && cur_span->static_flag == 0) {\n                lv_mem_free(cur_span->txt);\n            }\n            lv_style_reset(&cur_span->style);\n            lv_mem_free(cur_span);\n            break;\n        }\n    }\n\n    refresh_self_size(obj);\n}"}, "lv_span_set_text": {"type": "Function", "def": "void lv_span_set_text(lv_span_t * span, const char * text)", "sline": 165, "body": "{\n    if(span == NULL || text == NULL) {\n        return;\n    }\n\n    if(span->txt == NULL || span->static_flag == 1) {\n        span->txt = lv_mem_alloc(strlen(text) + 1);\n    }\n    else {\n        lv_mem_realloc(span->txt, strlen(text) + 1);\n    }\n    span->static_flag = 0;\n    strcpy(span->txt, text);\n\n    refresh_self_size(span->spangroup);\n}"}, "lv_span_set_text_static": {"type": "Function", "def": "void lv_span_set_text_static(lv_span_t * span, const char * text)", "sline": 189, "body": "{\n    if(span == NULL || text == NULL) {\n        return;\n    }\n\n    if(span->txt && span->static_flag == 0) {\n        lv_mem_free(span->txt);\n    }\n    span->static_flag = 1;\n    span->txt = (char *)text;\n\n    refresh_self_size(span->spangroup);\n}"}, "lv_spangroup_set_align": {"type": "Function", "def": "void lv_spangroup_set_align(lv_obj_t * obj, lv_text_align_t align)", "sline": 209, "body": "{\n    lv_obj_set_style_text_align(obj, align, LV_PART_MAIN);\n}"}, "lv_spangroup_set_overflow": {"type": "Function", "def": "void lv_spangroup_set_overflow(lv_obj_t * obj, lv_span_overflow_t overflow)", "sline": 219, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spangroup_t * spans = (lv_spangroup_t *)obj;\n    if(spans->overflow == overflow) return;\n\n    spans->overflow = overflow;\n    lv_obj_invalidate(obj);\n}"}, "lv_spangroup_set_indent": {"type": "Function", "def": "void lv_spangroup_set_indent(lv_obj_t * obj, lv_coord_t indent)", "sline": 235, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spangroup_t * spans = (lv_spangroup_t *)obj;\n    if(spans->indent == indent) return;\n\n    spans->indent = indent;\n\n    refresh_self_size(obj);\n}"}, "lv_spangroup_set_mode": {"type": "Function", "def": "void lv_spangroup_set_mode(lv_obj_t * obj, lv_span_mode_t mode)", "sline": 251, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spangroup_t * spans = (lv_spangroup_t *)obj;\n    spans->mode = mode;\n    lv_spangroup_refr_mode(obj);\n}"}, "lv_spangroup_get_child": {"type": "Function", "def": "lv_span_t * lv_spangroup_get_child(const lv_obj_t * obj, int32_t id)", "sline": 275, "body": "{\n    if(obj == NULL) {\n        return NULL;\n    }\n\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spangroup_t * spans = (lv_spangroup_t *)obj;\n    lv_ll_t * linked_list = &spans->child_ll;\n\n    bool traverse_forwards = (id >= 0);\n    int32_t cur_idx = 0;\n    lv_ll_node_t * cur_node = linked_list->head;\n\n    /*If using a negative index, start from the tail and use cur -1 to indicate the end*/\n    if(!traverse_forwards) {\n        cur_idx = -1;\n        cur_node = linked_list->tail;\n    }\n\n    while(cur_node != NULL) {\n        if(cur_idx == id) {\n            return (lv_span_t *) cur_node;\n        }\n        if(traverse_forwards) {\n            cur_node = (lv_ll_node_t *) _lv_ll_get_next(linked_list, cur_node);\n            cur_idx++;\n        }\n        else {\n            cur_node = (lv_ll_node_t *) _lv_ll_get_prev(linked_list, cur_node);\n            cur_idx--;\n        }\n    }\n\n    return NULL;\n}"}, "lv_spangroup_get_child_cnt": {"type": "Function", "def": "uint32_t lv_spangroup_get_child_cnt(const lv_obj_t * obj)", "sline": 317, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    if(obj == NULL) {\n        return 0;\n    }\n\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spangroup_t * spans = (lv_spangroup_t *)obj;\n    return _lv_ll_get_len(&(spans->child_ll));\n}"}, "lv_spangroup_get_align": {"type": "Function", "def": "lv_text_align_t lv_spangroup_get_align(lv_obj_t * obj)", "sline": 335, "body": "{\n    return lv_obj_get_style_text_align(obj, LV_PART_MAIN);\n}"}, "lv_spangroup_get_overflow": {"type": "Function", "def": "lv_span_overflow_t lv_spangroup_get_overflow(lv_obj_t * obj)", "sline": 345, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spangroup_t * spans = (lv_spangroup_t *)obj;\n    return spans->overflow;\n}"}, "lv_spangroup_get_indent": {"type": "Function", "def": "lv_coord_t lv_spangroup_get_indent(lv_obj_t * obj)", "sline": 357, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spangroup_t * spans = (lv_spangroup_t *)obj;\n    return spans->indent;\n}"}, "lv_spangroup_get_mode": {"type": "Function", "def": "lv_span_mode_t lv_spangroup_get_mode(lv_obj_t * obj)", "sline": 369, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spangroup_t * spans = (lv_spangroup_t *)obj;\n    return spans->mode;\n}"}, "lv_spangroup_refr_mode": {"type": "Function", "def": "void lv_spangroup_refr_mode(lv_obj_t * obj)", "sline": 380, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spangroup_t * spans = (lv_spangroup_t *)obj;\n\n    if(spans->mode == LV_SPAN_MODE_EXPAND) {\n        lv_obj_set_width(obj, LV_SIZE_CONTENT);\n        lv_obj_set_height(obj, LV_SIZE_CONTENT);\n    }\n    else if(spans->mode == LV_SPAN_MODE_BREAK) {\n        if(lv_obj_get_style_width(obj, LV_PART_MAIN) == LV_SIZE_CONTENT) {\n            lv_obj_set_width(obj, 100);\n        }\n        lv_obj_set_height(obj, LV_SIZE_CONTENT);\n    }\n    else if(spans->mode == LV_SPAN_MODE_FIXED) {\n        /* use this mode, The user needs to set the size. */\n        /* This is just to prevent an infinite loop. */\n        if(lv_obj_get_style_width(obj, LV_PART_MAIN) == LV_SIZE_CONTENT) {\n            lv_obj_set_width(obj, 100);\n        }\n        if(lv_obj_get_style_height(obj, LV_PART_MAIN) == LV_SIZE_CONTENT) {\n            lv_coord_t width = lv_obj_get_style_width(obj, LV_PART_MAIN);\n            if(LV_COORD_IS_PCT(width)) {\n                width = 100;\n            }\n            lv_coord_t height = lv_spangroup_get_expand_height(obj, width);\n            lv_obj_set_content_height(obj, height);\n        }\n    }\n\n    refresh_self_size(obj);\n}"}, "lv_spangroup_get_max_line_h": {"type": "Function", "def": "lv_coord_t lv_spangroup_get_max_line_h(lv_obj_t * obj)", "sline": 418, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spangroup_t * spans = (lv_spangroup_t *)obj;\n\n    lv_coord_t max_line_h = 0;\n    lv_span_t * cur_span;\n    _LV_LL_READ(&spans->child_ll, cur_span) {\n        const lv_font_t * font = lv_span_get_style_text_font(obj, cur_span);\n        lv_coord_t line_h = lv_font_get_line_height(font);\n        if(line_h > max_line_h) {\n            max_line_h = line_h;\n        }\n    }\n\n    return max_line_h;\n}"}, "lv_spangroup_get_expand_width": {"type": "Function", "def": "lv_coord_t lv_spangroup_get_expand_width(lv_obj_t * obj)", "sline": 440, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spangroup_t * spans = (lv_spangroup_t *)obj;\n\n    if(_lv_ll_get_head(&spans->child_ll) == NULL) {\n        return 0;\n    }\n\n    lv_coord_t width = LV_COORD_IS_PCT(spans->indent) ? 0 : spans->indent;\n    lv_span_t * cur_span;\n    lv_coord_t letter_space = 0;\n    _LV_LL_READ(&spans->child_ll, cur_span) {\n        const lv_font_t * font = lv_span_get_style_text_font(obj, cur_span);\n        letter_space = lv_span_get_style_text_letter_space(obj, cur_span);\n        uint32_t j = 0;\n        const char * cur_txt = cur_span->txt;\n        span_text_check(&cur_txt);\n        while(cur_txt[j] != '\\0') {\n            uint32_t letter      = _lv_txt_encoded_next(cur_txt, &j);\n            uint32_t letter_next = _lv_txt_encoded_next(&cur_txt[j], NULL);\n            int32_t letter_w = lv_font_get_glyph_width(font, letter, letter_next);\n            width = width + letter_w + letter_space;\n        }\n    }\n\n    return width - letter_space;\n}"}, "lv_spangroup_get_expand_height": {"type": "Function", "def": "lv_coord_t lv_spangroup_get_expand_height(lv_obj_t * obj, lv_coord_t width)", "sline": 473, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_spangroup_t * spans = (lv_spangroup_t *)obj;\n    if(_lv_ll_get_head(&spans->child_ll) == NULL || width <= 0) {\n        return 0;\n    }\n\n    /* init draw variable */\n    lv_text_flag_t txt_flag = LV_TEXT_FLAG_NONE;\n    lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);\n    lv_coord_t max_width = width;\n    lv_coord_t indent = convert_indent_pct(obj, max_width);\n    lv_coord_t max_w  = max_width - indent; /* first line need minus indent */\n\n    /* coords of draw span-txt */\n    lv_point_t txt_pos;\n    txt_pos.y = 0;\n    txt_pos.x = 0 + indent; /* first line need add indent */\n\n    lv_span_t * cur_span = _lv_ll_get_head(&spans->child_ll);\n    const char * cur_txt = cur_span->txt;\n    span_text_check(&cur_txt);\n    uint32_t cur_txt_ofs = 0;\n    lv_snippet_t snippet;   /* use to save cur_span info and push it to stack */\n    memset(&snippet, 0, sizeof(snippet));\n\n    /* the loop control how many lines need to draw */\n    while(cur_span) {\n        int snippet_cnt = 0;\n        lv_coord_t max_line_h = 0;  /* the max height of span-font when a line have a lot of span */\n\n        /* the loop control to find a line and push the relevant span info into stack  */\n        while(1) {\n            /* switch to the next span when current is end */\n            if(cur_txt[cur_txt_ofs] == '\\0') {\n                cur_span = _lv_ll_get_next(&spans->child_ll, cur_span);\n                if(cur_span == NULL) break;\n                cur_txt = cur_span->txt;\n                span_text_check(&cur_txt);\n                cur_txt_ofs = 0;\n                /* maybe also cur_txt[cur_txt_ofs] == '\\0' */\n                continue;\n            }\n\n            /* init span info to snippet. */\n            if(cur_txt_ofs == 0) {\n                snippet.span = cur_span;\n                snippet.font = lv_span_get_style_text_font(obj, cur_span);\n                snippet.letter_space = lv_span_get_style_text_letter_space(obj, cur_span);\n                snippet.line_h = lv_font_get_line_height(snippet.font) + line_space;\n            }\n\n            /* get current span text line info */\n            uint32_t next_ofs = 0;\n            lv_coord_t use_width = 0;\n            bool isfill = lv_txt_get_snippet(&cur_txt[cur_txt_ofs], snippet.font, snippet.letter_space,\n                                             max_w, txt_flag, &use_width, &next_ofs);\n\n            /* break word deal width */\n            if(isfill && next_ofs > 0 && snippet_cnt > 0) {\n                uint32_t letter = (uint32_t)cur_txt[cur_txt_ofs + next_ofs - 1];\n                if(!(letter == '\\0' || letter == '\\n' || letter == '\\r' || _lv_txt_is_break_char(letter))) {\n                    letter = (uint32_t)cur_txt[cur_txt_ofs + next_ofs];\n                    if(!(letter == '\\0' || letter == '\\n'  || letter == '\\r' || _lv_txt_is_break_char(letter))) {\n                        break;\n                    }\n                }\n            }\n\n            snippet.txt = &cur_txt[cur_txt_ofs];\n            snippet.bytes = next_ofs;\n            snippet.txt_w = use_width;\n            cur_txt_ofs += next_ofs;\n            if(max_line_h < snippet.line_h) {\n                max_line_h = snippet.line_h;\n            }\n            snippet_cnt ++;\n            if(isfill) {\n                break;\n            }\n            max_w -= use_width;\n        }\n\n        /* next line init */\n        txt_pos.x = 0;\n        txt_pos.y += max_line_h;\n        max_w = max_width;\n    }\n    txt_pos.y -= line_space;\n\n    return txt_pos.y;\n}"}, "carbit_updater/lvgl/src/extra/widgets/span/lv_span.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/span/lv_span.c"}}, "carbit_updater/lvgl/src/hal/lv_hal_disp.h": {"stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 18}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 19}, "lv_hal": {"type": "Variable", "def": "#include lv_hal.h", "sline": 20, "include": ["carbit_updater/lvgl/src/hal/lv_hal.h", null]}, "lv_img_buf": {"type": "Variable", "def": "#include ../draw/lv_img_buf.h", "sline": 21}, "lv_color": {"type": "Variable", "def": "#include ../misc/lv_color.h", "sline": 22}, "lv_area": {"type": "Variable", "def": "#include ../misc/lv_area.h", "sline": 23}, "lv_ll": {"type": "Variable", "def": "#include ../misc/lv_ll.h", "sline": 24}, "lv_timer": {"type": "Variable", "def": "#include ../misc/lv_timer.h", "sline": 25}, "_lv_obj_t": {"type": "Struct", "def": "struct _lv_obj_t", "sline": 42}, "_lv_disp_t": {"type": "Struct", "def": "struct _lv_disp_t {\n    /**< Driver to the display*/\n    struct _lv_disp_drv_t * driver;\n\n    /**< A timer which periodically checks the dirty areas and refreshes them*/\n    lv_timer_t * refr_timer;\n\n    /**< The theme assigned to the screen*/\n    struct _lv_theme_t * theme;\n\n    /** Screens of the display*/\n    struct _lv_obj_t ** screens;    /**< Array of screen objects.*/\n    struct _lv_obj_t * act_scr;     /**< Currently active screen on this display*/\n    struct _lv_obj_t * prev_scr;    /**< Previous screen. Used during screen animations*/\n    struct _lv_obj_t * scr_to_load; /**< The screen prepared to load in lv_scr_load_anim*/\n    struct _lv_obj_t * top_layer;   /**< @see lv_disp_get_layer_top*/\n    struct _lv_obj_t * sys_layer;   /**< @see lv_disp_get_layer_sys*/\n    uint32_t screen_cnt;\nuint8_t del_prev  :\n    1;          /**< 1: Automatically delete the previous screen when the screen load animation is ready*/\n\n    lv_opa_t bg_opa;                /**<Opacity of the background color or wallpaper*/\n    lv_color_t bg_color;            /**< Default display color when screens are transparent*/\n    const void * bg_img;            /**< An image source to display as wallpaper*/\n    void (*bg_fn)(lv_area_t*);/**< A function to handle drawing*/\n\n    /** Invalidated (marked to redraw) areas*/\n    lv_area_t inv_areas[LV_INV_BUF_SIZE];\n    uint8_t inv_area_joined[LV_INV_BUF_SIZE];\n    uint16_t inv_p;\n\n    /*Miscellaneous data*/\n    uint32_t last_activity_time;        /**< Last time when there was activity on this display*/\n}", "sline": 152, "body": "struct _lv_disp_drv_t * driver\nlv_timer_t * refr_timer\nstruct _lv_theme_t * theme\nstruct _lv_obj_t ** screens\nstruct _lv_obj_t * act_scr\nstruct _lv_obj_t * prev_scr\nstruct _lv_obj_t * scr_to_load\nstruct _lv_obj_t * top_layer\nstruct _lv_obj_t * sys_layer\nuint32_t screen_cnt\nuint8_t del_prev  :\n    1\nlv_opa_t bg_opa\nlv_color_t bg_color\nconst void * bg_img\nvoid (*bg_fn)(lv_area_t*)\nlv_area_t inv_areas[LV_INV_BUF_SIZE]\nuint8_t inv_area_joined[LV_INV_BUF_SIZE]\nuint16_t inv_p\nuint32_t last_activity_time\n"}, "_lv_disp_drv_t": {"type": "Struct", "def": "struct _lv_disp_drv_t {\n\n    lv_coord_t hor_res;         /**< Horizontal resolution.*/\n    lv_coord_t ver_res;         /**< Vertical resolution.*/\n\n    lv_coord_t physical_hor_res;     /**< Horizontal resolution of the full / physical display. Set to -1 for fullscreen mode.*/\n    lv_coord_t physical_ver_res;     /**< Vertical resolution of the full / physical display. Set to -1 for fullscreen mode.*/\n    lv_coord_t offset_x;             /**< Horizontal offset from the full / physical display. Set to 0 for fullscreen mode.*/\n    lv_coord_t offset_y;             /**< Vertical offset from the full / physical display. Set to 0 for fullscreen mode.*/\n\n    /** Pointer to a buffer initialized with `lv_disp_draw_buf_init()`.\n     * LVGL will use this buffer(s) to draw the screens contents*/\n    lv_disp_draw_buf_t * draw_buf;\n\n    uint32_t direct_mode : 1;        /**< 1: Use screen-sized buffers and draw to absolute coordinates*/\n    uint32_t full_refresh : 1;       /**< 1: Always make the whole screen redrawn*/\n    uint32_t sw_rotate : 1;          /**< 1: use software rotation (slower)*/\n    uint32_t antialiasing : 1;       /**< 1: anti-aliasing is enabled on this display.*/\n    uint32_t rotated : 2;            /**< 1: turn the display by 90 degree. @warning Does not update coordinates for you!*/\n    uint32_t screen_transp : 1;      /**Handle if the screen doesn't have a solid (opa == LV_OPA_COVER) background.\n                                       * Use only if required because it's slower.*/\n\n    uint32_t dpi : 10;              /** DPI (dot per inch) of the display. Default value is `LV_DPI_DEF`.*/\n\n    /** MANDATORY: Write the internal buffer (draw_buf) to the display. 'lv_disp_flush_ready()' has to be\n     * called when finished*/\n    void (*flush_cb)(struct _lv_disp_drv_t * disp_drv, const lv_area_t * area, lv_color_t * color_p);\n\n    /** OPTIONAL: Extend the invalidated areas to match with the display drivers requirements\n     * E.g. round `y` to, 8, 16 ..) on a monochrome display*/\n    void (*rounder_cb)(struct _lv_disp_drv_t * disp_drv, lv_area_t * area);\n\n    /** OPTIONAL: Set a pixel in a buffer according to the special requirements of the display\n     * Can be used for color format not supported in LittelvGL. E.g. 2 bit -> 4 gray scales\n     * @note Much slower then drawing with supported color formats.*/\n    void (*set_px_cb)(struct _lv_disp_drv_t * disp_drv, uint8_t * buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,\n                      lv_color_t color, lv_opa_t opa);\n\n    /** OPTIONAL: Called after every refresh cycle to tell the rendering and flushing time + the\n     * number of flushed pixels*/\n    void (*monitor_cb)(struct _lv_disp_drv_t * disp_drv, uint32_t time, uint32_t px);\n\n    /** OPTIONAL: Called periodically while lvgl waits for operation to be completed.\n     * For example flushing or GPU\n     * User can execute very simple tasks here or yield the task*/\n    void (*wait_cb)(struct _lv_disp_drv_t * disp_drv);\n\n    /** OPTIONAL: Called when lvgl needs any CPU cache that affects rendering to be cleaned*/\n    void (*clean_dcache_cb)(struct _lv_disp_drv_t * disp_drv);\n\n    /** OPTIONAL: called to wait while the gpu is working*/\n    void (*gpu_wait_cb)(struct _lv_disp_drv_t * disp_drv);\n\n    /** OPTIONAL: called when driver parameters are updated */\n    void (*drv_update_cb)(struct _lv_disp_drv_t * disp_drv);\n\n    /** OPTIONAL: Fill a memory with a color (GPU only)*/\n    void (*gpu_fill_cb)(struct _lv_disp_drv_t * disp_drv, lv_color_t * dest_buf, lv_coord_t dest_width,\n                        const lv_area_t * fill_area, lv_color_t color);\n\n    /** On CHROMA_KEYED images this color will be transparent.\n     * `LV_COLOR_CHROMA_KEY` by default. (lv_conf.h)*/\n    lv_color_t color_chroma_key;\n\n#if LV_USE_USER_DATA\n    void * user_data; /**< Custom display driver user data*/\n#endif\n\n}", "sline": 78, "body": "lv_coord_t hor_res\nlv_coord_t ver_res\nlv_coord_t physical_hor_res\nlv_coord_t physical_ver_res\nlv_coord_t offset_x\nlv_coord_t offset_y\nlv_disp_draw_buf_t * draw_buf\nuint32_t direct_mode : 1\nuint32_t full_refresh : 1\nuint32_t sw_rotate : 1\nuint32_t antialiasing : 1\nuint32_t rotated : 2\nuint32_t screen_transp : 1\nuint32_t dpi : 10\nvoid (*flush_cb)(struct _lv_disp_drv_t * disp_drv, const lv_area_t * area, lv_color_t * color_p)\nvoid (*rounder_cb)(struct _lv_disp_drv_t * disp_drv, lv_area_t * area)\nvoid (*set_px_cb)(struct _lv_disp_drv_t * disp_drv, uint8_t * buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,\n                      lv_color_t color, lv_opa_t opa)\nvoid (*monitor_cb)(struct _lv_disp_drv_t * disp_drv, uint32_t time, uint32_t px)\nvoid (*wait_cb)(struct _lv_disp_drv_t * disp_drv)\nvoid (*clean_dcache_cb)(struct _lv_disp_drv_t * disp_drv)\nvoid (*gpu_wait_cb)(struct _lv_disp_drv_t * disp_drv)\nvoid (*drv_update_cb)(struct _lv_disp_drv_t * disp_drv)\nvoid (*gpu_fill_cb)(struct _lv_disp_drv_t * disp_drv, lv_color_t * dest_buf, lv_coord_t dest_width,\n                        const lv_area_t * fill_area, lv_color_t color)\nlv_color_t color_chroma_key\nvoid * user_data\n"}, "_lv_theme_t": {"type": "Struct", "def": "struct _lv_theme_t", "sline": 45}, "_lv_disp_draw_buf_t.buf1": {"type": "Variable", "def": "void * buf1", "sline": 51, "in_struct": "_lv_disp_draw_buf_t"}, "_lv_disp_draw_buf_t.buf2": {"type": "Variable", "def": "void * buf2", "sline": 52, "in_struct": "_lv_disp_draw_buf_t"}, "_lv_disp_draw_buf_t.buf_act": {"type": "Variable", "def": "void * buf_act", "sline": 55, "in_struct": "_lv_disp_draw_buf_t"}, "_lv_disp_draw_buf_t.size": {"type": "Variable", "def": "uint32_t size", "sline": 56, "in_struct": "_lv_disp_draw_buf_t"}, "_lv_disp_draw_buf_t.area": {"type": "Variable", "def": "lv_area_t area", "sline": 57, "in_struct": "_lv_disp_draw_buf_t"}, "_lv_disp_draw_buf_t.flushing": {"type": "Variable", "def": "volatile int flushing", "sline": 59, "in_struct": "_lv_disp_draw_buf_t"}, "_lv_disp_draw_buf_t.flushing_last": {"type": "Variable", "def": "volatile int flushing_last", "sline": 61, "in_struct": "_lv_disp_draw_buf_t"}, "_lv_disp_draw_buf_t.last_area": {"type": "Variable", "def": "volatile uint32_t last_area         : 1", "sline": 62, "in_struct": "_lv_disp_draw_buf_t"}, "_lv_disp_draw_buf_t.last_part": {"type": "Variable", "def": "volatile uint32_t last_part         : 1", "sline": 63, "in_struct": "_lv_disp_draw_buf_t"}, "_lv_disp_draw_buf_t": {"type": "Struct", "def": "struct _lv_disp_draw_buf_t {\n    void * buf1; /**< First display buffer.*/\n    void * buf2; /**< Second display buffer.*/\n\n    /*Internal, used by the library*/\n    void * buf_act;\n    uint32_t size; /*In pixel count*/\n    lv_area_t area;\n    /*1: flushing is in progress. (It can't be a bit field because when it's cleared from IRQ Read-Modify-Write issue might occur)*/\n    volatile int flushing;\n    /*1: It was the last chunk to flush. (It can't be a bit field because when it's cleared from IRQ Read-Modify-Write issue might occur)*/\n    volatile int flushing_last;\n    volatile uint32_t last_area         : 1; /*1: the last area is being rendered*/\n    volatile uint32_t last_part         : 1; /*1: the last part of the current area is being rendered*/\n}", "sline": 50, "docstring": "/**", "body": "void * buf1\nvoid * buf2\nvoid * buf_act\nuint32_t size\nlv_area_t area\nvolatile int flushing\nvolatile int flushing_last\nvolatile uint32_t last_area         : 1\nvolatile uint32_t last_part         : 1\n"}, "lv_disp_draw_buf_t": {"type": "Variable", "def": "typedef struct _lv_disp_draw_buf_t {\n    void * buf1; /**< First display buffer.*/\n    void * buf2; /**< Second display buffer.*/\n\n    /*Internal, used by the library*/\n    void * buf_act;\n    uint32_t size; /*In pixel count*/\n    lv_area_t area;\n    /*1: flushing is in progress. (It can't be a bit field because when it's cleared from IRQ Read-Modify-Write issue might occur)*/\n    volatile int flushing;\n    /*1: It was the last chunk to flush. (It can't be a bit field because when it's cleared from IRQ Read-Modify-Write issue might occur)*/\n    volatile int flushing_last;\n    volatile uint32_t last_area         : 1; /*1: the last area is being rendered*/\n    volatile uint32_t last_part         : 1; /*1: the last part of the current area is being rendered*/\n} lv_disp_draw_buf_t", "sline": 64, "docstring": "/**"}, "lv_disp_rot_t": {"type": "Variable", "def": "typedef enum {\n    LV_DISP_ROT_NONE = 0,\n    LV_DISP_ROT_90,\n    LV_DISP_ROT_180,\n    LV_DISP_ROT_270\n} lv_disp_rot_t", "sline": 71}, "_lv_disp_drv_t.hor_res": {"type": "Variable", "def": "lv_coord_t hor_res", "sline": 80, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.ver_res": {"type": "Variable", "def": "lv_coord_t ver_res", "sline": 81, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.physical_hor_res": {"type": "Variable", "def": "lv_coord_t physical_hor_res", "sline": 83, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.physical_ver_res": {"type": "Variable", "def": "lv_coord_t physical_ver_res", "sline": 84, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.offset_x": {"type": "Variable", "def": "lv_coord_t offset_x", "sline": 85, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.offset_y": {"type": "Variable", "def": "lv_coord_t offset_y", "sline": 86, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.draw_buf": {"type": "Variable", "def": "lv_disp_draw_buf_t * draw_buf", "sline": 90, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.direct_mode": {"type": "Variable", "def": "uint32_t direct_mode : 1", "sline": 92, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.full_refresh": {"type": "Variable", "def": "uint32_t full_refresh : 1", "sline": 93, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.sw_rotate": {"type": "Variable", "def": "uint32_t sw_rotate : 1", "sline": 94, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.antialiasing": {"type": "Variable", "def": "uint32_t antialiasing : 1", "sline": 95, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.rotated": {"type": "Variable", "def": "uint32_t rotated : 2", "sline": 96, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.screen_transp": {"type": "Variable", "def": "uint32_t screen_transp : 1", "sline": 97, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.dpi": {"type": "Variable", "def": "uint32_t dpi : 10", "sline": 100, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.flush_cb": {"type": "Variable", "def": "void (*flush_cb)(struct _lv_disp_drv_t * disp_drv, const lv_area_t * area, lv_color_t * color_p)", "sline": 104, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.rounder_cb": {"type": "Variable", "def": "void (*rounder_cb)(struct _lv_disp_drv_t * disp_drv, lv_area_t * area)", "sline": 108, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.set_px_cb": {"type": "Variable", "def": "void (*set_px_cb)(struct _lv_disp_drv_t * disp_drv, uint8_t * buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,\n                      lv_color_t color, lv_opa_t opa)", "sline": 113, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.monitor_cb": {"type": "Variable", "def": "void (*monitor_cb)(struct _lv_disp_drv_t * disp_drv, uint32_t time, uint32_t px)", "sline": 118, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.wait_cb": {"type": "Variable", "def": "void (*wait_cb)(struct _lv_disp_drv_t * disp_drv)", "sline": 123, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.clean_dcache_cb": {"type": "Variable", "def": "void (*clean_dcache_cb)(struct _lv_disp_drv_t * disp_drv)", "sline": 126, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.gpu_wait_cb": {"type": "Variable", "def": "void (*gpu_wait_cb)(struct _lv_disp_drv_t * disp_drv)", "sline": 129, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.drv_update_cb": {"type": "Variable", "def": "void (*drv_update_cb)(struct _lv_disp_drv_t * disp_drv)", "sline": 132, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.gpu_fill_cb": {"type": "Variable", "def": "void (*gpu_fill_cb)(struct _lv_disp_drv_t * disp_drv, lv_color_t * dest_buf, lv_coord_t dest_width,\n                        const lv_area_t * fill_area, lv_color_t color)", "sline": 135, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.color_chroma_key": {"type": "Variable", "def": "lv_color_t color_chroma_key", "sline": 140, "in_struct": "_lv_disp_drv_t"}, "_lv_disp_drv_t.user_data": {"type": "Variable", "def": "void * user_data", "sline": 143, "in_struct": "_lv_disp_drv_t"}, "lv_disp_drv_t": {"type": "Variable", "def": "typedef struct _lv_disp_drv_t {\n\n    lv_coord_t hor_res;         /**< Horizontal resolution.*/\n    lv_coord_t ver_res;         /**< Vertical resolution.*/\n\n    lv_coord_t physical_hor_res;     /**< Horizontal resolution of the full / physical display. Set to -1 for fullscreen mode.*/\n    lv_coord_t physical_ver_res;     /**< Vertical resolution of the full / physical display. Set to -1 for fullscreen mode.*/\n    lv_coord_t offset_x;             /**< Horizontal offset from the full / physical display. Set to 0 for fullscreen mode.*/\n    lv_coord_t offset_y;             /**< Vertical offset from the full / physical display. Set to 0 for fullscreen mode.*/\n\n    /** Pointer to a buffer initialized with `lv_disp_draw_buf_init()`.\n     * LVGL will use this buffer(s) to draw the screens contents*/\n    lv_disp_draw_buf_t * draw_buf;\n\n    uint32_t direct_mode : 1;        /**< 1: Use screen-sized buffers and draw to absolute coordinates*/\n    uint32_t full_refresh : 1;       /**< 1: Always make the whole screen redrawn*/\n    uint32_t sw_rotate : 1;          /**< 1: use software rotation (slower)*/\n    uint32_t antialiasing : 1;       /**< 1: anti-aliasing is enabled on this display.*/\n    uint32_t rotated : 2;            /**< 1: turn the display by 90 degree. @warning Does not update coordinates for you!*/\n    uint32_t screen_transp : 1;      /**Handle if the screen doesn't have a solid (opa == LV_OPA_COVER) background.\n                                       * Use only if required because it's slower.*/\n\n    uint32_t dpi : 10;              /** DPI (dot per inch) of the display. Default value is `LV_DPI_DEF`.*/\n\n    /** MANDATORY: Write the internal buffer (draw_buf) to the display. 'lv_disp_flush_ready()' has to be\n     * called when finished*/\n    void (*flush_cb)(struct _lv_disp_drv_t * disp_drv, const lv_area_t * area, lv_color_t * color_p);\n\n    /** OPTIONAL: Extend the invalidated areas to match with the display drivers requirements\n     * E.g. round `y` to, 8, 16 ..) on a monochrome display*/\n    void (*rounder_cb)(struct _lv_disp_drv_t * disp_drv, lv_area_t * area);\n\n    /** OPTIONAL: Set a pixel in a buffer according to the special requirements of the display\n     * Can be used for color format not supported in LittelvGL. E.g. 2 bit -> 4 gray scales\n     * @note Much slower then drawing with supported color formats.*/\n    void (*set_px_cb)(struct _lv_disp_drv_t * disp_drv, uint8_t * buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,\n                      lv_color_t color, lv_opa_t opa);\n\n    /** OPTIONAL: Called after every refresh cycle to tell the rendering and flushing time + the\n     * number of flushed pixels*/\n    void (*monitor_cb)(struct _lv_disp_drv_t * disp_drv, uint32_t time, uint32_t px);\n\n    /** OPTIONAL: Called periodically while lvgl waits for operation to be completed.\n     * For example flushing or GPU\n     * User can execute very simple tasks here or yield the task*/\n    void (*wait_cb)(struct _lv_disp_drv_t * disp_drv);\n\n    /** OPTIONAL: Called when lvgl needs any CPU cache that affects rendering to be cleaned*/\n    void (*clean_dcache_cb)(struct _lv_disp_drv_t * disp_drv);\n\n    /** OPTIONAL: called to wait while the gpu is working*/\n    void (*gpu_wait_cb)(struct _lv_disp_drv_t * disp_drv);\n\n    /** OPTIONAL: called when driver parameters are updated */\n    void (*drv_update_cb)(struct _lv_disp_drv_t * disp_drv);\n\n    /** OPTIONAL: Fill a memory with a color (GPU only)*/\n    void (*gpu_fill_cb)(struct _lv_disp_drv_t * disp_drv, lv_color_t * dest_buf, lv_coord_t dest_width,\n                        const lv_area_t * fill_area, lv_color_t color);\n\n    /** On CHROMA_KEYED images this color will be transparent.\n     * `LV_COLOR_CHROMA_KEY` by default. (lv_conf.h)*/\n    lv_color_t color_chroma_key;\n\n#if LV_USE_USER_DATA\n    void * user_data; /**< Custom display driver user data*/\n#endif\n\n} lv_disp_drv_t", "sline": 146}, "_lv_disp_t.driver": {"type": "Variable", "def": "struct _lv_disp_drv_t * driver", "sline": 154, "in_struct": "_lv_disp_t"}, "_lv_disp_t.refr_timer": {"type": "Variable", "def": "lv_timer_t * refr_timer", "sline": 157, "in_struct": "_lv_disp_t"}, "_lv_disp_t.theme": {"type": "Variable", "def": "struct _lv_theme_t * theme", "sline": 160, "in_struct": "_lv_disp_t"}, "_lv_disp_t.screens": {"type": "Variable", "def": "struct _lv_obj_t ** screens", "sline": 163, "in_struct": "_lv_disp_t"}, "_lv_disp_t.act_scr": {"type": "Variable", "def": "struct _lv_obj_t * act_scr", "sline": 164, "in_struct": "_lv_disp_t"}, "_lv_disp_t.prev_scr": {"type": "Variable", "def": "struct _lv_obj_t * prev_scr", "sline": 165, "in_struct": "_lv_disp_t"}, "_lv_disp_t.scr_to_load": {"type": "Variable", "def": "struct _lv_obj_t * scr_to_load", "sline": 166, "in_struct": "_lv_disp_t"}, "_lv_disp_t.top_layer": {"type": "Variable", "def": "struct _lv_obj_t * top_layer", "sline": 167, "in_struct": "_lv_disp_t"}, "_lv_disp_t.sys_layer": {"type": "Variable", "def": "struct _lv_obj_t * sys_layer", "sline": 168, "in_struct": "_lv_disp_t"}, "_lv_disp_t.screen_cnt": {"type": "Variable", "def": "uint32_t screen_cnt", "sline": 169, "in_struct": "_lv_disp_t"}, "_lv_disp_t.del_prev": {"type": "Variable", "def": "uint8_t del_prev  :\n    1", "sline": 170, "in_struct": "_lv_disp_t"}, "_lv_disp_t.bg_opa": {"type": "Variable", "def": "lv_opa_t bg_opa", "sline": 173, "in_struct": "_lv_disp_t"}, "_lv_disp_t.bg_color": {"type": "Variable", "def": "lv_color_t bg_color", "sline": 174, "in_struct": "_lv_disp_t"}, "_lv_disp_t.bg_img": {"type": "Variable", "def": "const void * bg_img", "sline": 175, "in_struct": "_lv_disp_t"}, "_lv_disp_t.bg_fn": {"type": "Variable", "def": "void (*bg_fn)(lv_area_t*)", "sline": 176, "in_struct": "_lv_disp_t"}, "_lv_disp_t.inv_areas": {"type": "Variable", "def": "lv_area_t inv_areas[LV_INV_BUF_SIZE]", "sline": 179, "in_struct": "_lv_disp_t"}, "_lv_disp_t.inv_area_joined": {"type": "Variable", "def": "uint8_t inv_area_joined[LV_INV_BUF_SIZE]", "sline": 180, "in_struct": "_lv_disp_t"}, "_lv_disp_t.inv_p": {"type": "Variable", "def": "uint16_t inv_p", "sline": 181, "in_struct": "_lv_disp_t"}, "_lv_disp_t.last_activity_time": {"type": "Variable", "def": "uint32_t last_activity_time", "sline": 184, "in_struct": "_lv_disp_t"}, "lv_disp_t": {"type": "Variable", "def": "typedef struct _lv_disp_t {\n    /**< Driver to the display*/\n    struct _lv_disp_drv_t * driver;\n\n    /**< A timer which periodically checks the dirty areas and refreshes them*/\n    lv_timer_t * refr_timer;\n\n    /**< The theme assigned to the screen*/\n    struct _lv_theme_t * theme;\n\n    /** Screens of the display*/\n    struct _lv_obj_t ** screens;    /**< Array of screen objects.*/\n    struct _lv_obj_t * act_scr;     /**< Currently active screen on this display*/\n    struct _lv_obj_t * prev_scr;    /**< Previous screen. Used during screen animations*/\n    struct _lv_obj_t * scr_to_load; /**< The screen prepared to load in lv_scr_load_anim*/\n    struct _lv_obj_t * top_layer;   /**< @see lv_disp_get_layer_top*/\n    struct _lv_obj_t * sys_layer;   /**< @see lv_disp_get_layer_sys*/\n    uint32_t screen_cnt;\nuint8_t del_prev  :\n    1;          /**< 1: Automatically delete the previous screen when the screen load animation is ready*/\n\n    lv_opa_t bg_opa;                /**<Opacity of the background color or wallpaper*/\n    lv_color_t bg_color;            /**< Default display color when screens are transparent*/\n    const void * bg_img;            /**< An image source to display as wallpaper*/\n    void (*bg_fn)(lv_area_t*);/**< A function to handle drawing*/\n\n    /** Invalidated (marked to redraw) areas*/\n    lv_area_t inv_areas[LV_INV_BUF_SIZE];\n    uint8_t inv_area_joined[LV_INV_BUF_SIZE];\n    uint16_t inv_p;\n\n    /*Miscellaneous data*/\n    uint32_t last_activity_time;        /**< Last time when there was activity on this display*/\n} lv_disp_t", "sline": 185}, "lv_disp_drv_init": {"type": "Function", "def": "void lv_disp_drv_init(lv_disp_drv_t * driver)", "sline": 197}, "lv_disp_draw_buf_init": {"type": "Function", "def": "void lv_disp_draw_buf_init(lv_disp_draw_buf_t * draw_buf, void * buf1, void * buf2, uint32_t size_in_px_cnt)", "sline": 214}, "lv_disp_drv_register": {"type": "Function", "def": "lv_disp_t * lv_disp_drv_register(lv_disp_drv_t * driver)", "sline": 222}, "lv_disp_drv_update": {"type": "Function", "def": "void lv_disp_drv_update(lv_disp_t * disp, lv_disp_drv_t * new_drv)", "sline": 229}, "lv_disp_remove": {"type": "Function", "def": "void lv_disp_remove(lv_disp_t * disp)", "sline": 235}, "lv_disp_set_default": {"type": "Function", "def": "void lv_disp_set_default(lv_disp_t * disp)", "sline": 241}, "lv_disp_get_default": {"type": "Function", "def": "lv_disp_t * lv_disp_get_default(void)", "sline": 247}, "lv_disp_get_hor_res": {"type": "Function", "def": "lv_coord_t lv_disp_get_hor_res(lv_disp_t * disp)", "sline": 254}, "lv_disp_get_ver_res": {"type": "Function", "def": "lv_coord_t lv_disp_get_ver_res(lv_disp_t * disp)", "sline": 261}, "lv_disp_get_physical_hor_res": {"type": "Function", "def": "lv_coord_t lv_disp_get_physical_hor_res(lv_disp_t * disp)", "sline": 268}, "lv_disp_get_physical_ver_res": {"type": "Function", "def": "lv_coord_t lv_disp_get_physical_ver_res(lv_disp_t * disp)", "sline": 275}, "lv_disp_get_offset_x": {"type": "Function", "def": "lv_coord_t lv_disp_get_offset_x(lv_disp_t * disp)", "sline": 282}, "lv_disp_get_offset_y": {"type": "Function", "def": "lv_coord_t lv_disp_get_offset_y(lv_disp_t * disp)", "sline": 289}, "lv_disp_get_antialiasing": {"type": "Function", "def": "bool lv_disp_get_antialiasing(lv_disp_t * disp)", "sline": 296}, "lv_disp_get_dpi": {"type": "Function", "def": "lv_coord_t lv_disp_get_dpi(const lv_disp_t * disp)", "sline": 303}, "lv_disp_set_rotation": {"type": "Function", "def": "void lv_disp_set_rotation(lv_disp_t * disp, lv_disp_rot_t rotation)", "sline": 311}, "lv_disp_get_rotation": {"type": "Function", "def": "lv_disp_rot_t lv_disp_get_rotation(lv_disp_t * disp)", "sline": 318, "rels": [["lv_disp_rot_t", null, "Typeof"]]}, "lv_disp_flush_ready": {"type": "Function", "def": "void lv_disp_flush_ready(lv_disp_drv_t * disp_drv)", "sline": 326}, "lv_disp_flush_is_last": {"type": "Function", "def": "bool lv_disp_flush_is_last(lv_disp_drv_t * disp_drv)", "sline": 334}, "lv_disp_get_next": {"type": "Function", "def": "lv_disp_t * lv_disp_get_next(lv_disp_t * disp)", "sline": 343}, "lv_disp_get_draw_buf": {"type": "Function", "def": "lv_disp_draw_buf_t * lv_disp_get_draw_buf(lv_disp_t * disp)", "sline": 350}, "lv_disp_drv_use_generic_set_px_cb": {"type": "Function", "def": "void lv_disp_drv_use_generic_set_px_cb(lv_disp_drv_t * disp_drv, lv_img_cf_t cf)", "sline": 352}, "carbit_updater/lvgl/src/hal/lv_hal_disp.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/hal/lv_hal_disp.h"}}, "carbit_updater/lvgl/src/extra/widgets/meter/lv_meter.h": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 16}, "lv_meter_scale_t.tick_color": {"type": "Variable", "def": "lv_color_t tick_color", "sline": 34, "in_struct": "lv_meter_scale_t"}, "lv_meter_scale_t.tick_cnt": {"type": "Variable", "def": "uint16_t tick_cnt", "sline": 35, "in_struct": "lv_meter_scale_t"}, "lv_meter_scale_t.tick_length": {"type": "Variable", "def": "uint16_t tick_length", "sline": 36, "in_struct": "lv_meter_scale_t"}, "lv_meter_scale_t.tick_width": {"type": "Variable", "def": "uint16_t tick_width", "sline": 37, "in_struct": "lv_meter_scale_t"}, "lv_meter_scale_t.tick_major_color": {"type": "Variable", "def": "lv_color_t tick_major_color", "sline": 39, "in_struct": "lv_meter_scale_t"}, "lv_meter_scale_t.tick_major_nth": {"type": "Variable", "def": "uint16_t tick_major_nth", "sline": 40, "in_struct": "lv_meter_scale_t"}, "lv_meter_scale_t.tick_major_length": {"type": "Variable", "def": "uint16_t tick_major_length", "sline": 41, "in_struct": "lv_meter_scale_t"}, "lv_meter_scale_t.tick_major_width": {"type": "Variable", "def": "uint16_t tick_major_width", "sline": 42, "in_struct": "lv_meter_scale_t"}, "lv_meter_scale_t.label_gap": {"type": "Variable", "def": "int16_t label_gap", "sline": 44, "in_struct": "lv_meter_scale_t"}, "lv_meter_scale_t.label_color": {"type": "Variable", "def": "int16_t label_color", "sline": 45, "in_struct": "lv_meter_scale_t"}, "lv_meter_scale_t.min": {"type": "Variable", "def": "int32_t min", "sline": 47, "in_struct": "lv_meter_scale_t"}, "lv_meter_scale_t.max": {"type": "Variable", "def": "int32_t max", "sline": 48, "in_struct": "lv_meter_scale_t"}, "lv_meter_scale_t.r_mod": {"type": "Variable", "def": "int16_t r_mod", "sline": 49, "in_struct": "lv_meter_scale_t"}, "lv_meter_scale_t.angle_range": {"type": "Variable", "def": "uint16_t angle_range", "sline": 50, "in_struct": "lv_meter_scale_t"}, "lv_meter_scale_t.rotation": {"type": "Variable", "def": "int16_t rotation", "sline": 51, "in_struct": "lv_meter_scale_t"}, "lv_meter_scale_t": {"type": "Variable", "def": "typedef struct {\n    lv_color_t tick_color;\n    uint16_t tick_cnt;\n    uint16_t tick_length;\n    uint16_t tick_width;\n\n    lv_color_t tick_major_color;\n    uint16_t tick_major_nth;\n    uint16_t tick_major_length;\n    uint16_t tick_major_width;\n\n    int16_t label_gap;\n    int16_t label_color;\n\n    int32_t min;\n    int32_t max;\n    int16_t r_mod;\n    uint16_t angle_range;\n    int16_t rotation;\n} lv_meter_scale_t", "sline": 52}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/meter/lv_meter.h:54:1)": {"type": "Enum", "def": "enum {\n    LV_METER_INDICATOR_TYPE_NEEDLE_IMG,\n    LV_METER_INDICATOR_TYPE_NEEDLE_LINE,\n    LV_METER_INDICATOR_TYPE_SCALE_LINES,\n    LV_METER_INDICATOR_TYPE_ARC,\n}", "sline": 54}, "lv_meter_indicator_type_t": {"type": "Variable", "def": "typedef uint8_t lv_meter_indicator_type_t", "sline": 60}, "lv_meter_indicator_t.scale": {"type": "Variable", "def": "lv_meter_scale_t * scale", "sline": 63, "in_struct": "lv_meter_indicator_t"}, "lv_meter_indicator_t.type": {"type": "Variable", "def": "lv_meter_indicator_type_t type", "sline": 64, "in_struct": "lv_meter_indicator_t", "rels": [["lv_meter_indicator_type_t", null, "Typeof"]]}, "lv_meter_indicator_t.opa": {"type": "Variable", "def": "lv_opa_t opa", "sline": 65, "in_struct": "lv_meter_indicator_t"}, "lv_meter_indicator_t.start_value": {"type": "Variable", "def": "int32_t start_value", "sline": 66, "in_struct": "lv_meter_indicator_t"}, "lv_meter_indicator_t.end_value": {"type": "Variable", "def": "int32_t end_value", "sline": 67, "in_struct": "lv_meter_indicator_t"}, "lv_meter_indicator_t.type_data": {"type": "Variable", "def": "union {\n        struct {\n            const void * src;\n            lv_point_t pivot;\n        } needle_img;\n        struct {\n            uint16_t width;\n            int16_t r_mod;\n            lv_color_t color;\n        } needle_line;\n        struct {\n            uint16_t width;\n            const void * src;\n            lv_color_t color;\n            int16_t r_mod;\n        } arc;\n        struct {\n            int16_t width_mod;\n            lv_color_t color_start;\n            lv_color_t color_end;\n            uint8_t local_grad  : 1;\n        } scale_lines;\n    } type_data", "sline": 90, "in_struct": "lv_meter_indicator_t"}, "lv_meter_indicator_t": {"type": "Variable", "def": "typedef struct {\n    lv_meter_scale_t * scale;\n    lv_meter_indicator_type_t type;\n    lv_opa_t opa;\n    int32_t start_value;\n    int32_t end_value;\n    union {\n        struct {\n            const void * src;\n            lv_point_t pivot;\n        } needle_img;\n        struct {\n            uint16_t width;\n            int16_t r_mod;\n            lv_color_t color;\n        } needle_line;\n        struct {\n            uint16_t width;\n            const void * src;\n            lv_color_t color;\n            int16_t r_mod;\n        } arc;\n        struct {\n            int16_t width_mod;\n            lv_color_t color_start;\n            lv_color_t color_end;\n            uint8_t local_grad  : 1;\n        } scale_lines;\n    } type_data;\n} lv_meter_indicator_t", "sline": 91}, "lv_meter_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 95, "in_struct": "lv_meter_t"}, "lv_meter_t.scale_ll": {"type": "Variable", "def": "lv_ll_t scale_ll", "sline": 96, "in_struct": "lv_meter_t"}, "lv_meter_t.indicator_ll": {"type": "Variable", "def": "lv_ll_t indicator_ll", "sline": 97, "in_struct": "lv_meter_t"}, "lv_meter_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    lv_ll_t scale_ll;\n    lv_ll_t indicator_ll;\n} lv_meter_t", "sline": 98, "docstring": "/*Data of line meter*/"}, "lv_meter_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_meter_class", "sline": 100}, "lv_meter_draw_part_type_t": {"type": "Variable", "def": "typedef enum {\n    LV_METER_DRAW_PART_ARC,             /**< The arc indicator*/\n    LV_METER_DRAW_PART_NEEDLE_LINE,     /**< The needle lines*/\n    LV_METER_DRAW_PART_NEEDLE_IMG,      /**< The needle images*/\n    LV_METER_DRAW_PART_TICK,            /**< The tick lines and labels*/\n} lv_meter_draw_part_type_t", "sline": 111}, "lv_meter_create": {"type": "Function", "def": "lv_obj_t * lv_meter_create(lv_obj_t * parent)", "sline": 122}, "lv_meter_add_scale": {"type": "Function", "def": "lv_meter_scale_t * lv_meter_add_scale(lv_obj_t * obj)", "sline": 134}, "lv_meter_set_scale_ticks": {"type": "Function", "def": "void lv_meter_set_scale_ticks(lv_obj_t * obj, lv_meter_scale_t * scale, uint16_t cnt, uint16_t width, uint16_t len,\n                              lv_color_t color)", "sline": 145}, "lv_meter_set_scale_major_ticks": {"type": "Function", "def": "void lv_meter_set_scale_major_ticks(lv_obj_t * obj, lv_meter_scale_t * scale, uint16_t nth, uint16_t width,\n                                    uint16_t len, lv_color_t color, int16_t label_gap)", "sline": 159}, "lv_meter_set_scale_range": {"type": "Function", "def": "void lv_meter_set_scale_range(lv_obj_t * obj, lv_meter_scale_t * scale, int32_t min, int32_t max, uint32_t angle_range,\n                              uint32_t rotation)", "sline": 171}, "lv_meter_add_needle_line": {"type": "Function", "def": "lv_meter_indicator_t * lv_meter_add_needle_line(lv_obj_t * obj, lv_meter_scale_t * scale, uint16_t width,\n                                                lv_color_t color, int16_t r_mod)", "sline": 187}, "lv_meter_add_needle_img": {"type": "Function", "def": "lv_meter_indicator_t * lv_meter_add_needle_img(lv_obj_t * obj, lv_meter_scale_t * scale, const void * src,\n                                               lv_coord_t pivot_x, lv_coord_t pivot_y)", "sline": 200}, "lv_meter_add_arc": {"type": "Function", "def": "lv_meter_indicator_t * lv_meter_add_arc(lv_obj_t * obj, lv_meter_scale_t * scale, uint16_t width, lv_color_t color,\n                                        int16_t r_mod)", "sline": 212}, "lv_meter_add_scale_lines": {"type": "Function", "def": "lv_meter_indicator_t * lv_meter_add_scale_lines(lv_obj_t * obj, lv_meter_scale_t * scale, lv_color_t color_start,\n                                                lv_color_t color_end, bool local, int16_t width_mod)", "sline": 226}, "lv_meter_set_indicator_value": {"type": "Function", "def": "void lv_meter_set_indicator_value(lv_obj_t * obj, lv_meter_indicator_t * indic, int32_t value)", "sline": 239}, "lv_meter_set_indicator_start_value": {"type": "Function", "def": "void lv_meter_set_indicator_start_value(lv_obj_t * obj, lv_meter_indicator_t * indic, int32_t value)", "sline": 247}, "lv_meter_set_indicator_end_value": {"type": "Function", "def": "void lv_meter_set_indicator_end_value(lv_obj_t * obj, lv_meter_indicator_t * indic, int32_t value)", "sline": 255}, "carbit_updater/lvgl/src/extra/widgets/meter/lv_meter.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/meter/lv_meter.h"}}, "carbit_updater/lvgl/src/widgets/lv_line.c": {"lv_line": {"type": "Variable", "def": "#include lv_line.h", "sline": 9, "include": ["carbit_updater/lvgl/src/widgets/lv_line.h", null]}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 12}, "lv_draw": {"type": "Variable", "def": "#include ../draw/lv_draw.h", "sline": 13}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 14}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 15}, "stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 16}, "string": {"type": "Variable", "def": "#include string.h", "sline": 17}, "lv_line_constructor": {"type": "Function", "def": "static void lv_line_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 108, "body": "{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_line_t * line = (lv_line_t *)obj;\n\n    line->point_num   = 0;\n    line->point_array = NULL;\n    line->y_inv       = 0;\n\n    lv_obj_clear_flag(obj, LV_OBJ_FLAG_CLICKABLE);\n\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}"}, "lv_line_event": {"type": "Function", "def": "static void lv_line_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 124, "body": "{\n    LV_UNUSED(class_p);\n\n    lv_res_t res;\n\n    /*Call the ancestor's event handler*/\n    res = lv_obj_event_base(MY_CLASS, e);\n    if(res != LV_RES_OK) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n\n    if(code == LV_EVENT_REFR_EXT_DRAW_SIZE) {\n        /*The corner of the skew lines is out of the intended area*/\n        lv_coord_t line_width = lv_obj_get_style_line_width(obj, LV_PART_MAIN);\n        lv_coord_t * s = lv_event_get_param(e);\n        if(*s < line_width) *s = line_width;\n    }\n    else if(code == LV_EVENT_GET_SELF_SIZE) {\n        lv_line_t * line = (lv_line_t *)obj;\n\n        lv_point_t * p = lv_event_get_param(e);\n        lv_coord_t w = 0;\n        lv_coord_t h = 0;\n        if(line->point_num > 0) {\n            uint16_t i;\n            for(i = 0; i < line->point_num; i++) {\n                w = LV_MAX(line->point_array[i].x, w);\n                h = LV_MAX(line->point_array[i].y, h);\n            }\n\n            lv_coord_t line_width = lv_obj_get_style_line_width(obj, LV_PART_MAIN);\n            w += line_width;\n            h += line_width;\n            p->x = w;\n            p->y = h;\n        }\n    }\n    else if(code == LV_EVENT_DRAW_MAIN) {\n        lv_line_t * line = (lv_line_t *)obj;\n        const lv_area_t * clip_area = lv_event_get_param(e);\n\n        if(line->point_num == 0 || line->point_array == NULL) return;\n\n        lv_area_t area;\n        lv_obj_get_coords(obj, &area);\n        lv_coord_t x_ofs = area.x1 - lv_obj_get_scroll_x(obj);\n        lv_coord_t y_ofs = area.y1 - lv_obj_get_scroll_y(obj);\n        lv_point_t p1;\n        lv_point_t p2;\n        lv_coord_t h = lv_obj_get_height(obj);\n        uint16_t i;\n\n        lv_draw_line_dsc_t line_dsc;\n        lv_draw_line_dsc_init(&line_dsc);\n        lv_obj_init_draw_line_dsc(obj, LV_PART_MAIN, &line_dsc);\n\n        /*Read all points and draw the lines*/\n        for(i = 0; i < line->point_num - 1; i++) {\n\n            p1.x = line->point_array[i].x + x_ofs;\n            p2.x = line->point_array[i + 1].x + x_ofs;\n\n            if(line->y_inv == 0) {\n                p1.y = line->point_array[i].y + y_ofs;\n                p2.y = line->point_array[i + 1].y + y_ofs;\n            }\n            else {\n                p1.y = h - line->point_array[i].y + y_ofs;\n                p2.y = h - line->point_array[i + 1].y + y_ofs;\n            }\n            lv_draw_line(&p1, &p2, clip_area, &line_dsc);\n            line_dsc.round_start = 0;   /*Draw the rounding only on the end points after the first line*/\n        }\n    }\n}"}, "lv_line_class": {"type": "Variable", "def": "const lv_obj_class_t lv_line_class = {\n    .constructor_cb = lv_line_constructor,\n    .event_cb = lv_line_event,\n    .width_def = LV_SIZE_CONTENT,\n    .height_def = LV_SIZE_CONTENT,\n    .instance_size = sizeof(lv_line_t),\n    .base_class = &lv_obj_class\n}", "sline": 37}, "lv_line_create": {"type": "Function", "def": "lv_obj_t * lv_line_create(lv_obj_t * parent)", "sline": 54, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_line_set_points": {"type": "Function", "def": "void lv_line_set_points(lv_obj_t * obj, const lv_point_t points[], uint16_t point_num)", "sline": 66, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_line_t * line = (lv_line_t *)obj;\n    line->point_array    = points;\n    line->point_num      = point_num;\n\n    lv_obj_refresh_self_size(obj);\n\n    lv_obj_invalidate(obj);\n}"}, "lv_line_set_y_invert": {"type": "Function", "def": "void lv_line_set_y_invert(lv_obj_t * obj, bool en)", "sline": 79, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_line_t * line = (lv_line_t *)obj;\n    if(line->y_inv == en) return;\n\n    line->y_inv = en == false ? 0 : 1;\n\n    lv_obj_invalidate(obj);\n}"}, "lv_line_get_y_invert": {"type": "Function", "def": "bool lv_line_get_y_invert(const lv_obj_t * obj)", "sline": 95, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_line_t * line = (lv_line_t *)obj;\n\n    return line->y_inv == 0 ? false : true;\n}"}, "carbit_updater/lvgl/src/widgets/lv_line.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_line.c"}}, "carbit_updater/lv_drivers/display/ILI9341.h": {"stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 16}, "lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 21}, "carbit_updater/lv_drivers/display/ILI9341.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/ILI9341.h"}}, "carbit_updater/lv_drivers/display/SHARP_MIP.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 21}, "carbit_updater/lv_drivers/display/SHARP_MIP.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/SHARP_MIP.h"}}, "carbit_updater/lv_drivers/display/g2d_driver_enh.h": {"stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 22}, "types": {"type": "Variable", "def": "#include linux/types.h", "sline": 23}, "ioctl": {"type": "Variable", "def": "#include linux/ioctl.h", "sline": 24}, "g2d_fmt_enh": {"type": "Variable", "def": "typedef enum {\n\tG2D_FORMAT_ARGB8888,\n\tG2D_FORMAT_ABGR8888,\n\tG2D_FORMAT_RGBA8888,\n\tG2D_FORMAT_BGRA8888,\n\tG2D_FORMAT_XRGB8888,\n\tG2D_FORMAT_XBGR8888,\n\tG2D_FORMAT_RGBX8888,\n\tG2D_FORMAT_BGRX8888,\n\tG2D_FORMAT_RGB888,\n\tG2D_FORMAT_BGR888,\n\tG2D_FORMAT_RGB565,\n\tG2D_FORMAT_BGR565,\n\tG2D_FORMAT_ARGB4444,\n\tG2D_FORMAT_ABGR4444,\n\tG2D_FORMAT_RGBA4444,\n\tG2D_FORMAT_BGRA4444,\n\tG2D_FORMAT_ARGB1555,\n\tG2D_FORMAT_ABGR1555,\n\tG2D_FORMAT_RGBA5551,\n\tG2D_FORMAT_BGRA5551,\n\tG2D_FORMAT_ARGB2101010,\n\tG2D_FORMAT_ABGR2101010,\n\tG2D_FORMAT_RGBA1010102,\n\tG2D_FORMAT_BGRA1010102,\n\n\t/* invailed for UI channel */\n\tG2D_FORMAT_IYUV422_V0Y1U0Y0 = 0x20,\n\tG2D_FORMAT_IYUV422_Y1V0Y0U0,\n\tG2D_FORMAT_IYUV422_U0Y1V0Y0,\n\tG2D_FORMAT_IYUV422_Y1U0Y0V0,\n\n\tG2D_FORMAT_YUV422UVC_V1U1V0U0,\n\tG2D_FORMAT_YUV422UVC_U1V1U0V0,\n\tG2D_FORMAT_YUV422_PLANAR,\n\n\tG2D_FORMAT_YUV420UVC_V1U1V0U0 = 0x28,\n\tG2D_FORMAT_YUV420UVC_U1V1U0V0,\n\tG2D_FORMAT_YUV420_PLANAR,\n\n\tG2D_FORMAT_YUV411UVC_V1U1V0U0 = 0x2c,\n\tG2D_FORMAT_YUV411UVC_U1V1U0V0,\n\tG2D_FORMAT_YUV411_PLANAR,\n\n\tG2D_FORMAT_Y8 = 0x30,\n\n\t/* YUV 10bit format */\n\tG2D_FORMAT_YVU10_P010 = 0x34,\n\n\tG2D_FORMAT_YVU10_P210 = 0x36,\n\n\tG2D_FORMAT_YVU10_444 = 0x38,\n\tG2D_FORMAT_YUV10_444 = 0x39,\n\tG2D_FORMAT_MAX,\n} g2d_fmt_enh", "sline": 81, "docstring": "/* data format */"}, "g2d_data_fmt": {"type": "Variable", "def": "typedef enum {\n\t/* share data format */\n\tG2D_FMT_ARGB_AYUV8888\t= (0x0),\n\tG2D_FMT_BGRA_VUYA8888\t= (0x1),\n\tG2D_FMT_ABGR_AVUY8888\t= (0x2),\n\tG2D_FMT_RGBA_YUVA8888\t= (0x3),\n\n\tG2D_FMT_XRGB8888\t\t= (0x4),\n\tG2D_FMT_BGRX8888\t\t= (0x5),\n\tG2D_FMT_XBGR8888\t\t= (0x6),\n\tG2D_FMT_RGBX8888\t\t= (0x7),\n\n\tG2D_FMT_ARGB4444\t\t= (0x8),\n\tG2D_FMT_ABGR4444\t\t= (0x9),\n\tG2D_FMT_RGBA4444\t\t= (0xA),\n\tG2D_FMT_BGRA4444\t\t= (0xB),\n\n\tG2D_FMT_ARGB1555\t\t= (0xC),\n\tG2D_FMT_ABGR1555\t\t= (0xD),\n\tG2D_FMT_RGBA5551\t\t= (0xE),\n\tG2D_FMT_BGRA5551\t\t= (0xF),\n\n\tG2D_FMT_RGB565\t\t\t= (0x10),\n\tG2D_FMT_BGR565\t\t\t= (0x11),\n\n\tG2D_FMT_IYUV422\t\t\t= (0x12),\n\n\tG2D_FMT_8BPP_MONO\t\t= (0x13),\n\tG2D_FMT_4BPP_MONO\t\t= (0x14),\n\tG2D_FMT_2BPP_MONO\t\t= (0x15),\n\tG2D_FMT_1BPP_MONO\t\t= (0x16),\n\n\tG2D_FMT_PYUV422UVC\t\t= (0x17),\n\tG2D_FMT_PYUV420UVC\t\t= (0x18),\n\tG2D_FMT_PYUV411UVC\t\t= (0x19),\n\n\t/* just for output format */\n\tG2D_FMT_PYUV422\t\t\t= (0x1A),\n\tG2D_FMT_PYUV420\t\t\t= (0x1B),\n\tG2D_FMT_PYUV411\t\t\t= (0x1C),\n\n\t/* just for input format */\n\tG2D_FMT_8BPP_PALETTE\t= (0x1D),\n\tG2D_FMT_4BPP_PALETTE\t= (0x1E),\n\tG2D_FMT_2BPP_PALETTE\t= (0x1F),\n\tG2D_FMT_1BPP_PALETTE\t= (0x20),\n\n\tG2D_FMT_PYUV422UVC_MB16\t= (0x21),\n\tG2D_FMT_PYUV420UVC_MB16\t= (0x22),\n\tG2D_FMT_PYUV411UVC_MB16\t= (0x23),\n\tG2D_FMT_PYUV422UVC_MB32\t= (0x24),\n\tG2D_FMT_PYUV420UVC_MB32\t= (0x25),\n\tG2D_FMT_PYUV411UVC_MB32\t= (0x26),\n\tG2D_FMT_PYUV422UVC_MB64\t= (0x27),\n\tG2D_FMT_PYUV420UVC_MB64\t= (0x28),\n\tG2D_FMT_PYUV411UVC_MB64\t= (0x29),\n\tG2D_FMT_PYUV422UVC_MB128 = (0x2A),\n\tG2D_FMT_PYUV420UVC_MB128 = (0x2B),\n\tG2D_FMT_PYUV411UVC_MB128 = (0x2C),\n\n} g2d_data_fmt", "sline": 143, "docstring": "/* mixer data format */"}, "g2d_pixel_seq": {"type": "Variable", "def": "typedef enum {\n\tG2D_SEQ_NORMAL = 0x0,\n\n\t/* for interleaved yuv422 */\n\tG2D_SEQ_VYUY   = 0x1,\t\t\t/* pixel 0\ufffd\u06b5\ufffd16\u03bb */\n\tG2D_SEQ_YVYU   = 0x2,\t\t\t/* pixel 1\ufffd\u06b5\ufffd16\u03bb */\n\n\t/* for uv_combined yuv420 */\n\tG2D_SEQ_VUVU   = 0x3,\n\n\t/* for 16bpp rgb */\n\tG2D_SEQ_P10    = 0x4,\t\t\t/* pixel 0\ufffd\u06b5\ufffd16\u03bb */\n\tG2D_SEQ_P01    = 0x5,\t\t\t/* pixel 1\ufffd\u06b5\ufffd16\u03bb */\n\n\t/* planar format or 8bpp rgb */\n\tG2D_SEQ_P3210  = 0x6,\t\t\t/* pixel 0\ufffd\u06b5\ufffd8\u03bb */\n\tG2D_SEQ_P0123  = 0x7,\t\t\t/* pixel 3\ufffd\u06b5\ufffd8\u03bb */\n\n\t/* for 4bpp rgb */\n\tG2D_SEQ_P76543210  = 0x8,\t\t\t/* 7,6,5,4,3,2,1,0 */\n\tG2D_SEQ_P67452301  = 0x9,\t\t\t/* 6,7,4,5,2,3,0,1 */\n\tG2D_SEQ_P10325476  = 0xA,\t\t\t/* 1,0,3,2,5,4,7,6 */\n\tG2D_SEQ_P01234567  = 0xB,\t\t\t/* 0,1,2,3,4,5,6,7 */\n\n\t/* for 2bpp rgb */\n\t/* 15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0 */\n\tG2D_SEQ_2BPP_BIG_BIG       = 0xC,\n\t/* 12,13,14,15,8,9,10,11,4,5,6,7,0,1,2,3 */\n\tG2D_SEQ_2BPP_BIG_LITTER    = 0xD,\n\t/* 3,2,1,0,7,6,5,4,11,10,9,8,15,14,13,12 */\n\tG2D_SEQ_2BPP_LITTER_BIG    = 0xE,\n\t/* 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 */\n\tG2D_SEQ_2BPP_LITTER_LITTER = 0xF,\n\n\t/* for 1bpp rgb */\n\t/* 31,30,29,28,27,26,25,24,23,22,21,20,\n\t * 19,18,17,16,15,14,13,12,11,10,9,8,7,\n\t * 6,5,4,3,2,1,0\n\t */\n\tG2D_SEQ_1BPP_BIG_BIG       = 0x10,\n\t/* 24,25,26,27,28,29,30,31,16,17,\n\t * 18,19,20,21,22,23,8,9,10,11,12,\n\t * 13,14,15,0,1,2,3,4,5,6,7\n\t */\n\tG2D_SEQ_1BPP_BIG_LITTER    = 0x11,\n\t/* 7,6,5,4,3,2,1,0,15,14,13,12,11,\n\t * 10,9,8,23,22,21,20,19,18,17,16,\n\t * 31,30,29,28,27,26,25,24\n\t */\n\tG2D_SEQ_1BPP_LITTER_BIG    = 0x12,\n\t/* 0,1,2,3,4,5,6,7,8,9,10,11,12,13,\n\t * 14,15,16,17,18,19,20,21,22,23,24,\n\t * 25,26,27,28,29,30,31\n\t */\n\tG2D_SEQ_1BPP_LITTER_LITTER = 0x13,\n} g2d_pixel_seq", "sline": 201, "docstring": "/* pixel sequence in double word */"}, "g2d_blt_flags_h": {"type": "Variable", "def": "typedef enum {\n\tG2D_BLT_NONE_H = 0x0,\n\tG2D_BLT_BLACKNESS,\n\tG2D_BLT_NOTMERGEPEN,\n\tG2D_BLT_MASKNOTPEN,\n\tG2D_BLT_NOTCOPYPEN,\n\tG2D_BLT_MASKPENNOT,\n\tG2D_BLT_NOT,\n\tG2D_BLT_XORPEN,\n\tG2D_BLT_NOTMASKPEN,\n\tG2D_BLT_MASKPEN,\n\tG2D_BLT_NOTXORPEN,\n\tG2D_BLT_NOP,\n\tG2D_BLT_MERGENOTPEN,\n\tG2D_BLT_COPYPEN,\n\tG2D_BLT_MERGEPENNOT,\n\tG2D_BLT_MERGEPEN,\n\tG2D_BLT_WHITENESS = 0x000000ff,\n\n\tG2D_ROT_90  = 0x00000100,\n\tG2D_ROT_180 = 0x00000200,\n\tG2D_ROT_270 = 0x00000300,\n\tG2D_ROT_0   = 0x00000400,\n\tG2D_ROT_H = 0x00001000,\n\tG2D_ROT_V = 0x00002000,\n\n/*\tG2D_SM_TDLR_1  =    0x10000000, */\n\tG2D_SM_DTLR_1 = 0x10000000,\n/*\tG2D_SM_TDRL_1  =    0x20000000, */\n/*\tG2D_SM_DTRL_1  =    0x30000000, */\n} g2d_blt_flags_h", "sline": 234, "docstring": "/*  */"}, "g2d_rop3_cmd_flag": {"type": "Variable", "def": "typedef enum {\n\tG2D_ROP3_BLACKNESS = 0x00,\n\tG2D_ROP3_NOTSRCERASE = 0x11,\n\tG2D_ROP3_NOTSRCCOPY = 0x33,\n\tG2D_ROP3_SRCERASE = 0x44,\n\tG2D_ROP3_DSTINVERT = 0x55,\n\tG2D_ROP3_PATINVERT = 0x5A,\n\tG2D_ROP3_SRCINVERT = 0x66,\n\tG2D_ROP3_SRCAND = 0x88,\n\tG2D_ROP3_MERGEPAINT = 0xBB,\n\tG2D_ROP3_MERGECOPY = 0xC0,\n\tG2D_ROP3_SRCCOPY = 0xCC,\n\tG2D_ROP3_SRCPAINT = 0xEE,\n\tG2D_ROP3_PATCOPY = 0xF0,\n\tG2D_ROP3_PATPAINT = 0xFB,\n\tG2D_ROP3_WHITENESS = 0xFF,\n} g2d_rop3_cmd_flag", "sline": 253, "docstring": "/* ROP3 command */"}, "g2d_fillrect_flags": {"type": "Variable", "def": "typedef enum {\n\tG2D_FIL_NONE\t\t\t= 0x00000000,\n\tG2D_FIL_PIXEL_ALPHA\t\t= 0x00000001,\n\tG2D_FIL_PLANE_ALPHA\t\t= 0x00000002,\n\tG2D_FIL_MULTI_ALPHA\t\t= 0x00000004,\n} g2d_fillrect_flags", "sline": 260}, "g2d_blt_flags": {"type": "Variable", "def": "typedef enum {\n\tG2D_BLT_NONE\t\t\t= 0x00000000,\n\tG2D_BLT_PIXEL_ALPHA\t\t= 0x00000001,\n\tG2D_BLT_PLANE_ALPHA\t\t= 0x00000002,\n\tG2D_BLT_MULTI_ALPHA\t\t= 0x00000004,\n\tG2D_BLT_SRC_COLORKEY\t= 0x00000008,\n\tG2D_BLT_DST_COLORKEY\t= 0x00000010,\n\tG2D_BLT_FLIP_HORIZONTAL\t= 0x00000020,\n\tG2D_BLT_FLIP_VERTICAL\t= 0x00000040,\n\tG2D_BLT_ROTATE90\t\t= 0x00000080,\n\tG2D_BLT_ROTATE180\t\t= 0x00000100,\n\tG2D_BLT_ROTATE270\t\t= 0x00000200,\n\tG2D_BLT_MIRROR45\t\t= 0x00000400,\n\tG2D_BLT_MIRROR135\t\t= 0x00000800,\n\tG2D_BLT_SRC_PREMULTIPLY\t= 0x00001000,\n\tG2D_BLT_DST_PREMULTIPLY\t= 0x00002000,\n} g2d_blt_flags", "sline": 278}, "g2d_alpha_mode_enh": {"type": "Variable", "def": "typedef enum {\n\tG2D_PIXEL_ALPHA,\n\tG2D_GLOBAL_ALPHA,\n\tG2D_MIXER_ALPHA,\n} g2d_alpha_mode_enh", "sline": 285, "docstring": "/* BLD LAYER ALPHA MODE*/"}, "g2d_rect.x": {"type": "Variable", "def": "__s32\t\tx", "sline": 289, "in_struct": "g2d_rect"}, "g2d_rect.y": {"type": "Variable", "def": "__s32\t\ty", "sline": 290, "in_struct": "g2d_rect"}, "g2d_rect.w": {"type": "Variable", "def": "__u32\t\tw", "sline": 291, "in_struct": "g2d_rect"}, "g2d_rect.h": {"type": "Variable", "def": "__u32\t\th", "sline": 292, "in_struct": "g2d_rect"}, "g2d_rect": {"type": "Variable", "def": "typedef struct {\n\t__s32\t\tx;\t\t/* left top point coordinate x */\n\t__s32\t\ty;\t\t/* left top point coordinate y */\n\t__u32\t\tw;\t\t/* rectangle width */\n\t__u32\t\th;\t\t/* rectangle height */\n} g2d_rect", "sline": 293, "docstring": "/* flip rectangle struct */"}, "g2d_color_gmt": {"type": "Variable", "def": "typedef enum {\n\tG2D_BT601,\n\tG2D_BT709,\n\tG2D_BT2020,\n} g2d_color_gmt", "sline": 300, "docstring": "/* g2d color gamut */"}, "g2d_image.addr": {"type": "Variable", "def": "__u32\t\taddr[3]", "sline": 304, "in_struct": "g2d_image"}, "g2d_image.w": {"type": "Variable", "def": "__u32\t\tw", "sline": 305, "in_struct": "g2d_image"}, "g2d_image.h": {"type": "Variable", "def": "__u32\t\th", "sline": 306, "in_struct": "g2d_image"}, "g2d_image.format": {"type": "Variable", "def": "g2d_data_fmt\tformat", "sline": 307, "in_struct": "g2d_image", "rels": [["g2d_data_fmt", null, "Typeof"]]}, "g2d_image.pixel_seq": {"type": "Variable", "def": "g2d_pixel_seq\tpixel_seq", "sline": 308, "in_struct": "g2d_image", "rels": [["g2d_pixel_seq", null, "Typeof"]]}, "g2d_image": {"type": "Variable", "def": "typedef struct {\n\t__u32\t\taddr[3];/* base addr of image frame buffer in byte */\n\t__u32\t\tw;\t/* width of image frame buffer in pixel */\n\t__u32\t\th;\t/* height of image frame buffer in pixel */\n\tg2d_data_fmt\tformat;\t/* pixel format of image frame buffer */\n\tg2d_pixel_seq\tpixel_seq;/* pixel sequence of image frame buffer */\n} g2d_image", "sline": 309, "docstring": "/* image struct */"}, "g2d_coor.x": {"type": "Variable", "def": "unsigned int x", "sline": 313, "in_struct": "g2d_coor"}, "g2d_coor.y": {"type": "Variable", "def": "unsigned int y", "sline": 315, "in_struct": "g2d_coor"}, "g2d_coor": {"type": "Variable", "def": "typedef struct {\n\t/* left point coordinate x of dst rect */\n\tunsigned int x;\n\t/* top point coordinate y of dst rect */\n\tunsigned int y;\n} g2d_coor", "sline": 316}, "color_range": {"type": "Enum", "def": "enum color_range {\n\tCOLOR_RANGE_0_255 = 0,\n\tCOLOR_RANGE_16_255 = 1,\n}", "sline": 318}, "g2d_image_enh.bbuff": {"type": "Variable", "def": "int\t\t bbuff", "sline": 324, "in_struct": "g2d_image_enh"}, "g2d_image_enh.color": {"type": "Variable", "def": "__u32\t\t color", "sline": 325, "in_struct": "g2d_image_enh"}, "g2d_image_enh.format": {"type": "Variable", "def": "g2d_fmt_enh\t format", "sline": 326, "in_struct": "g2d_image_enh", "rels": [["g2d_fmt_enh", null, "Typeof"]]}, "g2d_image_enh.laddr": {"type": "Variable", "def": "__u32\t\t laddr[3]", "sline": 327, "in_struct": "g2d_image_enh"}, "g2d_image_enh.haddr": {"type": "Variable", "def": "__u32\t\t haddr[3]", "sline": 328, "in_struct": "g2d_image_enh"}, "g2d_image_enh.width": {"type": "Variable", "def": "__u32\t\t width", "sline": 329, "in_struct": "g2d_image_enh"}, "g2d_image_enh.height": {"type": "Variable", "def": "__u32\t\t height", "sline": 330, "in_struct": "g2d_image_enh"}, "g2d_image_enh.align": {"type": "Variable", "def": "__u32\t\t align[3]", "sline": 331, "in_struct": "g2d_image_enh"}, "g2d_image_enh.clip_rect": {"type": "Variable", "def": "g2d_rect\t clip_rect", "sline": 333, "in_struct": "g2d_image_enh", "rels": [["g2d_rect", null, "Typeof"]]}, "g2d_image_enh.coor": {"type": "Variable", "def": "g2d_coor\t coor", "sline": 334, "in_struct": "g2d_image_enh", "rels": [["g2d_coor", null, "Typeof"]]}, "g2d_image_enh.gamut": {"type": "Variable", "def": "g2d_color_gmt    gamut", "sline": 336, "in_struct": "g2d_image_enh", "rels": [["g2d_color_gmt", null, "Typeof"]]}, "g2d_image_enh.bpremul": {"type": "Variable", "def": "int\t\t bpremul", "sline": 337, "in_struct": "g2d_image_enh"}, "g2d_image_enh.alpha": {"type": "Variable", "def": "__u8\t\t alpha", "sline": 338, "in_struct": "g2d_image_enh"}, "g2d_image_enh.mode": {"type": "Variable", "def": "g2d_alpha_mode_enh mode", "sline": 339, "in_struct": "g2d_image_enh", "rels": [["g2d_alpha_mode_enh", null, "Typeof"]]}, "g2d_image_enh.fd": {"type": "Variable", "def": "int\t\t fd", "sline": 340, "in_struct": "g2d_image_enh"}, "g2d_image_enh.use_phy_addr": {"type": "Variable", "def": "__u32 use_phy_addr", "sline": 341, "in_struct": "g2d_image_enh"}, "g2d_image_enh.color_range": {"type": "Variable", "def": "enum color_range color_range", "sline": 342, "in_struct": "g2d_image_enh"}, "g2d_image_enh": {"type": "Variable", "def": "typedef struct {\n\tint\t\t bbuff;\n\t__u32\t\t color;\n\tg2d_fmt_enh\t format;\n\t__u32\t\t laddr[3];\n\t__u32\t\t haddr[3];\n\t__u32\t\t width;\n\t__u32\t\t height;\n\t__u32\t\t align[3];\n\n\tg2d_rect\t clip_rect;\n\tg2d_coor\t coor;\n\n\tg2d_color_gmt    gamut;\n\tint\t\t bpremul;\n\t__u8\t\t alpha;\n\tg2d_alpha_mode_enh mode;\n\tint\t\t fd;\n\t__u32 use_phy_addr;\n\tenum color_range color_range;\n} g2d_image_enh", "sline": 343, "docstring": "/* image struct */"}, "g2d_scan_order": {"type": "Enum", "def": "enum g2d_scan_order {\n\tG2D_SM_TDLR = 0x00000000,\n\tG2D_SM_TDRL = 0x00000001,\n\tG2D_SM_DTLR = 0x00000002,\n\tG2D_SM_DTRL = 0x00000003,\n}", "sline": 351}, "g2d_fillrect.flag": {"type": "Variable", "def": "g2d_fillrect_flags\t flag", "sline": 359, "in_struct": "g2d_fillrect", "rels": [["g2d_fillrect_flags", null, "Typeof"]]}, "g2d_fillrect.dst_image": {"type": "Variable", "def": "g2d_image\t\t\t dst_image", "sline": 360, "in_struct": "g2d_fillrect", "rels": [["g2d_image", null, "Typeof"]]}, "g2d_fillrect.dst_rect": {"type": "Variable", "def": "g2d_rect\t\t\t dst_rect", "sline": 361, "in_struct": "g2d_fillrect", "rels": [["g2d_rect", null, "Typeof"]]}, "g2d_fillrect.color": {"type": "Variable", "def": "__u32\t\t\t\t color", "sline": 363, "in_struct": "g2d_fillrect"}, "g2d_fillrect.alpha": {"type": "Variable", "def": "__u32\t\t\t\t alpha", "sline": 364, "in_struct": "g2d_fillrect"}, "g2d_fillrect": {"type": "Variable", "def": "typedef struct {\n\tg2d_fillrect_flags\t flag;\n\tg2d_image\t\t\t dst_image;\n\tg2d_rect\t\t\t dst_rect;\n\n\t__u32\t\t\t\t color;\t\t/* fill color */\n\t__u32\t\t\t\t alpha;\t\t/* plane alpha value */\n\n} g2d_fillrect", "sline": 366}, "g2d_fillrect_h.dst_image_h": {"type": "Variable", "def": "g2d_image_enh dst_image_h", "sline": 369, "in_struct": "g2d_fillrect_h", "rels": [["g2d_image_enh", null, "Typeof"]]}, "g2d_fillrect_h": {"type": "Variable", "def": "typedef struct {\n\tg2d_image_enh dst_image_h;\n} g2d_fillrect_h", "sline": 370}, "g2d_blt.flag": {"type": "Variable", "def": "g2d_blt_flags\t\tflag", "sline": 373, "in_struct": "g2d_blt", "rels": [["g2d_blt_flags", null, "Typeof"]]}, "g2d_blt.src_image": {"type": "Variable", "def": "g2d_image\t\tsrc_image", "sline": 374, "in_struct": "g2d_blt", "rels": [["g2d_image", null, "Typeof"]]}, "g2d_blt.src_rect": {"type": "Variable", "def": "g2d_rect\t\tsrc_rect", "sline": 375, "in_struct": "g2d_blt", "rels": [["g2d_rect", null, "Typeof"]]}, "g2d_blt.dst_image": {"type": "Variable", "def": "g2d_image\t\tdst_image", "sline": 377, "in_struct": "g2d_blt", "rels": [["g2d_image", null, "Typeof"]]}, "g2d_blt.dst_x": {"type": "Variable", "def": "__s32\t\t\tdst_x", "sline": 379, "in_struct": "g2d_blt"}, "g2d_blt.dst_y": {"type": "Variable", "def": "__s32\t\t\tdst_y", "sline": 381, "in_struct": "g2d_blt"}, "g2d_blt.color": {"type": "Variable", "def": "__u32\t\t\tcolor", "sline": 383, "in_struct": "g2d_blt"}, "g2d_blt.alpha": {"type": "Variable", "def": "__u32\t\t\talpha", "sline": 384, "in_struct": "g2d_blt"}, "g2d_blt": {"type": "Variable", "def": "typedef struct {\n\tg2d_blt_flags\t\tflag;\n\tg2d_image\t\tsrc_image;\n\tg2d_rect\t\tsrc_rect;\n\n\tg2d_image\t\tdst_image;\n\t/* left top point coordinate x of dst rect */\n\t__s32\t\t\tdst_x;\n\t/* left top point coordinate y of dst rect */\n\t__s32\t\t\tdst_y;\n\n\t__u32\t\t\tcolor;\t\t/* colorkey color */\n\t__u32\t\t\talpha;\t\t/* plane alpha value */\n\n} g2d_blt", "sline": 386}, "g2d_blt_h.flag_h": {"type": "Variable", "def": "g2d_blt_flags_h flag_h", "sline": 389, "in_struct": "g2d_blt_h", "rels": [["g2d_blt_flags_h", null, "Typeof"]]}, "g2d_blt_h.src_image_h": {"type": "Variable", "def": "g2d_image_enh src_image_h", "sline": 390, "in_struct": "g2d_blt_h", "rels": [["g2d_image_enh", null, "Typeof"]]}, "g2d_blt_h.dst_image_h": {"type": "Variable", "def": "g2d_image_enh dst_image_h", "sline": 391, "in_struct": "g2d_blt_h", "rels": [["g2d_image_enh", null, "Typeof"]]}, "g2d_blt_h": {"type": "Variable", "def": "typedef struct {\n\tg2d_blt_flags_h flag_h;\n\tg2d_image_enh src_image_h;\n\tg2d_image_enh dst_image_h;\n} g2d_blt_h", "sline": 392}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:394:9).blt": {"type": "Variable", "def": "g2d_blt_h blt", "sline": 395, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:394:9)", "rels": [["g2d_blt_h", null, "Typeof"]]}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:394:9).lbc_cmp_ratio": {"type": "Variable", "def": "__u32\tlbc_cmp_ratio", "sline": 396, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:394:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:394:9).enc_is_lossy": {"type": "Variable", "def": "bool\tenc_is_lossy", "sline": 397, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:394:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:394:9).dec_is_lossy": {"type": "Variable", "def": "bool\tdec_is_lossy", "sline": 398, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:394:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:394:9)": {"type": "Struct", "def": "struct {\n\tg2d_blt_h blt;\n\t__u32\tlbc_cmp_ratio;\n\tbool\tenc_is_lossy;\n\tbool\tdec_is_lossy;\n}", "sline": 394, "body": "g2d_blt_h blt\n__u32\tlbc_cmp_ratio\nbool\tenc_is_lossy\nbool\tdec_is_lossy\n"}, "g2d_lbc_rot": {"type": "Variable", "def": "typedef struct {\n\tg2d_blt_h blt;\n\t__u32\tlbc_cmp_ratio;\n\tbool\tenc_is_lossy;\n\tbool\tdec_is_lossy;\n} g2d_lbc_rot", "sline": 399}, "g2d_stretchblt.flag": {"type": "Variable", "def": "g2d_blt_flags\t\t\t flag", "sline": 402, "in_struct": "g2d_stretchblt", "rels": [["g2d_blt_flags", null, "Typeof"]]}, "g2d_stretchblt.src_image": {"type": "Variable", "def": "g2d_image\t\t\t src_image", "sline": 403, "in_struct": "g2d_stretchblt", "rels": [["g2d_image", null, "Typeof"]]}, "g2d_stretchblt.src_rect": {"type": "Variable", "def": "g2d_rect\t\t\t src_rect", "sline": 404, "in_struct": "g2d_stretchblt", "rels": [["g2d_rect", null, "Typeof"]]}, "g2d_stretchblt.dst_image": {"type": "Variable", "def": "g2d_image\t\t\t dst_image", "sline": 406, "in_struct": "g2d_stretchblt", "rels": [["g2d_image", null, "Typeof"]]}, "g2d_stretchblt.dst_rect": {"type": "Variable", "def": "g2d_rect\t\t\t dst_rect", "sline": 407, "in_struct": "g2d_stretchblt", "rels": [["g2d_rect", null, "Typeof"]]}, "g2d_stretchblt.color": {"type": "Variable", "def": "__u32\t\t\t\t color", "sline": 409, "in_struct": "g2d_stretchblt"}, "g2d_stretchblt.alpha": {"type": "Variable", "def": "__u32\t\t\t\t alpha", "sline": 410, "in_struct": "g2d_stretchblt"}, "g2d_stretchblt": {"type": "Variable", "def": "typedef struct {\n\tg2d_blt_flags\t\t\t flag;\n\tg2d_image\t\t\t src_image;\n\tg2d_rect\t\t\t src_rect;\n\n\tg2d_image\t\t\t dst_image;\n\tg2d_rect\t\t\t dst_rect;\n\n\t__u32\t\t\t\t color;\t\t/* colorkey color */\n\t__u32\t\t\t\t alpha;\t\t/* plane alpha value */\n\n\n} g2d_stretchblt", "sline": 413}, "g2d_maskblt.back_flag": {"type": "Variable", "def": "g2d_rop3_cmd_flag back_flag", "sline": 416, "in_struct": "g2d_maskblt", "rels": [["g2d_rop3_cmd_flag", null, "Typeof"]]}, "g2d_maskblt.fore_flag": {"type": "Variable", "def": "g2d_rop3_cmd_flag fore_flag", "sline": 417, "in_struct": "g2d_maskblt", "rels": [["g2d_rop3_cmd_flag", null, "Typeof"]]}, "g2d_maskblt.dst_image_h": {"type": "Variable", "def": "g2d_image_enh dst_image_h", "sline": 419, "in_struct": "g2d_maskblt", "rels": [["g2d_image_enh", null, "Typeof"]]}, "g2d_maskblt.src_image_h": {"type": "Variable", "def": "g2d_image_enh src_image_h", "sline": 420, "in_struct": "g2d_maskblt", "rels": [["g2d_image_enh", null, "Typeof"]]}, "g2d_maskblt.ptn_image_h": {"type": "Variable", "def": "g2d_image_enh ptn_image_h", "sline": 421, "in_struct": "g2d_maskblt", "rels": [["g2d_image_enh", null, "Typeof"]]}, "g2d_maskblt.mask_image_h": {"type": "Variable", "def": "g2d_image_enh mask_image_h", "sline": 422, "in_struct": "g2d_maskblt", "rels": [["g2d_image_enh", null, "Typeof"]]}, "g2d_maskblt": {"type": "Variable", "def": "typedef struct {\n\tg2d_rop3_cmd_flag back_flag;\n\tg2d_rop3_cmd_flag fore_flag;\n\n\tg2d_image_enh dst_image_h;\n\tg2d_image_enh src_image_h;\n\tg2d_image_enh ptn_image_h;\n\tg2d_image_enh mask_image_h;\n\n} g2d_maskblt", "sline": 424}, "g2d_bld_cmd_flag": {"type": "Variable", "def": "typedef enum {\n\tG2D_BLD_CLEAR = 0x00000001,\n\tG2D_BLD_COPY = 0x00000002,\n\tG2D_BLD_DST = 0x00000003,\n\tG2D_BLD_SRCOVER = 0x00000004,\n\tG2D_BLD_DSTOVER = 0x00000005,\n\tG2D_BLD_SRCIN = 0x00000006,\n\tG2D_BLD_DSTIN = 0x00000007,\n\tG2D_BLD_SRCOUT = 0x00000008,\n\tG2D_BLD_DSTOUT = 0x00000009,\n\tG2D_BLD_SRCATOP = 0x0000000a,\n\tG2D_BLD_DSTATOP = 0x0000000b,\n\tG2D_BLD_XOR = 0x0000000c,\n\tG2D_CK_SRC = 0x00010000,\n\tG2D_CK_DST = 0x00020000,\n} g2d_bld_cmd_flag", "sline": 442, "docstring": "/* Porter Duff BLD command*/"}, "g2d_palette.pbuffer": {"type": "Variable", "def": "__u32\t\t*pbuffer", "sline": 445, "in_struct": "g2d_palette"}, "g2d_palette.size": {"type": "Variable", "def": "__u32\t\t size", "sline": 446, "in_struct": "g2d_palette"}, "g2d_palette": {"type": "Variable", "def": "typedef struct {\n\t__u32\t\t*pbuffer;\n\t__u32\t\t size;\n\n} g2d_palette", "sline": 448}, "g2d_cache_range.start": {"type": "Variable", "def": "long\tstart", "sline": 453, "in_struct": "g2d_cache_range"}, "g2d_cache_range.end": {"type": "Variable", "def": "long\tend", "sline": 454, "in_struct": "g2d_cache_range"}, "g2d_cache_range": {"type": "Variable", "def": "typedef struct {\n\tlong\tstart;\n\tlong\tend;\n} g2d_cache_range", "sline": 455}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:458:9).match_rule": {"type": "Variable", "def": "bool match_rule", "sline": 459, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:458:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:458:9).max_color": {"type": "Variable", "def": "__u32 max_color", "sline": 461, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:458:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:458:9).min_color": {"type": "Variable", "def": "__u32 min_color", "sline": 462, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:458:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:458:9)": {"type": "Struct", "def": "struct {\n\tbool match_rule;\n/*\tint match_rule; */\n\t__u32 max_color;\n\t__u32 min_color;\n}", "sline": 458, "docstring": "/* CK PARA struct */", "body": "bool match_rule\n__u32 max_color\n__u32 min_color\n"}, "g2d_ck": {"type": "Variable", "def": "typedef struct {\n\tbool match_rule;\n/*\tint match_rule; */\n\t__u32 max_color;\n\t__u32 min_color;\n} g2d_ck", "sline": 463, "docstring": "/* CK PARA struct */"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:465:9).bld_cmd": {"type": "Variable", "def": "g2d_bld_cmd_flag bld_cmd", "sline": 466, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:465:9)", "rels": [["g2d_bld_cmd_flag", null, "Typeof"]]}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:465:9).dst_image": {"type": "Variable", "def": "g2d_image_enh dst_image", "sline": 467, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:465:9)", "rels": [["g2d_image_enh", null, "Typeof"]]}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:465:9).src_image": {"type": "Variable", "def": "g2d_image_enh src_image[4]", "sline": 468, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:465:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:465:9).ck_para": {"type": "Variable", "def": "g2d_ck ck_para", "sline": 469, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:465:9)", "rels": [["g2d_ck", null, "Typeof"]]}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h:465:9)": {"type": "Struct", "def": "struct {\n\tg2d_bld_cmd_flag bld_cmd;\n\tg2d_image_enh dst_image;\n\tg2d_image_enh src_image[4];/*now only ch0 and ch3*/\n\tg2d_ck ck_para;\n}", "sline": 465, "body": "g2d_bld_cmd_flag bld_cmd\ng2d_image_enh dst_image\ng2d_image_enh src_image[4]\ng2d_ck ck_para\n"}, "g2d_bld": {"type": "Variable", "def": "typedef struct {\n\tg2d_bld_cmd_flag bld_cmd;\n\tg2d_image_enh dst_image;\n\tg2d_image_enh src_image[4];/*now only ch0 and ch3*/\n\tg2d_ck ck_para;\n} g2d_bld", "sline": 470}, "g2d_operation_flag": {"type": "Variable", "def": "typedef enum {\n\tOP_FILLRECT = 0x1,\n\tOP_BITBLT = 0x2,\n\tOP_BLEND = 0x4,\n\tOP_MASK = 0x8,\n\tOP_SPLIT_MEM = 0x10,\n} g2d_operation_flag", "sline": 478}, "mixer_para.op_flag": {"type": "Variable", "def": "g2d_operation_flag op_flag", "sline": 484, "in_struct": "mixer_para", "rels": [["g2d_operation_flag", null, "Typeof"]]}, "mixer_para.flag_h": {"type": "Variable", "def": "g2d_blt_flags_h flag_h", "sline": 485, "in_struct": "mixer_para", "rels": [["g2d_blt_flags_h", null, "Typeof"]]}, "mixer_para.back_flag": {"type": "Variable", "def": "g2d_rop3_cmd_flag back_flag", "sline": 486, "in_struct": "mixer_para", "rels": [["g2d_rop3_cmd_flag", null, "Typeof"]]}, "mixer_para.fore_flag": {"type": "Variable", "def": "g2d_rop3_cmd_flag fore_flag", "sline": 487, "in_struct": "mixer_para", "rels": [["g2d_rop3_cmd_flag", null, "Typeof"]]}, "mixer_para.bld_cmd": {"type": "Variable", "def": "g2d_bld_cmd_flag bld_cmd", "sline": 488, "in_struct": "mixer_para", "rels": [["g2d_bld_cmd_flag", null, "Typeof"]]}, "mixer_para.src_image_h": {"type": "Variable", "def": "g2d_image_enh src_image_h", "sline": 489, "in_struct": "mixer_para", "rels": [["g2d_image_enh", null, "Typeof"]]}, "mixer_para.dst_image_h": {"type": "Variable", "def": "g2d_image_enh dst_image_h", "sline": 490, "in_struct": "mixer_para", "rels": [["g2d_image_enh", null, "Typeof"]]}, "mixer_para.ptn_image_h": {"type": "Variable", "def": "g2d_image_enh ptn_image_h", "sline": 491, "in_struct": "mixer_para", "rels": [["g2d_image_enh", null, "Typeof"]]}, "mixer_para.mask_image_h": {"type": "Variable", "def": "g2d_image_enh mask_image_h", "sline": 492, "in_struct": "mixer_para", "rels": [["g2d_image_enh", null, "Typeof"]]}, "mixer_para.ck_para": {"type": "Variable", "def": "g2d_ck ck_para", "sline": 493, "in_struct": "mixer_para", "rels": [["g2d_ck", null, "Typeof"]]}, "mixer_para": {"type": "Struct", "def": "struct mixer_para {\n\tg2d_operation_flag op_flag;\n\tg2d_blt_flags_h flag_h;\n\tg2d_rop3_cmd_flag back_flag;\n\tg2d_rop3_cmd_flag fore_flag;\n\tg2d_bld_cmd_flag bld_cmd;\n\tg2d_image_enh src_image_h;\n\tg2d_image_enh dst_image_h;\n\tg2d_image_enh ptn_image_h;\n\tg2d_image_enh mask_image_h;\n\tg2d_ck ck_para;\n}", "sline": 483, "docstring": "/**", "body": "g2d_operation_flag op_flag\ng2d_blt_flags_h flag_h\ng2d_rop3_cmd_flag back_flag\ng2d_rop3_cmd_flag fore_flag\ng2d_bld_cmd_flag bld_cmd\ng2d_image_enh src_image_h\ng2d_image_enh dst_image_h\ng2d_image_enh ptn_image_h\ng2d_image_enh mask_image_h\ng2d_ck ck_para\n"}, "g2d_cmd": {"type": "Variable", "def": "typedef enum {\n\tG2D_CMD_BITBLT\t\t\t=\t0x50,\n\tG2D_CMD_FILLRECT\t\t=\t0x51,\n\tG2D_CMD_STRETCHBLT\t\t=\t0x52,\n\tG2D_CMD_PALETTE_TBL\t\t=\t0x53,\n\tG2D_CMD_QUEUE\t\t\t=\t0x54,\n\tG2D_CMD_BITBLT_H\t\t=\t0x55,\n\tG2D_CMD_FILLRECT_H\t\t=\t0x56,\n\tG2D_CMD_BLD_H\t\t\t=\t0x57,\n\tG2D_CMD_MASK_H\t\t\t=\t0x58,\n\n\tG2D_CMD_MEM_REQUEST\t\t=\t0x59,\n\tG2D_CMD_MEM_RELEASE\t\t=\t0x5A,\n\tG2D_CMD_MEM_GETADR\t\t=\t0x5B,\n\tG2D_CMD_MEM_SELIDX\t\t=\t0x5C,\n\tG2D_CMD_MEM_FLUSH_CACHE\t\t=\t0x5D,\n\tG2D_CMD_INVERTED_ORDER\t\t=\t0x5E,\n\tG2D_CMD_MIXER_TASK\t\t=\t0x5F,\n\tG2D_CMD_LBC_ROT\t\t\t=\t0x60,\n\tG2D_CMD_CREATE_TASK = SUNXI_G2D_IOW(0x1, struct mixer_para),\n\tG2D_CMD_TASK_APPLY = SUNXI_G2D_IOW(0x2, struct mixer_para),\n\tG2D_CMD_TASK_DESTROY = SUNXI_G2D_IOW(0x3, unsigned int),\n\tG2D_CMD_TASK_GET_PARA = SUNXI_G2D_IOR(0x4, struct mixer_para),\n} g2d_cmd", "sline": 524}, "carbit_updater/lv_drivers/display/g2d_driver_enh.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver_enh.h"}}, "carbit_updater/lvgl/src/draw/lv_img_buf.c": {"stddef": {"type": "Variable", "def": "#include stddef.h", "sline": 9}, "string": {"type": "Variable", "def": "#include string.h", "sline": 10}, "lv_img_buf": {"type": "Variable", "def": "#include lv_img_buf.h", "sline": 11, "include": ["carbit_updater/lvgl/src/draw/lv_img_buf.h", null]}, "lv_draw_img": {"type": "Variable", "def": "#include lv_draw_img.h", "sline": 12, "include": ["carbit_updater/lvgl/src/draw/lv_draw_img.h", null]}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 13}, "lv_log": {"type": "Variable", "def": "#include ../misc/lv_log.h", "sline": 14}, "lv_mem": {"type": "Variable", "def": "#include ../misc/lv_mem.h", "sline": 15}, "lv_img_buf_get_px_color": {"type": "Function", "def": "lv_color_t lv_img_buf_get_px_color(lv_img_dsc_t * dsc, lv_coord_t x, lv_coord_t y, lv_color_t color)", "sline": 51, "body": "{\n    lv_color_t p_color = lv_color_black();\n    uint8_t * buf_u8 = (uint8_t *)dsc->data;\n\n    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED ||\n       dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA) {\n        uint8_t px_size = lv_img_cf_get_px_size(dsc->header.cf) >> 3;\n        uint32_t px     = dsc->header.w * y * px_size + x * px_size;\n        lv_memcpy_small(&p_color, &buf_u8[px], sizeof(lv_color_t));\n#if LV_COLOR_SIZE == 32\n        p_color.ch.alpha = 0xFF; /*Only the color should be get so use a default alpha value*/\n#endif\n    }\n    else if(dsc->header.cf == LV_IMG_CF_INDEXED_1BIT) {\n        buf_u8 += 4 * 2;\n        uint8_t bit = x & 0x7;\n        x           = x >> 3;\n\n        /*Get the current pixel.\n         *dsc->header.w + 7 means rounding up to 8 because the lines are byte aligned\n         *so the possible real width are 8, 16, 24 ...*/\n        uint32_t px  = ((dsc->header.w + 7) >> 3) * y + x;\n        p_color.full = (buf_u8[px] & (1 << (7 - bit))) >> (7 - bit);\n    }\n    else if(dsc->header.cf == LV_IMG_CF_INDEXED_2BIT) {\n        buf_u8 += 4 * 4;\n        uint8_t bit = (x & 0x3) * 2;\n        x           = x >> 2;\n\n        /*Get the current pixel.\n         *dsc->header.w + 3 means rounding up to 4 because the lines are byte aligned\n         *so the possible real width are 4, 8, 12 ...*/\n        uint32_t px  = ((dsc->header.w + 3) >> 2) * y + x;\n        p_color.full = (buf_u8[px] & (3 << (6 - bit))) >> (6 - bit);\n    }\n    else if(dsc->header.cf == LV_IMG_CF_INDEXED_4BIT) {\n        buf_u8 += 4 * 16;\n        uint8_t bit = (x & 0x1) * 4;\n        x           = x >> 1;\n\n        /*Get the current pixel.\n         *dsc->header.w + 1 means rounding up to 2 because the lines are byte aligned\n         *so the possible real width are 2, 4, 6 ...*/\n        uint32_t px  = ((dsc->header.w + 1) >> 1) * y + x;\n        p_color.full = (buf_u8[px] & (0xF << (4 - bit))) >> (4 - bit);\n    }\n    else if(dsc->header.cf == LV_IMG_CF_INDEXED_8BIT) {\n        buf_u8 += 4 * 256;\n        uint32_t px  = dsc->header.w * y + x;\n        p_color.full = buf_u8[px];\n    }\n    else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT || dsc->header.cf == LV_IMG_CF_ALPHA_2BIT ||\n            dsc->header.cf == LV_IMG_CF_ALPHA_4BIT || dsc->header.cf == LV_IMG_CF_ALPHA_8BIT) {\n        p_color = color;\n    }\n    return p_color;\n}"}, "lv_img_buf_get_px_alpha": {"type": "Function", "def": "lv_opa_t lv_img_buf_get_px_alpha(lv_img_dsc_t * dsc, lv_coord_t x, lv_coord_t y)", "sline": 118, "body": "{\n    uint8_t * buf_u8 = (uint8_t *)dsc->data;\n\n    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA) {\n        uint32_t px = dsc->header.w * y * LV_IMG_PX_SIZE_ALPHA_BYTE + x * LV_IMG_PX_SIZE_ALPHA_BYTE;\n        return buf_u8[px + LV_IMG_PX_SIZE_ALPHA_BYTE - 1];\n    }\n    else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT) {\n        uint8_t bit = x & 0x7;\n        x           = x >> 3;\n\n        /*Get the current pixel.\n         *dsc->header.w + 7 means rounding up to 8 because the lines are byte aligned\n         *so the possible real width are 8 ,16, 24 ...*/\n        uint32_t px    = ((dsc->header.w + 7) >> 3) * y + x;\n        uint8_t px_opa = (buf_u8[px] & (1 << (7 - bit))) >> (7 - bit);\n        return px_opa ? LV_OPA_TRANSP : LV_OPA_COVER;\n    }\n    else if(dsc->header.cf == LV_IMG_CF_ALPHA_2BIT) {\n        const uint8_t opa_table[4] = {0, 85, 170, 255}; /*Opacity mapping with bpp = 2*/\n\n        uint8_t bit = (x & 0x3) * 2;\n        x           = x >> 2;\n\n        /*Get the current pixel.\n         *dsc->header.w + 4 means rounding up to 8 because the lines are byte aligned\n         *so the possible real width are 4 ,8, 12 ...*/\n        uint32_t px    = ((dsc->header.w + 3) >> 2) * y + x;\n        uint8_t px_opa = (buf_u8[px] & (3 << (6 - bit))) >> (6 - bit);\n        return opa_table[px_opa];\n    }\n    else if(dsc->header.cf == LV_IMG_CF_ALPHA_4BIT) {\n        const uint8_t opa_table[16] = {0,  17, 34,  51, /*Opacity mapping with bpp = 4*/\n                                       68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255\n                                      };\n\n        uint8_t bit = (x & 0x1) * 4;\n        x           = x >> 1;\n\n        /*Get the current pixel.\n         *dsc->header.w + 1 means rounding up to 8 because the lines are byte aligned\n         *so the possible real width are 2 ,4, 6 ...*/\n        uint32_t px    = ((dsc->header.w + 1) >> 1) * y + x;\n        uint8_t px_opa = (buf_u8[px] & (0xF << (4 - bit))) >> (4 - bit);\n        return opa_table[px_opa];\n    }\n    else if(dsc->header.cf == LV_IMG_CF_ALPHA_8BIT) {\n        uint32_t px = dsc->header.w * y + x;\n        return buf_u8[px];\n    }\n\n    return LV_OPA_COVER;\n}"}, "lv_img_buf_set_px_alpha": {"type": "Function", "def": "void lv_img_buf_set_px_alpha(lv_img_dsc_t * dsc, lv_coord_t x, lv_coord_t y, lv_opa_t opa)", "sline": 181, "body": "{\n    uint8_t * buf_u8 = (uint8_t *)dsc->data;\n\n    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA) {\n        uint8_t px_size          = lv_img_cf_get_px_size(dsc->header.cf) >> 3;\n        uint32_t px              = dsc->header.w * y * px_size + x * px_size;\n        buf_u8[px + px_size - 1] = opa;\n    }\n    else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT) {\n        opa         = opa >> 7; /*opa -> [0,1]*/\n        uint8_t bit = x & 0x7;\n        x           = x >> 3;\n\n        /*Get the current pixel.\n         *dsc->header.w + 7 means rounding up to 8 because the lines are byte aligned\n         *so the possible real width are 8 ,16, 24 ...*/\n        uint32_t px = ((dsc->header.w + 7) >> 3) * y + x;\n        buf_u8[px]  = buf_u8[px] & ~(1 << (7 - bit));\n        buf_u8[px]  = buf_u8[px] | ((opa & 0x1) << (7 - bit));\n    }\n    else if(dsc->header.cf == LV_IMG_CF_ALPHA_2BIT) {\n        opa         = opa >> 6; /*opa -> [0,3]*/\n        uint8_t bit = (x & 0x3) * 2;\n        x           = x >> 2;\n\n        /*Get the current pixel.\n         *dsc->header.w + 4 means rounding up to 8 because the lines are byte aligned\n         *so the possible real width are 4 ,8, 12 ...*/\n        uint32_t px = ((dsc->header.w + 3) >> 2) * y + x;\n        buf_u8[px]  = buf_u8[px] & ~(3 << (6 - bit));\n        buf_u8[px]  = buf_u8[px] | ((opa & 0x3) << (6 - bit));\n    }\n    else if(dsc->header.cf == LV_IMG_CF_ALPHA_4BIT) {\n        opa         = opa >> 4; /*opa -> [0,15]*/\n        uint8_t bit = (x & 0x1) * 4;\n        x           = x >> 1;\n\n        /*Get the current pixel.\n         *dsc->header.w + 1 means rounding up to 8 because the lines are byte aligned\n         *so the possible real width are 2 ,4, 6 ...*/\n        uint32_t px = ((dsc->header.w + 1) >> 1) * y + x;\n        buf_u8[px]  = buf_u8[px] & ~(0xF << (4 - bit));\n        buf_u8[px]  = buf_u8[px] | ((opa & 0xF) << (4 - bit));\n    }\n    else if(dsc->header.cf == LV_IMG_CF_ALPHA_8BIT) {\n        uint32_t px = dsc->header.w * y + x;\n        buf_u8[px]  = opa;\n    }\n}"}, "lv_img_buf_set_px_color": {"type": "Function", "def": "void lv_img_buf_set_px_color(lv_img_dsc_t * dsc, lv_coord_t x, lv_coord_t y, lv_color_t c)", "sline": 240, "body": "{\n    uint8_t * buf_u8 = (uint8_t *)dsc->data;\n\n    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {\n        uint8_t px_size = lv_img_cf_get_px_size(dsc->header.cf) >> 3;\n        uint32_t px     = dsc->header.w * y * px_size + x * px_size;\n        lv_memcpy_small(&buf_u8[px], &c, px_size);\n    }\n    else if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA) {\n        uint8_t px_size = lv_img_cf_get_px_size(dsc->header.cf) >> 3;\n        uint32_t px     = dsc->header.w * y * px_size + x * px_size;\n        lv_memcpy_small(&buf_u8[px], &c, px_size - 1); /*-1 to not overwrite the alpha value*/\n    }\n    else if(dsc->header.cf == LV_IMG_CF_INDEXED_1BIT) {\n        buf_u8 += sizeof(lv_color32_t) * 2; /*Skip the palette*/\n\n        uint8_t bit = x & 0x7;\n        x           = x >> 3;\n\n        /*Get the current pixel.\n         *dsc->header.w + 7 means rounding up to 8 because the lines are byte aligned\n         *so the possible real width are 8 ,16, 24 ...*/\n        uint32_t px = ((dsc->header.w + 7) >> 3) * y + x;\n        buf_u8[px]  = buf_u8[px] & ~(1 << (7 - bit));\n        buf_u8[px]  = buf_u8[px] | ((c.full & 0x1) << (7 - bit));\n    }\n    else if(dsc->header.cf == LV_IMG_CF_INDEXED_2BIT) {\n        buf_u8 += sizeof(lv_color32_t) * 4; /*Skip the palette*/\n        uint8_t bit = (x & 0x3) * 2;\n        x           = x >> 2;\n\n        /*Get the current pixel.\n         *dsc->header.w + 3 means rounding up to 4 because the lines are byte aligned\n         *so the possible real width are 4, 8 ,12 ...*/\n        uint32_t px = ((dsc->header.w + 3) >> 2) * y + x;\n\n        buf_u8[px] = buf_u8[px] & ~(3 << (6 - bit));\n        buf_u8[px] = buf_u8[px] | ((c.full & 0x3) << (6 - bit));\n    }\n    else if(dsc->header.cf == LV_IMG_CF_INDEXED_4BIT) {\n        buf_u8 += sizeof(lv_color32_t) * 16; /*Skip the palette*/\n        uint8_t bit = (x & 0x1) * 4;\n        x           = x >> 1;\n\n        /*Get the current pixel.\n         *dsc->header.w + 1 means rounding up to 2 because the lines are byte aligned\n         *so the possible real width are 2 ,4, 6 ...*/\n        uint32_t px = ((dsc->header.w + 1) >> 1) * y + x;\n        buf_u8[px]  = buf_u8[px] & ~(0xF << (4 - bit));\n        buf_u8[px]  = buf_u8[px] | ((c.full & 0xF) << (4 - bit));\n    }\n    else if(dsc->header.cf == LV_IMG_CF_INDEXED_8BIT) {\n        buf_u8 += sizeof(lv_color32_t) * 256; /*Skip the palette*/\n        uint32_t px = dsc->header.w * y + x;\n        buf_u8[px]  = c.full;\n    }\n}"}, "lv_img_buf_set_palette": {"type": "Function", "def": "void lv_img_buf_set_palette(lv_img_dsc_t * dsc, uint8_t id, lv_color_t c)", "sline": 309, "body": "{\n    if((dsc->header.cf == LV_IMG_CF_ALPHA_1BIT && id > 1) || (dsc->header.cf == LV_IMG_CF_ALPHA_2BIT && id > 3) ||\n       (dsc->header.cf == LV_IMG_CF_ALPHA_4BIT && id > 15) || (dsc->header.cf == LV_IMG_CF_ALPHA_8BIT)) {\n        LV_LOG_WARN(\"lv_img_buf_set_px_alpha: invalid 'id'\");\n        return;\n    }\n\n    lv_color32_t c32;\n    c32.full      = lv_color_to32(c);\n    uint8_t * buf = (uint8_t *)dsc->data;\n    lv_memcpy_small(&buf[id * sizeof(c32)], &c32, sizeof(c32));\n}"}, "lv_img_buf_alloc": {"type": "Function", "def": "lv_img_dsc_t * lv_img_buf_alloc(lv_coord_t w, lv_coord_t h, lv_img_cf_t cf)", "sline": 330, "body": "{\n    /*Allocate image descriptor*/\n    lv_img_dsc_t * dsc = lv_mem_alloc(sizeof(lv_img_dsc_t));\n    if(dsc == NULL)\n        return NULL;\n\n    lv_memset_00(dsc, sizeof(lv_img_dsc_t));\n\n    /*Get image data size*/\n    dsc->data_size = lv_img_buf_get_img_size(w, h, cf);\n    if(dsc->data_size == 0) {\n        lv_mem_free(dsc);\n        return NULL;\n    }\n\n    /*Allocate raw buffer*/\n    dsc->data = lv_mem_alloc(dsc->data_size);\n    if(dsc->data == NULL) {\n        lv_mem_free(dsc);\n        return NULL;\n    }\n    lv_memset_00((uint8_t *)dsc->data, dsc->data_size);\n\n    /*Fill in header*/\n    dsc->header.always_zero = 0;\n    dsc->header.w = w;\n    dsc->header.h = h;\n    dsc->header.cf = cf;\n    return dsc;\n}"}, "lv_img_buf_free": {"type": "Function", "def": "void lv_img_buf_free(lv_img_dsc_t * dsc)", "sline": 366, "body": "{\n    if(dsc != NULL) {\n        if(dsc->data != NULL)\n            lv_mem_free((void *)dsc->data);\n\n        lv_mem_free(dsc);\n    }\n}"}, "lv_img_buf_get_img_size": {"type": "Function", "def": "uint32_t lv_img_buf_get_img_size(lv_coord_t w, lv_coord_t h, lv_img_cf_t cf)", "sline": 383, "body": "{\n    switch(cf) {\n        case LV_IMG_CF_TRUE_COLOR:\n            return LV_IMG_BUF_SIZE_TRUE_COLOR(w, h);\n        case LV_IMG_CF_TRUE_COLOR_ALPHA:\n            return LV_IMG_BUF_SIZE_TRUE_COLOR_ALPHA(w, h);\n        case LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED:\n            return LV_IMG_BUF_SIZE_TRUE_COLOR_CHROMA_KEYED(w, h);\n        case LV_IMG_CF_ALPHA_1BIT:\n            return LV_IMG_BUF_SIZE_ALPHA_1BIT(w, h);\n        case LV_IMG_CF_ALPHA_2BIT:\n            return LV_IMG_BUF_SIZE_ALPHA_2BIT(w, h);\n        case LV_IMG_CF_ALPHA_4BIT:\n            return LV_IMG_BUF_SIZE_ALPHA_4BIT(w, h);\n        case LV_IMG_CF_ALPHA_8BIT:\n            return LV_IMG_BUF_SIZE_ALPHA_8BIT(w, h);\n        case LV_IMG_CF_INDEXED_1BIT:\n            return LV_IMG_BUF_SIZE_INDEXED_1BIT(w, h);\n        case LV_IMG_CF_INDEXED_2BIT:\n            return LV_IMG_BUF_SIZE_INDEXED_2BIT(w, h);\n        case LV_IMG_CF_INDEXED_4BIT:\n            return LV_IMG_BUF_SIZE_INDEXED_4BIT(w, h);\n        case LV_IMG_CF_INDEXED_8BIT:\n            return LV_IMG_BUF_SIZE_INDEXED_8BIT(w, h);\n        default:\n            return 0;\n    }\n}"}, "_lv_img_buf_transform_init": {"type": "Function", "def": "void _lv_img_buf_transform_init(lv_img_transform_dsc_t * dsc)", "sline": 418, "body": "{\n    dsc->tmp.pivot_x_256 = dsc->cfg.pivot_x * 256;\n    dsc->tmp.pivot_y_256 = dsc->cfg.pivot_y * 256;\n\n    int32_t angle_low = dsc->cfg.angle / 10;\n    int32_t angle_high = angle_low + 1;\n    int32_t angle_rem = dsc->cfg.angle  - (angle_low * 10);\n\n    int32_t s1 = lv_trigo_sin(-angle_low);\n    int32_t s2 = lv_trigo_sin(-angle_high);\n\n    int32_t c1 = lv_trigo_sin(-angle_low + 90);\n    int32_t c2 = lv_trigo_sin(-angle_high + 90);\n\n    dsc->tmp.sinma = (s1 * (10 - angle_rem) + s2 * angle_rem) / 10;\n    dsc->tmp.cosma = (c1 * (10 - angle_rem) + c2 * angle_rem) / 10;\n\n    /*Use smaller value to avoid overflow*/\n    dsc->tmp.sinma = dsc->tmp.sinma >> (LV_TRIGO_SHIFT - _LV_TRANSFORM_TRIGO_SHIFT);\n    dsc->tmp.cosma = dsc->tmp.cosma >> (LV_TRIGO_SHIFT - _LV_TRANSFORM_TRIGO_SHIFT);\n\n    dsc->tmp.chroma_keyed = lv_img_cf_is_chroma_keyed(dsc->cfg.cf) ? 1 : 0;\n    dsc->tmp.has_alpha = lv_img_cf_has_alpha(dsc->cfg.cf) ? 1 : 0;\n    if(dsc->cfg.cf == LV_IMG_CF_TRUE_COLOR || dsc->cfg.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||\n       dsc->cfg.cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {\n        dsc->tmp.native_color = 1;\n    }\n    else {\n        dsc->tmp.native_color = 0;\n    }\n\n    dsc->tmp.img_dsc.data = dsc->cfg.src;\n    dsc->tmp.img_dsc.header.always_zero = 0;\n    dsc->tmp.img_dsc.header.cf = dsc->cfg.cf;\n    dsc->tmp.img_dsc.header.w = dsc->cfg.src_w;\n    dsc->tmp.img_dsc.header.h = dsc->cfg.src_h;\n\n    /*The inverse of the zoom will be sued during the transformation\n     * + dsc->cfg.zoom / 2 for rounding*/\n    dsc->tmp.zoom_inv = (((256 * 256) << _LV_ZOOM_INV_UPSCALE) + dsc->cfg.zoom / 2) / dsc->cfg.zoom;\n\n    dsc->res.opa = LV_OPA_COVER;\n    dsc->res.color = dsc->cfg.color;\n}"}, "_lv_img_buf_get_transformed_area": {"type": "Function", "def": "void _lv_img_buf_get_transformed_area(lv_area_t * res, lv_coord_t w, lv_coord_t h, int16_t angle, uint16_t zoom,\n                                      const lv_point_t * pivot)", "sline": 474, "body": "{\n#if LV_DRAW_COMPLEX\n    if(angle == 0 && zoom == LV_IMG_ZOOM_NONE) {\n        res->x1 = 0;\n        res->y1 = 0;\n        res->x2 = w - 1;\n        res->y2 = h - 1;\n        return;\n    }\n\n    res->x1 = (((int32_t)(-pivot->x) * zoom) >> 8) - 1;\n    res->y1 = (((int32_t)(-pivot->y) * zoom) >> 8) - 1;\n    res->x2 = (((int32_t)(w - pivot->x) * zoom) >> 8) + 2;\n    res->y2 = (((int32_t)(h - pivot->y) * zoom) >> 8) + 2;\n\n    if(angle == 0) {\n        res->x1 += pivot->x;\n        res->y1 += pivot->y;\n        res->x2 += pivot->x;\n        res->y2 += pivot->y;\n        return;\n    }\n\n    int32_t angle_low = angle / 10;\n    int32_t angle_high = angle_low + 1;\n    int32_t angle_rem = angle  - (angle_low * 10);\n\n    int32_t s1 = lv_trigo_sin(angle_low);\n    int32_t s2 = lv_trigo_sin(angle_high);\n\n    int32_t c1 = lv_trigo_sin(angle_low + 90);\n    int32_t c2 = lv_trigo_sin(angle_high + 90);\n\n    int32_t sinma = (s1 * (10 - angle_rem) + s2 * angle_rem) / 10;\n    int32_t cosma = (c1 * (10 - angle_rem) + c2 * angle_rem) / 10;\n\n    /*Use smaller value to avoid overflow*/\n    sinma = sinma >> (LV_TRIGO_SHIFT - _LV_TRANSFORM_TRIGO_SHIFT);\n    cosma = cosma >> (LV_TRIGO_SHIFT - _LV_TRANSFORM_TRIGO_SHIFT);\n\n    lv_point_t lt;\n    lv_point_t rt;\n    lv_point_t lb;\n    lv_point_t rb;\n\n    lv_coord_t xt;\n    lv_coord_t yt;\n\n    xt = res->x1;\n    yt = res->y1;\n    lt.x = ((cosma * xt - sinma * yt) >> _LV_TRANSFORM_TRIGO_SHIFT) + pivot->x;\n    lt.y = ((sinma * xt + cosma * yt) >> _LV_TRANSFORM_TRIGO_SHIFT) + pivot->y;\n\n    xt = res->x2;\n    yt = res->y1;\n    rt.x = ((cosma * xt - sinma * yt) >> _LV_TRANSFORM_TRIGO_SHIFT) + pivot->x;\n    rt.y = ((sinma * xt + cosma * yt) >> _LV_TRANSFORM_TRIGO_SHIFT) + pivot->y;\n\n    xt = res->x1;\n    yt = res->y2;\n    lb.x = ((cosma * xt - sinma * yt) >> _LV_TRANSFORM_TRIGO_SHIFT) + pivot->x;\n    lb.y = ((sinma * xt + cosma * yt) >> _LV_TRANSFORM_TRIGO_SHIFT) + pivot->y;\n\n    xt = res->x2;\n    yt = res->y2;\n    rb.x = ((cosma * xt - sinma * yt) >> _LV_TRANSFORM_TRIGO_SHIFT) + pivot->x;\n    rb.y = ((sinma * xt + cosma * yt) >> _LV_TRANSFORM_TRIGO_SHIFT) + pivot->y;\n\n    res->x1 = LV_MIN4(lb.x, lt.x, rb.x, rt.x);\n    res->x2 = LV_MAX4(lb.x, lt.x, rb.x, rt.x);\n    res->y1 = LV_MIN4(lb.y, lt.y, rb.y, rt.y);\n    res->y2 = LV_MAX4(lb.y, lt.y, rb.y, rt.y);\n#else\n    LV_UNUSED(angle);\n    LV_UNUSED(zoom);\n    LV_UNUSED(pivot);\n    res->x1 = 0;\n    res->y1 = 0;\n    res->x2 = w - 1;\n    res->y2 = h - 1;\n#endif\n}"}, "_lv_img_buf_transform": {"type": "Function", "def": "bool _lv_img_buf_transform(lv_img_transform_dsc_t * dsc, lv_coord_t x, lv_coord_t y)", "sline": 569, "body": "{\n    const uint8_t * src_u8 = (const uint8_t *)dsc->cfg.src;\n\n    /*Get the target point relative coordinates to the pivot*/\n    int32_t xt = x - dsc->cfg.pivot_x;\n    int32_t yt = y - dsc->cfg.pivot_y;\n\n    int32_t xs;\n    int32_t ys;\n    if(dsc->cfg.zoom == LV_IMG_ZOOM_NONE) {\n        /*Get the source pixel from the upscaled image*/\n        xs = ((dsc->tmp.cosma * xt - dsc->tmp.sinma * yt) >> (_LV_TRANSFORM_TRIGO_SHIFT - 8)) + dsc->tmp.pivot_x_256;\n        ys = ((dsc->tmp.sinma * xt + dsc->tmp.cosma * yt) >> (_LV_TRANSFORM_TRIGO_SHIFT - 8)) + dsc->tmp.pivot_y_256;\n    }\n    else if(dsc->cfg.angle == 0) {\n        xt = (int32_t)((int32_t)xt * dsc->tmp.zoom_inv) >> _LV_ZOOM_INV_UPSCALE;\n        yt = (int32_t)((int32_t)yt * dsc->tmp.zoom_inv) >> _LV_ZOOM_INV_UPSCALE;\n        xs = xt + dsc->tmp.pivot_x_256;\n        ys = yt + dsc->tmp.pivot_y_256;\n    }\n    else {\n        xt = (int32_t)((int32_t)xt * dsc->tmp.zoom_inv) >> _LV_ZOOM_INV_UPSCALE;\n        yt = (int32_t)((int32_t)yt * dsc->tmp.zoom_inv) >> _LV_ZOOM_INV_UPSCALE;\n        xs = ((dsc->tmp.cosma * xt - dsc->tmp.sinma * yt) >> (_LV_TRANSFORM_TRIGO_SHIFT)) + dsc->tmp.pivot_x_256;\n        ys = ((dsc->tmp.sinma * xt + dsc->tmp.cosma * yt) >> (_LV_TRANSFORM_TRIGO_SHIFT)) + dsc->tmp.pivot_y_256;\n    }\n\n    /*Get the integer part of the source pixel*/\n    int32_t xs_int = xs >> 8;\n    int32_t ys_int = ys >> 8;\n\n    if(xs_int >= dsc->cfg.src_w) return false;\n    else if(xs_int < 0) return false;\n\n    if(ys_int >= dsc->cfg.src_h) return false;\n    else if(ys_int < 0) return false;\n\n    uint8_t px_size;\n    uint32_t pxi;\n    if(dsc->tmp.native_color) {\n        if(dsc->tmp.has_alpha == 0) {\n            px_size = LV_COLOR_SIZE >> 3;\n\n            pxi     = dsc->cfg.src_w * ys_int * px_size + xs_int * px_size;\n            lv_memcpy_small(&dsc->res.color, &src_u8[pxi], px_size);\n        }\n        else {\n            px_size = LV_IMG_PX_SIZE_ALPHA_BYTE;\n            pxi     = dsc->cfg.src_w * ys_int * px_size + xs_int * px_size;\n            lv_memcpy_small(&dsc->res.color, &src_u8[pxi], px_size - 1);\n            dsc->res.opa = src_u8[pxi + px_size - 1];\n        }\n    }\n    else {\n        pxi = 0; /*unused*/\n        px_size = 0;    /*unused*/\n        dsc->res.color = lv_img_buf_get_px_color(&dsc->tmp.img_dsc, xs_int, ys_int, dsc->cfg.color);\n        dsc->res.opa = lv_img_buf_get_px_alpha(&dsc->tmp.img_dsc, xs_int, ys_int);\n    }\n\n    if(dsc->tmp.chroma_keyed) {\n        lv_color_t ct = LV_COLOR_CHROMA_KEY;\n        if(dsc->res.color.full == ct.full) return false;\n    }\n\n    if(dsc->cfg.antialias == false) return true;\n\n    dsc->tmp.xs = xs;\n    dsc->tmp.ys = ys;\n    dsc->tmp.xs_int = xs_int;\n    dsc->tmp.ys_int = ys_int;\n    dsc->tmp.pxi = pxi;\n    dsc->tmp.px_size = px_size;\n\n    bool ret;\n    ret = _lv_img_buf_transform_anti_alias(dsc);\n\n    return ret;\n}"}, "_lv_img_buf_transform_anti_alias": {"type": "Function", "def": "bool _lv_img_buf_transform_anti_alias(lv_img_transform_dsc_t * dsc)", "sline": 654, "body": "{\n    const uint8_t * src_u8 = dsc->cfg.src;\n\n    /*Get the fractional part of the source pixel*/\n    int xs_fract = dsc->tmp.xs & 0xff;\n    int ys_fract = dsc->tmp.ys & 0xff;\n    int32_t xn;      /*x neighbor*/\n    lv_opa_t xr; /*x mix ratio*/\n\n    if(xs_fract < 0x70) {\n        xn = - 1;\n        if(dsc->tmp.xs_int + xn < 0) xn = 0;\n        xr = xs_fract + 0x80;\n    }\n    else if(xs_fract > 0x90) {\n        xn =  1;\n        if(dsc->tmp.xs_int + xn >= dsc->cfg.src_w) xn = 0;\n        xr = (0xFF - xs_fract) + 0x80;\n    }\n    else {\n        xn = 0;\n        xr = 0xFF;\n    }\n\n    int32_t yn;      /*x neighbor*/\n    lv_opa_t yr; /*x mix ratio*/\n\n    if(ys_fract < 0x70) {\n        yn = - 1;\n        if(dsc->tmp.ys_int + yn < 0) yn = 0;\n\n        yr = ys_fract + 0x80;\n    }\n    else if(ys_fract > 0x90) {\n        yn =  1;\n        if(dsc->tmp.ys_int + yn >= dsc->cfg.src_h) yn = 0;\n\n        yr = (0xFF - ys_fract) + 0x80;\n    }\n    else {\n        yn = 0;\n        yr = 0xFF;\n    }\n\n    lv_color_t c00 = dsc->res.color;\n    lv_color_t c01;\n    lv_color_t c10;\n    lv_color_t c11;\n\n    lv_opa_t a00 = dsc->res.opa;\n    lv_opa_t a10 = 0;\n    lv_opa_t a01 = 0;\n    lv_opa_t a11 = 0;\n\n    if(dsc->tmp.native_color) {\n        lv_memcpy_small(&c01, &src_u8[dsc->tmp.pxi + dsc->tmp.px_size * xn], sizeof(lv_color_t));\n        lv_memcpy_small(&c10, &src_u8[dsc->tmp.pxi + dsc->cfg.src_w * dsc->tmp.px_size * yn], sizeof(lv_color_t));\n        lv_memcpy_small(&c11, &src_u8[dsc->tmp.pxi + dsc->cfg.src_w * dsc->tmp.px_size * yn + dsc->tmp.px_size * xn],\n                        sizeof(lv_color_t));\n        if(dsc->tmp.has_alpha) {\n            a10 = src_u8[dsc->tmp.pxi + dsc->tmp.px_size * xn + dsc->tmp.px_size - 1];\n            a01 = src_u8[dsc->tmp.pxi + dsc->cfg.src_w * dsc->tmp.px_size * yn + dsc->tmp.px_size - 1];\n            a11 = src_u8[dsc->tmp.pxi + dsc->cfg.src_w * dsc->tmp.px_size * yn + dsc->tmp.px_size * xn + dsc->tmp.px_size - 1];\n        }\n    }\n    else {\n        c01 = lv_img_buf_get_px_color(&dsc->tmp.img_dsc, dsc->tmp.xs_int + xn, dsc->tmp.ys_int, dsc->cfg.color);\n        c10 = lv_img_buf_get_px_color(&dsc->tmp.img_dsc, dsc->tmp.xs_int, dsc->tmp.ys_int + yn, dsc->cfg.color);\n        c11 = lv_img_buf_get_px_color(&dsc->tmp.img_dsc, dsc->tmp.xs_int + xn, dsc->tmp.ys_int + yn, dsc->cfg.color);\n\n        if(dsc->tmp.has_alpha) {\n            a10 = lv_img_buf_get_px_alpha(&dsc->tmp.img_dsc, dsc->tmp.xs_int + xn, dsc->tmp.ys_int);\n            a01 = lv_img_buf_get_px_alpha(&dsc->tmp.img_dsc, dsc->tmp.xs_int, dsc->tmp.ys_int + yn);\n            a11 = lv_img_buf_get_px_alpha(&dsc->tmp.img_dsc, dsc->tmp.xs_int + xn, dsc->tmp.ys_int + yn);\n        }\n    }\n\n    lv_opa_t xr0 = xr;\n    lv_opa_t xr1 = xr;\n    if(dsc->tmp.has_alpha) {\n        lv_opa_t a0 = (a00 * xr + (a10 * (255 - xr))) >> 8;\n        lv_opa_t a1 = (a01 * xr + (a11 * (255 - xr))) >> 8;\n        dsc->res.opa = (a0 * yr + (a1 * (255 - yr))) >> 8;\n\n        if(a0 <= LV_OPA_MIN && a1 <= LV_OPA_MIN) return false;\n        if(a0 <= LV_OPA_MIN) yr = LV_OPA_TRANSP;\n        if(a1 <= LV_OPA_MIN) yr = LV_OPA_COVER;\n        if(a00 <= LV_OPA_MIN) xr0 = LV_OPA_TRANSP;\n        if(a10 <= LV_OPA_MIN) xr0 = LV_OPA_COVER;\n        if(a01 <= LV_OPA_MIN) xr1 = LV_OPA_TRANSP;\n        if(a11 <= LV_OPA_MIN) xr1 = LV_OPA_COVER;\n    }\n    else {\n        xr0 = xr;\n        xr1 = xr;\n        dsc->res.opa = LV_OPA_COVER;\n    }\n\n    lv_color_t c0;\n    if(xr0 == LV_OPA_TRANSP) c0 = c01;\n    else if(xr0 == LV_OPA_COVER) c0 = c00;\n    else c0 = lv_color_mix(c00, c01, xr0);\n\n    lv_color_t c1;\n    if(xr1 == LV_OPA_TRANSP) c1 = c11;\n    else if(xr1 == LV_OPA_COVER) c1 = c10;\n    else c1 = lv_color_mix(c10, c11, xr1);\n\n    if(yr == LV_OPA_TRANSP) dsc->res.color = c1;\n    else if(yr == LV_OPA_COVER) dsc->res.color = c0;\n    else dsc->res.color = lv_color_mix(c0, c1, yr);\n\n    return true;\n}"}, "carbit_updater/lvgl/src/draw/lv_img_buf.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_img_buf.c"}}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_draw_img.c": {"lv_conf_internal": {"type": "Variable", "def": "#include ../../lv_conf_internal.h", "sline": 10}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_draw_img.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_draw_img.c"}}, "carbit_updater/lvgl/src/extra/libs/png/lodepng.c": {"lodepng": {"type": "Variable", "def": "#include lodepng.h", "sline": 31, "include": ["carbit_updater/lvgl/src/extra/libs/png/lodepng.h", null]}, "carbit_updater/lvgl/src/extra/libs/png/lodepng.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/png/lodepng.c"}}, "carbit_updater/lv_drivers/indev/AD_touch.c": {"AD_touch": {"type": "Variable", "def": "#include AD_touch.h", "sline": 6, "include": ["carbit_updater/lv_drivers/indev/AD_touch.h", null]}, "carbit_updater/lv_drivers/indev/AD_touch.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/indev/AD_touch.c"}}, "carbit_updater/lvgl/src/extra/widgets/animimg/lv_animimg.c": {"lv_animimg": {"type": "Variable", "def": "#include lv_animimg.h", "sline": 9, "include": ["carbit_updater/lvgl/src/extra/widgets/animimg/lv_animimg.h", null]}, "lv_assert": {"type": "Variable", "def": "#include ../../../misc/lv_assert.h", "sline": 17}, "lv_img_decoder": {"type": "Variable", "def": "#include ../../../draw/lv_img_decoder.h", "sline": 18}, "lv_fs": {"type": "Variable", "def": "#include ../../../misc/lv_fs.h", "sline": 19}, "lv_txt": {"type": "Variable", "def": "#include ../../../misc/lv_txt.h", "sline": 20}, "lv_math": {"type": "Variable", "def": "#include ../../../misc/lv_math.h", "sline": 21}, "lv_log": {"type": "Variable", "def": "#include ../../../misc/lv_log.h", "sline": 22}, "lv_anim": {"type": "Variable", "def": "#include ../../../misc/lv_anim.h", "sline": 23}, "index_change": {"type": "Function", "def": "static void index_change(lv_obj_t * obj, int32_t index)", "sline": 128, "body": "{\n    lv_coord_t idx;\n    lv_animimg_t * animimg = (lv_animimg_t *)obj;\n\n    idx = index % animimg->pic_count;\n\n    lv_img_set_src(obj, animimg->dsc[idx]);\n}"}, "lv_animimg_constructor": {"type": "Function", "def": "static void lv_animimg_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 110, "body": "{\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    LV_UNUSED(class_p);\n    lv_animimg_t * animimg = (lv_animimg_t *)obj;\n\n    animimg->dsc = NULL;\n    animimg->pic_count = -1;\n    //initial animation\n    lv_anim_init(&animimg->anim);\n    lv_anim_set_var(&animimg->anim, obj);\n    lv_anim_set_time(&animimg->anim, 30);\n    lv_anim_set_exec_cb(&animimg->anim, (lv_anim_exec_xcb_t)index_change);\n    lv_anim_set_values(&animimg->anim, 0, 1);\n    lv_anim_set_repeat_count(&animimg->anim, LV_ANIM_REPEAT_INFINITE);\n}"}, "lv_animimg_class": {"type": "Variable", "def": "const lv_obj_class_t lv_animimg_class = {\n    .constructor_cb = lv_animimg_constructor,\n    .instance_size = sizeof(lv_animimg_t),\n    .base_class = &lv_img_class\n}", "sline": 45}, "lv_animimg_create": {"type": "Function", "def": "lv_obj_t * lv_animimg_create(lv_obj_t * parent)", "sline": 59, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_animimg_class, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_animimg_set_src": {"type": "Function", "def": "void lv_animimg_set_src(lv_obj_t * obj,  lv_img_dsc_t * dsc[], uint8_t num)", "sline": 67, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_animimg_t * animimg = (lv_animimg_t *)obj;\n    animimg->dsc = dsc;\n    animimg->pic_count = num;\n    lv_anim_set_values(&animimg->anim, 0, num);\n}"}, "lv_animimg_start": {"type": "Function", "def": "void lv_animimg_start(lv_obj_t * obj)", "sline": 76, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_animimg_t * animimg = (lv_animimg_t *)obj;\n    lv_anim_start(&animimg->anim);\n}"}, "lv_animimg_set_duration": {"type": "Function", "def": "void lv_animimg_set_duration(lv_obj_t * obj, uint32_t duration)", "sline": 87, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_animimg_t * animimg = (lv_animimg_t *)obj;\n    lv_anim_set_time(&animimg->anim, duration);\n    lv_anim_set_playback_delay(&animimg->anim, duration);\n}"}, "lv_animimg_set_repeat_count": {"type": "Function", "def": "void lv_animimg_set_repeat_count(lv_obj_t * obj, uint16_t count)", "sline": 95, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_animimg_t * animimg = (lv_animimg_t *)obj;\n    lv_anim_set_repeat_count(&animimg->anim, count);\n}"}, "carbit_updater/lvgl/src/extra/widgets/animimg/lv_animimg.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/animimg/lv_animimg.c"}}, "carbit_updater/lvgl/src/extra/layouts/grid/lv_grid.c": {"lv_layouts": {"type": "Variable", "def": "#include ../lv_layouts.h", "sline": 9}, "item_repos_hint_t.col": {"type": "Variable", "def": "uint32_t col", "sline": 27, "in_struct": "item_repos_hint_t"}, "item_repos_hint_t.row": {"type": "Variable", "def": "uint32_t row", "sline": 28, "in_struct": "item_repos_hint_t"}, "item_repos_hint_t.grid_abs": {"type": "Variable", "def": "lv_point_t grid_abs", "sline": 29, "in_struct": "item_repos_hint_t"}, "item_repos_hint_t": {"type": "Variable", "def": "typedef struct {\n    uint32_t col;\n    uint32_t row;\n    lv_point_t grid_abs;\n} item_repos_hint_t", "sline": 30, "docstring": "/**********************"}, "_lv_grid_calc_t.x": {"type": "Variable", "def": "lv_coord_t * x", "sline": 33, "in_struct": "_lv_grid_calc_t"}, "_lv_grid_calc_t.y": {"type": "Variable", "def": "lv_coord_t * y", "sline": 34, "in_struct": "_lv_grid_calc_t"}, "_lv_grid_calc_t.w": {"type": "Variable", "def": "lv_coord_t * w", "sline": 35, "in_struct": "_lv_grid_calc_t"}, "_lv_grid_calc_t.h": {"type": "Variable", "def": "lv_coord_t * h", "sline": 36, "in_struct": "_lv_grid_calc_t"}, "_lv_grid_calc_t.col_num": {"type": "Variable", "def": "uint32_t col_num", "sline": 37, "in_struct": "_lv_grid_calc_t"}, "_lv_grid_calc_t.row_num": {"type": "Variable", "def": "uint32_t row_num", "sline": 38, "in_struct": "_lv_grid_calc_t"}, "_lv_grid_calc_t.grid_w": {"type": "Variable", "def": "lv_coord_t grid_w", "sline": 39, "in_struct": "_lv_grid_calc_t"}, "_lv_grid_calc_t.grid_h": {"type": "Variable", "def": "lv_coord_t grid_h", "sline": 40, "in_struct": "_lv_grid_calc_t"}, "_lv_grid_calc_t": {"type": "Variable", "def": "typedef struct {\n    lv_coord_t * x;\n    lv_coord_t * y;\n    lv_coord_t * w;\n    lv_coord_t * h;\n    uint32_t col_num;\n    uint32_t row_num;\n    lv_coord_t grid_w;\n    lv_coord_t grid_h;\n} _lv_grid_calc_t", "sline": 41}, "grid_update": {"type": "Function", "def": "static void grid_update(lv_obj_t * cont, void * user_data)", "sline": 344, "body": "{\n    LV_LOG_INFO(\"update %p container\", (void *)cont);\n    LV_UNUSED(user_data);\n\n    const lv_coord_t * col_templ = get_col_dsc(cont);\n    const lv_coord_t * row_templ = get_row_dsc(cont);\n    if(col_templ == NULL || row_templ == NULL) return;\n\n    _lv_grid_calc_t c;\n    calc(cont, &c);\n\n    item_repos_hint_t hint;\n    lv_memset_00(&hint, sizeof(hint));\n\n    /*Calculate the grids absolute x and y coordinates.\n     *It will be used as helper during item repositioning to avoid calculating this value for every children*/\n    lv_coord_t border_widt = lv_obj_get_style_border_width(cont, LV_PART_MAIN);\n    lv_coord_t pad_left = lv_obj_get_style_pad_left(cont, LV_PART_MAIN) + border_widt;\n    lv_coord_t pad_top = lv_obj_get_style_pad_top(cont, LV_PART_MAIN) + border_widt;\n    hint.grid_abs.x = pad_left + cont->coords.x1 - lv_obj_get_scroll_x(cont);\n    hint.grid_abs.y = pad_top + cont->coords.y1 - lv_obj_get_scroll_y(cont);\n\n    uint32_t i;\n    for(i = 0; i < cont->spec_attr->child_cnt; i++) {\n        lv_obj_t * item = cont->spec_attr->children[i];\n        item_repos(item, &c, &hint);\n    }\n    calc_free(&c);\n\n    lv_coord_t w_set = lv_obj_get_style_width(cont, LV_PART_MAIN);\n    lv_coord_t h_set = lv_obj_get_style_height(cont, LV_PART_MAIN);\n    if(w_set == LV_SIZE_CONTENT || h_set == LV_SIZE_CONTENT) {\n        lv_obj_refr_size(cont);\n    }\n\n    lv_event_send(cont, LV_EVENT_LAYOUT_CHANGED, NULL);\n\n    LV_TRACE_LAYOUT(\"finished\");\n}"}, "calc": {"type": "Function", "def": "static void calc(lv_obj_t * cont, _lv_grid_calc_t * calc_out)", "sline": 391, "body": "{\n    if(lv_obj_get_child(cont, 0) == NULL) {\n        lv_memset_00(calc_out, sizeof(_lv_grid_calc_t));\n        return;\n    }\n\n    calc_rows(cont, calc_out);\n    calc_cols(cont, calc_out);\n\n    lv_coord_t col_gap = lv_obj_get_style_pad_column(cont, LV_PART_MAIN);\n    lv_coord_t row_gap = lv_obj_get_style_pad_row(cont, LV_PART_MAIN);\n\n    bool rev = lv_obj_get_style_base_dir(cont, LV_PART_MAIN) == LV_BASE_DIR_RTL ? true : false;\n\n    lv_coord_t w_set = lv_obj_get_style_width(cont, LV_PART_MAIN);\n    lv_coord_t h_set = lv_obj_get_style_height(cont, LV_PART_MAIN);\n    bool auto_w = (w_set == LV_SIZE_CONTENT && !cont->w_layout) ? true : false;\n    lv_coord_t cont_w = lv_obj_get_content_width(cont);\n    calc_out->grid_w = grid_align(cont_w, auto_w, get_grid_col_align(cont), col_gap, calc_out->col_num, calc_out->w,\n                                  calc_out->x, rev);\n\n    bool auto_h = (h_set == LV_SIZE_CONTENT && !cont->h_layout) ? true : false;\n    lv_coord_t cont_h = lv_obj_get_content_height(cont);\n    calc_out->grid_h = grid_align(cont_h, auto_h, get_grid_row_align(cont), row_gap, calc_out->row_num, calc_out->h,\n                                  calc_out->y, false);\n\n    LV_ASSERT_MEM_INTEGRITY();\n}"}, "calc_free": {"type": "Function", "def": "static void calc_free(_lv_grid_calc_t * calc)", "sline": 425, "body": "{\n    lv_mem_buf_release(calc->x);\n    lv_mem_buf_release(calc->y);\n    lv_mem_buf_release(calc->w);\n    lv_mem_buf_release(calc->h);\n}"}, "calc_cols": {"type": "Function", "def": "static void calc_cols(lv_obj_t * cont, _lv_grid_calc_t * c)", "sline": 433, "body": "{\n    const lv_coord_t * col_templ = get_col_dsc(cont);\n    lv_coord_t cont_w = lv_obj_get_content_width(cont);\n\n    c->col_num = count_tracks(col_templ);\n    c->x = lv_mem_buf_get(sizeof(lv_coord_t) * c->col_num);\n    c->w = lv_mem_buf_get(sizeof(lv_coord_t) * c->col_num);\n\n    /*Set sizes for CONTENT cells*/\n    uint32_t i;\n    for(i = 0; i < c->col_num; i++) {\n        lv_coord_t size = LV_COORD_MIN;\n        if(IS_CONTENT(col_templ[i])) {\n            /*Check the size of children of this cell*/\n            uint32_t ci;\n            for(ci = 0; ci < lv_obj_get_child_cnt(cont); ci++) {\n                lv_obj_t * item = lv_obj_get_child(cont, ci);\n                if(lv_obj_has_flag_any(item, LV_OBJ_FLAG_IGNORE_LAYOUT | LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;\n                uint32_t col_span = get_col_span(item);\n                if(col_span != 1) continue;\n\n                uint32_t col_pos = get_col_pos(item);\n                if(col_pos != i) continue;\n\n                size = LV_MAX(size, lv_obj_get_width(item));\n            }\n            if(size >= 0) c->w[i] = size;\n            else c->w[i] = 0;\n        }\n    }\n\n    uint32_t col_fr_cnt = 0;\n    lv_coord_t grid_w = 0;\n\n    for(i = 0; i < c->col_num; i++) {\n        lv_coord_t x = col_templ[i];\n        if(IS_FR(x)) {\n            col_fr_cnt += GET_FR(x);\n        }\n        else if(IS_CONTENT(x)) {\n            grid_w += c->w[i];\n        }\n        else {\n            c->w[i] = x;\n            grid_w += x;\n        }\n    }\n\n    lv_coord_t col_gap = lv_obj_get_style_pad_column(cont, LV_PART_MAIN);\n    cont_w -= col_gap * (c->col_num - 1);\n    lv_coord_t free_w = cont_w - grid_w;\n    if(free_w < 0) free_w = 0;\n\n    int32_t last_fr_i = -1;\n    int32_t last_fr_x = 0;\n    for(i = 0; i < c->col_num; i++) {\n        lv_coord_t x = col_templ[i];\n        if(IS_FR(x)) {\n            lv_coord_t f = GET_FR(x);\n            c->w[i] = (free_w * f) / col_fr_cnt;\n            last_fr_i = i;\n            last_fr_x = f;\n        }\n    }\n\n    /*To avoid rounding errors set the last FR track to the remaining size */\n    if(last_fr_i >= 0) {\n        c->w[last_fr_i] = free_w - ((free_w * (col_fr_cnt - last_fr_x)) / col_fr_cnt);\n    }\n}"}, "calc_rows": {"type": "Function", "def": "static void calc_rows(lv_obj_t * cont, _lv_grid_calc_t * c)", "sline": 505, "body": "{\n    uint32_t i;\n    const lv_coord_t * row_templ = get_row_dsc(cont);\n    c->row_num = count_tracks(row_templ);\n    c->y = lv_mem_buf_get(sizeof(lv_coord_t) * c->row_num);\n    c->h = lv_mem_buf_get(sizeof(lv_coord_t) * c->row_num);\n    /*Set sizes for CONTENT cells*/\n    for(i = 0; i < c->row_num; i++) {\n        lv_coord_t size = LV_COORD_MIN;\n        if(IS_CONTENT(row_templ[i])) {\n            /*Check the size of children of this cell*/\n            uint32_t ci;\n            for(ci = 0; ci < lv_obj_get_child_cnt(cont); ci++) {\n                lv_obj_t * item = lv_obj_get_child(cont, ci);\n                if(lv_obj_has_flag_any(item, LV_OBJ_FLAG_IGNORE_LAYOUT | LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;\n                uint32_t row_span = get_row_span(item);\n                if(row_span != 1) continue;\n\n                uint32_t row_pos = get_row_pos(item);\n                if(row_pos != i) continue;\n\n                size = LV_MAX(size, lv_obj_get_height(item));\n            }\n            if(size >= 0) c->h[i] = size;\n            else c->h[i] = 0;\n        }\n    }\n\n    uint32_t row_fr_cnt = 0;\n    lv_coord_t grid_h = 0;\n\n    for(i = 0; i < c->row_num; i++) {\n        lv_coord_t x = row_templ[i];\n        if(IS_FR(x)) {\n            row_fr_cnt += GET_FR(x);\n        }\n        else if(IS_CONTENT(x)) {\n            grid_h += c->h[i];\n        }\n        else {\n            c->h[i] = x;\n            grid_h += x;\n        }\n    }\n\n\n    lv_coord_t row_gap = lv_obj_get_style_pad_row(cont, LV_PART_MAIN);\n    lv_coord_t cont_h = lv_obj_get_content_height(cont) - row_gap * (c->row_num - 1);\n    lv_coord_t free_h = cont_h - grid_h;\n    if(free_h < 0) free_h = 0;\n\n    int32_t last_fr_i = -1;\n    int32_t last_fr_x = 0;\n    for(i = 0; i < c->row_num; i++) {\n        lv_coord_t x = row_templ[i];\n        if(IS_FR(x)) {\n            lv_coord_t f = GET_FR(x);\n            c->h[i] = (free_h * f) / row_fr_cnt;\n        }\n    }\n\n    /*To avoid rounding errors set the last FR track to the remaining size */\n    if(last_fr_i >= 0) {\n        c->h[last_fr_i] = free_h - ((free_h * (row_fr_cnt - last_fr_x)) / row_fr_cnt);\n    }\n}"}, "item_repos": {"type": "Function", "def": "static void item_repos(lv_obj_t * item, _lv_grid_calc_t * c, item_repos_hint_t * hint)", "sline": 580, "body": "{\n    if(lv_obj_has_flag_any(item, LV_OBJ_FLAG_IGNORE_LAYOUT | LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) return;\n    uint32_t col_span = get_col_span(item);\n    uint32_t row_span = get_row_span(item);\n    if(row_span == 0 || col_span == 0) return;\n\n    uint32_t col_pos = get_col_pos(item);\n    uint32_t row_pos = get_row_pos(item);\n    lv_grid_align_t col_align = get_cell_col_align(item);\n    lv_grid_align_t row_align = get_cell_row_align(item);\n\n\n    lv_coord_t col_x1 = c->x[col_pos];\n    lv_coord_t col_x2 = c->x[col_pos + col_span - 1] + c->w[col_pos + col_span - 1];\n    lv_coord_t col_w = col_x2 - col_x1;\n\n    lv_coord_t row_y1 = c->y[row_pos];\n    lv_coord_t row_y2 = c->y[row_pos + row_span - 1] + c->h[row_pos + row_span - 1];\n    lv_coord_t row_h = row_y2 - row_y1;\n\n\n    /*If the item has RTL base dir switch start and end*/\n    if(lv_obj_get_style_base_dir(item, LV_PART_MAIN) == LV_BASE_DIR_RTL) {\n        if(col_align == LV_GRID_ALIGN_START) col_align = LV_GRID_ALIGN_END;\n        else if(col_align == LV_GRID_ALIGN_END) col_align = LV_GRID_ALIGN_START;\n    }\n\n    lv_coord_t x;\n    lv_coord_t y;\n    lv_coord_t item_w = lv_area_get_width(&item->coords);\n    lv_coord_t item_h = lv_area_get_height(&item->coords);\n\n    switch(col_align) {\n        default:\n        case LV_GRID_ALIGN_START:\n            x = c->x[col_pos];\n            item->w_layout = 0;\n            break;\n        case LV_GRID_ALIGN_STRETCH:\n            x = c->x[col_pos];\n            item_w = col_w;\n            item->w_layout = 1;\n            break;\n        case LV_GRID_ALIGN_CENTER:\n            x = c->x[col_pos] + (col_w - item_w) / 2;\n            item->w_layout = 0;\n            break;\n        case LV_GRID_ALIGN_END:\n            x = c->x[col_pos] + col_w - lv_obj_get_width(item);\n            item->w_layout = 0;\n            break;\n    }\n\n    switch(row_align) {\n        default:\n        case LV_GRID_ALIGN_START:\n            y = c->y[row_pos];\n            item->h_layout = 0;\n            break;\n        case LV_GRID_ALIGN_STRETCH:\n            y = c->y[row_pos];\n            item_h = row_h;\n            item->h_layout = 1;\n            break;\n        case LV_GRID_ALIGN_CENTER:\n            y = c->y[row_pos] + (row_h - item_h) / 2;\n            item->h_layout = 0;\n            break;\n        case LV_GRID_ALIGN_END:\n            y = c->y[row_pos] + row_h - lv_obj_get_height(item);\n            item->h_layout = 0;\n            break;\n    }\n\n    /*Set a new size if required*/\n    if(lv_obj_get_width(item) != item_w || lv_obj_get_height(item) != item_h) {\n        lv_area_t old_coords;\n        lv_area_copy(&old_coords, &item->coords);\n        lv_obj_invalidate(item);\n        lv_area_set_width(&item->coords, item_w);\n        lv_area_set_height(&item->coords, item_h);\n        lv_obj_invalidate(item);\n        lv_event_send(item, LV_EVENT_SIZE_CHANGED, &old_coords);\n        lv_event_send(lv_obj_get_parent(item), LV_EVENT_CHILD_CHANGED, item);\n\n    }\n\n    /*Handle percentage value of translate*/\n    lv_coord_t tr_x = lv_obj_get_style_translate_x(item, LV_PART_MAIN);\n    lv_coord_t tr_y = lv_obj_get_style_translate_y(item, LV_PART_MAIN);\n    lv_coord_t w = lv_obj_get_width(item);\n    lv_coord_t h = lv_obj_get_height(item);\n    if(LV_COORD_IS_PCT(tr_x)) tr_x = (w * LV_COORD_GET_PCT(tr_x)) / 100;\n    if(LV_COORD_IS_PCT(tr_y)) tr_y = (h * LV_COORD_GET_PCT(tr_y)) / 100;\n\n    x += tr_x;\n    y += tr_y;\n\n    lv_coord_t diff_x = hint->grid_abs.x + x - item->coords.x1;\n    lv_coord_t diff_y = hint->grid_abs.y + y - item->coords.y1;\n    if(diff_x || diff_y) {\n        lv_obj_invalidate(item);\n        item->coords.x1 += diff_x;\n        item->coords.x2 += diff_x;\n        item->coords.y1 += diff_y;\n        item->coords.y2 += diff_y;\n        lv_obj_invalidate(item);\n        lv_obj_move_children_by(item, diff_x, diff_y, true);\n    }\n}"}, "grid_align": {"type": "Function", "def": "static lv_coord_t grid_align(lv_coord_t cont_size,  bool auto_size, uint8_t align, lv_coord_t gap, uint32_t track_num,\n                             lv_coord_t * size_array, lv_coord_t * pos_array, bool reverse)", "sline": 704, "body": "{\n    lv_coord_t grid_size = 0;\n    uint32_t i;\n\n    if(auto_size) {\n        pos_array[0] = 0;\n    }\n    else {\n        /*With spaced alignment gap will be calculated from the remaining space*/\n        if(align == LV_GRID_ALIGN_SPACE_AROUND || align == LV_GRID_ALIGN_SPACE_BETWEEN || align == LV_GRID_ALIGN_SPACE_EVENLY) {\n            gap = 0;\n            if(track_num == 1) align = LV_GRID_ALIGN_CENTER;\n        }\n\n        /*Get the full grid size with gap*/\n        for(i = 0; i < track_num; i++) {\n            grid_size += size_array[i] + gap;\n        }\n        grid_size -= gap;\n\n        /*Calculate the position of the first item and set gap is necessary*/\n        switch(align) {\n            case LV_GRID_ALIGN_START:\n                pos_array[0] = 0;\n                break;\n            case LV_GRID_ALIGN_CENTER:\n                pos_array[0] = (cont_size - grid_size) / 2;\n                break;\n            case LV_GRID_ALIGN_END:\n                pos_array[0] = cont_size - grid_size;\n                break;\n            case LV_GRID_ALIGN_SPACE_BETWEEN:\n                pos_array[0] = 0;\n                gap = (lv_coord_t)(cont_size - grid_size) / (lv_coord_t)(track_num - 1);\n                break;\n            case LV_GRID_ALIGN_SPACE_AROUND:\n                gap = (lv_coord_t)(cont_size - grid_size) / (lv_coord_t)(track_num);\n                pos_array[0] = gap / 2;\n                break;\n            case LV_GRID_ALIGN_SPACE_EVENLY:\n                gap = (lv_coord_t)(cont_size - grid_size) / (lv_coord_t)(track_num + 1);\n                pos_array[0] = gap;\n                break;\n\n        }\n    }\n\n    /*Set the position of all tracks from the start position, gaps and track sizes*/\n    for(i = 0; i < track_num - 1; i++) {\n        pos_array[i + 1] = pos_array[i] + size_array[i] + gap;\n    }\n\n    lv_coord_t total_gird_size = pos_array[track_num - 1] + size_array[track_num - 1] - pos_array[0];\n\n    if(reverse) {\n        for(i = 0; i < track_num; i++) {\n            pos_array[i] = cont_size - pos_array[i] - size_array[i];\n        }\n\n    }\n\n    /*Return the full size of the grid*/\n    return total_gird_size;\n}"}, "count_tracks": {"type": "Function", "def": "static uint32_t count_tracks(const lv_coord_t * templ)", "sline": 771, "body": "{\n    uint32_t i;\n    for(i = 0; templ[i] != LV_GRID_TEMPLATE_LAST; i++);\n\n    return i;\n}"}, "get_col_dsc": {"type": "Function", "def": "static inline const lv_coord_t * get_col_dsc(lv_obj_t * obj)", "sline": 61, "body": "{\n    return lv_obj_get_style_grid_column_dsc_array(obj, 0);\n}"}, "get_row_dsc": {"type": "Function", "def": "static inline const lv_coord_t * get_row_dsc(lv_obj_t * obj)", "sline": 65, "body": "{\n    return lv_obj_get_style_grid_row_dsc_array(obj, 0);\n}"}, "get_col_pos": {"type": "Function", "def": "static inline uint8_t get_col_pos(lv_obj_t * obj)", "sline": 69, "body": "{\n    return lv_obj_get_style_grid_cell_column_pos(obj, 0);\n}"}, "get_row_pos": {"type": "Function", "def": "static inline uint8_t get_row_pos(lv_obj_t * obj)", "sline": 73, "body": "{\n    return lv_obj_get_style_grid_cell_row_pos(obj, 0);\n}"}, "get_col_span": {"type": "Function", "def": "static inline uint8_t get_col_span(lv_obj_t * obj)", "sline": 77, "body": "{\n    return lv_obj_get_style_grid_cell_column_span(obj, 0);\n}"}, "get_row_span": {"type": "Function", "def": "static inline uint8_t get_row_span(lv_obj_t * obj)", "sline": 81, "body": "{\n    return lv_obj_get_style_grid_cell_row_span(obj, 0);\n}"}, "get_cell_col_align": {"type": "Function", "def": "static inline uint8_t get_cell_col_align(lv_obj_t * obj)", "sline": 85, "body": "{\n    return lv_obj_get_style_grid_cell_x_align(obj, 0);\n}"}, "get_cell_row_align": {"type": "Function", "def": "static inline uint8_t get_cell_row_align(lv_obj_t * obj)", "sline": 89, "body": "{\n    return lv_obj_get_style_grid_cell_y_align(obj, 0);\n}"}, "get_grid_col_align": {"type": "Function", "def": "static inline uint8_t get_grid_col_align(lv_obj_t * obj)", "sline": 93, "body": "{\n    return lv_obj_get_style_grid_column_align(obj, 0);\n}"}, "get_grid_row_align": {"type": "Function", "def": "static inline uint8_t get_grid_row_align(lv_obj_t * obj)", "sline": 97, "body": "{\n    return lv_obj_get_style_grid_row_align(obj, 0);\n}"}, "LV_LAYOUT_GRID": {"type": "Variable", "def": "uint32_t LV_LAYOUT_GRID", "sline": 105}, "LV_STYLE_GRID_COLUMN_DSC_ARRAY": {"type": "Variable", "def": "lv_style_prop_t LV_STYLE_GRID_COLUMN_DSC_ARRAY", "sline": 106}, "LV_STYLE_GRID_COLUMN_ALIGN": {"type": "Variable", "def": "lv_style_prop_t LV_STYLE_GRID_COLUMN_ALIGN", "sline": 107}, "LV_STYLE_GRID_ROW_DSC_ARRAY": {"type": "Variable", "def": "lv_style_prop_t LV_STYLE_GRID_ROW_DSC_ARRAY", "sline": 108}, "LV_STYLE_GRID_ROW_ALIGN": {"type": "Variable", "def": "lv_style_prop_t LV_STYLE_GRID_ROW_ALIGN", "sline": 109}, "LV_STYLE_GRID_CELL_COLUMN_POS": {"type": "Variable", "def": "lv_style_prop_t LV_STYLE_GRID_CELL_COLUMN_POS", "sline": 110}, "LV_STYLE_GRID_CELL_COLUMN_SPAN": {"type": "Variable", "def": "lv_style_prop_t LV_STYLE_GRID_CELL_COLUMN_SPAN", "sline": 111}, "LV_STYLE_GRID_CELL_X_ALIGN": {"type": "Variable", "def": "lv_style_prop_t LV_STYLE_GRID_CELL_X_ALIGN", "sline": 112}, "LV_STYLE_GRID_CELL_ROW_POS": {"type": "Variable", "def": "lv_style_prop_t LV_STYLE_GRID_CELL_ROW_POS", "sline": 113}, "LV_STYLE_GRID_CELL_ROW_SPAN": {"type": "Variable", "def": "lv_style_prop_t LV_STYLE_GRID_CELL_ROW_SPAN", "sline": 114}, "LV_STYLE_GRID_CELL_Y_ALIGN": {"type": "Variable", "def": "lv_style_prop_t LV_STYLE_GRID_CELL_Y_ALIGN", "sline": 115}, "lv_grid_init": {"type": "Function", "def": "void lv_grid_init(void)", "sline": 130, "body": "{\n    LV_LAYOUT_GRID = lv_layout_register(grid_update, NULL);\n\n    LV_STYLE_GRID_COLUMN_DSC_ARRAY = lv_style_register_prop() | LV_STYLE_PROP_LAYOUT_REFR;\n    LV_STYLE_GRID_ROW_DSC_ARRAY = lv_style_register_prop() | LV_STYLE_PROP_LAYOUT_REFR;\n    LV_STYLE_GRID_COLUMN_ALIGN = lv_style_register_prop() | LV_STYLE_PROP_LAYOUT_REFR;\n    LV_STYLE_GRID_ROW_ALIGN = lv_style_register_prop() | LV_STYLE_PROP_LAYOUT_REFR;\n\n    LV_STYLE_GRID_CELL_ROW_SPAN = lv_style_register_prop() | LV_STYLE_PROP_LAYOUT_REFR;\n    LV_STYLE_GRID_CELL_ROW_POS = lv_style_register_prop() | LV_STYLE_PROP_LAYOUT_REFR;\n    LV_STYLE_GRID_CELL_COLUMN_SPAN = lv_style_register_prop() | LV_STYLE_PROP_LAYOUT_REFR;\n    LV_STYLE_GRID_CELL_COLUMN_POS = lv_style_register_prop() | LV_STYLE_PROP_LAYOUT_REFR;\n    LV_STYLE_GRID_CELL_X_ALIGN = lv_style_register_prop() | LV_STYLE_PROP_LAYOUT_REFR;\n    LV_STYLE_GRID_CELL_Y_ALIGN = lv_style_register_prop() | LV_STYLE_PROP_LAYOUT_REFR;\n}"}, "lv_obj_set_grid_dsc_array": {"type": "Function", "def": "void lv_obj_set_grid_dsc_array(lv_obj_t * obj, const lv_coord_t col_dsc[], const lv_coord_t row_dsc[])", "sline": 147, "body": "{\n    lv_obj_set_style_grid_column_dsc_array(obj, col_dsc, 0);\n    lv_obj_set_style_grid_row_dsc_array(obj, row_dsc, 0);\n    lv_obj_set_style_layout(obj, LV_LAYOUT_GRID, 0);\n}"}, "lv_obj_set_grid_align": {"type": "Function", "def": "void lv_obj_set_grid_align(lv_obj_t * obj, lv_grid_align_t column_align, lv_grid_align_t row_align)", "sline": 154, "body": "{\n    lv_obj_set_style_grid_column_align(obj, column_align, 0);\n    lv_obj_set_style_grid_row_align(obj, row_align, 0);\n\n}"}, "lv_obj_set_grid_cell": {"type": "Function", "def": "void lv_obj_set_grid_cell(lv_obj_t * obj, lv_grid_align_t x_align, uint8_t col_pos, uint8_t col_span,\n                          lv_grid_align_t y_align, uint8_t row_pos, uint8_t row_span)", "sline": 161, "body": "{\n    lv_obj_set_style_grid_cell_column_pos(obj, col_pos, 0);\n    lv_obj_set_style_grid_cell_row_pos(obj, row_pos, 0);\n    lv_obj_set_style_grid_cell_x_align(obj, x_align, 0);\n    lv_obj_set_style_grid_cell_column_span(obj, col_span, 0);\n    lv_obj_set_style_grid_cell_row_span(obj, row_span, 0);\n    lv_obj_set_style_grid_cell_y_align(obj, y_align, 0);\n\n    lv_obj_mark_layout_as_dirty(lv_obj_get_parent(obj));\n}"}, "lv_style_set_grid_row_dsc_array": {"type": "Function", "def": "void lv_style_set_grid_row_dsc_array(lv_style_t * style, const lv_coord_t value[])", "sline": 176, "body": "{\n    lv_style_value_t v = {\n        .ptr = (const void *)value\n    };\n    lv_style_set_prop(style, LV_STYLE_GRID_ROW_DSC_ARRAY, v);\n}"}, "lv_style_set_grid_column_dsc_array": {"type": "Function", "def": "void lv_style_set_grid_column_dsc_array(lv_style_t * style, const lv_coord_t value[])", "sline": 184, "body": "{\n    lv_style_value_t v = {\n        .ptr = (const void *)value\n    };\n    lv_style_set_prop(style, LV_STYLE_GRID_COLUMN_DSC_ARRAY, v);\n}"}, "lv_style_set_grid_row_align": {"type": "Function", "def": "void lv_style_set_grid_row_align(lv_style_t * style, lv_grid_align_t value)", "sline": 192, "body": "{\n    lv_style_value_t v = {\n        .num = (lv_grid_align_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_GRID_ROW_ALIGN, v);\n}"}, "lv_style_set_grid_column_align": {"type": "Function", "def": "void lv_style_set_grid_column_align(lv_style_t * style, lv_grid_align_t value)", "sline": 200, "body": "{\n    lv_style_value_t v = {\n        .num = (lv_grid_align_t)value\n    };\n    lv_style_set_prop(style, LV_STYLE_GRID_COLUMN_ALIGN, v);\n}"}, "lv_style_set_grid_cell_column_pos": {"type": "Function", "def": "void lv_style_set_grid_cell_column_pos(lv_style_t * style, lv_coord_t value)", "sline": 209, "body": "{\n    lv_style_value_t v = {\n        .num = value\n    };\n    lv_style_set_prop(style, LV_STYLE_GRID_CELL_COLUMN_POS, v);\n}"}, "lv_style_set_grid_cell_column_span": {"type": "Function", "def": "void lv_style_set_grid_cell_column_span(lv_style_t * style, lv_coord_t value)", "sline": 217, "body": "{\n    lv_style_value_t v = {\n        .num = value\n    };\n    lv_style_set_prop(style, LV_STYLE_GRID_CELL_COLUMN_SPAN, v);\n}"}, "lv_style_set_grid_cell_row_pos": {"type": "Function", "def": "void lv_style_set_grid_cell_row_pos(lv_style_t * style, lv_coord_t value)", "sline": 225, "body": "{\n    lv_style_value_t v = {\n        .num = value\n    };\n    lv_style_set_prop(style, LV_STYLE_GRID_CELL_ROW_POS, v);\n}"}, "lv_style_set_grid_cell_row_span": {"type": "Function", "def": "void lv_style_set_grid_cell_row_span(lv_style_t * style, lv_coord_t value)", "sline": 233, "body": "{\n    lv_style_value_t v = {\n        .num = value\n    };\n    lv_style_set_prop(style, LV_STYLE_GRID_CELL_ROW_SPAN, v);\n}"}, "lv_style_set_grid_cell_x_align": {"type": "Function", "def": "void lv_style_set_grid_cell_x_align(lv_style_t * style, lv_coord_t value)", "sline": 241, "body": "{\n    lv_style_value_t v = {\n        .num = value\n    };\n    lv_style_set_prop(style, LV_STYLE_GRID_CELL_X_ALIGN, v);\n}"}, "lv_style_set_grid_cell_y_align": {"type": "Function", "def": "void lv_style_set_grid_cell_y_align(lv_style_t * style, lv_coord_t value)", "sline": 249, "body": "{\n    lv_style_value_t v = {\n        .num = value\n    };\n    lv_style_set_prop(style, LV_STYLE_GRID_CELL_Y_ALIGN, v);\n}"}, "lv_obj_set_style_grid_row_dsc_array": {"type": "Function", "def": "void lv_obj_set_style_grid_row_dsc_array(lv_obj_t * obj, const lv_coord_t value[], lv_style_selector_t selector)", "sline": 257, "body": "{\n    lv_style_value_t v = {\n        .ptr = (const void *)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_GRID_ROW_DSC_ARRAY, v, selector);\n}"}, "lv_obj_set_style_grid_column_dsc_array": {"type": "Function", "def": "void lv_obj_set_style_grid_column_dsc_array(lv_obj_t * obj, const lv_coord_t value[], lv_style_selector_t selector)", "sline": 265, "body": "{\n    lv_style_value_t v = {\n        .ptr = (const void *)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_GRID_COLUMN_DSC_ARRAY, v, selector);\n}"}, "lv_obj_set_style_grid_row_align": {"type": "Function", "def": "void lv_obj_set_style_grid_row_align(lv_obj_t * obj, lv_grid_align_t value, lv_style_selector_t selector)", "sline": 274, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t) value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_GRID_ROW_ALIGN, v, selector);\n}"}, "lv_obj_set_style_grid_column_align": {"type": "Function", "def": "void lv_obj_set_style_grid_column_align(lv_obj_t * obj, lv_grid_align_t value, lv_style_selector_t selector)", "sline": 282, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t) value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_GRID_COLUMN_ALIGN, v, selector);\n}"}, "lv_obj_set_style_grid_cell_column_pos": {"type": "Function", "def": "void lv_obj_set_style_grid_cell_column_pos(lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 291, "body": "{\n    lv_style_value_t v = {\n        .num = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_GRID_CELL_COLUMN_POS, v, selector);\n}"}, "lv_obj_set_style_grid_cell_column_span": {"type": "Function", "def": "void lv_obj_set_style_grid_cell_column_span(lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 299, "body": "{\n    lv_style_value_t v = {\n        .num = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_GRID_CELL_COLUMN_SPAN, v, selector);\n}"}, "lv_obj_set_style_grid_cell_row_pos": {"type": "Function", "def": "void lv_obj_set_style_grid_cell_row_pos(lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 307, "body": "{\n    lv_style_value_t v = {\n        .num = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_GRID_CELL_ROW_POS, v, selector);\n}"}, "lv_obj_set_style_grid_cell_row_span": {"type": "Function", "def": "void lv_obj_set_style_grid_cell_row_span(lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 315, "body": "{\n    lv_style_value_t v = {\n        .num = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_GRID_CELL_ROW_SPAN, v, selector);\n}"}, "lv_obj_set_style_grid_cell_x_align": {"type": "Function", "def": "void lv_obj_set_style_grid_cell_x_align(lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 323, "body": "{\n    lv_style_value_t v = {\n        .num = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_GRID_CELL_X_ALIGN, v, selector);\n}"}, "lv_obj_set_style_grid_cell_y_align": {"type": "Function", "def": "void lv_obj_set_style_grid_cell_y_align(lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 331, "body": "{\n    lv_style_value_t v = {\n        .num = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_GRID_CELL_Y_ALIGN, v, selector);\n}"}, "carbit_updater/lvgl/src/extra/layouts/grid/lv_grid.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/layouts/grid/lv_grid.c"}}, "carbit_updater/lvgl/src/misc/lv_math.c": {"lv_math": {"type": "Variable", "def": "#include lv_math.h", "sline": 9, "include": ["carbit_updater/lvgl/src/misc/lv_math.h", null]}, "sin0_90_table": {"type": "Variable", "def": "static const int16_t sin0_90_table[] = {\n    0,     572,   1144,  1715,  2286,  2856,  3425,  3993,  4560,  5126,  5690,  6252,  6813,  7371,  7927,  8481,\n    9032,  9580,  10126, 10668, 11207, 11743, 12275, 12803, 13328, 13848, 14364, 14876, 15383, 15886, 16383, 16876,\n    17364, 17846, 18323, 18794, 19260, 19720, 20173, 20621, 21062, 21497, 21925, 22347, 22762, 23170, 23571, 23964,\n    24351, 24730, 25101, 25465, 25821, 26169, 26509, 26841, 27165, 27481, 27788, 28087, 28377, 28659, 28932, 29196,\n    29451, 29697, 29934, 30162, 30381, 30591, 30791, 30982, 31163, 31335, 31498, 31650, 31794, 31927, 32051, 32165,\n    32269, 32364, 32448, 32523, 32587, 32642, 32687, 32722, 32747, 32762, 32767\n}", "sline": 26}, "lv_trigo_sin": {"type": "Function", "def": "int16_t lv_trigo_sin(int16_t angle)", "sline": 48, "body": "{\n    int16_t ret = 0;\n    angle       = angle % 360;\n\n    if(angle < 0) angle = 360 + angle;\n\n    if(angle < 90) {\n        ret = sin0_90_table[angle];\n    }\n    else if(angle >= 90 && angle < 180) {\n        angle = 180 - angle;\n        ret   = sin0_90_table[angle];\n    }\n    else if(angle >= 180 && angle < 270) {\n        angle = angle - 180;\n        ret   = -sin0_90_table[angle];\n    }\n    else {   /*angle >=270*/\n        angle = 360 - angle;\n        ret   = -sin0_90_table[angle];\n    }\n\n    return ret;\n}"}, "lv_bezier3": {"type": "Function", "def": "uint32_t lv_bezier3(uint32_t t, uint32_t u0, uint32_t u1, uint32_t u2, uint32_t u3)", "sline": 83, "body": "{\n    uint32_t t_rem  = 1024 - t;\n    uint32_t t_rem2 = (t_rem * t_rem) >> 10;\n    uint32_t t_rem3 = (t_rem2 * t_rem) >> 10;\n    uint32_t t2     = (t * t) >> 10;\n    uint32_t t3     = (t2 * t) >> 10;\n\n    uint32_t v1 = (t_rem3 * u0) >> 10;\n    uint32_t v2 = (3 * t_rem2 * t * u1) >> 20;\n    uint32_t v3 = (3 * t_rem * t2 * u2) >> 20;\n    uint32_t v4 = (t3 * u3) >> 10;\n\n    return v1 + v2 + v3 + v4;\n}"}, "lv_sqrt": {"type": "Function", "def": "void lv_sqrt(uint32_t x, lv_sqrt_res_t * q, uint32_t mask)", "sline": 109, "body": "{\n    x = x << 8; /*To get 4 bit precision. (sqrt(256) = 16 = 4 bit)*/\n\n    uint32_t root = 0;\n    uint32_t trial;\n    // http://ww1.microchip.com/...en/AppNotes/91040a.pdf\n    do {\n        trial = root + mask;\n        if(trial * trial <= x) root = trial;\n        mask = mask >> 1;\n    } while(mask);\n\n    q->i = root >> 4;\n    q->f = (root & 0xf) << 4;\n}"}, "lv_atan2": {"type": "Function", "def": "uint16_t lv_atan2(int x, int y)", "sline": 132, "body": "{\n    // Fast XY vector to integer degree algorithm - Jan 2011 www.RomanBlack.com\n    // Converts any XY values including 0 to a degree value that should be\n    // within +/- 1 degree of the accurate value without needing\n    // large slow trig functions like ArcTan() or ArcCos().\n    // NOTE! at least one of the X or Y values must be non-zero!\n    // This is the full version, for all 4 quadrants and will generate\n    // the angle in integer degrees from 0-360.\n    // Any values of X and Y are usable including negative values provided\n    // they are between -1456 and 1456 so the 16bit multiply does not overflow.\n\n    unsigned char negflag;\n    unsigned char tempdegree;\n    unsigned char comp;\n    unsigned int degree;     // this will hold the result\n    unsigned int ux;\n    unsigned int uy;\n\n    // Save the sign flags then remove signs and get XY as unsigned ints\n    negflag = 0;\n    if(x < 0) {\n        negflag += 0x01;    // x flag bit\n        x = (0 - x);        // is now +\n    }\n    ux = x;                // copy to unsigned var before multiply\n    if(y < 0) {\n        negflag += 0x02;    // y flag bit\n        y = (0 - y);        // is now +\n    }\n    uy = y;                // copy to unsigned var before multiply\n\n    // 1. Calc the scaled \"degrees\"\n    if(ux > uy) {\n        degree = (uy * 45) / ux;   // degree result will be 0-45 range\n        negflag += 0x10;    // octant flag bit\n    }\n    else {\n        degree = (ux * 45) / uy;   // degree result will be 0-45 range\n    }\n\n    // 2. Compensate for the 4 degree error curve\n    comp = 0;\n    tempdegree = degree;    // use an unsigned char for speed!\n    if(tempdegree > 22) {    // if top half of range\n        if(tempdegree <= 44) comp++;\n        if(tempdegree <= 41) comp++;\n        if(tempdegree <= 37) comp++;\n        if(tempdegree <= 32) comp++;  // max is 4 degrees compensated\n    }\n    else {   // else is lower half of range\n        if(tempdegree >= 2) comp++;\n        if(tempdegree >= 6) comp++;\n        if(tempdegree >= 10) comp++;\n        if(tempdegree >= 15) comp++;  // max is 4 degrees compensated\n    }\n    degree += comp;   // degree is now accurate to +/- 1 degree!\n\n    // Invert degree if it was X>Y octant, makes 0-45 into 90-45\n    if(negflag & 0x10) degree = (90 - degree);\n\n    // 3. Degree is now 0-90 range for this quadrant,\n    // need to invert it for whichever quadrant it was in\n    if(negflag & 0x02) { // if -Y\n        if(negflag & 0x01)   // if -Y -X\n            degree = (180 + degree);\n        else        // else is -Y +X\n            degree = (180 - degree);\n    }\n    else {   // else is +Y\n        if(negflag & 0x01)   // if +Y -X\n            degree = (360 - degree);\n    }\n    return degree;\n}"}, "lv_pow": {"type": "Function", "def": "int64_t lv_pow(int64_t base, int8_t exp)", "sline": 214, "body": "{\n    int64_t result = 1;\n    while(exp) {\n        if(exp & 1)\n            result *= base;\n        exp >>= 1;\n        base *= base;\n    }\n\n    return result;\n}"}, "lv_map": {"type": "Function", "def": "int32_t lv_map(int32_t x, int32_t min_in, int32_t max_in, int32_t min_out, int32_t max_out)", "sline": 236, "body": "{\n    if(x >= max_in) return max_out;\n    if(x <= min_in) return min_out;\n\n    /**\n     * The equation should be:\n     *   ((x - min_in) * delta_out) / delta in) + min_out\n     * To avoid rounding error reorder the operations:\n     *   (x - min_in) * (delta_out / delta_min) + min_out\n     */\n\n    int32_t delta_in = max_in - min_in;\n    int32_t delta_out = max_out - min_out;\n\n    return ((x - min_in) * delta_out) / delta_in + min_out;\n}"}, "lv_rand": {"type": "Function", "def": "uint32_t lv_rand(uint32_t min, uint32_t max)", "sline": 254, "body": "{\n    static uint32_t a = 0x1234ABCD; /*Seed*/\n\n    /*Algorithm \"xor\" from p. 4 of Marsaglia, \"Xorshift RNGs\"*/\n    uint32_t x = a;\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    a = x;\n\n    return (a % (max - min + 1)) + min;\n}"}, "carbit_updater/lvgl/src/misc/lv_math.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_math.c"}}, "carbit_updater/lvgl/src/extra/libs/sjpg/tjpgd.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../../../lv_conf_internal.h", "sline": 11}, "carbit_updater/lvgl/src/extra/libs/sjpg/tjpgd.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/sjpg/tjpgd.h"}}, "carbit_updater/lvgl/src/core/lv_disp.c": {"lv_disp": {"type": "Variable", "def": "#include lv_disp.h", "sline": 9, "include": ["carbit_updater/lvgl/src/core/lv_disp.h", null]}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 10}, "lv_refr": {"type": "Variable", "def": "#include ../core/lv_refr.h", "sline": 11}, "scr_load_anim_start": {"type": "Function", "def": "static void scr_load_anim_start(lv_anim_t * a)", "sline": 418, "body": "{\n    lv_disp_t * d = lv_obj_get_disp(a->var);\n\n    d->prev_scr = lv_scr_act();\n    d->act_scr = a->var;\n\n    lv_event_send(d->act_scr, LV_EVENT_SCREEN_LOAD_START, NULL);\n}"}, "opa_scale_anim": {"type": "Function", "def": "static void opa_scale_anim(void * obj, int32_t v)", "sline": 428, "body": "{\n    lv_obj_set_style_opa(obj, v, 0);\n}"}, "set_x_anim": {"type": "Function", "def": "static void set_x_anim(void * obj, int32_t v)", "sline": 433, "body": "{\n    lv_obj_set_x(obj, v);\n}"}, "set_y_anim": {"type": "Function", "def": "static void set_y_anim(void * obj, int32_t v)", "sline": 438, "body": "{\n    lv_obj_set_y(obj, v);\n}"}, "scr_anim_ready": {"type": "Function", "def": "static void scr_anim_ready(lv_anim_t * a)", "sline": 443, "body": "{\n    lv_disp_t * d = lv_obj_get_disp(a->var);\n\n    lv_event_send(d->act_scr, LV_EVENT_SCREEN_LOADED, NULL);\n    lv_event_send(d->prev_scr, LV_EVENT_SCREEN_UNLOADED, NULL);\n\n    if(d->prev_scr && d->del_prev) lv_obj_del(d->prev_scr);\n    d->prev_scr = NULL;\n    d->scr_to_load = NULL;\n    lv_obj_remove_local_style_prop(a->var, LV_STYLE_OPA, 0);\n}"}, "lv_disp_get_scr_act": {"type": "Function", "def": "lv_obj_t * lv_disp_get_scr_act(lv_disp_t * disp)", "sline": 49, "body": "{\n    if(!disp) disp = lv_disp_get_default();\n    if(!disp) {\n        LV_LOG_WARN(\"no display registered to get its active screen\");\n        return NULL;\n    }\n\n    return disp->act_scr;\n}"}, "lv_disp_get_scr_prev": {"type": "Function", "def": "lv_obj_t * lv_disp_get_scr_prev(lv_disp_t * disp)", "sline": 66, "body": "{\n    if(!disp) disp = lv_disp_get_default();\n    if(!disp) {\n        LV_LOG_WARN(\"no display registered to get its previous screen\");\n        return NULL;\n    }\n\n    return disp->prev_scr;\n}"}, "lv_disp_load_scr": {"type": "Function", "def": "void lv_disp_load_scr(lv_obj_t * scr)", "sline": 81, "body": "{\n    lv_disp_t * d = lv_obj_get_disp(scr);\n    if(!d) return;  /*Shouldn't happen, just to be sure*/\n\n    lv_obj_t * old_scr = d->act_scr;\n\n    if(d->act_scr) lv_event_send(old_scr, LV_EVENT_SCREEN_UNLOAD_START, NULL);\n    if(d->act_scr) lv_event_send(scr, LV_EVENT_SCREEN_LOAD_START, NULL);\n\n    d->act_scr = scr;\n\n    if(d->act_scr) lv_event_send(scr, LV_EVENT_SCREEN_LOADED, NULL);\n    if(d->act_scr) lv_event_send(old_scr, LV_EVENT_SCREEN_UNLOADED, NULL);\n\n    lv_obj_invalidate(scr);\n}"}, "lv_disp_get_layer_top": {"type": "Function", "def": "lv_obj_t * lv_disp_get_layer_top(lv_disp_t * disp)", "sline": 104, "body": "{\n    if(!disp) disp = lv_disp_get_default();\n    if(!disp) {\n        LV_LOG_WARN(\"lv_layer_top: no display registered to get its top layer\");\n        return NULL;\n    }\n\n    return disp->top_layer;\n}"}, "lv_disp_get_layer_sys": {"type": "Function", "def": "lv_obj_t * lv_disp_get_layer_sys(lv_disp_t * disp)", "sline": 121, "body": "{\n    if(!disp) disp = lv_disp_get_default();\n    if(!disp) {\n        LV_LOG_WARN(\"lv_layer_sys: no display registered to get its sys. layer\");\n        return NULL;\n    }\n\n    return disp->sys_layer;\n}"}, "lv_disp_set_theme": {"type": "Function", "def": "void lv_disp_set_theme(lv_disp_t * disp, lv_theme_t * th)", "sline": 136, "body": "{\n    if(disp == NULL) disp = lv_disp_get_default();\n    disp->theme = th;\n\n    if(disp->screen_cnt == 3 &&\n       lv_obj_get_child_cnt(disp->screens[0]) == 0 &&\n       lv_obj_get_child_cnt(disp->screens[1]) == 0 &&\n       lv_obj_get_child_cnt(disp->screens[2]) == 0) {\n        lv_theme_apply(disp->screens[0]);\n    }\n}"}, "lv_disp_get_theme": {"type": "Function", "def": "lv_theme_t * lv_disp_get_theme(lv_disp_t * disp)", "sline": 153, "body": "{\n    if(disp == NULL) disp = lv_disp_get_default();\n    return disp->theme;\n}"}, "lv_disp_set_bg_color": {"type": "Function", "def": "void lv_disp_set_bg_color(lv_disp_t * disp, lv_color_t color)", "sline": 164, "body": "{\n    if(!disp) disp = lv_disp_get_default();\n    if(!disp) {\n        LV_LOG_WARN(\"no display registered\");\n        return;\n    }\n\n    disp->bg_color = color;\n\n    lv_area_t a;\n    lv_area_set(&a, 0, 0, lv_disp_get_hor_res(disp) - 1, lv_disp_get_ver_res(disp) - 1);\n    _lv_inv_area(disp, &a);\n\n}"}, "lv_disp_set_bg_image": {"type": "Function", "def": "void lv_disp_set_bg_image(lv_disp_t * disp, const void  * img_src)", "sline": 185, "body": "{\n    if(!disp) disp = lv_disp_get_default();\n    if(!disp) {\n        LV_LOG_WARN(\"no display registered\");\n        return;\n    }\n\n    disp->bg_img = img_src;\n\n    lv_area_t a;\n    lv_area_set(&a, 0, 0, lv_disp_get_hor_res(disp) - 1, lv_disp_get_ver_res(disp) - 1);\n    _lv_inv_area(disp, &a);\n}"}, "lv_disp_set_bg_opa": {"type": "Function", "def": "void lv_disp_set_bg_opa(lv_disp_t * disp, lv_opa_t opa)", "sline": 205, "body": "{\n    if(!disp) disp = lv_disp_get_default();\n    if(!disp) {\n        LV_LOG_WARN(\"no display registered\");\n        return;\n    }\n\n    disp->bg_opa = opa;\n\n    lv_area_t a;\n    lv_area_set(&a, 0, 0, lv_disp_get_hor_res(disp) - 1, lv_disp_get_ver_res(disp) - 1);\n    _lv_inv_area(disp, &a);\n}"}, "lv_scr_load_anim": {"type": "Function", "def": "void lv_scr_load_anim(lv_obj_t * new_scr, lv_scr_load_anim_t anim_type, uint32_t time, uint32_t delay, bool auto_del)", "sline": 228, "body": "{\n\n    lv_disp_t * d = lv_obj_get_disp(new_scr);\n    lv_obj_t * act_scr = lv_scr_act();\n\n    /*If an other screen load animation is in progress\n     *make target screen loaded immediately. */\n    if(d->scr_to_load && act_scr != d->scr_to_load) {\n        lv_disp_load_scr(d->scr_to_load);\n        lv_anim_del(d->scr_to_load, NULL);\n        lv_obj_set_pos(d->scr_to_load, 0, 0);\n        lv_obj_remove_local_style_prop(d->scr_to_load, LV_STYLE_OPA, 0);\n\n        if(d->del_prev) {\n            lv_obj_del(act_scr);\n        }\n        act_scr = d->scr_to_load;\n    }\n\n    d->scr_to_load = new_scr;\n\n    if(d->prev_scr && d->del_prev) {\n        lv_obj_del(d->prev_scr);\n        d->prev_scr = NULL;\n    }\n\n    d->del_prev = auto_del;\n\n    /*Be sure there is no other animation on the screens*/\n    lv_anim_del(new_scr, NULL);\n    lv_anim_del(lv_scr_act(), NULL);\n\n    /*Be sure both screens are in a normal position*/\n    lv_obj_set_pos(new_scr, 0, 0);\n    lv_obj_set_pos(lv_scr_act(), 0, 0);\n    lv_obj_remove_local_style_prop(new_scr, LV_STYLE_OPA, 0);\n    lv_obj_remove_local_style_prop(lv_scr_act(), LV_STYLE_OPA, 0);\n\n    lv_anim_t a_new;\n    lv_anim_init(&a_new);\n    lv_anim_set_var(&a_new, new_scr);\n    lv_anim_set_start_cb(&a_new, scr_load_anim_start);\n    lv_anim_set_ready_cb(&a_new, scr_anim_ready);\n    lv_anim_set_time(&a_new, time);\n    lv_anim_set_delay(&a_new, delay);\n\n    lv_anim_t a_old;\n    lv_anim_init(&a_old);\n    lv_anim_set_var(&a_old, d->act_scr);\n    lv_anim_set_time(&a_old, time);\n    lv_anim_set_delay(&a_old, delay);\n\n    switch(anim_type) {\n        case LV_SCR_LOAD_ANIM_NONE:\n            /*Create a dummy animation to apply the delay*/\n            lv_anim_set_exec_cb(&a_new, set_x_anim);\n            lv_anim_set_values(&a_new, 0, 0);\n            break;\n        case LV_SCR_LOAD_ANIM_OVER_LEFT:\n            lv_anim_set_exec_cb(&a_new, set_x_anim);\n            lv_anim_set_values(&a_new, lv_disp_get_hor_res(d), 0);\n            break;\n        case LV_SCR_LOAD_ANIM_OVER_RIGHT:\n            lv_anim_set_exec_cb(&a_new, set_x_anim);\n            lv_anim_set_values(&a_new, -lv_disp_get_hor_res(d), 0);\n            break;\n        case LV_SCR_LOAD_ANIM_OVER_TOP:\n            lv_anim_set_exec_cb(&a_new, set_y_anim);\n            lv_anim_set_values(&a_new, lv_disp_get_ver_res(d), 0);\n            break;\n        case LV_SCR_LOAD_ANIM_OVER_BOTTOM:\n            lv_anim_set_exec_cb(&a_new, set_y_anim);\n            lv_anim_set_values(&a_new, -lv_disp_get_ver_res(d), 0);\n            break;\n        case LV_SCR_LOAD_ANIM_MOVE_LEFT:\n            lv_anim_set_exec_cb(&a_new, set_x_anim);\n            lv_anim_set_values(&a_new, lv_disp_get_hor_res(d), 0);\n\n            lv_anim_set_exec_cb(&a_old, set_x_anim);\n            lv_anim_set_values(&a_old, 0, -lv_disp_get_hor_res(d));\n            break;\n        case LV_SCR_LOAD_ANIM_MOVE_RIGHT:\n            lv_anim_set_exec_cb(&a_new, set_x_anim);\n            lv_anim_set_values(&a_new, -lv_disp_get_hor_res(d), 0);\n\n            lv_anim_set_exec_cb(&a_old, set_x_anim);\n            lv_anim_set_values(&a_old, 0, lv_disp_get_hor_res(d));\n            break;\n        case LV_SCR_LOAD_ANIM_MOVE_TOP:\n            lv_anim_set_exec_cb(&a_new, set_y_anim);\n            lv_anim_set_values(&a_new, lv_disp_get_ver_res(d), 0);\n\n            lv_anim_set_exec_cb(&a_old, set_y_anim);\n            lv_anim_set_values(&a_old, 0, -lv_disp_get_ver_res(d));\n            break;\n        case LV_SCR_LOAD_ANIM_MOVE_BOTTOM:\n            lv_anim_set_exec_cb(&a_new, set_y_anim);\n            lv_anim_set_values(&a_new, -lv_disp_get_ver_res(d), 0);\n\n            lv_anim_set_exec_cb(&a_old, set_y_anim);\n            lv_anim_set_values(&a_old, 0, lv_disp_get_ver_res(d));\n            break;\n\n        case LV_SCR_LOAD_ANIM_FADE_ON:\n            lv_anim_set_exec_cb(&a_new, opa_scale_anim);\n            lv_anim_set_values(&a_new, LV_OPA_TRANSP, LV_OPA_COVER);\n            break;\n    }\n\n    lv_event_send(act_scr, LV_EVENT_SCREEN_UNLOAD_START, NULL);\n\n    lv_anim_start(&a_new);\n    lv_anim_start(&a_old);\n\n}"}, "lv_disp_get_inactive_time": {"type": "Function", "def": "uint32_t lv_disp_get_inactive_time(const lv_disp_t * disp)", "sline": 350, "body": "{\n    if(disp) return lv_tick_elaps(disp->last_activity_time);\n\n    lv_disp_t * d;\n    uint32_t t = UINT32_MAX;\n    d          = lv_disp_get_next(NULL);\n    while(d) {\n        uint32_t elaps = lv_tick_elaps(d->last_activity_time);\n        t = LV_MIN(t, elaps);\n        d = lv_disp_get_next(d);\n    }\n\n    return t;\n}"}, "lv_disp_trig_activity": {"type": "Function", "def": "void lv_disp_trig_activity(lv_disp_t * disp)", "sline": 370, "body": "{\n    if(!disp) disp = lv_disp_get_default();\n    if(!disp) {\n        LV_LOG_WARN(\"lv_disp_trig_activity: no display registered\");\n        return;\n    }\n\n    disp->last_activity_time = lv_tick_get();\n}"}, "lv_disp_clean_dcache": {"type": "Function", "def": "void lv_disp_clean_dcache(lv_disp_t * disp)", "sline": 385, "body": "{\n    if(!disp) disp = lv_disp_get_default();\n    if(!disp) {\n        LV_LOG_WARN(\"lv_disp_clean_dcache: no display registered\");\n        return;\n    }\n\n    if(disp->driver->clean_dcache_cb)\n        disp->driver->clean_dcache_cb(disp->driver);\n}"}, "_lv_disp_get_refr_timer": {"type": "Function", "def": "lv_timer_t * _lv_disp_get_refr_timer(lv_disp_t * disp)", "sline": 403, "body": "{\n    if(!disp) disp = lv_disp_get_default();\n    if(!disp) {\n        LV_LOG_WARN(\"lv_disp_get_refr_timer: no display registered\");\n        return NULL;\n    }\n\n    return disp->refr_timer;\n}"}, "carbit_updater/lvgl/src/core/lv_disp.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_disp.c"}}, "carbit_updater/lvgl/src/misc/lv_async.h": {"lv_types": {"type": "Variable", "def": "#include lv_types.h", "sline": 17, "include": ["carbit_updater/lvgl/src/misc/lv_types.h", null]}, "lv_async_cb_t": {"type": "Variable", "def": "typedef void (*lv_async_cb_t)(void *)", "sline": 30, "docstring": "/**"}, "lv_async_call": {"type": "Function", "def": "lv_res_t lv_async_call(lv_async_cb_t async_xcb, void * user_data)", "sline": 44}, "carbit_updater/lvgl/src/misc/lv_async.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_async.h"}}, "carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar_header_arrow.c": {"lv_calendar_header_arrow": {"type": "Variable", "def": "#include lv_calendar_header_arrow.h", "sline": 9, "include": ["carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar_header_arrow.h", null]}, "lv_calendar": {"type": "Variable", "def": "#include lv_calendar.h", "sline": 12, "include": ["carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar.h", null]}, "lv_btn": {"type": "Variable", "def": "#include ../../../widgets/lv_btn.h", "sline": 13}, "lv_label": {"type": "Variable", "def": "#include ../../../widgets/lv_label.h", "sline": 14}, "lv_flex": {"type": "Variable", "def": "#include ../../layouts/flex/lv_flex.h", "sline": 15}, "my_constructor": {"type": "Function", "def": "static void my_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 63, "body": "{\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    LV_UNUSED(class_p);\n\n    lv_obj_move_to_index(obj, 0);\n\n    lv_obj_set_flex_flow(obj, LV_FLEX_FLOW_ROW);\n    lv_obj_set_flex_align(obj, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_START);\n\n    lv_obj_t * mo_prev = lv_btn_create(obj);\n    lv_obj_set_style_bg_img_src(mo_prev, LV_SYMBOL_LEFT, 0);\n    lv_obj_set_height(mo_prev, lv_pct(100));\n    lv_obj_update_layout(mo_prev);\n    lv_coord_t btn_size = lv_obj_get_height(mo_prev);\n    lv_obj_set_width(mo_prev, btn_size);\n\n    lv_obj_add_event_cb(mo_prev, month_event_cb, LV_EVENT_CLICKED, NULL);\n    lv_obj_clear_flag(mo_prev, LV_OBJ_FLAG_CLICK_FOCUSABLE);\n\n    lv_obj_t * label = lv_label_create(obj);\n    lv_label_set_long_mode(label, LV_LABEL_LONG_SCROLL_CIRCULAR);\n    lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_CENTER, 0);\n    lv_obj_set_flex_grow(label, 1);\n\n    lv_obj_t * mo_next = lv_btn_create(obj);\n    lv_obj_set_style_bg_img_src(mo_next, LV_SYMBOL_RIGHT, 0);\n    lv_obj_set_size(mo_next, btn_size, btn_size);\n\n    lv_obj_add_event_cb(mo_next, month_event_cb, LV_EVENT_CLICKED, NULL);\n    lv_obj_clear_flag(mo_next, LV_OBJ_FLAG_CLICK_FOCUSABLE);\n\n    lv_obj_add_event_cb(obj, value_changed_event_cb, LV_EVENT_VALUE_CHANGED, NULL);\n    /*Refresh the drop downs*/\n    lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n}"}, "month_event_cb": {"type": "Function", "def": "static void month_event_cb(lv_event_t * e)", "sline": 101, "body": "{\n    lv_obj_t * btn = lv_event_get_target(e);\n\n    lv_obj_t * header = lv_obj_get_parent(btn);\n    lv_obj_t * calendar = lv_obj_get_parent(header);\n\n    const lv_calendar_date_t * d;\n    d = lv_calendar_get_showed_date(calendar);\n    lv_calendar_date_t newd = *d;\n\n    /*The last child is the right button*/\n    if(lv_obj_get_child(header, 0) == btn) {\n        if(newd.month == 1) {\n            newd.month = 12;\n            newd.year --;\n        }\n        else {\n            newd.month --;\n        }\n    }\n    else {\n        if(newd.month == 12) {\n            newd.month = 1;\n            newd.year ++;\n        }\n        else {\n            newd.month ++;\n        }\n    }\n\n    lv_calendar_set_showed_date(calendar, newd.year, newd.month);\n\n    lv_obj_t * label = lv_obj_get_child(header, 1);\n    lv_label_set_text_fmt(label, \"%d %s\", newd.year, month_names_def[newd.month - 1]);\n}"}, "value_changed_event_cb": {"type": "Function", "def": "static void value_changed_event_cb(lv_event_t * e)", "sline": 138, "body": "{\n    lv_obj_t * header = lv_event_get_target(e);\n    lv_obj_t * calendar = lv_obj_get_parent(header);\n\n    const lv_calendar_date_t * cur_date = lv_calendar_get_showed_date(calendar);\n    lv_obj_t * label = lv_obj_get_child(header, 1);\n    lv_label_set_text_fmt(label, \"%d %s\", cur_date->year, month_names_def[cur_date->month - 1]);\n}"}, "lv_calendar_header_arrow_class": {"type": "Variable", "def": "const lv_obj_class_t lv_calendar_header_arrow_class = {\n    .base_class = &lv_obj_class,\n    .constructor_cb = my_constructor,\n    .width_def = LV_PCT(100),\n    .height_def = LV_DPI_DEF / 3\n}", "sline": 35}, "month_names_def": {"type": "Variable", "def": "static const char * month_names_def[12] = LV_CALENDAR_DEFAULT_MONTH_NAMES", "sline": 42}, "lv_calendar_header_arrow_create": {"type": "Function", "def": "lv_obj_t * lv_calendar_header_arrow_create(lv_obj_t * parent)", "sline": 52, "body": "{\n    lv_obj_t * obj = lv_obj_class_create_obj(&lv_calendar_header_arrow_class, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar_header_arrow.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar_header_arrow.c"}}, "carbit_updater/lv_drivers/indev/AD_touch.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 20}, "carbit_updater/lv_drivers/indev/AD_touch.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/indev/AD_touch.h"}}, "carbit_updater/lvgl/src/core/lv_obj.c": {"lv_obj": {"type": "Variable", "def": "#include lv_obj.h", "sline": 9, "include": ["carbit_updater/lvgl/src/core/lv_obj.h", null]}, "lv_indev": {"type": "Variable", "def": "#include lv_indev.h", "sline": 10, "include": ["carbit_updater/lvgl/src/core/lv_indev.h", null]}, "lv_refr": {"type": "Variable", "def": "#include lv_refr.h", "sline": 11, "include": ["carbit_updater/lvgl/src/core/lv_refr.h", null]}, "lv_group": {"type": "Variable", "def": "#include lv_group.h", "sline": 12, "include": ["carbit_updater/lvgl/src/core/lv_group.h", null]}, "lv_disp": {"type": "Variable", "def": "#include lv_disp.h", "sline": 13, "include": ["carbit_updater/lvgl/src/core/lv_disp.h", null]}, "lv_theme": {"type": "Variable", "def": "#include lv_theme.h", "sline": 14, "include": ["carbit_updater/lvgl/src/core/lv_theme.h", null]}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 15}, "lv_draw": {"type": "Variable", "def": "#include ../draw/lv_draw.h", "sline": 16}, "lv_anim": {"type": "Variable", "def": "#include ../misc/lv_anim.h", "sline": 17}, "lv_timer": {"type": "Variable", "def": "#include ../misc/lv_timer.h", "sline": 18}, "lv_async": {"type": "Variable", "def": "#include ../misc/lv_async.h", "sline": 19}, "lv_fs": {"type": "Variable", "def": "#include ../misc/lv_fs.h", "sline": 20}, "lv_gc": {"type": "Variable", "def": "#include ../misc/lv_gc.h", "sline": 21}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 22}, "lv_log": {"type": "Variable", "def": "#include ../misc/lv_log.h", "sline": 23}, "lv_hal": {"type": "Variable", "def": "#include ../hal/lv_hal.h", "sline": 24}, "lv_extra": {"type": "Variable", "def": "#include ../extra/lv_extra.h", "sline": 25}, "stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 26}, "string": {"type": "Variable", "def": "#include string.h", "sline": 27}, "lv_obj_constructor": {"type": "Function", "def": "static void lv_obj_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 401, "body": "{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_obj_t * parent = obj->parent;\n    if(parent) {\n        lv_coord_t sl = lv_obj_get_scroll_left(parent);\n        lv_coord_t st = lv_obj_get_scroll_top(parent);\n\n        obj->coords.y1 = parent->coords.y1 + lv_obj_get_style_pad_top(parent, LV_PART_MAIN) - st;\n        obj->coords.y2 = obj->coords.y1 - 1;\n        obj->coords.x1  = parent->coords.x1 + lv_obj_get_style_pad_left(parent, LV_PART_MAIN) - sl;\n        obj->coords.x2  = obj->coords.x1 - 1;\n    }\n\n    /*Set attributes*/\n    obj->flags = LV_OBJ_FLAG_CLICKABLE;\n    obj->flags |= LV_OBJ_FLAG_SNAPPABLE;\n    if(parent) obj->flags |= LV_OBJ_FLAG_PRESS_LOCK;\n    if(parent) obj->flags |= LV_OBJ_FLAG_SCROLL_CHAIN;\n    obj->flags |= LV_OBJ_FLAG_CLICK_FOCUSABLE;\n    obj->flags |= LV_OBJ_FLAG_SCROLLABLE;\n    obj->flags |= LV_OBJ_FLAG_SCROLL_ELASTIC;\n    obj->flags |= LV_OBJ_FLAG_SCROLL_MOMENTUM;\n    if(parent) obj->flags |= LV_OBJ_FLAG_GESTURE_BUBBLE;\n\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}"}, "lv_obj_destructor": {"type": "Function", "def": "static void lv_obj_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 431, "body": "{\n    LV_UNUSED(class_p);\n\n    _lv_event_mark_deleted(obj);\n\n    /*Remove all style*/\n    lv_obj_enable_style_refresh(false); /*No need to refresh the style because the object will be deleted*/\n    lv_obj_remove_style_all(obj);\n    lv_obj_enable_style_refresh(true);\n\n    /*Remove the animations from this object*/\n    lv_anim_del(obj, NULL);\n\n    /*Delete from the group*/\n    lv_group_t * group = lv_obj_get_group(obj);\n    if(group) lv_group_remove_obj(obj);\n\n    if(obj->spec_attr) {\n        if(obj->spec_attr->children) {\n            lv_mem_free(obj->spec_attr->children);\n            obj->spec_attr->children = NULL;\n        }\n        if(obj->spec_attr->event_dsc) {\n            lv_mem_free(obj->spec_attr->event_dsc);\n            obj->spec_attr->event_dsc = NULL;\n        }\n\n        lv_mem_free(obj->spec_attr);\n        obj->spec_attr = NULL;\n    }\n}"}, "lv_obj_draw": {"type": "Function", "def": "static void lv_obj_draw(lv_event_t * e)", "sline": 464, "body": "{\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n    if(code == LV_EVENT_COVER_CHECK) {\n        lv_cover_check_info_t * info = lv_event_get_param(e);\n        if(info->res == LV_COVER_RES_MASKED) return;\n        if(lv_obj_get_style_clip_corner(obj, LV_PART_MAIN)) {\n            info->res = LV_COVER_RES_MASKED;\n            return;\n        }\n\n        /*Most trivial test. Is the mask fully IN the object? If no it surely doesn't cover it*/\n        lv_coord_t r = lv_obj_get_style_radius(obj, LV_PART_MAIN);\n        lv_coord_t w = lv_obj_get_style_transform_width(obj, LV_PART_MAIN);\n        lv_coord_t h = lv_obj_get_style_transform_height(obj, LV_PART_MAIN);\n        lv_area_t coords;\n        lv_area_copy(&coords, &obj->coords);\n        coords.x1 -= w;\n        coords.x2 += w;\n        coords.y1 -= h;\n        coords.y2 += h;\n\n        if(_lv_area_is_in(info->area, &coords, r) == false) {\n            info->res = LV_COVER_RES_NOT_COVER;\n            return;\n        }\n\n        if(lv_obj_get_style_bg_opa(obj, LV_PART_MAIN) < LV_OPA_MAX) {\n            info->res = LV_COVER_RES_NOT_COVER;\n            return;\n        }\n\n#if LV_DRAW_COMPLEX\n        if(lv_obj_get_style_blend_mode(obj, LV_PART_MAIN) != LV_BLEND_MODE_NORMAL) {\n            info->res = LV_COVER_RES_NOT_COVER;\n            return;\n        }\n#endif\n        if(lv_obj_get_style_opa(obj, LV_PART_MAIN) < LV_OPA_MAX) {\n            info->res = LV_COVER_RES_NOT_COVER;\n            return;\n        }\n\n        info->res = LV_COVER_RES_COVER;\n\n    }\n    else if(code == LV_EVENT_DRAW_MAIN) {\n        const lv_area_t * clip_area = lv_event_get_param(e);\n        lv_draw_rect_dsc_t draw_dsc;\n        lv_draw_rect_dsc_init(&draw_dsc);\n        /*If the border is drawn later disable loading its properties*/\n        if(lv_obj_get_style_border_post(obj, LV_PART_MAIN)) {\n            draw_dsc.border_post = 1;\n        }\n\n        lv_obj_init_draw_rect_dsc(obj, LV_PART_MAIN, &draw_dsc);\n\n        lv_coord_t w = lv_obj_get_style_transform_width(obj, LV_PART_MAIN);\n        lv_coord_t h = lv_obj_get_style_transform_height(obj, LV_PART_MAIN);\n        lv_area_t coords;\n        lv_area_copy(&coords, &obj->coords);\n        coords.x1 -= w;\n        coords.x2 += w;\n        coords.y1 -= h;\n        coords.y2 += h;\n\n        lv_obj_draw_part_dsc_t part_dsc;\n        lv_obj_draw_dsc_init(&part_dsc, clip_area);\n        part_dsc.class_p = MY_CLASS;\n        part_dsc.type = LV_OBJ_DRAW_PART_RECTANGLE;\n        part_dsc.rect_dsc = &draw_dsc;\n        part_dsc.draw_area = &coords;\n        part_dsc.part = LV_PART_MAIN;\n        lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_dsc);\n\n        lv_draw_rect(&coords, clip_area, &draw_dsc);\n\n        lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_dsc);\n\n#if LV_DRAW_COMPLEX\n        if(lv_obj_get_style_clip_corner(obj, LV_PART_MAIN)) {\n            /*If the radius is 0 the parent's coordinates will clip anyway*/\n            lv_coord_t r = lv_obj_get_style_radius(obj, LV_PART_MAIN);\n            if(r != 0) {\n                lv_draw_mask_radius_param_t * mp = lv_mem_buf_get(sizeof(lv_draw_mask_radius_param_t));\n                lv_draw_mask_radius_init(mp, &obj->coords, r, false);\n                /*Add the mask and use `obj+8` as custom id. Don't use `obj` directly because it might be used by the user*/\n                lv_draw_mask_add(mp, obj + 8);\n            }\n        }\n#endif\n    }\n    else if(code == LV_EVENT_DRAW_POST) {\n        const lv_area_t * clip_area = lv_event_get_param(e);\n        draw_scrollbar(obj, clip_area);\n\n#if LV_DRAW_COMPLEX\n        if(lv_obj_get_style_clip_corner(obj, LV_PART_MAIN)) {\n            lv_draw_mask_radius_param_t * param = lv_draw_mask_remove_custom(obj + 8);\n            if(param) {\n                lv_draw_mask_free_param(param);\n                lv_mem_buf_release(param);\n            }\n        }\n#endif\n\n        /*If the border is drawn later disable loading other properties*/\n        if(lv_obj_get_style_border_post(obj, LV_PART_MAIN)) {\n            lv_draw_rect_dsc_t draw_dsc;\n            lv_draw_rect_dsc_init(&draw_dsc);\n            draw_dsc.bg_opa = LV_OPA_TRANSP;\n            draw_dsc.outline_opa = LV_OPA_TRANSP;\n            draw_dsc.shadow_opa = LV_OPA_TRANSP;\n            draw_dsc.bg_img_opa = LV_OPA_TRANSP;\n            lv_obj_init_draw_rect_dsc(obj, LV_PART_MAIN, &draw_dsc);\n\n            lv_coord_t w = lv_obj_get_style_transform_width(obj, LV_PART_MAIN);\n            lv_coord_t h = lv_obj_get_style_transform_height(obj, LV_PART_MAIN);\n            lv_area_t coords;\n            lv_area_copy(&coords, &obj->coords);\n            coords.x1 -= w;\n            coords.x2 += w;\n            coords.y1 -= h;\n            coords.y2 += h;\n\n            lv_obj_draw_part_dsc_t part_dsc;\n            lv_obj_draw_dsc_init(&part_dsc, clip_area);\n            part_dsc.class_p = MY_CLASS;\n            part_dsc.type = LV_OBJ_DRAW_PART_BORDER_POST;\n            part_dsc.rect_dsc = &draw_dsc;\n            part_dsc.draw_area = &coords;\n            part_dsc.part = LV_PART_MAIN;\n            lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_dsc);\n\n            lv_draw_rect(&coords, clip_area, &draw_dsc);\n            lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_dsc);\n        }\n    }\n}"}, "lv_obj_event": {"type": "Function", "def": "static void lv_obj_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 697, "body": "{\n    LV_UNUSED(class_p);\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n    if(code == LV_EVENT_PRESSED) {\n        lv_obj_add_state(obj, LV_STATE_PRESSED);\n    }\n    else if(code == LV_EVENT_RELEASED) {\n        lv_obj_clear_state(obj, LV_STATE_PRESSED);\n        void * param = lv_event_get_param(e);\n        /*Go the checked state if enabled*/\n        if(lv_indev_get_scroll_obj(param) == NULL && lv_obj_has_flag(obj, LV_OBJ_FLAG_CHECKABLE)) {\n            if(!(lv_obj_get_state(obj) & LV_STATE_CHECKED)) lv_obj_add_state(obj, LV_STATE_CHECKED);\n            else lv_obj_clear_state(obj, LV_STATE_CHECKED);\n\n            lv_res_t res = lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n            if(res != LV_RES_OK) return;\n        }\n    }\n    else if(code == LV_EVENT_PRESS_LOST) {\n        lv_obj_clear_state(obj, LV_STATE_PRESSED);\n    }\n    else if(code == LV_EVENT_STYLE_CHANGED) {\n        uint32_t child_cnt = lv_obj_get_child_cnt(obj);\n        for(uint32_t i = 0; i < child_cnt; i++) {\n            lv_obj_t * child = obj->spec_attr->children[i];\n            lv_obj_mark_layout_as_dirty(child);\n        }\n    }\n    else if(code == LV_EVENT_KEY) {\n        if(lv_obj_has_flag(obj, LV_OBJ_FLAG_CHECKABLE)) {\n            char c = *((char *)lv_event_get_param(e));\n            if(c == LV_KEY_RIGHT || c == LV_KEY_UP) {\n                lv_obj_add_state(obj, LV_STATE_CHECKED);\n            }\n            else if(c == LV_KEY_LEFT || c == LV_KEY_DOWN) {\n                lv_obj_clear_state(obj, LV_STATE_CHECKED);\n            }\n\n            /*With Enter LV_EVENT_RELEASED will send VALUE_CHANGE event*/\n            if(c != LV_KEY_ENTER) {\n                lv_res_t res = lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n                if(res != LV_RES_OK) return;\n            }\n        }\n        else if(lv_obj_has_flag(obj, LV_OBJ_FLAG_SCROLLABLE) && !lv_obj_is_editable(obj)) {\n            /*scroll by keypad or encoder*/\n            lv_anim_enable_t anim_enable = LV_ANIM_OFF;\n            lv_coord_t sl = lv_obj_get_scroll_left(obj);\n            lv_coord_t sr = lv_obj_get_scroll_right(obj);\n            char c = *((char *)lv_event_get_param(e));\n            if(c == LV_KEY_DOWN) {\n                /*use scroll_to_x/y functions to enforce scroll limits*/\n                lv_obj_scroll_to_y(obj, lv_obj_get_scroll_y(obj) + lv_obj_get_height(obj) / 4, anim_enable);\n            }\n            else if(c == LV_KEY_UP) {\n                lv_obj_scroll_to_y(obj, lv_obj_get_scroll_y(obj) - lv_obj_get_height(obj) / 4, anim_enable);\n            }\n            else if(c == LV_KEY_RIGHT) {\n                /*If the object can't be scrolled horizontally then scroll it vertically*/\n                if(!((lv_obj_get_scroll_dir(obj) & LV_DIR_HOR) && (sl > 0 || sr > 0)))\n                    lv_obj_scroll_to_y(obj, lv_obj_get_scroll_y(obj) + lv_obj_get_height(obj) / 4, anim_enable);\n                else\n                    lv_obj_scroll_to_x(obj, lv_obj_get_scroll_x(obj) + lv_obj_get_width(obj) / 4, anim_enable);\n            }\n            else if(c == LV_KEY_LEFT) {\n                /*If the object can't be scrolled horizontally then scroll it vertically*/\n                if(!((lv_obj_get_scroll_dir(obj) & LV_DIR_HOR) && (sl > 0 || sr > 0)))\n                    lv_obj_scroll_to_y(obj, lv_obj_get_scroll_y(obj) - lv_obj_get_height(obj) / 4, anim_enable);\n                else\n                    lv_obj_scroll_to_x(obj, lv_obj_get_scroll_x(obj) - lv_obj_get_width(obj) / 4, anim_enable);\n            }\n        }\n    }\n    else if(code == LV_EVENT_FOCUSED) {\n        if(lv_obj_has_flag(obj, LV_OBJ_FLAG_SCROLL_ON_FOCUS)) {\n            lv_obj_scroll_to_view_recursive(obj, LV_ANIM_ON);\n        }\n\n        bool editing = false;\n        editing = lv_group_get_editing(lv_obj_get_group(obj));\n        lv_state_t state = LV_STATE_FOCUSED;\n\n        /* Use the indev for then indev handler.\n         * But if the obj was focused manually it returns NULL so try to\n         * use the indev from the event*/\n        lv_indev_t * indev = lv_indev_get_act();\n        if(indev == NULL) indev = lv_event_get_indev(e);\n\n        lv_indev_type_t indev_type = lv_indev_get_type(indev);\n        if(indev_type == LV_INDEV_TYPE_KEYPAD || indev_type == LV_INDEV_TYPE_ENCODER) state |= LV_STATE_FOCUS_KEY;\n        if(editing) {\n            state |= LV_STATE_EDITED;\n            lv_obj_add_state(obj, state);\n        }\n        else {\n            lv_obj_add_state(obj, state);\n            lv_obj_clear_state(obj, LV_STATE_EDITED);\n        }\n    }\n    else if(code == LV_EVENT_SCROLL_BEGIN) {\n        lv_obj_add_state(obj, LV_STATE_SCROLLED);\n    }\n    else if(code == LV_EVENT_SCROLL_END) {\n        lv_obj_clear_state(obj, LV_STATE_SCROLLED);\n        if(lv_obj_get_scrollbar_mode(obj) == LV_SCROLLBAR_MODE_ACTIVE) {\n            lv_area_t hor_area, ver_area;\n            lv_obj_get_scrollbar_area(obj, &hor_area, &ver_area);\n            lv_obj_invalidate_area(obj, &hor_area);\n            lv_obj_invalidate_area(obj, &ver_area);\n        }\n    }\n    else if(code == LV_EVENT_DEFOCUSED) {\n        lv_obj_clear_state(obj, LV_STATE_FOCUSED | LV_STATE_EDITED | LV_STATE_FOCUS_KEY);\n    }\n    else if(code == LV_EVENT_SIZE_CHANGED) {\n        lv_coord_t align = lv_obj_get_style_align(obj, LV_PART_MAIN);\n        uint16_t layout = lv_obj_get_style_layout(obj, LV_PART_MAIN);\n        if(layout || align) {\n            lv_obj_mark_layout_as_dirty(obj);\n        }\n\n        uint32_t i;\n        uint32_t child_cnt = lv_obj_get_child_cnt(obj);\n        for(i = 0; i < child_cnt; i++) {\n            lv_obj_t * child = obj->spec_attr->children[i];\n            lv_obj_mark_layout_as_dirty(child);\n        }\n    }\n    else if(code == LV_EVENT_CHILD_CHANGED) {\n        lv_coord_t w = lv_obj_get_style_width(obj, LV_PART_MAIN);\n        lv_coord_t h = lv_obj_get_style_height(obj, LV_PART_MAIN);\n        lv_coord_t align = lv_obj_get_style_align(obj, LV_PART_MAIN);\n        uint16_t layout = lv_obj_get_style_layout(obj, LV_PART_MAIN);\n        if(layout || align || w == LV_SIZE_CONTENT || h == LV_SIZE_CONTENT) {\n            lv_obj_mark_layout_as_dirty(obj);\n        }\n    }\n    else if(code == LV_EVENT_REFR_EXT_DRAW_SIZE) {\n        lv_coord_t * s = lv_event_get_param(e);\n        lv_coord_t d = lv_obj_calculate_ext_draw_size(obj, LV_PART_MAIN);\n        *s = LV_MAX(*s, d);\n    }\n    else if(code == LV_EVENT_DRAW_MAIN || code == LV_EVENT_DRAW_POST || code == LV_EVENT_COVER_CHECK) {\n        lv_obj_draw(e);\n    }\n}"}, "draw_scrollbar": {"type": "Function", "def": "static void draw_scrollbar(lv_obj_t * obj, const lv_area_t * clip_area)", "sline": 605, "body": "{\n\n    lv_area_t hor_area;\n    lv_area_t ver_area;\n    lv_obj_get_scrollbar_area(obj, &hor_area, &ver_area);\n\n    if(lv_area_get_size(&hor_area) <= 0 && lv_area_get_size(&ver_area) <= 0) return;\n\n    lv_draw_rect_dsc_t draw_dsc;\n    lv_res_t sb_res = scrollbar_init_draw_dsc(obj, &draw_dsc);\n    if(sb_res != LV_RES_OK) return;\n\n    lv_obj_draw_part_dsc_t part_dsc;\n    lv_obj_draw_dsc_init(&part_dsc, clip_area);\n    part_dsc.class_p = MY_CLASS;\n    part_dsc.type = LV_OBJ_DRAW_PART_SCROLLBAR;\n    part_dsc.rect_dsc = &draw_dsc;\n    part_dsc.part = LV_PART_SCROLLBAR;\n\n    if(lv_area_get_size(&hor_area) > 0) {\n        part_dsc.draw_area = &hor_area;\n        lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_dsc);\n        lv_draw_rect(&hor_area, clip_area, &draw_dsc);\n        lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_dsc);\n    }\n    if(lv_area_get_size(&ver_area) > 0) {\n        part_dsc.draw_area = &ver_area;\n        lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_dsc);\n        lv_draw_rect(&ver_area, clip_area, &draw_dsc);\n        lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_dsc);\n    }\n}"}, "scrollbar_init_draw_dsc": {"type": "Function", "def": "static lv_res_t scrollbar_init_draw_dsc(lv_obj_t * obj, lv_draw_rect_dsc_t * dsc)", "sline": 645, "body": "{\n    lv_draw_rect_dsc_init(dsc);\n    dsc->bg_opa = lv_obj_get_style_bg_opa(obj, LV_PART_SCROLLBAR);\n    if(dsc->bg_opa > LV_OPA_MIN) {\n        dsc->bg_color = lv_obj_get_style_bg_color(obj, LV_PART_SCROLLBAR);\n    }\n\n    dsc->border_opa = lv_obj_get_style_border_opa(obj, LV_PART_SCROLLBAR);\n    if(dsc->border_opa > LV_OPA_MIN) {\n        dsc->border_width = lv_obj_get_style_border_width(obj, LV_PART_SCROLLBAR);\n        if(dsc->border_width > 0) {\n            dsc->border_color = lv_obj_get_style_border_color(obj, LV_PART_SCROLLBAR);\n        }\n        else {\n            dsc->border_opa = LV_OPA_TRANSP;\n        }\n    }\n\n#if LV_DRAW_COMPLEX\n    dsc->shadow_opa = lv_obj_get_style_shadow_opa(obj, LV_PART_SCROLLBAR);\n    if(dsc->shadow_opa > LV_OPA_MIN) {\n        dsc->shadow_width = lv_obj_get_style_shadow_width(obj, LV_PART_SCROLLBAR);\n        if(dsc->shadow_width > 0) {\n            dsc->shadow_spread = lv_obj_get_style_shadow_spread(obj, LV_PART_SCROLLBAR);\n            dsc->shadow_color = lv_obj_get_style_shadow_color(obj, LV_PART_SCROLLBAR);\n        }\n        else {\n            dsc->shadow_opa = LV_OPA_TRANSP;\n        }\n    }\n\n    lv_opa_t opa = lv_obj_get_style_opa(obj, LV_PART_SCROLLBAR);\n    if(opa < LV_OPA_MAX) {\n        dsc->bg_opa = (dsc->bg_opa * opa) >> 8;\n        dsc->border_opa = (dsc->bg_opa * opa) >> 8;\n        dsc->shadow_opa = (dsc->bg_opa * opa) >> 8;\n    }\n\n    if(dsc->bg_opa != LV_OPA_TRANSP || dsc->border_opa != LV_OPA_TRANSP || dsc->shadow_opa != LV_OPA_TRANSP) {\n        dsc->radius = lv_obj_get_style_radius(obj, LV_PART_SCROLLBAR);\n        return LV_RES_OK;\n    }\n    else {\n        return LV_RES_INV;\n    }\n#else\n    if(dsc->bg_opa != LV_OPA_TRANSP || dsc->border_opa != LV_OPA_TRANSP) return LV_RES_OK;\n    else return LV_RES_INV;\n#endif\n}"}, "obj_valid_child": {"type": "Function", "def": "static bool obj_valid_child(const lv_obj_t * parent, const lv_obj_t * obj_to_find)", "sline": 926, "body": "{\n    /*Check all children of `parent`*/\n    uint32_t child_cnt = 0;\n    if(parent->spec_attr) child_cnt = parent->spec_attr->child_cnt;\n    uint32_t i;\n    for(i = 0; i < child_cnt; i++) {\n        lv_obj_t * child = parent->spec_attr->children[i];\n        if(child == obj_to_find) {\n            return true;\n        }\n\n        /*Check the children*/\n        bool found = obj_valid_child(child, obj_to_find);\n        if(found) {\n            return true;\n        }\n    }\n    return false;\n}"}, "lv_obj_set_state": {"type": "Function", "def": "static void lv_obj_set_state(lv_obj_t * obj, lv_state_t new_state)", "sline": 853, "body": "{\n    if(obj->state == new_state) return;\n\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_state_t prev_state = obj->state;\n    obj->state = new_state;\n\n    _lv_style_state_cmp_t cmp_res = _lv_obj_style_state_compare(obj, prev_state, new_state);\n    /*If there is no difference in styles there is nothing else to do*/\n    if(cmp_res == _LV_STYLE_STATE_CMP_SAME) return;\n\n    _lv_obj_style_transition_dsc_t * ts = lv_mem_buf_get(sizeof(_lv_obj_style_transition_dsc_t) * STYLE_TRANSITION_MAX);\n    lv_memset_00(ts, sizeof(_lv_obj_style_transition_dsc_t) * STYLE_TRANSITION_MAX);\n    uint32_t tsi = 0;\n    uint32_t i;\n    for(i = 0; i < obj->style_cnt && tsi < STYLE_TRANSITION_MAX; i++) {\n        _lv_obj_style_t * obj_style = &obj->styles[i];\n        lv_state_t state_act = lv_obj_style_get_selector_state(obj->styles[i].selector);\n        lv_part_t part_act = lv_obj_style_get_selector_part(obj->styles[i].selector);\n        if(state_act & (~new_state)) continue; /*Skip unrelated styles*/\n        if(obj_style->is_trans) continue;\n\n        lv_style_value_t v;\n        if(lv_style_get_prop_inlined(obj_style->style, LV_STYLE_TRANSITION, &v) == false) continue;\n        const lv_style_transition_dsc_t * tr = v.ptr;\n\n        /*Add the props to the set if not added yet or added but with smaller weight*/\n        uint32_t j;\n        for(j = 0; tr->props[j] != 0 && tsi < STYLE_TRANSITION_MAX; j++) {\n            uint32_t t;\n            for(t = 0; t < tsi; t++) {\n                lv_style_selector_t selector = ts[t].selector;\n                lv_state_t state_ts = lv_obj_style_get_selector_state(selector);\n                lv_part_t part_ts = lv_obj_style_get_selector_part(selector);\n                if(ts[t].prop == tr->props[j] && part_ts == part_act && state_ts >= state_act) break;\n            }\n\n            /*If not found  add it*/\n            if(t == tsi) {\n                ts[tsi].time = tr->time;\n                ts[tsi].delay = tr->delay;\n                ts[tsi].path_cb = tr->path_xcb;\n                ts[tsi].prop = tr->props[j];\n#if LV_USE_USER_DATA\n                ts[tsi].user_data = tr->user_data;\n#endif\n                ts[tsi].selector = obj_style->selector;\n                tsi++;\n            }\n        }\n    }\n\n    for(i = 0; i < tsi; i++) {\n        lv_part_t part_act = lv_obj_style_get_selector_part(ts[i].selector);\n        _lv_obj_style_create_transition(obj, part_act, prev_state, new_state, &ts[i]);\n    }\n\n    lv_mem_buf_release(ts);\n\n    if(cmp_res == _LV_STYLE_STATE_CMP_DIFF_REDRAW) {\n        lv_obj_invalidate(obj);\n    }\n    else if(cmp_res == _LV_STYLE_STATE_CMP_DIFF_LAYOUT) {\n        lv_obj_refresh_style(obj, LV_PART_ANY, LV_STYLE_PROP_ANY);\n    }\n    else if(cmp_res == _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD) {\n        lv_obj_invalidate(obj);\n        lv_obj_refresh_ext_draw_size(obj);\n    }\n}"}, "lv_initialized": {"type": "Variable", "def": "static bool lv_initialized", "sline": 70}, "lv_obj_class": {"type": "Variable", "def": "const lv_obj_class_t lv_obj_class", "sline": 71}, "lv_is_initialized": {"type": "Function", "def": "bool lv_is_initialized(void)", "sline": 91, "body": "{\n    return lv_initialized;\n}"}, "lv_init": {"type": "Function", "def": "void lv_init(void)", "sline": 96, "body": "{\n    /*Do nothing if already initialized*/\n    if(lv_initialized) {\n        LV_LOG_WARN(\"lv_init: already inited\");\n        return;\n    }\n\n    LV_LOG_INFO(\"begin\");\n\n    /*Initialize the misc modules*/\n    lv_mem_init();\n\n    _lv_timer_core_init();\n\n    _lv_fs_init();\n\n    _lv_anim_core_init();\n\n    _lv_group_init();\n\n#if LV_USE_GPU_STM32_DMA2D\n    /*Initialize DMA2D GPU*/\n    lv_gpu_stm32_dma2d_init();\n#endif\n\n#if LV_USE_GPU_NXP_PXP && LV_USE_GPU_NXP_PXP_AUTO_INIT\n    if(lv_gpu_nxp_pxp_init(&pxp_default_cfg) != LV_RES_OK) {\n        LV_LOG_ERROR(\"PXP init error. STOP.\\n\");\n        for(; ;) ;\n    }\n#endif\n#if LV_USE_GPU_SDL\n    lv_gpu_sdl_init();\n#endif\n\n    _lv_obj_style_init();\n    _lv_ll_init(&LV_GC_ROOT(_lv_disp_ll), sizeof(lv_disp_t));\n    _lv_ll_init(&LV_GC_ROOT(_lv_indev_ll), sizeof(lv_indev_t));\n\n    /*Initialize the screen refresh system*/\n    _lv_refr_init();\n\n    _lv_img_decoder_init();\n#if LV_IMG_CACHE_DEF_SIZE\n    lv_img_cache_set_size(LV_IMG_CACHE_DEF_SIZE);\n#endif\n    /*Test if the IDE has UTF-8 encoding*/\n    char * txt = \"\u00c1\";\n\n    uint8_t * txt_u8 = (uint8_t *)txt;\n    if(txt_u8[0] != 0xc3 || txt_u8[1] != 0x81 || txt_u8[2] != 0x00) {\n        LV_LOG_WARN(\"The strings has no UTF-8 encoding. Non-ASCII characters won't be displayed.\");\n    }\n\n    uint32_t endianess_test = 0x11223344;\n    uint8_t * endianess_test_p = (uint8_t *) &endianess_test;\n    bool big_endian = endianess_test_p[0] == 0x11 ? true : false;\n\n    if(big_endian) {\n        LV_ASSERT_MSG(LV_BIG_ENDIAN_SYSTEM == 1,\n                      \"It's a big endian system but LV_BIG_ENDIAN_SYSTEM is not enabled in lv_conf.h\");\n    }\n    else {\n        LV_ASSERT_MSG(LV_BIG_ENDIAN_SYSTEM == 0,\n                      \"It's a little endian system but LV_BIG_ENDIAN_SYSTEM is enabled in lv_conf.h\");\n    }\n\n#if LV_USE_ASSERT_MEM_INTEGRITY\n    LV_LOG_WARN(\"Memory integrity checks are enabled via LV_USE_ASSERT_MEM_INTEGRITY which makes LVGL much slower\");\n#endif\n\n#if LV_USE_ASSERT_OBJ\n    LV_LOG_WARN(\"Object sanity checks are enabled via LV_USE_ASSERT_OBJ which makes LVGL much slower\");\n#endif\n\n#if LV_USE_ASSERT_STYLE\n    LV_LOG_WARN(\"Style sanity checks are enabled that uses more RAM\");\n#endif\n\n#if LV_LOG_LEVEL == LV_LOG_LEVEL_TRACE\n    LV_LOG_WARN(\"Log level is set the Trace which makes LVGL much slower\");\n#endif\n\n    lv_extra_init();\n\n    lv_initialized = true;\n\n    LV_LOG_TRACE(\"finished\");\n}"}, "lv_deinit": {"type": "Function", "def": "void lv_deinit(void)", "sline": 189, "body": "{\n#if LV_USE_GPU_SDL\n    lv_gpu_sdl_deinit();\n#endif\n    _lv_gc_clear_roots();\n\n    lv_disp_set_default(NULL);\n    lv_mem_deinit();\n    lv_initialized = false;\n\n    LV_LOG_INFO(\"lv_deinit done\");\n\n#if LV_USE_LOG\n    lv_log_register_print_cb(NULL);\n#endif\n}"}, "lv_obj_create": {"type": "Function", "def": "lv_obj_t * lv_obj_create(lv_obj_t * parent)", "sline": 208, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_obj_add_flag": {"type": "Function", "def": "void lv_obj_add_flag(lv_obj_t * obj, lv_obj_flag_t f)", "sline": 224, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    bool was_on_layout = lv_obj_is_layout_positioned(obj);\n\n    if(f & LV_OBJ_FLAG_HIDDEN) lv_obj_invalidate(obj);\n\n    obj->flags |= f;\n\n    if(f & LV_OBJ_FLAG_HIDDEN) {\n        lv_obj_invalidate(obj);\n    }\n\n    if((was_on_layout != lv_obj_is_layout_positioned(obj)) || (f & (LV_OBJ_FLAG_LAYOUT_1 |  LV_OBJ_FLAG_LAYOUT_2))) {\n        lv_obj_mark_layout_as_dirty(lv_obj_get_parent(obj));\n    }\n\n    if(f & LV_OBJ_FLAG_SCROLLABLE) {\n        lv_area_t hor_area, ver_area;\n        lv_obj_get_scrollbar_area(obj, &hor_area, &ver_area);\n        lv_obj_invalidate_area(obj, &hor_area);\n        lv_obj_invalidate_area(obj, &ver_area);\n    }\n}"}, "lv_obj_clear_flag": {"type": "Function", "def": "void lv_obj_clear_flag(lv_obj_t * obj, lv_obj_flag_t f)", "sline": 250, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    bool was_on_layout = lv_obj_is_layout_positioned(obj);\n    if(f & LV_OBJ_FLAG_SCROLLABLE) {\n        lv_area_t hor_area, ver_area;\n        lv_obj_get_scrollbar_area(obj, &hor_area, &ver_area);\n        lv_obj_invalidate_area(obj, &hor_area);\n        lv_obj_invalidate_area(obj, &ver_area);\n    }\n\n    obj->flags &= (~f);\n\n    if(f & LV_OBJ_FLAG_HIDDEN) {\n        lv_obj_invalidate(obj);\n        if(lv_obj_is_layout_positioned(obj)) {\n            lv_obj_mark_layout_as_dirty(lv_obj_get_parent(obj));\n        }\n    }\n\n    if((was_on_layout != lv_obj_is_layout_positioned(obj)) || (f & (LV_OBJ_FLAG_LAYOUT_1 |  LV_OBJ_FLAG_LAYOUT_2))) {\n        lv_obj_mark_layout_as_dirty(lv_obj_get_parent(obj));\n    }\n}"}, "lv_obj_add_state": {"type": "Function", "def": "void lv_obj_add_state(lv_obj_t * obj, lv_state_t state)", "sline": 276, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_state_t new_state = obj->state | state;\n    if(obj->state != new_state) {\n        lv_obj_set_state(obj, new_state);\n    }\n}"}, "lv_obj_clear_state": {"type": "Function", "def": "void lv_obj_clear_state(lv_obj_t * obj, lv_state_t state)", "sline": 286, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_state_t new_state = obj->state & (~state);\n    if(obj->state != new_state) {\n        lv_obj_set_state(obj, new_state);\n    }\n}"}, "lv_obj_has_flag": {"type": "Function", "def": "bool lv_obj_has_flag(const lv_obj_t * obj, lv_obj_flag_t f)", "sline": 300, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    return (obj->flags & f)  == f ? true : false;\n}"}, "lv_obj_has_flag_any": {"type": "Function", "def": "bool lv_obj_has_flag_any(const lv_obj_t * obj, lv_obj_flag_t f)", "sline": 307, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    return (obj->flags & f) ? true : false;\n}"}, "lv_obj_get_state": {"type": "Function", "def": "lv_state_t lv_obj_get_state(const lv_obj_t * obj)", "sline": 314, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    return obj->state;\n}"}, "lv_obj_has_state": {"type": "Function", "def": "bool lv_obj_has_state(const lv_obj_t * obj, lv_state_t state)", "sline": 321, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    return obj->state & state ? true : false;\n}"}, "lv_obj_get_group": {"type": "Function", "def": "void * lv_obj_get_group(const lv_obj_t * obj)", "sline": 328, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    if(obj->spec_attr) return obj->spec_attr->group_p;\n    else return NULL;\n}"}, "lv_obj_allocate_spec_attr": {"type": "Function", "def": "void lv_obj_allocate_spec_attr(lv_obj_t * obj)", "sline": 340, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    if(obj->spec_attr == NULL) {\n        static uint32_t x = 0;\n        x++;\n        obj->spec_attr = lv_mem_alloc(sizeof(_lv_obj_spec_attr_t));\n        LV_ASSERT_MALLOC(obj->spec_attr);\n        if(obj->spec_attr == NULL) return;\n\n        lv_memset_00(obj->spec_attr, sizeof(_lv_obj_spec_attr_t));\n\n        obj->spec_attr->scroll_dir = LV_DIR_ALL;\n        obj->spec_attr->scrollbar_mode = LV_SCROLLBAR_MODE_AUTO;\n    }\n}"}, "lv_obj_check_type": {"type": "Function", "def": "bool lv_obj_check_type(const lv_obj_t * obj, const lv_obj_class_t * class_p)", "sline": 358, "body": "{\n    if(obj == NULL) return false;\n    return obj->class_p == class_p ? true : false;\n}"}, "lv_obj_has_class": {"type": "Function", "def": "bool lv_obj_has_class(const lv_obj_t * obj, const lv_obj_class_t * class_p)", "sline": 364, "body": "{\n    const lv_obj_class_t * obj_class = obj->class_p;\n    while(obj_class) {\n        if(obj_class == class_p) return true;\n        obj_class = obj_class->base_class;\n    }\n\n    return false;\n}"}, "lv_obj_get_class": {"type": "Function", "def": "const lv_obj_class_t * lv_obj_get_class(const lv_obj_t * obj)", "sline": 375, "body": "{\n    return obj->class_p;\n}"}, "lv_obj_is_valid": {"type": "Function", "def": "bool lv_obj_is_valid(const lv_obj_t * obj)", "sline": 380, "body": "{\n    lv_disp_t * disp = lv_disp_get_next(NULL);\n    while(disp) {\n        uint32_t i;\n        for(i = 0; i < disp->screen_cnt; i++) {\n            if(disp->screens[i] == obj) return true;\n            bool found = obj_valid_child(disp->screens[i], obj);\n            if(found) return true;\n        }\n\n        disp = lv_disp_get_next(disp);\n    }\n\n    return false;\n}"}, "carbit_updater/lvgl/src/core/lv_obj.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj.c"}}, "carbit_updater/lvgl/src/extra/others/snapshot/lv_snapshot.c": {"lv_snapshot": {"type": "Variable", "def": "#include lv_snapshot.h", "sline": 9, "include": ["carbit_updater/lvgl/src/extra/others/snapshot/lv_snapshot.h", null]}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 12}, "lv_disp": {"type": "Variable", "def": "#include ../../../core/lv_disp.h", "sline": 13}, "lv_refr": {"type": "Variable", "def": "#include ../../../core/lv_refr.h", "sline": 14}, "lv_snapshot_buf_size_needed": {"type": "Function", "def": "uint32_t lv_snapshot_buf_size_needed(lv_obj_t * obj, lv_img_cf_t cf)", "sline": 46, "body": "{\n    switch(cf) {\n        case LV_IMG_CF_TRUE_COLOR_ALPHA:\n        case LV_IMG_CF_ALPHA_1BIT:\n        case LV_IMG_CF_ALPHA_2BIT:\n        case LV_IMG_CF_ALPHA_4BIT:\n        case LV_IMG_CF_ALPHA_8BIT:\n            break;\n        default:\n            return 0;\n    }\n\n    lv_obj_update_layout(obj);\n\n    /*Width and height determine snapshot image size.*/\n    lv_coord_t w = lv_obj_get_width(obj);\n    lv_coord_t h = lv_obj_get_height(obj);\n    lv_coord_t ext_size = _lv_obj_get_ext_draw_size(obj);\n    w += ext_size * 2;\n    h += ext_size * 2;\n\n    uint8_t px_size = lv_img_cf_get_px_size(cf);\n    return w * h * ((px_size + 7) >> 3);\n}"}, "lv_snapshot_take_to_buf": {"type": "Function", "def": "lv_res_t lv_snapshot_take_to_buf(lv_obj_t * obj, lv_img_cf_t cf, lv_img_dsc_t * dsc, void * buf, uint32_t buff_size)", "sline": 82, "body": "{\n    LV_ASSERT(dsc);\n    LV_ASSERT(buf);\n\n    switch(cf) {\n        case LV_IMG_CF_TRUE_COLOR_ALPHA:\n        case LV_IMG_CF_ALPHA_1BIT:\n        case LV_IMG_CF_ALPHA_2BIT:\n        case LV_IMG_CF_ALPHA_4BIT:\n        case LV_IMG_CF_ALPHA_8BIT:\n            break;\n        default:\n            return LV_RES_INV;\n    }\n\n    if(lv_snapshot_buf_size_needed(obj, cf) > buff_size)\n        return LV_RES_INV;\n\n    /*Width and height determine snapshot image size.*/\n    lv_coord_t w = lv_obj_get_width(obj);\n    lv_coord_t h = lv_obj_get_height(obj);\n    lv_coord_t ext_size = _lv_obj_get_ext_draw_size(obj);\n    w += ext_size * 2;\n    h += ext_size * 2;\n\n    /*Backup obj original info.*/\n    lv_obj_t * parent_old = lv_obj_get_parent(obj);\n    lv_area_t coords_bkp;\n    lv_area_copy(&coords_bkp, &obj->coords);\n\n    lv_memset(buf, 0x00, buff_size);\n    lv_memset_00(dsc, sizeof(lv_img_dsc_t));\n\n    /*We are safe to use stack for below variables since disp will be\n     * unregistered when function returns. */\n    lv_disp_t * disp;\n    lv_disp_drv_t driver;\n    lv_disp_draw_buf_t draw_buf;\n\n    lv_disp_draw_buf_init(&draw_buf, buf, NULL, w * h);\n\n    lv_disp_drv_init(&driver);\n    driver.draw_buf = &draw_buf;\n    driver.hor_res = w;\n    driver.ver_res = h;\n    lv_disp_drv_use_generic_set_px_cb(&driver, cf);\n\n    disp = lv_disp_drv_register(&driver);\n    if(disp == NULL) {\n        return LV_RES_INV;\n    }\n\n    /*Make background transparent */\n    lv_disp_set_bg_opa(disp, LV_OPA_TRANSP);\n\n    /*Move obj to newly created disp and refresh it. */\n    lv_obj_t * screen = lv_disp_get_scr_act(disp);\n    lv_obj_remove_style_all(screen);\n    lv_obj_allocate_spec_attr(screen);\n    screen->spec_attr->child_cnt = 1;\n    screen->spec_attr->children = &obj;\n\n    obj->parent = screen;\n\n    disp->inv_p = 0;\n\n    obj->coords.x2 = w - ext_size - 1;\n    obj->coords.x1 = ext_size;\n    obj->coords.y2 = h - ext_size - 1;\n    obj->coords.y1 = ext_size;\n\n    lv_obj_invalidate(obj);\n\n    /*Don't call lv_refr_now to avoid animation disruption */\n    _lv_disp_refr_timer(disp->refr_timer);\n\n    /*Restore obj original parameters and clean up*/\n    obj->parent = parent_old;\n    screen->spec_attr->child_cnt = 0;\n    screen->spec_attr->children = NULL;\n\n    lv_disp_remove(disp);\n\n    lv_area_copy(&obj->coords, &coords_bkp);\n\n    dsc->data = buf;\n    dsc->header.w = lv_area_get_width(&draw_buf.area);\n    dsc->header.h = lv_area_get_height(&draw_buf.area);\n    dsc->header.cf = cf;\n    return LV_RES_OK;\n}"}, "lv_snapshot_take": {"type": "Function", "def": "lv_img_dsc_t * lv_snapshot_take(lv_obj_t * obj, lv_img_cf_t cf)", "sline": 182, "body": "{\n    uint32_t buff_size = lv_snapshot_buf_size_needed(obj, cf);\n\n    void * buf = lv_mem_alloc(buff_size);\n    if(buf == NULL) {\n        return NULL;\n    }\n\n    lv_img_dsc_t * dsc = lv_mem_alloc(sizeof(lv_img_dsc_t));\n    if(dsc == NULL) {\n        lv_mem_free(buf);\n        return NULL;\n    }\n\n    if(lv_snapshot_take_to_buf(obj, cf, dsc, buf, buff_size) == LV_RES_INV) {\n        lv_mem_free(buf);\n        lv_mem_free(dsc);\n        return NULL;\n    }\n\n    return dsc;\n}"}, "lv_snapshot_free": {"type": "Function", "def": "void lv_snapshot_free(lv_img_dsc_t * dsc)", "sline": 213, "body": "{\n    if(!dsc)\n        return;\n\n    if(dsc->data)\n        lv_mem_free((void *)dsc->data);\n\n    lv_mem_free(dsc);\n}"}, "carbit_updater/lvgl/src/extra/others/snapshot/lv_snapshot.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/others/snapshot/lv_snapshot.c"}}, "carbit_updater/lvgl/src/extra/lv_extra.h": {"lv_extra_init": {"type": "Function", "def": "void lv_extra_init(void)", "sline": 32}, "carbit_updater/lvgl/src/extra/lv_extra.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/lv_extra.h"}}, "carbit_updater/lvgl/src/lv_api_map.h": {"lvgl": {"type": "Variable", "def": "#include ../lvgl.h", "sline": 16}, "lv_task_handler": {"type": "Function", "def": "static inline LV_ATTRIBUTE_TIMER_HANDLER uint32_t lv_task_handler(void)", "sline": 35, "body": "{\n    return lv_timer_handler();\n}"}, "lv_obj_move_foreground": {"type": "Function", "def": "static inline void lv_obj_move_foreground(lv_obj_t * obj)", "sline": 55, "body": "{\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    lv_obj_move_to_index(obj, lv_obj_get_child_cnt(parent) - 1);\n}"}, "lv_obj_move_background": {"type": "Function", "def": "static inline void lv_obj_move_background(lv_obj_t * obj)", "sline": 67, "body": "{\n    lv_obj_move_to_index(obj, 0);\n}"}, "lv_obj_get_child_id": {"type": "Function", "def": "static inline uint32_t lv_obj_get_child_id(const struct _lv_obj_t * obj)", "sline": 78, "body": "{\n    LV_LOG_WARN(\"lv_obj_get_child_id(obj) is deprecated, please use lv_obj_get_index(obj).\");\n    return lv_obj_get_index(obj);\n}"}, "carbit_updater/lvgl/src/lv_api_map.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/lv_api_map.h"}}, "carbit_updater/lvgl/src/misc/lv_timer.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 15}, "stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 17}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 18}, "_lv_timer_t": {"type": "Struct", "def": "struct _lv_timer_t {\n    uint32_t period; /**< How often the timer should run*/\n    uint32_t last_run; /**< Last time the timer ran*/\n    lv_timer_cb_t timer_cb; /**< Timer function*/\n    void * user_data; /**< Custom user data*/\n    int32_t repeat_count; /**< 1: One time;  -1 : infinity;  n>0: residual times*/\n    uint32_t paused : 1;\n}", "sline": 43, "docstring": "/**", "body": "uint32_t period\nuint32_t last_run\nlv_timer_cb_t timer_cb\nvoid * user_data\nint32_t repeat_count\nuint32_t paused : 1\n"}, "lv_timer_cb_t": {"type": "Variable", "def": "typedef void (*lv_timer_cb_t)(struct _lv_timer_t *)", "sline": 38, "docstring": "/**"}, "_lv_timer_t.period": {"type": "Variable", "def": "uint32_t period", "sline": 44, "in_struct": "_lv_timer_t"}, "_lv_timer_t.last_run": {"type": "Variable", "def": "uint32_t last_run", "sline": 45, "in_struct": "_lv_timer_t"}, "_lv_timer_t.timer_cb": {"type": "Variable", "def": "lv_timer_cb_t timer_cb", "sline": 46, "in_struct": "_lv_timer_t", "rels": [["lv_timer_cb_t", null, "Typeof"]]}, "_lv_timer_t.user_data": {"type": "Variable", "def": "void * user_data", "sline": 47, "in_struct": "_lv_timer_t"}, "_lv_timer_t.repeat_count": {"type": "Variable", "def": "int32_t repeat_count", "sline": 48, "in_struct": "_lv_timer_t"}, "_lv_timer_t.paused": {"type": "Variable", "def": "uint32_t paused : 1", "sline": 49, "in_struct": "_lv_timer_t"}, "lv_timer_t": {"type": "Variable", "def": "typedef struct _lv_timer_t {\n    uint32_t period; /**< How often the timer should run*/\n    uint32_t last_run; /**< Last time the timer ran*/\n    lv_timer_cb_t timer_cb; /**< Timer function*/\n    void * user_data; /**< Custom user data*/\n    int32_t repeat_count; /**< 1: One time;  -1 : infinity;  n>0: residual times*/\n    uint32_t paused : 1;\n} lv_timer_t", "sline": 50, "docstring": "/**"}, "_lv_timer_core_init": {"type": "Function", "def": "void _lv_timer_core_init(void)", "sline": 59}, "lv_timer_handler": {"type": "Function", "def": "uint32_t lv_timer_handler(void)", "sline": 67}, "lv_timer_create_basic": {"type": "Function", "def": "lv_timer_t * lv_timer_create_basic(void)", "sline": 76}, "lv_timer_create": {"type": "Function", "def": "lv_timer_t * lv_timer_create(lv_timer_cb_t timer_xcb, uint32_t period, void * user_data)", "sline": 87}, "lv_timer_del": {"type": "Function", "def": "void lv_timer_del(lv_timer_t * timer)", "sline": 93}, "lv_timer_pause": {"type": "Function", "def": "void lv_timer_pause(lv_timer_t * timer)", "sline": 99}, "lv_timer_resume": {"type": "Function", "def": "void lv_timer_resume(lv_timer_t * timer)", "sline": 101}, "lv_timer_set_cb": {"type": "Function", "def": "void lv_timer_set_cb(lv_timer_t * timer, lv_timer_cb_t timer_cb)", "sline": 108}, "lv_timer_set_period": {"type": "Function", "def": "void lv_timer_set_period(lv_timer_t * timer, uint32_t period)", "sline": 115}, "lv_timer_ready": {"type": "Function", "def": "void lv_timer_ready(lv_timer_t * timer)", "sline": 121}, "lv_timer_set_repeat_count": {"type": "Function", "def": "void lv_timer_set_repeat_count(lv_timer_t * timer, int32_t repeat_count)", "sline": 128}, "lv_timer_reset": {"type": "Function", "def": "void lv_timer_reset(lv_timer_t * timer)", "sline": 135}, "lv_timer_enable": {"type": "Function", "def": "void lv_timer_enable(bool en)", "sline": 141}, "lv_timer_get_idle": {"type": "Function", "def": "uint8_t lv_timer_get_idle(void)", "sline": 147}, "lv_timer_get_next": {"type": "Function", "def": "lv_timer_t * lv_timer_get_next(lv_timer_t * timer)", "sline": 154}, "carbit_updater/lvgl/src/misc/lv_timer.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_timer.h"}}, "carbit_updater/lv_drivers/indev/xkb.c": {"xkb": {"type": "Variable", "def": "#include xkb.h", "sline": 9, "include": ["carbit_updater/lv_drivers/indev/xkb.h", null]}, "carbit_updater/lv_drivers/indev/xkb.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/indev/xkb.c"}}, "carbit_updater/lvgl/src/widgets/lv_line.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "lv_obj": {"type": "Variable", "def": "#include ../core/lv_obj.h", "sline": 20}, "lv_line_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 32, "in_struct": "lv_line_t"}, "lv_line_t.point_array": {"type": "Variable", "def": "const lv_point_t * point_array", "sline": 33, "in_struct": "lv_line_t"}, "lv_line_t.point_num": {"type": "Variable", "def": "uint16_t point_num", "sline": 34, "in_struct": "lv_line_t"}, "lv_line_t.y_inv": {"type": "Variable", "def": "uint8_t y_inv : 1", "sline": 35, "in_struct": "lv_line_t"}, "lv_line_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    const lv_point_t * point_array;     /**< Pointer to an array with the points of the line*/\n    uint16_t point_num;                 /**< Number of points in 'point_array'*/\n    uint8_t y_inv : 1;                  /**< 1: y == 0 will be on the bottom*/\n} lv_line_t", "sline": 36, "docstring": "/*Data of line*/"}, "lv_line_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_line_class", "sline": 38}, "lv_line_create": {"type": "Function", "def": "lv_obj_t * lv_line_create(lv_obj_t * parent)", "sline": 49}, "lv_line_set_points": {"type": "Function", "def": "void lv_line_set_points(lv_obj_t * obj, const lv_point_t points[], uint16_t point_num)", "sline": 61}, "lv_line_set_y_invert": {"type": "Function", "def": "void lv_line_set_y_invert(lv_obj_t * obj, bool en)", "sline": 70}, "lv_line_get_y_invert": {"type": "Function", "def": "bool lv_line_get_y_invert(const lv_obj_t * obj)", "sline": 81}, "carbit_updater/lvgl/src/widgets/lv_line.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_line.h"}}, "carbit_updater/lvgl/src/extra/layouts/flex/lv_flex.h": {"lv_obj": {"type": "Variable", "def": "#include ../../../core/lv_obj.h", "sline": 16}, "_silence_gcc_warning": {"type": "Struct", "def": "LV_EXPORT_CONST_INT(LV_OBJ_FLAG_FLEX_IN_NEW_TRACK)", "sline": 24}, "_lv_obj_t": {"type": "Struct", "def": "struct _lv_obj_t", "sline": 35, "docstring": "/*Can't include lv_obj.h because it includes this header file*/"}, "lv_flex_align_t": {"type": "Variable", "def": "typedef enum {\n    LV_FLEX_ALIGN_START,\n    LV_FLEX_ALIGN_END,\n    LV_FLEX_ALIGN_CENTER,\n    LV_FLEX_ALIGN_SPACE_EVENLY,\n    LV_FLEX_ALIGN_SPACE_AROUND,\n    LV_FLEX_ALIGN_SPACE_BETWEEN,\n} lv_flex_align_t", "sline": 44, "docstring": "/*Can't include lv_obj.h because it includes this header file*/"}, "lv_flex_flow_t": {"type": "Variable", "def": "typedef enum {\n    LV_FLEX_FLOW_ROW                 = 0x00,\n    LV_FLEX_FLOW_COLUMN              = _LV_FLEX_COLUMN,\n    LV_FLEX_FLOW_ROW_WRAP            = LV_FLEX_FLOW_ROW | _LV_FLEX_WRAP,\n    LV_FLEX_FLOW_ROW_REVERSE         = LV_FLEX_FLOW_ROW | _LV_FLEX_REVERSE,\n    LV_FLEX_FLOW_ROW_WRAP_REVERSE    = LV_FLEX_FLOW_ROW | _LV_FLEX_WRAP | _LV_FLEX_REVERSE,\n    LV_FLEX_FLOW_COLUMN_WRAP         = LV_FLEX_FLOW_COLUMN | _LV_FLEX_WRAP,\n    LV_FLEX_FLOW_COLUMN_REVERSE      = LV_FLEX_FLOW_COLUMN | _LV_FLEX_REVERSE,\n    LV_FLEX_FLOW_COLUMN_WRAP_REVERSE = LV_FLEX_FLOW_COLUMN | _LV_FLEX_WRAP | _LV_FLEX_REVERSE,\n} lv_flex_flow_t", "sline": 55}, "LV_LAYOUT_FLEX": {"type": "Variable", "def": "extern uint32_t LV_LAYOUT_FLEX", "sline": 60}, "LV_STYLE_FLEX_FLOW": {"type": "Variable", "def": "extern lv_style_prop_t LV_STYLE_FLEX_FLOW", "sline": 61}, "LV_STYLE_FLEX_MAIN_PLACE": {"type": "Variable", "def": "extern lv_style_prop_t LV_STYLE_FLEX_MAIN_PLACE", "sline": 62}, "LV_STYLE_FLEX_CROSS_PLACE": {"type": "Variable", "def": "extern lv_style_prop_t LV_STYLE_FLEX_CROSS_PLACE", "sline": 63}, "LV_STYLE_FLEX_TRACK_PLACE": {"type": "Variable", "def": "extern lv_style_prop_t LV_STYLE_FLEX_TRACK_PLACE", "sline": 64}, "LV_STYLE_FLEX_GROW": {"type": "Variable", "def": "extern lv_style_prop_t LV_STYLE_FLEX_GROW", "sline": 65}, "lv_flex_init": {"type": "Function", "def": "void lv_flex_init(void)", "sline": 75}, "lv_obj_set_flex_flow": {"type": "Function", "def": "void lv_obj_set_flex_flow(lv_obj_t * obj, lv_flex_flow_t flow)", "sline": 82}, "lv_obj_set_flex_align": {"type": "Function", "def": "void lv_obj_set_flex_align(lv_obj_t * obj, lv_flex_align_t main_place, lv_flex_align_t cross_place,\n                           lv_flex_align_t track_cross_place)", "sline": 91}, "lv_obj_set_flex_grow": {"type": "Function", "def": "void lv_obj_set_flex_grow(lv_obj_t * obj, uint8_t grow)", "sline": 99}, "lv_style_set_flex_flow": {"type": "Function", "def": "void lv_style_set_flex_flow(lv_style_t * style, lv_flex_flow_t value)", "sline": 101}, "lv_style_set_flex_main_place": {"type": "Function", "def": "void lv_style_set_flex_main_place(lv_style_t * style, lv_flex_align_t value)", "sline": 102}, "lv_style_set_flex_cross_place": {"type": "Function", "def": "void lv_style_set_flex_cross_place(lv_style_t * style, lv_flex_align_t value)", "sline": 103}, "lv_style_set_flex_track_place": {"type": "Function", "def": "void lv_style_set_flex_track_place(lv_style_t * style, lv_flex_align_t value)", "sline": 104}, "lv_style_set_flex_grow": {"type": "Function", "def": "void lv_style_set_flex_grow(lv_style_t * style, uint8_t value)", "sline": 105}, "lv_obj_set_style_flex_flow": {"type": "Function", "def": "void lv_obj_set_style_flex_flow(lv_obj_t * obj, lv_flex_flow_t value, lv_style_selector_t selector)", "sline": 106}, "lv_obj_set_style_flex_main_place": {"type": "Function", "def": "void lv_obj_set_style_flex_main_place(lv_obj_t * obj, lv_flex_align_t value, lv_style_selector_t selector)", "sline": 107}, "lv_obj_set_style_flex_cross_place": {"type": "Function", "def": "void lv_obj_set_style_flex_cross_place(lv_obj_t * obj, lv_flex_align_t value, lv_style_selector_t selector)", "sline": 108}, "lv_obj_set_style_flex_track_place": {"type": "Function", "def": "void lv_obj_set_style_flex_track_place(lv_obj_t * obj, lv_flex_align_t value, lv_style_selector_t selector)", "sline": 109}, "lv_obj_set_style_flex_grow": {"type": "Function", "def": "void lv_obj_set_style_flex_grow(lv_obj_t * obj, uint8_t value, lv_style_selector_t selector)", "sline": 110}, "lv_obj_get_style_flex_flow": {"type": "Function", "def": "static inline lv_flex_flow_t lv_obj_get_style_flex_flow(const lv_obj_t * obj, uint32_t part)", "sline": 112, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_FLEX_FLOW);\n    return (lv_flex_flow_t)v.num;\n}", "rels": [["lv_flex_flow_t", null, "Typeof"]]}, "lv_obj_get_style_flex_main_place": {"type": "Function", "def": "static inline lv_flex_align_t lv_obj_get_style_flex_main_place(const lv_obj_t * obj, uint32_t part)", "sline": 118, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_FLEX_MAIN_PLACE);\n    return (lv_flex_align_t)v.num;\n}", "rels": [["lv_flex_align_t", null, "Typeof"]]}, "lv_obj_get_style_flex_cross_place": {"type": "Function", "def": "static inline lv_flex_align_t lv_obj_get_style_flex_cross_place(const lv_obj_t * obj, uint32_t part)", "sline": 124, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_FLEX_CROSS_PLACE);\n    return (lv_flex_align_t)v.num;\n}", "rels": [["lv_flex_align_t", null, "Typeof"]]}, "lv_obj_get_style_flex_track_place": {"type": "Function", "def": "static inline lv_flex_align_t lv_obj_get_style_flex_track_place(const lv_obj_t * obj, uint32_t part)", "sline": 130, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_FLEX_TRACK_PLACE);\n    return (lv_flex_align_t)v.num;\n}", "rels": [["lv_flex_align_t", null, "Typeof"]]}, "lv_obj_get_style_flex_grow": {"type": "Function", "def": "static inline uint8_t lv_obj_get_style_flex_grow(const lv_obj_t * obj, uint32_t part)", "sline": 136, "body": "{\n    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_FLEX_GROW);\n    return (uint8_t)v.num;\n}"}, "carbit_updater/lvgl/src/extra/layouts/flex/lv_flex.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/layouts/flex/lv_flex.h"}}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_utils.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../../lv_conf_internal.h", "sline": 16}, "lv_color": {"type": "Variable", "def": "#include ../../misc/lv_color.h", "sline": 18}, "lv_area": {"type": "Variable", "def": "#include ../../misc/lv_area.h", "sline": 19}, "_lv_gpu_sdl_utils_init": {"type": "Function", "def": "void _lv_gpu_sdl_utils_init()", "sline": 35}, "_lv_gpu_sdl_utils_deinit": {"type": "Function", "def": "void _lv_gpu_sdl_utils_deinit()", "sline": 37}, "lv_area_to_sdl_rect": {"type": "Function", "def": "void lv_area_to_sdl_rect(const lv_area_t * in, SDL_Rect * out)", "sline": 39}, "lv_color_to_sdl_color": {"type": "Function", "def": "void lv_color_to_sdl_color(const lv_color_t * in, SDL_Color * out)", "sline": 41}, "lv_area_zoom_to_sdl_rect": {"type": "Function", "def": "void lv_area_zoom_to_sdl_rect(const lv_area_t * in, SDL_Rect * out, uint16_t zoom, const lv_point_t * pivot)", "sline": 43}, "lv_sdl_round": {"type": "Function", "def": "double lv_sdl_round(double d)", "sline": 45}, "lv_sdl_alloc_palette_for_bpp": {"type": "Function", "def": "SDL_Palette * lv_sdl_alloc_palette_for_bpp(const uint8_t * mapping, uint8_t bpp)", "sline": 47}, "lv_sdl_get_grayscale_palette": {"type": "Function", "def": "SDL_Palette * lv_sdl_get_grayscale_palette(uint8_t bpp)", "sline": 49}, "lv_sdl_to_8bpp": {"type": "Function", "def": "void lv_sdl_to_8bpp(uint8_t * dest, const uint8_t * src, int width, int height, int stride, uint8_t bpp)", "sline": 51}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_utils.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_utils.h"}}, "carbit_updater/lvgl/src/extra/libs/fsdrv/lv_fs_win32.c": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/extra/libs/fsdrv/lv_fs_win32.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/fsdrv/lv_fs_win32.c"}}, "carbit_updater/lvgl/tests/src/lv_test_init.c": {"carbit_updater/lvgl/tests/src/lv_test_init.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/tests/src/lv_test_init.c"}}, "carbit_updater/lvgl/tests/src/test_cases/_test_template.c": {"carbit_updater/lvgl/tests/src/test_cases/_test_template.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/tests/src/test_cases/_test_template.c"}}, "carbit_updater/lvgl/src/draw/lv_draw_label.c": {"lv_draw_label": {"type": "Function", "def": "void lv_draw_label(const lv_area_t * coords, const lv_area_t * mask,\n                                         const lv_draw_label_dsc_t * dsc,\n                                         const char * txt,\n                                         lv_draw_label_hint_t * hint)", "sline": 121, "body": "{\n\n    if(dsc->opa <= LV_OPA_MIN) return;\n    const lv_font_t * font = dsc->font;\n    int32_t w;\n\n    /*No need to waste processor time if string is empty*/\n    if(txt == NULL || txt[0] == '\\0')\n        return;\n\n    lv_area_t clipped_area;\n    bool clip_ok = _lv_area_intersect(&clipped_area, coords, mask);\n    if(!clip_ok) return;\n\n    lv_text_align_t align = dsc->align;\n    lv_base_dir_t base_dir = dsc->bidi_dir;\n\n    lv_bidi_calculate_align(&align, &base_dir, txt);\n\n    if((dsc->flag & LV_TEXT_FLAG_EXPAND) == 0) {\n        /*Normally use the label's width as width*/\n        w = lv_area_get_width(coords);\n    }\n    else {\n        /*If EXAPND is enabled then not limit the text's width to the object's width*/\n        lv_point_t p;\n        lv_txt_get_size(&p, txt, dsc->font, dsc->letter_space, dsc->line_space, LV_COORD_MAX,\n                        dsc->flag);\n        w = p.x;\n    }\n\n    int32_t line_height_font = lv_font_get_line_height(font);\n    int32_t line_height = line_height_font + dsc->line_space;\n\n    /*Init variables for the first line*/\n    int32_t line_width = 0;\n    lv_point_t pos;\n    pos.x = coords->x1;\n    pos.y = coords->y1;\n\n    int32_t x_ofs = 0;\n    int32_t y_ofs = 0;\n    x_ofs = dsc->ofs_x;\n    y_ofs = dsc->ofs_y;\n    pos.y += y_ofs;\n\n    uint32_t line_start     = 0;\n    int32_t last_line_start = -1;\n\n    /*Check the hint to use the cached info*/\n    if(hint && y_ofs == 0 && coords->y1 < 0) {\n        /*If the label changed too much recalculate the hint.*/\n        if(LV_ABS(hint->coord_y - coords->y1) > LV_LABEL_HINT_UPDATE_TH - 2 * line_height) {\n            hint->line_start = -1;\n        }\n        last_line_start = hint->line_start;\n    }\n\n    /*Use the hint if it's valid*/\n    if(hint && last_line_start >= 0) {\n        line_start = last_line_start;\n        pos.y += hint->y;\n    }\n\n    uint32_t line_end = line_start + _lv_txt_get_next_line(&txt[line_start], font, dsc->letter_space, w, dsc->flag);\n\n    /*Go the first visible line*/\n    while(pos.y + line_height_font < mask->y1) {\n        /*Go to next line*/\n        line_start = line_end;\n        line_end += _lv_txt_get_next_line(&txt[line_start], font, dsc->letter_space, w, dsc->flag);\n        pos.y += line_height;\n\n        /*Save at the threshold coordinate*/\n        if(hint && pos.y >= -LV_LABEL_HINT_UPDATE_TH && hint->line_start < 0) {\n            hint->line_start = line_start;\n            hint->y          = pos.y - coords->y1;\n            hint->coord_y    = coords->y1;\n        }\n\n        if(txt[line_start] == '\\0') return;\n    }\n\n    /*Align to middle*/\n    if(align == LV_TEXT_ALIGN_CENTER) {\n        line_width = lv_txt_get_width(&txt[line_start], line_end - line_start, font, dsc->letter_space, dsc->flag);\n\n        pos.x += (lv_area_get_width(coords) - line_width) / 2;\n\n    }\n    /*Align to the right*/\n    else if(align == LV_TEXT_ALIGN_RIGHT) {\n        line_width = lv_txt_get_width(&txt[line_start], line_end - line_start, font, dsc->letter_space, dsc->flag);\n        pos.x += lv_area_get_width(coords) - line_width;\n    }\n\n    lv_opa_t opa = dsc->opa;\n\n    uint32_t sel_start = dsc->sel_start;\n    uint32_t sel_end = dsc->sel_end;\n    if(sel_start > sel_end) {\n        uint32_t tmp = sel_start;\n        sel_start = sel_end;\n        sel_end = tmp;\n    }\n    lv_draw_line_dsc_t line_dsc;\n\n    if((dsc->decor & LV_TEXT_DECOR_UNDERLINE) || (dsc->decor & LV_TEXT_DECOR_STRIKETHROUGH)) {\n        lv_draw_line_dsc_init(&line_dsc);\n        line_dsc.color = dsc->color;\n        line_dsc.width = font->underline_thickness ? font->underline_thickness : 1;\n        line_dsc.opa = dsc->opa;\n        line_dsc.blend_mode = dsc->blend_mode;\n    }\n\n    cmd_state_t cmd_state = CMD_STATE_WAIT;\n    uint32_t i;\n    uint32_t par_start = 0;\n    lv_color_t recolor;\n    int32_t letter_w;\n\n    lv_draw_rect_dsc_t draw_dsc_sel;\n    lv_draw_rect_dsc_init(&draw_dsc_sel);\n    draw_dsc_sel.bg_color = dsc->sel_bg_color;\n\n    int32_t pos_x_start = pos.x;\n    /*Write out all lines*/\n    while(txt[line_start] != '\\0') {\n        pos.x += x_ofs;\n\n        /*Write all letter of a line*/\n        cmd_state = CMD_STATE_WAIT;\n        i         = 0;\n#if LV_USE_BIDI\n        char * bidi_txt = lv_mem_buf_get(line_end - line_start + 1);\n        _lv_bidi_process_paragraph(txt + line_start, bidi_txt, line_end - line_start, base_dir, NULL, 0);\n#else\n        const char * bidi_txt = txt + line_start;\n#endif\n\n        while(i < line_end - line_start) {\n            uint32_t logical_char_pos = 0;\n            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {\n#if LV_USE_BIDI\n                logical_char_pos = _lv_txt_encoded_get_char_id(txt, line_start);\n                uint32_t t = _lv_txt_encoded_get_char_id(bidi_txt, i);\n                logical_char_pos += _lv_bidi_get_logical_pos(bidi_txt, NULL, line_end - line_start, base_dir, t, NULL);\n#else\n                logical_char_pos = _lv_txt_encoded_get_char_id(txt, line_start + i);\n#endif\n            }\n\n            uint32_t letter;\n            uint32_t letter_next;\n            _lv_txt_encoded_letter_next_2(bidi_txt, &letter, &letter_next, &i);\n            /*Handle the re-color command*/\n            if((dsc->flag & LV_TEXT_FLAG_RECOLOR) != 0) {\n                if(letter == (uint32_t)LV_TXT_COLOR_CMD[0]) {\n                    if(cmd_state == CMD_STATE_WAIT) { /*Start char*/\n                        par_start = i;\n                        cmd_state = CMD_STATE_PAR;\n                        continue;\n                    }\n                    else if(cmd_state == CMD_STATE_PAR) {   /*Other start char in parameter escaped cmd. char*/\n                        cmd_state = CMD_STATE_WAIT;\n                    }\n                    else if(cmd_state == CMD_STATE_IN) {   /*Command end*/\n                        cmd_state = CMD_STATE_WAIT;\n                        continue;\n                    }\n                }\n\n                /*Skip the color parameter and wait the space after it*/\n                if(cmd_state == CMD_STATE_PAR) {\n                    if(letter == ' ') {\n                        /*Get the parameter*/\n                        if(i - par_start == LABEL_RECOLOR_PAR_LENGTH + 1) {\n                            char buf[LABEL_RECOLOR_PAR_LENGTH + 1];\n                            lv_memcpy_small(buf, &bidi_txt[par_start], LABEL_RECOLOR_PAR_LENGTH);\n                            buf[LABEL_RECOLOR_PAR_LENGTH] = '\\0';\n                            int r, g, b;\n                            r       = (hex_char_to_num(buf[0]) << 4) + hex_char_to_num(buf[1]);\n                            g       = (hex_char_to_num(buf[2]) << 4) + hex_char_to_num(buf[3]);\n                            b       = (hex_char_to_num(buf[4]) << 4) + hex_char_to_num(buf[5]);\n                            recolor = lv_color_make(r, g, b);\n                        }\n                        else {\n                            recolor.full = dsc->color.full;\n                        }\n                        cmd_state = CMD_STATE_IN; /*After the parameter the text is in the command*/\n                    }\n                    continue;\n                }\n            }\n\n            lv_color_t color = dsc->color;\n\n            if(cmd_state == CMD_STATE_IN) color = recolor;\n\n            letter_w = lv_font_get_glyph_width(font, letter, letter_next);\n\n            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {\n                if(logical_char_pos >= sel_start && logical_char_pos < sel_end) {\n                    lv_area_t sel_coords;\n                    sel_coords.x1 = pos.x;\n                    sel_coords.y1 = pos.y;\n                    sel_coords.x2 = pos.x + letter_w + dsc->letter_space - 1;\n                    sel_coords.y2 = pos.y + line_height - 1;\n                    lv_draw_rect(&sel_coords, mask, &draw_dsc_sel);\n                    color = dsc->sel_color;\n                }\n            }\n\n            lv_draw_letter(&pos, mask, font, letter, color, opa, dsc->blend_mode);\n\n            if(letter_w > 0) {\n                pos.x += letter_w + dsc->letter_space;\n            }\n        }\n\n        if(dsc->decor & LV_TEXT_DECOR_STRIKETHROUGH) {\n            lv_point_t p1;\n            lv_point_t p2;\n            p1.x = pos_x_start;\n            p1.y = pos.y + (dsc->font->line_height / 2)  + line_dsc.width / 2;\n            p2.x = pos.x;\n            p2.y = p1.y;\n            lv_draw_line(&p1, &p2, mask, &line_dsc);\n        }\n\n        if(dsc->decor  & LV_TEXT_DECOR_UNDERLINE) {\n            lv_point_t p1;\n            lv_point_t p2;\n            p1.x = pos_x_start;\n            p1.y = pos.y + dsc->font->line_height - dsc->font->base_line - font->underline_position;\n            p2.x = pos.x;\n            p2.y = p1.y;\n            lv_draw_line(&p1, &p2, mask, &line_dsc);\n        }\n\n#if LV_USE_BIDI\n        lv_mem_buf_release(bidi_txt);\n        bidi_txt = NULL;\n#endif\n        /*Go to next line*/\n        line_start = line_end;\n        line_end += _lv_txt_get_next_line(&txt[line_start], font, dsc->letter_space, w, dsc->flag);\n\n        pos.x = coords->x1;\n        /*Align to middle*/\n        if(align == LV_TEXT_ALIGN_CENTER) {\n            line_width =\n                lv_txt_get_width(&txt[line_start], line_end - line_start, font, dsc->letter_space, dsc->flag);\n\n            pos.x += (lv_area_get_width(coords) - line_width) / 2;\n\n        }\n        /*Align to the right*/\n        else if(align == LV_TEXT_ALIGN_RIGHT) {\n            line_width =\n                lv_txt_get_width(&txt[line_start], line_end - line_start, font, dsc->letter_space, dsc->flag);\n            pos.x += lv_area_get_width(coords) - line_width;\n        }\n\n        /*Go the next line position*/\n        pos.y += line_height;\n\n        if(pos.y > mask->y2) return;\n    }\n\n    LV_ASSERT_MEM_INTEGRITY();\n}"}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 10}, "lv_hal_disp": {"type": "Variable", "def": "#include ../hal/lv_hal_disp.h", "sline": 11}, "lv_refr": {"type": "Variable", "def": "#include ../core/lv_refr.h", "sline": 12}, "lv_bidi": {"type": "Variable", "def": "#include ../misc/lv_bidi.h", "sline": 13}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 14}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_draw_label.c:28:1)": {"type": "Enum", "def": "enum {\n    CMD_STATE_WAIT,\n    CMD_STATE_PAR,\n    CMD_STATE_IN,\n}", "sline": 28, "docstring": "/**********************"}, "cmd_state_t": {"type": "Variable", "def": "typedef uint8_t cmd_state_t", "sline": 33}, "draw_letter_normal": {"type": "Function", "def": "static void draw_letter_normal(lv_coord_t pos_x, lv_coord_t pos_y, lv_font_glyph_dsc_t * g,\n                                                     const lv_area_t * clip_area,\n                                                     const uint8_t * map_p, lv_color_t color, lv_opa_t opa, lv_blend_mode_t blend_mode)", "sline": 470, "body": "{\n    const uint8_t * bpp_opa_table_p;\n    uint32_t bitmask_init;\n    uint32_t bitmask;\n    uint32_t bpp = g->bpp;\n    uint32_t shades;\n    if(bpp == 3) bpp = 4;\n\n    switch(bpp) {\n        case 1:\n            bpp_opa_table_p = _lv_bpp1_opa_table;\n            bitmask_init  = 0x80;\n            shades = 2;\n            break;\n        case 2:\n            bpp_opa_table_p = _lv_bpp2_opa_table;\n            bitmask_init  = 0xC0;\n            shades = 4;\n            break;\n        case 4:\n            bpp_opa_table_p = _lv_bpp4_opa_table;\n            bitmask_init  = 0xF0;\n            shades = 16;\n            break;\n        case 8:\n            bpp_opa_table_p = _lv_bpp8_opa_table;\n            bitmask_init  = 0xFF;\n            shades = 256;\n            break;       /*No opa table, pixel value will be used directly*/\n        default:\n            LV_LOG_WARN(\"lv_draw_letter: invalid bpp\");\n            return; /*Invalid bpp. Can't render the letter*/\n    }\n\n    static lv_opa_t opa_table[256];\n    static lv_opa_t prev_opa = LV_OPA_TRANSP;\n    static uint32_t prev_bpp = 0;\n    if(opa < LV_OPA_MAX) {\n        if(prev_opa != opa || prev_bpp != bpp) {\n            uint32_t i;\n            for(i = 0; i < shades; i++) {\n                opa_table[i] = bpp_opa_table_p[i] == LV_OPA_COVER ? opa : ((bpp_opa_table_p[i] * opa) >> 8);\n            }\n        }\n        bpp_opa_table_p = opa_table;\n        prev_opa = opa;\n        prev_bpp = bpp;\n    }\n\n    int32_t col, row;\n    int32_t box_w = g->box_w;\n    int32_t box_h = g->box_h;\n    int32_t width_bit = box_w * bpp; /*Letter width in bits*/\n\n    /*Calculate the col/row start/end on the map*/\n    int32_t col_start = pos_x >= clip_area->x1 ? 0 : clip_area->x1 - pos_x;\n    int32_t col_end   = pos_x + box_w <= clip_area->x2 ? box_w : clip_area->x2 - pos_x + 1;\n    int32_t row_start = pos_y >= clip_area->y1 ? 0 : clip_area->y1 - pos_y;\n    int32_t row_end   = pos_y + box_h <= clip_area->y2 ? box_h : clip_area->y2 - pos_y + 1;\n\n    /*Move on the map too*/\n    uint32_t bit_ofs = (row_start * width_bit) + (col_start * bpp);\n    map_p += bit_ofs >> 3;\n\n    uint8_t letter_px;\n    uint32_t col_bit;\n    col_bit = bit_ofs & 0x7; /*\"& 0x7\" equals to \"% 8\" just faster*/\n\n    lv_coord_t hor_res = lv_disp_get_hor_res(_lv_refr_get_disp_refreshing());\n    uint32_t mask_buf_size = box_w * box_h > hor_res ? hor_res : box_w * box_h;\n    lv_opa_t * mask_buf = lv_mem_buf_get(mask_buf_size);\n    int32_t mask_p = 0;\n\n    lv_area_t fill_area;\n    fill_area.x1 = col_start + pos_x;\n    fill_area.x2 = col_end  + pos_x - 1;\n    fill_area.y1 = row_start + pos_y;\n    fill_area.y2 = fill_area.y1;\n#if LV_DRAW_COMPLEX\n    bool mask_any = lv_draw_mask_is_any(&fill_area);\n#endif\n\n    uint32_t col_bit_max = 8 - bpp;\n    uint32_t col_bit_row_ofs = (box_w + col_start - col_end) * bpp;\n\n    for(row = row_start ; row < row_end; row++) {\n#if LV_DRAW_COMPLEX\n        int32_t mask_p_start = mask_p;\n#endif\n        bitmask = bitmask_init >> col_bit;\n        for(col = col_start; col < col_end; col++) {\n            /*Load the pixel's opacity into the mask*/\n            letter_px = (*map_p & bitmask) >> (col_bit_max - col_bit);\n            if(letter_px) {\n                mask_buf[mask_p] = bpp_opa_table_p[letter_px];\n            }\n            else {\n                mask_buf[mask_p] = 0;\n            }\n\n            /*Go to the next column*/\n            if(col_bit < col_bit_max) {\n                col_bit += bpp;\n                bitmask = bitmask >> bpp;\n            }\n            else {\n                col_bit = 0;\n                bitmask = bitmask_init;\n                map_p++;\n            }\n\n            /*Next mask byte*/\n            mask_p++;\n        }\n\n#if LV_DRAW_COMPLEX\n        /*Apply masks if any*/\n        if(mask_any) {\n            lv_draw_mask_res_t mask_res = lv_draw_mask_apply(mask_buf + mask_p_start, fill_area.x1, fill_area.y2,\n                                                             lv_area_get_width(&fill_area));\n            if(mask_res == LV_DRAW_MASK_RES_TRANSP) {\n                lv_memset_00(mask_buf + mask_p_start, lv_area_get_width(&fill_area));\n            }\n        }\n#endif\n\n        if((uint32_t) mask_p + (col_end - col_start) < mask_buf_size) {\n            fill_area.y2 ++;\n        }\n        else {\n            _lv_blend_fill(clip_area, &fill_area,\n                           color, mask_buf, LV_DRAW_MASK_RES_CHANGED, LV_OPA_COVER,\n                           blend_mode);\n\n            fill_area.y1 = fill_area.y2 + 1;\n            fill_area.y2 = fill_area.y1;\n            mask_p = 0;\n        }\n\n        col_bit += col_bit_row_ofs;\n        map_p += (col_bit >> 3);\n        col_bit = col_bit & 0x7;\n    }\n\n    /*Flush the last part*/\n    if(fill_area.y1 != fill_area.y2) {\n        fill_area.y2--;\n        _lv_blend_fill(clip_area, &fill_area,\n                       color, mask_buf, LV_DRAW_MASK_RES_CHANGED, LV_OPA_COVER,\n                       blend_mode);\n        mask_p = 0;\n    }\n\n    lv_mem_buf_release(mask_buf);\n}"}, "hex_char_to_num": {"type": "Function", "def": "static uint8_t hex_char_to_num(char hex)", "sline": 841, "body": "{\n    uint8_t result = 0;\n\n    if(hex >= '0' && hex <= '9') {\n        result = hex - '0';\n    }\n    else {\n        if(hex >= 'a') hex -= 'a' - 'A'; /*Convert to upper case*/\n\n        switch(hex) {\n            case 'A':\n                result = 10;\n                break;\n            case 'B':\n                result = 11;\n                break;\n            case 'C':\n                result = 12;\n                break;\n            case 'D':\n                result = 13;\n                break;\n            case 'E':\n                result = 14;\n                break;\n            case 'F':\n                result = 15;\n                break;\n            default:\n                result = 0;\n                break;\n        }\n    }\n\n    return result;\n}"}, "_lv_bpp1_opa_table": {"type": "Variable", "def": "const uint8_t _lv_bpp1_opa_table[2]  = {0, 255}", "sline": 60}, "_lv_bpp2_opa_table": {"type": "Variable", "def": "const uint8_t _lv_bpp2_opa_table[4]  = {0, 85, 170, 255}", "sline": 61}, "_lv_bpp3_opa_table": {"type": "Variable", "def": "const uint8_t _lv_bpp3_opa_table[8]  = {0, 36,  73, 109,   /*Opacity mapping with bpp = 3*/\n                                        146, 182,  219, 255\n                                       }", "sline": 63}, "_lv_bpp4_opa_table": {"type": "Variable", "def": "const uint8_t _lv_bpp4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/\n                                        68, 85, 102, 119,\n                                        136, 153, 170, 187,\n                                        204, 221, 238, 255\n                                       }", "sline": 67}, "_lv_bpp8_opa_table": {"type": "Variable", "def": "const uint8_t _lv_bpp8_opa_table[256] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                                         16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n                                         32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n                                         48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,\n                                         64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n                                         80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\n                                         96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,\n                                         112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,\n                                         128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,\n                                         144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n                                         160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,\n                                         176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,\n                                         192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,\n                                         208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,\n                                         224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,\n                                         240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255\n                                        }", "sline": 73}, "lv_draw_label_dsc_init": {"type": "Function", "def": "void lv_draw_label_dsc_init(lv_draw_label_dsc_t * dsc)", "sline": 99, "body": "{\n    lv_memset_00(dsc, sizeof(lv_draw_label_dsc_t));\n    dsc->opa = LV_OPA_COVER;\n    dsc->color = lv_color_black();\n    dsc->font = LV_FONT_DEFAULT;\n    dsc->sel_start = LV_DRAW_LABEL_NO_TXT_SEL;\n    dsc->sel_end = LV_DRAW_LABEL_NO_TXT_SEL;\n    dsc->sel_color = lv_color_black();\n    dsc->sel_bg_color = lv_palette_main(LV_PALETTE_BLUE);\n    dsc->bidi_dir = LV_BASE_DIR_LTR;\n}"}, "lv_draw_letter": {"type": "Function", "def": "void lv_draw_letter(const lv_point_t * pos_p, const lv_area_t * clip_area,\n                                          const lv_font_t * font_p,\n                                          uint32_t letter,\n                                          lv_color_t color, lv_opa_t opa, lv_blend_mode_t blend_mode)", "sline": 412, "body": "{\n    if(opa < LV_OPA_MIN) return;\n    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;\n\n    if(font_p == NULL) {\n        LV_LOG_WARN(\"lv_draw_letter: font is NULL\");\n        return;\n    }\n\n    lv_font_glyph_dsc_t g;\n    bool g_ret = lv_font_get_glyph_dsc(font_p, &g, letter, '\\0');\n    if(g_ret == false)  {\n        /*Add warning if the dsc is not found\n         *but do not print warning for non printable ASCII chars (e.g. '\\n')*/\n        if(letter >= 0x20 &&\n           letter != 0xf8ff && /*LV_SYMBOL_DUMMY*/\n           letter != 0x200c) { /*ZERO WIDTH NON-JOINER*/\n            LV_LOG_WARN(\"lv_draw_letter: glyph dsc. not found for U+%X\", (unsigned int)letter);\n        }\n        return;\n    }\n\n    /*Don't draw anything if the character is empty. E.g. space*/\n    if((g.box_h == 0) || (g.box_w == 0)) return;\n\n    int32_t pos_x = pos_p->x + g.ofs_x;\n    int32_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;\n\n    /*If the letter is completely out of mask don't draw it*/\n    if(pos_x + g.box_w < clip_area->x1 ||\n       pos_x > clip_area->x2 ||\n       pos_y + g.box_h < clip_area->y1 ||\n       pos_y > clip_area->y2)  {\n        return;\n    }\n\n    const uint8_t * map_p = lv_font_get_glyph_bitmap(font_p, letter);\n    if(map_p == NULL) {\n        LV_LOG_WARN(\"lv_draw_letter: character's bitmap not found\");\n        return;\n    }\n\n    if(font_p->subpx) {\n#if LV_DRAW_COMPLEX && LV_USE_FONT_SUBPX\n        draw_letter_subpx(pos_x, pos_y, &g, clip_area, map_p, color, opa, blend_mode);\n#else\n        LV_LOG_WARN(\"Can't draw sub-pixel rendered letter because LV_USE_FONT_SUBPX == 0 in lv_conf.h\");\n#endif\n    }\n    else {\n        draw_letter_normal(pos_x, pos_y, &g, clip_area, map_p, color, opa, blend_mode);\n    }\n}"}, "carbit_updater/lvgl/src/draw/lv_draw_label.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_draw_label.c"}}, "carbit_updater/lvgl/src/widgets/lv_canvas.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "lv_obj": {"type": "Variable", "def": "#include ../core/lv_obj.h", "sline": 20}, "lv_img": {"type": "Variable", "def": "#include ../widgets/lv_img.h", "sline": 21}, "lv_draw_img": {"type": "Variable", "def": "#include ../draw/lv_draw_img.h", "sline": 22}, "lv_canvas_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_canvas_class", "sline": 31}, "lv_canvas_t.img": {"type": "Variable", "def": "lv_img_t img", "sline": 35, "in_struct": "lv_canvas_t"}, "lv_canvas_t.dsc": {"type": "Variable", "def": "lv_img_dsc_t dsc", "sline": 36, "in_struct": "lv_canvas_t"}, "lv_canvas_t": {"type": "Variable", "def": "typedef struct {\n    lv_img_t img;\n    lv_img_dsc_t dsc;\n} lv_canvas_t", "sline": 37, "docstring": "/*Data of canvas*/"}, "lv_canvas_create": {"type": "Function", "def": "lv_obj_t * lv_canvas_create(lv_obj_t * parent)", "sline": 48}, "lv_canvas_set_buffer": {"type": "Function", "def": "void lv_canvas_set_buffer(lv_obj_t * canvas, void * buf, lv_coord_t w, lv_coord_t h, lv_img_cf_t cf)", "sline": 66}, "lv_canvas_set_px_color": {"type": "Function", "def": "void lv_canvas_set_px_color(lv_obj_t * canvas, lv_coord_t x, lv_coord_t y, lv_color_t c)", "sline": 75}, "lv_canvas_set_px": {"type": "Function", "def": "static inline void lv_canvas_set_px(lv_obj_t * canvas, lv_coord_t x, lv_coord_t y, lv_color_t c)", "sline": 80, "docstring": "/**", "body": "{\n    lv_canvas_set_px_color(canvas, x, y, c);\n}"}, "lv_canvas_set_px_opa": {"type": "Function", "def": "void lv_canvas_set_px_opa(lv_obj_t * canvas, lv_coord_t x, lv_coord_t y, lv_opa_t opa)", "sline": 92}, "lv_canvas_set_palette": {"type": "Function", "def": "void lv_canvas_set_palette(lv_obj_t * canvas, uint8_t id, lv_color_t c)", "sline": 105}, "lv_canvas_get_px": {"type": "Function", "def": "lv_color_t lv_canvas_get_px(lv_obj_t * canvas, lv_coord_t x, lv_coord_t y)", "sline": 118}, "lv_canvas_get_img": {"type": "Function", "def": "lv_img_dsc_t * lv_canvas_get_img(lv_obj_t * canvas)", "sline": 125}, "lv_canvas_copy_buf": {"type": "Function", "def": "void lv_canvas_copy_buf(lv_obj_t * canvas, const void * to_copy, lv_coord_t x, lv_coord_t y, lv_coord_t w,\n                        lv_coord_t h)", "sline": 141}, "lv_canvas_transform": {"type": "Function", "def": "void lv_canvas_transform(lv_obj_t * canvas, lv_img_dsc_t * img, int16_t angle, uint16_t zoom, lv_coord_t offset_x,\n                         lv_coord_t offset_y,\n                         int32_t pivot_x, int32_t pivot_y, bool antialias)", "sline": 159}, "lv_canvas_blur_hor": {"type": "Function", "def": "void lv_canvas_blur_hor(lv_obj_t * canvas, const lv_area_t * area, uint16_t r)", "sline": 169}, "lv_canvas_blur_ver": {"type": "Function", "def": "void lv_canvas_blur_ver(lv_obj_t * canvas, const lv_area_t * area, uint16_t r)", "sline": 177}, "lv_canvas_fill_bg": {"type": "Function", "def": "void lv_canvas_fill_bg(lv_obj_t * canvas, lv_color_t color, lv_opa_t opa)", "sline": 185}, "lv_canvas_draw_rect": {"type": "Function", "def": "void lv_canvas_draw_rect(lv_obj_t * canvas, lv_coord_t x, lv_coord_t y, lv_coord_t w, lv_coord_t h,\n                         const lv_draw_rect_dsc_t * draw_dsc)", "sline": 196}, "lv_canvas_draw_text": {"type": "Function", "def": "void lv_canvas_draw_text(lv_obj_t * canvas, lv_coord_t x, lv_coord_t y, lv_coord_t max_w,\n                         lv_draw_label_dsc_t * draw_dsc, const char * txt)", "sline": 208}, "lv_canvas_draw_img": {"type": "Function", "def": "void lv_canvas_draw_img(lv_obj_t * canvas, lv_coord_t x, lv_coord_t y, const void * src,\n                        const lv_draw_img_dsc_t * draw_dsc)", "sline": 219}, "lv_canvas_draw_line": {"type": "Function", "def": "void lv_canvas_draw_line(lv_obj_t * canvas, const lv_point_t points[], uint32_t point_cnt,\n                         const lv_draw_line_dsc_t * draw_dsc)", "sline": 229}, "lv_canvas_draw_polygon": {"type": "Function", "def": "void lv_canvas_draw_polygon(lv_obj_t * canvas, const lv_point_t points[], uint32_t point_cnt,\n                            const lv_draw_rect_dsc_t * draw_dsc)", "sline": 239}, "lv_canvas_draw_arc": {"type": "Function", "def": "void lv_canvas_draw_arc(lv_obj_t * canvas, lv_coord_t x, lv_coord_t y, lv_coord_t r, int32_t start_angle,\n                        int32_t end_angle, const lv_draw_arc_dsc_t * draw_dsc)", "sline": 252}, "carbit_updater/lvgl/src/widgets/lv_canvas.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_canvas.h"}}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_mask.c": {"lv_conf_internal": {"type": "Variable", "def": "#include ../../lv_conf_internal.h", "sline": 10}, "carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_mask.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/sdl/lv_gpu_sdl_mask.c"}}, "carbit_updater/lvgl/src/draw/lv_draw_img.h": {"lv_img_decoder": {"type": "Variable", "def": "#include lv_img_decoder.h", "sline": 16, "include": ["carbit_updater/lvgl/src/draw/lv_img_decoder.h", null]}, "lv_img_buf": {"type": "Variable", "def": "#include lv_img_buf.h", "sline": 17, "include": ["carbit_updater/lvgl/src/draw/lv_img_buf.h", null]}, "lv_draw_blend": {"type": "Variable", "def": "#include lv_draw_blend.h", "sline": 18, "include": ["carbit_updater/lvgl/src/draw/lv_draw_blend.h", null]}, "lv_draw_img_dsc_t.angle": {"type": "Variable", "def": "uint16_t angle", "sline": 34, "in_struct": "lv_draw_img_dsc_t"}, "lv_draw_img_dsc_t.zoom": {"type": "Variable", "def": "uint16_t zoom", "sline": 35, "in_struct": "lv_draw_img_dsc_t"}, "lv_draw_img_dsc_t.pivot": {"type": "Variable", "def": "lv_point_t pivot", "sline": 36, "in_struct": "lv_draw_img_dsc_t"}, "lv_draw_img_dsc_t.recolor": {"type": "Variable", "def": "lv_color_t recolor", "sline": 38, "in_struct": "lv_draw_img_dsc_t"}, "lv_draw_img_dsc_t.recolor_opa": {"type": "Variable", "def": "lv_opa_t recolor_opa", "sline": 39, "in_struct": "lv_draw_img_dsc_t"}, "lv_draw_img_dsc_t.opa": {"type": "Variable", "def": "lv_opa_t opa", "sline": 41, "in_struct": "lv_draw_img_dsc_t"}, "lv_draw_img_dsc_t.blend_mode": {"type": "Variable", "def": "lv_blend_mode_t blend_mode : 4", "sline": 42, "in_struct": "lv_draw_img_dsc_t"}, "lv_draw_img_dsc_t.frame_id": {"type": "Variable", "def": "int32_t frame_id", "sline": 44, "in_struct": "lv_draw_img_dsc_t"}, "lv_draw_img_dsc_t.antialias": {"type": "Variable", "def": "uint8_t antialias       : 1", "sline": 45, "in_struct": "lv_draw_img_dsc_t"}, "lv_draw_img_dsc_t": {"type": "Variable", "def": "typedef struct {\n\n    uint16_t angle;\n    uint16_t zoom;\n    lv_point_t pivot;\n\n    lv_color_t recolor;\n    lv_opa_t recolor_opa;\n\n    lv_opa_t opa;\n    lv_blend_mode_t blend_mode : 4;\n\n    int32_t frame_id;\n    uint8_t antialias       : 1;\n} lv_draw_img_dsc_t", "sline": 46}, "lv_draw_img_dsc_init": {"type": "Function", "def": "void lv_draw_img_dsc_init(lv_draw_img_dsc_t * dsc)", "sline": 52}, "lv_draw_img": {"type": "Function", "def": "void lv_draw_img(const lv_area_t * coords, const lv_area_t * mask, const void * src, const lv_draw_img_dsc_t * dsc)", "sline": 60}, "lv_img_src_get_type": {"type": "Function", "def": "lv_img_src_t lv_img_src_get_type(const void * src)", "sline": 70}, "lv_img_cf_get_px_size": {"type": "Function", "def": "uint8_t lv_img_cf_get_px_size(lv_img_cf_t cf)", "sline": 77}, "lv_img_cf_is_chroma_keyed": {"type": "Function", "def": "bool lv_img_cf_is_chroma_keyed(lv_img_cf_t cf)", "sline": 84}, "lv_img_cf_has_alpha": {"type": "Function", "def": "bool lv_img_cf_has_alpha(lv_img_cf_t cf)", "sline": 91}, "carbit_updater/lvgl/src/draw/lv_draw_img.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_draw_img.h"}}, "carbit_updater/include/properties.h": {"property_get": {"type": "Function", "def": "int property_get(const char *key, char *value, const char *default_value)", "sline": 11}, "property_set": {"type": "Function", "def": "int property_set(const char *key, const char *value)", "sline": 13}, "property_list": {"type": "Function", "def": "int property_list(char *path)", "sline": 16}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/include/properties.h:21:1)": {"type": "Enum", "def": "enum {\n    kSystemPropertyUnknown = 0,\n    kSystemPropertyGet,\n    kSystemPropertySet,\n    kSystemPropertyList\n}", "sline": 21}, "carbit_updater/include/properties.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/include/properties.h"}}, "carbit_updater/lvgl/src/extra/lv_extra.c": {"lvgl": {"type": "Variable", "def": "#include ../lvgl.h", "sline": 9}, "lv_extra_init": {"type": "Function", "def": "void lv_extra_init(void)", "sline": 35, "body": "{\n#if LV_USE_FLEX\n    lv_flex_init();\n#endif\n\n#if LV_USE_GRID\n    lv_grid_init();\n#endif\n\n#if LV_USE_FS_FATFS != '\\0'\n    lv_fs_fatfs_init();\n#endif\n\n#if LV_USE_FS_STDIO != '\\0'\n    lv_fs_stdio_init();\n#endif\n\n#if LV_USE_FS_POSIX != '\\0'\n    lv_fs_posix_init();\n#endif\n\n#if LV_USE_FS_WIN32 != '\\0'\n    lv_fs_win32_init();\n#endif\n\n#if LV_USE_PNG\n    lv_png_init();\n#endif\n\n#if LV_USE_SJPG\n    lv_split_jpeg_init();\n#endif\n\n#if LV_USE_BMP\n    lv_bmp_init();\n#endif\n\n#if LV_USE_FREETYPE\n    /*Init freetype library\n     *Cache max 64 faces and 1 size*/\n    lv_freetype_init(0, 0, LV_FREETYPE_CACHE_SIZE);\n#endif\n}"}, "carbit_updater/lvgl/src/extra/lv_extra.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/lv_extra.c"}}, "carbit_updater/lv_drivers/indev/libinput.c": {"libinput_drv": {"type": "Variable", "def": "#include libinput_drv.h", "sline": 9, "include": ["carbit_updater/lv_drivers/indev/libinput_drv.h", null]}, "carbit_updater/lv_drivers/indev/libinput.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/indev/libinput.c"}}, "carbit_updater/lv_drivers/win32drv/win32drv.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 17}, "carbit_updater/lv_drivers/win32drv/win32drv.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/win32drv/win32drv.h"}}, "carbit_updater/lvgl/src/draw/lv_img_cache.h": {"lv_img_decoder": {"type": "Variable", "def": "#include lv_img_decoder.h", "sline": 16, "include": ["carbit_updater/lvgl/src/draw/lv_img_decoder.h", null]}, "_lv_img_cache_entry_t.dec_dsc": {"type": "Variable", "def": "lv_img_decoder_dsc_t dec_dsc", "sline": 32, "in_struct": "_lv_img_cache_entry_t"}, "_lv_img_cache_entry_t.life": {"type": "Variable", "def": "int32_t life", "sline": 37, "in_struct": "_lv_img_cache_entry_t"}, "_lv_img_cache_entry_t": {"type": "Variable", "def": "typedef struct {\n    lv_img_decoder_dsc_t dec_dsc; /**< Image information*/\n\n    /** Count the cache entries's life. Add `time_to_open` to `life` when the entry is used.\n     * Decrement all lifes by one every in every ::lv_img_cache_open.\n     * If life == 0 the entry can be reused*/\n    int32_t life;\n} _lv_img_cache_entry_t", "sline": 38}, "_lv_img_cache_open": {"type": "Function", "def": "_lv_img_cache_entry_t * _lv_img_cache_open(const void * src, lv_color_t color, int32_t frame_id)", "sline": 53}, "lv_img_cache_set_size": {"type": "Function", "def": "void lv_img_cache_set_size(uint16_t new_slot_num)", "sline": 61}, "lv_img_cache_invalidate_src": {"type": "Function", "def": "void lv_img_cache_invalidate_src(const void * src)", "sline": 68}, "carbit_updater/lvgl/src/draw/lv_img_cache.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_img_cache.h"}}, "carbit_updater/lvgl/src/draw/lv_draw_arc.h": {"lv_draw_line": {"type": "Variable", "def": "#include lv_draw_line.h", "sline": 16, "include": ["carbit_updater/lvgl/src/draw/lv_draw_line.h", null]}, "lv_draw_arc_dsc_t.color": {"type": "Variable", "def": "lv_color_t color", "sline": 26, "in_struct": "lv_draw_arc_dsc_t"}, "lv_draw_arc_dsc_t.width": {"type": "Variable", "def": "lv_coord_t width", "sline": 27, "in_struct": "lv_draw_arc_dsc_t"}, "lv_draw_arc_dsc_t.img_src": {"type": "Variable", "def": "const void * img_src", "sline": 28, "in_struct": "lv_draw_arc_dsc_t"}, "lv_draw_arc_dsc_t.opa": {"type": "Variable", "def": "lv_opa_t opa", "sline": 29, "in_struct": "lv_draw_arc_dsc_t"}, "lv_draw_arc_dsc_t.blend_mode": {"type": "Variable", "def": "lv_blend_mode_t blend_mode  : 2", "sline": 30, "in_struct": "lv_draw_arc_dsc_t"}, "lv_draw_arc_dsc_t.rounded": {"type": "Variable", "def": "uint8_t rounded : 1", "sline": 31, "in_struct": "lv_draw_arc_dsc_t"}, "lv_draw_arc_dsc_t": {"type": "Variable", "def": "typedef struct {\n    lv_color_t color;\n    lv_coord_t width;\n    const void * img_src;\n    lv_opa_t opa;\n    lv_blend_mode_t blend_mode  : 2;\n    uint8_t rounded : 1;\n} lv_draw_arc_dsc_t", "sline": 32, "docstring": "/**********************"}, "lv_draw_arc_dsc_init": {"type": "Function", "def": "void lv_draw_arc_dsc_init(lv_draw_arc_dsc_t * dsc)", "sline": 38}, "lv_draw_arc": {"type": "Function", "def": "void lv_draw_arc(lv_coord_t center_x, lv_coord_t center_y, uint16_t radius,  uint16_t start_angle, uint16_t end_angle,\n                 const lv_area_t * clip_area, const lv_draw_arc_dsc_t * dsc)", "sline": 51}, "lv_draw_arc_get_area": {"type": "Function", "def": "void lv_draw_arc_get_area(lv_coord_t x, lv_coord_t y, uint16_t radius,  uint16_t start_angle, uint16_t end_angle,\n                          lv_coord_t w, bool rounded, lv_area_t * area)", "sline": 65}, "carbit_updater/lvgl/src/draw/lv_draw_arc.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_draw_arc.h"}}, "carbit_updater/lvgl/src/core/lv_disp.h": {"lv_hal": {"type": "Variable", "def": "#include ../hal/lv_hal.h", "sline": 16}, "lv_obj": {"type": "Variable", "def": "#include lv_obj.h", "sline": 17, "include": ["carbit_updater/lvgl/src/core/lv_obj.h", null]}, "lv_theme": {"type": "Variable", "def": "#include lv_theme.h", "sline": 18, "include": ["carbit_updater/lvgl/src/core/lv_theme.h", null]}, "lv_scr_load_anim_t": {"type": "Variable", "def": "typedef enum {\n    LV_SCR_LOAD_ANIM_NONE,\n    LV_SCR_LOAD_ANIM_OVER_LEFT,\n    LV_SCR_LOAD_ANIM_OVER_RIGHT,\n    LV_SCR_LOAD_ANIM_OVER_TOP,\n    LV_SCR_LOAD_ANIM_OVER_BOTTOM,\n    LV_SCR_LOAD_ANIM_MOVE_LEFT,\n    LV_SCR_LOAD_ANIM_MOVE_RIGHT,\n    LV_SCR_LOAD_ANIM_MOVE_TOP,\n    LV_SCR_LOAD_ANIM_MOVE_BOTTOM,\n    LV_SCR_LOAD_ANIM_FADE_ON,\n} lv_scr_load_anim_t", "sline": 39}, "lv_disp_get_scr_act": {"type": "Function", "def": "lv_obj_t * lv_disp_get_scr_act(lv_disp_t * disp)", "sline": 51}, "lv_disp_get_scr_prev": {"type": "Function", "def": "lv_obj_t * lv_disp_get_scr_prev(lv_disp_t * disp)", "sline": 59}, "lv_disp_load_scr": {"type": "Function", "def": "void lv_disp_load_scr(lv_obj_t * scr)", "sline": 65}, "lv_disp_get_layer_top": {"type": "Function", "def": "lv_obj_t * lv_disp_get_layer_top(lv_disp_t * disp)", "sline": 72}, "lv_disp_get_layer_sys": {"type": "Function", "def": "lv_obj_t * lv_disp_get_layer_sys(lv_disp_t * disp)", "sline": 80}, "lv_disp_set_theme": {"type": "Function", "def": "void lv_disp_set_theme(lv_disp_t * disp, lv_theme_t * th)", "sline": 86}, "lv_disp_get_theme": {"type": "Function", "def": "lv_theme_t * lv_disp_get_theme(lv_disp_t * disp)", "sline": 93}, "lv_disp_set_bg_color": {"type": "Function", "def": "void lv_disp_set_bg_color(lv_disp_t * disp, lv_color_t color)", "sline": 100}, "lv_disp_set_bg_image": {"type": "Function", "def": "void lv_disp_set_bg_image(lv_disp_t * disp, const void  * img_src)", "sline": 107}, "lv_disp_set_bg_opa": {"type": "Function", "def": "void lv_disp_set_bg_opa(lv_disp_t * disp, lv_opa_t opa)", "sline": 114}, "lv_scr_load_anim": {"type": "Function", "def": "void lv_scr_load_anim(lv_obj_t * scr, lv_scr_load_anim_t anim_type, uint32_t time, uint32_t delay, bool auto_del)", "sline": 124}, "lv_disp_get_inactive_time": {"type": "Function", "def": "uint32_t lv_disp_get_inactive_time(const lv_disp_t * disp)", "sline": 131}, "lv_disp_trig_activity": {"type": "Function", "def": "void lv_disp_trig_activity(lv_disp_t * disp)", "sline": 137}, "lv_disp_clean_dcache": {"type": "Function", "def": "void lv_disp_clean_dcache(lv_disp_t * disp)", "sline": 143}, "_lv_disp_get_refr_timer": {"type": "Function", "def": "lv_timer_t * _lv_disp_get_refr_timer(lv_disp_t * disp)", "sline": 151}, "lv_scr_act": {"type": "Function", "def": "static inline lv_obj_t * lv_scr_act(void)", "sline": 162, "body": "{\n    return lv_disp_get_scr_act(lv_disp_get_default());\n}"}, "lv_layer_top": {"type": "Function", "def": "static inline lv_obj_t * lv_layer_top(void)", "sline": 171, "body": "{\n    return lv_disp_get_layer_top(lv_disp_get_default());\n}"}, "lv_layer_sys": {"type": "Function", "def": "static inline lv_obj_t * lv_layer_sys(void)", "sline": 180, "body": "{\n    return lv_disp_get_layer_sys(lv_disp_get_default());\n}"}, "lv_scr_load": {"type": "Function", "def": "static inline void lv_scr_load(lv_obj_t * scr)", "sline": 185, "body": "{\n    lv_disp_load_scr(scr);\n}"}, "lv_dpx": {"type": "Function", "def": "static inline lv_coord_t lv_dpx(lv_coord_t n)", "sline": 221, "body": "{\n    return LV_DPX(n);\n}"}, "lv_disp_dpx": {"type": "Function", "def": "static inline lv_coord_t lv_disp_dpx(const lv_disp_t * disp, lv_coord_t n)", "sline": 235, "body": "{\n    return _LV_DPX_CALC(lv_disp_get_dpi(disp), n);\n}"}, "carbit_updater/lvgl/src/core/lv_disp.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_disp.h"}}, "carbit_updater/lv_drivers/display/sunxifb.c": {"sunxifb": {"type": "Variable", "def": "#include sunxifb.h", "sline": 9, "include": ["carbit_updater/lv_drivers/display/sunxifb.h", null]}, "stdlib": {"type": "Variable", "def": "#include stdlib.h", "sline": 12}, "unistd": {"type": "Variable", "def": "#include unistd.h", "sline": 13}, "stddef": {"type": "Variable", "def": "#include stddef.h", "sline": 14}, "stdio": {"type": "Variable", "def": "#include stdio.h", "sline": 15}, "fcntl": {"type": "Variable", "def": "#include fcntl.h", "sline": 16}, "mman": {"type": "Variable", "def": "#include sys/mman.h", "sline": 17}, "ioctl": {"type": "Variable", "def": "#include sys/ioctl.h", "sline": 18}, "fb": {"type": "Variable", "def": "#include linux/fb.h", "sline": 19}, "vinfo": {"type": "Variable", "def": "static struct fb_var_screeninfo vinfo", "sline": 52}, "finfo": {"type": "Variable", "def": "static struct fb_fix_screeninfo finfo", "sline": 53}, "fbp": {"type": "Variable", "def": "static char *fbp = 0", "sline": 54}, "screensize": {"type": "Variable", "def": "static long int screensize = 0", "sline": 55}, "fbfd": {"type": "Variable", "def": "static int fbfd = 0", "sline": 56}, "fbp_w": {"type": "Variable", "def": "static uint32_t fbp_w", "sline": 57}, "fbp_h": {"type": "Variable", "def": "static uint32_t fbp_h", "sline": 58}, "fbp_line_length": {"type": "Variable", "def": "static uint32_t fbp_line_length", "sline": 59}, "sunxifb_init": {"type": "Function", "def": "void sunxifb_init(uint32_t rotated)", "sline": 94, "docstring": "/**********************", "body": "{\n    // Open the file for reading and writing\n    fbfd = open(SUNXIFB_PATH, O_RDWR);\n    if (fbfd == -1) {\n        perror(\"Error: cannot open framebuffer device\");\n        return;\n    }\n\n    // Get fixed screen information\n    if (ioctl(fbfd, FBIOGET_FSCREENINFO, &finfo) == -1) {\n        perror(\"Error reading fixed information\");\n        return;\n    }\n\n    // Get variable screen information\n    if (ioctl(fbfd, FBIOGET_VSCREENINFO, &vinfo) == -1) {\n        perror(\"Error reading variable information\");\n        return;\n    }\n\n#if defined(USE_SUNXIFB_DOUBLE_BUFFER) && defined(USE_SUNXIFB_CACHE)\n    // Speed up the speed of buf copy\n    uintptr_t args[2] = { 1, 0 };\n    if (ioctl(fbfd, FBIO_ENABLE_CACHE, args) < 0) {\n        perror(\"Error: FBIO_ENABLE_CACHE fail\");\n    }\n#endif /* USE_SUNXIFB_CACHE */\n\n    // Figure out the size of the screen in bytes\n    screensize = finfo.smem_len; //finfo.line_length * vinfo.yres;\n\n    // Map the device to memory\n    fbp = (char*) mmap(0, screensize, PROT_READ | PROT_WRITE, MAP_SHARED, fbfd,\n            0);\n    if ((intptr_t) fbp == -1) {\n        perror(\"Error: failed to map framebuffer device to memory\");\n        return;\n    }\n\n    printf(\"wh=%dx%d, vwh=%dx%d, bpp=%d, rotated=%d\\n\", vinfo.xres, vinfo.yres,\n            vinfo.xres_virtual, vinfo.yres_virtual, vinfo.bits_per_pixel,\n            rotated);\n\n    fbp_w = vinfo.xres;\n    fbp_h = vinfo.yres;\n    fbp_line_length = finfo.line_length;\n\n#ifdef USE_SUNXIFB_DOUBLE_BUFFER\n    memset(&sinfo, 0, sizeof(struct sunxifb_info));\n    sinfo.dbuf_en = true;\n    // Do not clear fb and pointer to back fb\n    sinfo.fbnum = (uint32_t)(screensize / (finfo.line_length * vinfo.yres));\n    if (sinfo.fbnum > 1) {\n        printf(\"Turn on double buffering.\\n\");\n\n        sinfo.screenfbp[0] = fbp;\n        sinfo.screenfbp[1] = fbp + finfo.line_length * vinfo.yres;\n\n        if (vinfo.yoffset == 0) {\n            sinfo.fbindex = !sinfo.fbindex;\n            fbp = sinfo.screenfbp[sinfo.fbindex];\n        }\n\n#ifdef USE_SUNXIFB_G2D\n        printf(\"Turn on 2d hardware acceleration.\\n\");\n\n        sunxifb_g2d_init(vinfo.bits_per_pixel);\n\n        sunxifb_mem_init();\n\n#ifdef USE_SUNXIFB_G2D_ROTATE\n        printf(\"Turn on 2d hardware acceleration rotate.\\n\");\n\n        sinfo.rotatefbp = sunxifb_mem_alloc(finfo.line_length * vinfo.yres, \"sunxifb_rotate\");\n        if (sinfo.rotatefbp == NULL) {\n            perror(\"Error: cannot malloc rotate buffer\");\n            return;\n        }\n\n        fbp = sinfo.rotatefbp;\n        sinfo.rotatefbp_phy = (uintptr_t) sunxifb_mem_get_phyaddr(\n                sinfo.rotatefbp);\n\n        switch (rotated) {\n        case LV_DISP_ROT_90:\n            sinfo.rotated = G2D_ROT_270;\n            sinfo.rotatefbp_w = vinfo.yres;\n            sinfo.rotatefbp_h = vinfo.xres;\n            fbp_w = vinfo.yres;\n            fbp_h = vinfo.xres;\n            fbp_line_length = fbp_w * vinfo.bits_per_pixel / 8;\n            break;\n        case LV_DISP_ROT_180:\n            sinfo.rotated = G2D_ROT_180;\n            sinfo.rotatefbp_w = vinfo.xres;\n            sinfo.rotatefbp_h = vinfo.yres;\n            break;\n        case LV_DISP_ROT_270:\n            sinfo.rotated = G2D_ROT_90;\n            sinfo.rotatefbp_w = vinfo.yres;\n            sinfo.rotatefbp_h = vinfo.xres;\n            fbp_w = vinfo.yres;\n            fbp_h = vinfo.xres;\n            fbp_line_length = fbp_w * vinfo.bits_per_pixel / 8;\n            break;\n        default:\n            sinfo.rotated = G2D_ROT_0;\n            sinfo.rotatefbp_w = vinfo.xres;\n            sinfo.rotatefbp_h = vinfo.yres;\n            break;\n        }\n#endif /* USE_SUNXIFB_G2D_ROTATE */\n#endif /* USE_SUNXIFB_G2D */\n    }\n#else\n    memset(fbp, 0, screensize);\n#endif /* USE_SUNXIFB_DOUBLE_BUFFER */\n}"}, "sunxifb_exit": {"type": "Function", "def": "void sunxifb_exit(void)", "sline": 213, "body": "{\n#ifdef USE_SUNXIFB_DOUBLE_BUFFER\n#ifdef USE_SUNXIFB_CACHE\n    uintptr_t args[2] = { 0, 0 };\n    if (ioctl(fbfd, FBIO_ENABLE_CACHE, args) < 0) {\n        perror(\"Error: FBIO_ENABLE_CACHE fail\");\n    }\n#endif /* USE_SUNXIFB_CACHE */\n\n#ifdef USE_SUNXIFB_G2D\n    sunxifb_g2d_deinit();\n\n#ifdef USE_SUNXIFB_G2D_ROTATE\n    sunxifb_mem_free((void **) &sinfo.rotatefbp, \"sunxifb_rotate\");\n#endif /* USE_SUNXIFB_G2D_ROTATE */\n    sunxifb_mem_deinit();\n#endif /* USE_SUNXIFB_G2D */\n#endif /* USE_SUNXIFB_DOUBLE_BUFFER */\n    close(fbfd);\n}"}, "sunxifb_flush": {"type": "Function", "def": "void sunxifb_flush(lv_disp_drv_t *drv, const lv_area_t *area,\n        lv_color_t *color_p)", "sline": 240, "body": "{\n    if (fbp == NULL || area->x2 < 0 || area->y2 < 0\n            || area->x1 > (int32_t) fbp_w - 1\n            || area->y1 > (int32_t) fbp_h - 1) {\n        lv_disp_flush_ready(drv);\n        return;\n    }\n\n    /*Truncate the area to the screen*/\n    int32_t act_x1 = area->x1 < 0 ? 0 : area->x1;\n    int32_t act_y1 = area->y1 < 0 ? 0 : area->y1;\n    int32_t act_x2 =\n            area->x2 > (int32_t) fbp_w - 1 ? (int32_t) fbp_w - 1 : area->x2;\n    int32_t act_y2 =\n            area->y2 > (int32_t) fbp_h - 1 ? (int32_t) fbp_h - 1 : area->y2;\n\n    lv_coord_t w = (act_x2 - act_x1 + 1);\n    long int location = 0;\n    long int byte_location = 0;\n    unsigned char bit_location = 0;\n\n    /*32 or 24 bit per pixel*/\n    if (vinfo.bits_per_pixel == 32 || vinfo.bits_per_pixel == 24) {\n        uint32_t *fbp32 = (uint32_t*) fbp;\n        int32_t y;\n        for (y = act_y1; y <= act_y2; y++) {\n#ifdef USE_SUNXIFB_DOUBLE_BUFFER\n            if (sinfo.fbnum > 1)\n                location = act_x1 + y * fbp_line_length / 4;\n            else\n#endif /* USE_SUNXIFB_DOUBLE_BUFFER */\n                location = (act_x1 + vinfo.xoffset)\n                        + (y + vinfo.yoffset) * finfo.line_length / 4;\n            memcpy(&fbp32[location], (uint32_t*) color_p,\n                    (act_x2 - act_x1 + 1) * 4);\n            color_p += w;\n        }\n    }\n    /*16 bit per pixel*/\n    else if (vinfo.bits_per_pixel == 16) {\n        uint16_t *fbp16 = (uint16_t*) fbp;\n        int32_t y;\n        for (y = act_y1; y <= act_y2; y++) {\n#ifdef USE_SUNXIFB_DOUBLE_BUFFER\n            if (sinfo.fbnum > 1)\n                location = act_x1 + y * fbp_line_length / 2;\n            else\n#endif /* USE_SUNXIFB_DOUBLE_BUFFER */\n                location = (act_x1 + vinfo.xoffset)\n                        + (y + vinfo.yoffset) * finfo.line_length / 2;\n            memcpy(&fbp16[location], (uint32_t*) color_p,\n                    (act_x2 - act_x1 + 1) * 2);\n            color_p += w;\n        }\n    }\n    /*8 bit per pixel*/\n    else if (vinfo.bits_per_pixel == 8) {\n        uint8_t *fbp8 = (uint8_t*) fbp;\n        int32_t y;\n        for (y = act_y1; y <= act_y2; y++) {\n#ifdef USE_SUNXIFB_DOUBLE_BUFFER\n            if (sinfo.fbnum > 1)\n                location = act_x1 + y * fbp_line_length;\n            else\n#endif /* USE_SUNXIFB_DOUBLE_BUFFER */\n                location = (act_x1 + vinfo.xoffset)\n                        + (y + vinfo.yoffset) * finfo.line_length;\n            memcpy(&fbp8[location], (uint32_t*) color_p, (act_x2 - act_x1 + 1));\n            color_p += w;\n        }\n    }\n    /*1 bit per pixel*/\n    else if (vinfo.bits_per_pixel == 1) {\n        uint8_t *fbp8 = (uint8_t*) fbp;\n        int32_t x;\n        int32_t y;\n        for (y = act_y1; y <= act_y2; y++) {\n            for (x = act_x1; x <= act_x2; x++) {\n#ifdef USE_SUNXIFB_DOUBLE_BUFFER\n                if (sinfo.fbnum > 1)\n                    location = x + y * fbp_w;\n                else\n#endif /* USE_SUNXIFB_DOUBLE_BUFFER */\n                    location = (x + vinfo.xoffset)\n                            + (y + vinfo.yoffset) * vinfo.xres;\n                byte_location = location / 8; /* find the byte we need to change */\n                bit_location = location % 8; /* inside the byte found, find the bit we need to change */\n                fbp8[byte_location] &= ~(((uint8_t)(1)) << bit_location);\n                fbp8[byte_location] |= ((uint8_t)(color_p->full))\n                        << bit_location;\n                color_p++;\n            }\n\n            color_p += area->x2 - act_x2;\n        }\n    } else {\n        /*Not supported bit per pixel*/\n    }\n\n    //May be some direct update command is required\n    //ret = ioctl(state->fd, FBIO_UPDATE, (unsigned long)((uintptr_t)rect));\n\n#ifdef USE_SUNXIFB_DOUBLE_BUFFER\n    if (sinfo.fbnum > 1 && sinfo.dbuf_en && lv_disp_flush_is_last(drv)) {\n#ifdef USE_SUNXIFB_CACHE\n        uintptr_t args[2];\n        args[0] = (uintptr_t) sinfo.screenfbp[sinfo.fbindex];\n        args[1] = finfo.line_length * vinfo.yres;\n        if (ioctl(fbfd, FBIO_CACHE_SYNC, args) < 0) {\n            perror(\"Error: FBIO_CACHE_SYNC fail\");\n        }\n#endif /* USE_SUNXIFB_CACHE */\n\n#ifdef USE_SUNXIFB_G2D_ROTATE\n        sunxifb_mem_flush_cache(sinfo.rotatefbp,\n                finfo.line_length * vinfo.yres);\n        sunxifb_g2d_blit_to_fb(sinfo.rotatefbp_phy, sinfo.rotatefbp_w,\n                sinfo.rotatefbp_h, 0, 0, sinfo.rotatefbp_w,\n                sinfo.rotatefbp_h, finfo.smem_start, vinfo.xres_virtual,\n                vinfo.yres_virtual, 0, sinfo.fbindex * vinfo.yres, vinfo.xres,\n                vinfo.yres, sinfo.rotated);\n#endif /* USE_SUNXIFB_G2D_ROTATE */\n\n        vinfo.yoffset = sinfo.fbindex * vinfo.yres;\n        if (ioctl(fbfd, FBIOPAN_DISPLAY, &vinfo) < 0) {\n            perror(\"Error: FBIOPAN_DISPLAY fail\");\n        }\n\n#if defined(USE_SUNXIFB_G2D) && !defined(USE_SUNXIFB_G2D_ROTATE)\n        sunxifb_g2d_blit_to_fb(finfo.smem_start, vinfo.xres_virtual,\n                vinfo.yres_virtual, 0, sinfo.fbindex * vinfo.yres, vinfo.xres,\n                vinfo.yres, finfo.smem_start, vinfo.xres_virtual,\n                vinfo.yres_virtual, 0, !sinfo.fbindex * vinfo.yres, vinfo.xres,\n                vinfo.yres, G2D_ROT_0);\n#elif !defined(USE_SUNXIFB_G2D_ROTATE)\n        memcpy(sinfo.screenfbp[!sinfo.fbindex], sinfo.screenfbp[sinfo.fbindex],\n                finfo.line_length * vinfo.yres);\n#endif /* USE_SUNXIFB_G2D && !USE_SUNXIFB_G2D_ROTATE */\n\n        sinfo.fbindex = !sinfo.fbindex;\n#ifndef USE_SUNXIFB_G2D_ROTATE\n        fbp = sinfo.screenfbp[sinfo.fbindex];\n#endif /* USE_SUNXIFB_G2D_ROTATE */\n\n#ifdef LV_USE_SUNXIFB_DEBUG\n        static struct timeval new, old;\n        static uint32_t cur_fps, avg_fps, max_fps, min_fps = 60, fps_cnt, first;\n        gettimeofday(&new, NULL);\n        if (new.tv_sec * 1000 - old.tv_sec * 1000 >= 1000) {\n            if (first > 4) {\n                if (first > 64) {\n                    fps_cnt = 0;\n                    avg_fps = 0;\n                    max_fps = 0;\n                    min_fps = 60;\n                    first = 4;\n                }\n                fps_cnt++;\n                avg_fps += cur_fps;\n                if (max_fps < cur_fps)\n                    max_fps = cur_fps;\n                if (min_fps > cur_fps)\n                    min_fps = cur_fps;\n            }\n\n            if (fps_cnt > 0)\n                printf(\"sunxifb_flush fps_cnt=%u cur_fps=%u, max_fps=%u, \"\n                        \"min_fps=%u, cur_page=%d, avg_fps=%.2f\\n\", fps_cnt,\n                        cur_fps, max_fps, min_fps, sinfo.fbindex,\n                        (float) avg_fps / (float) fps_cnt);\n\n            first++;\n            old = new;\n            cur_fps = 0;\n        } else {\n            cur_fps++;\n        }\n#endif /* LV_USE_SUNXIFB_DEBUG */\n    }\n#endif /* USE_SUNXIFB_DOUBLE_BUFFER */\n\n    lv_disp_flush_ready(drv);\n}"}, "sunxifb_get_sizes": {"type": "Function", "def": "void sunxifb_get_sizes(uint32_t *width, uint32_t *height)", "sline": 425, "body": "{\n    if (width)\n        *width = vinfo.xres;\n\n    if (height)\n        *height = vinfo.yres;\n}"}, "sunxifb_alloc": {"type": "Function", "def": "void* sunxifb_alloc(size_t size, char *label)", "sline": 433, "body": "{\n#if defined(LV_USE_SUNXIFB_G2D_FILL) || defined(LV_USE_SUNXIFB_G2D_BLIT) \\\n    || defined(LV_USE_SUNXIFB_G2D_BLEND) || defined(LV_USE_SUNXIFB_G2D_SCALE)\n    return sunxifb_mem_alloc(size, label);\n#else\n    return malloc(size);\n#endif\n}"}, "sunxifb_free": {"type": "Function", "def": "void sunxifb_free(void **data, char *label)", "sline": 442, "body": "{\n#if defined(LV_USE_SUNXIFB_G2D_FILL) || defined(LV_USE_SUNXIFB_G2D_BLIT) \\\n    || defined(LV_USE_SUNXIFB_G2D_BLEND) || defined(LV_USE_SUNXIFB_G2D_SCALE)\n    sunxifb_mem_free(data, label);\n#else\n    if (*data != NULL) {\n        free(*data);\n        *data = NULL;\n    }\n#endif\n}"}, "carbit_updater/lv_drivers/display/sunxifb.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/sunxifb.c"}}, "carbit_updater/lv_drivers/sdl/sdl.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 20}, "carbit_updater/lv_drivers/sdl/sdl.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/sdl/sdl.h"}}, "carbit_updater/lvgl/src/widgets/lv_roller.c": {"lv_roller": {"type": "Variable", "def": "#include lv_roller.h", "sline": 9, "include": ["carbit_updater/lvgl/src/widgets/lv_roller.h", null]}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 12}, "lv_draw": {"type": "Variable", "def": "#include ../draw/lv_draw.h", "sline": 13}, "lv_group": {"type": "Variable", "def": "#include ../core/lv_group.h", "sline": 14}, "lv_indev": {"type": "Variable", "def": "#include ../core/lv_indev.h", "sline": 15}, "lv_indev_scroll": {"type": "Variable", "def": "#include ../core/lv_indev_scroll.h", "sline": 16}, "lv_roller_constructor": {"type": "Function", "def": "static void lv_roller_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 291, "body": "{\n    LV_UNUSED(class_p);\n    lv_roller_t * roller = (lv_roller_t *)obj;\n\n    roller->mode = LV_ROLLER_MODE_NORMAL;\n    roller->option_cnt = 0;\n    roller->sel_opt_id = 0;\n    roller->sel_opt_id_ori = 0;\n\n    lv_obj_clear_flag(obj, LV_OBJ_FLAG_SCROLLABLE);\n    lv_obj_clear_flag(obj, LV_OBJ_FLAG_SCROLL_CHAIN);\n\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * label = lv_obj_class_create_obj(&lv_roller_label_class, obj);\n    lv_obj_class_init_obj(label);\n    lv_roller_set_options(obj, \"Option 1\\nOption 2\\nOption 3\\nOption 4\\nOption 5\", LV_ROLLER_MODE_NORMAL);\n\n    LV_LOG_TRACE(\"finshed\");\n}"}, "lv_roller_event": {"type": "Function", "def": "static void lv_roller_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 312, "body": "{\n    LV_UNUSED(class_p);\n\n    lv_res_t res;\n\n    /*Call the ancestor's event handler*/\n    res = lv_obj_event_base(MY_CLASS, e);\n    if(res != LV_RES_OK) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_roller_t * roller = (lv_roller_t *)obj;\n\n    if(code == LV_EVENT_GET_SELF_SIZE) {\n        lv_point_t * p = lv_event_get_param(e);\n        p->x =  get_selected_label_width(obj);\n    }\n    else if(code == LV_EVENT_STYLE_CHANGED) {\n        lv_obj_t * label = get_label(obj);\n        /*Be sure the label's style is updated before processing the roller*/\n        if(label) lv_event_send(label, LV_EVENT_STYLE_CHANGED, NULL);\n        lv_obj_refresh_self_size(obj);\n        refr_position(obj, false);\n    }\n    else if(code == LV_EVENT_SIZE_CHANGED) {\n        refr_position(obj, false);\n    }\n    else if(code == LV_EVENT_PRESSED) {\n        roller->moved = 0;\n        lv_anim_del(get_label(obj), set_y_anim);\n    }\n    else if(code == LV_EVENT_PRESSING) {\n        lv_indev_t * indev = lv_indev_get_act();\n        lv_point_t p;\n        lv_indev_get_vect(indev, &p);\n        if(p.y) {\n            lv_obj_t * label = get_label(obj);\n            lv_obj_set_y(label, lv_obj_get_y(label) + p.y);\n            roller->moved = 1;\n        }\n    }\n    else if(code == LV_EVENT_RELEASED) {\n        release_handler(obj);\n    }\n    else if(code == LV_EVENT_FOCUSED) {\n        lv_group_t * g             = lv_obj_get_group(obj);\n        bool editing               = lv_group_get_editing(g);\n        lv_indev_type_t indev_type = lv_indev_get_type(lv_indev_get_act());\n\n        /*Encoders need special handling*/\n        if(indev_type == LV_INDEV_TYPE_ENCODER) {\n            /*In navigate mode revert the original value*/\n            if(!editing) {\n                if(roller->sel_opt_id != roller->sel_opt_id_ori) {\n                    roller->sel_opt_id = roller->sel_opt_id_ori;\n                    refr_position(obj, true);\n                }\n            }\n            /*Save the current state when entered to edit mode*/\n            else {\n                roller->sel_opt_id_ori = roller->sel_opt_id;\n            }\n        }\n        else {\n            roller->sel_opt_id_ori = roller->sel_opt_id; /*Save the current value. Used to revert this state if\n                                                                    ENTER won't be pressed*/\n        }\n    }\n    else if(code == LV_EVENT_DEFOCUSED) {\n        /*Revert the original state*/\n        if(roller->sel_opt_id != roller->sel_opt_id_ori) {\n            roller->sel_opt_id = roller->sel_opt_id_ori;\n            refr_position(obj, true);\n        }\n    }\n    else if(code == LV_EVENT_KEY) {\n        char c = *((char *)lv_event_get_param(e));\n        if(c == LV_KEY_RIGHT || c == LV_KEY_DOWN) {\n            if(roller->sel_opt_id + 1 < roller->option_cnt) {\n                uint16_t ori_id = roller->sel_opt_id_ori; /*lv_roller_set_selected will overwrite this*/\n                lv_roller_set_selected(obj, roller->sel_opt_id + 1, true);\n                roller->sel_opt_id_ori = ori_id;\n            }\n        }\n        else if(c == LV_KEY_LEFT || c == LV_KEY_UP) {\n            if(roller->sel_opt_id > 0) {\n                uint16_t ori_id = roller->sel_opt_id_ori; /*lv_roller_set_selected will overwrite this*/\n\n                lv_roller_set_selected(obj, roller->sel_opt_id - 1, true);\n                roller->sel_opt_id_ori = ori_id;\n            }\n        }\n    }\n    else if(code == LV_EVENT_REFR_EXT_DRAW_SIZE) {\n        lv_obj_t * label = get_label(obj);\n        lv_obj_refresh_ext_draw_size(label);\n    }\n    else if(code == LV_EVENT_DRAW_MAIN || code == LV_EVENT_DRAW_POST) {\n        draw_main(e);\n    }\n}"}, "lv_roller_label_event": {"type": "Function", "def": "static void lv_roller_label_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 415, "body": "{\n    LV_UNUSED(class_p);\n\n    lv_res_t res;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    /*LV_EVENT_DRAW_MAIN will be called in the draw function*/\n    if(code != LV_EVENT_DRAW_MAIN) {\n        /* Call the ancestor's event handler */\n        res = lv_obj_event_base(MY_CLASS_LABEL, e);\n        if(res != LV_RES_OK) return;\n    }\n\n    lv_obj_t * label = lv_event_get_target(e);\n    if(code == LV_EVENT_REFR_EXT_DRAW_SIZE) {\n        /*If the selected text has a larger font it needs some extra space to draw it*/\n        lv_coord_t * s = lv_event_get_param(e);\n        lv_obj_t * obj = lv_obj_get_parent(label);\n        lv_coord_t sel_w = get_selected_label_width(obj);\n        lv_coord_t label_w = lv_obj_get_width(label);\n        *s = LV_MAX(*s, sel_w - label_w);\n    }\n    else if(code == LV_EVENT_SIZE_CHANGED) {\n        refr_position(lv_obj_get_parent(label), LV_ANIM_OFF);\n    }\n    else if(code == LV_EVENT_DRAW_MAIN) {\n        draw_label(e);\n    }\n}"}, "draw_main": {"type": "Function", "def": "static void draw_main(lv_event_t * e)", "sline": 447, "body": "{\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n    if(code == LV_EVENT_DRAW_MAIN) {\n        /*Draw the selected rectangle*/\n        const lv_area_t * clip_area = lv_event_get_param(e);\n        lv_area_t sel_area;\n        get_sel_area(obj, &sel_area);\n        lv_draw_rect_dsc_t sel_dsc;\n        lv_draw_rect_dsc_init(&sel_dsc);\n        lv_obj_init_draw_rect_dsc(obj, LV_PART_SELECTED, &sel_dsc);\n        lv_draw_rect(&sel_area, clip_area, &sel_dsc);\n    }\n    /*Post draw when the children are drawn*/\n    else if(code == LV_EVENT_DRAW_POST) {\n        const lv_area_t * clip_area = lv_event_get_param(e);\n\n        lv_draw_label_dsc_t label_dsc;\n        lv_draw_label_dsc_init(&label_dsc);\n        lv_obj_init_draw_label_dsc(obj, LV_PART_SELECTED, &label_dsc);\n\n        /*Redraw the text on the selected area*/\n        lv_area_t sel_area;\n        get_sel_area(obj, &sel_area);\n        lv_area_t mask_sel;\n        bool area_ok;\n        area_ok = _lv_area_intersect(&mask_sel, clip_area, &sel_area);\n        if(area_ok) {\n            lv_obj_t * label = get_label(obj);\n\n            /*Get the size of the \"selected text\"*/\n            lv_point_t res_p;\n            lv_txt_get_size(&res_p, lv_label_get_text(label), label_dsc.font, label_dsc.letter_space, label_dsc.line_space,\n                            lv_obj_get_width(obj), LV_TEXT_FLAG_EXPAND);\n\n            /*Move the selected label proportionally with the background label*/\n            lv_coord_t roller_h = lv_obj_get_height(obj);\n            int32_t label_y_prop = label->coords.y1 - (roller_h / 2 +\n                                                       obj->coords.y1); /*label offset from the middle line of the roller*/\n            label_y_prop = (label_y_prop * 16384) / lv_obj_get_height(\n                               label); /*Proportional position from the middle line (upscaled by << 14)*/\n\n            /*Apply a correction with different line heights*/\n            const lv_font_t * normal_label_font = lv_obj_get_style_text_font(obj, LV_PART_MAIN);\n            lv_coord_t corr = (label_dsc.font->line_height - normal_label_font->line_height) / 2;\n\n            /*Apply the proportional position to the selected text*/\n            res_p.y -= corr;\n            int32_t label_sel_y = roller_h / 2 + obj->coords.y1;\n            label_sel_y += (label_y_prop * res_p.y) >> 14;\n            label_sel_y -= corr;\n\n            lv_coord_t bwidth = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n            lv_coord_t pleft = lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n            lv_coord_t pright = lv_obj_get_style_pad_right(obj, LV_PART_MAIN);\n\n            /*Draw the selected text*/\n            lv_area_t label_sel_area;\n            label_sel_area.x1 = obj->coords.x1 + pleft + bwidth;\n            label_sel_area.y1 = label_sel_y;\n            label_sel_area.x2 = obj->coords.x2 - pright - bwidth;\n            label_sel_area.y2 = label_sel_area.y1 + res_p.y;\n\n            label_dsc.flag |= LV_TEXT_FLAG_EXPAND;\n            lv_draw_label(&label_sel_area, &mask_sel, &label_dsc, lv_label_get_text(label), NULL);\n        }\n    }\n}"}, "draw_label": {"type": "Function", "def": "static void draw_label(lv_event_t * e)", "sline": 517, "body": "{\n    /* Split the drawing of the label into  an upper (above the selected area)\n     * and a lower (below the selected area)*/\n    lv_obj_t * label_obj = lv_event_get_target(e);\n    lv_obj_t * roller = lv_obj_get_parent(label_obj);\n    lv_draw_label_dsc_t label_draw_dsc;\n    lv_draw_label_dsc_init(&label_draw_dsc);\n    lv_obj_init_draw_label_dsc(roller, LV_PART_MAIN, &label_draw_dsc);\n    const lv_area_t * clip_area = lv_event_get_param(e);\n\n    lv_area_t sel_area;\n    get_sel_area(roller, &sel_area);\n\n    lv_area_t clip2;\n    clip2.x1 = label_obj->coords.x1;\n    clip2.y1 = label_obj->coords.y1;\n    clip2.x2 = label_obj->coords.x2;\n    clip2.y2 = sel_area.y1;\n    if(_lv_area_intersect(&clip2, clip_area, &clip2)) {\n        lv_draw_label(&label_obj->coords, &clip2, &label_draw_dsc, lv_label_get_text(label_obj), NULL);\n    }\n\n    clip2.x1 = label_obj->coords.x1;\n    clip2.y1 = sel_area.y2;\n    clip2.x2 = label_obj->coords.x2;\n    clip2.y2 = label_obj->coords.y2;\n    if(_lv_area_intersect(&clip2, clip_area, &clip2)) {\n        lv_draw_label(&label_obj->coords, &clip2, &label_draw_dsc, lv_label_get_text(label_obj), NULL);\n    }\n}"}, "get_sel_area": {"type": "Function", "def": "static void get_sel_area(lv_obj_t * obj, lv_area_t * sel_area)", "sline": 549, "body": "{\n\n    const lv_font_t * font_main = lv_obj_get_style_text_font(obj, LV_PART_MAIN);\n    const lv_font_t * font_sel = lv_obj_get_style_text_font(obj, LV_PART_SELECTED);\n    lv_coord_t font_main_h        = lv_font_get_line_height(font_main);\n    lv_coord_t font_sel_h        = lv_font_get_line_height(font_sel);\n    lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);\n    lv_coord_t d = (font_sel_h + font_main_h) / 2 + line_space;\n    sel_area->y1 = obj->coords.y1 + lv_obj_get_height(obj) / 2 - d / 2;\n    sel_area->y2 = sel_area->y1 + d;\n    lv_area_t roller_coords;\n    lv_obj_get_coords(obj, &roller_coords);\n\n    sel_area->x1 = roller_coords.x1;\n    sel_area->x2 = roller_coords.x2;\n\n}"}, "refr_position": {"type": "Function", "def": "static void refr_position(lv_obj_t * obj, lv_anim_enable_t anim_en)", "sline": 573, "body": "{\n    lv_obj_t * label = get_label(obj);\n    if(label == NULL) return;\n\n    lv_text_align_t align = lv_obj_calculate_style_text_align(label, LV_PART_MAIN, lv_label_get_text(label));\n\n    switch(align) {\n        case LV_TEXT_ALIGN_CENTER:\n            lv_obj_set_x(label, (lv_obj_get_content_width(obj) - lv_obj_get_width(label)) / 2);\n            break;\n        case LV_TEXT_ALIGN_RIGHT:\n            lv_obj_set_x(label, lv_obj_get_content_width(obj) - lv_obj_get_width(label));\n            break;\n        case LV_TEXT_ALIGN_LEFT:\n            lv_obj_set_x(label, 0);\n            break;\n    }\n\n    lv_roller_t * roller = (lv_roller_t *)obj;\n    const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_MAIN);\n    lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);\n    lv_coord_t font_h              = lv_font_get_line_height(font);\n    lv_coord_t h                   = lv_obj_get_content_height(obj);\n    uint16_t anim_time             = lv_obj_get_style_anim_time(obj, LV_PART_MAIN);\n\n    /*Normally the animation's `end_cb` sets correct position of the roller if infinite.\n     *But without animations do it manually*/\n    if(anim_en == LV_ANIM_OFF || anim_time == 0) {\n        inf_normalize(obj);\n    }\n\n    int32_t id = roller->sel_opt_id;\n    lv_coord_t sel_y1 = id * (font_h + line_space);\n    lv_coord_t mid_y1 = h / 2 - font_h / 2;\n\n    lv_coord_t new_y = mid_y1 - sel_y1;\n\n    if(anim_en == LV_ANIM_OFF || anim_time == 0) {\n        lv_anim_del(label, set_y_anim);\n        lv_obj_set_y(label, new_y);\n    }\n    else {\n        lv_anim_t a;\n        lv_anim_init(&a);\n        lv_anim_set_var(&a, label);\n        lv_anim_set_exec_cb(&a, set_y_anim);\n        lv_anim_set_values(&a, lv_obj_get_y(label), new_y);\n        lv_anim_set_time(&a, anim_time);\n        lv_anim_set_ready_cb(&a, scroll_anim_ready_cb);\n        lv_anim_set_path_cb(&a, lv_anim_path_ease_out);\n        lv_anim_start(&a);\n    }\n}"}, "release_handler": {"type": "Function", "def": "static lv_res_t release_handler(lv_obj_t * obj)", "sline": 628, "body": "{\n    lv_obj_t * label = get_label(obj);\n    if(label == NULL) return LV_RES_OK;\n\n    lv_indev_t * indev = lv_indev_get_act();\n    lv_roller_t * roller = (lv_roller_t *)obj;\n\n    /*Leave edit mode once a new option is selected*/\n    lv_indev_type_t indev_type = lv_indev_get_type(indev);\n    if(indev_type == LV_INDEV_TYPE_ENCODER || indev_type == LV_INDEV_TYPE_KEYPAD) {\n        roller->sel_opt_id_ori = roller->sel_opt_id;\n\n        if(indev_type == LV_INDEV_TYPE_ENCODER) {\n            lv_group_t * g      = lv_obj_get_group(obj);\n            if(lv_group_get_editing(g)) {\n                lv_group_set_editing(g, false);\n            }\n        }\n    }\n\n    if(lv_indev_get_type(indev) == LV_INDEV_TYPE_POINTER || lv_indev_get_type(indev) == LV_INDEV_TYPE_BUTTON) {\n        /*Search the clicked option (For KEYPAD and ENCODER the new value should be already set)*/\n        int16_t new_opt  = -1;\n        if(roller->moved == 0) {\n            new_opt = 0;\n            lv_point_t p;\n            lv_indev_get_point(indev, &p);\n            p.y -= label->coords.y1;\n            p.x -= label->coords.x1;\n            uint32_t letter_i;\n            letter_i = lv_label_get_letter_on(label, &p);\n\n            const char * txt  = lv_label_get_text(label);\n            uint32_t i        = 0;\n            uint32_t i_prev   = 0;\n\n            uint32_t letter_cnt = 0;\n            for(letter_cnt = 0; letter_cnt < letter_i; letter_cnt++) {\n                uint32_t letter = _lv_txt_encoded_next(txt, &i);\n                /*Count he lines to reach the clicked letter. But ignore the last '\\n' because it\n                 * still belongs to the clicked line*/\n                if(letter == '\\n' && i_prev != letter_i) new_opt++;\n                i_prev = i;\n            }\n        }\n        else {\n            /*If dragged then align the list to have an element in the middle*/\n            const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_MAIN);\n            lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);\n            lv_coord_t font_h              = lv_font_get_line_height(font);\n\n            lv_coord_t label_unit = font_h + line_space;\n            lv_coord_t mid        = obj->coords.y1 + (obj->coords.y2 - obj->coords.y1) / 2;\n            lv_coord_t label_y1 = label->coords.y1 + lv_indev_scroll_throw_predict(indev, LV_DIR_VER);\n            int32_t id = (mid - label_y1) / label_unit;\n\n            if(id < 0) id = 0;\n            if(id >= roller->option_cnt) id = roller->option_cnt - 1;\n\n            new_opt = id;\n        }\n\n        if(new_opt >= 0) {\n            lv_roller_set_selected(obj, new_opt, LV_ANIM_ON);\n        }\n    }\n\n    uint32_t id  = roller->sel_opt_id; /*Just to use uint32_t in event data*/\n    lv_res_t res = lv_event_send(obj, LV_EVENT_VALUE_CHANGED, &id);\n    return res;\n}"}, "inf_normalize": {"type": "Function", "def": "static void inf_normalize(lv_obj_t * obj)", "sline": 705, "body": "{\n    lv_roller_t * roller = (lv_roller_t *)obj;\n\n    if(roller->mode == LV_ROLLER_MODE_INFINITE) {\n        uint16_t real_id_cnt = roller->option_cnt / LV_ROLLER_INF_PAGES;\n        roller->sel_opt_id = roller->sel_opt_id % real_id_cnt;\n        roller->sel_opt_id += (LV_ROLLER_INF_PAGES / 2) * real_id_cnt; /*Select the middle page*/\n\n        roller->sel_opt_id_ori = roller->sel_opt_id % real_id_cnt;\n        roller->sel_opt_id_ori += (LV_ROLLER_INF_PAGES / 2) * real_id_cnt; /*Select the middle page*/\n\n        /*Move to the new id*/\n        const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_MAIN);\n        lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);\n        lv_coord_t font_h              = lv_font_get_line_height(font);\n        lv_coord_t h                   = lv_obj_get_content_height(obj);\n\n        lv_obj_t * label = get_label(obj);\n\n\n        lv_coord_t sel_y1 = roller->sel_opt_id * (font_h + line_space);\n        lv_coord_t mid_y1 = h / 2 - font_h / 2;\n        lv_coord_t new_y = mid_y1 - sel_y1;\n        lv_obj_set_y(label, new_y);\n    }\n}"}, "get_label": {"type": "Function", "def": "static lv_obj_t * get_label(const lv_obj_t * obj)", "sline": 733, "body": "{\n    return lv_obj_get_child(obj, 0);\n}"}, "get_selected_label_width": {"type": "Function", "def": "static lv_coord_t get_selected_label_width(const lv_obj_t * obj)", "sline": 739, "body": "{\n    lv_obj_t * label = get_label(obj);\n    if(label == NULL) return 0;\n\n    const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_SELECTED);\n    lv_coord_t letter_space = lv_obj_get_style_text_letter_space(obj, LV_PART_SELECTED);\n    const char * txt = lv_label_get_text(label);\n    lv_point_t size;\n    lv_txt_get_size(&size, txt, font, letter_space, 0, LV_COORD_MAX,  LV_TEXT_FLAG_NONE);\n    return size.x;\n}"}, "scroll_anim_ready_cb": {"type": "Function", "def": "static void scroll_anim_ready_cb(lv_anim_t * a)", "sline": 752, "body": "{\n    lv_obj_t * obj = lv_obj_get_parent(a->var); /*The label is animated*/\n    inf_normalize(obj);\n}"}, "set_y_anim": {"type": "Function", "def": "static void set_y_anim(void * obj, int32_t v)", "sline": 759, "body": "{\n    lv_obj_set_y(obj, v);\n}"}, "lv_roller_class": {"type": "Variable", "def": "const lv_obj_class_t lv_roller_class = {\n    .constructor_cb = lv_roller_constructor,\n    .event_cb = lv_roller_event,\n    .width_def = LV_SIZE_CONTENT,\n    .height_def = LV_DPI_DEF,\n    .instance_size = sizeof(lv_roller_t),\n    .editable = LV_OBJ_CLASS_EDITABLE_TRUE,\n    .group_def = LV_OBJ_CLASS_GROUP_DEF_TRUE,\n    .base_class = &lv_obj_class\n}", "sline": 48}, "lv_roller_label_class": {"type": "Variable", "def": "const lv_obj_class_t lv_roller_label_class  = {\n    .event_cb = lv_roller_label_event,\n    .instance_size = sizeof(lv_label_t),\n    .base_class = &lv_label_class\n}", "sline": 59}, "lv_roller_create": {"type": "Function", "def": "lv_obj_t * lv_roller_create(lv_obj_t * parent)", "sline": 78, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_roller_set_options": {"type": "Function", "def": "void lv_roller_set_options(lv_obj_t * obj, const char * options, lv_roller_mode_t mode)", "sline": 96, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(options);\n\n    lv_roller_t * roller = (lv_roller_t *)obj;\n    lv_obj_t * label = get_label(obj);\n\n    roller->sel_opt_id     = 0;\n    roller->sel_opt_id_ori = 0;\n\n    /*Count the '\\n'-s to determine the number of options*/\n    roller->option_cnt = 0;\n    uint32_t cnt;\n    for(cnt = 0; options[cnt] != '\\0'; cnt++) {\n        if(options[cnt] == '\\n') roller->option_cnt++;\n    }\n    roller->option_cnt++; /*Last option has no `\\n`*/\n\n    if(mode == LV_ROLLER_MODE_NORMAL) {\n        roller->mode = LV_ROLLER_MODE_NORMAL;\n        lv_label_set_text(label, options);\n    }\n    else {\n        roller->mode = LV_ROLLER_MODE_INFINITE;\n\n        size_t opt_len = strlen(options) + 1; /*+1 to add '\\n' after option lists*/\n        char * opt_extra = lv_mem_buf_get(opt_len * LV_ROLLER_INF_PAGES);\n        uint8_t i;\n        for(i = 0; i < LV_ROLLER_INF_PAGES; i++) {\n            strcpy(&opt_extra[opt_len * i], options);\n            opt_extra[opt_len * (i + 1) - 1] = '\\n';\n        }\n        opt_extra[opt_len * LV_ROLLER_INF_PAGES - 1] = '\\0';\n        lv_label_set_text(label, opt_extra);\n        lv_mem_buf_release(opt_extra);\n\n        roller->sel_opt_id     = ((LV_ROLLER_INF_PAGES / 2) + 0) * roller->option_cnt;\n\n        roller->option_cnt = roller->option_cnt * LV_ROLLER_INF_PAGES;\n        inf_normalize(obj);\n    }\n\n    roller->sel_opt_id_ori = roller->sel_opt_id;\n\n    /*If the selected text has larger font the label needs some extra draw padding to draw it.*/\n    lv_obj_refresh_ext_draw_size(label);\n\n}"}, "lv_roller_set_selected": {"type": "Function", "def": "void lv_roller_set_selected(lv_obj_t * obj, uint16_t sel_opt, lv_anim_enable_t anim)", "sline": 152, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    /*Set the value even if it's the same as the current value because\n     *if moving to the next option with an animation which was just deleted in the PRESS Call the ancestor's event handler\n     *nothing will continue the animation.*/\n\n    lv_roller_t * roller = (lv_roller_t *)obj;\n\n    /*In infinite mode interpret the new ID relative to the currently visible \"page\"*/\n    if(roller->mode == LV_ROLLER_MODE_INFINITE) {\n        int32_t sel_opt_signed = sel_opt;\n        uint16_t page = roller->sel_opt_id / LV_ROLLER_INF_PAGES;\n\n        /*`sel_opt` should be less than the number of options set by the user.\n         *If it's more then probably it's a reference from not the first page\n         *so normalize `sel_opt`*/\n        if(page != 0) {\n            sel_opt_signed -= page * LV_ROLLER_INF_PAGES;\n        }\n\n        sel_opt = page * LV_ROLLER_INF_PAGES + sel_opt_signed;\n    }\n\n    roller->sel_opt_id     = sel_opt < roller->option_cnt ? sel_opt : roller->option_cnt - 1;\n    roller->sel_opt_id_ori = roller->sel_opt_id;\n\n    refr_position(obj, anim);\n}"}, "lv_roller_set_visible_row_count": {"type": "Function", "def": "void lv_roller_set_visible_row_count(lv_obj_t * obj, uint8_t row_cnt)", "sline": 188, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_MAIN);\n    lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n    lv_obj_set_height(obj, (lv_font_get_line_height(font) + line_space) * row_cnt + 2 * border_width);\n}"}, "lv_roller_get_selected": {"type": "Function", "def": "uint16_t lv_roller_get_selected(const lv_obj_t * obj)", "sline": 207, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_roller_t * roller = (lv_roller_t *)obj;\n    if(roller->mode == LV_ROLLER_MODE_INFINITE) {\n        uint16_t real_id_cnt = roller->option_cnt / LV_ROLLER_INF_PAGES;\n        return roller->sel_opt_id % real_id_cnt;\n    }\n    else {\n        return roller->sel_opt_id;\n    }\n}"}, "lv_roller_get_selected_str": {"type": "Function", "def": "void lv_roller_get_selected_str(const lv_obj_t * obj, char * buf, uint32_t buf_size)", "sline": 227, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_roller_t * roller = (lv_roller_t *)obj;\n    lv_obj_t * label = get_label(obj);\n    uint32_t i;\n    uint16_t line        = 0;\n    const char * opt_txt = lv_label_get_text(label);\n    size_t txt_len     = strlen(opt_txt);\n\n    for(i = 0; i < txt_len && line != roller->sel_opt_id; i++) {\n        if(opt_txt[i] == '\\n') line++;\n    }\n\n    uint32_t c;\n    for(c = 0; i < txt_len && opt_txt[i] != '\\n'; c++, i++) {\n        if(buf_size && c >= buf_size - 1) {\n            LV_LOG_WARN(\"lv_dropdown_get_selected_str: the buffer was too small\");\n            break;\n        }\n        buf[c] = opt_txt[i];\n    }\n\n    buf[c] = '\\0';\n}"}, "lv_roller_get_options": {"type": "Function", "def": "const char * lv_roller_get_options(const lv_obj_t * obj)", "sline": 260, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    return lv_label_get_text(get_label(obj));\n}"}, "lv_roller_get_option_cnt": {"type": "Function", "def": "uint16_t lv_roller_get_option_cnt(const lv_obj_t * obj)", "sline": 273, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_roller_t * roller = (lv_roller_t *)obj;\n    if(roller->mode == LV_ROLLER_MODE_INFINITE) {\n        return roller->option_cnt / LV_ROLLER_INF_PAGES;\n    }\n    else {\n        return roller->option_cnt;\n    }\n}"}, "carbit_updater/lvgl/src/widgets/lv_roller.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_roller.c"}}, "carbit_updater/lvgl/src/extra/libs/qrcode/qrcodegen.c": {"assert": {"type": "Variable", "def": "#include assert.h", "sline": 24}, "limits": {"type": "Variable", "def": "#include limits.h", "sline": 25}, "stdlib": {"type": "Variable", "def": "#include stdlib.h", "sline": 26}, "string": {"type": "Variable", "def": "#include string.h", "sline": 27}, "qrcodegen": {"type": "Variable", "def": "#include qrcodegen.h", "sline": 28, "include": ["carbit_updater/lvgl/src/extra/libs/qrcode/qrcodegen.h", null]}, "appendBitsToBuffer": {"type": "Function", "def": "testable void appendBitsToBuffer(unsigned int val, int numBits, uint8_t buffer[], int *bitLen)", "sline": 184, "body": "{\n\tassert(0 <= numBits && numBits <= 16 && (unsigned long)val >> numBits == 0);\n\tfor (int i = numBits - 1; i >= 0; i--, (*bitLen)++)\n\t\tbuffer[*bitLen >> 3] |= ((val >> i) & 1) << (7 - (*bitLen & 7));\n}"}, "addEccAndInterleave": {"type": "Function", "def": "testable void addEccAndInterleave(uint8_t data[], int version, enum qrcodegen_Ecc ecl, uint8_t result[])", "sline": 291, "body": "{\n\t// Calculate parameter numbers\n\tassert(0 <= (int)ecl && (int)ecl < 4 && qrcodegen_VERSION_MIN <= version && version <= qrcodegen_VERSION_MAX);\n\tint numBlocks = NUM_ERROR_CORRECTION_BLOCKS[(int)ecl][version];\n\tint blockEccLen = ECC_CODEWORDS_PER_BLOCK  [(int)ecl][version];\n\tint rawCodewords = getNumRawDataModules(version) / 8;\n\tint dataLen = getNumDataCodewords(version, ecl);\n\tint numShortBlocks = numBlocks - rawCodewords % numBlocks;\n\tint shortBlockDataLen = rawCodewords / numBlocks - blockEccLen;\n\t\n\t// Split data into blocks, calculate ECC, and interleave\n\t// (not concatenate) the bytes into a single sequence\n\tuint8_t generator[qrcodegen_REED_SOLOMON_DEGREE_MAX];\n\tcalcReedSolomonGenerator(blockEccLen, generator);\n\tconst uint8_t *dat = data;\n\tfor (int i = 0; i < numBlocks; i++) {\n\t\tint datLen = shortBlockDataLen + (i < numShortBlocks ? 0 : 1);\n\t\tuint8_t *ecc = &data[dataLen];  // Temporary storage\n\t\tcalcReedSolomonRemainder(dat, datLen, generator, blockEccLen, ecc);\n\t\tfor (int j = 0, k = i; j < datLen; j++, k += numBlocks) {  // Copy data\n\t\t\tif (j == shortBlockDataLen)\n\t\t\t\tk -= numShortBlocks;\n\t\t\tresult[k] = dat[j];\n\t\t}\n\t\tfor (int j = 0, k = dataLen + i; j < blockEccLen; j++, k += numBlocks)  // Copy ECC\n\t\t\tresult[k] = ecc[j];\n\t\tdat += datLen;\n\t}\n}"}, "getNumDataCodewords": {"type": "Function", "def": "testable int getNumDataCodewords(int version, enum qrcodegen_Ecc ecl)", "sline": 324, "body": "{\n\tint v = version, e = (int)ecl;\n\tassert(0 <= e && e < 4);\n\treturn getNumRawDataModules(v) / 8\n\t\t- ECC_CODEWORDS_PER_BLOCK    [e][v]\n\t\t* NUM_ERROR_CORRECTION_BLOCKS[e][v];\n}"}, "getNumRawDataModules": {"type": "Function", "def": "testable int getNumRawDataModules(int ver)", "sline": 336, "body": "{\n\tassert(qrcodegen_VERSION_MIN <= ver && ver <= qrcodegen_VERSION_MAX);\n\tint result = (16 * ver + 128) * ver + 64;\n\tif (ver >= 2) {\n\t\tint numAlign = ver / 7 + 2;\n\t\tresult -= (25 * numAlign - 10) * numAlign - 55;\n\t\tif (ver >= 7)\n\t\t\tresult -= 36;\n\t}\n\treturn result;\n}"}, "calcReedSolomonGenerator": {"type": "Function", "def": "testable void calcReedSolomonGenerator(int degree, uint8_t result[])", "sline": 353, "body": "{\n\t// Start with the monomial x^0\n\tassert(1 <= degree && degree <= qrcodegen_REED_SOLOMON_DEGREE_MAX);\n\tmemset(result, 0, degree * sizeof(result[0]));\n\tresult[degree - 1] = 1;\n\t\n\t// Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),\n\t// drop the highest term, and store the rest of the coefficients in order of descending powers.\n\t// Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).\n\tuint8_t root = 1;\n\tfor (int i = 0; i < degree; i++) {\n\t\t// Multiply the current product by (x - r^i)\n\t\tfor (int j = 0; j < degree; j++) {\n\t\t\tresult[j] = finiteFieldMultiply(result[j], root);\n\t\t\tif (j + 1 < degree)\n\t\t\t\tresult[j] ^= result[j + 1];\n\t\t}\n\t\troot = finiteFieldMultiply(root, 0x02);\n\t}\n}"}, "calcReedSolomonRemainder": {"type": "Function", "def": "testable void calcReedSolomonRemainder(const uint8_t data[], int dataLen,\n\t\tconst uint8_t generator[], int degree, uint8_t result[])", "sline": 377, "body": "{\n\t\n\t// Perform polynomial division\n\tassert(1 <= degree && degree <= qrcodegen_REED_SOLOMON_DEGREE_MAX);\n\tmemset(result, 0, degree * sizeof(result[0]));\n\tfor (int i = 0; i < dataLen; i++) {\n\t\tuint8_t factor = data[i] ^ result[0];\n\t\tmemmove(&result[0], &result[1], (degree - 1) * sizeof(result[0]));\n\t\tresult[degree - 1] = 0;\n\t\tfor (int j = 0; j < degree; j++)\n\t\t\tresult[j] ^= finiteFieldMultiply(generator[j], factor);\n\t}\n}"}, "finiteFieldMultiply": {"type": "Function", "def": "testable uint8_t finiteFieldMultiply(uint8_t x, uint8_t y)", "sline": 397, "body": "{\n\t// Russian peasant multiplication\n\tuint8_t z = 0;\n\tfor (int i = 7; i >= 0; i--) {\n\t\tz = (z << 1) ^ ((z >> 7) * 0x11D);\n\t\tz ^= ((y >> i) & 1) * x;\n\t}\n\treturn z;\n}"}, "initializeFunctionModules": {"type": "Function", "def": "testable void initializeFunctionModules(int version, uint8_t qrcode[])", "sline": 413, "body": "{\n\t// Initialize QR Code\n\tint qrsize = version * 4 + 17;\n\tmemset(qrcode, 0, ((qrsize * qrsize + 7) / 8 + 1) * sizeof(qrcode[0]));\n\tqrcode[0] = (uint8_t)qrsize;\n\t\n\t// Fill horizontal and vertical timing patterns\n\tfillRectangle(6, 0, 1, qrsize, qrcode);\n\tfillRectangle(0, 6, qrsize, 1, qrcode);\n\t\n\t// Fill 3 finder patterns (all corners except bottom right) and format bits\n\tfillRectangle(0, 0, 9, 9, qrcode);\n\tfillRectangle(qrsize - 8, 0, 8, 9, qrcode);\n\tfillRectangle(0, qrsize - 8, 9, 8, qrcode);\n\t\n\t// Fill numerous alignment patterns\n\tuint8_t alignPatPos[7];\n\tint numAlign = getAlignmentPatternPositions(version, alignPatPos);\n\tfor (int i = 0; i < numAlign; i++) {\n\t\tfor (int j = 0; j < numAlign; j++) {\n\t\t\t// Don't draw on the three finder corners\n\t\t\tif (!((i == 0 && j == 0) || (i == 0 && j == numAlign - 1) || (i == numAlign - 1 && j == 0)))\n\t\t\t\tfillRectangle(alignPatPos[i] - 2, alignPatPos[j] - 2, 5, 5, qrcode);\n\t\t}\n\t}\n\t\n\t// Fill version blocks\n\tif (version >= 7) {\n\t\tfillRectangle(qrsize - 11, 0, 3, 6, qrcode);\n\t\tfillRectangle(0, qrsize - 11, 6, 3, qrcode);\n\t}\n}"}, "drawWhiteFunctionModules": {"type": "Function", "def": "static void drawWhiteFunctionModules(uint8_t qrcode[], int version)", "sline": 450, "docstring": "// Draws white function modules and possibly some black modules onto the given QR Code, without changing\n// non-function modules. This does not draw the format bits. This requires all function modules to be previously\n// marked black (namely by initializeFunctionModules()), because this may skip redrawing black function modules.", "body": "{\n\t// Draw horizontal and vertical timing patterns\n\tint qrsize = qrcodegen_getSize(qrcode);\n\tfor (int i = 7; i < qrsize - 7; i += 2) {\n\t\tsetModule(qrcode, 6, i, false);\n\t\tsetModule(qrcode, i, 6, false);\n\t}\n\t\n\t// Draw 3 finder patterns (all corners except bottom right; overwrites some timing modules)\n\tfor (int dy = -4; dy <= 4; dy++) {\n\t\tfor (int dx = -4; dx <= 4; dx++) {\n\t\t\tint dist = abs(dx);\n\t\t\tif (abs(dy) > dist)\n\t\t\t\tdist = abs(dy);\n\t\t\tif (dist == 2 || dist == 4) {\n\t\t\t\tsetModuleBounded(qrcode, 3 + dx, 3 + dy, false);\n\t\t\t\tsetModuleBounded(qrcode, qrsize - 4 + dx, 3 + dy, false);\n\t\t\t\tsetModuleBounded(qrcode, 3 + dx, qrsize - 4 + dy, false);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Draw numerous alignment patterns\n\tuint8_t alignPatPos[7];\n\tint numAlign = getAlignmentPatternPositions(version, alignPatPos);\n\tfor (int i = 0; i < numAlign; i++) {\n\t\tfor (int j = 0; j < numAlign; j++) {\n\t\t\tif ((i == 0 && j == 0) || (i == 0 && j == numAlign - 1) || (i == numAlign - 1 && j == 0))\n\t\t\t\tcontinue;  // Don't draw on the three finder corners\n\t\t\tfor (int dy = -1; dy <= 1; dy++) {\n\t\t\t\tfor (int dx = -1; dx <= 1; dx++)\n\t\t\t\t\tsetModule(qrcode, alignPatPos[i] + dx, alignPatPos[j] + dy, dx == 0 && dy == 0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Draw version blocks\n\tif (version >= 7) {\n\t\t// Calculate error correction code and pack bits\n\t\tint rem = version;  // version is uint6, in the range [7, 40]\n\t\tfor (int i = 0; i < 12; i++)\n\t\t\trem = (rem << 1) ^ ((rem >> 11) * 0x1F25);\n\t\tlong bits = (long)version << 12 | rem;  // uint18\n\t\tassert(bits >> 18 == 0);\n\t\t\n\t\t// Draw two copies\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tint k = qrsize - 11 + j;\n\t\t\t\tsetModule(qrcode, k, i, (bits & 1) != 0);\n\t\t\t\tsetModule(qrcode, i, k, (bits & 1) != 0);\n\t\t\t\tbits >>= 1;\n\t\t\t}\n\t\t}\n\t}\n}"}, "drawFormatBits": {"type": "Function", "def": "static void drawFormatBits(enum qrcodegen_Ecc ecl, enum qrcodegen_Mask mask, uint8_t qrcode[])", "sline": 511, "docstring": "// Draws two copies of the format bits (with its own error correction code) based\n// on the given mask and error correction level. This always draws all modules of\n// the format bits, unlike drawWhiteFunctionModules() which might skip black modules.", "body": "{\n\t// Calculate error correction code and pack bits\n\tassert(0 <= (int)mask && (int)mask <= 7);\n\tstatic const int table[] = {1, 0, 3, 2};\n\tint data = table[(int)ecl] << 3 | (int)mask;  // errCorrLvl is uint2, mask is uint3\n\tint rem = data;\n\tfor (int i = 0; i < 10; i++)\n\t\trem = (rem << 1) ^ ((rem >> 9) * 0x537);\n\tint bits = (data << 10 | rem) ^ 0x5412;  // uint15\n\tassert(bits >> 15 == 0);\n\t\n\t// Draw first copy\n\tfor (int i = 0; i <= 5; i++)\n\t\tsetModule(qrcode, 8, i, getBit(bits, i));\n\tsetModule(qrcode, 8, 7, getBit(bits, 6));\n\tsetModule(qrcode, 8, 8, getBit(bits, 7));\n\tsetModule(qrcode, 7, 8, getBit(bits, 8));\n\tfor (int i = 9; i < 15; i++)\n\t\tsetModule(qrcode, 14 - i, 8, getBit(bits, i));\n\t\n\t// Draw second copy\n\tint qrsize = qrcodegen_getSize(qrcode);\n\tfor (int i = 0; i < 8; i++)\n\t\tsetModule(qrcode, qrsize - 1 - i, 8, getBit(bits, i));\n\tfor (int i = 8; i < 15; i++)\n\t\tsetModule(qrcode, 8, qrsize - 15 + i, getBit(bits, i));\n\tsetModule(qrcode, 8, qrsize - 8, true);  // Always black\n}"}, "getAlignmentPatternPositions": {"type": "Function", "def": "testable int getAlignmentPatternPositions(int version, uint8_t result[7])", "sline": 545, "body": "{\n\tif (version == 1)\n\t\treturn 0;\n\tint numAlign = version / 7 + 2;\n\tint step = (version == 32) ? 26 :\n\t\t(version*4 + numAlign*2 + 1) / (numAlign*2 - 2) * 2;\n\tfor (int i = numAlign - 1, pos = version * 4 + 10; i >= 1; i--, pos -= step)\n\t\tresult[i] = pos;\n\tresult[0] = 6;\n\treturn numAlign;\n}"}, "fillRectangle": {"type": "Function", "def": "static void fillRectangle(int left, int top, int width, int height, uint8_t qrcode[])", "sline": 559, "docstring": "// Sets every pixel in the range [left : left + width] * [top : top + height] to black.", "body": "{\n\tfor (int dy = 0; dy < height; dy++) {\n\t\tfor (int dx = 0; dx < width; dx++)\n\t\t\tsetModule(qrcode, left + dx, top + dy, true);\n\t}\n}"}, "drawCodewords": {"type": "Function", "def": "static void drawCodewords(const uint8_t data[], int dataLen, uint8_t qrcode[])", "sline": 572, "docstring": "// Draws the raw codewords (including data and ECC) onto the given QR Code. This requires the initial state of\n// the QR Code to be black at function modules and white at codeword modules (including unused remainder bits).", "body": "{\n\tint qrsize = qrcodegen_getSize(qrcode);\n\tint i = 0;  // Bit index into the data\n\t// Do the funny zigzag scan\n\tfor (int right = qrsize - 1; right >= 1; right -= 2) {  // Index of right column in each column pair\n\t\tif (right == 6)\n\t\t\tright = 5;\n\t\tfor (int vert = 0; vert < qrsize; vert++) {  // Vertical counter\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tint x = right - j;  // Actual x coordinate\n\t\t\t\tbool upward = ((right + 1) & 2) == 0;\n\t\t\t\tint y = upward ? qrsize - 1 - vert : vert;  // Actual y coordinate\n\t\t\t\tif (!getModule(qrcode, x, y) && i < dataLen * 8) {\n\t\t\t\t\tbool black = getBit(data[i >> 3], 7 - (i & 7));\n\t\t\t\t\tsetModule(qrcode, x, y, black);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\t// If this QR Code has any remainder bits (0 to 7), they were assigned as\n\t\t\t\t// 0/false/white by the constructor and are left unchanged by this method\n\t\t\t}\n\t\t}\n\t}\n\tassert(i == dataLen * 8);\n}"}, "applyMask": {"type": "Function", "def": "static void applyMask(const uint8_t functionModules[], uint8_t qrcode[], enum qrcodegen_Mask mask)", "sline": 603, "docstring": "// before masking. Due to the arithmetic of XOR, calling applyMask() with\n// the same mask value a second time will undo the mask. A final well-formed\n// QR Code needs exactly one (not zero, two, etc.) mask applied.", "body": "{\n\tassert(0 <= (int)mask && (int)mask <= 7);  // Disallows qrcodegen_Mask_AUTO\n\tint qrsize = qrcodegen_getSize(qrcode);\n\tfor (int y = 0; y < qrsize; y++) {\n\t\tfor (int x = 0; x < qrsize; x++) {\n\t\t\tif (getModule(functionModules, x, y))\n\t\t\t\tcontinue;\n\t\t\tbool invert;\n\t\t\tswitch ((int)mask) {\n\t\t\t\tcase 0:  invert = (x + y) % 2 == 0;                    break;\n\t\t\t\tcase 1:  invert = y % 2 == 0;                          break;\n\t\t\t\tcase 2:  invert = x % 3 == 0;                          break;\n\t\t\t\tcase 3:  invert = (x + y) % 3 == 0;                    break;\n\t\t\t\tcase 4:  invert = (x / 3 + y / 2) % 2 == 0;            break;\n\t\t\t\tcase 5:  invert = x * y % 2 + x * y % 3 == 0;          break;\n\t\t\t\tcase 6:  invert = (x * y % 2 + x * y % 3) % 2 == 0;    break;\n\t\t\t\tcase 7:  invert = ((x + y) % 2 + x * y % 3) % 2 == 0;  break;\n\t\t\t\tdefault:  assert(false);  return;\n\t\t\t}\n\t\t\tbool val = getModule(qrcode, x, y);\n\t\t\tsetModule(qrcode, x, y, val ^ invert);\n\t\t}\n\t}\n}"}, "getPenaltyScore": {"type": "Function", "def": "static long getPenaltyScore(const uint8_t qrcode[])", "sline": 631, "docstring": "// Calculates and returns the penalty score based on state of the given QR Code's current modules.\n// This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.", "body": "{\n\tint qrsize = qrcodegen_getSize(qrcode);\n\tlong result = 0;\n\t\n\t// Adjacent modules in row having same color, and finder-like patterns\n\tfor (int y = 0; y < qrsize; y++) {\n\t\tunsigned char runHistory[7] = {0};\n\t\tbool color = false;\n\t\tunsigned char runX = 0;\n\t\tfor (int x = 0; x < qrsize; x++) {\n\t\t\tif (getModule(qrcode, x, y) == color) {\n\t\t\t\trunX++;\n\t\t\t\tif (runX == 5)\n\t\t\t\t\tresult += PENALTY_N1;\n\t\t\t\telse if (runX > 5)\n\t\t\t\t\tresult++;\n\t\t\t} else {\n\t\t\t\taddRunToHistory(runX, runHistory);\n\t\t\t\tif (!color && hasFinderLikePattern(runHistory))\n\t\t\t\t\tresult += PENALTY_N3;\n\t\t\t\tcolor = getModule(qrcode, x, y);\n\t\t\t\trunX = 1;\n\t\t\t}\n\t\t}\n\t\taddRunToHistory(runX, runHistory);\n\t\tif (color)\n\t\t\taddRunToHistory(0, runHistory);  // Dummy run of white\n\t\tif (hasFinderLikePattern(runHistory))\n\t\t\tresult += PENALTY_N3;\n\t}\n\t// Adjacent modules in column having same color, and finder-like patterns\n\tfor (int x = 0; x < qrsize; x++) {\n\t\tunsigned char runHistory[7] = {0};\n\t\tbool color = false;\n\t\tunsigned char runY = 0;\n\t\tfor (int y = 0; y < qrsize; y++) {\n\t\t\tif (getModule(qrcode, x, y) == color) {\n\t\t\t\trunY++;\n\t\t\t\tif (runY == 5)\n\t\t\t\t\tresult += PENALTY_N1;\n\t\t\t\telse if (runY > 5)\n\t\t\t\t\tresult++;\n\t\t\t} else {\n\t\t\t\taddRunToHistory(runY, runHistory);\n\t\t\t\tif (!color && hasFinderLikePattern(runHistory))\n\t\t\t\t\tresult += PENALTY_N3;\n\t\t\t\tcolor = getModule(qrcode, x, y);\n\t\t\t\trunY = 1;\n\t\t\t}\n\t\t}\n\t\taddRunToHistory(runY, runHistory);\n\t\tif (color)\n\t\t\taddRunToHistory(0, runHistory);  // Dummy run of white\n\t\tif (hasFinderLikePattern(runHistory))\n\t\t\tresult += PENALTY_N3;\n\t}\n\t\n\t// 2*2 blocks of modules having same color\n\tfor (int y = 0; y < qrsize - 1; y++) {\n\t\tfor (int x = 0; x < qrsize - 1; x++) {\n\t\t\tbool  color = getModule(qrcode, x, y);\n\t\t\tif (  color == getModule(qrcode, x + 1, y) &&\n\t\t\t      color == getModule(qrcode, x, y + 1) &&\n\t\t\t      color == getModule(qrcode, x + 1, y + 1))\n\t\t\t\tresult += PENALTY_N2;\n\t\t}\n\t}\n\t\n\t// Balance of black and white modules\n\tint black = 0;\n\tfor (int y = 0; y < qrsize; y++) {\n\t\tfor (int x = 0; x < qrsize; x++) {\n\t\t\tif (getModule(qrcode, x, y))\n\t\t\t\tblack++;\n\t\t}\n\t}\n\tint total = qrsize * qrsize;  // Note that size is odd, so black/total != 1/2\n\t// Compute the smallest integer k >= 0 such that (45-5k)% <= black/total <= (55+5k)%\n\tint k = (int)((labs(black * 20L - total * 10L) + total - 1) / total) - 1;\n\tresult += k * PENALTY_N4;\n\treturn result;\n}"}, "addRunToHistory": {"type": "Function", "def": "static void addRunToHistory(unsigned char run, unsigned char history[7])", "sline": 717, "docstring": "// Inserts the given value to the front of the given array, which shifts over the\n// existing values and deletes the last value. A helper function for getPenaltyScore().", "body": "{\n\tmemmove(&history[1], &history[0], 6 * sizeof(history[0]));\n\thistory[0] = run;\n}"}, "hasFinderLikePattern": {"type": "Function", "def": "static bool hasFinderLikePattern(const unsigned char runHistory[7])", "sline": 726, "docstring": "// Tests whether the given run history has the pattern of ratio 1:1:3:1:1 in the middle, and\n// surrounded by at least 4 on either or both ends. A helper function for getPenaltyScore().\n// Must only be called immediately after a run of white modules has ended.", "body": "{\n\tunsigned char n = runHistory[1];\n\t// The maximum QR Code size is 177, hence the run length n <= 177.\n\t// Arithmetic is promoted to int, so n*4 will not overflow.\n\treturn n > 0 && runHistory[2] == n && runHistory[4] == n && runHistory[5] == n\n\t\t&& runHistory[3] == n * 3 && (runHistory[0] >= n * 4 || runHistory[6] >= n * 4);\n}"}, "getModule": {"type": "Function", "def": "testable bool getModule(const uint8_t qrcode[], int x, int y)", "sline": 757, "body": "{\n\tint qrsize = qrcode[0];\n\tassert(21 <= qrsize && qrsize <= 177 && 0 <= x && x < qrsize && 0 <= y && y < qrsize);\n\tint index = y * qrsize + x;\n\treturn getBit(qrcode[(index >> 3) + 1], index & 7);\n}"}, "setModule": {"type": "Function", "def": "testable void setModule(uint8_t qrcode[], int x, int y, bool isBlack)", "sline": 766, "body": "{\n\tint qrsize = qrcode[0];\n\tassert(21 <= qrsize && qrsize <= 177 && 0 <= x && x < qrsize && 0 <= y && y < qrsize);\n\tint index = y * qrsize + x;\n\tint bitIndex = index & 7;\n\tint byteIndex = (index >> 3) + 1;\n\tif (isBlack)\n\t\tqrcode[byteIndex] |= 1 << bitIndex;\n\telse\n\t\tqrcode[byteIndex] &= (1 << bitIndex) ^ 0xFF;\n}"}, "setModuleBounded": {"type": "Function", "def": "testable void setModuleBounded(uint8_t qrcode[], int x, int y, bool isBlack)", "sline": 780, "body": "{\n\tint qrsize = qrcode[0];\n\tif (0 <= x && x < qrsize && 0 <= y && y < qrsize)\n\t\tsetModule(qrcode, x, y, isBlack);\n}"}, "getBit": {"type": "Function", "def": "static bool getBit(int x, int i)", "sline": 788, "docstring": "// Returns true iff the i'th bit of x is set to 1. Requires x >= 0 and 0 <= i <= 14.", "body": "{\n\treturn ((x >> i) & 1) != 0;\n}"}, "calcSegmentBitLength": {"type": "Function", "def": "testable int calcSegmentBitLength(enum qrcodegen_Mode mode, size_t numChars)", "sline": 836, "body": "{\n\t// All calculations are designed to avoid overflow on all platforms\n\tif (numChars > (unsigned int)INT16_MAX)\n\t\treturn -1;\n\tlong result = (long)numChars;\n\tif (mode == qrcodegen_Mode_NUMERIC)\n\t\tresult = (result * 10 + 2) / 3;  // ceil(10/3 * n)\n\telse if (mode == qrcodegen_Mode_ALPHANUMERIC)\n\t\tresult = (result * 11 + 1) / 2;  // ceil(11/2 * n)\n\telse if (mode == qrcodegen_Mode_BYTE)\n\t\tresult *= 8;\n\telse if (mode == qrcodegen_Mode_KANJI)\n\t\tresult *= 13;\n\telse if (mode == qrcodegen_Mode_ECI && numChars == 0)\n\t\tresult = 3 * 8;\n\telse {  // Invalid argument\n\t\tassert(false);\n\t\treturn -1;\n\t}\n\tassert(result >= 0);\n\tif (result > (unsigned int)INT16_MAX)\n\t\treturn -1;\n\treturn (int)result;\n}"}, "getTotalBits": {"type": "Function", "def": "testable int getTotalBits(const struct qrcodegen_Segment segs[], size_t len, int version)", "sline": 975, "body": "{\n\tassert(segs != NULL || len == 0);\n\tlong result = 0;\n\tfor (size_t i = 0; i < len; i++) {\n\t\tint numChars  = segs[i].numChars;\n\t\tint bitLength = segs[i].bitLength;\n\t\tassert(0 <= numChars  && numChars  <= INT16_MAX);\n\t\tassert(0 <= bitLength && bitLength <= INT16_MAX);\n\t\tint ccbits = numCharCountBits(segs[i].mode, version);\n\t\tassert(0 <= ccbits && ccbits <= 16);\n\t\tif (numChars >= (1L << ccbits))\n\t\t\treturn -1;  // The segment's length doesn't fit the field's bit width\n\t\tresult += 4L + ccbits + bitLength;\n\t\tif (result > INT16_MAX)\n\t\t\treturn -1;  // The sum might overflow an int type\n\t}\n\tassert(0 <= result && result <= INT16_MAX);\n\treturn (int)result;\n}"}, "numCharCountBits": {"type": "Function", "def": "static int numCharCountBits(enum qrcodegen_Mode mode, int version)", "sline": 998, "docstring": "// Returns the bit width of the character count field for a segment in the given mode\n// in a QR Code at the given version number. The result is in the range [0, 16].", "body": "{\n\tassert(qrcodegen_VERSION_MIN <= version && version <= qrcodegen_VERSION_MAX);\n\tint i = (version + 7) / 17;\n\tswitch (mode) {\n\t\tcase qrcodegen_Mode_NUMERIC     : { static const int temp[] = {10, 12, 14}; return temp[i]; }\n\t\tcase qrcodegen_Mode_ALPHANUMERIC: { static const int temp[] = { 9, 11, 13}; return temp[i]; }\n\t\tcase qrcodegen_Mode_BYTE        : { static const int temp[] = { 8, 16, 16}; return temp[i]; }\n\t\tcase qrcodegen_Mode_KANJI       : { static const int temp[] = { 8, 10, 12}; return temp[i]; }\n\t\tcase qrcodegen_Mode_ECI         : return 0;\n\t\tdefault:  assert(false);  return -1;  // Dummy value\n\t}\n}"}, "ALPHANUMERIC_CHARSET": {"type": "Variable", "def": "static const char *ALPHANUMERIC_CHARSET = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\"", "sline": 93}, "ECC_CODEWORDS_PER_BLOCK": {"type": "Variable", "def": "testable const int8_t ECC_CODEWORDS_PER_BLOCK[4][41] = {\n\t// Version: (note that index 0 is for padding, and is set to an illegal value)\n\t//0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n\t{-1,  7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // Low\n\t{-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28},  // Medium\n\t{-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // Quartile\n\t{-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // High\n}", "sline": 96}, "NUM_ERROR_CORRECTION_BLOCKS": {"type": "Variable", "def": "testable const int8_t NUM_ERROR_CORRECTION_BLOCKS[4][41] = {\n\t// Version: (note that index 0 is for padding, and is set to an illegal value)\n\t//0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n\t{-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4,  4,  4,  4,  4,  6,  6,  6,  6,  7,  8,  8,  9,  9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25},  // Low\n\t{-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5,  5,  8,  9,  9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49},  // Medium\n\t{-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8,  8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68},  // Quartile\n\t{-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81},  // High\n}", "sline": 108}, "PENALTY_N1": {"type": "Variable", "def": "static const int PENALTY_N1 =  3", "sline": 118}, "PENALTY_N2": {"type": "Variable", "def": "static const int PENALTY_N2 =  3", "sline": 119}, "PENALTY_N3": {"type": "Variable", "def": "static const int PENALTY_N3 = 40", "sline": 120}, "PENALTY_N4": {"type": "Variable", "def": "static const int PENALTY_N4 = 10", "sline": 121}, "qrcodegen_encodeText": {"type": "Function", "def": "bool qrcodegen_encodeText(const char *text, uint8_t tempBuffer[], uint8_t qrcode[],\n\t\tenum qrcodegen_Ecc ecl, int minVersion, int maxVersion, enum qrcodegen_Mask mask, bool boostEcl)", "sline": 128, "docstring": "// Public function - see documentation comment in header file.", "body": "{\n\t\n\tsize_t textLen = strlen(text);\n\tif (textLen == 0)\n\t\treturn qrcodegen_encodeSegmentsAdvanced(NULL, 0, ecl, minVersion, maxVersion, mask, boostEcl, tempBuffer, qrcode);\n\tsize_t bufLen = qrcodegen_BUFFER_LEN_FOR_VERSION(maxVersion);\n\t\n\tstruct qrcodegen_Segment seg;\n\tif (qrcodegen_isNumeric(text)) {\n\t\tif (qrcodegen_calcSegmentBufferSize(qrcodegen_Mode_NUMERIC, textLen) > bufLen)\n\t\t\tgoto fail;\n\t\tseg = qrcodegen_makeNumeric(text, tempBuffer);\n\t} else if (qrcodegen_isAlphanumeric(text)) {\n\t\tif (qrcodegen_calcSegmentBufferSize(qrcodegen_Mode_ALPHANUMERIC, textLen) > bufLen)\n\t\t\tgoto fail;\n\t\tseg = qrcodegen_makeAlphanumeric(text, tempBuffer);\n\t} else {\n\t\tif (textLen > bufLen)\n\t\t\tgoto fail;\n\t\tfor (size_t i = 0; i < textLen; i++)\n\t\t\ttempBuffer[i] = (uint8_t)text[i];\n\t\tseg.mode = qrcodegen_Mode_BYTE;\n\t\tseg.bitLength = calcSegmentBitLength(seg.mode, textLen);\n\t\tif (seg.bitLength == -1)\n\t\t\tgoto fail;\n\t\tseg.numChars = (int)textLen;\n\t\tseg.data = tempBuffer;\n\t}\n\treturn qrcodegen_encodeSegmentsAdvanced(&seg, 1, ecl, minVersion, maxVersion, mask, boostEcl, tempBuffer, qrcode);\n\t\nfail:\n\tqrcode[0] = 0;  // Set size to invalid value for safety\n\treturn false;\n}"}, "qrcodegen_encodeBinary": {"type": "Function", "def": "bool qrcodegen_encodeBinary(uint8_t dataAndTemp[], size_t dataLen, uint8_t qrcode[],\n\t\tenum qrcodegen_Ecc ecl, int minVersion, int maxVersion, enum qrcodegen_Mask mask, bool boostEcl)", "sline": 166, "docstring": "// Public function - see documentation comment in header file.", "body": "{\n\t\n\tstruct qrcodegen_Segment seg;\n\tseg.mode = qrcodegen_Mode_BYTE;\n\tseg.bitLength = calcSegmentBitLength(seg.mode, dataLen);\n\tif (seg.bitLength == -1) {\n\t\tqrcode[0] = 0;  // Set size to invalid value for safety\n\t\treturn false;\n\t}\n\tseg.numChars = (int)dataLen;\n\tseg.data = dataAndTemp;\n\treturn qrcodegen_encodeSegmentsAdvanced(&seg, 1, ecl, minVersion, maxVersion, mask, boostEcl, dataAndTemp, qrcode);\n}"}, "qrcodegen_encodeSegments": {"type": "Function", "def": "bool qrcodegen_encodeSegments(const struct qrcodegen_Segment segs[], size_t len,\n\t\tenum qrcodegen_Ecc ecl, uint8_t tempBuffer[], uint8_t qrcode[])", "sline": 195, "docstring": "// Public function - see documentation comment in header file.", "body": "{\n\treturn qrcodegen_encodeSegmentsAdvanced(segs, len, ecl,\n\t\tqrcodegen_VERSION_MIN, qrcodegen_VERSION_MAX, -1, true, tempBuffer, qrcode);\n}"}, "qrcodegen_encodeSegmentsAdvanced": {"type": "Function", "def": "bool qrcodegen_encodeSegmentsAdvanced(const struct qrcodegen_Segment segs[], size_t len, enum qrcodegen_Ecc ecl,\n\t\tint minVersion, int maxVersion, int mask, bool boostEcl, uint8_t tempBuffer[], uint8_t qrcode[])", "sline": 203, "docstring": "// Public function - see documentation comment in header file.", "body": "{\n\tassert(segs != NULL || len == 0);\n\tassert(qrcodegen_VERSION_MIN <= minVersion && minVersion <= maxVersion && maxVersion <= qrcodegen_VERSION_MAX);\n\tassert(0 <= (int)ecl && (int)ecl <= 3 && -1 <= (int)mask && (int)mask <= 7);\n\t\n\t// Find the minimal version number to use\n\tint version, dataUsedBits;\n\tfor (version = minVersion; ; version++) {\n\t\tint dataCapacityBits = getNumDataCodewords(version, ecl) * 8;  // Number of data bits available\n\t\tdataUsedBits = getTotalBits(segs, len, version);\n\t\tif (dataUsedBits != -1 && dataUsedBits <= dataCapacityBits)\n\t\t\tbreak;  // This version number is found to be suitable\n\t\tif (version >= maxVersion) {  // All versions in the range could not fit the given data\n\t\t\tqrcode[0] = 0;  // Set size to invalid value for safety\n\t\t\treturn false;\n\t\t}\n\t}\n\tassert(dataUsedBits != -1);\n\t\n\t// Increase the error correction level while the data still fits in the current version number\n\tfor (int i = (int)qrcodegen_Ecc_MEDIUM; i <= (int)qrcodegen_Ecc_HIGH; i++) {  // From low to high\n\t\tif (boostEcl && dataUsedBits <= getNumDataCodewords(version, (enum qrcodegen_Ecc)i) * 8)\n\t\t\tecl = (enum qrcodegen_Ecc)i;\n\t}\n\t\n\t// Concatenate all segments to create the data bit string\n\tmemset(qrcode, 0, qrcodegen_BUFFER_LEN_FOR_VERSION(version) * sizeof(qrcode[0]));\n\tint bitLen = 0;\n\tfor (size_t i = 0; i < len; i++) {\n\t\tconst struct qrcodegen_Segment *seg = &segs[i];\n\t\tappendBitsToBuffer((int)seg->mode, 4, qrcode, &bitLen);\n\t\tappendBitsToBuffer(seg->numChars, numCharCountBits(seg->mode, version), qrcode, &bitLen);\n\t\tfor (int j = 0; j < seg->bitLength; j++)\n\t\t\tappendBitsToBuffer((seg->data[j >> 3] >> (7 - (j & 7))) & 1, 1, qrcode, &bitLen);\n\t}\n\tassert(bitLen == dataUsedBits);\n\t\n\t// Add terminator and pad up to a byte if applicable\n\tint dataCapacityBits = getNumDataCodewords(version, ecl) * 8;\n\tassert(bitLen <= dataCapacityBits);\n\tint terminatorBits = dataCapacityBits - bitLen;\n\tif (terminatorBits > 4)\n\t\tterminatorBits = 4;\n\tappendBitsToBuffer(0, terminatorBits, qrcode, &bitLen);\n\tappendBitsToBuffer(0, (8 - bitLen % 8) % 8, qrcode, &bitLen);\n\tassert(bitLen % 8 == 0);\n\t\n\t// Pad with alternating bytes until data capacity is reached\n\tfor (uint8_t padByte = 0xEC; bitLen < dataCapacityBits; padByte ^= 0xEC ^ 0x11)\n\t\tappendBitsToBuffer(padByte, 8, qrcode, &bitLen);\n\t\n\t// Draw function and data codeword modules\n\taddEccAndInterleave(qrcode, version, ecl, tempBuffer);\n\tinitializeFunctionModules(version, qrcode);\n\tdrawCodewords(tempBuffer, getNumRawDataModules(version) / 8, qrcode);\n\tdrawWhiteFunctionModules(qrcode, version);\n\tinitializeFunctionModules(version, tempBuffer);\n\t\n\t// Handle masking\n\tif (mask == qrcodegen_Mask_AUTO) {  // Automatically choose best mask\n\t\tlong minPenalty = LONG_MAX;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tenum qrcodegen_Mask msk = (enum qrcodegen_Mask)i;\n\t\t\tapplyMask(tempBuffer, qrcode, msk);\n\t\t\tdrawFormatBits(ecl, msk, qrcode);\n\t\t\tlong penalty = getPenaltyScore(qrcode);\n\t\t\tif (penalty < minPenalty) {\n\t\t\t\tmask = msk;\n\t\t\t\tminPenalty = penalty;\n\t\t\t}\n\t\t\tapplyMask(tempBuffer, qrcode, msk);  // Undoes the mask due to XOR\n\t\t}\n\t}\n\tassert(0 <= (int)mask && (int)mask <= 7);\n\tapplyMask(tempBuffer, qrcode, mask);\n\tdrawFormatBits(ecl, mask, qrcode);\n\treturn true;\n}"}, "qrcodegen_getSize": {"type": "Function", "def": "int qrcodegen_getSize(const uint8_t qrcode[])", "sline": 739, "docstring": "// Public function - see documentation comment in header file.", "body": "{\n\tassert(qrcode != NULL);\n\tint result = qrcode[0];\n\tassert((qrcodegen_VERSION_MIN * 4 + 17) <= result\n\t\t&& result <= (qrcodegen_VERSION_MAX * 4 + 17));\n\treturn result;\n}"}, "qrcodegen_getModule": {"type": "Function", "def": "bool qrcodegen_getModule(const uint8_t qrcode[], int x, int y)", "sline": 749, "docstring": "// Public function - see documentation comment in header file.", "body": "{\n\tassert(qrcode != NULL);\n\tint qrsize = qrcode[0];\n\treturn (0 <= x && x < qrsize && 0 <= y && y < qrsize) && getModule(qrcode, x, y);\n}"}, "qrcodegen_isAlphanumeric": {"type": "Function", "def": "bool qrcodegen_isAlphanumeric(const char *text)", "sline": 797, "docstring": "// Public function - see documentation comment in header file.", "body": "{\n\tassert(text != NULL);\n\tfor (; *text != '\\0'; text++) {\n\t\tif (strchr(ALPHANUMERIC_CHARSET, *text) == NULL)\n\t\t\treturn false;\n\t}\n\treturn true;\n}"}, "qrcodegen_isNumeric": {"type": "Function", "def": "bool qrcodegen_isNumeric(const char *text)", "sline": 808, "docstring": "// Public function - see documentation comment in header file.", "body": "{\n\tassert(text != NULL);\n\tfor (; *text != '\\0'; text++) {\n\t\tif (*text < '0' || *text > '9')\n\t\t\treturn false;\n\t}\n\treturn true;\n}"}, "qrcodegen_calcSegmentBufferSize": {"type": "Function", "def": "size_t qrcodegen_calcSegmentBufferSize(enum qrcodegen_Mode mode, size_t numChars)", "sline": 819, "docstring": "// Public function - see documentation comment in header file.", "body": "{\n\tint temp = calcSegmentBitLength(mode, numChars);\n\tif (temp == -1)\n\t\treturn SIZE_MAX;\n\tassert(0 <= temp && temp <= INT16_MAX);\n\treturn ((size_t)temp + 7) / 8;\n}"}, "qrcodegen_makeBytes": {"type": "Function", "def": "struct qrcodegen_Segment qrcodegen_makeBytes(const uint8_t data[], size_t len, uint8_t buf[])", "sline": 863, "docstring": "// Public function - see documentation comment in header file.", "body": "{\n\tassert(data != NULL || len == 0);\n\tstruct qrcodegen_Segment result;\n\tresult.mode = qrcodegen_Mode_BYTE;\n\tresult.bitLength = calcSegmentBitLength(result.mode, len);\n\tassert(result.bitLength != -1);\n\tresult.numChars = (int)len;\n\tif (len > 0)\n\t\tmemcpy(buf, data, len * sizeof(buf[0]));\n\tresult.data = buf;\n\treturn result;\n}"}, "qrcodegen_makeNumeric": {"type": "Function", "def": "struct qrcodegen_Segment qrcodegen_makeNumeric(const char *digits, uint8_t buf[])", "sline": 878, "docstring": "// Public function - see documentation comment in header file.", "body": "{\n\tassert(digits != NULL);\n\tstruct qrcodegen_Segment result;\n\tsize_t len = strlen(digits);\n\tresult.mode = qrcodegen_Mode_NUMERIC;\n\tint bitLen = calcSegmentBitLength(result.mode, len);\n\tassert(bitLen != -1);\n\tresult.numChars = (int)len;\n\tif (bitLen > 0)\n\t\tmemset(buf, 0, ((size_t)bitLen + 7) / 8 * sizeof(buf[0]));\n\tresult.bitLength = 0;\n\t\n\tunsigned int accumData = 0;\n\tint accumCount = 0;\n\tfor (; *digits != '\\0'; digits++) {\n\t\tchar c = *digits;\n\t\tassert('0' <= c && c <= '9');\n\t\taccumData = accumData * 10 + (unsigned int)(c - '0');\n\t\taccumCount++;\n\t\tif (accumCount == 3) {\n\t\t\tappendBitsToBuffer(accumData, 10, buf, &result.bitLength);\n\t\t\taccumData = 0;\n\t\t\taccumCount = 0;\n\t\t}\n\t}\n\tif (accumCount > 0)  // 1 or 2 digits remaining\n\t\tappendBitsToBuffer(accumData, accumCount * 3 + 1, buf, &result.bitLength);\n\tassert(result.bitLength == bitLen);\n\tresult.data = buf;\n\treturn result;\n}"}, "qrcodegen_makeAlphanumeric": {"type": "Function", "def": "struct qrcodegen_Segment qrcodegen_makeAlphanumeric(const char *text, uint8_t buf[])", "sline": 912, "docstring": "// Public function - see documentation comment in header file.", "body": "{\n\tassert(text != NULL);\n\tstruct qrcodegen_Segment result;\n\tsize_t len = strlen(text);\n\tresult.mode = qrcodegen_Mode_ALPHANUMERIC;\n\tint bitLen = calcSegmentBitLength(result.mode, len);\n\tassert(bitLen != -1);\n\tresult.numChars = (int)len;\n\tif (bitLen > 0)\n\t\tmemset(buf, 0, ((size_t)bitLen + 7) / 8 * sizeof(buf[0]));\n\tresult.bitLength = 0;\n\t\n\tunsigned int accumData = 0;\n\tint accumCount = 0;\n\tfor (; *text != '\\0'; text++) {\n\t\tconst char *temp = strchr(ALPHANUMERIC_CHARSET, *text);\n\t\tassert(temp != NULL);\n\t\taccumData = accumData * 45 + (unsigned int)(temp - ALPHANUMERIC_CHARSET);\n\t\taccumCount++;\n\t\tif (accumCount == 2) {\n\t\t\tappendBitsToBuffer(accumData, 11, buf, &result.bitLength);\n\t\t\taccumData = 0;\n\t\t\taccumCount = 0;\n\t\t}\n\t}\n\tif (accumCount > 0)  // 1 character remaining\n\t\tappendBitsToBuffer(accumData, 6, buf, &result.bitLength);\n\tassert(result.bitLength == bitLen);\n\tresult.data = buf;\n\treturn result;\n}"}, "qrcodegen_makeEci": {"type": "Function", "def": "struct qrcodegen_Segment qrcodegen_makeEci(long assignVal, uint8_t buf[])", "sline": 946, "docstring": "// Public function - see documentation comment in header file.", "body": "{\n\tstruct qrcodegen_Segment result;\n\tresult.mode = qrcodegen_Mode_ECI;\n\tresult.numChars = 0;\n\tresult.bitLength = 0;\n\tif (assignVal < 0)\n\t\tassert(false);\n\telse if (assignVal < (1 << 7)) {\n\t\tmemset(buf, 0, 1 * sizeof(buf[0]));\n\t\tappendBitsToBuffer(assignVal, 8, buf, &result.bitLength);\n\t} else if (assignVal < (1 << 14)) {\n\t\tmemset(buf, 0, 2 * sizeof(buf[0]));\n\t\tappendBitsToBuffer(2, 2, buf, &result.bitLength);\n\t\tappendBitsToBuffer(assignVal, 14, buf, &result.bitLength);\n\t} else if (assignVal < 1000000L) {\n\t\tmemset(buf, 0, 3 * sizeof(buf[0]));\n\t\tappendBitsToBuffer(6, 3, buf, &result.bitLength);\n\t\tappendBitsToBuffer(assignVal >> 10, 11, buf, &result.bitLength);\n\t\tappendBitsToBuffer(assignVal & 0x3FF, 10, buf, &result.bitLength);\n\t} else\n\t\tassert(false);\n\tresult.data = buf;\n\treturn result;\n}"}, "carbit_updater/lvgl/src/extra/libs/qrcode/qrcodegen.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/qrcode/qrcodegen.c"}}, "carbit_updater/lvgl/src/extra/widgets/colorwheel/lv_colorwheel.c": {"lv_colorwheel": {"type": "Variable", "def": "#include lv_colorwheel.h", "sline": 10, "include": ["carbit_updater/lvgl/src/extra/widgets/colorwheel/lv_colorwheel.h", null]}, "lv_assert": {"type": "Variable", "def": "#include ../../../misc/lv_assert.h", "sline": 13}, "lv_colorwheel_constructor": {"type": "Function", "def": "static void lv_colorwheel_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 224, "body": "{\n    LV_UNUSED(class_p);\n    lv_colorwheel_t * colorwheel = (lv_colorwheel_t *)obj;\n    colorwheel->hsv.h = 0;\n    colorwheel->hsv.s = 100;\n    colorwheel->hsv.v = 100;\n    colorwheel->mode = LV_COLORWHEEL_MODE_HUE;\n    colorwheel->mode_fixed = 0;\n    colorwheel->last_click_time = 0;\n    colorwheel->last_change_time = 0;\n    colorwheel->knob.recolor = create_knob_recolor;\n\n    lv_obj_add_flag(obj, LV_OBJ_FLAG_ADV_HITTEST);\n    lv_obj_clear_flag(obj, LV_OBJ_FLAG_SCROLL_CHAIN);\n    refr_knob_pos(obj);\n}"}, "lv_colorwheel_event": {"type": "Function", "def": "static void lv_colorwheel_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 356, "body": "{\n    LV_UNUSED(class_p);\n\n    /*Call the ancestor's event handler*/\n    lv_res_t res = lv_obj_event_base(MY_CLASS, e);\n\n    if(res != LV_RES_OK) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_colorwheel_t * colorwheel = (lv_colorwheel_t *)obj;\n\n    if(code == LV_EVENT_REFR_EXT_DRAW_SIZE) {\n        lv_coord_t left = lv_obj_get_style_pad_left(obj, LV_PART_KNOB);\n        lv_coord_t right = lv_obj_get_style_pad_right(obj, LV_PART_KNOB);\n        lv_coord_t top = lv_obj_get_style_pad_top(obj, LV_PART_KNOB);\n        lv_coord_t bottom = lv_obj_get_style_pad_bottom(obj, LV_PART_KNOB);\n\n        lv_coord_t knob_pad = LV_MAX4(left, right, top, bottom) + 2;\n        lv_coord_t * s = lv_event_get_param(e);\n        *s = LV_MAX(*s, knob_pad);\n    }\n    else if(code == LV_EVENT_SIZE_CHANGED) {\n        void * param = lv_event_get_param(e);\n        /*Refresh extended draw area to make knob visible*/\n        if(lv_obj_get_width(obj) != lv_area_get_width(param) ||\n           lv_obj_get_height(obj) != lv_area_get_height(param)) {\n            refr_knob_pos(obj);\n        }\n    }\n    else if(code == LV_EVENT_STYLE_CHANGED) {\n        /*Refresh extended draw area to make knob visible*/\n        refr_knob_pos(obj);\n    }\n    else if(code == LV_EVENT_KEY) {\n        uint32_t c = *((uint32_t *)lv_event_get_param(e)); /*uint32_t because can be UTF-8*/\n\n        if(c == LV_KEY_RIGHT || c == LV_KEY_UP) {\n            lv_color_hsv_t hsv_cur;\n            hsv_cur = colorwheel->hsv;\n\n            switch(colorwheel->mode) {\n                case LV_COLORWHEEL_MODE_HUE:\n                    hsv_cur.h = (colorwheel->hsv.h + 1) % 360;\n                    break;\n                case LV_COLORWHEEL_MODE_SATURATION:\n                    hsv_cur.s = (colorwheel->hsv.s + 1) % 100;\n                    break;\n                case LV_COLORWHEEL_MODE_VALUE:\n                    hsv_cur.v = (colorwheel->hsv.v + 1) % 100;\n                    break;\n            }\n\n            if(lv_colorwheel_set_hsv(obj, hsv_cur)) {\n                res = lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n                if(res != LV_RES_OK) return;\n            }\n        }\n        else if(c == LV_KEY_LEFT || c == LV_KEY_DOWN) {\n            lv_color_hsv_t hsv_cur;\n            hsv_cur = colorwheel->hsv;\n\n            switch(colorwheel->mode) {\n                case LV_COLORWHEEL_MODE_HUE:\n                    hsv_cur.h = colorwheel->hsv.h > 0 ? (colorwheel->hsv.h - 1) : 360;\n                    break;\n                case LV_COLORWHEEL_MODE_SATURATION:\n                    hsv_cur.s = colorwheel->hsv.s > 0 ? (colorwheel->hsv.s - 1) : 100;\n                    break;\n                case LV_COLORWHEEL_MODE_VALUE:\n                    hsv_cur.v = colorwheel->hsv.v > 0 ? (colorwheel->hsv.v - 1) : 100;\n                    break;\n            }\n\n            if(lv_colorwheel_set_hsv(obj, hsv_cur)) {\n                res = lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n                if(res != LV_RES_OK) return;\n            }\n        }\n    }\n    else if(code == LV_EVENT_PRESSED) {\n        colorwheel->last_change_time = lv_tick_get();\n        lv_indev_get_point(lv_indev_get_act(), &colorwheel->last_press_point);\n        res = double_click_reset(obj);\n        if(res != LV_RES_OK) return;\n    }\n    else if(code == LV_EVENT_PRESSING) {\n        lv_indev_t * indev = lv_indev_get_act();\n        if(indev == NULL) return;\n\n        lv_indev_type_t indev_type = lv_indev_get_type(indev);\n        lv_point_t p;\n        if(indev_type == LV_INDEV_TYPE_ENCODER || indev_type == LV_INDEV_TYPE_KEYPAD) {\n            p.x = obj->coords.x1 + lv_obj_get_width(obj) / 2;\n            p.y = obj->coords.y1 + lv_obj_get_height(obj) / 2;\n        }\n        else {\n            lv_indev_get_point(indev, &p);\n        }\n\n        lv_coord_t drag_limit = indev->driver->scroll_limit;\n        if((LV_ABS(p.x - colorwheel->last_press_point.x) > drag_limit) ||\n           (LV_ABS(p.y - colorwheel->last_press_point.y) > drag_limit)) {\n            colorwheel->last_change_time = lv_tick_get();\n            colorwheel->last_press_point.x = p.x;\n            colorwheel->last_press_point.y = p.y;\n        }\n\n        p.x -= obj->coords.x1;\n        p.y -= obj->coords.y1;\n\n        /*Ignore pressing in the inner area*/\n        uint16_t w = lv_obj_get_width(obj);\n\n        int16_t angle = 0;\n        lv_coord_t cir_w = lv_obj_get_style_arc_width(obj, LV_PART_MAIN);\n\n        lv_coord_t r_in = w / 2;\n        p.x -= r_in;\n        p.y -= r_in;\n        bool on_ring = true;\n        r_in -= cir_w;\n        if(r_in > LV_DPI_DEF / 2) {\n            lv_coord_t inner = cir_w / 2;\n            r_in -= inner;\n\n            if(r_in < LV_DPI_DEF / 2) r_in = LV_DPI_DEF / 2;\n        }\n\n        if(p.x * p.x + p.y * p.y < r_in * r_in) {\n            on_ring = false;\n        }\n\n        /*If the inner area is being pressed, go to the next color mode on long press*/\n        uint32_t diff = lv_tick_elaps(colorwheel->last_change_time);\n        if(!on_ring && diff > indev->driver->long_press_time && !colorwheel->mode_fixed) {\n            next_color_mode(obj);\n            lv_indev_wait_release(lv_indev_get_act());\n            return;\n        }\n\n        /*Set the angle only if pressed on the ring*/\n        if(!on_ring) return;\n\n        angle = lv_atan2(p.x, p.y) % 360;\n\n        lv_color_hsv_t hsv_cur;\n        hsv_cur = colorwheel->hsv;\n\n        switch(colorwheel->mode) {\n            case LV_COLORWHEEL_MODE_HUE:\n                hsv_cur.h = angle;\n                break;\n            case LV_COLORWHEEL_MODE_SATURATION:\n                hsv_cur.s = (angle * 100) / 360;\n                break;\n            case LV_COLORWHEEL_MODE_VALUE:\n                hsv_cur.v = (angle * 100) / 360;\n                break;\n        }\n\n        if(lv_colorwheel_set_hsv(obj, hsv_cur)) {\n            res = lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n            if(res != LV_RES_OK) return;\n        }\n    }\n    else if(code == LV_EVENT_HIT_TEST) {\n        lv_hit_test_info_t * info = lv_event_get_param(e);;\n\n        /*Valid clicks can be only in the circle*/\n        info->res = _lv_area_is_point_on(&obj->coords, info->point, LV_RADIUS_CIRCLE);\n    }\n    else if(code == LV_EVENT_DRAW_MAIN) {\n        draw_disc_grad(e);\n        draw_knob(e);\n    }\n    else if(code == LV_EVENT_COVER_CHECK) {\n        lv_cover_check_info_t * info = lv_event_get_param(e);\n        if(info->res != LV_COVER_RES_MASKED) info->res = LV_COVER_RES_NOT_COVER;\n    }\n}"}, "draw_disc_grad": {"type": "Function", "def": "static void draw_disc_grad(lv_event_t * e)", "sline": 242, "body": "{\n    lv_obj_t * obj = lv_event_get_target(e);\n    const lv_area_t * clip_area = lv_event_get_param(e);\n    lv_coord_t w = lv_obj_get_width(obj);\n    lv_coord_t h = lv_obj_get_height(obj);\n    lv_coord_t cx = obj->coords.x1 + w / 2;\n    lv_coord_t cy = obj->coords.y1 + h / 2;\n    lv_coord_t r = w / 2;\n\n    lv_draw_line_dsc_t line_dsc;\n    lv_draw_line_dsc_init(&line_dsc);\n    lv_obj_init_draw_line_dsc(obj, LV_PART_MAIN, &line_dsc);\n\n    line_dsc.width = (r * 628 / (256 / LV_CPICKER_DEF_QF)) / 100;\n    line_dsc.width += 2;\n    uint16_t i;\n    uint32_t a = 0;\n    lv_coord_t cir_w = lv_obj_get_style_arc_width(obj, LV_PART_MAIN);\n\n#if LV_DRAW_COMPLEX\n    /*Mask outer and inner ring of widget to tidy up ragged edges of lines while drawing outer ring*/\n    lv_draw_mask_radius_param_t mask_out_param;\n    lv_draw_mask_radius_init(&mask_out_param, &obj->coords, LV_RADIUS_CIRCLE, false);\n    int16_t mask_out_id = lv_draw_mask_add(&mask_out_param, 0);\n\n    lv_area_t mask_area;\n    lv_area_copy(&mask_area, &obj->coords);\n    mask_area.x1 += cir_w;\n    mask_area.x2 -= cir_w;\n    mask_area.y1 += cir_w;\n    mask_area.y2 -= cir_w;\n    lv_draw_mask_radius_param_t mask_in_param;\n    lv_draw_mask_radius_init(&mask_in_param, &mask_area, LV_RADIUS_CIRCLE, true);\n    int16_t mask_in_id = lv_draw_mask_add(&mask_in_param, 0);\n\n    /*The inner and outer line ends will be masked out.\n     *So make lines a little bit longer because the masking makes a more even result*/\n    lv_coord_t cir_w_extra = line_dsc.width;\n#else\n    lv_coord_t cir_w_extra = 0;\n#endif\n\n    for(i = 0; i <= 256; i += LV_CPICKER_DEF_QF, a += 360 * LV_CPICKER_DEF_QF) {\n        line_dsc.color = angle_to_mode_color_fast(obj, i);\n        uint16_t angle_trigo = (uint16_t)(a >> 8); /*i * 360 / 256 is the scale to apply, but we can skip multiplication here*/\n\n        lv_point_t p[2];\n        p[0].x = cx + ((r + cir_w_extra) * lv_trigo_sin(angle_trigo) >> LV_TRIGO_SHIFT);\n        p[0].y = cy + ((r + cir_w_extra) * lv_trigo_cos(angle_trigo) >> LV_TRIGO_SHIFT);\n        p[1].x = cx + ((r - cir_w - cir_w_extra) * lv_trigo_sin(angle_trigo) >> LV_TRIGO_SHIFT);\n        p[1].y = cy + ((r - cir_w - cir_w_extra) * lv_trigo_cos(angle_trigo) >> LV_TRIGO_SHIFT);\n\n        lv_draw_line(&p[0], &p[1], clip_area, &line_dsc);\n    }\n\n#if LV_DRAW_COMPLEX\n    lv_draw_mask_free_param(&mask_out_param);\n    lv_draw_mask_free_param(&mask_in_param);\n    lv_draw_mask_remove_id(mask_out_id);\n    lv_draw_mask_remove_id(mask_in_id);\n#endif\n}"}, "draw_knob": {"type": "Function", "def": "static void draw_knob(lv_event_t * e)", "sline": 306, "body": "{\n    lv_obj_t * obj = lv_event_get_target(e);\n    const lv_area_t * clip_area = lv_event_get_param(e);\n    lv_colorwheel_t * colorwheel = (lv_colorwheel_t *)obj;\n\n    lv_draw_rect_dsc_t cir_dsc;\n    lv_draw_rect_dsc_init(&cir_dsc);\n    lv_obj_init_draw_rect_dsc(obj, LV_PART_KNOB, &cir_dsc);\n\n    cir_dsc.radius = LV_RADIUS_CIRCLE;\n\n    if(colorwheel->knob.recolor) {\n        cir_dsc.bg_color = lv_colorwheel_get_rgb(obj);\n    }\n\n    lv_area_t knob_area = get_knob_area(obj);\n\n    lv_draw_rect(&knob_area, clip_area, &cir_dsc);\n}"}, "invalidate_knob": {"type": "Function", "def": "static void invalidate_knob(lv_obj_t * obj)", "sline": 327, "body": "{\n    lv_area_t knob_area = get_knob_area(obj);\n\n    lv_obj_invalidate_area(obj, &knob_area);\n}"}, "get_knob_area": {"type": "Function", "def": "static lv_area_t get_knob_area(lv_obj_t * obj)", "sline": 334, "body": "{\n    lv_colorwheel_t * colorwheel = (lv_colorwheel_t *)obj;\n\n    /*Get knob's radius*/\n    uint16_t r = 0;\n    r = lv_obj_get_style_arc_width(obj, LV_PART_MAIN) / 2;\n\n    lv_coord_t left = lv_obj_get_style_pad_left(obj, LV_PART_KNOB);\n    lv_coord_t right = lv_obj_get_style_pad_right(obj, LV_PART_KNOB);\n    lv_coord_t top = lv_obj_get_style_pad_top(obj, LV_PART_KNOB);\n    lv_coord_t bottom = lv_obj_get_style_pad_bottom(obj, LV_PART_KNOB);\n\n    lv_area_t knob_area;\n    knob_area.x1 = obj->coords.x1 + colorwheel->knob.pos.x - r - left;\n    knob_area.y1 = obj->coords.y1 + colorwheel->knob.pos.y - r - right;\n    knob_area.x2 = obj->coords.x1 + colorwheel->knob.pos.x + r + top;\n    knob_area.y2 = obj->coords.y1 + colorwheel->knob.pos.y + r + bottom;\n\n    return knob_area;\n}"}, "next_color_mode": {"type": "Function", "def": "static void next_color_mode(lv_obj_t * obj)", "sline": 541, "body": "{\n    lv_colorwheel_t * colorwheel = (lv_colorwheel_t *)obj;\n    colorwheel->mode = (colorwheel->mode + 1) % 3;\n    refr_knob_pos(obj);\n    lv_obj_invalidate(obj);\n}"}, "double_click_reset": {"type": "Function", "def": "static lv_res_t double_click_reset(lv_obj_t * obj)", "sline": 567, "body": "{\n    lv_colorwheel_t * colorwheel = (lv_colorwheel_t *)obj;\n    lv_indev_t * indev = lv_indev_get_act();\n    /*Double clicked? Use long press time as double click time out*/\n    if(lv_tick_elaps(colorwheel->last_click_time) < indev->driver->long_press_time) {\n        lv_color_hsv_t hsv_cur;\n        hsv_cur = colorwheel->hsv;\n\n        switch(colorwheel->mode) {\n            case LV_COLORWHEEL_MODE_HUE:\n                hsv_cur.h = 0;\n                break;\n            case LV_COLORWHEEL_MODE_SATURATION:\n                hsv_cur.s = 100;\n                break;\n            case LV_COLORWHEEL_MODE_VALUE:\n                hsv_cur.v = 100;\n                break;\n        }\n\n        lv_indev_wait_release(indev);\n\n        if(lv_colorwheel_set_hsv(obj, hsv_cur)) {\n            lv_res_t res = lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n            if(res != LV_RES_OK) return res;\n        }\n    }\n    colorwheel->last_click_time = lv_tick_get();\n\n    return LV_RES_OK;\n}"}, "refr_knob_pos": {"type": "Function", "def": "static void refr_knob_pos(lv_obj_t * obj)", "sline": 549, "body": "{\n    invalidate_knob(obj);\n\n    lv_colorwheel_t * colorwheel = (lv_colorwheel_t *)obj;\n    lv_coord_t w = lv_obj_get_width(obj);\n\n    lv_coord_t scale_w = lv_obj_get_style_arc_width(obj, LV_PART_MAIN);\n    lv_coord_t r = (w - scale_w) / 2;\n    uint16_t angle = get_angle(obj);\n    colorwheel->knob.pos.x = (((int32_t)r * lv_trigo_sin(angle)) >> LV_TRIGO_SHIFT);\n    colorwheel->knob.pos.y = (((int32_t)r * lv_trigo_cos(angle)) >> LV_TRIGO_SHIFT);\n    colorwheel->knob.pos.x = colorwheel->knob.pos.x + w / 2;\n    colorwheel->knob.pos.y = colorwheel->knob.pos.y + w / 2;\n\n    invalidate_knob(obj);\n}"}, "angle_to_mode_color_fast": {"type": "Function", "def": "static lv_color_t angle_to_mode_color_fast(lv_obj_t * obj, uint16_t angle)", "sline": 649, "body": "{\n    lv_colorwheel_t * ext = (lv_colorwheel_t *)obj;\n    uint8_t r = 0, g = 0, b = 0;\n    static uint16_t h = 0;\n    static uint8_t s = 0, v = 0, m = 255;\n\n    switch(ext->mode) {\n        default:\n        case LV_COLORWHEEL_MODE_HUE:\n            /*Don't recompute costly scaling if it does not change*/\n            if(m != ext->mode) {\n                s = (uint8_t)(((uint16_t)ext->hsv.s * 51) / 20);\n                v = (uint8_t)(((uint16_t)ext->hsv.v * 51) / 20);\n                m = ext->mode;\n            }\n            fast_hsv2rgb(angle * 6, s, v, &r, &g,\n                         &b); /*A smart compiler will replace x * 6 by (x << 2) + (x << 1) if it's more efficient*/\n            break;\n        case LV_COLORWHEEL_MODE_SATURATION:\n            /*Don't recompute costly scaling if it does not change*/\n            if(m != ext->mode) {\n                h = (uint16_t)(((uint32_t)ext->hsv.h * 6 * 256) / 360);\n                v = (uint8_t)(((uint16_t)ext->hsv.v * 51) / 20);\n                m = ext->mode;\n            }\n            fast_hsv2rgb(h, angle, v, &r, &g, &b);\n            break;\n        case LV_COLORWHEEL_MODE_VALUE:\n            /*Don't recompute costly scaling if it does not change*/\n            if(m != ext->mode) {\n                h = (uint16_t)(((uint32_t)ext->hsv.h * 6 * 256) / 360);\n                s = (uint8_t)(((uint16_t)ext->hsv.s * 51) / 20);\n                m = ext->mode;\n            }\n            fast_hsv2rgb(h, s, angle, &r, &g, &b);\n            break;\n    }\n    return lv_color_make(r, g, b);\n}"}, "get_angle": {"type": "Function", "def": "static uint16_t get_angle(lv_obj_t * obj)", "sline": 690, "body": "{\n    lv_colorwheel_t * colorwheel = (lv_colorwheel_t *)obj;\n    uint16_t angle;\n    switch(colorwheel->mode) {\n        default:\n        case LV_COLORWHEEL_MODE_HUE:\n            angle = colorwheel->hsv.h;\n            break;\n        case LV_COLORWHEEL_MODE_SATURATION:\n            angle = (colorwheel->hsv.s * 360) / 100;\n            break;\n        case LV_COLORWHEEL_MODE_VALUE:\n            angle = (colorwheel->hsv.v * 360) / 100 ;\n            break;\n    }\n    return angle;\n}"}, "lv_colorwheel_class": {"type": "Variable", "def": "const lv_obj_class_t lv_colorwheel_class = {.instance_size = sizeof(lv_colorwheel_t), .base_class = &lv_obj_class,\n                                            .constructor_cb = lv_colorwheel_constructor,\n                                            .event_cb = lv_colorwheel_event,\n                                            .width_def = LV_DPI_DEF * 2,\n                                            .height_def = LV_DPI_DEF * 2,\n                                            .editable = LV_OBJ_CLASS_EDITABLE_TRUE,\n                                           }", "sline": 54}, "create_knob_recolor": {"type": "Function", "def": "static bool create_knob_recolor", "sline": 62}, "lv_colorwheel_create": {"type": "Function", "def": "lv_obj_t * lv_colorwheel_create(lv_obj_t * parent, bool knob_recolor)", "sline": 77, "body": "{\n    LV_LOG_INFO(\"begin\");\n    create_knob_recolor = knob_recolor;\n\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_colorwheel_set_hsv": {"type": "Function", "def": "bool lv_colorwheel_set_hsv(lv_obj_t * obj, lv_color_hsv_t hsv)", "sline": 97, "body": "{\n    if(hsv.h > 360) hsv.h %= 360;\n    if(hsv.s > 100) hsv.s = 100;\n    if(hsv.v > 100) hsv.v = 100;\n\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_colorwheel_t * colorwheel = (lv_colorwheel_t *)obj;\n\n    if(colorwheel->hsv.h == hsv.h && colorwheel->hsv.s == hsv.s && colorwheel->hsv.v == hsv.v) return false;\n\n    colorwheel->hsv = hsv;\n\n    refr_knob_pos(obj);\n\n    lv_obj_invalidate(obj);\n\n    return true;\n}"}, "lv_colorwheel_set_rgb": {"type": "Function", "def": "bool lv_colorwheel_set_rgb(lv_obj_t * obj, lv_color_t color)", "sline": 123, "body": "{\n    lv_color32_t c32;\n    c32.full = lv_color_to32(color);\n\n    return lv_colorwheel_set_hsv(obj,  lv_color_rgb_to_hsv(c32.ch.red, c32.ch.green, c32.ch.blue));\n}"}, "lv_colorwheel_set_mode": {"type": "Function", "def": "void lv_colorwheel_set_mode(lv_obj_t * obj, lv_colorwheel_mode_t mode)", "sline": 136, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_colorwheel_t * colorwheel = (lv_colorwheel_t *)obj;\n\n    colorwheel->mode = mode;\n    refr_knob_pos(obj);\n    lv_obj_invalidate(obj);\n}"}, "lv_colorwheel_set_mode_fixed": {"type": "Function", "def": "void lv_colorwheel_set_mode_fixed(lv_obj_t * obj, bool fixed)", "sline": 151, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_colorwheel_t * colorwheel = (lv_colorwheel_t *)obj;\n\n    colorwheel->mode_fixed = fixed;\n}"}, "lv_colorwheel_get_hsv": {"type": "Function", "def": "lv_color_hsv_t lv_colorwheel_get_hsv(lv_obj_t * obj)", "sline": 169, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_colorwheel_t * colorwheel = (lv_colorwheel_t *)obj;\n\n    return colorwheel->hsv;\n}"}, "lv_colorwheel_get_rgb": {"type": "Function", "def": "lv_color_t lv_colorwheel_get_rgb(lv_obj_t * obj)", "sline": 182, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_colorwheel_t * colorwheel = (lv_colorwheel_t *)obj;\n\n    return lv_color_hsv_to_rgb(colorwheel->hsv.h, colorwheel->hsv.s, colorwheel->hsv.v);\n}"}, "lv_colorwheel_get_color_mode": {"type": "Function", "def": "lv_colorwheel_mode_t lv_colorwheel_get_color_mode(lv_obj_t * obj)", "sline": 195, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_colorwheel_t * colorwheel = (lv_colorwheel_t *)obj;\n\n    return colorwheel->mode;\n}"}, "lv_colorwheel_get_color_mode_fixed": {"type": "Function", "def": "bool lv_colorwheel_get_color_mode_fixed(lv_obj_t * obj)", "sline": 208, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_colorwheel_t * colorwheel = (lv_colorwheel_t *)obj;\n\n    return colorwheel->mode_fixed;\n}"}, "fast_hsv2rgb": {"type": "Function", "def": "static void fast_hsv2rgb(uint16_t h, uint8_t s, uint8_t v, uint8_t * r, uint8_t * g, uint8_t * b)", "sline": 617, "body": "{\n    if(!s) {\n        *r = *g = *b = v;\n        return;\n    }\n\n    uint8_t sextant = h >> 8;\n    HSV_PTR_SWAP(sextant, r, g, b); /*Swap pointers so the conversion code is the same*/\n\n    *g = v;\n\n    uint8_t bb = ~s;\n    uint16_t ww = v * bb; /*Don't try to be precise, but instead, be fast*/\n    *b = ww >> 8;\n\n    uint8_t h_frac = h & 0xff;\n\n    if(!(sextant & 1)) {\n        /*Up slope*/\n        ww = !h_frac ? ((uint16_t)s << 8) : (s * (uint8_t)(-h_frac)); /*Skip multiply if not required*/\n    }\n    else {\n        /*Down slope*/\n        ww = s * h_frac;\n    }\n    bb = ww >> 8;\n    bb = ~bb;\n    ww = v * bb;\n    *r = ww >> 8;\n}"}, "carbit_updater/lvgl/src/extra/widgets/colorwheel/lv_colorwheel.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/colorwheel/lv_colorwheel.c"}}, "carbit_updater/lvgl/src/widgets/lv_btn.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "lv_obj": {"type": "Variable", "def": "#include ../core/lv_obj.h", "sline": 19}, "lv_btn_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 30, "in_struct": "lv_btn_t"}, "lv_btn_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n} lv_btn_t", "sline": 31}, "lv_btn_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_btn_class", "sline": 33}, "lv_btn_create": {"type": "Function", "def": "lv_obj_t * lv_btn_create(lv_obj_t * parent)", "sline": 44}, "carbit_updater/lvgl/src/widgets/lv_btn.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_btn.h"}}, "carbit_updater/lvgl/src/font/lv_font_unscii_8.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_unscii_8.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_unscii_8.c"}}, "carbit_updater/lvgl/src/widgets/lv_arc.c": {"lv_arc": {"type": "Variable", "def": "#include lv_arc.h", "sline": 9, "include": ["carbit_updater/lvgl/src/widgets/lv_arc.h", null]}, "lv_group": {"type": "Variable", "def": "#include ../core/lv_group.h", "sline": 12}, "lv_indev": {"type": "Variable", "def": "#include ../core/lv_indev.h", "sline": 13}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 14}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 15}, "lv_draw_arc": {"type": "Variable", "def": "#include ../draw/lv_draw_arc.h", "sline": 16}, "lv_arc_constructor": {"type": "Function", "def": "static void lv_arc_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 315, "body": "{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_arc_t * arc = (lv_arc_t *)obj;\n\n    /*Initialize the allocated 'ext'*/\n    arc->rotation = 0;\n    arc->bg_angle_start = 135;\n    arc->bg_angle_end   = 45;\n    arc->indic_angle_start = 135;\n    arc->indic_angle_end   = 270;\n    arc->type = LV_ARC_MODE_NORMAL;\n    arc->value = VALUE_UNSET;\n    arc->min_close = 1;\n    arc->min_value = 0;\n    arc->max_value = 100;\n    arc->dragging = false;\n    arc->chg_rate = 720;\n    arc->last_tick = lv_tick_get();\n    arc->last_angle = arc->indic_angle_end;\n\n    lv_obj_add_flag(obj, LV_OBJ_FLAG_CLICKABLE);\n    lv_obj_clear_flag(obj, LV_OBJ_FLAG_SCROLL_CHAIN);\n    lv_obj_set_ext_click_area(obj, LV_DPI_DEF / 10);\n\n\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}"}, "lv_arc_draw": {"type": "Function", "def": "static void lv_arc_draw(lv_event_t * e)", "sline": 546, "body": "{\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_arc_t * arc = (lv_arc_t *)obj;\n\n    const lv_area_t * clip_area = lv_event_get_param(e);\n\n    lv_point_t center;\n    lv_coord_t arc_r;\n    get_center(obj, &center, &arc_r);\n\n    lv_obj_draw_part_dsc_t part_draw_dsc;\n    lv_obj_draw_dsc_init(&part_draw_dsc, clip_area);\n\n    /*Draw the background arc*/\n    lv_draw_arc_dsc_t arc_dsc;\n    if(arc_r > 0) {\n        lv_draw_arc_dsc_init(&arc_dsc);\n        lv_obj_init_draw_arc_dsc(obj, LV_PART_MAIN, &arc_dsc);\n\n        part_draw_dsc.part = LV_PART_MAIN;\n        part_draw_dsc.class_p = MY_CLASS;\n        part_draw_dsc.type = LV_ARC_DRAW_PART_BACKGROUND;\n        part_draw_dsc.p1 = &center;\n        part_draw_dsc.radius = arc_r;\n        part_draw_dsc.arc_dsc = &arc_dsc;\n        lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n\n        lv_draw_arc(center.x, center.y, part_draw_dsc.radius, arc->bg_angle_start + arc->rotation,\n                    arc->bg_angle_end + arc->rotation, clip_area,\n                    &arc_dsc);\n\n        lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n    }\n\n    /*make the indicator arc smaller or larger according to its greatest padding value*/\n    lv_coord_t left_indic = lv_obj_get_style_pad_left(obj, LV_PART_INDICATOR);\n    lv_coord_t right_indic = lv_obj_get_style_pad_right(obj, LV_PART_INDICATOR);\n    lv_coord_t top_indic = lv_obj_get_style_pad_top(obj, LV_PART_INDICATOR);\n    lv_coord_t bottom_indic = lv_obj_get_style_pad_bottom(obj, LV_PART_INDICATOR);\n    lv_coord_t indic_r = arc_r - LV_MAX4(left_indic, right_indic, top_indic, bottom_indic);\n\n    if(indic_r > 0) {\n        lv_draw_arc_dsc_init(&arc_dsc);\n        lv_obj_init_draw_arc_dsc(obj, LV_PART_INDICATOR, &arc_dsc);\n\n        part_draw_dsc.part = LV_PART_INDICATOR;\n        part_draw_dsc.class_p = MY_CLASS;\n        part_draw_dsc.type = LV_ARC_DRAW_PART_FOREGROUND;\n        part_draw_dsc.p1 = &center;\n        part_draw_dsc.radius = indic_r;\n        part_draw_dsc.arc_dsc = &arc_dsc;\n        lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n\n        if(arc_dsc.width > part_draw_dsc.radius) arc_dsc.width = part_draw_dsc.radius;\n        lv_draw_arc(center.x, center.y, part_draw_dsc.radius, arc->indic_angle_start + arc->rotation,\n                    arc->indic_angle_end + arc->rotation, clip_area,\n                    &arc_dsc);\n\n        lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n    }\n\n    lv_area_t knob_area;\n    get_knob_area(obj, &center, arc_r, &knob_area);\n\n    lv_draw_rect_dsc_t knob_rect_dsc;\n    lv_draw_rect_dsc_init(&knob_rect_dsc);\n    lv_obj_init_draw_rect_dsc(obj, LV_PART_KNOB, &knob_rect_dsc);\n\n    part_draw_dsc.part = LV_PART_KNOB;\n    part_draw_dsc.class_p = MY_CLASS;\n    part_draw_dsc.type = LV_ARC_DRAW_PART_KNOB;\n    part_draw_dsc.draw_area = &knob_area;\n    part_draw_dsc.rect_dsc = &knob_rect_dsc;\n    lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n\n    lv_draw_rect(&knob_area, clip_area, &knob_rect_dsc);\n\n    lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n}"}, "lv_arc_event": {"type": "Function", "def": "static void lv_arc_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 346, "body": "{\n    LV_UNUSED(class_p);\n\n    lv_res_t res;\n\n    /*Call the ancestor's event handler*/\n    res = lv_obj_event_base(MY_CLASS, e);\n    if(res != LV_RES_OK) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_arc_t * arc = (lv_arc_t *)lv_event_get_target(e);\n    if(code == LV_EVENT_PRESSING) {\n        lv_indev_t * indev = lv_indev_get_act();\n        if(indev == NULL) return;\n\n        /*Handle only pointers here*/\n        lv_indev_type_t indev_type = lv_indev_get_type(indev);\n        if(indev_type != LV_INDEV_TYPE_POINTER) return;\n\n        lv_point_t p;\n        lv_indev_get_point(indev, &p);\n\n        /*Make point relative to the arc's center*/\n        lv_point_t center;\n        lv_coord_t r;\n        get_center(obj, &center, &r);\n\n        p.x -=  center.x;\n        p.y -=  center.y;\n\n        /*Enter dragging mode if pressed out of the knob*/\n        if(arc->dragging == false) {\n            lv_coord_t indic_width = lv_obj_get_style_arc_width(obj, LV_PART_INDICATOR);\n            r -=  indic_width;\n            /*Add some more sensitive area if there is no advanced git testing.\n             * (Advanced hit testing is more precise)*/\n            if(lv_obj_has_flag(obj, LV_OBJ_FLAG_ADV_HITTEST)) {\n                r -= indic_width;\n\n            } else {\n                r -= LV_MAX(r / 4, indic_width);\n            }\n            if(r < 1) r = 1;\n\n            if(p.x * p.x + p.y * p.y > r * r) {\n                arc->dragging = true;\n                arc->last_tick = lv_tick_get(); /*Capture timestamp at dragging start*/\n            }\n        }\n\n        /*It must be in \"dragging\" mode to turn the arc*/\n        if(arc->dragging == false) return;\n\n        /*No angle can be determined if exactly the middle of the arc is being pressed*/\n        if(p.x == 0 && p.y == 0) return;\n\n        /*Calculate the angle of the pressed point*/\n        int16_t angle;\n        int16_t bg_end = arc->bg_angle_end;\n        if(arc->bg_angle_end < arc->bg_angle_start) {\n            bg_end = arc->bg_angle_end + 360;\n        }\n\n        angle = lv_atan2(p.y, p.x);\n        angle -= arc->rotation;\n        angle -= arc->bg_angle_start;  /*Make the angle relative to the start angle*/\n\n        if(angle < 0) angle += 360;\n\n        int16_t deg_range = bg_end - arc->bg_angle_start;\n\n        int16_t last_angle_rel = arc->last_angle - arc->bg_angle_start;\n        int16_t delta_angle = angle - last_angle_rel;\n\n        /*Do not allow big jumps.\n         *It's mainly to avoid jumping to the opposite end if the \"dead\" range between min. and max. is crossed.\n         *Check which end was closer on the last valid press (arc->min_close) and prefer that end*/\n        if(LV_ABS(delta_angle) > 280) {\n            if(arc->min_close) angle = 0;\n            else angle = deg_range;\n        }\n        else {\n            if(angle < deg_range / 2)arc->min_close = 1;\n            else arc->min_close = 0;\n        }\n\n        /*Calculate the slew rate limited angle based on change rate (degrees/sec)*/\n        delta_angle = angle - last_angle_rel;\n        uint32_t delta_tick = lv_tick_elaps(arc->last_tick);\n        int16_t delta_angle_max = (arc->chg_rate * delta_tick) / 1000;\n\n        if(delta_angle > delta_angle_max) {\n            delta_angle = delta_angle_max;\n        }\n        else if(delta_angle < -delta_angle_max) {\n            delta_angle = -delta_angle_max;\n        }\n\n        angle = last_angle_rel + delta_angle; /*Apply the limited angle change*/\n\n        /*Rounding for symmetry*/\n        int32_t round = ((bg_end - arc->bg_angle_start) * 8) / (arc->max_value - arc->min_value);\n        round = (round + 4) >> 4;\n        angle += round;\n\n        angle += arc->bg_angle_start;  /*Make the angle absolute again*/\n\n        /*Set the new value*/\n        int16_t old_value = arc->value;\n        int16_t new_value = lv_map(angle, arc->bg_angle_start, bg_end, arc->min_value, arc->max_value);\n        if(new_value != lv_arc_get_value(obj)) {\n            arc->last_tick = lv_tick_get(); /*Cache timestamp for the next iteration*/\n            lv_arc_set_value(obj, new_value); /*set_value caches the last_angle for the next iteration*/\n            if(new_value != old_value) {\n                res = lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n                if(res != LV_RES_OK) return;\n            }\n        }\n\n        /*Don't let the elapsed time become too big while sitting on an end point*/\n        if(new_value == arc->min_value || new_value == arc->max_value) {\n            arc->last_tick = lv_tick_get(); /*Cache timestamp for the next iteration*/\n        }\n    }\n    else if(code == LV_EVENT_RELEASED || code == LV_EVENT_PRESS_LOST) {\n        arc->dragging = false;\n\n        /*Leave edit mode if released. (No need to wait for LONG_PRESS)*/\n        lv_group_t * g             = lv_obj_get_group(obj);\n        bool editing               = lv_group_get_editing(g);\n        lv_indev_type_t indev_type = lv_indev_get_type(lv_indev_get_act());\n        if(indev_type == LV_INDEV_TYPE_ENCODER) {\n            if(editing) lv_group_set_editing(g, false);\n        }\n\n    }\n    else if(code == LV_EVENT_KEY) {\n        char c = *((char *)lv_event_get_param(e));\n\n        int16_t old_value = arc->value;\n        if(c == LV_KEY_RIGHT || c == LV_KEY_UP) {\n            lv_arc_set_value(obj, lv_arc_get_value(obj) + 1);\n        }\n        else if(c == LV_KEY_LEFT || c == LV_KEY_DOWN) {\n            lv_arc_set_value(obj, lv_arc_get_value(obj) - 1);\n        }\n\n        if(old_value != arc->value) {\n            res = lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n            if(res != LV_RES_OK) return;\n        }\n    }\n    else if(code == LV_EVENT_HIT_TEST) {\n        lv_hit_test_info_t * info = lv_event_get_param(e);;\n\n        lv_point_t p;\n        lv_coord_t r;\n        get_center(obj, &p, &r);\n\n        lv_coord_t ext_click_area = 0;\n        if(obj->spec_attr) ext_click_area = obj->spec_attr->ext_click_pad;\n\n        lv_coord_t w = lv_obj_get_style_arc_width(obj, LV_PART_MAIN);\n        r -= w + ext_click_area;\n\n        lv_area_t a;\n        /*Invalid if clicked inside*/\n        lv_area_set(&a, p.x - r, p.y - r, p.x + r, p.y + r);\n        if(_lv_area_is_point_on(&a, info->point, LV_RADIUS_CIRCLE)) {\n            info->res = false;\n             return;\n        }\n\n        /*Valid if no clicked outside*/\n        lv_area_increase(&a, w + ext_click_area * 2, w + ext_click_area * 2);\n        info->res = _lv_area_is_point_on(&a, info->point, LV_RADIUS_CIRCLE);\n    }\n    else if(code == LV_EVENT_REFR_EXT_DRAW_SIZE) {\n        lv_coord_t bg_left = lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n        lv_coord_t bg_right = lv_obj_get_style_pad_right(obj, LV_PART_MAIN);\n        lv_coord_t bg_top = lv_obj_get_style_pad_top(obj, LV_PART_MAIN);\n        lv_coord_t bg_bottom = lv_obj_get_style_pad_bottom(obj, LV_PART_MAIN);\n        lv_coord_t bg_pad = LV_MAX4(bg_left, bg_right, bg_top, bg_bottom);\n\n        lv_coord_t knob_left = lv_obj_get_style_pad_left(obj, LV_PART_KNOB);\n        lv_coord_t knob_right = lv_obj_get_style_pad_right(obj, LV_PART_KNOB);\n        lv_coord_t knob_top = lv_obj_get_style_pad_top(obj, LV_PART_KNOB);\n        lv_coord_t knob_bottom = lv_obj_get_style_pad_bottom(obj, LV_PART_KNOB);\n        lv_coord_t knob_pad = LV_MAX4(knob_left, knob_right, knob_top, knob_bottom) + 2;\n\n        lv_coord_t * s = lv_event_get_param(e);\n        *s = LV_MAX(*s, knob_pad - bg_pad);\n    }\n    else if(code == LV_EVENT_DRAW_MAIN) {\n        lv_arc_draw(e);\n    }\n}"}, "inv_arc_area": {"type": "Function", "def": "static void inv_arc_area(lv_obj_t * obj, uint16_t start_angle, uint16_t end_angle, lv_part_t part)", "sline": 627, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_arc_t * arc = (lv_arc_t *)obj;\n\n    if(start_angle == end_angle) return;\n\n    if(start_angle > 360) start_angle -= 360;\n    if(end_angle > 360) end_angle -= 360;\n\n    /*Skip this complicated invalidation if the arc is not visible*/\n    if(lv_obj_is_visible(obj) == false) return;\n\n    lv_coord_t left = lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n    lv_coord_t right = lv_obj_get_style_pad_right(obj, LV_PART_MAIN);\n    lv_coord_t top = lv_obj_get_style_pad_top(obj, LV_PART_MAIN);\n    lv_coord_t bottom = lv_obj_get_style_pad_bottom(obj, LV_PART_MAIN);\n    lv_coord_t rout       = (LV_MIN(lv_obj_get_width(obj) - left - right, lv_obj_get_height(obj) - top - bottom)) / 2;\n    lv_coord_t x       = obj->coords.x1 + rout + left;\n    lv_coord_t y       = obj->coords.y1 + rout + top;\n    lv_coord_t w = lv_obj_get_style_arc_width(obj, part);\n    lv_coord_t rounded = lv_obj_get_style_arc_rounded(obj, part);\n\n    if(part == LV_PART_INDICATOR) {\n        lv_coord_t knob_extra_size = lv_obj_calculate_ext_draw_size(obj, LV_PART_KNOB);\n\n        lv_coord_t knob_left = lv_obj_get_style_pad_left(obj, LV_PART_KNOB);\n        lv_coord_t knob_right = lv_obj_get_style_pad_right(obj, LV_PART_KNOB);\n        lv_coord_t knob_top = lv_obj_get_style_pad_top(obj, LV_PART_KNOB);\n        lv_coord_t knob_bottom = lv_obj_get_style_pad_bottom(obj, LV_PART_KNOB);\n\n        knob_extra_size += LV_MAX4(knob_left, knob_right, knob_top, knob_bottom);\n\n        w += knob_extra_size * 2 + 2;\n        rout += knob_extra_size + 2;\n    }\n\n    start_angle += arc->rotation;\n    end_angle += arc->rotation;\n\n    if(start_angle > 360) start_angle -= 360;\n    if(end_angle > 360) end_angle -= 360;\n\n    lv_area_t inv_area;\n    lv_draw_arc_get_area(x, y, rout, start_angle, end_angle, w, rounded, &inv_area);\n    lv_obj_invalidate_area(obj, &inv_area);\n}"}, "get_center": {"type": "Function", "def": "static void get_center(lv_obj_t * obj, lv_point_t * center, lv_coord_t * arc_r)", "sline": 675, "body": "{\n    lv_coord_t left_bg = lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n    lv_coord_t right_bg = lv_obj_get_style_pad_right(obj, LV_PART_MAIN);\n    lv_coord_t top_bg = lv_obj_get_style_pad_top(obj, LV_PART_MAIN);\n    lv_coord_t bottom_bg = lv_obj_get_style_pad_bottom(obj, LV_PART_MAIN);\n\n    lv_coord_t r = (LV_MIN(lv_obj_get_width(obj) - left_bg - right_bg,\n                           lv_obj_get_height(obj) - top_bg - bottom_bg)) / 2;\n\n    *arc_r = r;\n    center->x = obj->coords.x1 + r + left_bg;\n    center->y = obj->coords.y1 + r + top_bg;\n\n    lv_coord_t indic_width = lv_obj_get_style_arc_width(obj, LV_PART_INDICATOR);\n    r -= indic_width;\n}"}, "get_knob_area": {"type": "Function", "def": "static void get_knob_area(lv_obj_t * obj, const lv_point_t * center, lv_coord_t r, lv_area_t * knob_area)", "sline": 693, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_arc_t * arc = (lv_arc_t *)obj;\n\n    lv_coord_t indic_width = lv_obj_get_style_arc_width(obj, LV_PART_INDICATOR);\n    lv_coord_t indic_width_half = indic_width / 2;\n    r -= indic_width_half;\n\n    uint16_t angle = arc->rotation;\n    if(arc->type == LV_ARC_MODE_NORMAL) {\n        angle += arc->indic_angle_end;\n    }\n    else if(arc->type == LV_ARC_MODE_REVERSE) {\n        angle += arc->indic_angle_start;\n    }\n    else if(arc->type == LV_ARC_MODE_SYMMETRICAL) {\n        int32_t range_midpoint = (int32_t)(arc->min_value + arc->max_value) / 2;\n        if(arc->value < range_midpoint) angle += arc->indic_angle_start;\n        else angle += arc->indic_angle_end;\n    }\n    lv_coord_t knob_x = (r * lv_trigo_sin(angle + 90)) >> LV_TRIGO_SHIFT;\n    lv_coord_t knob_y = (r * lv_trigo_sin(angle)) >> LV_TRIGO_SHIFT;\n\n    lv_coord_t left_knob = lv_obj_get_style_pad_left(obj, LV_PART_KNOB);\n    lv_coord_t right_knob = lv_obj_get_style_pad_right(obj, LV_PART_KNOB);\n    lv_coord_t top_knob = lv_obj_get_style_pad_top(obj, LV_PART_KNOB);\n    lv_coord_t bottom_knob = lv_obj_get_style_pad_bottom(obj, LV_PART_KNOB);\n\n    knob_area->x1 = center->x + knob_x - left_knob - indic_width_half;\n    knob_area->x2 = center->x + knob_x + right_knob + indic_width_half;\n    knob_area->y1 = center->y + knob_y - top_knob - indic_width_half;\n    knob_area->y2 = center->y + knob_y + bottom_knob + indic_width_half;\n}"}, "value_update": {"type": "Function", "def": "static void value_update(lv_obj_t * obj)", "sline": 732, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_arc_t * arc = (lv_arc_t *)obj;\n\n    /*If the value is still not set to any value do not update*/\n    if(arc->value == VALUE_UNSET) return;\n\n    int16_t bg_midpoint, range_midpoint, bg_end = arc->bg_angle_end;\n    if(arc->bg_angle_end < arc->bg_angle_start) bg_end = arc->bg_angle_end + 360;\n\n    int16_t angle;\n    switch(arc->type) {\n        case LV_ARC_MODE_SYMMETRICAL:\n            bg_midpoint = (arc->bg_angle_start + bg_end) / 2;\n            range_midpoint = (int32_t)(arc->min_value + arc->max_value) / 2;\n\n            if(arc->value < range_midpoint) {\n                angle = lv_map(arc->value, arc->min_value, range_midpoint, arc->bg_angle_start, bg_midpoint);\n                lv_arc_set_start_angle(obj, angle);\n                lv_arc_set_end_angle(obj, bg_midpoint);\n            }\n            else {\n                angle = lv_map(arc->value, range_midpoint, arc->max_value, bg_midpoint, bg_end);\n                lv_arc_set_start_angle(obj, bg_midpoint);\n                lv_arc_set_end_angle(obj, angle);\n            }\n            break;\n        case LV_ARC_MODE_REVERSE:\n            angle = lv_map(arc->value, arc->min_value, arc->max_value, arc->bg_angle_start, bg_end);\n            lv_arc_set_angles(obj, angle, arc->bg_angle_end);\n            break;\n        case LV_ARC_MODE_NORMAL:\n            angle = lv_map(arc->value, arc->min_value, arc->max_value, arc->bg_angle_start, bg_end);\n            lv_arc_set_angles(obj, arc->bg_angle_start, angle);\n            break;\n        default:\n            LV_LOG_WARN(\"Invalid mode: %d\", arc->type);\n            return;\n    }\n    arc->last_angle = angle; /*Cache angle for slew rate limiting*/\n}"}, "lv_arc_class": {"type": "Variable", "def": "const lv_obj_class_t lv_arc_class  = {\n    .constructor_cb = lv_arc_constructor,\n    .event_cb = lv_arc_event,\n    .instance_size = sizeof(lv_arc_t),\n    .editable = LV_OBJ_CLASS_EDITABLE_TRUE,\n    .base_class = &lv_obj_class\n}", "sline": 44}, "lv_arc_create": {"type": "Function", "def": "lv_obj_t * lv_arc_create(lv_obj_t * parent)", "sline": 60, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_arc_set_start_angle": {"type": "Function", "def": "void lv_arc_set_start_angle(lv_obj_t * obj, uint16_t start)", "sline": 80, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_arc_t * arc = (lv_arc_t *)obj;\n\n    if(start > 360) start -= 360;\n\n    int16_t old_delta =  arc->indic_angle_end - arc->indic_angle_start;\n    int16_t new_delta =  arc->indic_angle_end - start;\n\n    if(old_delta < 0) old_delta = 360 + old_delta;\n    if(new_delta < 0) new_delta = 360 + new_delta;\n\n    if(LV_ABS(new_delta - old_delta) > 180)  lv_obj_invalidate(obj);\n    else if(new_delta < old_delta) inv_arc_area(obj, arc->indic_angle_start, start, LV_PART_INDICATOR);\n    else if(old_delta < new_delta) inv_arc_area(obj, start, arc->indic_angle_start, LV_PART_INDICATOR);\n\n    arc->indic_angle_start = start;\n}"}, "lv_arc_set_end_angle": {"type": "Function", "def": "void lv_arc_set_end_angle(lv_obj_t * obj, uint16_t end)", "sline": 100, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_arc_t * arc = (lv_arc_t *)obj;\n    if(end > 360) end -= 360;\n\n    int16_t old_delta =  arc->indic_angle_end - arc->indic_angle_start;\n    int16_t new_delta =  end - arc->indic_angle_start;\n\n    if(old_delta < 0) old_delta = 360 + old_delta;\n    if(new_delta < 0) new_delta = 360 + new_delta;\n\n    if(LV_ABS(new_delta - old_delta) > 180)  lv_obj_invalidate(obj);\n    else if(new_delta < old_delta) inv_arc_area(obj, end, arc->indic_angle_end, LV_PART_INDICATOR);\n    else if(old_delta < new_delta) inv_arc_area(obj, arc->indic_angle_end, end, LV_PART_INDICATOR);\n\n    arc->indic_angle_end = end;\n}"}, "lv_arc_set_angles": {"type": "Function", "def": "void lv_arc_set_angles(lv_obj_t * obj, uint16_t start, uint16_t end)", "sline": 119, "body": "{\n    lv_arc_set_end_angle(obj, end);\n    lv_arc_set_start_angle(obj, start);\n}"}, "lv_arc_set_bg_start_angle": {"type": "Function", "def": "void lv_arc_set_bg_start_angle(lv_obj_t * obj, uint16_t start)", "sline": 125, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_arc_t * arc = (lv_arc_t *)obj;\n\n    if(start > 360) start -= 360;\n\n    int16_t old_delta =  arc->bg_angle_end - arc->bg_angle_start;\n    int16_t new_delta =  arc->bg_angle_end - start;\n\n    if(old_delta < 0) old_delta = 360 + old_delta;\n    if(new_delta < 0) new_delta = 360 + new_delta;\n\n    if(LV_ABS(new_delta - old_delta) > 180)  lv_obj_invalidate(obj);\n    else if(new_delta < old_delta) inv_arc_area(obj, arc->bg_angle_start, start, LV_PART_MAIN);\n    else if(old_delta < new_delta) inv_arc_area(obj, start, arc->bg_angle_start, LV_PART_MAIN);\n\n    arc->bg_angle_start = start;\n\n    value_update(obj);\n}"}, "lv_arc_set_bg_end_angle": {"type": "Function", "def": "void lv_arc_set_bg_end_angle(lv_obj_t * obj, uint16_t end)", "sline": 147, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_arc_t * arc = (lv_arc_t *)obj;\n\n    if(end > 360) end -= 360;\n\n    int16_t old_delta =  arc->bg_angle_end - arc->bg_angle_start;\n    int16_t new_delta =  end - arc->bg_angle_start;\n\n    if(old_delta < 0) old_delta = 360 + old_delta;\n    if(new_delta < 0) new_delta = 360 + new_delta;\n\n    if(LV_ABS(new_delta - old_delta) > 180)  lv_obj_invalidate(obj);\n    else if(new_delta < old_delta) inv_arc_area(obj, end, arc->bg_angle_end, LV_PART_MAIN);\n    else if(old_delta < new_delta) inv_arc_area(obj, arc->bg_angle_end, end, LV_PART_MAIN);\n\n    arc->bg_angle_end = end;\n\n    value_update(obj);\n}"}, "lv_arc_set_bg_angles": {"type": "Function", "def": "void lv_arc_set_bg_angles(lv_obj_t * obj, uint16_t start, uint16_t end)", "sline": 169, "body": "{\n    lv_arc_set_bg_end_angle(obj, end);\n    lv_arc_set_bg_start_angle(obj, start);\n}"}, "lv_arc_set_rotation": {"type": "Function", "def": "void lv_arc_set_rotation(lv_obj_t * obj, uint16_t rotation)", "sline": 175, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_arc_t * arc = (lv_arc_t *)obj;\n\n    arc->rotation = rotation;\n\n    lv_obj_invalidate(obj);\n}"}, "lv_arc_set_mode": {"type": "Function", "def": "void lv_arc_set_mode(lv_obj_t * obj, lv_arc_mode_t type)", "sline": 185, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_arc_t * arc = (lv_arc_t *)obj;\n\n    int16_t val = arc->value;\n\n    arc->type = type;\n    arc->value = -1; /** Force set_value handling*/\n\n    int16_t bg_midpoint, bg_end = arc->bg_angle_end;\n    if(arc->bg_angle_end < arc->bg_angle_start) bg_end = arc->bg_angle_end + 360;\n\n    switch(arc->type) {\n        case LV_ARC_MODE_SYMMETRICAL:\n            bg_midpoint = (arc->bg_angle_start + bg_end) / 2;\n            lv_arc_set_start_angle(obj, bg_midpoint);\n            lv_arc_set_end_angle(obj, bg_midpoint);\n            break;\n        case LV_ARC_MODE_REVERSE:\n            lv_arc_set_end_angle(obj, arc->bg_angle_end);\n            break;\n        default: /** LV_ARC_TYPE_NORMAL*/\n            lv_arc_set_start_angle(obj, arc->bg_angle_start);\n    }\n\n    lv_arc_set_value(obj, val);\n}"}, "lv_arc_set_value": {"type": "Function", "def": "void lv_arc_set_value(lv_obj_t * obj, int16_t value)", "sline": 214, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_arc_t * arc = (lv_arc_t *)obj;\n\n    if(arc->value == value) return;\n\n    int16_t new_value;\n    new_value = value > arc->max_value ? arc->max_value : value;\n    new_value = new_value < arc->min_value ? arc->min_value : new_value;\n\n    if(arc->value == new_value) return;\n    arc->value = new_value;\n\n    value_update(obj);\n}"}, "lv_arc_set_range": {"type": "Function", "def": "void lv_arc_set_range(lv_obj_t * obj, int16_t min, int16_t max)", "sline": 231, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_arc_t * arc = (lv_arc_t *)obj;\n\n    if(arc->min_value == min && arc->max_value == max) return;\n\n    arc->min_value = min;\n    arc->max_value = max;\n\n    if(arc->value < min) {\n        arc->value = min;\n    }\n    if(arc->value > max) {\n        arc->value = max;\n    }\n\n    value_update(obj); /*value has changed relative to the new range*/\n}"}, "lv_arc_set_change_rate": {"type": "Function", "def": "void lv_arc_set_change_rate(lv_obj_t * obj, uint16_t rate)", "sline": 251, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_arc_t * arc = (lv_arc_t *)obj;\n\n    arc->chg_rate = rate;\n}"}, "lv_arc_get_angle_start": {"type": "Function", "def": "uint16_t lv_arc_get_angle_start(lv_obj_t * obj)", "sline": 263, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    return ((lv_arc_t *) obj)->indic_angle_start;\n}"}, "lv_arc_get_angle_end": {"type": "Function", "def": "uint16_t lv_arc_get_angle_end(lv_obj_t * obj)", "sline": 269, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    return ((lv_arc_t *) obj)->indic_angle_end;\n}"}, "lv_arc_get_bg_angle_start": {"type": "Function", "def": "uint16_t lv_arc_get_bg_angle_start(lv_obj_t * obj)", "sline": 275, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    return ((lv_arc_t *) obj)->bg_angle_start;\n}"}, "lv_arc_get_bg_angle_end": {"type": "Function", "def": "uint16_t lv_arc_get_bg_angle_end(lv_obj_t * obj)", "sline": 281, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    return ((lv_arc_t *) obj)->bg_angle_end;\n}"}, "lv_arc_get_value": {"type": "Function", "def": "int16_t lv_arc_get_value(const lv_obj_t * obj)", "sline": 287, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    return ((lv_arc_t *) obj)->value;\n}"}, "lv_arc_get_min_value": {"type": "Function", "def": "int16_t lv_arc_get_min_value(const lv_obj_t * obj)", "sline": 293, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    return ((lv_arc_t *) obj)->min_value;\n}"}, "lv_arc_get_max_value": {"type": "Function", "def": "int16_t lv_arc_get_max_value(const lv_obj_t * obj)", "sline": 299, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    return ((lv_arc_t *) obj)->max_value;\n}"}, "lv_arc_get_mode": {"type": "Function", "def": "lv_arc_mode_t lv_arc_get_mode(const lv_obj_t * obj)", "sline": 305, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    return ((lv_arc_t *) obj)->type;\n}"}, "carbit_updater/lvgl/src/widgets/lv_arc.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_arc.c"}}, "carbit_updater/lvgl/src/widgets/lv_slider.c": {"lv_slider": {"type": "Variable", "def": "#include lv_slider.h", "sline": 9, "include": ["carbit_updater/lvgl/src/widgets/lv_slider.h", null]}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 12}, "lv_group": {"type": "Variable", "def": "#include ../core/lv_group.h", "sline": 13}, "lv_indev": {"type": "Variable", "def": "#include ../core/lv_indev.h", "sline": 14}, "lv_draw": {"type": "Variable", "def": "#include ../draw/lv_draw.h", "sline": 15}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 16}, "lv_disp": {"type": "Variable", "def": "#include ../core/lv_disp.h", "sline": 17}, "lv_img": {"type": "Variable", "def": "#include lv_img.h", "sline": 18, "include": ["carbit_updater/lvgl/src/widgets/lv_img.h", null]}, "lv_slider_constructor": {"type": "Function", "def": "static void lv_slider_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 79, "body": "{\n    LV_UNUSED(class_p);\n    lv_slider_t * slider = (lv_slider_t *)obj;\n\n    /*Initialize the allocated 'slider'*/\n    slider->value_to_set = NULL;\n    slider->dragging = 0;\n    slider->left_knob_focus = 0;\n\n    lv_obj_clear_flag(obj, LV_OBJ_FLAG_SCROLL_CHAIN);\n    lv_obj_clear_flag(obj, LV_OBJ_FLAG_SCROLLABLE);\n    lv_obj_set_ext_click_area(obj, LV_DPX(8));\n}"}, "lv_slider_event": {"type": "Function", "def": "static void lv_slider_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 94, "body": "{\n    LV_UNUSED(class_p);\n\n    lv_res_t res;\n\n    /*Call the ancestor's event handler*/\n    res = lv_obj_event_base(MY_CLASS, e);\n    if(res != LV_RES_OK) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_slider_t * slider = (lv_slider_t *)obj;\n    lv_slider_mode_t type = lv_slider_get_mode(obj);\n\n    /*Advanced hit testing: react only on dragging the knob(s)*/\n    if(code == LV_EVENT_HIT_TEST) {\n        lv_hit_test_info_t * info = lv_event_get_param(e);\n\n        /*Ordinary slider: was the knob area hit?*/\n        info->res = _lv_area_is_point_on(&slider->right_knob_area, info->point, 0);\n\n        /*There's still a change we have a hit, if we have another knob*/\n        if((info->res == false) && (type == LV_SLIDER_MODE_RANGE)) {\n            info->res = _lv_area_is_point_on(&slider->left_knob_area, info->point, 0);\n        }\n    }\n    else if(code == LV_EVENT_PRESSED) {\n        lv_obj_invalidate(obj);\n\n        lv_point_t p;\n        slider->dragging = true;\n        if(type == LV_SLIDER_MODE_NORMAL || type == LV_SLIDER_MODE_SYMMETRICAL) {\n            slider->value_to_set = &slider->bar.cur_value;\n        }\n        else if(type == LV_SLIDER_MODE_RANGE) {\n            lv_indev_get_point(lv_indev_get_act(), &p);\n            bool hor = lv_obj_get_width(obj) >= lv_obj_get_height(obj);\n            lv_base_dir_t base_dir = lv_obj_get_style_base_dir(obj, LV_PART_MAIN);\n\n            lv_coord_t dist_left, dist_right;\n            if(hor) {\n                if((base_dir != LV_BASE_DIR_RTL && p.x > slider->right_knob_area.x2) || (base_dir == LV_BASE_DIR_RTL &&\n                                                                                         p.x < slider->right_knob_area.x1)) {\n                    slider->value_to_set = &slider->bar.cur_value;\n                }\n                else if((base_dir != LV_BASE_DIR_RTL && p.x < slider->left_knob_area.x1) || (base_dir == LV_BASE_DIR_RTL &&\n                                                                                             p.x > slider->left_knob_area.x2)) {\n                    slider->value_to_set = &slider->bar.start_value;\n                }\n                else {\n                    /*Calculate the distance from each knob*/\n                    dist_left = LV_ABS((slider->left_knob_area.x1 + (slider->left_knob_area.x2 - slider->left_knob_area.x1) / 2) - p.x);\n                    dist_right = LV_ABS((slider->right_knob_area.x1 + (slider->right_knob_area.x2 - slider->right_knob_area.x1) / 2) - p.x);\n\n                    /*Use whichever one is closer*/\n                    if(dist_right < dist_left) {\n                        slider->value_to_set = &slider->bar.cur_value;\n                        slider->left_knob_focus = 0;\n                    }\n                    else {\n                        slider->value_to_set = &slider->bar.start_value;\n                        slider->left_knob_focus = 1;\n                    }\n                }\n            }\n            else {\n                if(p.y < slider->right_knob_area.y1) {\n                    slider->value_to_set = &slider->bar.cur_value;\n                }\n                else if(p.y > slider->left_knob_area.y2) {\n                    slider->value_to_set = &slider->bar.start_value;\n                }\n                else {\n                    /*Calculate the distance from each knob*/\n                    dist_left = LV_ABS((slider->left_knob_area.y1 + (slider->left_knob_area.y2 - slider->left_knob_area.y1) / 2) - p.y);\n                    dist_right = LV_ABS((slider->right_knob_area.y1 + (slider->right_knob_area.y2 - slider->right_knob_area.y1) / 2) - p.y);\n\n                    /*Use whichever one is closer*/\n                    if(dist_right < dist_left) {\n                        slider->value_to_set = &slider->bar.cur_value;\n                        slider->left_knob_focus = 0;\n                    }\n                    else {\n                        slider->value_to_set = &slider->bar.start_value;\n                        slider->left_knob_focus = 1;\n                    }\n                }\n            }\n        }\n    }\n    else if(code == LV_EVENT_PRESSING && slider->value_to_set != NULL) {\n        lv_indev_t * indev = lv_indev_get_act();\n        if(lv_indev_get_type(indev) != LV_INDEV_TYPE_POINTER) return;\n\n        lv_point_t p;\n        lv_indev_get_point(indev, &p);\n        lv_base_dir_t base_dir = lv_obj_get_style_base_dir(obj, LV_PART_MAIN);\n\n        lv_coord_t w = lv_obj_get_width(obj);\n        lv_coord_t h = lv_obj_get_height(obj);\n\n        lv_coord_t bg_left = lv_obj_get_style_pad_left(obj,   LV_PART_MAIN);\n        lv_coord_t bg_right = lv_obj_get_style_pad_right(obj,  LV_PART_MAIN);\n        lv_coord_t bg_top = lv_obj_get_style_pad_top(obj,    LV_PART_MAIN);\n        lv_coord_t bg_bottom = lv_obj_get_style_pad_bottom(obj, LV_PART_MAIN);\n\n        int32_t range = slider->bar.max_value - slider->bar.min_value;\n        int32_t new_value = 0;\n        int32_t real_max_value = slider->bar.max_value;\n        int32_t real_min_value = slider->bar.min_value;\n\n        if(w >= h) {\n            lv_coord_t indic_w = w - bg_left - bg_right;\n            if(base_dir == LV_BASE_DIR_RTL) {\n                new_value = (obj->coords.x2 - bg_right) - p.x; /*Make the point relative to the indicator*/\n            }\n            else {\n                new_value = p.x - (obj->coords.x1 + bg_left); /*Make the point relative to the indicator*/\n            }\n            new_value = (new_value * range) / indic_w;\n            new_value += slider->bar.min_value;\n        }\n        else {\n            lv_coord_t indic_h = h - bg_bottom - bg_top;\n            new_value = p.y - (obj->coords.y2 + bg_bottom); /*Make the point relative to the indicator*/\n            new_value = (-new_value * range) / indic_h;\n            new_value += slider->bar.min_value;\n\n        }\n\n        /*Figure out the min. and max. for this mode*/\n        if(slider->value_to_set == &slider->bar.start_value) {\n            real_max_value = slider->bar.cur_value;\n        }\n        else {\n            real_min_value = slider->bar.start_value;\n        }\n\n        if(new_value < real_min_value) new_value = real_min_value;\n        else if(new_value > real_max_value) new_value = real_max_value;\n        if(*slider->value_to_set != new_value) {\n            *slider->value_to_set = new_value;\n            lv_obj_invalidate(obj);\n            res = lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n            if(res != LV_RES_OK) return;\n        }\n\n    }\n    else if(code == LV_EVENT_RELEASED || code == LV_EVENT_PRESS_LOST) {\n        slider->dragging = false;\n        slider->value_to_set = NULL;\n\n        lv_obj_invalidate(obj);\n\n        /*Leave edit mode if released. (No need to wait for LONG_PRESS)*/\n        lv_group_t * g   = lv_obj_get_group(obj);\n        bool editing     = lv_group_get_editing(g);\n        lv_indev_type_t indev_type = lv_indev_get_type(lv_indev_get_act());\n        if(indev_type == LV_INDEV_TYPE_ENCODER) {\n            if(editing) {\n                if(lv_slider_get_mode(obj) == LV_SLIDER_MODE_RANGE) {\n                    if(slider->left_knob_focus == 0) slider->left_knob_focus = 1;\n                    else {\n                        slider->left_knob_focus = 0;\n                        lv_group_set_editing(g, false);\n                    }\n                }\n                else {\n                    lv_group_set_editing(g, false);\n                }\n            }\n        }\n\n    }\n    else if(code == LV_EVENT_FOCUSED) {\n        lv_indev_type_t indev_type = lv_indev_get_type(lv_indev_get_act());\n        if(indev_type == LV_INDEV_TYPE_ENCODER || indev_type == LV_INDEV_TYPE_KEYPAD) {\n            slider->left_knob_focus = 0;\n        }\n    }\n    else if(code == LV_EVENT_SIZE_CHANGED) {\n        lv_obj_refresh_ext_draw_size(obj);\n    }\n    else if(code == LV_EVENT_REFR_EXT_DRAW_SIZE) {\n        lv_coord_t knob_left = lv_obj_get_style_pad_left(obj, LV_PART_KNOB);\n        lv_coord_t knob_right = lv_obj_get_style_pad_right(obj, LV_PART_KNOB);\n        lv_coord_t knob_top = lv_obj_get_style_pad_top(obj, LV_PART_KNOB);\n        lv_coord_t knob_bottom = lv_obj_get_style_pad_bottom(obj, LV_PART_KNOB);\n\n        /*The smaller size is the knob diameter*/\n        lv_coord_t zoom = lv_obj_get_style_transform_zoom(obj, LV_PART_KNOB);\n        lv_coord_t trans_w = lv_obj_get_style_transform_width(obj, LV_PART_KNOB);\n        lv_coord_t trans_h = lv_obj_get_style_transform_height(obj, LV_PART_KNOB);\n        lv_coord_t knob_size = LV_MIN(lv_obj_get_width(obj) + 2 * trans_w, lv_obj_get_height(obj) + 2 * trans_h) >> 1;\n        knob_size = (knob_size * zoom) >> 8;\n        knob_size += LV_MAX(LV_MAX(knob_left, knob_right), LV_MAX(knob_bottom, knob_top));\n        knob_size += 2;         /*For rounding error*/\n        knob_size += lv_obj_calculate_ext_draw_size(obj, LV_PART_KNOB);\n\n        /*Indic. size is handled by bar*/\n        lv_coord_t * s = lv_event_get_param(e);\n        *s  = LV_MAX(*s, knob_size);\n\n    }\n    else if(code == LV_EVENT_KEY) {\n        char c = *((char *)lv_event_get_param(e));\n\n        if(c == LV_KEY_RIGHT || c == LV_KEY_UP) {\n            if(!slider->left_knob_focus) lv_slider_set_value(obj, lv_slider_get_value(obj) + 1, LV_ANIM_ON);\n            else lv_slider_set_left_value(obj, lv_slider_get_left_value(obj) + 1, LV_ANIM_ON);\n\n            res = lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n            if(res != LV_RES_OK) return;\n        }\n        else if(c == LV_KEY_LEFT || c == LV_KEY_DOWN) {\n            if(!slider->left_knob_focus) lv_slider_set_value(obj, lv_slider_get_value(obj) - 1, LV_ANIM_ON);\n            else lv_slider_set_left_value(obj, lv_slider_get_left_value(obj) - 1, LV_ANIM_ON);\n\n            res = lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n            if(res != LV_RES_OK) return;\n        }\n    }\n    else if(code == LV_EVENT_DRAW_MAIN) {\n        draw_knob(e);\n    }\n}"}, "position_knob": {"type": "Function", "def": "static void position_knob(lv_obj_t * obj, lv_area_t * knob_area, lv_coord_t knob_size, bool hor)", "sline": 419, "body": "{\n\n    if(hor) {\n        knob_area->x1 -= (knob_size >> 1);\n        knob_area->x2 = knob_area->x1 + knob_size - 1;\n        knob_area->y1 = obj->coords.y1;\n        knob_area->y2 = obj->coords.y2;\n    }\n    else {\n        knob_area->y1 -= (knob_size >> 1);\n        knob_area->y2 = knob_area->y1 + knob_size - 1;\n        knob_area->x1 = obj->coords.x1;\n        knob_area->x2 = obj->coords.x2;\n    }\n\n    lv_coord_t knob_left = lv_obj_get_style_pad_left(obj,   LV_PART_KNOB);\n    lv_coord_t knob_right = lv_obj_get_style_pad_right(obj,  LV_PART_KNOB);\n    lv_coord_t knob_top = lv_obj_get_style_pad_top(obj,    LV_PART_KNOB);\n    lv_coord_t knob_bottom = lv_obj_get_style_pad_bottom(obj, LV_PART_KNOB);\n\n    lv_coord_t transf_w = lv_obj_get_style_transform_width(obj, LV_PART_KNOB);\n    lv_coord_t transf_h = lv_obj_get_style_transform_height(obj, LV_PART_KNOB);\n\n    /*Apply the paddings on the knob area*/\n    knob_area->x1 -= knob_left + transf_w;\n    knob_area->x2 += knob_right + transf_w;\n    knob_area->y1 -= knob_top + transf_h;\n    knob_area->y2 += knob_bottom + transf_h;\n}"}, "draw_knob": {"type": "Function", "def": "static void draw_knob(lv_event_t * e)", "sline": 322, "body": "{\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_slider_t * slider = (lv_slider_t *)obj;\n    const lv_area_t * clip_area = lv_event_get_param(e);\n    lv_base_dir_t base_dir = lv_obj_get_style_base_dir(obj, LV_PART_MAIN);\n\n    lv_coord_t objw = lv_obj_get_width(obj);\n    lv_coord_t objh = lv_obj_get_height(obj);\n    bool hor = objw >= objh ? true : false;\n    lv_coord_t knob_size = hor ? objh : objw;\n    bool sym = false;\n    if(slider->bar.mode == LV_BAR_MODE_SYMMETRICAL && slider->bar.min_value < 0 && slider->bar.max_value > 0) sym = true;\n\n    lv_area_t knob_area;\n\n    /*Horizontal*/\n    if(hor) {\n        if(!sym) {\n            knob_area.x1 = LV_SLIDER_KNOB_COORD(hor, base_dir == LV_BASE_DIR_RTL, slider->bar.indic_area);\n        }\n        else {\n            if(slider->bar.cur_value >= 0) {\n                knob_area.x1 = LV_SLIDER_KNOB_COORD(hor, base_dir == LV_BASE_DIR_RTL, slider->bar.indic_area);\n            }\n            else {\n                knob_area.x1 = LV_SLIDER_KNOB_COORD(hor, base_dir != LV_BASE_DIR_RTL, slider->bar.indic_area);\n            }\n        }\n    }\n    /*Vertical*/\n    else {\n        if(!sym) {\n            knob_area.y1 = slider->bar.indic_area.y1;\n        }\n        else {\n            if(slider->bar.cur_value >= 0) {\n                knob_area.y1 = slider->bar.indic_area.y1;\n            }\n            else {\n                knob_area.y1 = slider->bar.indic_area.y2;\n            }\n        }\n    }\n\n    lv_draw_rect_dsc_t knob_rect_dsc;\n    lv_draw_rect_dsc_init(&knob_rect_dsc);\n    lv_obj_init_draw_rect_dsc(obj, LV_PART_KNOB, &knob_rect_dsc);\n\n    position_knob(obj, &knob_area, knob_size, hor);\n    lv_area_copy(&slider->right_knob_area, &knob_area);\n\n    lv_obj_draw_part_dsc_t part_draw_dsc;\n    lv_obj_draw_dsc_init(&part_draw_dsc, clip_area);\n    part_draw_dsc.part = LV_PART_KNOB;\n    part_draw_dsc.class_p = MY_CLASS;\n    part_draw_dsc.type = LV_SLIDER_DRAW_PART_KNOB;\n    part_draw_dsc.id = 0;\n    part_draw_dsc.draw_area = &slider->right_knob_area;\n    part_draw_dsc.rect_dsc = &knob_rect_dsc;\n\n    if(lv_slider_get_mode(obj) != LV_SLIDER_MODE_RANGE) {\n        lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n        lv_draw_rect(&slider->right_knob_area, clip_area, &knob_rect_dsc);\n        lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n    }\n    else {\n        /*Save the draw part_draw_dsc. because it can be modified in the event*/\n        lv_draw_rect_dsc_t knob_rect_dsc_tmp;\n        lv_memcpy(&knob_rect_dsc_tmp, &knob_rect_dsc, sizeof(lv_draw_rect_dsc_t));\n\n        lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n        lv_draw_rect(&slider->right_knob_area, clip_area, &knob_rect_dsc);\n        lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n\n        /*Draw a second knob for the start_value side*/\n        if(hor) {\n            knob_area.x1 = LV_SLIDER_KNOB_COORD(hor, base_dir != LV_BASE_DIR_RTL, slider->bar.indic_area);\n        }\n        else {\n            knob_area.y1 = slider->bar.indic_area.y2;\n        }\n        position_knob(obj, &knob_area, knob_size, hor);\n        lv_area_copy(&slider->left_knob_area, &knob_area);\n\n        lv_memcpy(&knob_rect_dsc, &knob_rect_dsc_tmp, sizeof(lv_draw_rect_dsc_t));\n        part_draw_dsc.type = LV_SLIDER_DRAW_PART_KNOB_LEFT;\n        part_draw_dsc.draw_area = &slider->left_knob_area;\n        part_draw_dsc.rect_dsc = &knob_rect_dsc;\n        part_draw_dsc.id = 1;\n\n        lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n        lv_draw_rect(&slider->left_knob_area, clip_area, &knob_rect_dsc);\n        lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n    }\n}"}, "lv_slider_class": {"type": "Variable", "def": "const lv_obj_class_t lv_slider_class = {\n    .constructor_cb = lv_slider_constructor,\n    .event_cb = lv_slider_event,\n    .editable = LV_OBJ_CLASS_EDITABLE_TRUE,\n    .group_def = LV_OBJ_CLASS_GROUP_DEF_TRUE,\n    .instance_size = sizeof(lv_slider_t),\n    .base_class = &lv_bar_class\n}", "sline": 42}, "lv_slider_create": {"type": "Function", "def": "lv_obj_t * lv_slider_create(lv_obj_t * parent)", "sline": 59, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_slider_is_dragged": {"type": "Function", "def": "bool lv_slider_is_dragged(const lv_obj_t * obj)", "sline": 67, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_slider_t * slider = (lv_slider_t *)obj;\n\n    return slider->dragging ? true : false;\n}"}, "carbit_updater/lvgl/src/widgets/lv_slider.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_slider.c"}}, "carbit_updater/lvgl/src/extra/widgets/colorwheel/lv_colorwheel.h": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 16}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/colorwheel/lv_colorwheel.h:28:1)": {"type": "Enum", "def": "enum {\n    LV_COLORWHEEL_MODE_HUE,\n    LV_COLORWHEEL_MODE_SATURATION,\n    LV_COLORWHEEL_MODE_VALUE\n}", "sline": 28}, "lv_colorwheel_mode_t": {"type": "Variable", "def": "typedef uint8_t lv_colorwheel_mode_t", "sline": 33}, "lv_colorwheel_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 38, "in_struct": "lv_colorwheel_t"}, "lv_colorwheel_t.hsv": {"type": "Variable", "def": "lv_color_hsv_t hsv", "sline": 39, "in_struct": "lv_colorwheel_t"}, "lv_colorwheel_t.knob": {"type": "Variable", "def": "struct {\n        lv_point_t pos;\n        uint8_t recolor     : 1;\n    } knob", "sline": 43, "in_struct": "lv_colorwheel_t"}, "lv_colorwheel_t.last_click_time": {"type": "Variable", "def": "uint32_t last_click_time", "sline": 44, "in_struct": "lv_colorwheel_t"}, "lv_colorwheel_t.last_change_time": {"type": "Variable", "def": "uint32_t last_change_time", "sline": 45, "in_struct": "lv_colorwheel_t"}, "lv_colorwheel_t.last_press_point": {"type": "Variable", "def": "lv_point_t last_press_point", "sline": 46, "in_struct": "lv_colorwheel_t"}, "lv_colorwheel_t.mode": {"type": "Variable", "def": "lv_colorwheel_mode_t mode  : 2", "sline": 47, "in_struct": "lv_colorwheel_t", "rels": [["lv_colorwheel_mode_t", null, "Typeof"]]}, "lv_colorwheel_t.mode_fixed": {"type": "Variable", "def": "uint8_t mode_fixed            : 1", "sline": 48, "in_struct": "lv_colorwheel_t"}, "lv_colorwheel_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    lv_color_hsv_t hsv;\n    struct {\n        lv_point_t pos;\n        uint8_t recolor     : 1;\n    } knob;\n    uint32_t last_click_time;\n    uint32_t last_change_time;\n    lv_point_t last_press_point;\n    lv_colorwheel_mode_t mode  : 2;\n    uint8_t mode_fixed            : 1;\n} lv_colorwheel_t", "sline": 49, "docstring": "/*Data of color picker*/"}, "lv_colorwheel_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_colorwheel_class", "sline": 51}, "lv_colorwheel_create": {"type": "Function", "def": "lv_obj_t * lv_colorwheel_create(lv_obj_t * parent, bool knob_recolor)", "sline": 63}, "lv_colorwheel_set_hsv": {"type": "Function", "def": "bool lv_colorwheel_set_hsv(lv_obj_t * obj, lv_color_hsv_t hsv)", "sline": 75}, "lv_colorwheel_set_rgb": {"type": "Function", "def": "bool lv_colorwheel_set_rgb(lv_obj_t * obj, lv_color_t color)", "sline": 83}, "lv_colorwheel_set_mode": {"type": "Function", "def": "void lv_colorwheel_set_mode(lv_obj_t * obj, lv_colorwheel_mode_t mode)", "sline": 90}, "lv_colorwheel_set_mode_fixed": {"type": "Function", "def": "void lv_colorwheel_set_mode_fixed(lv_obj_t * obj, bool fixed)", "sline": 97}, "lv_colorwheel_get_hsv": {"type": "Function", "def": "lv_color_hsv_t lv_colorwheel_get_hsv(lv_obj_t * obj)", "sline": 108}, "lv_colorwheel_get_rgb": {"type": "Function", "def": "lv_color_t lv_colorwheel_get_rgb(lv_obj_t * obj)", "sline": 115}, "lv_colorwheel_get_color_mode": {"type": "Function", "def": "lv_colorwheel_mode_t lv_colorwheel_get_color_mode(lv_obj_t * obj)", "sline": 122, "rels": [["lv_colorwheel_mode_t", null, "Typeof"]]}, "lv_colorwheel_get_color_mode_fixed": {"type": "Function", "def": "bool lv_colorwheel_get_color_mode_fixed(lv_obj_t * obj)", "sline": 129}, "carbit_updater/lvgl/src/extra/widgets/colorwheel/lv_colorwheel.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/colorwheel/lv_colorwheel.h"}}, "carbit_updater/lvgl/src/core/lv_obj_draw.c": {"lv_obj_draw": {"type": "Variable", "def": "#include lv_obj_draw.h", "sline": 9, "include": ["carbit_updater/lvgl/src/core/lv_obj_draw.h", null]}, "lv_obj": {"type": "Variable", "def": "#include lv_obj.h", "sline": 10, "include": ["carbit_updater/lvgl/src/core/lv_obj.h", null]}, "lv_disp": {"type": "Variable", "def": "#include lv_disp.h", "sline": 11, "include": ["carbit_updater/lvgl/src/core/lv_disp.h", null]}, "lv_indev": {"type": "Variable", "def": "#include lv_indev.h", "sline": 12, "include": ["carbit_updater/lvgl/src/core/lv_indev.h", null]}, "lv_obj_init_draw_rect_dsc": {"type": "Function", "def": "void lv_obj_init_draw_rect_dsc(lv_obj_t * obj, uint32_t part, lv_draw_rect_dsc_t * draw_dsc)", "sline": 39, "body": "{\n\n#if LV_DRAW_COMPLEX\n    draw_dsc->radius = lv_obj_get_style_radius(obj, part);\n\n    lv_opa_t main_opa = part != LV_PART_MAIN ? lv_obj_get_style_opa(obj, part) : LV_OPA_COVER;\n    lv_opa_t opa = lv_obj_get_style_opa(obj, part);\n    if(opa <= LV_OPA_MIN || main_opa <= LV_OPA_MIN) {\n        draw_dsc->bg_opa = LV_OPA_TRANSP;\n        draw_dsc->border_opa = LV_OPA_TRANSP;\n        draw_dsc->shadow_opa = LV_OPA_TRANSP;\n        draw_dsc->outline_opa = LV_OPA_TRANSP;\n        return;\n    }\n\n    draw_dsc->blend_mode = lv_obj_get_style_blend_mode(obj, part);\n\n    if(draw_dsc->bg_opa != LV_OPA_TRANSP) {\n        draw_dsc->bg_opa = lv_obj_get_style_bg_opa(obj, part);\n        if(draw_dsc->bg_opa > LV_OPA_MIN) {\n            draw_dsc->bg_color = lv_obj_get_style_bg_color_filtered(obj, part);\n            draw_dsc->bg_grad_dir =  lv_obj_get_style_bg_grad_dir(obj, part);\n            if(draw_dsc->bg_grad_dir != LV_GRAD_DIR_NONE) {\n                draw_dsc->bg_grad_color = lv_obj_get_style_bg_grad_color_filtered(obj, part);\n                draw_dsc->bg_main_color_stop =  lv_obj_get_style_bg_main_stop(obj, part);\n                draw_dsc->bg_grad_color_stop =  lv_obj_get_style_bg_grad_stop(obj, part);\n            }\n        }\n    }\n\n    draw_dsc->border_width = lv_obj_get_style_border_width(obj, part);\n    if(draw_dsc->border_width) {\n        if(draw_dsc->border_opa != LV_OPA_TRANSP) {\n            draw_dsc->border_opa = lv_obj_get_style_border_opa(obj, part);\n            if(draw_dsc->border_opa > LV_OPA_MIN) {\n                draw_dsc->border_side = lv_obj_get_style_border_side(obj, part);\n                draw_dsc->border_color = lv_obj_get_style_border_color_filtered(obj, part);\n            }\n        }\n    }\n\n    draw_dsc->outline_width = lv_obj_get_style_outline_width(obj, part);\n    if(draw_dsc->outline_width) {\n        if(draw_dsc->outline_opa != LV_OPA_TRANSP) {\n            draw_dsc->outline_opa = lv_obj_get_style_outline_opa(obj, part);\n            if(draw_dsc->outline_opa > LV_OPA_MIN) {\n                draw_dsc->outline_pad = lv_obj_get_style_outline_pad(obj, part);\n                draw_dsc->outline_color = lv_obj_get_style_outline_color_filtered(obj, part);\n            }\n        }\n    }\n\n    if(draw_dsc->bg_img_opa != LV_OPA_TRANSP) {\n        draw_dsc->bg_img_src = lv_obj_get_style_bg_img_src(obj, part);\n        if(draw_dsc->bg_img_src) {\n            draw_dsc->bg_img_opa = lv_obj_get_style_bg_img_opa(obj, part);\n            if(draw_dsc->bg_img_opa > LV_OPA_MIN) {\n                if(lv_img_src_get_type(draw_dsc->bg_img_src) == LV_IMG_SRC_SYMBOL) {\n                    draw_dsc->bg_img_symbol_font = lv_obj_get_style_text_font(obj, part);\n                    draw_dsc->bg_img_recolor = lv_obj_get_style_text_color_filtered(obj, part);\n                }\n                else {\n                    draw_dsc->bg_img_recolor = lv_obj_get_style_bg_img_recolor_filtered(obj, part);\n                    draw_dsc->bg_img_recolor_opa = lv_obj_get_style_bg_img_recolor_opa(obj, part);\n                    draw_dsc->bg_img_tiled = lv_obj_get_style_bg_img_tiled(obj, part);\n                }\n            }\n        }\n    }\n\n    if(draw_dsc->shadow_opa) {\n        draw_dsc->shadow_width = lv_obj_get_style_shadow_width(obj, part);\n        if(draw_dsc->shadow_width) {\n            if(draw_dsc->shadow_opa > LV_OPA_MIN) {\n                draw_dsc->shadow_opa = lv_obj_get_style_shadow_opa(obj, part);\n                if(draw_dsc->shadow_opa > LV_OPA_MIN) {\n                    draw_dsc->shadow_ofs_x = lv_obj_get_style_shadow_ofs_x(obj, part);\n                    draw_dsc->shadow_ofs_y = lv_obj_get_style_shadow_ofs_y(obj, part);\n                    draw_dsc->shadow_spread = lv_obj_get_style_shadow_spread(obj, part);\n                    draw_dsc->shadow_color = lv_obj_get_style_shadow_color_filtered(obj, part);\n                }\n            }\n        }\n    }\n\n    if(main_opa < LV_OPA_MAX) {\n        opa = (uint16_t)((uint16_t) main_opa * opa) >> 8;\n    }\n\n    if(opa < LV_OPA_MAX) {\n        draw_dsc->bg_opa = (uint16_t)((uint16_t)draw_dsc->bg_opa * opa) >> 8;\n        draw_dsc->border_opa = (uint16_t)((uint16_t)draw_dsc->border_opa * opa) >> 8;\n        draw_dsc->shadow_opa = (uint16_t)((uint16_t)draw_dsc->shadow_opa * opa) >> 8;\n        draw_dsc->outline_opa = (uint16_t)((uint16_t)draw_dsc->outline_opa * opa) >> 8;\n    }\n#else /*LV_DRAW_COMPLEX*/\n    if(draw_dsc->bg_opa != LV_OPA_TRANSP) {\n        draw_dsc->bg_opa = lv_obj_get_style_bg_opa(obj, part);\n        if(draw_dsc->bg_opa > LV_OPA_MIN) {\n            draw_dsc->bg_color = lv_obj_get_style_bg_color_filtered(obj, part);\n        }\n    }\n\n    draw_dsc->border_width = lv_obj_get_style_border_width(obj, part);\n    if(draw_dsc->border_width) {\n        if(draw_dsc->border_opa != LV_OPA_TRANSP) {\n            draw_dsc->border_opa = lv_obj_get_style_border_opa(obj, part);\n            if(draw_dsc->border_opa > LV_OPA_MIN) {\n                draw_dsc->border_color = lv_obj_get_style_border_color_filtered(obj, part);\n                draw_dsc->border_side = lv_obj_get_style_border_side(obj, part);\n            }\n        }\n    }\n\n    draw_dsc->outline_width = lv_obj_get_style_outline_width(obj, part);\n    if(draw_dsc->outline_width) {\n        if(draw_dsc->outline_opa != LV_OPA_TRANSP) {\n            draw_dsc->outline_opa = lv_obj_get_style_outline_opa(obj, part);\n            if(draw_dsc->outline_opa > LV_OPA_MIN) {\n                draw_dsc->outline_pad = lv_obj_get_style_outline_pad(obj, part);\n                draw_dsc->outline_color = lv_obj_get_style_outline_color_filtered(obj, part);\n            }\n        }\n    }\n\n    if(draw_dsc->bg_img_opa != LV_OPA_TRANSP) {\n        draw_dsc->bg_img_src = lv_obj_get_style_bg_img_src(obj, part);\n        if(draw_dsc->bg_img_src) {\n            draw_dsc->bg_img_opa = lv_obj_get_style_bg_img_opa(obj, part);\n            if(draw_dsc->bg_img_opa > LV_OPA_MIN) {\n                if(lv_img_src_get_type(draw_dsc->bg_img_src) == LV_IMG_SRC_SYMBOL) {\n                    draw_dsc->bg_img_symbol_font = lv_obj_get_style_text_font(obj, part);\n                    draw_dsc->bg_img_recolor = lv_obj_get_style_text_color_filtered(obj, part);\n                }\n                else {\n                    draw_dsc->bg_img_recolor = lv_obj_get_style_bg_img_recolor_filtered(obj, part);\n                    draw_dsc->bg_img_recolor_opa = lv_obj_get_style_bg_img_recolor_opa(obj, part);\n                    draw_dsc->bg_img_tiled = lv_obj_get_style_bg_img_tiled(obj, part);\n                }\n            }\n        }\n    }\n#endif\n}"}, "lv_obj_init_draw_label_dsc": {"type": "Function", "def": "void lv_obj_init_draw_label_dsc(lv_obj_t * obj, uint32_t part, lv_draw_label_dsc_t * draw_dsc)", "sline": 185, "body": "{\n    draw_dsc->opa = lv_obj_get_style_text_opa(obj, part);\n    if(draw_dsc->opa <= LV_OPA_MIN) return;\n\n    lv_opa_t opa = lv_obj_get_style_opa(obj, part);\n    if(opa < LV_OPA_MAX) {\n        draw_dsc->opa = (uint16_t)((uint16_t)draw_dsc->opa * opa) >> 8;\n    }\n    if(draw_dsc->opa <= LV_OPA_MIN) return;\n\n    draw_dsc->color = lv_obj_get_style_text_color_filtered(obj, part);\n    draw_dsc->letter_space = lv_obj_get_style_text_letter_space(obj, part);\n    draw_dsc->line_space = lv_obj_get_style_text_line_space(obj, part);\n    draw_dsc->decor = lv_obj_get_style_text_decor(obj, part);\n#if LV_DRAW_COMPLEX\n    draw_dsc->blend_mode = lv_obj_get_style_blend_mode(obj, part);\n#endif\n\n    draw_dsc->font = lv_obj_get_style_text_font(obj, part);\n\n#if LV_USE_BIDI\n    draw_dsc->bidi_dir = lv_obj_get_style_base_dir(obj, LV_PART_MAIN);\n#endif\n\n    draw_dsc->align = lv_obj_get_style_text_align(obj, part);\n}"}, "lv_obj_init_draw_img_dsc": {"type": "Function", "def": "void lv_obj_init_draw_img_dsc(lv_obj_t * obj, uint32_t part, lv_draw_img_dsc_t * draw_dsc)", "sline": 213, "body": "{\n    draw_dsc->opa = lv_obj_get_style_img_opa(obj, part);\n    if(draw_dsc->opa <= LV_OPA_MIN)  return;\n\n    lv_opa_t opa_scale = lv_obj_get_style_opa(obj, part);\n    if(opa_scale < LV_OPA_MAX) {\n        draw_dsc->opa = (uint16_t)((uint16_t)draw_dsc->opa * opa_scale) >> 8;\n    }\n    if(draw_dsc->opa <= LV_OPA_MIN)  return;\n\n    draw_dsc->angle = 0;\n    draw_dsc->zoom = LV_IMG_ZOOM_NONE;\n    draw_dsc->pivot.x = lv_area_get_width(&obj->coords) / 2;\n    draw_dsc->pivot.y = lv_area_get_height(&obj->coords) / 2;\n\n    draw_dsc->recolor_opa = lv_obj_get_style_img_recolor_opa(obj, part);\n    if(draw_dsc->recolor_opa > 0) {\n        draw_dsc->recolor = lv_obj_get_style_img_recolor_filtered(obj, part);\n    }\n#if LV_DRAW_COMPLEX\n    draw_dsc->blend_mode = lv_obj_get_style_blend_mode(obj, part);\n#endif\n}"}, "lv_obj_init_draw_line_dsc": {"type": "Function", "def": "void lv_obj_init_draw_line_dsc(lv_obj_t * obj, uint32_t part, lv_draw_line_dsc_t * draw_dsc)", "sline": 238, "body": "{\n    draw_dsc->width = lv_obj_get_style_line_width(obj, part);\n    if(draw_dsc->width == 0) return;\n\n    draw_dsc->opa = lv_obj_get_style_line_opa(obj, part);\n    if(draw_dsc->opa <= LV_OPA_MIN)  return;\n\n    lv_opa_t opa = lv_obj_get_style_opa(obj, part);\n    if(opa < LV_OPA_MAX) {\n        draw_dsc->opa = (uint16_t)((uint16_t)draw_dsc->opa * opa) >> 8;\n    }\n    if(draw_dsc->opa <= LV_OPA_MIN)  return;\n\n    draw_dsc->color = lv_obj_get_style_line_color_filtered(obj, part);\n\n    draw_dsc->dash_width = lv_obj_get_style_line_dash_width(obj, part);\n    if(draw_dsc->dash_width) {\n        draw_dsc->dash_gap = lv_obj_get_style_line_dash_gap(obj, part);\n    }\n\n    draw_dsc->round_start = lv_obj_get_style_line_rounded(obj, part);\n    draw_dsc->round_end = draw_dsc->round_start;\n\n#if LV_DRAW_COMPLEX\n    draw_dsc->blend_mode = lv_obj_get_style_blend_mode(obj, part);\n#endif\n}"}, "lv_obj_init_draw_arc_dsc": {"type": "Function", "def": "void lv_obj_init_draw_arc_dsc(lv_obj_t * obj, uint32_t part, lv_draw_arc_dsc_t * draw_dsc)", "sline": 267, "body": "{\n    draw_dsc->width = lv_obj_get_style_arc_width(obj, part);\n    if(draw_dsc->width == 0) return;\n\n    draw_dsc->opa = lv_obj_get_style_arc_opa(obj, part);\n    if(draw_dsc->opa <= LV_OPA_MIN)  return;\n\n    lv_opa_t opa = lv_obj_get_style_opa(obj, part);\n    if(opa < LV_OPA_MAX) {\n        draw_dsc->opa = (uint16_t)((uint16_t)draw_dsc->opa * opa) >> 8;\n    }\n    if(draw_dsc->opa <= LV_OPA_MIN)  return;\n\n    draw_dsc->color = lv_obj_get_style_arc_color_filtered(obj, part);\n    draw_dsc->img_src = lv_obj_get_style_arc_img_src(obj, part);\n\n    draw_dsc->rounded = lv_obj_get_style_arc_rounded(obj, part);\n\n#if LV_DRAW_COMPLEX\n    draw_dsc->blend_mode = lv_obj_get_style_blend_mode(obj, part);\n#endif\n}"}, "lv_obj_calculate_ext_draw_size": {"type": "Function", "def": "lv_coord_t lv_obj_calculate_ext_draw_size(lv_obj_t * obj, uint32_t part)", "sline": 291, "body": "{\n    lv_coord_t s = 0;\n\n    lv_coord_t sh_width = lv_obj_get_style_shadow_width(obj, part);\n    if(sh_width) {\n        lv_opa_t sh_opa = lv_obj_get_style_shadow_opa(obj, part);\n        if(sh_opa > LV_OPA_MIN) {\n            sh_width = sh_width / 2 + 1;    /*The blur adds only half width*/\n            sh_width += lv_obj_get_style_shadow_spread(obj, part);\n            lv_coord_t sh_ofs_x = lv_obj_get_style_shadow_ofs_x(obj, part);\n            lv_coord_t sh_ofs_y = lv_obj_get_style_shadow_ofs_y(obj, part);\n            sh_width += LV_MAX(LV_ABS(sh_ofs_x), LV_ABS(sh_ofs_y));\n            s = LV_MAX(s, sh_width);\n        }\n    }\n\n    lv_coord_t outline_width = lv_obj_get_style_outline_width(obj, part);\n    if(outline_width) {\n        lv_opa_t outline_opa = lv_obj_get_style_outline_opa(obj, part);\n        if(outline_opa > LV_OPA_MIN) {\n            lv_coord_t outline_pad = lv_obj_get_style_outline_pad(obj, part);\n            s = LV_MAX(s, outline_pad + outline_width);\n        }\n    }\n\n    lv_coord_t w = lv_obj_get_style_transform_width(obj, part);\n    lv_coord_t h = lv_obj_get_style_transform_height(obj, part);\n    lv_coord_t wh = LV_MAX(w, h);\n    if(wh > 0) s += wh;\n\n    return s;\n}"}, "lv_obj_draw_dsc_init": {"type": "Function", "def": "void lv_obj_draw_dsc_init(lv_obj_draw_part_dsc_t * dsc, const lv_area_t * clip_area)", "sline": 325, "body": "{\n    lv_memset_00(dsc, sizeof(lv_obj_draw_part_dsc_t));\n    dsc->clip_area = clip_area;\n}"}, "lv_obj_draw_part_check_type": {"type": "Function", "def": "bool lv_obj_draw_part_check_type(lv_obj_draw_part_dsc_t * dsc, const lv_obj_class_t * class_p, uint32_t type)", "sline": 331, "body": "{\n    if(dsc->class_p == class_p && dsc->type == type) return true;\n    else return false;\n}"}, "lv_obj_refresh_ext_draw_size": {"type": "Function", "def": "void lv_obj_refresh_ext_draw_size(lv_obj_t * obj)", "sline": 337, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_coord_t s_old = _lv_obj_get_ext_draw_size(obj);\n    lv_coord_t s_new = 0;\n    lv_event_send(obj, LV_EVENT_REFR_EXT_DRAW_SIZE, &s_new);\n\n    if(s_new != s_old) lv_obj_invalidate(obj);\n\n    /*Store the result if the special attrs already allocated*/\n    if(obj->spec_attr) {\n        obj->spec_attr->ext_draw_size = s_new;\n    }\n    /*Allocate spec. attrs. only if the result is not zero.\n     *Zero is the default value if the spec. attr. are not defined.*/\n    else if(s_new != 0) {\n        lv_obj_allocate_spec_attr(obj);\n        obj->spec_attr->ext_draw_size = s_new;\n    }\n\n    if(s_new != s_old) lv_obj_invalidate(obj);\n}"}, "_lv_obj_get_ext_draw_size": {"type": "Function", "def": "lv_coord_t _lv_obj_get_ext_draw_size(const lv_obj_t * obj)", "sline": 361, "body": "{\n    if(obj->spec_attr) return obj->spec_attr->ext_draw_size;\n    else return 0;\n}"}, "carbit_updater/lvgl/src/core/lv_obj_draw.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_draw.c"}}, "carbit_updater/lvgl/src/gpu/lv_gpu_sdl.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 17}, "carbit_updater/lvgl/src/gpu/lv_gpu_sdl.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_sdl.h"}}, "carbit_updater/lvgl/tests/unity/unity.h": {"carbit_updater/lvgl/tests/unity/unity.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/tests/unity/unity.h"}}, "carbit_updater/lvgl/src/extra/widgets/tabview/lv_tabview.h": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 16}, "lv_tabview_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 29, "in_struct": "lv_tabview_t"}, "lv_tabview_t.map": {"type": "Variable", "def": "char ** map", "sline": 30, "in_struct": "lv_tabview_t"}, "lv_tabview_t.tab_cnt": {"type": "Variable", "def": "uint16_t tab_cnt", "sline": 31, "in_struct": "lv_tabview_t"}, "lv_tabview_t.tab_cur": {"type": "Variable", "def": "uint16_t tab_cur", "sline": 32, "in_struct": "lv_tabview_t"}, "lv_tabview_t.tab_pos": {"type": "Variable", "def": "lv_dir_t tab_pos", "sline": 33, "in_struct": "lv_tabview_t"}, "lv_tabview_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    char ** map;\n    uint16_t tab_cnt;\n    uint16_t tab_cur;\n    lv_dir_t tab_pos;\n} lv_tabview_t", "sline": 34}, "lv_tabview_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_tabview_class", "sline": 36}, "lv_tabview_create": {"type": "Function", "def": "lv_obj_t * lv_tabview_create(lv_obj_t * parent, lv_dir_t tab_pos, lv_coord_t tab_size)", "sline": 41}, "lv_tabview_add_tab": {"type": "Function", "def": "lv_obj_t * lv_tabview_add_tab(lv_obj_t * tv, const char * name)", "sline": 43}, "lv_tabview_get_content": {"type": "Function", "def": "lv_obj_t * lv_tabview_get_content(lv_obj_t * tv)", "sline": 45}, "lv_tabview_get_tab_btns": {"type": "Function", "def": "lv_obj_t * lv_tabview_get_tab_btns(lv_obj_t * tv)", "sline": 47}, "lv_tabview_set_act": {"type": "Function", "def": "void lv_tabview_set_act(lv_obj_t * obj, uint32_t id, lv_anim_enable_t anim_en)", "sline": 49}, "lv_tabview_get_tab_act": {"type": "Function", "def": "uint16_t lv_tabview_get_tab_act(lv_obj_t * tv)", "sline": 51}, "carbit_updater/lvgl/src/extra/widgets/tabview/lv_tabview.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/tabview/lv_tabview.h"}}, "carbit_updater/lvgl/lvgl.h": {"lv_log": {"type": "Variable", "def": "#include src/misc/lv_log.h", "sline": 25, "include": ["carbit_updater/lvgl/src/misc/lv_log.h", null]}, "lv_timer": {"type": "Variable", "def": "#include src/misc/lv_timer.h", "sline": 26, "include": ["carbit_updater/lvgl/src/misc/lv_timer.h", null]}, "lv_math": {"type": "Variable", "def": "#include src/misc/lv_math.h", "sline": 27, "include": ["carbit_updater/lvgl/src/misc/lv_math.h", null]}, "lv_mem": {"type": "Variable", "def": "#include src/misc/lv_mem.h", "sline": 28, "include": ["carbit_updater/lvgl/src/misc/lv_mem.h", null]}, "lv_async": {"type": "Variable", "def": "#include src/misc/lv_async.h", "sline": 29, "include": ["carbit_updater/lvgl/src/misc/lv_async.h", null]}, "lv_anim_timeline": {"type": "Variable", "def": "#include src/misc/lv_anim_timeline.h", "sline": 30, "include": ["carbit_updater/lvgl/src/misc/lv_anim_timeline.h", null]}, "lv_printf": {"type": "Variable", "def": "#include src/misc/lv_printf.h", "sline": 31, "include": ["carbit_updater/lvgl/src/misc/lv_printf.h", null]}, "lv_hal": {"type": "Variable", "def": "#include src/hal/lv_hal.h", "sline": 33, "include": ["carbit_updater/lvgl/src/hal/lv_hal.h", null]}, "lv_obj": {"type": "Variable", "def": "#include src/core/lv_obj.h", "sline": 35, "include": ["carbit_updater/lvgl/src/core/lv_obj.h", null]}, "lv_group": {"type": "Variable", "def": "#include src/core/lv_group.h", "sline": 36, "include": ["carbit_updater/lvgl/src/core/lv_group.h", null]}, "lv_indev": {"type": "Variable", "def": "#include src/core/lv_indev.h", "sline": 37, "include": ["carbit_updater/lvgl/src/core/lv_indev.h", null]}, "lv_refr": {"type": "Variable", "def": "#include src/core/lv_refr.h", "sline": 38, "include": ["carbit_updater/lvgl/src/core/lv_refr.h", null]}, "lv_disp": {"type": "Variable", "def": "#include src/core/lv_disp.h", "sline": 39, "include": ["carbit_updater/lvgl/src/core/lv_disp.h", null]}, "lv_theme": {"type": "Variable", "def": "#include src/core/lv_theme.h", "sline": 40, "include": ["carbit_updater/lvgl/src/core/lv_theme.h", null]}, "lv_font": {"type": "Variable", "def": "#include src/font/lv_font.h", "sline": 42, "include": ["carbit_updater/lvgl/src/font/lv_font.h", null]}, "lv_font_loader": {"type": "Variable", "def": "#include src/font/lv_font_loader.h", "sline": 43, "include": ["carbit_updater/lvgl/src/font/lv_font_loader.h", null]}, "lv_font_fmt_txt": {"type": "Variable", "def": "#include src/font/lv_font_fmt_txt.h", "sline": 44, "include": ["carbit_updater/lvgl/src/font/lv_font_fmt_txt.h", null]}, "lv_arc": {"type": "Variable", "def": "#include src/widgets/lv_arc.h", "sline": 46, "include": ["carbit_updater/lvgl/src/widgets/lv_arc.h", null]}, "lv_btn": {"type": "Variable", "def": "#include src/widgets/lv_btn.h", "sline": 47, "include": ["carbit_updater/lvgl/src/widgets/lv_btn.h", null]}, "lv_img": {"type": "Variable", "def": "#include src/widgets/lv_img.h", "sline": 48, "include": ["carbit_updater/lvgl/src/widgets/lv_img.h", null]}, "lv_label": {"type": "Variable", "def": "#include src/widgets/lv_label.h", "sline": 49, "include": ["carbit_updater/lvgl/src/widgets/lv_label.h", null]}, "lv_line": {"type": "Variable", "def": "#include src/widgets/lv_line.h", "sline": 50, "include": ["carbit_updater/lvgl/src/widgets/lv_line.h", null]}, "lv_table": {"type": "Variable", "def": "#include src/widgets/lv_table.h", "sline": 51, "include": ["carbit_updater/lvgl/src/widgets/lv_table.h", null]}, "lv_checkbox": {"type": "Variable", "def": "#include src/widgets/lv_checkbox.h", "sline": 52, "include": ["carbit_updater/lvgl/src/widgets/lv_checkbox.h", null]}, "lv_bar": {"type": "Variable", "def": "#include src/widgets/lv_bar.h", "sline": 53, "include": ["carbit_updater/lvgl/src/widgets/lv_bar.h", null]}, "lv_slider": {"type": "Variable", "def": "#include src/widgets/lv_slider.h", "sline": 54, "include": ["carbit_updater/lvgl/src/widgets/lv_slider.h", null]}, "lv_btnmatrix": {"type": "Variable", "def": "#include src/widgets/lv_btnmatrix.h", "sline": 55, "include": ["carbit_updater/lvgl/src/widgets/lv_btnmatrix.h", null]}, "lv_dropdown": {"type": "Variable", "def": "#include src/widgets/lv_dropdown.h", "sline": 56, "include": ["carbit_updater/lvgl/src/widgets/lv_dropdown.h", null]}, "lv_roller": {"type": "Variable", "def": "#include src/widgets/lv_roller.h", "sline": 57, "include": ["carbit_updater/lvgl/src/widgets/lv_roller.h", null]}, "lv_textarea": {"type": "Variable", "def": "#include src/widgets/lv_textarea.h", "sline": 58, "include": ["carbit_updater/lvgl/src/widgets/lv_textarea.h", null]}, "lv_canvas": {"type": "Variable", "def": "#include src/widgets/lv_canvas.h", "sline": 59, "include": ["carbit_updater/lvgl/src/widgets/lv_canvas.h", null]}, "lv_switch": {"type": "Variable", "def": "#include src/widgets/lv_switch.h", "sline": 60, "include": ["carbit_updater/lvgl/src/widgets/lv_switch.h", null]}, "lv_draw": {"type": "Variable", "def": "#include src/draw/lv_draw.h", "sline": 62, "include": ["carbit_updater/lvgl/src/draw/lv_draw.h", null]}, "lv_api_map": {"type": "Variable", "def": "#include src/lv_api_map.h", "sline": 64, "include": ["carbit_updater/lvgl/src/lv_api_map.h", null]}, "lv_extra": {"type": "Variable", "def": "#include src/extra/lv_extra.h", "sline": 69, "include": ["carbit_updater/lvgl/src/extra/lv_extra.h", null]}, "lv_widgets": {"type": "Variable", "def": "#include src/extra/widgets/lv_widgets.h", "sline": 70, "include": ["carbit_updater/lvgl/src/extra/widgets/lv_widgets.h", null]}, "lv_layouts": {"type": "Variable", "def": "#include src/extra/layouts/lv_layouts.h", "sline": 71, "include": ["carbit_updater/lvgl/src/extra/layouts/lv_layouts.h", null]}, "lv_themes": {"type": "Variable", "def": "#include src/extra/themes/lv_themes.h", "sline": 72, "include": ["carbit_updater/lvgl/src/extra/themes/lv_themes.h", null]}, "lv_others": {"type": "Variable", "def": "#include src/extra/others/lv_others.h", "sline": 73, "include": ["carbit_updater/lvgl/src/extra/others/lv_others.h", null]}, "lv_libs": {"type": "Variable", "def": "#include src/extra/libs/lv_libs.h", "sline": 74, "include": ["carbit_updater/lvgl/src/extra/libs/lv_libs.h", null]}, "lv_version_major": {"type": "Function", "def": "static inline int lv_version_major(void)", "sline": 119, "body": "{\n    return LVGL_VERSION_MAJOR;\n}"}, "lv_version_minor": {"type": "Function", "def": "static inline int lv_version_minor(void)", "sline": 124, "body": "{\n    return LVGL_VERSION_MINOR;\n}"}, "lv_version_patch": {"type": "Function", "def": "static inline int lv_version_patch(void)", "sline": 129, "body": "{\n    return LVGL_VERSION_PATCH;\n}"}, "lv_version_info": {"type": "Function", "def": "static inline const char *lv_version_info(void)", "sline": 134, "body": "{\n    return LVGL_VERSION_INFO;\n}"}, "carbit_updater/lvgl/lvgl.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/lvgl.h"}}, "carbit_updater/lvgl/src/extra/widgets/animimg/lv_animimg.h": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 16}, "lv_animimg_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_animimg_class", "sline": 33}, "lv_animimg_t.img": {"type": "Variable", "def": "lv_img_t img", "sline": 37, "in_struct": "lv_animimg_t"}, "lv_animimg_t.anim": {"type": "Variable", "def": "lv_anim_t anim", "sline": 38, "in_struct": "lv_animimg_t"}, "lv_animimg_t.dsc": {"type": "Variable", "def": "lv_img_dsc_t ** dsc", "sline": 40, "in_struct": "lv_animimg_t"}, "lv_animimg_t.pic_count": {"type": "Variable", "def": "int8_t  pic_count", "sline": 41, "in_struct": "lv_animimg_t"}, "lv_animimg_t": {"type": "Variable", "def": "typedef struct {\n    lv_img_t img;\n    lv_anim_t anim;\n    /*picture sequence */\n    lv_img_dsc_t ** dsc;\n    int8_t  pic_count;\n} lv_animimg_t", "sline": 42, "docstring": "/*Data of image*/"}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/animimg/lv_animimg.h:46:1)": {"type": "Enum", "def": "enum {\n    LV_ANIM_IMG_PART_MAIN,\n}", "sline": 46, "docstring": "/*Image parts*/"}, "lv_animimg_part_t": {"type": "Variable", "def": "typedef uint8_t lv_animimg_part_t", "sline": 49}, "lv_animimg_create": {"type": "Function", "def": "lv_obj_t * lv_animimg_create(lv_obj_t * parent)", "sline": 61}, "lv_animimg_set_src": {"type": "Function", "def": "void lv_animimg_set_src(lv_obj_t * img,  lv_img_dsc_t * dsc[], uint8_t num)", "sline": 73}, "lv_animimg_start": {"type": "Function", "def": "void lv_animimg_start(lv_obj_t * obj)", "sline": 79}, "lv_animimg_set_duration": {"type": "Function", "def": "void lv_animimg_set_duration(lv_obj_t * img, uint32_t duration)", "sline": 85}, "lv_animimg_set_repeat_count": {"type": "Function", "def": "void lv_animimg_set_repeat_count(lv_obj_t * img, uint16_t count)", "sline": 91}, "carbit_updater/lvgl/src/extra/widgets/animimg/lv_animimg.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/animimg/lv_animimg.h"}}, "carbit_updater/lvgl/src/extra/libs/gif/lv_gif.c": {"lv_gif": {"type": "Variable", "def": "#include lv_gif.h", "sline": 9, "include": ["carbit_updater/lvgl/src/extra/libs/gif/lv_gif.h", null]}, "carbit_updater/lvgl/src/extra/libs/gif/lv_gif.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/gif/lv_gif.c"}}, "carbit_updater/lvgl/src/misc/lv_bidi.c": {"stddef": {"type": "Variable", "def": "#include stddef.h", "sline": 9}, "lv_bidi": {"type": "Variable", "def": "#include lv_bidi.h", "sline": 10, "include": ["carbit_updater/lvgl/src/misc/lv_bidi.h", null]}, "lv_txt": {"type": "Variable", "def": "#include lv_txt.h", "sline": 11, "include": ["carbit_updater/lvgl/src/misc/lv_txt.h", null]}, "lv_mem": {"type": "Variable", "def": "#include ../misc/lv_mem.h", "sline": 12}, "carbit_updater/lvgl/src/misc/lv_bidi.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_bidi.c"}}, "carbit_updater/lvgl/src/misc/lv_txt_ap.h": {"stddef": {"type": "Variable", "def": "#include stddef.h", "sline": 16}, "lv_txt": {"type": "Variable", "def": "#include lv_txt.h", "sline": 17, "include": ["carbit_updater/lvgl/src/misc/lv_txt.h", null]}, "lv_draw": {"type": "Variable", "def": "#include ../draw/lv_draw.h", "sline": 18}, "carbit_updater/lvgl/src/misc/lv_txt_ap.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_txt_ap.h"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_10.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_montserrat_10.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_10.c"}}, "carbit_updater/lvgl/src/misc/lv_txt.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 18}, "stdarg": {"type": "Variable", "def": "#include stdarg.h", "sline": 19}, "lv_area": {"type": "Variable", "def": "#include lv_area.h", "sline": 20, "include": ["carbit_updater/lvgl/src/misc/lv_area.h", null]}, "lv_font": {"type": "Variable", "def": "#include ../font/lv_font.h", "sline": 21}, "lv_printf": {"type": "Variable", "def": "#include lv_printf.h", "sline": 22, "include": ["carbit_updater/lvgl/src/misc/lv_printf.h", null]}, "lv_types": {"type": "Variable", "def": "#include lv_types.h", "sline": 23, "include": ["carbit_updater/lvgl/src/misc/lv_types.h", null]}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_txt.h:42:1)": {"type": "Enum", "def": "enum {\n    LV_TEXT_FLAG_NONE    = 0x00,\n    LV_TEXT_FLAG_RECOLOR = 0x01, /**< Enable parsing of recolor command*/\n    LV_TEXT_FLAG_EXPAND  = 0x02, /**< Ignore max-width to avoid automatic word wrapping*/\n    LV_TEXT_FLAG_FIT     = 0x04, /**< Max-width is already equal to the longest line. (Used to skip some calculation)*/\n}", "sline": 42, "docstring": "/**"}, "lv_text_flag_t": {"type": "Variable", "def": "typedef uint8_t lv_text_flag_t", "sline": 48}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_txt.h:52:1)": {"type": "Enum", "def": "enum {\n    LV_TEXT_CMD_STATE_WAIT, /**< Waiting for command*/\n    LV_TEXT_CMD_STATE_PAR,  /**< Processing the parameter*/\n    LV_TEXT_CMD_STATE_IN,   /**< Processing the command*/\n}", "sline": 52, "docstring": "/**"}, "lv_text_cmd_state_t": {"type": "Variable", "def": "typedef uint8_t lv_text_cmd_state_t", "sline": 57}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_txt.h:60:1)": {"type": "Enum", "def": "enum {\n    LV_TEXT_ALIGN_AUTO, /**< Align text auto*/\n    LV_TEXT_ALIGN_LEFT, /**< Align text to left*/\n    LV_TEXT_ALIGN_CENTER, /**< Align text to center*/\n    LV_TEXT_ALIGN_RIGHT, /**< Align text to right*/\n}", "sline": 60, "docstring": "/** Label align policy*/"}, "lv_text_align_t": {"type": "Variable", "def": "typedef uint8_t lv_text_align_t", "sline": 66}, "lv_txt_get_size": {"type": "Function", "def": "void lv_txt_get_size(lv_point_t * size_res, const char * text, const lv_font_t * font, lv_coord_t letter_space,\n                     lv_coord_t line_space, lv_coord_t max_width, lv_text_flag_t flag)", "sline": 83}, "_lv_txt_get_next_line": {"type": "Function", "def": "uint32_t _lv_txt_get_next_line(const char * txt, const lv_font_t * font, lv_coord_t letter_space, lv_coord_t max_width,\n                               lv_text_flag_t flag)", "sline": 97}, "lv_txt_get_width": {"type": "Function", "def": "lv_coord_t lv_txt_get_width(const char * txt, uint32_t length, const lv_font_t * font, lv_coord_t letter_space,\n                            lv_text_flag_t flag)", "sline": 110}, "_lv_txt_is_cmd": {"type": "Function", "def": "bool _lv_txt_is_cmd(lv_text_cmd_state_t * state, uint32_t c)", "sline": 121}, "_lv_txt_ins": {"type": "Function", "def": "void _lv_txt_ins(char * txt_buf, uint32_t pos, const char * ins_txt)", "sline": 129}, "_lv_txt_cut": {"type": "Function", "def": "void _lv_txt_cut(char * txt, uint32_t pos, uint32_t len)", "sline": 138}, "_lv_txt_set_text_vfmt": {"type": "Function", "def": "char * _lv_txt_set_text_vfmt(const char * fmt, va_list ap) LV_FORMAT_ATTRIBUTE(1, 0)", "sline": 145}, "_lv_txt_encoded_letter_next_2": {"type": "Function", "def": "void _lv_txt_encoded_letter_next_2(const char * txt, uint32_t * letter, uint32_t * letter_next, uint32_t * ofs)", "sline": 156}, "_lv_txt_is_break_char": {"type": "Function", "def": "static inline bool _lv_txt_is_break_char(uint32_t letter)", "sline": 163, "body": "{\n    uint8_t i;\n    bool ret = false;\n\n    /* each chinese character can be break */\n    if(letter >= 0x4E00 && letter <= 0x9FA5) {\n        return true;\n    }\n\n    /*Compare the letter to TXT_BREAK_CHARS*/\n    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\\0'; i++) {\n        if(letter == (uint32_t)LV_TXT_BREAK_CHARS[i]) {\n            ret = true; /*If match then it is break char*/\n            break;\n        }\n    }\n\n    return ret;\n}"}, "_lv_txt_encoded_size": {"type": "Variable", "def": "extern uint8_t (*_lv_txt_encoded_size)(const char *)", "sline": 193}, "_lv_txt_unicode_to_encoded": {"type": "Variable", "def": "extern uint32_t (*_lv_txt_unicode_to_encoded)(uint32_t)", "sline": 200}, "_lv_txt_encoded_conv_wc": {"type": "Variable", "def": "extern uint32_t (*_lv_txt_encoded_conv_wc)(uint32_t c)", "sline": 207}, "_lv_txt_encoded_next": {"type": "Variable", "def": "extern uint32_t (*_lv_txt_encoded_next)(const char *, uint32_t *)", "sline": 217}, "_lv_txt_encoded_prev": {"type": "Variable", "def": "extern uint32_t (*_lv_txt_encoded_prev)(const char *, uint32_t *)", "sline": 226}, "_lv_txt_encoded_get_byte_id": {"type": "Variable", "def": "extern uint32_t (*_lv_txt_encoded_get_byte_id)(const char *, uint32_t)", "sline": 235}, "_lv_txt_encoded_get_char_id": {"type": "Variable", "def": "extern uint32_t (*_lv_txt_encoded_get_char_id)(const char *, uint32_t)", "sline": 244}, "_lv_txt_get_encoded_length": {"type": "Variable", "def": "extern uint32_t (*_lv_txt_get_encoded_length)(const char *)", "sline": 252}, "carbit_updater/lvgl/src/misc/lv_txt.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_txt.h"}}, "carbit_updater/lv_drivers/sdl/sdl.c": {"sdl": {"type": "Variable", "def": "#include sdl.h", "sline": 9, "include": ["carbit_updater/lv_drivers/sdl/sdl.h", null]}, "carbit_updater/lv_drivers/sdl/sdl.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/sdl/sdl.c"}}, "carbit_updater/lvgl/src/extra/widgets/win/lv_win.h": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 16}, "lv_win_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 26, "in_struct": "lv_win_t"}, "lv_win_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n} lv_win_t", "sline": 27, "docstring": "/**********************"}, "lv_win_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_win_class", "sline": 29}, "lv_win_create": {"type": "Function", "def": "lv_obj_t * lv_win_create(lv_obj_t * parent, lv_coord_t header_height)", "sline": 35}, "lv_win_add_title": {"type": "Function", "def": "lv_obj_t * lv_win_add_title(lv_obj_t * win, const char * txt)", "sline": 38}, "lv_win_add_btn": {"type": "Function", "def": "lv_obj_t * lv_win_add_btn(lv_obj_t * win, const void * icon, lv_coord_t btn_w)", "sline": 39}, "lv_win_get_header": {"type": "Function", "def": "lv_obj_t * lv_win_get_header(lv_obj_t * win)", "sline": 41}, "lv_win_get_content": {"type": "Function", "def": "lv_obj_t * lv_win_get_content(lv_obj_t * win)", "sline": 42}, "carbit_updater/lvgl/src/extra/widgets/win/lv_win.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/win/lv_win.h"}}, "carbit_updater/lvgl/src/core/lv_obj_style_gen.c": {"lv_obj": {"type": "Variable", "def": "#include lv_obj.h", "sline": 1, "include": ["carbit_updater/lvgl/src/core/lv_obj.h", null]}, "lv_obj_set_style_width": {"type": "Function", "def": "void lv_obj_set_style_width(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 2, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_WIDTH, v, selector);\n}"}, "lv_obj_set_style_min_width": {"type": "Function", "def": "void lv_obj_set_style_min_width(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 10, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_MIN_WIDTH, v, selector);\n}"}, "lv_obj_set_style_max_width": {"type": "Function", "def": "void lv_obj_set_style_max_width(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 18, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_MAX_WIDTH, v, selector);\n}"}, "lv_obj_set_style_height": {"type": "Function", "def": "void lv_obj_set_style_height(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 26, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_HEIGHT, v, selector);\n}"}, "lv_obj_set_style_min_height": {"type": "Function", "def": "void lv_obj_set_style_min_height(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 34, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_MIN_HEIGHT, v, selector);\n}"}, "lv_obj_set_style_max_height": {"type": "Function", "def": "void lv_obj_set_style_max_height(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 42, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_MAX_HEIGHT, v, selector);\n}"}, "lv_obj_set_style_x": {"type": "Function", "def": "void lv_obj_set_style_x(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 50, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_X, v, selector);\n}"}, "lv_obj_set_style_y": {"type": "Function", "def": "void lv_obj_set_style_y(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 58, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_Y, v, selector);\n}"}, "lv_obj_set_style_align": {"type": "Function", "def": "void lv_obj_set_style_align(struct _lv_obj_t * obj, lv_align_t value, lv_style_selector_t selector)", "sline": 66, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_ALIGN, v, selector);\n}"}, "lv_obj_set_style_transform_width": {"type": "Function", "def": "void lv_obj_set_style_transform_width(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 74, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_TRANSFORM_WIDTH, v, selector);\n}"}, "lv_obj_set_style_transform_height": {"type": "Function", "def": "void lv_obj_set_style_transform_height(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 82, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_TRANSFORM_HEIGHT, v, selector);\n}"}, "lv_obj_set_style_translate_x": {"type": "Function", "def": "void lv_obj_set_style_translate_x(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 90, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_TRANSLATE_X, v, selector);\n}"}, "lv_obj_set_style_translate_y": {"type": "Function", "def": "void lv_obj_set_style_translate_y(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 98, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_TRANSLATE_Y, v, selector);\n}"}, "lv_obj_set_style_transform_zoom": {"type": "Function", "def": "void lv_obj_set_style_transform_zoom(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 106, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_TRANSFORM_ZOOM, v, selector);\n}"}, "lv_obj_set_style_transform_angle": {"type": "Function", "def": "void lv_obj_set_style_transform_angle(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 114, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_TRANSFORM_ANGLE, v, selector);\n}"}, "lv_obj_set_style_pad_top": {"type": "Function", "def": "void lv_obj_set_style_pad_top(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 122, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_PAD_TOP, v, selector);\n}"}, "lv_obj_set_style_pad_bottom": {"type": "Function", "def": "void lv_obj_set_style_pad_bottom(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 130, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_PAD_BOTTOM, v, selector);\n}"}, "lv_obj_set_style_pad_left": {"type": "Function", "def": "void lv_obj_set_style_pad_left(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 138, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_PAD_LEFT, v, selector);\n}"}, "lv_obj_set_style_pad_right": {"type": "Function", "def": "void lv_obj_set_style_pad_right(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 146, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_PAD_RIGHT, v, selector);\n}"}, "lv_obj_set_style_pad_row": {"type": "Function", "def": "void lv_obj_set_style_pad_row(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 154, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_PAD_ROW, v, selector);\n}"}, "lv_obj_set_style_pad_column": {"type": "Function", "def": "void lv_obj_set_style_pad_column(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 162, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_PAD_COLUMN, v, selector);\n}"}, "lv_obj_set_style_radius": {"type": "Function", "def": "void lv_obj_set_style_radius(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 170, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_RADIUS, v, selector);\n}"}, "lv_obj_set_style_clip_corner": {"type": "Function", "def": "void lv_obj_set_style_clip_corner(struct _lv_obj_t * obj, bool value, lv_style_selector_t selector)", "sline": 178, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_CLIP_CORNER, v, selector);\n}"}, "lv_obj_set_style_opa": {"type": "Function", "def": "void lv_obj_set_style_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 186, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_OPA, v, selector);\n}"}, "lv_obj_set_style_color_filter_dsc": {"type": "Function", "def": "void lv_obj_set_style_color_filter_dsc(struct _lv_obj_t * obj, const lv_color_filter_dsc_t * value, lv_style_selector_t selector)", "sline": 194, "body": "{\n    lv_style_value_t v = {\n        .ptr = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_COLOR_FILTER_DSC, v, selector);\n}"}, "lv_obj_set_style_color_filter_opa": {"type": "Function", "def": "void lv_obj_set_style_color_filter_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 202, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_COLOR_FILTER_OPA, v, selector);\n}"}, "lv_obj_set_style_anim_time": {"type": "Function", "def": "void lv_obj_set_style_anim_time(struct _lv_obj_t * obj, uint32_t value, lv_style_selector_t selector)", "sline": 210, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_ANIM_TIME, v, selector);\n}"}, "lv_obj_set_style_anim_speed": {"type": "Function", "def": "void lv_obj_set_style_anim_speed(struct _lv_obj_t * obj, uint32_t value, lv_style_selector_t selector)", "sline": 218, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_ANIM_SPEED, v, selector);\n}"}, "lv_obj_set_style_transition": {"type": "Function", "def": "void lv_obj_set_style_transition(struct _lv_obj_t * obj, const lv_style_transition_dsc_t * value, lv_style_selector_t selector)", "sline": 226, "body": "{\n    lv_style_value_t v = {\n        .ptr = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_TRANSITION, v, selector);\n}"}, "lv_obj_set_style_blend_mode": {"type": "Function", "def": "void lv_obj_set_style_blend_mode(struct _lv_obj_t * obj, lv_blend_mode_t value, lv_style_selector_t selector)", "sline": 234, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_BLEND_MODE, v, selector);\n}"}, "lv_obj_set_style_layout": {"type": "Function", "def": "void lv_obj_set_style_layout(struct _lv_obj_t * obj, uint16_t value, lv_style_selector_t selector)", "sline": 242, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_LAYOUT, v, selector);\n}"}, "lv_obj_set_style_base_dir": {"type": "Function", "def": "void lv_obj_set_style_base_dir(struct _lv_obj_t * obj, lv_base_dir_t value, lv_style_selector_t selector)", "sline": 250, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_BASE_DIR, v, selector);\n}"}, "lv_obj_set_style_bg_color": {"type": "Function", "def": "void lv_obj_set_style_bg_color(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 258, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_BG_COLOR, v, selector);\n}"}, "lv_obj_set_style_bg_color_filtered": {"type": "Function", "def": "void lv_obj_set_style_bg_color_filtered(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 266, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_BG_COLOR_FILTERED, v, selector);\n}"}, "lv_obj_set_style_bg_opa": {"type": "Function", "def": "void lv_obj_set_style_bg_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 274, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_BG_OPA, v, selector);\n}"}, "lv_obj_set_style_bg_grad_color": {"type": "Function", "def": "void lv_obj_set_style_bg_grad_color(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 282, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_BG_GRAD_COLOR, v, selector);\n}"}, "lv_obj_set_style_bg_grad_color_filtered": {"type": "Function", "def": "void lv_obj_set_style_bg_grad_color_filtered(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 290, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_BG_GRAD_COLOR_FILTERED, v, selector);\n}"}, "lv_obj_set_style_bg_grad_dir": {"type": "Function", "def": "void lv_obj_set_style_bg_grad_dir(struct _lv_obj_t * obj, lv_grad_dir_t value, lv_style_selector_t selector)", "sline": 298, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_BG_GRAD_DIR, v, selector);\n}"}, "lv_obj_set_style_bg_main_stop": {"type": "Function", "def": "void lv_obj_set_style_bg_main_stop(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 306, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_BG_MAIN_STOP, v, selector);\n}"}, "lv_obj_set_style_bg_grad_stop": {"type": "Function", "def": "void lv_obj_set_style_bg_grad_stop(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 314, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_BG_GRAD_STOP, v, selector);\n}"}, "lv_obj_set_style_bg_img_src": {"type": "Function", "def": "void lv_obj_set_style_bg_img_src(struct _lv_obj_t * obj, const void * value, lv_style_selector_t selector)", "sline": 322, "body": "{\n    lv_style_value_t v = {\n        .ptr = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_BG_IMG_SRC, v, selector);\n}"}, "lv_obj_set_style_bg_img_opa": {"type": "Function", "def": "void lv_obj_set_style_bg_img_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 330, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_BG_IMG_OPA, v, selector);\n}"}, "lv_obj_set_style_bg_img_recolor": {"type": "Function", "def": "void lv_obj_set_style_bg_img_recolor(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 338, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_BG_IMG_RECOLOR, v, selector);\n}"}, "lv_obj_set_style_bg_img_recolor_filtered": {"type": "Function", "def": "void lv_obj_set_style_bg_img_recolor_filtered(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 346, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_BG_IMG_RECOLOR_FILTERED, v, selector);\n}"}, "lv_obj_set_style_bg_img_recolor_opa": {"type": "Function", "def": "void lv_obj_set_style_bg_img_recolor_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 354, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_BG_IMG_RECOLOR_OPA, v, selector);\n}"}, "lv_obj_set_style_bg_img_tiled": {"type": "Function", "def": "void lv_obj_set_style_bg_img_tiled(struct _lv_obj_t * obj, bool value, lv_style_selector_t selector)", "sline": 362, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_BG_IMG_TILED, v, selector);\n}"}, "lv_obj_set_style_border_color": {"type": "Function", "def": "void lv_obj_set_style_border_color(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 370, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_BORDER_COLOR, v, selector);\n}"}, "lv_obj_set_style_border_color_filtered": {"type": "Function", "def": "void lv_obj_set_style_border_color_filtered(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 378, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_BORDER_COLOR_FILTERED, v, selector);\n}"}, "lv_obj_set_style_border_opa": {"type": "Function", "def": "void lv_obj_set_style_border_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 386, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_BORDER_OPA, v, selector);\n}"}, "lv_obj_set_style_border_width": {"type": "Function", "def": "void lv_obj_set_style_border_width(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 394, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_BORDER_WIDTH, v, selector);\n}"}, "lv_obj_set_style_border_side": {"type": "Function", "def": "void lv_obj_set_style_border_side(struct _lv_obj_t * obj, lv_border_side_t value, lv_style_selector_t selector)", "sline": 402, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_BORDER_SIDE, v, selector);\n}"}, "lv_obj_set_style_border_post": {"type": "Function", "def": "void lv_obj_set_style_border_post(struct _lv_obj_t * obj, bool value, lv_style_selector_t selector)", "sline": 410, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_BORDER_POST, v, selector);\n}"}, "lv_obj_set_style_text_color": {"type": "Function", "def": "void lv_obj_set_style_text_color(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 418, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_TEXT_COLOR, v, selector);\n}"}, "lv_obj_set_style_text_color_filtered": {"type": "Function", "def": "void lv_obj_set_style_text_color_filtered(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 426, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_TEXT_COLOR_FILTERED, v, selector);\n}"}, "lv_obj_set_style_text_opa": {"type": "Function", "def": "void lv_obj_set_style_text_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 434, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_TEXT_OPA, v, selector);\n}"}, "lv_obj_set_style_text_font": {"type": "Function", "def": "void lv_obj_set_style_text_font(struct _lv_obj_t * obj, const lv_font_t * value, lv_style_selector_t selector)", "sline": 442, "body": "{\n    lv_style_value_t v = {\n        .ptr = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_TEXT_FONT, v, selector);\n}"}, "lv_obj_set_style_text_letter_space": {"type": "Function", "def": "void lv_obj_set_style_text_letter_space(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 450, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_TEXT_LETTER_SPACE, v, selector);\n}"}, "lv_obj_set_style_text_line_space": {"type": "Function", "def": "void lv_obj_set_style_text_line_space(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 458, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_TEXT_LINE_SPACE, v, selector);\n}"}, "lv_obj_set_style_text_decor": {"type": "Function", "def": "void lv_obj_set_style_text_decor(struct _lv_obj_t * obj, lv_text_decor_t value, lv_style_selector_t selector)", "sline": 466, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_TEXT_DECOR, v, selector);\n}"}, "lv_obj_set_style_text_align": {"type": "Function", "def": "void lv_obj_set_style_text_align(struct _lv_obj_t * obj, lv_text_align_t value, lv_style_selector_t selector)", "sline": 474, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_TEXT_ALIGN, v, selector);\n}"}, "lv_obj_set_style_img_opa": {"type": "Function", "def": "void lv_obj_set_style_img_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 482, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_IMG_OPA, v, selector);\n}"}, "lv_obj_set_style_img_recolor": {"type": "Function", "def": "void lv_obj_set_style_img_recolor(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 490, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_IMG_RECOLOR, v, selector);\n}"}, "lv_obj_set_style_img_recolor_filtered": {"type": "Function", "def": "void lv_obj_set_style_img_recolor_filtered(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 498, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_IMG_RECOLOR_FILTERED, v, selector);\n}"}, "lv_obj_set_style_img_recolor_opa": {"type": "Function", "def": "void lv_obj_set_style_img_recolor_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 506, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_IMG_RECOLOR_OPA, v, selector);\n}"}, "lv_obj_set_style_outline_width": {"type": "Function", "def": "void lv_obj_set_style_outline_width(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 514, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_OUTLINE_WIDTH, v, selector);\n}"}, "lv_obj_set_style_outline_color": {"type": "Function", "def": "void lv_obj_set_style_outline_color(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 522, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_OUTLINE_COLOR, v, selector);\n}"}, "lv_obj_set_style_outline_color_filtered": {"type": "Function", "def": "void lv_obj_set_style_outline_color_filtered(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 530, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_OUTLINE_COLOR_FILTERED, v, selector);\n}"}, "lv_obj_set_style_outline_opa": {"type": "Function", "def": "void lv_obj_set_style_outline_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 538, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_OUTLINE_OPA, v, selector);\n}"}, "lv_obj_set_style_outline_pad": {"type": "Function", "def": "void lv_obj_set_style_outline_pad(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 546, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_OUTLINE_PAD, v, selector);\n}"}, "lv_obj_set_style_shadow_width": {"type": "Function", "def": "void lv_obj_set_style_shadow_width(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 554, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_SHADOW_WIDTH, v, selector);\n}"}, "lv_obj_set_style_shadow_ofs_x": {"type": "Function", "def": "void lv_obj_set_style_shadow_ofs_x(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 562, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_SHADOW_OFS_X, v, selector);\n}"}, "lv_obj_set_style_shadow_ofs_y": {"type": "Function", "def": "void lv_obj_set_style_shadow_ofs_y(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 570, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_SHADOW_OFS_Y, v, selector);\n}"}, "lv_obj_set_style_shadow_spread": {"type": "Function", "def": "void lv_obj_set_style_shadow_spread(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 578, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_SHADOW_SPREAD, v, selector);\n}"}, "lv_obj_set_style_shadow_color": {"type": "Function", "def": "void lv_obj_set_style_shadow_color(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 586, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_SHADOW_COLOR, v, selector);\n}"}, "lv_obj_set_style_shadow_color_filtered": {"type": "Function", "def": "void lv_obj_set_style_shadow_color_filtered(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 594, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_SHADOW_COLOR_FILTERED, v, selector);\n}"}, "lv_obj_set_style_shadow_opa": {"type": "Function", "def": "void lv_obj_set_style_shadow_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 602, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_SHADOW_OPA, v, selector);\n}"}, "lv_obj_set_style_line_width": {"type": "Function", "def": "void lv_obj_set_style_line_width(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 610, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_LINE_WIDTH, v, selector);\n}"}, "lv_obj_set_style_line_dash_width": {"type": "Function", "def": "void lv_obj_set_style_line_dash_width(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 618, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_LINE_DASH_WIDTH, v, selector);\n}"}, "lv_obj_set_style_line_dash_gap": {"type": "Function", "def": "void lv_obj_set_style_line_dash_gap(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 626, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_LINE_DASH_GAP, v, selector);\n}"}, "lv_obj_set_style_line_rounded": {"type": "Function", "def": "void lv_obj_set_style_line_rounded(struct _lv_obj_t * obj, bool value, lv_style_selector_t selector)", "sline": 634, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_LINE_ROUNDED, v, selector);\n}"}, "lv_obj_set_style_line_color": {"type": "Function", "def": "void lv_obj_set_style_line_color(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 642, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_LINE_COLOR, v, selector);\n}"}, "lv_obj_set_style_line_color_filtered": {"type": "Function", "def": "void lv_obj_set_style_line_color_filtered(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 650, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_LINE_COLOR_FILTERED, v, selector);\n}"}, "lv_obj_set_style_line_opa": {"type": "Function", "def": "void lv_obj_set_style_line_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 658, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_LINE_OPA, v, selector);\n}"}, "lv_obj_set_style_arc_width": {"type": "Function", "def": "void lv_obj_set_style_arc_width(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector)", "sline": 666, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_ARC_WIDTH, v, selector);\n}"}, "lv_obj_set_style_arc_rounded": {"type": "Function", "def": "void lv_obj_set_style_arc_rounded(struct _lv_obj_t * obj, bool value, lv_style_selector_t selector)", "sline": 674, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_ARC_ROUNDED, v, selector);\n}"}, "lv_obj_set_style_arc_color": {"type": "Function", "def": "void lv_obj_set_style_arc_color(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 682, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_ARC_COLOR, v, selector);\n}"}, "lv_obj_set_style_arc_color_filtered": {"type": "Function", "def": "void lv_obj_set_style_arc_color_filtered(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)", "sline": 690, "body": "{\n    lv_style_value_t v = {\n        .color = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_ARC_COLOR_FILTERED, v, selector);\n}"}, "lv_obj_set_style_arc_opa": {"type": "Function", "def": "void lv_obj_set_style_arc_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)", "sline": 698, "body": "{\n    lv_style_value_t v = {\n        .num = (int32_t)value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_ARC_OPA, v, selector);\n}"}, "lv_obj_set_style_arc_img_src": {"type": "Function", "def": "void lv_obj_set_style_arc_img_src(struct _lv_obj_t * obj, const void * value, lv_style_selector_t selector)", "sline": 706, "body": "{\n    lv_style_value_t v = {\n        .ptr = value\n    };\n    lv_obj_set_local_style_prop(obj, LV_STYLE_ARC_IMG_SRC, v, selector);\n}"}, "carbit_updater/lvgl/src/core/lv_obj_style_gen.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_style_gen.c"}}, "carbit_updater/lvgl/src/misc/lv_anim_timeline.c": {"lv_anim_timeline": {"type": "Variable", "def": "#include lv_anim_timeline.h", "sline": 9, "include": ["carbit_updater/lvgl/src/misc/lv_anim_timeline.h", null]}, "lv_mem": {"type": "Variable", "def": "#include lv_mem.h", "sline": 10, "include": ["carbit_updater/lvgl/src/misc/lv_mem.h", null]}, "lv_assert": {"type": "Variable", "def": "#include lv_assert.h", "sline": 11, "include": ["carbit_updater/lvgl/src/misc/lv_assert.h", null]}, "lv_anim_timeline_dsc_t.anim": {"type": "Variable", "def": "lv_anim_t anim", "sline": 23, "in_struct": "lv_anim_timeline_dsc_t"}, "lv_anim_timeline_dsc_t.start_time": {"type": "Variable", "def": "uint32_t start_time", "sline": 24, "in_struct": "lv_anim_timeline_dsc_t"}, "lv_anim_timeline_dsc_t": {"type": "Variable", "def": "typedef struct {\n    lv_anim_t anim;\n    uint32_t start_time;\n} lv_anim_timeline_dsc_t", "sline": 25, "docstring": "/*Data of anim_timeline_dsc*/"}, "_lv_anim_timeline_t.anim_dsc": {"type": "Variable", "def": "lv_anim_timeline_dsc_t * anim_dsc", "sline": 29, "in_struct": "_lv_anim_timeline_t"}, "_lv_anim_timeline_t.anim_dsc_cnt": {"type": "Variable", "def": "uint32_t anim_dsc_cnt", "sline": 30, "in_struct": "_lv_anim_timeline_t"}, "_lv_anim_timeline_t.reverse": {"type": "Variable", "def": "bool reverse", "sline": 31, "in_struct": "_lv_anim_timeline_t"}, "_lv_anim_timeline_t": {"type": "Struct", "def": "struct _lv_anim_timeline_t {\n    lv_anim_timeline_dsc_t * anim_dsc;  /**< Dynamically allocated anim dsc array*/\n    uint32_t anim_dsc_cnt;              /**< The length of anim dsc array*/\n    bool reverse;                       /**< Reverse playback*/\n}", "sline": 28, "docstring": "/*Data of anim_timeline*/", "body": "lv_anim_timeline_dsc_t * anim_dsc\nuint32_t anim_dsc_cnt\nbool reverse\n"}, "lv_anim_timeline_virtual_exec_cb": {"type": "Function", "def": "static void lv_anim_timeline_virtual_exec_cb(void * var, int32_t v)", "sline": 194, "body": "{\n    LV_UNUSED(var);\n    LV_UNUSED(v);\n}"}, "lv_anim_timeline_create": {"type": "Function", "def": "lv_anim_timeline_t * lv_anim_timeline_create(void)", "sline": 51, "body": "{\n    lv_anim_timeline_t * at = (lv_anim_timeline_t *)lv_mem_alloc(sizeof(lv_anim_timeline_t));\n\n    LV_ASSERT_MALLOC(at);\n\n    if(at) lv_memset_00(at, sizeof(lv_anim_timeline_t));\n\n    return at;\n}"}, "lv_anim_timeline_del": {"type": "Function", "def": "void lv_anim_timeline_del(lv_anim_timeline_t * at)", "sline": 62, "body": "{\n    LV_ASSERT_NULL(at);\n\n    lv_anim_timeline_stop(at);\n\n    lv_mem_free(at->anim_dsc);\n    lv_mem_free(at);\n}"}, "lv_anim_timeline_add": {"type": "Function", "def": "void lv_anim_timeline_add(lv_anim_timeline_t * at, uint32_t start_time, lv_anim_t * a)", "sline": 72, "body": "{\n    LV_ASSERT_NULL(at);\n\n    at->anim_dsc_cnt++;\n    at->anim_dsc = lv_mem_realloc(at->anim_dsc, at->anim_dsc_cnt * sizeof(lv_anim_timeline_dsc_t));\n\n    LV_ASSERT_MALLOC(at->anim_dsc);\n\n    at->anim_dsc[at->anim_dsc_cnt - 1].anim = *a;\n    at->anim_dsc[at->anim_dsc_cnt - 1].start_time = start_time;\n\n    /*Add default var and virtual exec_cb, used to delete animation.*/\n    if(a->var == NULL && a->exec_cb == NULL) {\n        at->anim_dsc[at->anim_dsc_cnt - 1].anim.var = at;\n        at->anim_dsc[at->anim_dsc_cnt - 1].anim.exec_cb = lv_anim_timeline_virtual_exec_cb;\n    }\n}"}, "lv_anim_timeline_start": {"type": "Function", "def": "uint32_t lv_anim_timeline_start(lv_anim_timeline_t * at)", "sline": 91, "body": "{\n    LV_ASSERT_NULL(at);\n\n    const uint32_t playtime = lv_anim_timeline_get_playtime(at);\n    bool reverse = at->reverse;\n\n    for(uint32_t i = 0; i < at->anim_dsc_cnt; i++) {\n        lv_anim_t a = at->anim_dsc[i].anim;\n        uint32_t start_time = at->anim_dsc[i].start_time;\n\n        if(reverse) {\n            int32_t temp = a.start_value;\n            a.start_value = a.end_value;\n            a.end_value = temp;\n            lv_anim_set_delay(&a, playtime - (start_time + a.time));\n        }\n        else {\n            lv_anim_set_delay(&a, start_time);\n        }\n\n        lv_anim_start(&a);\n    }\n\n    return playtime;\n}"}, "lv_anim_timeline_stop": {"type": "Function", "def": "void lv_anim_timeline_stop(lv_anim_timeline_t * at)", "sline": 118, "body": "{\n    LV_ASSERT_NULL(at);\n\n    for(uint32_t i = 0; i < at->anim_dsc_cnt; i++) {\n        lv_anim_t * a = &(at->anim_dsc[i].anim);\n        lv_anim_del(a->var, a->exec_cb);\n    }\n}"}, "lv_anim_timeline_set_reverse": {"type": "Function", "def": "void lv_anim_timeline_set_reverse(lv_anim_timeline_t * at, bool reverse)", "sline": 128, "body": "{\n    LV_ASSERT_NULL(at);\n    at->reverse = reverse;\n}"}, "lv_anim_timeline_set_progress": {"type": "Function", "def": "void lv_anim_timeline_set_progress(lv_anim_timeline_t * at, uint16_t progress)", "sline": 134, "body": "{\n    LV_ASSERT_NULL(at);\n\n    const uint32_t playtime = lv_anim_timeline_get_playtime(at);\n    const uint32_t act_time = progress * playtime / 0xFFFF;\n\n    for(uint32_t i = 0; i < at->anim_dsc_cnt; i++) {\n        lv_anim_t * a = &(at->anim_dsc[i].anim);\n\n        if(a->exec_cb == NULL) {\n            continue;\n        }\n\n        uint32_t start_time = at->anim_dsc[i].start_time;\n        int32_t value = 0;\n\n        if(act_time < start_time) {\n            value = a->start_value;\n        }\n        else if(act_time < (start_time + a->time)) {\n            a->act_time = act_time - start_time;\n            value = a->path_cb(a);\n        }\n        else {\n            value = a->end_value;\n        }\n\n        a->exec_cb(a->var, value);\n    }\n}"}, "lv_anim_timeline_get_playtime": {"type": "Function", "def": "uint32_t lv_anim_timeline_get_playtime(lv_anim_timeline_t * at)", "sline": 166, "body": "{\n    LV_ASSERT_NULL(at);\n\n    uint32_t playtime = 0;\n    for(uint32_t i = 0; i < at->anim_dsc_cnt; i++) {\n        uint32_t end = lv_anim_get_playtime(&at->anim_dsc[i].anim);\n        if (end == LV_ANIM_PLAYTIME_INFINITE)\n            return end;\n        end += at->anim_dsc[i].start_time;\n        if(end > playtime) {\n            playtime = end;\n        }\n    }\n\n    return playtime;\n}"}, "lv_anim_timeline_get_reverse": {"type": "Function", "def": "bool lv_anim_timeline_get_reverse(lv_anim_timeline_t * at)", "sline": 184, "body": "{\n    LV_ASSERT_NULL(at);\n    return at->reverse;\n}"}, "carbit_updater/lvgl/src/misc/lv_anim_timeline.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_anim_timeline.c"}}, "carbit_updater/lvgl/src/extra/libs/gif/gifdec.c": {"gifdec": {"type": "Variable", "def": "#include gifdec.h", "sline": 1, "include": ["carbit_updater/lvgl/src/extra/libs/gif/gifdec.h", null]}, "lv_log": {"type": "Variable", "def": "#include ../../../misc/lv_log.h", "sline": 2}, "lv_mem": {"type": "Variable", "def": "#include ../../../misc/lv_mem.h", "sline": 3}, "lv_color": {"type": "Variable", "def": "#include ../../../misc/lv_color.h", "sline": 4}, "carbit_updater/lvgl/src/extra/libs/gif/gifdec.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/gif/gifdec.c"}}, "carbit_updater/lv_drivers/sdl/sdl_gpu.c": {"sdl_gpu": {"type": "Variable", "def": "#include sdl_gpu.h", "sline": 9, "include": ["carbit_updater/lv_drivers/sdl/sdl_gpu.h", null]}, "carbit_updater/lv_drivers/sdl/sdl_gpu.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/sdl/sdl_gpu.c"}}, "carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.c": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 34}, "carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_vglite.c"}}, "carbit_updater/lvgl/src/core/lv_obj_tree.c": {"stdlib": {"type": "Variable", "def": "#include stdlib.h", "sline": 9}, "lv_obj": {"type": "Variable", "def": "#include lv_obj.h", "sline": 11, "include": ["carbit_updater/lvgl/src/core/lv_obj.h", null]}, "lv_indev": {"type": "Variable", "def": "#include lv_indev.h", "sline": 12, "include": ["carbit_updater/lvgl/src/core/lv_indev.h", null]}, "lv_anim": {"type": "Variable", "def": "#include ../misc/lv_anim.h", "sline": 13}, "lv_gc": {"type": "Variable", "def": "#include ../misc/lv_gc.h", "sline": 14}, "lv_async": {"type": "Variable", "def": "#include ../misc/lv_async.h", "sline": 15}, "lv_obj_del_async_cb": {"type": "Function", "def": "static void lv_obj_del_async_cb(void * obj)", "sline": 343, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_obj_del(obj);\n}"}, "obj_del_core": {"type": "Function", "def": "static void obj_del_core(lv_obj_t * obj)", "sline": 350, "body": "{\n    /*Let the user free the resources used in `LV_EVENT_DELETE`*/\n    lv_res_t res = lv_event_send(obj, LV_EVENT_DELETE, NULL);\n    if(res == LV_RES_INV) return;\n\n    /*Recursively delete the children*/\n    lv_obj_t * child = lv_obj_get_child(obj, 0);\n    while(child) {\n        obj_del_core(child);\n        child = lv_obj_get_child(obj, 0);\n    }\n\n    lv_group_t * group = lv_obj_get_group(obj);\n\n    /*Reset all input devices if the object to delete is used*/\n    lv_indev_t * indev = lv_indev_get_next(NULL);\n    while(indev) {\n        if(indev->proc.types.pointer.act_obj == obj || indev->proc.types.pointer.last_obj == obj) {\n            lv_indev_reset(indev, obj);\n        }\n        if(indev->proc.types.pointer.last_pressed == obj) {\n            indev->proc.types.pointer.last_pressed = NULL;\n        }\n\n        if(indev->group == group && obj == lv_indev_get_obj_act()) {\n            lv_indev_reset(indev, obj);\n        }\n        indev = lv_indev_get_next(indev);\n    }\n\n    /*All children deleted. Now clean up the object specific data*/\n    _lv_obj_destruct(obj);\n\n    /*Remove the screen for the screen list*/\n    if(obj->parent == NULL) {\n        lv_disp_t * disp = lv_obj_get_disp(obj);\n        uint32_t i;\n        /*Find the screen in the list*/\n        for(i = 0; i < disp->screen_cnt; i++) {\n            if(disp->screens[i] == obj) break;\n        }\n\n        uint32_t id = i;\n        for(i = id; i < disp->screen_cnt - 1; i++) {\n            disp->screens[i] = disp->screens[i + 1];\n        }\n        disp->screen_cnt--;\n        disp->screens = lv_mem_realloc(disp->screens, disp->screen_cnt * sizeof(lv_obj_t *));\n    }\n    /*Remove the object from the child list of its parent*/\n    else {\n        uint32_t id = lv_obj_get_index(obj);\n        uint32_t i;\n        for(i = id; i < obj->parent->spec_attr->child_cnt - 1; i++) {\n            obj->parent->spec_attr->children[i] = obj->parent->spec_attr->children[i + 1];\n        }\n        obj->parent->spec_attr->child_cnt--;\n        obj->parent->spec_attr->children = lv_mem_realloc(obj->parent->spec_attr->children,\n                                                          obj->parent->spec_attr->child_cnt * sizeof(lv_obj_t *));\n    }\n\n    /*Free the object itself*/\n    lv_mem_free(obj);\n}"}, "walk_core": {"type": "Function", "def": "static lv_obj_tree_walk_res_t walk_core(lv_obj_t * obj, lv_obj_tree_walk_cb_t cb, void * user_data)", "sline": 417, "body": "{\n    lv_obj_tree_walk_res_t res = LV_OBJ_TREE_WALK_NEXT;\n\n    if(obj == NULL) {\n        lv_disp_t * disp = lv_disp_get_next(NULL);\n        while(disp) {\n            uint32_t i;\n            for(i = 0; i < disp->screen_cnt; i++) {\n                walk_core(disp->screens[i], cb, user_data);\n            }\n            disp = lv_disp_get_next(disp);\n        }\n        return LV_OBJ_TREE_WALK_END;    /*The value doesn't matter as it wasn't called recursively*/\n    }\n\n    res = cb(obj, user_data);\n\n    if(res == LV_OBJ_TREE_WALK_END) return LV_OBJ_TREE_WALK_END;\n\n    if(res != LV_OBJ_TREE_WALK_SKIP_CHILDREN) {\n        uint32_t i;\n        for(i = 0; i < lv_obj_get_child_cnt(obj); i++) {\n            res = walk_core(lv_obj_get_child(obj, i), cb, user_data);\n            if(res == LV_OBJ_TREE_WALK_END) return LV_OBJ_TREE_WALK_END;\n        }\n    }\n    return LV_OBJ_TREE_WALK_NEXT;\n}"}, "lv_obj_del": {"type": "Function", "def": "void lv_obj_del(lv_obj_t * obj)", "sline": 45, "body": "{\n    LV_LOG_TRACE(\"begin (delete %p)\", (void *)obj);\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_obj_invalidate(obj);\n\n    lv_obj_t * par = lv_obj_get_parent(obj);\n    if(par) {\n        lv_obj_scrollbar_invalidate(par);\n    }\n\n    lv_disp_t * disp = NULL;\n    bool act_scr_del = false;\n    if(par == NULL) {\n        disp = lv_obj_get_disp(obj);\n        if(!disp) return;   /*Shouldn't happen*/\n        if(disp->act_scr == obj) act_scr_del = true;\n    }\n\n    obj_del_core(obj);\n\n    /*Call the ancestor's event handler to the parent to notify it about the child delete*/\n    if(par) {\n        lv_obj_readjust_scroll(par, LV_ANIM_OFF);\n        lv_obj_scrollbar_invalidate(par);\n        lv_event_send(par, LV_EVENT_CHILD_CHANGED, NULL);\n        lv_event_send(par, LV_EVENT_CHILD_DELETED, NULL);\n    }\n\n    /*Handle if the active screen was deleted*/\n    if(act_scr_del) {\n        LV_LOG_WARN(\"the active screen was deleted\");\n        disp->act_scr = NULL;\n    }\n\n    LV_ASSERT_MEM_INTEGRITY();\n    LV_LOG_TRACE(\"finished (delete %p)\", (void *)obj);\n}"}, "lv_obj_clean": {"type": "Function", "def": "void lv_obj_clean(lv_obj_t * obj)", "sline": 84, "body": "{\n    LV_LOG_TRACE(\"begin (delete %p)\", (void *)obj);\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_obj_invalidate(obj);\n\n    lv_obj_t * child = lv_obj_get_child(obj, 0);\n    while(child) {\n        obj_del_core(child);\n        child = lv_obj_get_child(obj, 0);\n    }\n    /*Just to remove scroll animations if any*/\n    lv_obj_scroll_to(obj, 0, 0, LV_ANIM_OFF);\n    if(obj->spec_attr) {\n        obj->spec_attr->scroll.x = 0;\n        obj->spec_attr->scroll.y = 0;\n    }\n\n    LV_ASSERT_MEM_INTEGRITY();\n\n    LV_LOG_TRACE(\"finished (delete %p)\", (void *)obj);\n}"}, "lv_obj_del_delayed": {"type": "Function", "def": "void lv_obj_del_delayed(lv_obj_t * obj, uint32_t delay_ms)", "sline": 108, "body": "{\n    lv_anim_t a;\n    lv_anim_init(&a);\n    lv_anim_set_var(&a, obj);\n    lv_anim_set_exec_cb(&a, NULL);\n    lv_anim_set_time(&a, 1);\n    lv_anim_set_delay(&a, delay_ms);\n    lv_anim_set_ready_cb(&a, lv_obj_del_anim_ready_cb);\n    lv_anim_start(&a);\n}"}, "lv_obj_del_anim_ready_cb": {"type": "Function", "def": "void lv_obj_del_anim_ready_cb(lv_anim_t * a)", "sline": 120, "body": "{\n    lv_obj_del(a->var);\n}"}, "lv_obj_del_async": {"type": "Function", "def": "void lv_obj_del_async(lv_obj_t * obj)", "sline": 125, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    lv_async_call(lv_obj_del_async_cb, obj);\n}"}, "lv_obj_set_parent": {"type": "Function", "def": "void lv_obj_set_parent(lv_obj_t * obj, lv_obj_t * parent)", "sline": 131, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_OBJ(parent, MY_CLASS);\n\n    if(obj->parent == NULL) {\n        LV_LOG_WARN(\"Can't set the parent of a screen\");\n        return;\n    }\n\n    if(parent == NULL) {\n        LV_LOG_WARN(\"Can't set parent == NULL to an object\");\n        return;\n    }\n\n    lv_obj_invalidate(obj);\n\n    lv_obj_allocate_spec_attr(parent);\n\n    lv_obj_t * old_parent = obj->parent;\n    /*Remove the object from the old parent's child list*/\n    int32_t i;\n    for(i = lv_obj_get_index(obj); i <= (int32_t)lv_obj_get_child_cnt(old_parent) - 2; i++) {\n        old_parent->spec_attr->children[i] = old_parent->spec_attr->children[i + 1];\n    }\n    old_parent->spec_attr->child_cnt--;\n    if(old_parent->spec_attr->child_cnt) {\n        old_parent->spec_attr->children = lv_mem_realloc(old_parent->spec_attr->children,\n                                                         old_parent->spec_attr->child_cnt * (sizeof(lv_obj_t *)));\n    }\n    else {\n        lv_mem_free(old_parent->spec_attr->children);\n        old_parent->spec_attr->children = NULL;\n    }\n\n    /*Add the child to the new parent as the last (newest child)*/\n    parent->spec_attr->child_cnt++;\n    parent->spec_attr->children = lv_mem_realloc(parent->spec_attr->children,\n                                                 parent->spec_attr->child_cnt * (sizeof(lv_obj_t *)));\n    parent->spec_attr->children[lv_obj_get_child_cnt(parent) - 1] = obj;\n\n    obj->parent = parent;\n\n    /*Notify the original parent because one of its children is lost*/\n    lv_event_send(old_parent, LV_EVENT_CHILD_CHANGED, obj);\n    lv_event_send(old_parent, LV_EVENT_CHILD_DELETED, NULL);\n\n    /*Notify the new parent about the child*/\n    lv_event_send(parent, LV_EVENT_CHILD_CHANGED, obj);\n    lv_event_send(parent, LV_EVENT_CHILD_CREATED, NULL);\n\n    lv_obj_mark_layout_as_dirty(obj);\n\n    lv_obj_invalidate(obj);\n}"}, "lv_obj_move_to_index": {"type": "Function", "def": "void lv_obj_move_to_index(lv_obj_t * obj, int32_t index)", "sline": 187, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    const int32_t old_index = lv_obj_get_index(obj);\n\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n\n    if(index < 0) return;\n    if(index >= (int32_t) lv_obj_get_child_cnt(parent)) return;\n    if(index == old_index) return;\n\n    int32_t i = old_index;\n    if(index < old_index) {\n        while(i > index)  {\n            parent->spec_attr->children[i] = parent->spec_attr->children[i - 1];\n            i--;\n        }\n    }\n    else {\n        while(i < index) {\n            parent->spec_attr->children[i] = parent->spec_attr->children[i + 1];\n            i++;\n        }\n    }\n\n    parent->spec_attr->children[index] = obj;\n    lv_event_send(parent, LV_EVENT_CHILD_CHANGED, NULL);\n    lv_obj_invalidate(parent);\n}"}, "lv_obj_swap": {"type": "Function", "def": "void lv_obj_swap(lv_obj_t * obj1, lv_obj_t * obj2)", "sline": 218, "body": "{\n    LV_ASSERT_OBJ(obj1, MY_CLASS);\n    LV_ASSERT_OBJ(obj2, MY_CLASS);\n\n    lv_obj_t * parent = lv_obj_get_parent(obj1);\n    lv_obj_t * parent2 = lv_obj_get_parent(obj2);\n\n    uint_fast32_t index1 = lv_obj_get_index(obj1);\n    uint_fast32_t index2 = lv_obj_get_index(obj2);\n\n    lv_event_send(parent2, LV_EVENT_CHILD_DELETED, obj2);\n    lv_event_send(parent, LV_EVENT_CHILD_DELETED, obj1);\n\n    parent->spec_attr->children[index1] = obj2;\n    parent2->spec_attr->children[index2] = obj1;\n\n    lv_event_send(parent, LV_EVENT_CHILD_CHANGED, obj2);\n    lv_event_send(parent, LV_EVENT_CHILD_CREATED, obj2);\n    lv_event_send(parent2, LV_EVENT_CHILD_CHANGED, obj1);\n    lv_event_send(parent2, LV_EVENT_CHILD_CREATED, obj1);\n\n    lv_obj_invalidate(parent);\n\n    if(parent != parent2) {\n        lv_obj_invalidate(parent2);\n    }\n    lv_group_swap_obj(obj1, obj2);\n}"}, "lv_obj_get_screen": {"type": "Function", "def": "lv_obj_t * lv_obj_get_screen(const lv_obj_t * obj)", "sline": 248, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    const lv_obj_t * par = obj;\n    const lv_obj_t * act_par;\n\n    do {\n        act_par = par;\n        par = lv_obj_get_parent(act_par);\n    } while(par != NULL);\n\n    return (lv_obj_t *)act_par;\n}"}, "lv_obj_get_disp": {"type": "Function", "def": "lv_disp_t * lv_obj_get_disp(const lv_obj_t * obj)", "sline": 263, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    const lv_obj_t * scr;\n\n    if(obj->parent == NULL) scr = obj;  /*`obj` is a screen*/\n    else scr = lv_obj_get_screen(obj);  /*get the screen of `obj`*/\n\n    lv_disp_t * d;\n    _LV_LL_READ(&LV_GC_ROOT(_lv_disp_ll), d) {\n        uint32_t i;\n        for(i = 0; i < d->screen_cnt; i++) {\n            if(d->screens[i] == scr) return d;\n        }\n    }\n\n    LV_LOG_WARN(\"No screen found\");\n    return NULL;\n}"}, "lv_obj_get_parent": {"type": "Function", "def": "lv_obj_t * lv_obj_get_parent(const lv_obj_t * obj)", "sline": 284, "body": "{\n    if(obj == NULL) return NULL;\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    return obj->parent;\n}"}, "lv_obj_get_child": {"type": "Function", "def": "lv_obj_t * lv_obj_get_child(const lv_obj_t * obj, int32_t id)", "sline": 292, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    if(obj->spec_attr == NULL) return NULL;\n\n    uint32_t idu;\n    if(id < 0) {\n        id = obj->spec_attr->child_cnt + id;\n        if(id < 0) return NULL;\n        idu = (uint32_t) id;\n    }\n    else {\n        idu = id;\n    }\n\n    if(idu >= obj->spec_attr->child_cnt) return NULL;\n    else return obj->spec_attr->children[id];\n}"}, "lv_obj_get_child_cnt": {"type": "Function", "def": "uint32_t lv_obj_get_child_cnt(const lv_obj_t * obj)", "sline": 312, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    if(obj->spec_attr == NULL) return 0;\n    return obj->spec_attr->child_cnt;\n}"}, "lv_obj_get_index": {"type": "Function", "def": "uint32_t lv_obj_get_index(const lv_obj_t * obj)", "sline": 319, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_obj_t * parent = lv_obj_get_parent(obj);\n    if(parent == NULL) return 0;\n\n    uint32_t i = 0;\n    for(i = 0; i < lv_obj_get_child_cnt(parent); i++) {\n        if(lv_obj_get_child(parent, i) == obj) return i;\n    }\n\n    return 0xFFFFFFFF; /*Shouldn't happen*/\n}"}, "lv_obj_tree_walk": {"type": "Function", "def": "void lv_obj_tree_walk(lv_obj_t * start_obj, lv_obj_tree_walk_cb_t cb, void * user_data)", "sline": 334, "body": "{\n    walk_core(start_obj, cb, user_data);\n}"}, "carbit_updater/lvgl/src/core/lv_obj_tree.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_obj_tree.c"}}, "carbit_updater/lvgl/src/gpu/lv_gpu_nxp_pxp_osa.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 37}, "carbit_updater/lvgl/src/gpu/lv_gpu_nxp_pxp_osa.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_pxp_osa.h"}}, "carbit_updater/lvgl/src/widgets/lv_arc.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "lv_obj": {"type": "Variable", "def": "#include ../core/lv_obj.h", "sline": 20}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_arc.h:30:1)": {"type": "Enum", "def": "enum {\n    LV_ARC_MODE_NORMAL,\n    LV_ARC_MODE_SYMMETRICAL,\n    LV_ARC_MODE_REVERSE\n}", "sline": 30}, "lv_arc_mode_t": {"type": "Variable", "def": "typedef uint8_t lv_arc_mode_t", "sline": 35}, "lv_arc_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 38, "in_struct": "lv_arc_t"}, "lv_arc_t.rotation": {"type": "Variable", "def": "uint16_t rotation", "sline": 39, "in_struct": "lv_arc_t"}, "lv_arc_t.indic_angle_start": {"type": "Variable", "def": "uint16_t indic_angle_start", "sline": 40, "in_struct": "lv_arc_t"}, "lv_arc_t.indic_angle_end": {"type": "Variable", "def": "uint16_t indic_angle_end", "sline": 41, "in_struct": "lv_arc_t"}, "lv_arc_t.bg_angle_start": {"type": "Variable", "def": "uint16_t bg_angle_start", "sline": 42, "in_struct": "lv_arc_t"}, "lv_arc_t.bg_angle_end": {"type": "Variable", "def": "uint16_t bg_angle_end", "sline": 43, "in_struct": "lv_arc_t"}, "lv_arc_t.value": {"type": "Variable", "def": "int16_t value", "sline": 44, "in_struct": "lv_arc_t"}, "lv_arc_t.min_value": {"type": "Variable", "def": "int16_t min_value", "sline": 45, "in_struct": "lv_arc_t"}, "lv_arc_t.max_value": {"type": "Variable", "def": "int16_t max_value", "sline": 46, "in_struct": "lv_arc_t"}, "lv_arc_t.dragging": {"type": "Variable", "def": "uint16_t dragging    : 1", "sline": 47, "in_struct": "lv_arc_t"}, "lv_arc_t.type": {"type": "Variable", "def": "uint16_t type        : 2", "sline": 48, "in_struct": "lv_arc_t"}, "lv_arc_t.min_close": {"type": "Variable", "def": "uint16_t min_close   : 1", "sline": 49, "in_struct": "lv_arc_t"}, "lv_arc_t.chg_rate": {"type": "Variable", "def": "uint16_t chg_rate", "sline": 50, "in_struct": "lv_arc_t"}, "lv_arc_t.last_tick": {"type": "Variable", "def": "uint32_t last_tick", "sline": 51, "in_struct": "lv_arc_t"}, "lv_arc_t.last_angle": {"type": "Variable", "def": "int16_t last_angle", "sline": 52, "in_struct": "lv_arc_t"}, "lv_arc_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    uint16_t rotation;\n    uint16_t indic_angle_start;\n    uint16_t indic_angle_end;\n    uint16_t bg_angle_start;\n    uint16_t bg_angle_end;\n    int16_t value;              /*Current value of the arc*/\n    int16_t min_value;          /*Minimum value of the arc*/\n    int16_t max_value;          /*Maximum value of the arc*/\n    uint16_t dragging    : 1;\n    uint16_t type        : 2;\n    uint16_t min_close   : 1;   /*1: the last pressed angle was closer to minimum end*/\n    uint16_t chg_rate;          /*Drag angle rate of change of the arc (degrees/sec)*/\n    uint32_t last_tick;         /*Last dragging event timestamp of the arc*/\n    int16_t last_angle;         /*Last dragging angle of the arc*/\n} lv_arc_t", "sline": 53}, "lv_arc_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_arc_class", "sline": 55}, "lv_arc_draw_part_type_t": {"type": "Variable", "def": "typedef enum {\n    LV_ARC_DRAW_PART_BACKGROUND,    /**< The background arc*/\n    LV_ARC_DRAW_PART_FOREGROUND,    /**< The foreground arc*/\n    LV_ARC_DRAW_PART_KNOB,          /**< The knob*/\n} lv_arc_draw_part_type_t", "sline": 65}, "lv_arc_create": {"type": "Function", "def": "lv_obj_t * lv_arc_create(lv_obj_t * parent)", "sline": 76}, "lv_arc_set_start_angle": {"type": "Function", "def": "void lv_arc_set_start_angle(lv_obj_t * arc, uint16_t start)", "sline": 91}, "lv_arc_set_end_angle": {"type": "Function", "def": "void lv_arc_set_end_angle(lv_obj_t * arc, uint16_t end)", "sline": 98}, "lv_arc_set_angles": {"type": "Function", "def": "void lv_arc_set_angles(lv_obj_t * arc, uint16_t start, uint16_t end)", "sline": 106}, "lv_arc_set_bg_start_angle": {"type": "Function", "def": "void lv_arc_set_bg_start_angle(lv_obj_t * arc, uint16_t start)", "sline": 113}, "lv_arc_set_bg_end_angle": {"type": "Function", "def": "void lv_arc_set_bg_end_angle(lv_obj_t * arc, uint16_t end)", "sline": 120}, "lv_arc_set_bg_angles": {"type": "Function", "def": "void lv_arc_set_bg_angles(lv_obj_t * arc, uint16_t start, uint16_t end)", "sline": 128}, "lv_arc_set_rotation": {"type": "Function", "def": "void lv_arc_set_rotation(lv_obj_t * arc, uint16_t rotation)", "sline": 135}, "lv_arc_set_mode": {"type": "Function", "def": "void lv_arc_set_mode(lv_obj_t * arc, lv_arc_mode_t type)", "sline": 142}, "lv_arc_set_value": {"type": "Function", "def": "void lv_arc_set_value(lv_obj_t * arc, int16_t value)", "sline": 149}, "lv_arc_set_range": {"type": "Function", "def": "void lv_arc_set_range(lv_obj_t * arc, int16_t min, int16_t max)", "sline": 157}, "lv_arc_set_change_rate": {"type": "Function", "def": "void lv_arc_set_change_rate(lv_obj_t * arc, uint16_t rate)", "sline": 164}, "lv_arc_get_angle_start": {"type": "Function", "def": "uint16_t lv_arc_get_angle_start(lv_obj_t * obj)", "sline": 175}, "lv_arc_get_angle_end": {"type": "Function", "def": "uint16_t lv_arc_get_angle_end(lv_obj_t * obj)", "sline": 182}, "lv_arc_get_bg_angle_start": {"type": "Function", "def": "uint16_t lv_arc_get_bg_angle_start(lv_obj_t * obj)", "sline": 189}, "lv_arc_get_bg_angle_end": {"type": "Function", "def": "uint16_t lv_arc_get_bg_angle_end(lv_obj_t * obj)", "sline": 196}, "lv_arc_get_value": {"type": "Function", "def": "int16_t lv_arc_get_value(const lv_obj_t * obj)", "sline": 203}, "lv_arc_get_min_value": {"type": "Function", "def": "int16_t lv_arc_get_min_value(const lv_obj_t * obj)", "sline": 210}, "lv_arc_get_max_value": {"type": "Function", "def": "int16_t lv_arc_get_max_value(const lv_obj_t * obj)", "sline": 217}, "lv_arc_get_mode": {"type": "Function", "def": "lv_arc_mode_t lv_arc_get_mode(const lv_obj_t * obj)", "sline": 224, "rels": [["lv_arc_mode_t", null, "Typeof"]]}, "carbit_updater/lvgl/src/widgets/lv_arc.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_arc.h"}}, "carbit_updater/lvgl/src/extra/themes/default/lv_theme_default.c": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 9}, "lv_theme_default": {"type": "Variable", "def": "#include lv_theme_default.h", "sline": 13, "include": ["carbit_updater/lvgl/src/extra/themes/default/lv_theme_default.h", null]}, "lv_gc": {"type": "Variable", "def": "#include ../../../misc/lv_gc.h", "sline": 14}, "my_theme_styles_t.scr": {"type": "Variable", "def": "lv_style_t scr", "sline": 44, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.scrollbar": {"type": "Variable", "def": "lv_style_t scrollbar", "sline": 45, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.scrollbar_scrolled": {"type": "Variable", "def": "lv_style_t scrollbar_scrolled", "sline": 46, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.card": {"type": "Variable", "def": "lv_style_t card", "sline": 47, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.btn": {"type": "Variable", "def": "lv_style_t btn", "sline": 48, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.bg_color_primary": {"type": "Variable", "def": "lv_style_t bg_color_primary", "sline": 51, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.bg_color_primary_muted": {"type": "Variable", "def": "lv_style_t bg_color_primary_muted", "sline": 52, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.bg_color_secondary": {"type": "Variable", "def": "lv_style_t bg_color_secondary", "sline": 53, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.bg_color_secondary_muted": {"type": "Variable", "def": "lv_style_t bg_color_secondary_muted", "sline": 54, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.bg_color_grey": {"type": "Variable", "def": "lv_style_t bg_color_grey", "sline": 55, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.bg_color_white": {"type": "Variable", "def": "lv_style_t bg_color_white", "sline": 56, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.pressed": {"type": "Variable", "def": "lv_style_t pressed", "sline": 57, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.disabled": {"type": "Variable", "def": "lv_style_t disabled", "sline": 58, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.pad_zero": {"type": "Variable", "def": "lv_style_t pad_zero", "sline": 59, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.pad_tiny": {"type": "Variable", "def": "lv_style_t pad_tiny", "sline": 60, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.pad_small": {"type": "Variable", "def": "lv_style_t pad_small", "sline": 61, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.pad_normal": {"type": "Variable", "def": "lv_style_t pad_normal", "sline": 62, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.pad_gap": {"type": "Variable", "def": "lv_style_t pad_gap", "sline": 63, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.line_space_large": {"type": "Variable", "def": "lv_style_t line_space_large", "sline": 64, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.text_align_center": {"type": "Variable", "def": "lv_style_t text_align_center", "sline": 65, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.outline_primary": {"type": "Variable", "def": "lv_style_t outline_primary", "sline": 66, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.outline_secondary": {"type": "Variable", "def": "lv_style_t outline_secondary", "sline": 67, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.circle": {"type": "Variable", "def": "lv_style_t circle", "sline": 68, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.no_radius": {"type": "Variable", "def": "lv_style_t no_radius", "sline": 69, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.clip_corner": {"type": "Variable", "def": "lv_style_t clip_corner", "sline": 70, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.grow": {"type": "Variable", "def": "lv_style_t grow", "sline": 72, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.transition_delayed": {"type": "Variable", "def": "lv_style_t transition_delayed", "sline": 74, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.transition_normal": {"type": "Variable", "def": "lv_style_t transition_normal", "sline": 75, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.anim": {"type": "Variable", "def": "lv_style_t anim", "sline": 76, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.anim_fast": {"type": "Variable", "def": "lv_style_t anim_fast", "sline": 77, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.knob": {"type": "Variable", "def": "lv_style_t knob", "sline": 80, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.indic": {"type": "Variable", "def": "lv_style_t indic", "sline": 81, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.arc_indic": {"type": "Variable", "def": "lv_style_t arc_indic", "sline": 84, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.arc_indic_primary": {"type": "Variable", "def": "lv_style_t arc_indic_primary", "sline": 85, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.chart_series": {"type": "Variable", "def": "lv_style_t chart_series", "sline": 89, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.chart_indic": {"type": "Variable", "def": "lv_style_t chart_series, chart_indic", "sline": 89, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.chart_ticks": {"type": "Variable", "def": "lv_style_t chart_series, chart_indic, chart_ticks", "sline": 89, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.chart_bg": {"type": "Variable", "def": "lv_style_t chart_series, chart_indic, chart_ticks, chart_bg", "sline": 89, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.dropdown_list": {"type": "Variable", "def": "lv_style_t dropdown_list", "sline": 93, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.cb_marker": {"type": "Variable", "def": "lv_style_t cb_marker", "sline": 97, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.cb_marker_checked": {"type": "Variable", "def": "lv_style_t cb_marker, cb_marker_checked", "sline": 97, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.switch_knob": {"type": "Variable", "def": "lv_style_t switch_knob", "sline": 101, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.line": {"type": "Variable", "def": "lv_style_t line", "sline": 105, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.table_cell": {"type": "Variable", "def": "lv_style_t table_cell", "sline": 109, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.meter_marker": {"type": "Variable", "def": "lv_style_t meter_marker", "sline": 113, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.meter_indic": {"type": "Variable", "def": "lv_style_t meter_marker, meter_indic", "sline": 113, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.ta_cursor": {"type": "Variable", "def": "lv_style_t ta_cursor", "sline": 117, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.ta_placeholder": {"type": "Variable", "def": "lv_style_t ta_cursor, ta_placeholder", "sline": 117, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.calendar_btnm_bg": {"type": "Variable", "def": "lv_style_t calendar_btnm_bg", "sline": 121, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.calendar_btnm_day": {"type": "Variable", "def": "lv_style_t calendar_btnm_bg, calendar_btnm_day", "sline": 121, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.calendar_header": {"type": "Variable", "def": "lv_style_t calendar_btnm_bg, calendar_btnm_day, calendar_header", "sline": 121, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.colorwheel_main": {"type": "Variable", "def": "lv_style_t colorwheel_main", "sline": 125, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.msgbox_bg": {"type": "Variable", "def": "lv_style_t msgbox_bg", "sline": 129, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.msgbox_btn_bg": {"type": "Variable", "def": "lv_style_t msgbox_bg, msgbox_btn_bg", "sline": 129, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.msgbox_backdrop_bg": {"type": "Variable", "def": "lv_style_t msgbox_bg, msgbox_btn_bg, msgbox_backdrop_bg", "sline": 129, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.keyboard_btn_bg": {"type": "Variable", "def": "lv_style_t keyboard_btn_bg", "sline": 133, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.list_bg": {"type": "Variable", "def": "lv_style_t list_bg", "sline": 137, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.list_btn": {"type": "Variable", "def": "lv_style_t list_bg, list_btn", "sline": 137, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.list_item_grow": {"type": "Variable", "def": "lv_style_t list_bg, list_btn, list_item_grow", "sline": 137, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.list_label": {"type": "Variable", "def": "lv_style_t list_bg, list_btn, list_item_grow, list_label", "sline": 137, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.tab_bg_focus": {"type": "Variable", "def": "lv_style_t tab_bg_focus", "sline": 141, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.tab_btn": {"type": "Variable", "def": "lv_style_t tab_bg_focus, tab_btn", "sline": 141, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.led": {"type": "Variable", "def": "lv_style_t led", "sline": 144, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t": {"type": "Variable", "def": "typedef struct {\n    lv_style_t scr;\n    lv_style_t scrollbar;\n    lv_style_t scrollbar_scrolled;\n    lv_style_t card;\n    lv_style_t btn;\n\n    /*Utility*/\n    lv_style_t bg_color_primary;\n    lv_style_t bg_color_primary_muted;\n    lv_style_t bg_color_secondary;\n    lv_style_t bg_color_secondary_muted;\n    lv_style_t bg_color_grey;\n    lv_style_t bg_color_white;\n    lv_style_t pressed;\n    lv_style_t disabled;\n    lv_style_t pad_zero;\n    lv_style_t pad_tiny;\n    lv_style_t pad_small;\n    lv_style_t pad_normal;\n    lv_style_t pad_gap;\n    lv_style_t line_space_large;\n    lv_style_t text_align_center;\n    lv_style_t outline_primary;\n    lv_style_t outline_secondary;\n    lv_style_t circle;\n    lv_style_t no_radius;\n    lv_style_t clip_corner;\n#if LV_THEME_DEFAULT_GROW\n    lv_style_t grow;\n#endif\n    lv_style_t transition_delayed;\n    lv_style_t transition_normal;\n    lv_style_t anim;\n    lv_style_t anim_fast;\n\n    /*Parts*/\n    lv_style_t knob;\n    lv_style_t indic;\n\n#if LV_USE_ARC\n    lv_style_t arc_indic;\n    lv_style_t arc_indic_primary;\n#endif\n\n#if LV_USE_CHART\n    lv_style_t chart_series, chart_indic, chart_ticks, chart_bg;\n#endif\n\n#if LV_USE_DROPDOWN\n    lv_style_t dropdown_list;\n#endif\n\n#if LV_USE_CHECKBOX\n    lv_style_t cb_marker, cb_marker_checked;\n#endif\n\n#if LV_USE_SWITCH\n    lv_style_t switch_knob;\n#endif\n\n#if LV_USE_LINE\n    lv_style_t line;\n#endif\n\n#if LV_USE_TABLE\n    lv_style_t table_cell;\n#endif\n\n#if LV_USE_METER\n    lv_style_t meter_marker, meter_indic;\n#endif\n\n#if LV_USE_TEXTAREA\n    lv_style_t ta_cursor, ta_placeholder;\n#endif\n\n#if LV_USE_CALENDAR\n    lv_style_t calendar_btnm_bg, calendar_btnm_day, calendar_header;\n#endif\n\n#if LV_USE_COLORWHEEL\n    lv_style_t colorwheel_main;\n#endif\n\n#if LV_USE_MSGBOX\n    lv_style_t msgbox_bg, msgbox_btn_bg, msgbox_backdrop_bg;\n#endif\n\n#if LV_USE_KEYBOARD\n    lv_style_t keyboard_btn_bg;\n#endif\n\n#if LV_USE_LIST\n    lv_style_t list_bg, list_btn, list_item_grow, list_label;\n#endif\n\n#if LV_USE_TABVIEW\n    lv_style_t tab_bg_focus, tab_btn;\n#endif\n#if LV_USE_LED\n    lv_style_t led;\n#endif\n} my_theme_styles_t", "sline": 146, "docstring": "/**********************"}, "my_theme_t.base": {"type": "Variable", "def": "lv_theme_t base", "sline": 149, "in_struct": "my_theme_t"}, "my_theme_t.light": {"type": "Variable", "def": "uint8_t light : 1", "sline": 150, "in_struct": "my_theme_t"}, "my_theme_t": {"type": "Variable", "def": "typedef struct {\n    lv_theme_t base;\n    uint8_t light : 1;\n} my_theme_t", "sline": 151}, "disp_size_t": {"type": "Variable", "def": "typedef enum {\n    DISP_SMALL = 3,\n    DISP_MEDIUM = 2,\n    DISP_LARGE = 1,\n} disp_size_t", "sline": 157}, "theme_apply": {"type": "Function", "def": "static void theme_apply(lv_theme_t * th, lv_obj_t * obj)", "sline": 624, "body": "{\n    LV_UNUSED(th);\n\n    if(lv_obj_get_parent(obj) == NULL) {\n        lv_obj_add_style(obj, &styles->scr, 0);\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n        lv_obj_add_style(obj, &styles->scrollbar_scrolled, LV_PART_SCROLLBAR | LV_STATE_SCROLLED);\n        return;\n    }\n\n    if(lv_obj_check_type(obj, &lv_obj_class)) {\n#if LV_USE_TABVIEW\n        lv_obj_t * parent = lv_obj_get_parent(obj);\n        /*Tabview content area*/\n        if(lv_obj_check_type(parent, &lv_tabview_class)) {\n            return;\n        }\n        /*Tabview pages*/\n        else if(lv_obj_check_type(lv_obj_get_parent(parent), &lv_tabview_class)) {\n            lv_obj_add_style(obj, &styles->pad_normal, 0);\n            lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n            lv_obj_add_style(obj, &styles->scrollbar_scrolled, LV_PART_SCROLLBAR | LV_STATE_SCROLLED);\n            return;\n        }\n#endif\n\n#if LV_USE_WIN\n        /*Header*/\n        if(lv_obj_get_index(obj) == 0 && lv_obj_check_type(lv_obj_get_parent(obj), &lv_win_class)) {\n            lv_obj_add_style(obj, &styles->bg_color_grey, 0);\n            lv_obj_add_style(obj, &styles->pad_tiny, 0);\n            return;\n        }\n        /*Content*/\n        else if(lv_obj_get_index(obj) == 1 && lv_obj_check_type(lv_obj_get_parent(obj), &lv_win_class)) {\n            lv_obj_add_style(obj, &styles->scr, 0);\n            lv_obj_add_style(obj, &styles->pad_normal, 0);\n            lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n            lv_obj_add_style(obj, &styles->scrollbar_scrolled, LV_PART_SCROLLBAR | LV_STATE_SCROLLED);\n            return;\n        }\n#endif\n\n\n#if LV_USE_CALENDAR\n    else if(lv_obj_check_type(lv_obj_get_parent(obj), &lv_calendar_class)) {\n        /*No style*/\n        return;\n    }\n#endif\n\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n        lv_obj_add_style(obj, &styles->scrollbar_scrolled, LV_PART_SCROLLBAR | LV_STATE_SCROLLED);\n    }\n#if LV_USE_BTN\n    else if(lv_obj_check_type(obj, &lv_btn_class)) {\n        lv_obj_add_style(obj, &styles->btn, 0);\n        lv_obj_add_style(obj, &styles->bg_color_primary, 0);\n        lv_obj_add_style(obj, &styles->transition_delayed, 0);\n        lv_obj_add_style(obj, &styles->pressed, LV_STATE_PRESSED);\n        lv_obj_add_style(obj, &styles->transition_normal, LV_STATE_PRESSED);\n        lv_obj_add_style(obj, &styles->outline_primary, LV_STATE_FOCUS_KEY);\n#if LV_THEME_DEFAULT_GROW\n        lv_obj_add_style(obj, &styles->grow, LV_STATE_PRESSED);\n#endif\n        lv_obj_add_style(obj, &styles->bg_color_secondary, LV_STATE_CHECKED);\n        lv_obj_add_style(obj, &styles->disabled, LV_STATE_DISABLED);\n    }\n#endif\n\n#if LV_USE_LINE\n    else if(lv_obj_check_type(obj, &lv_line_class)) {\n        lv_obj_add_style(obj, &styles->line, 0);\n    }\n#endif\n\n#if LV_USE_BTNMATRIX\n    else if(lv_obj_check_type(obj, &lv_btnmatrix_class)) {\n#if LV_USE_MSGBOX\n        if(lv_obj_check_type(lv_obj_get_parent(obj), &lv_msgbox_class)) {\n            lv_obj_add_style(obj, &styles->msgbox_btn_bg, 0);\n            lv_obj_add_style(obj, &styles->pad_gap, 0);\n            lv_obj_add_style(obj, &styles->btn, LV_PART_ITEMS);\n            lv_obj_add_style(obj, &styles->pressed, LV_PART_ITEMS | LV_STATE_PRESSED);\n            lv_obj_add_style(obj, &styles->disabled, LV_PART_ITEMS | LV_STATE_DISABLED);\n            lv_obj_add_style(obj, &styles->bg_color_primary, LV_PART_ITEMS | LV_STATE_CHECKED);\n            lv_obj_add_style(obj, &styles->bg_color_primary_muted, LV_PART_ITEMS | LV_STATE_FOCUS_KEY);\n            lv_obj_add_style(obj, &styles->bg_color_secondary_muted, LV_PART_ITEMS | LV_STATE_EDITED);\n            return;\n        }\n#endif\n#if LV_USE_TABVIEW\n        if(lv_obj_check_type(lv_obj_get_parent(obj), &lv_tabview_class)) {\n            lv_obj_add_style(obj, &styles->bg_color_white, 0);\n            lv_obj_add_style(obj, &styles->outline_primary, LV_STATE_FOCUS_KEY);\n            lv_obj_add_style(obj, &styles->tab_bg_focus, LV_STATE_FOCUS_KEY);\n            lv_obj_add_style(obj, &styles->pressed, LV_PART_ITEMS | LV_STATE_PRESSED);\n            lv_obj_add_style(obj, &styles->bg_color_primary_muted, LV_PART_ITEMS | LV_STATE_CHECKED);\n            lv_obj_add_style(obj, &styles->tab_btn, LV_PART_ITEMS | LV_STATE_CHECKED);\n            lv_obj_add_style(obj, &styles->outline_primary, LV_PART_ITEMS | LV_STATE_FOCUS_KEY);\n            lv_obj_add_style(obj, &styles->outline_secondary, LV_PART_ITEMS | LV_STATE_EDITED);\n            lv_obj_add_style(obj, &styles->tab_bg_focus, LV_PART_ITEMS | LV_STATE_FOCUS_KEY);\n            return;\n        }\n#endif\n\n#if LV_USE_CALENDAR\n        if(lv_obj_check_type(lv_obj_get_parent(obj), &lv_calendar_class)) {\n            lv_obj_add_style(obj, &styles->calendar_btnm_bg, 0);\n            lv_obj_add_style(obj, &styles->outline_primary, LV_STATE_FOCUS_KEY);\n            lv_obj_add_style(obj, &styles->outline_secondary, LV_STATE_EDITED);\n            lv_obj_add_style(obj, &styles->calendar_btnm_day, LV_PART_ITEMS);\n            lv_obj_add_style(obj, &styles->pressed, LV_PART_ITEMS | LV_STATE_PRESSED);\n            lv_obj_add_style(obj, &styles->disabled, LV_PART_ITEMS | LV_STATE_DISABLED);\n            lv_obj_add_style(obj, &styles->outline_primary, LV_PART_ITEMS | LV_STATE_FOCUS_KEY);\n            lv_obj_add_style(obj, &styles->outline_secondary, LV_PART_ITEMS | LV_STATE_EDITED);\n            return;\n        }\n#endif\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->outline_primary, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->outline_secondary, LV_STATE_EDITED);\n        lv_obj_add_style(obj, &styles->btn, LV_PART_ITEMS);\n        lv_obj_add_style(obj, &styles->disabled, LV_PART_ITEMS | LV_STATE_DISABLED);\n        lv_obj_add_style(obj, &styles->pressed, LV_PART_ITEMS | LV_STATE_PRESSED);\n        lv_obj_add_style(obj, &styles->bg_color_primary, LV_PART_ITEMS | LV_STATE_CHECKED);\n        lv_obj_add_style(obj, &styles->outline_primary, LV_PART_ITEMS | LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->outline_secondary, LV_PART_ITEMS | LV_STATE_EDITED);\n    }\n#endif\n\n#if LV_USE_BAR\n    else if(lv_obj_check_type(obj, &lv_bar_class)) {\n        lv_obj_add_style(obj, &styles->bg_color_primary_muted, 0);\n        lv_obj_add_style(obj, &styles->circle, 0);\n        lv_obj_add_style(obj, &styles->outline_primary, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->outline_secondary, LV_STATE_EDITED);\n        lv_obj_add_style(obj, &styles->bg_color_primary, LV_PART_INDICATOR);\n        lv_obj_add_style(obj, &styles->circle, LV_PART_INDICATOR);\n    }\n#endif\n\n#if LV_USE_SLIDER\n    else if(lv_obj_check_type(obj, &lv_slider_class)) {\n        lv_obj_add_style(obj, &styles->bg_color_primary_muted, 0);\n        lv_obj_add_style(obj, &styles->circle, 0);\n        lv_obj_add_style(obj, &styles->outline_primary, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->outline_secondary, LV_STATE_EDITED);\n        lv_obj_add_style(obj, &styles->bg_color_primary, LV_PART_INDICATOR);\n        lv_obj_add_style(obj, &styles->circle, LV_PART_INDICATOR);\n        lv_obj_add_style(obj, &styles->knob, LV_PART_KNOB);\n#if LV_THEME_DEFAULT_GROW\n        lv_obj_add_style(obj, &styles->grow, LV_PART_KNOB | LV_STATE_PRESSED);\n#endif\n        lv_obj_add_style(obj, &styles->transition_delayed, LV_PART_KNOB);\n        lv_obj_add_style(obj, &styles->transition_normal, LV_PART_KNOB | LV_STATE_PRESSED);\n    }\n#endif\n\n#if LV_USE_TABLE\n    else if(lv_obj_check_type(obj, &lv_table_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->pad_zero, 0);\n        lv_obj_add_style(obj, &styles->no_radius, 0);\n        lv_obj_add_style(obj, &styles->outline_primary, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->outline_secondary, LV_STATE_EDITED);\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n        lv_obj_add_style(obj, &styles->scrollbar_scrolled, LV_PART_SCROLLBAR | LV_STATE_SCROLLED);\n        lv_obj_add_style(obj, &styles->bg_color_white, LV_PART_ITEMS);\n        lv_obj_add_style(obj, &styles->table_cell, LV_PART_ITEMS);\n        lv_obj_add_style(obj, &styles->pad_normal, LV_PART_ITEMS);\n        lv_obj_add_style(obj, &styles->pressed, LV_PART_ITEMS | LV_STATE_PRESSED);\n        lv_obj_add_style(obj, &styles->bg_color_primary, LV_PART_ITEMS | LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->bg_color_secondary, LV_PART_ITEMS | LV_STATE_EDITED);\n    }\n#endif\n\n#if LV_USE_CHECKBOX\n    else if(lv_obj_check_type(obj, &lv_checkbox_class)) {\n        lv_obj_add_style(obj, &styles->pad_gap, 0);\n        lv_obj_add_style(obj, &styles->outline_primary, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->disabled, LV_PART_INDICATOR | LV_STATE_DISABLED);\n        lv_obj_add_style(obj, &styles->cb_marker, LV_PART_INDICATOR);\n        lv_obj_add_style(obj, &styles->bg_color_primary, LV_PART_INDICATOR | LV_STATE_CHECKED);\n        lv_obj_add_style(obj, &styles->cb_marker_checked, LV_PART_INDICATOR | LV_STATE_CHECKED);\n        lv_obj_add_style(obj, &styles->pressed, LV_PART_INDICATOR | LV_STATE_PRESSED);\n#if LV_THEME_DEFAULT_GROW\n        lv_obj_add_style(obj, &styles->grow, LV_PART_INDICATOR | LV_STATE_PRESSED);\n#endif\n        lv_obj_add_style(obj, &styles->transition_normal, LV_PART_INDICATOR | LV_STATE_PRESSED);\n        lv_obj_add_style(obj, &styles->transition_delayed, LV_PART_INDICATOR);\n    }\n#endif\n\n#if LV_USE_SWITCH\n    else if(lv_obj_check_type(obj, &lv_switch_class)) {\n        lv_obj_add_style(obj, &styles->bg_color_grey, 0);\n        lv_obj_add_style(obj, &styles->circle, 0);\n        lv_obj_add_style(obj, &styles->anim_fast, 0);\n        lv_obj_add_style(obj, &styles->disabled, LV_STATE_DISABLED);\n        lv_obj_add_style(obj, &styles->outline_primary, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->bg_color_primary, LV_PART_INDICATOR | LV_STATE_CHECKED);\n        lv_obj_add_style(obj, &styles->circle, LV_PART_INDICATOR);\n        lv_obj_add_style(obj, &styles->disabled, LV_PART_INDICATOR | LV_STATE_DISABLED);\n        lv_obj_add_style(obj, &styles->knob, LV_PART_KNOB);\n        lv_obj_add_style(obj, &styles->bg_color_white, LV_PART_KNOB);\n        lv_obj_add_style(obj, &styles->switch_knob, LV_PART_KNOB);\n        lv_obj_add_style(obj, &styles->disabled, LV_PART_KNOB | LV_STATE_DISABLED);\n\n        lv_obj_add_style(obj, &styles->transition_normal, LV_PART_INDICATOR | LV_STATE_CHECKED);\n        lv_obj_add_style(obj, &styles->transition_normal, LV_PART_INDICATOR);\n    }\n#endif\n\n#if LV_USE_CHART\n    else if(lv_obj_check_type(obj, &lv_chart_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->pad_small, 0);\n        lv_obj_add_style(obj, &styles->chart_bg, 0);\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n        lv_obj_add_style(obj, &styles->scrollbar_scrolled, LV_PART_SCROLLBAR | LV_STATE_SCROLLED);\n        lv_obj_add_style(obj, &styles->chart_series, LV_PART_ITEMS);\n        lv_obj_add_style(obj, &styles->chart_indic, LV_PART_INDICATOR);\n        lv_obj_add_style(obj, &styles->chart_ticks, LV_PART_TICKS);\n        lv_obj_add_style(obj, &styles->chart_series, LV_PART_CURSOR);\n    }\n#endif\n\n#if LV_USE_ROLLER\n    else if(lv_obj_check_type(obj, &lv_roller_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->anim, 0);\n        lv_obj_add_style(obj, &styles->line_space_large, 0);\n        lv_obj_add_style(obj, &styles->text_align_center, 0);\n        lv_obj_add_style(obj, &styles->outline_primary, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->outline_secondary, LV_STATE_EDITED);\n        lv_obj_add_style(obj, &styles->bg_color_primary, LV_PART_SELECTED);\n    }\n#endif\n\n#if LV_USE_DROPDOWN\n    else if(lv_obj_check_type(obj, &lv_dropdown_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->pad_small, 0);\n        lv_obj_add_style(obj, &styles->transition_delayed, 0);\n        lv_obj_add_style(obj, &styles->transition_normal, LV_STATE_PRESSED);\n        lv_obj_add_style(obj, &styles->pressed, LV_STATE_PRESSED);\n        lv_obj_add_style(obj, &styles->outline_primary, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->outline_secondary, LV_STATE_EDITED);\n        lv_obj_add_style(obj, &styles->transition_normal, LV_PART_INDICATOR);\n    }\n    else if(lv_obj_check_type(obj, &lv_dropdownlist_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->clip_corner, 0);\n        lv_obj_add_style(obj, &styles->line_space_large, 0);\n        lv_obj_add_style(obj, &styles->dropdown_list, 0);\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n        lv_obj_add_style(obj, &styles->scrollbar_scrolled, LV_PART_SCROLLBAR | LV_STATE_SCROLLED);\n        lv_obj_add_style(obj, &styles->bg_color_white, LV_PART_SELECTED);\n        lv_obj_add_style(obj, &styles->bg_color_primary, LV_PART_SELECTED | LV_STATE_CHECKED);\n        lv_obj_add_style(obj, &styles->pressed, LV_PART_SELECTED | LV_STATE_PRESSED);\n    }\n#endif\n\n#if LV_USE_ARC\n    else if(lv_obj_check_type(obj, &lv_arc_class)) {\n        lv_obj_add_style(obj, &styles->arc_indic, 0);\n        lv_obj_add_style(obj, &styles->arc_indic, LV_PART_INDICATOR);\n        lv_obj_add_style(obj, &styles->arc_indic_primary, LV_PART_INDICATOR);\n        lv_obj_add_style(obj, &styles->knob, LV_PART_KNOB);\n    }\n#endif\n\n\n#if LV_USE_SPINNER\n    else if(lv_obj_check_type(obj, &lv_spinner_class)) {\n        lv_obj_add_style(obj, &styles->arc_indic, 0);\n        lv_obj_add_style(obj, &styles->arc_indic, LV_PART_INDICATOR);\n        lv_obj_add_style(obj, &styles->arc_indic_primary, LV_PART_INDICATOR);\n    }\n#endif\n\n#if LV_USE_METER\n    else if(lv_obj_check_type(obj, &lv_meter_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->circle, 0);\n        lv_obj_add_style(obj, &styles->meter_indic, LV_PART_INDICATOR);\n    }\n#endif\n\n#if LV_USE_TEXTAREA\n    else if(lv_obj_check_type(obj, &lv_textarea_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->pad_small, 0);\n        lv_obj_add_style(obj, &styles->outline_primary, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->outline_secondary, LV_STATE_EDITED);\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n        lv_obj_add_style(obj, &styles->scrollbar_scrolled, LV_PART_SCROLLBAR | LV_STATE_SCROLLED);\n        lv_obj_add_style(obj, &styles->ta_cursor, LV_PART_CURSOR | LV_STATE_FOCUSED);\n        lv_obj_add_style(obj, &styles->ta_placeholder, LV_PART_TEXTAREA_PLACEHOLDER);\n    }\n#endif\n\n#if LV_USE_CALENDAR\n    else if(lv_obj_check_type(obj, &lv_calendar_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->pad_zero, 0);\n    }\n#endif\n\n#if LV_USE_CALENDAR_HEADER_ARROW\n    else if(lv_obj_check_type(obj, &lv_calendar_header_arrow_class)) {\n        lv_obj_add_style(obj, &styles->calendar_header, 0);\n    }\n#endif\n\n#if LV_USE_CALENDAR_HEADER_DROPDOWN\n    else if(lv_obj_check_type(obj, &lv_calendar_header_dropdown_class)) {\n        lv_obj_add_style(obj, &styles->calendar_header, 0);\n    }\n#endif\n\n#if LV_USE_KEYBOARD\n    else if(lv_obj_check_type(obj, &lv_keyboard_class)) {\n        lv_obj_add_style(obj, &styles->scr, 0);\n        lv_obj_add_style(obj, disp_size == DISP_LARGE ? &styles->pad_small : &styles->pad_tiny, 0);\n        lv_obj_add_style(obj, &styles->outline_primary, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->outline_secondary, LV_STATE_EDITED);\n        lv_obj_add_style(obj, &styles->btn, LV_PART_ITEMS);\n        lv_obj_add_style(obj, &styles->disabled, LV_PART_ITEMS | LV_STATE_DISABLED);\n        lv_obj_add_style(obj, &styles->bg_color_white, LV_PART_ITEMS);\n        lv_obj_add_style(obj, &styles->keyboard_btn_bg, LV_PART_ITEMS);\n        lv_obj_add_style(obj, &styles->pressed, LV_PART_ITEMS | LV_STATE_PRESSED);\n        lv_obj_add_style(obj, &styles->bg_color_grey, LV_PART_ITEMS | LV_STATE_CHECKED);\n        lv_obj_add_style(obj, &styles->bg_color_primary_muted, LV_PART_ITEMS | LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->bg_color_secondary_muted, LV_PART_ITEMS | LV_STATE_EDITED);\n    }\n#endif\n#if LV_USE_LIST\n    else if(lv_obj_check_type(obj, &lv_list_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->list_bg, 0);\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n        lv_obj_add_style(obj, &styles->scrollbar_scrolled, LV_PART_SCROLLBAR | LV_STATE_SCROLLED);\n        return;\n    }\n    else if(lv_obj_check_type(obj, &lv_list_text_class)) {\n        lv_obj_add_style(obj, &styles->bg_color_grey, 0);\n        lv_obj_add_style(obj, &styles->list_item_grow, 0);\n    }\n    else if(lv_obj_check_type(obj, &lv_list_btn_class)) {\n        lv_obj_add_style(obj, &styles->bg_color_white, 0);\n        lv_obj_add_style(obj, &styles->list_btn, 0);\n        lv_obj_add_style(obj, &styles->bg_color_primary, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->list_item_grow, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->list_item_grow, LV_STATE_PRESSED);\n        lv_obj_add_style(obj, &styles->pressed, LV_STATE_PRESSED);\n\n    }\n#endif\n#if LV_USE_MSGBOX\n    else if(lv_obj_check_type(obj, &lv_msgbox_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->msgbox_bg, 0);\n        return;\n    }\n    else if(lv_obj_check_type(obj, &lv_msgbox_backdrop_class)) {\n        lv_obj_add_style(obj, &styles->msgbox_backdrop_bg, 0);\n    }\n#endif\n#if LV_USE_SPINBOX\n    else if(lv_obj_check_type(obj, &lv_spinbox_class)) {\n        lv_obj_add_style(obj, &styles->card, 0);\n        lv_obj_add_style(obj, &styles->pad_small, 0);\n        lv_obj_add_style(obj, &styles->outline_primary, LV_STATE_FOCUS_KEY);\n        lv_obj_add_style(obj, &styles->outline_secondary, LV_STATE_EDITED);\n        lv_obj_add_style(obj, &styles->bg_color_primary, LV_PART_CURSOR);\n    }\n#endif\n#if LV_USE_TILEVIEW\n    else if(lv_obj_check_type(obj, &lv_tileview_class)) {\n        lv_obj_add_style(obj, &styles->scr, 0);\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n        lv_obj_add_style(obj, &styles->scrollbar_scrolled, LV_PART_SCROLLBAR | LV_STATE_SCROLLED);\n    }\n    else if(lv_obj_check_type(obj, &lv_tileview_tile_class)) {\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n        lv_obj_add_style(obj, &styles->scrollbar_scrolled, LV_PART_SCROLLBAR | LV_STATE_SCROLLED);\n    }\n#endif\n\n#if LV_USE_TABVIEW\n    else if(lv_obj_check_type(obj, &lv_tabview_class)) {\n        lv_obj_add_style(obj, &styles->scr, 0);\n        lv_obj_add_style(obj, &styles->pad_zero, 0);\n    }\n#endif\n\n#if LV_USE_WIN\n    else if(lv_obj_check_type(obj, &lv_win_class)) {\n        lv_obj_add_style(obj, &styles->clip_corner, 0);\n    }\n#endif\n\n#if LV_USE_COLORWHEEL\n    else if(lv_obj_check_type(obj, &lv_colorwheel_class)) {\n        lv_obj_add_style(obj, &styles->colorwheel_main, 0);\n        lv_obj_add_style(obj, &styles->pad_normal, 0);\n        lv_obj_add_style(obj, &styles->bg_color_white, LV_PART_KNOB);\n        lv_obj_add_style(obj, &styles->pad_normal, LV_PART_KNOB);\n    }\n#endif\n\n#if LV_USE_LED\n    else if(lv_obj_check_type(obj, &lv_led_class)) {\n        lv_obj_add_style(obj, &styles->led, 0);\n    }\n#endif\n}"}, "style_init_reset": {"type": "Function", "def": "static void style_init_reset(lv_style_t * style)", "sline": 1050, "body": "{\n    if(inited) lv_style_reset(style);\n    else lv_style_init(style);\n}"}, "styles": {"type": "Variable", "def": "static my_theme_styles_t * styles", "sline": 168}, "theme": {"type": "Variable", "def": "static lv_theme_t theme", "sline": 169}, "disp_size": {"type": "Variable", "def": "static disp_size_t disp_size", "sline": 170, "rels": [["disp_size_t", null, "Typeof"]]}, "inited": {"type": "Function", "def": "static bool inited", "sline": 171}, "color_scr": {"type": "Variable", "def": "static lv_color_t color_scr", "sline": 172}, "color_text": {"type": "Variable", "def": "static lv_color_t color_text", "sline": 173}, "color_card": {"type": "Variable", "def": "static lv_color_t color_card", "sline": 174}, "color_grey": {"type": "Variable", "def": "static lv_color_t color_grey", "sline": 175}, "dark_color_filter_cb": {"type": "Function", "def": "static lv_color_t dark_color_filter_cb(const lv_color_filter_dsc_t * f, lv_color_t c, lv_opa_t opa)", "sline": 187, "body": "{\n    LV_UNUSED(f);\n    return lv_color_darken(c, opa);\n}"}, "grey_filter_cb": {"type": "Function", "def": "static lv_color_t grey_filter_cb(const lv_color_filter_dsc_t * f, lv_color_t color, lv_opa_t opa)", "sline": 193, "body": "{\n    LV_UNUSED(f);\n    if(theme.flags & MODE_DARK) return lv_color_mix(lv_palette_darken(LV_PALETTE_GREY, 2), color, opa);\n    else return lv_color_mix(lv_palette_lighten(LV_PALETTE_GREY, 2), color, opa);\n}"}, "style_init": {"type": "Function", "def": "static void style_init(void)", "sline": 200, "body": "{\n    static const lv_style_prop_t trans_props[] = {\n        LV_STYLE_BG_OPA, LV_STYLE_BG_COLOR,\n        LV_STYLE_TRANSFORM_WIDTH, LV_STYLE_TRANSFORM_HEIGHT,\n        LV_STYLE_TRANSLATE_Y, LV_STYLE_TRANSLATE_X,\n        LV_STYLE_TRANSFORM_ZOOM, LV_STYLE_TRANSFORM_ANGLE,\n        LV_STYLE_COLOR_FILTER_OPA, LV_STYLE_COLOR_FILTER_DSC,\n        0\n    };\n\n    color_scr = theme.flags & MODE_DARK ? DARK_COLOR_SCR : LIGHT_COLOR_SCR;\n    color_text = theme.flags & MODE_DARK ? DARK_COLOR_TEXT : LIGHT_COLOR_TEXT;\n    color_card = theme.flags & MODE_DARK ? DARK_COLOR_CARD : LIGHT_COLOR_CARD;\n    color_grey = theme.flags & MODE_DARK ? DARK_COLOR_GREY : LIGHT_COLOR_GREY;\n\n    static lv_style_transition_dsc_t trans_delayed;\n    lv_style_transition_dsc_init(&trans_delayed, trans_props, lv_anim_path_linear, TRANSITION_TIME, 70, NULL);\n\n    static lv_style_transition_dsc_t trans_normal;\n    lv_style_transition_dsc_init(&trans_normal, trans_props, lv_anim_path_linear, TRANSITION_TIME, 0, NULL);\n\n    style_init_reset(&styles->transition_delayed);\n    lv_style_set_transition(&styles->transition_delayed, &trans_delayed); /*Go back to default state with delay*/\n\n    style_init_reset(&styles->transition_normal);\n    lv_style_set_transition(&styles->transition_normal, &trans_normal); /*Go back to default state with delay*/\n\n    style_init_reset(&styles->scrollbar);\n    lv_style_set_bg_color(&styles->scrollbar, (theme.flags & MODE_DARK) ? lv_palette_darken(LV_PALETTE_GREY,\n                                                                                            2) : lv_palette_main(LV_PALETTE_GREY));\n    lv_style_set_radius(&styles->scrollbar, LV_RADIUS_CIRCLE);\n    lv_style_set_pad_right(&styles->scrollbar, lv_disp_dpx(theme.disp, 7));\n    lv_style_set_pad_top(&styles->scrollbar,  lv_disp_dpx(theme.disp, 7));\n    lv_style_set_size(&styles->scrollbar,  lv_disp_dpx(theme.disp, 5));\n    lv_style_set_bg_opa(&styles->scrollbar,  LV_OPA_40);\n    lv_style_set_transition(&styles->scrollbar, &trans_normal);\n\n    style_init_reset(&styles->scrollbar_scrolled);\n    lv_style_set_bg_opa(&styles->scrollbar_scrolled,  LV_OPA_COVER);\n\n    style_init_reset(&styles->scr);\n    lv_style_set_bg_opa(&styles->scr, LV_OPA_COVER);\n    lv_style_set_bg_color(&styles->scr, color_scr);\n    lv_style_set_text_color(&styles->scr, color_text);\n    lv_style_set_pad_row(&styles->scr, PAD_SMALL);\n    lv_style_set_pad_column(&styles->scr, PAD_SMALL);\n\n    style_init_reset(&styles->card);\n    lv_style_set_radius(&styles->card, RADIUS_DEFAULT);\n    lv_style_set_bg_opa(&styles->card, LV_OPA_COVER);\n    lv_style_set_bg_color(&styles->card, color_card);\n    lv_style_set_border_color(&styles->card, color_grey);\n    lv_style_set_border_width(&styles->card, BORDER_WIDTH);\n    lv_style_set_border_post(&styles->card, true);\n    lv_style_set_text_color(&styles->card, color_text);\n    lv_style_set_pad_all(&styles->card, PAD_DEF);\n    lv_style_set_pad_row(&styles->card, PAD_SMALL);\n    lv_style_set_pad_column(&styles->card, PAD_SMALL);\n    lv_style_set_line_color(&styles->card, lv_palette_main(LV_PALETTE_GREY));\n    lv_style_set_line_width(&styles->card, lv_disp_dpx(theme.disp, 1));\n\n    style_init_reset(&styles->outline_primary);\n    lv_style_set_outline_color(&styles->outline_primary, theme.color_primary);\n    lv_style_set_outline_width(&styles->outline_primary, OUTLINE_WIDTH);\n    lv_style_set_outline_pad(&styles->outline_primary, OUTLINE_WIDTH);\n    lv_style_set_outline_opa(&styles->outline_primary, LV_OPA_50);\n\n    style_init_reset(&styles->outline_secondary);\n    lv_style_set_outline_color(&styles->outline_secondary, theme.color_secondary);\n    lv_style_set_outline_width(&styles->outline_secondary, OUTLINE_WIDTH);\n    lv_style_set_outline_opa(&styles->outline_secondary, LV_OPA_50);\n\n    style_init_reset(&styles->btn);\n    lv_style_set_radius(&styles->btn, (disp_size == DISP_LARGE ? lv_disp_dpx(theme.disp,\n                                                                             16) : disp_size == DISP_MEDIUM ? lv_disp_dpx(theme.disp, 12) : lv_disp_dpx(theme.disp, 8)));\n    lv_style_set_bg_opa(&styles->btn, LV_OPA_COVER);\n    lv_style_set_bg_color(&styles->btn, color_grey);\n    if(!(theme.flags & MODE_DARK)) {\n        lv_style_set_shadow_color(&styles->btn, lv_palette_main(LV_PALETTE_GREY));\n        lv_style_set_shadow_width(&styles->btn, LV_DPX(3));\n        lv_style_set_shadow_opa(&styles->btn, LV_OPA_50);\n        lv_style_set_shadow_ofs_y(&styles->btn, lv_disp_dpx(theme.disp, LV_DPX(4)));\n    }\n    lv_style_set_text_color(&styles->btn, color_text);\n    lv_style_set_pad_hor(&styles->btn, PAD_DEF);\n    lv_style_set_pad_ver(&styles->btn, PAD_SMALL);\n    lv_style_set_pad_column(&styles->btn, lv_disp_dpx(theme.disp, 5));\n    lv_style_set_pad_row(&styles->btn, lv_disp_dpx(theme.disp, 5));\n\n    static lv_color_filter_dsc_t dark_filter;\n    lv_color_filter_dsc_init(&dark_filter, dark_color_filter_cb);\n\n    static lv_color_filter_dsc_t grey_filter;\n    lv_color_filter_dsc_init(&grey_filter, grey_filter_cb);\n\n    style_init_reset(&styles->pressed);\n    lv_style_set_color_filter_dsc(&styles->pressed, &dark_filter);\n    lv_style_set_color_filter_opa(&styles->pressed, 35);\n\n    style_init_reset(&styles->disabled);\n    lv_style_set_color_filter_dsc(&styles->disabled, &grey_filter);\n    lv_style_set_color_filter_opa(&styles->disabled, LV_OPA_50);\n\n    style_init_reset(&styles->clip_corner);\n    lv_style_set_clip_corner(&styles->clip_corner, true);\n    lv_style_set_border_post(&styles->clip_corner, true);\n\n    style_init_reset(&styles->pad_normal);\n    lv_style_set_pad_all(&styles->pad_normal, PAD_DEF);\n    lv_style_set_pad_row(&styles->pad_normal, PAD_DEF);\n    lv_style_set_pad_column(&styles->pad_normal, PAD_DEF);\n\n    style_init_reset(&styles->pad_small);\n    lv_style_set_pad_all(&styles->pad_small, PAD_SMALL);\n    lv_style_set_pad_gap(&styles->pad_small, PAD_SMALL);\n\n    style_init_reset(&styles->pad_gap);\n    lv_style_set_pad_row(&styles->pad_gap, lv_disp_dpx(theme.disp, 10));\n    lv_style_set_pad_column(&styles->pad_gap, lv_disp_dpx(theme.disp, 10));\n\n    style_init_reset(&styles->line_space_large);\n    lv_style_set_text_line_space(&styles->line_space_large, lv_disp_dpx(theme.disp, 20));\n\n    style_init_reset(&styles->text_align_center);\n    lv_style_set_text_align(&styles->text_align_center, LV_TEXT_ALIGN_CENTER);\n\n    style_init_reset(&styles->pad_zero);\n    lv_style_set_pad_all(&styles->pad_zero, 0);\n    lv_style_set_pad_row(&styles->pad_zero, 0);\n    lv_style_set_pad_column(&styles->pad_zero, 0);\n\n    style_init_reset(&styles->pad_tiny);\n    lv_style_set_pad_all(&styles->pad_tiny, PAD_TINY);\n    lv_style_set_pad_row(&styles->pad_tiny, PAD_TINY);\n    lv_style_set_pad_column(&styles->pad_tiny, PAD_TINY);\n\n    style_init_reset(&styles->bg_color_primary);\n    lv_style_set_bg_color(&styles->bg_color_primary, theme.color_primary);\n    lv_style_set_text_color(&styles->bg_color_primary, lv_color_white());\n    lv_style_set_bg_opa(&styles->bg_color_primary, LV_OPA_COVER);\n\n    style_init_reset(&styles->bg_color_primary_muted);\n    lv_style_set_bg_color(&styles->bg_color_primary_muted, theme.color_primary);\n    lv_style_set_text_color(&styles->bg_color_primary_muted, theme.color_primary);\n    lv_style_set_bg_opa(&styles->bg_color_primary_muted, LV_OPA_20);\n\n    style_init_reset(&styles->bg_color_secondary);\n    lv_style_set_bg_color(&styles->bg_color_secondary, theme.color_secondary);\n    lv_style_set_text_color(&styles->bg_color_secondary, lv_color_white());\n    lv_style_set_bg_opa(&styles->bg_color_secondary, LV_OPA_COVER);\n\n    style_init_reset(&styles->bg_color_secondary_muted);\n    lv_style_set_bg_color(&styles->bg_color_secondary_muted, theme.color_secondary);\n    lv_style_set_text_color(&styles->bg_color_secondary_muted, theme.color_secondary);\n    lv_style_set_bg_opa(&styles->bg_color_secondary_muted, LV_OPA_20);\n\n    style_init_reset(&styles->bg_color_grey);\n    lv_style_set_bg_color(&styles->bg_color_grey, color_grey);\n    lv_style_set_bg_opa(&styles->bg_color_grey, LV_OPA_COVER);\n    lv_style_set_text_color(&styles->bg_color_grey, color_text);\n\n    style_init_reset(&styles->bg_color_white);\n    lv_style_set_bg_color(&styles->bg_color_white, color_card);\n    lv_style_set_bg_opa(&styles->bg_color_white, LV_OPA_COVER);\n    lv_style_set_text_color(&styles->bg_color_white, color_text);\n\n    style_init_reset(&styles->circle);\n    lv_style_set_radius(&styles->circle, LV_RADIUS_CIRCLE);\n\n    style_init_reset(&styles->no_radius);\n    lv_style_set_radius(&styles->no_radius, 0);\n\n#if LV_THEME_DEFAULT_GROW\n    style_init_reset(&styles->grow);\n    lv_style_set_transform_width(&styles->grow, lv_disp_dpx(theme.disp, 3));\n    lv_style_set_transform_height(&styles->grow, lv_disp_dpx(theme.disp, 3));\n#endif\n\n    style_init_reset(&styles->knob);\n    lv_style_set_bg_color(&styles->knob, theme.color_primary);\n    lv_style_set_bg_opa(&styles->knob, LV_OPA_COVER);\n    lv_style_set_pad_all(&styles->knob, lv_disp_dpx(theme.disp, 6));\n    lv_style_set_radius(&styles->knob, LV_RADIUS_CIRCLE);\n\n    style_init_reset(&styles->anim);\n    lv_style_set_anim_time(&styles->anim, 200);\n\n    style_init_reset(&styles->anim_fast);\n    lv_style_set_anim_time(&styles->anim_fast, 120);\n\n#if LV_USE_ARC\n    style_init_reset(&styles->arc_indic);\n    lv_style_set_arc_color(&styles->arc_indic, color_grey);\n    lv_style_set_arc_width(&styles->arc_indic, lv_disp_dpx(theme.disp, 15));\n    lv_style_set_arc_rounded(&styles->arc_indic, true);\n\n    style_init_reset(&styles->arc_indic_primary);\n    lv_style_set_arc_color(&styles->arc_indic_primary, theme.color_primary);\n#endif\n\n#if LV_USE_DROPDOWN\n    style_init_reset(&styles->dropdown_list);\n    lv_style_set_max_height(&styles->dropdown_list, LV_DPI_DEF * 2);\n#endif\n#if LV_USE_CHECKBOX\n    style_init_reset(&styles->cb_marker);\n    lv_style_set_pad_all(&styles->cb_marker, lv_disp_dpx(theme.disp, 3));\n    lv_style_set_border_width(&styles->cb_marker, BORDER_WIDTH);\n    lv_style_set_border_color(&styles->cb_marker, theme.color_primary);\n    lv_style_set_bg_color(&styles->cb_marker, color_card);\n    lv_style_set_bg_opa(&styles->cb_marker, LV_OPA_COVER);\n    lv_style_set_radius(&styles->cb_marker, RADIUS_DEFAULT / 2);\n\n    style_init_reset(&styles->cb_marker_checked);\n    lv_style_set_bg_img_src(&styles->cb_marker_checked, LV_SYMBOL_OK);\n    lv_style_set_text_color(&styles->cb_marker_checked, lv_color_white());\n    lv_style_set_text_font(&styles->cb_marker_checked, theme.font_small);\n#endif\n\n#if LV_USE_SWITCH\n    style_init_reset(&styles->switch_knob);\n    lv_style_set_pad_all(&styles->switch_knob, - lv_disp_dpx(theme.disp, 4));\n    lv_style_set_bg_color(&styles->switch_knob, lv_color_white());\n#endif\n\n#if LV_USE_LINE\n    style_init_reset(&styles->line);\n    lv_style_set_line_width(&styles->line, 1);\n    lv_style_set_line_color(&styles->line, color_text);\n#endif\n\n#if LV_USE_CHART\n    style_init_reset(&styles->chart_bg);\n    lv_style_set_border_post(&styles->chart_bg, false);\n    lv_style_set_pad_column(&styles->chart_bg, lv_disp_dpx(theme.disp, 10));\n    lv_style_set_line_color(&styles->chart_bg, color_grey);\n\n    style_init_reset(&styles->chart_series);\n    lv_style_set_line_width(&styles->chart_series, lv_disp_dpx(theme.disp, 3));\n    lv_style_set_radius(&styles->chart_series, lv_disp_dpx(theme.disp, 3));\n    lv_style_set_size(&styles->chart_series, lv_disp_dpx(theme.disp, 8));\n    lv_style_set_pad_column(&styles->chart_series, lv_disp_dpx(theme.disp, 2));\n\n    style_init_reset(&styles->chart_indic);\n    lv_style_set_radius(&styles->chart_indic, LV_RADIUS_CIRCLE);\n    lv_style_set_size(&styles->chart_indic, lv_disp_dpx(theme.disp, 8));\n    lv_style_set_bg_color(&styles->chart_indic, theme.color_primary);\n    lv_style_set_bg_opa(&styles->chart_indic, LV_OPA_COVER);\n\n    style_init_reset(&styles->chart_ticks);\n    lv_style_set_line_width(&styles->chart_ticks, lv_disp_dpx(theme.disp, 1));\n    lv_style_set_line_color(&styles->chart_ticks, color_text);\n    lv_style_set_pad_all(&styles->chart_ticks, lv_disp_dpx(theme.disp, 2));\n    lv_style_set_text_color(&styles->chart_ticks, lv_palette_main(LV_PALETTE_GREY));\n#endif\n\n#if LV_USE_METER\n    style_init_reset(&styles->meter_marker);\n    lv_style_set_line_width(&styles->meter_marker, lv_disp_dpx(theme.disp, 5));\n    lv_style_set_line_color(&styles->meter_marker, color_text);\n    lv_style_set_size(&styles->meter_marker, lv_disp_dpx(theme.disp, 20));\n    lv_style_set_pad_left(&styles->meter_marker, lv_disp_dpx(theme.disp, 15));\n\n    style_init_reset(&styles->meter_indic);\n    lv_style_set_radius(&styles->meter_indic, LV_RADIUS_CIRCLE);\n    lv_style_set_bg_color(&styles->meter_indic, color_text);\n    lv_style_set_bg_opa(&styles->meter_indic, LV_OPA_COVER);\n    lv_style_set_size(&styles->meter_indic, lv_disp_dpx(theme.disp, 15));\n#endif\n\n#if LV_USE_TABLE\n    style_init_reset(&styles->table_cell);\n    lv_style_set_border_width(&styles->table_cell, lv_disp_dpx(theme.disp, 1));\n    lv_style_set_border_color(&styles->table_cell, color_grey);\n    lv_style_set_border_side(&styles->table_cell, LV_BORDER_SIDE_TOP | LV_BORDER_SIDE_BOTTOM);\n#endif\n\n#if LV_USE_TEXTAREA\n    style_init_reset(&styles->ta_cursor);\n    lv_style_set_border_color(&styles->ta_cursor, color_text);\n    lv_style_set_border_width(&styles->ta_cursor, lv_disp_dpx(theme.disp, 2));\n    lv_style_set_pad_left(&styles->ta_cursor, - lv_disp_dpx(theme.disp, 1));\n    lv_style_set_border_side(&styles->ta_cursor, LV_BORDER_SIDE_LEFT);\n    lv_style_set_anim_time(&styles->ta_cursor, 400);\n\n    style_init_reset(&styles->ta_placeholder);\n    lv_style_set_text_color(&styles->ta_placeholder, (theme.flags & MODE_DARK) ? lv_palette_darken(LV_PALETTE_GREY,\n                                                                                                   2) : lv_palette_lighten(LV_PALETTE_GREY, 1));\n#endif\n\n#if LV_USE_CALENDAR\n    style_init_reset(&styles->calendar_btnm_bg);\n    lv_style_set_pad_all(&styles->calendar_btnm_bg, PAD_SMALL);\n    lv_style_set_pad_gap(&styles->calendar_btnm_bg, PAD_SMALL / 2);\n\n    style_init_reset(&styles->calendar_btnm_day);\n    lv_style_set_border_width(&styles->calendar_btnm_day, lv_disp_dpx(theme.disp, 1));\n    lv_style_set_border_color(&styles->calendar_btnm_day, color_grey);\n    lv_style_set_bg_color(&styles->calendar_btnm_day, color_card);\n    lv_style_set_bg_opa(&styles->calendar_btnm_day, LV_OPA_20);\n\n    style_init_reset(&styles->calendar_header);\n    lv_style_set_pad_hor(&styles->calendar_header, PAD_SMALL);\n    lv_style_set_pad_top(&styles->calendar_header, PAD_SMALL);\n    lv_style_set_pad_bottom(&styles->calendar_header, PAD_TINY);\n    lv_style_set_pad_gap(&styles->calendar_header, PAD_SMALL);\n#endif\n\n#if LV_USE_COLORWHEEL\n    style_init_reset(&styles->colorwheel_main);\n    lv_style_set_arc_width(&styles->colorwheel_main, lv_disp_dpx(theme.disp, 10));\n#endif\n\n#if LV_USE_MSGBOX\n    /*To add space for for the button shadow*/\n    style_init_reset(&styles->msgbox_btn_bg);\n    lv_style_set_pad_all(&styles->msgbox_btn_bg, lv_disp_dpx(theme.disp, 4));\n\n    style_init_reset(&styles->msgbox_bg);\n    lv_style_set_max_width(&styles->msgbox_bg, lv_pct(100));\n\n    style_init_reset(&styles->msgbox_backdrop_bg);\n    lv_style_set_bg_color(&styles->msgbox_backdrop_bg, lv_palette_main(LV_PALETTE_GREY));\n    lv_style_set_bg_opa(&styles->msgbox_backdrop_bg, LV_OPA_50);\n#endif\n#if LV_USE_KEYBOARD\n    style_init_reset(&styles->keyboard_btn_bg);\n    lv_style_set_shadow_width(&styles->keyboard_btn_bg, 0);\n    lv_style_set_radius(&styles->keyboard_btn_bg, disp_size == DISP_SMALL ? RADIUS_DEFAULT / 2 : RADIUS_DEFAULT);\n#endif\n\n#if LV_USE_TABVIEW\n    style_init_reset(&styles->tab_btn);\n    lv_style_set_border_color(&styles->tab_btn, theme.color_primary);\n    lv_style_set_border_width(&styles->tab_btn, BORDER_WIDTH * 2);\n    lv_style_set_border_side(&styles->tab_btn, LV_BORDER_SIDE_BOTTOM);\n\n    style_init_reset(&styles->tab_bg_focus);\n    lv_style_set_outline_pad(&styles->tab_bg_focus, -BORDER_WIDTH);\n#endif\n\n#if LV_USE_LIST\n    style_init_reset(&styles->list_bg);\n    lv_style_set_pad_hor(&styles->list_bg, PAD_DEF);\n    lv_style_set_pad_ver(&styles->list_bg, 0);\n    lv_style_set_pad_gap(&styles->list_bg, 0);\n    lv_style_set_clip_corner(&styles->list_bg, true);\n\n    style_init_reset(&styles->list_btn);\n    lv_style_set_border_width(&styles->list_btn, lv_disp_dpx(theme.disp, 1));\n    lv_style_set_border_color(&styles->list_btn, color_grey);\n    lv_style_set_border_side(&styles->list_btn, LV_BORDER_SIDE_BOTTOM);\n    lv_style_set_pad_all(&styles->list_btn, PAD_SMALL);\n    lv_style_set_pad_column(&styles->list_btn, PAD_SMALL);\n\n    style_init_reset(&styles->list_item_grow);\n    lv_style_set_transform_width(&styles->list_item_grow, PAD_DEF);\n#endif\n\n\n#if LV_USE_LED\n    style_init_reset(&styles->led);\n    lv_style_set_bg_opa(&styles->led, LV_OPA_COVER);\n    lv_style_set_bg_color(&styles->led, lv_color_white());\n    lv_style_set_bg_grad_color(&styles->led, lv_palette_main(LV_PALETTE_GREY));\n    lv_style_set_radius(&styles->led, LV_RADIUS_CIRCLE);\n    lv_style_set_shadow_width(&styles->led, lv_disp_dpx(theme.disp, 15));\n    lv_style_set_shadow_color(&styles->led, lv_color_white());\n    lv_style_set_shadow_spread(&styles->led, lv_disp_dpx(theme.disp, 5));\n#endif\n}"}, "lv_theme_default_init": {"type": "Function", "def": "lv_theme_t * lv_theme_default_init(lv_disp_t * disp, lv_color_t color_primary, lv_color_t color_secondary, bool dark,\n                                   const lv_font_t * font)", "sline": 577, "body": "{\n\n    /*This trick is required only to avoid the garbage collection of\n     *styles' data if LVGL is used in a binding (e.g. Micropython)\n     *In a general case styles could be in simple `static lv_style_t my_style...` variables*/\n    if(!inited) {\n        LV_GC_ROOT(_lv_theme_default_styles) = lv_mem_alloc(sizeof(my_theme_styles_t));\n        styles = (my_theme_styles_t *)LV_GC_ROOT(_lv_theme_default_styles);\n    }\n\n    if(LV_HOR_RES <= 320) disp_size = DISP_SMALL;\n    else if(LV_HOR_RES < 720) disp_size = DISP_MEDIUM;\n    else disp_size = DISP_LARGE;\n\n    theme.disp = disp;\n    theme.color_primary = color_primary;\n    theme.color_secondary = color_secondary;\n    theme.font_small = font;\n    theme.font_normal = font;\n    theme.font_large = font;\n    theme.apply_cb = theme_apply;\n    theme.flags = dark ? MODE_DARK : 0;\n\n    style_init();\n\n    inited = true;\n\n    if(disp == NULL || lv_disp_get_theme(disp) == &theme) lv_obj_report_style_change(NULL);\n\n    return (lv_theme_t *)&theme;\n}"}, "lv_theme_default_get": {"type": "Function", "def": "lv_theme_t * lv_theme_default_get(void)", "sline": 611, "body": "{\n    if(!inited) return NULL;\n\n    return (lv_theme_t *)&theme;\n}"}, "lv_theme_default_is_inited": {"type": "Function", "def": "bool lv_theme_default_is_inited(void)", "sline": 618, "body": "{\n    return inited;\n}"}, "carbit_updater/lvgl/src/extra/themes/default/lv_theme_default.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/themes/default/lv_theme_default.c"}}, "carbit_updater/lvgl/src/draw/lv_img_buf.h": {"stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 16}, "lv_color": {"type": "Variable", "def": "#include ../misc/lv_color.h", "sline": 17}, "lv_area": {"type": "Variable", "def": "#include ../misc/lv_area.h", "sline": 18}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_img_buf.h:56:1)": {"type": "Enum", "def": "enum {\n    LV_IMG_CF_UNKNOWN = 0,\n\n    LV_IMG_CF_RAW,              /**< Contains the file as it is. Needs custom decoder function*/\n    LV_IMG_CF_RAW_ALPHA,        /**< Contains the file as it is. The image has alpha. Needs custom decoder\n                                   function*/\n    LV_IMG_CF_RAW_CHROMA_KEYED, /**< Contains the file as it is. The image is chroma keyed. Needs\n                                   custom decoder function*/\n\n    LV_IMG_CF_TRUE_COLOR,              /**< Color format and depth should match with LV_COLOR settings*/\n    LV_IMG_CF_TRUE_COLOR_ALPHA,        /**< Same as `LV_IMG_CF_TRUE_COLOR` but every pixel has an alpha byte*/\n    LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED, /**< Same as `LV_IMG_CF_TRUE_COLOR` but LV_COLOR_TRANSP pixels\n                                          will be transparent*/\n\n    LV_IMG_CF_INDEXED_1BIT, /**< Can have 2 different colors in a palette (always chroma keyed)*/\n    LV_IMG_CF_INDEXED_2BIT, /**< Can have 4 different colors in a palette (always chroma keyed)*/\n    LV_IMG_CF_INDEXED_4BIT, /**< Can have 16 different colors in a palette (always chroma keyed)*/\n    LV_IMG_CF_INDEXED_8BIT, /**< Can have 256 different colors in a palette (always chroma keyed)*/\n\n    LV_IMG_CF_ALPHA_1BIT, /**< Can have one color and it can be drawn or not*/\n    LV_IMG_CF_ALPHA_2BIT, /**< Can have one color but 4 different alpha value*/\n    LV_IMG_CF_ALPHA_4BIT, /**< Can have one color but 16 different alpha value*/\n    LV_IMG_CF_ALPHA_8BIT, /**< Can have one color but 256 different alpha value*/\n\n    LV_IMG_CF_RESERVED_15,              /**< Reserved for further use.*/\n    LV_IMG_CF_RESERVED_16,              /**< Reserved for further use.*/\n    LV_IMG_CF_RESERVED_17,              /**< Reserved for further use.*/\n    LV_IMG_CF_RESERVED_18,              /**< Reserved for further use.*/\n    LV_IMG_CF_RESERVED_19,              /**< Reserved for further use.*/\n    LV_IMG_CF_RESERVED_20,              /**< Reserved for further use.*/\n    LV_IMG_CF_RESERVED_21,              /**< Reserved for further use.*/\n    LV_IMG_CF_RESERVED_22,              /**< Reserved for further use.*/\n    LV_IMG_CF_RESERVED_23,              /**< Reserved for further use.*/\n\n    LV_IMG_CF_USER_ENCODED_0,          /**< User holder encoding format.*/\n    LV_IMG_CF_USER_ENCODED_1,          /**< User holder encoding format.*/\n    LV_IMG_CF_USER_ENCODED_2,          /**< User holder encoding format.*/\n    LV_IMG_CF_USER_ENCODED_3,          /**< User holder encoding format.*/\n    LV_IMG_CF_USER_ENCODED_4,          /**< User holder encoding format.*/\n    LV_IMG_CF_USER_ENCODED_5,          /**< User holder encoding format.*/\n    LV_IMG_CF_USER_ENCODED_6,          /**< User holder encoding format.*/\n    LV_IMG_CF_USER_ENCODED_7,          /**< User holder encoding format.*/\n}", "sline": 56, "docstring": "/*Image color format*/"}, "lv_img_cf_t": {"type": "Variable", "def": "typedef uint8_t lv_img_cf_t", "sline": 99}, "lv_img_header_t.cf": {"type": "Variable", "def": "uint32_t cf : 5", "sline": 122, "in_struct": "lv_img_header_t"}, "lv_img_header_t.always_zero": {"type": "Variable", "def": "uint32_t always_zero : 3", "sline": 123, "in_struct": "lv_img_header_t"}, "lv_img_header_t.reserved": {"type": "Variable", "def": "uint32_t reserved : 2", "sline": 126, "in_struct": "lv_img_header_t"}, "lv_img_header_t.w": {"type": "Variable", "def": "uint32_t w : 11", "sline": 128, "in_struct": "lv_img_header_t"}, "lv_img_header_t.h": {"type": "Variable", "def": "uint32_t h : 11", "sline": 129, "in_struct": "lv_img_header_t"}, "lv_img_header_t": {"type": "Variable", "def": "typedef struct {\n\n    uint32_t cf : 5;          /*Color format: See `lv_img_color_format_t`*/\n    uint32_t always_zero : 3; /*It the upper bits of the first byte. Always zero to look like a\n                                 non-printable character*/\n\n    uint32_t reserved : 2; /*Reserved to be used later*/\n\n    uint32_t w : 11; /*Width of the image map*/\n    uint32_t h : 11; /*Height of the image map*/\n} lv_img_header_t", "sline": 130}, "lv_img_dsc_t.header": {"type": "Variable", "def": "lv_img_header_t header", "sline": 136, "in_struct": "lv_img_dsc_t", "rels": [["lv_img_header_t", null, "Typeof"]]}, "lv_img_dsc_t.data_size": {"type": "Variable", "def": "uint32_t data_size", "sline": 137, "in_struct": "lv_img_dsc_t"}, "lv_img_dsc_t.data": {"type": "Variable", "def": "const uint8_t * data", "sline": 138, "in_struct": "lv_img_dsc_t"}, "lv_img_dsc_t": {"type": "Variable", "def": "typedef struct {\n    lv_img_header_t header; /**< A header describing the basics of the image*/\n    uint32_t data_size;     /**< Size of the image in bytes*/\n    const uint8_t * data;   /**< Pointer to the data of the image*/\n} lv_img_dsc_t", "sline": 139, "docstring": "/** Image header it is compatible with"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_img_buf.h:141:9).cfg": {"type": "Variable", "def": "struct {\n        const void * src;           /*image source (array of pixels)*/\n        lv_coord_t src_w;           /*width of the image source*/\n        lv_coord_t src_h;           /*height of the image source*/\n        lv_coord_t pivot_x;         /*pivot x*/\n        lv_coord_t pivot_y;         /*pivot y*/\n        int16_t angle;              /*angle to rotate*/\n        uint16_t zoom;              /*256 no zoom, 128 half size, 512 double size*/\n        lv_color_t color;           /*a color used for `LV_IMG_CF_INDEXED_1/2/4/8BIT` color formats*/\n        lv_img_cf_t cf;             /*color format of the image to rotate*/\n        bool antialias;\n    } cfg", "sline": 153, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_img_buf.h:141:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_img_buf.h:141:9).res": {"type": "Variable", "def": "struct {\n        lv_color_t color;\n        lv_opa_t opa;\n    } res", "sline": 158, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_img_buf.h:141:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_img_buf.h:141:9).tmp": {"type": "Variable", "def": "struct {\n        lv_img_dsc_t img_dsc;\n        int32_t pivot_x_256;\n        int32_t pivot_y_256;\n        int32_t sinma;\n        int32_t cosma;\n\n        uint8_t chroma_keyed : 1;\n        uint8_t has_alpha : 1;\n        uint8_t native_color : 1;\n\n        uint32_t zoom_inv;\n\n        /*Runtime data*/\n        lv_coord_t xs;\n        lv_coord_t ys;\n        lv_coord_t xs_int;\n        lv_coord_t ys_int;\n        uint32_t pxi;\n        uint8_t px_size;\n    } tmp", "sline": 180, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_img_buf.h:141:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_img_buf.h:141:9)": {"type": "Struct", "def": "struct {\n    struct {\n        const void * src;           /*image source (array of pixels)*/\n        lv_coord_t src_w;           /*width of the image source*/\n        lv_coord_t src_h;           /*height of the image source*/\n        lv_coord_t pivot_x;         /*pivot x*/\n        lv_coord_t pivot_y;         /*pivot y*/\n        int16_t angle;              /*angle to rotate*/\n        uint16_t zoom;              /*256 no zoom, 128 half size, 512 double size*/\n        lv_color_t color;           /*a color used for `LV_IMG_CF_INDEXED_1/2/4/8BIT` color formats*/\n        lv_img_cf_t cf;             /*color format of the image to rotate*/\n        bool antialias;\n    } cfg;\n\n    struct {\n        lv_color_t color;\n        lv_opa_t opa;\n    } res;\n\n    struct {\n        lv_img_dsc_t img_dsc;\n        int32_t pivot_x_256;\n        int32_t pivot_y_256;\n        int32_t sinma;\n        int32_t cosma;\n\n        uint8_t chroma_keyed : 1;\n        uint8_t has_alpha : 1;\n        uint8_t native_color : 1;\n\n        uint32_t zoom_inv;\n\n        /*Runtime data*/\n        lv_coord_t xs;\n        lv_coord_t ys;\n        lv_coord_t xs_int;\n        lv_coord_t ys_int;\n        uint32_t pxi;\n        uint8_t px_size;\n    } tmp;\n}", "sline": 141, "body": "struct {\n        const void * src;           /*image source (array of pixels)*/\n        lv_coord_t src_w;           /*width of the image source*/\n        lv_coord_t src_h;           /*height of the image source*/\n        lv_coord_t pivot_x;         /*pivot x*/\n        lv_coord_t pivot_y;         /*pivot y*/\n        int16_t angle;              /*angle to rotate*/\n        uint16_t zoom;              /*256 no zoom, 128 half size, 512 double size*/\n        lv_color_t color;           /*a color used for `LV_IMG_CF_INDEXED_1/2/4/8BIT` color formats*/\n        lv_img_cf_t cf;             /*color format of the image to rotate*/\n        bool antialias;\n    } cfg\nstruct {\n        lv_color_t color;\n        lv_opa_t opa;\n    } res\nstruct {\n        lv_img_dsc_t img_dsc;\n        int32_t pivot_x_256;\n        int32_t pivot_y_256;\n        int32_t sinma;\n        int32_t cosma;\n\n        uint8_t chroma_keyed : 1;\n        uint8_t has_alpha : 1;\n        uint8_t native_color : 1;\n\n        uint32_t zoom_inv;\n\n        /*Runtime data*/\n        lv_coord_t xs;\n        lv_coord_t ys;\n        lv_coord_t xs_int;\n        lv_coord_t ys_int;\n        uint32_t pxi;\n        uint8_t px_size;\n    } tmp\n"}, "lv_img_transform_dsc_t": {"type": "Variable", "def": "typedef struct {\n    struct {\n        const void * src;           /*image source (array of pixels)*/\n        lv_coord_t src_w;           /*width of the image source*/\n        lv_coord_t src_h;           /*height of the image source*/\n        lv_coord_t pivot_x;         /*pivot x*/\n        lv_coord_t pivot_y;         /*pivot y*/\n        int16_t angle;              /*angle to rotate*/\n        uint16_t zoom;              /*256 no zoom, 128 half size, 512 double size*/\n        lv_color_t color;           /*a color used for `LV_IMG_CF_INDEXED_1/2/4/8BIT` color formats*/\n        lv_img_cf_t cf;             /*color format of the image to rotate*/\n        bool antialias;\n    } cfg;\n\n    struct {\n        lv_color_t color;\n        lv_opa_t opa;\n    } res;\n\n    struct {\n        lv_img_dsc_t img_dsc;\n        int32_t pivot_x_256;\n        int32_t pivot_y_256;\n        int32_t sinma;\n        int32_t cosma;\n\n        uint8_t chroma_keyed : 1;\n        uint8_t has_alpha : 1;\n        uint8_t native_color : 1;\n\n        uint32_t zoom_inv;\n\n        /*Runtime data*/\n        lv_coord_t xs;\n        lv_coord_t ys;\n        lv_coord_t xs_int;\n        lv_coord_t ys_int;\n        uint32_t pxi;\n        uint8_t px_size;\n    } tmp;\n} lv_img_transform_dsc_t", "sline": 181}, "lv_img_buf_alloc": {"type": "Function", "def": "lv_img_dsc_t * lv_img_buf_alloc(lv_coord_t w, lv_coord_t h, lv_img_cf_t cf)", "sline": 195}, "lv_img_buf_get_px_color": {"type": "Function", "def": "lv_color_t lv_img_buf_get_px_color(lv_img_dsc_t * dsc, lv_coord_t x, lv_coord_t y, lv_color_t color)", "sline": 207}, "lv_img_buf_get_px_alpha": {"type": "Function", "def": "lv_opa_t lv_img_buf_get_px_alpha(lv_img_dsc_t * dsc, lv_coord_t x, lv_coord_t y)", "sline": 217}, "lv_img_buf_set_px_color": {"type": "Function", "def": "void lv_img_buf_set_px_color(lv_img_dsc_t * dsc, lv_coord_t x, lv_coord_t y, lv_color_t c)", "sline": 227}, "lv_img_buf_set_px_alpha": {"type": "Function", "def": "void lv_img_buf_set_px_alpha(lv_img_dsc_t * dsc, lv_coord_t x, lv_coord_t y, lv_opa_t opa)", "sline": 237}, "lv_img_buf_set_palette": {"type": "Function", "def": "void lv_img_buf_set_palette(lv_img_dsc_t * dsc, uint8_t id, lv_color_t c)", "sline": 249}, "lv_img_buf_free": {"type": "Function", "def": "void lv_img_buf_free(lv_img_dsc_t * dsc)", "sline": 255}, "lv_img_buf_get_img_size": {"type": "Function", "def": "uint32_t lv_img_buf_get_img_size(lv_coord_t w, lv_coord_t h, lv_img_cf_t cf)", "sline": 264}, "_lv_img_buf_transform_init": {"type": "Function", "def": "void _lv_img_buf_transform_init(lv_img_transform_dsc_t * dsc)", "sline": 271}, "_lv_img_buf_transform_anti_alias": {"type": "Function", "def": "bool _lv_img_buf_transform_anti_alias(lv_img_transform_dsc_t * dsc)", "sline": 277}, "_lv_img_buf_transform": {"type": "Function", "def": "bool _lv_img_buf_transform(lv_img_transform_dsc_t * dsc, lv_coord_t x, lv_coord_t y)", "sline": 287}, "_lv_img_buf_get_transformed_area": {"type": "Function", "def": "void _lv_img_buf_get_transformed_area(lv_area_t * res, lv_coord_t w, lv_coord_t h, int16_t angle, uint16_t zoom,\n                                      const lv_point_t * pivot)", "sline": 299}, "carbit_updater/lvgl/src/draw/lv_img_buf.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_img_buf.h"}}, "carbit_updater/lvgl/src/extra/themes/basic/lv_theme_basic.c": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 9}, "lv_theme_basic": {"type": "Variable", "def": "#include lv_theme_basic.h", "sline": 13, "include": ["carbit_updater/lvgl/src/extra/themes/basic/lv_theme_basic.h", null]}, "lv_gc": {"type": "Variable", "def": "#include ../../../misc/lv_gc.h", "sline": 14}, "my_theme_styles_t.scr": {"type": "Variable", "def": "lv_style_t scr", "sline": 31, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.light": {"type": "Variable", "def": "lv_style_t light", "sline": 32, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.dark": {"type": "Variable", "def": "lv_style_t dark", "sline": 33, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.scrollbar": {"type": "Variable", "def": "lv_style_t scrollbar", "sline": 34, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.pressed": {"type": "Variable", "def": "lv_style_t pressed", "sline": 35, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.disabled": {"type": "Variable", "def": "lv_style_t disabled", "sline": 36, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.pad_zero": {"type": "Variable", "def": "lv_style_t pad_zero", "sline": 37, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t.ta_cursor": {"type": "Variable", "def": "lv_style_t ta_cursor", "sline": 39, "in_struct": "my_theme_styles_t"}, "my_theme_styles_t": {"type": "Variable", "def": "typedef struct {\n    lv_style_t scr;\n    lv_style_t light;\n    lv_style_t dark;\n    lv_style_t scrollbar;\n    lv_style_t pressed;\n    lv_style_t disabled;\n    lv_style_t pad_zero;\n#if LV_USE_TEXTAREA\n    lv_style_t ta_cursor;\n#endif\n} my_theme_styles_t", "sline": 41, "docstring": "/**********************"}, "style_init_reset": {"type": "Function", "def": "static void style_init_reset(lv_style_t * style)", "sline": 418, "body": "{\n    if(inited) lv_style_reset(style);\n    else lv_style_init(style);\n}"}, "theme_apply": {"type": "Function", "def": "static void theme_apply(lv_theme_t * th, lv_obj_t * obj)", "sline": 176, "body": "{\n    LV_UNUSED(th);\n\n    if(lv_obj_get_parent(obj) == NULL) {\n        lv_obj_add_style(obj, &styles->scr, 0);\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n        return;\n    }\n\n    if(lv_obj_check_type(obj, &lv_obj_class)) {\n#if LV_USE_TABVIEW\n        lv_obj_t * parent = lv_obj_get_parent(obj);\n        /*Tabview content area*/\n        if(lv_obj_check_type(parent, &lv_tabview_class)) {\n            lv_obj_add_style(obj, &styles->light, 0);\n            return;\n        }\n        /*Tabview pages*/\n        else if(lv_obj_check_type(lv_obj_get_parent(parent), &lv_tabview_class)) {\n            lv_obj_add_style(obj, &styles->light, 0);\n            lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n            return;\n        }\n#endif\n\n#if LV_USE_WIN\n        /*Header*/\n        if(lv_obj_get_index(obj) == 0 && lv_obj_check_type(lv_obj_get_parent(obj), &lv_win_class)) {\n            lv_obj_add_style(obj, &styles->light, 0);\n            return;\n        }\n        /*Content*/\n        else if(lv_obj_get_index(obj) == 1 && lv_obj_check_type(lv_obj_get_parent(obj), &lv_win_class)) {\n            lv_obj_add_style(obj, &styles->light, 0);\n            lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n            return;\n        }\n#endif\n        lv_obj_add_style(obj, &styles->light, 0);\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n    }\n#if LV_USE_BTN\n    else if(lv_obj_check_type(obj, &lv_btn_class)) {\n        lv_obj_add_style(obj, &styles->dark, 0);\n        lv_obj_add_style(obj, &styles->pressed, LV_STATE_PRESSED);\n        lv_obj_add_style(obj, &styles->disabled, LV_STATE_DISABLED);\n    }\n#endif\n\n#if LV_USE_BTNMATRIX\n    else if(lv_obj_check_type(obj, &lv_btnmatrix_class)) {\n#if LV_USE_MSGBOX\n        if(lv_obj_check_type(lv_obj_get_parent(obj), &lv_msgbox_class)) {\n            lv_obj_add_style(obj, &styles->light, LV_PART_ITEMS);\n            lv_obj_add_style(obj, &styles->pressed, LV_PART_ITEMS | LV_STATE_PRESSED);\n            return;\n        }\n#endif\n#if LV_USE_TABVIEW\n        if(lv_obj_check_type(lv_obj_get_parent(obj), &lv_tabview_class)) {\n            lv_obj_add_style(obj, &styles->light, LV_PART_ITEMS);\n            lv_obj_add_style(obj, &styles->pressed, LV_PART_ITEMS | LV_STATE_PRESSED);\n            return;\n        }\n#endif\n        lv_obj_add_style(obj, &styles->light, 0);\n        lv_obj_add_style(obj, &styles->dark, LV_PART_ITEMS);\n        lv_obj_add_style(obj, &styles->pressed, LV_PART_ITEMS | LV_STATE_PRESSED);\n    }\n#endif\n\n#if LV_USE_BAR\n    else if(lv_obj_check_type(obj, &lv_bar_class)) {\n        lv_obj_add_style(obj, &styles->light, 0);\n        lv_obj_add_style(obj, &styles->pad_zero, 0);\n        lv_obj_add_style(obj, &styles->dark, LV_PART_INDICATOR);\n    }\n#endif\n\n#if LV_USE_SLIDER\n    else if(lv_obj_check_type(obj, &lv_slider_class)) {\n        lv_obj_add_style(obj, &styles->light, 0);\n        lv_obj_add_style(obj, &styles->pad_zero, 0);\n        lv_obj_add_style(obj, &styles->dark, LV_PART_INDICATOR);\n        lv_obj_add_style(obj, &styles->dark, LV_PART_KNOB);\n    }\n#endif\n\n#if LV_USE_TABLE\n    else if(lv_obj_check_type(obj, &lv_table_class)) {\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n        lv_obj_add_style(obj, &styles->light, LV_PART_ITEMS);\n        lv_obj_add_style(obj, &styles->pressed, LV_PART_ITEMS | LV_STATE_PRESSED);\n    }\n#endif\n\n#if LV_USE_CHECKBOX\n    else if(lv_obj_check_type(obj, &lv_checkbox_class)) {\n        lv_obj_add_style(obj, &styles->light, LV_PART_INDICATOR);\n        lv_obj_add_style(obj, &styles->disabled, LV_PART_INDICATOR | LV_STATE_DISABLED);\n        lv_obj_add_style(obj, &styles->dark, LV_PART_INDICATOR | LV_STATE_CHECKED);\n        lv_obj_add_style(obj, &styles->pressed, LV_PART_INDICATOR | LV_STATE_PRESSED);\n    }\n#endif\n\n#if LV_USE_SWITCH\n    else if(lv_obj_check_type(obj, &lv_switch_class)) {\n        lv_obj_add_style(obj, &styles->light, 0);\n        lv_obj_add_style(obj, &styles->pad_zero, 0);\n        lv_obj_add_style(obj, &styles->dark, LV_PART_INDICATOR);\n        lv_obj_add_style(obj, &styles->dark, LV_PART_KNOB);\n        lv_obj_add_style(obj, &styles->pad_zero, LV_PART_KNOB);\n    }\n#endif\n\n#if LV_USE_CHART\n    else if(lv_obj_check_type(obj, &lv_chart_class)) {\n        lv_obj_add_style(obj, &styles->light, 0);\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n        lv_obj_add_style(obj, &styles->light, LV_PART_ITEMS);\n        lv_obj_add_style(obj, &styles->light, LV_PART_TICKS);\n        lv_obj_add_style(obj, &styles->light, LV_PART_CURSOR);\n    }\n#endif\n\n#if LV_USE_ROLLER\n    else if(lv_obj_check_type(obj, &lv_roller_class)) {\n        lv_obj_add_style(obj, &styles->light, 0);\n        lv_obj_add_style(obj, &styles->dark, LV_PART_SELECTED);\n    }\n#endif\n\n#if LV_USE_DROPDOWN\n    else if(lv_obj_check_type(obj, &lv_dropdown_class)) {\n        lv_obj_add_style(obj, &styles->light, 0);\n        lv_obj_add_style(obj, &styles->pressed, LV_STATE_PRESSED);\n    }\n    else if(lv_obj_check_type(obj, &lv_dropdownlist_class)) {\n        lv_obj_add_style(obj, &styles->light, 0);\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n        lv_obj_add_style(obj, &styles->light, LV_PART_SELECTED);\n        lv_obj_add_style(obj, &styles->dark, LV_PART_SELECTED | LV_STATE_CHECKED);\n        lv_obj_add_style(obj, &styles->pressed, LV_PART_SELECTED | LV_STATE_PRESSED);\n    }\n#endif\n\n#if LV_USE_ARC\n    else if(lv_obj_check_type(obj, &lv_arc_class)) {\n        lv_obj_add_style(obj, &styles->light, 0);\n        lv_obj_add_style(obj, &styles->dark, LV_PART_INDICATOR);\n        lv_obj_add_style(obj, &styles->pad_zero, LV_PART_INDICATOR);\n        lv_obj_add_style(obj, &styles->dark, LV_PART_KNOB);\n    }\n#endif\n\n#if LV_USE_METER\n    else if(lv_obj_check_type(obj, &lv_meter_class)) {\n        lv_obj_add_style(obj, &styles->light, 0);\n    }\n#endif\n\n#if LV_USE_TEXTAREA\n    else if(lv_obj_check_type(obj, &lv_textarea_class)) {\n        lv_obj_add_style(obj, &styles->light, 0);\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n        lv_obj_add_style(obj, &styles->ta_cursor, LV_PART_CURSOR);\n        lv_obj_add_style(obj, &styles->light, LV_PART_TEXTAREA_PLACEHOLDER);\n    }\n#endif\n\n#if LV_USE_CALENDAR\n    else if(lv_obj_check_type(obj, &lv_calendar_class)) {\n        lv_obj_add_style(obj, &styles->light, 0);\n        lv_obj_add_style(obj, &styles->light, LV_PART_ITEMS | LV_STATE_PRESSED);\n        lv_obj_add_style(obj, &styles->pressed, LV_PART_ITEMS | LV_STATE_PRESSED);\n        lv_obj_add_style(obj, &styles->disabled, LV_PART_ITEMS | LV_STATE_DISABLED);\n    }\n#endif\n\n#if LV_USE_KEYBOARD\n    else if(lv_obj_check_type(obj, &lv_keyboard_class)) {\n        lv_obj_add_style(obj, &styles->light, 0);\n        lv_obj_add_style(obj, &styles->light, LV_PART_ITEMS);\n        lv_obj_add_style(obj, &styles->pressed, LV_PART_ITEMS | LV_STATE_PRESSED);\n    }\n#endif\n#if LV_USE_LIST\n    else if(lv_obj_check_type(obj, &lv_list_class)) {\n        lv_obj_add_style(obj, &styles->light, 0);\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n        return;\n    }\n    else if(lv_obj_check_type(obj, &lv_list_text_class)) {\n\n    }\n    else if(lv_obj_check_type(obj, &lv_list_btn_class)) {\n        lv_obj_add_style(obj, &styles->dark, 0);\n        lv_obj_add_style(obj, &styles->pressed, LV_STATE_PRESSED);\n\n    }\n#endif\n#if LV_USE_MSGBOX\n    else if(lv_obj_check_type(obj, &lv_msgbox_class)) {\n        lv_obj_add_style(obj, &styles->light, 0);\n        return;\n    }\n#endif\n#if LV_USE_SPINBOX\n    else if(lv_obj_check_type(obj, &lv_spinbox_class)) {\n        lv_obj_add_style(obj, &styles->light, 0);\n        lv_obj_add_style(obj, &styles->dark, LV_PART_CURSOR);\n    }\n#endif\n#if LV_USE_TILEVIEW\n    else if(lv_obj_check_type(obj, &lv_tileview_class)) {\n        lv_obj_add_style(obj, &styles->scr, 0);\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n    }\n    else if(lv_obj_check_type(obj, &lv_tileview_tile_class)) {\n        lv_obj_add_style(obj, &styles->scrollbar, LV_PART_SCROLLBAR);\n    }\n#endif\n\n#if LV_USE_COLORWHEEL\n    else if(lv_obj_check_type(obj, &lv_colorwheel_class)) {\n        lv_obj_add_style(obj, &styles->light, 0);\n        lv_obj_add_style(obj, &styles->light, LV_PART_KNOB);\n    }\n#endif\n\n#if LV_USE_LED\n    else if(lv_obj_check_type(obj, &lv_led_class)) {\n        lv_obj_add_style(obj, &styles->light, 0);\n    }\n#endif\n}"}, "styles": {"type": "Variable", "def": "static my_theme_styles_t * styles", "sline": 53}, "theme": {"type": "Variable", "def": "static lv_theme_t theme", "sline": 54}, "inited": {"type": "Function", "def": "static bool inited", "sline": 55}, "dark_color_filter_cb": {"type": "Function", "def": "static lv_color_t dark_color_filter_cb(const lv_color_filter_dsc_t * f, lv_color_t c, lv_opa_t opa)", "sline": 65, "body": "{\n    LV_UNUSED(f);\n    return lv_color_darken(c, opa);\n}"}, "grey_filter_cb": {"type": "Function", "def": "static lv_color_t grey_filter_cb(const lv_color_filter_dsc_t * f, lv_color_t color, lv_opa_t opa)", "sline": 72, "body": "{\n    LV_UNUSED(f);\n    return lv_color_mix(lv_color_white(), color, opa);\n}"}, "style_init": {"type": "Function", "def": "static void style_init(void)", "sline": 78, "body": "{\n    style_init_reset(&styles->scrollbar);\n    lv_style_set_bg_opa(&styles->scrollbar, LV_OPA_COVER);\n    lv_style_set_bg_color(&styles->scrollbar, lv_palette_darken(LV_PALETTE_GREY, 2));\n    lv_style_set_width(&styles->scrollbar,  PAD_DEF);\n\n    style_init_reset(&styles->scr);\n    lv_style_set_bg_opa(&styles->scr, LV_OPA_COVER);\n    lv_style_set_bg_color(&styles->scr, COLOR_WHITE);\n    lv_style_set_text_color(&styles->scr, COLOR_DIM);\n    lv_style_set_pad_row(&styles->scr, PAD_DEF / 2);\n    lv_style_set_pad_column(&styles->scr, PAD_DEF / 2);\n\n    style_init_reset(&styles->light);\n    lv_style_set_bg_opa(&styles->light, LV_OPA_COVER);\n    lv_style_set_bg_color(&styles->light, COLOR_LIGHT);\n    lv_style_set_border_color(&styles->light, COLOR_MID);\n    lv_style_set_border_width(&styles->light, 1);\n    lv_style_set_pad_all(&styles->light, PAD_DEF);\n    lv_style_set_pad_gap(&styles->light, PAD_DEF / 2);\n    lv_style_set_line_width(&styles->light, LV_DPX(2));\n    lv_style_set_line_color(&styles->light, COLOR_MID);\n    lv_style_set_arc_width(&styles->light, LV_DPX(2));\n    lv_style_set_arc_color(&styles->light, COLOR_MID);\n\n    style_init_reset(&styles->dark);\n    lv_style_set_bg_opa(&styles->dark, LV_OPA_COVER);\n    lv_style_set_bg_color(&styles->dark, COLOR_DARK);\n    lv_style_set_border_color(&styles->dark, COLOR_DIM);\n    lv_style_set_border_width(&styles->dark, 1);\n    lv_style_set_pad_all(&styles->dark, PAD_DEF);\n    lv_style_set_pad_gap(&styles->dark, PAD_DEF / 2);\n    lv_style_set_line_width(&styles->dark, LV_DPX(2));\n    lv_style_set_line_color(&styles->dark, COLOR_DIM);\n    lv_style_set_arc_width(&styles->dark, LV_DPX(2));\n    lv_style_set_arc_color(&styles->dark, COLOR_DIM);\n\n    static lv_color_filter_dsc_t dark_filter;\n    lv_color_filter_dsc_init(&dark_filter, dark_color_filter_cb);\n\n    style_init_reset(&styles->pressed);\n    lv_style_set_color_filter_dsc(&styles->pressed, &dark_filter);\n    lv_style_set_color_filter_opa(&styles->pressed, 35);\n\n    static lv_color_filter_dsc_t grey_filter;\n    lv_color_filter_dsc_init(&grey_filter, grey_filter_cb);\n\n    style_init_reset(&styles->disabled);\n    lv_style_set_color_filter_dsc(&styles->disabled, &grey_filter);\n    lv_style_set_color_filter_opa(&styles->disabled, LV_OPA_70);\n\n    style_init_reset(&styles->pad_zero);\n    lv_style_set_pad_all(&styles->pad_zero, 0);\n    lv_style_set_pad_gap(&styles->pad_zero, 0);\n\n#if LV_USE_TEXTAREA\n    style_init_reset(&styles->ta_cursor);\n    lv_style_set_border_side(&styles->ta_cursor, LV_BORDER_SIDE_LEFT);\n    lv_style_set_border_color(&styles->ta_cursor, COLOR_DIM);\n    lv_style_set_border_width(&styles->ta_cursor, 2);\n    lv_style_set_bg_opa(&styles->ta_cursor, LV_OPA_TRANSP);\n    lv_style_set_anim_time(&styles->ta_cursor, 500);\n#endif\n}"}, "lv_theme_basic_init": {"type": "Function", "def": "lv_theme_t * lv_theme_basic_init(lv_disp_t * disp)", "sline": 149, "body": "{\n\n    /*This trick is required only to avoid the garbage collection of\n     *styles' data if LVGL is used in a binding (e.g. Micropython)\n     *In a general case styles could be in simple `static lv_style_t my_style...` variables*/\n    if(!inited) {\n        LV_GC_ROOT(_lv_theme_default_styles) = lv_mem_alloc(sizeof(my_theme_styles_t));\n        styles = (my_theme_styles_t *)LV_GC_ROOT(_lv_theme_default_styles);\n    }\n\n    theme.disp = disp;\n    theme.font_small = LV_FONT_DEFAULT;\n    theme.font_normal = LV_FONT_DEFAULT;\n    theme.font_large = LV_FONT_DEFAULT;\n    theme.apply_cb = theme_apply;\n\n    style_init();\n\n    inited = true;\n\n    if(disp == NULL || lv_disp_get_theme(disp) == &theme) lv_obj_report_style_change(NULL);\n\n    return (lv_theme_t *)&theme;\n}"}, "carbit_updater/lvgl/src/extra/themes/basic/lv_theme_basic.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/themes/basic/lv_theme_basic.c"}}, "carbit_updater/lv_drivers/indev/xkb.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 20}, "carbit_updater/lv_drivers/indev/xkb.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/indev/xkb.h"}}, "carbit_updater/lv_drivers/display/SHARP_MIP.c": {"SHARP_MIP": {"type": "Variable", "def": "#include SHARP_MIP.h", "sline": 43, "include": ["carbit_updater/lv_drivers/display/SHARP_MIP.h", null]}, "carbit_updater/lv_drivers/display/SHARP_MIP.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/SHARP_MIP.c"}}, "carbit_updater/lvgl/src/misc/lv_tlsf.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 1}, "stddef": {"type": "Variable", "def": "#include stddef.h", "sline": 44}, "lv_tlsf_t": {"type": "Variable", "def": "typedef void * lv_tlsf_t", "sline": 52, "docstring": "/* lv_tlsf_t: a TLSF structure. Can contain 1 to N pools. */\n/* lv_pool_t: a block of memory that TLSF can manage. */"}, "lv_pool_t": {"type": "Variable", "def": "typedef void * lv_pool_t", "sline": 53, "docstring": "/* lv_tlsf_t: a TLSF structure. Can contain 1 to N pools. */\n/* lv_pool_t: a block of memory that TLSF can manage. */"}, "lv_tlsf_create": {"type": "Function", "def": "lv_tlsf_t lv_tlsf_create(void * mem)", "sline": 56, "rels": [["lv_tlsf_t", null, "Typeof"]]}, "lv_tlsf_create_with_pool": {"type": "Function", "def": "lv_tlsf_t lv_tlsf_create_with_pool(void * mem, size_t bytes)", "sline": 57, "rels": [["lv_tlsf_t", null, "Typeof"]]}, "lv_tlsf_destroy": {"type": "Function", "def": "void lv_tlsf_destroy(lv_tlsf_t tlsf)", "sline": 58}, "lv_tlsf_get_pool": {"type": "Function", "def": "lv_pool_t lv_tlsf_get_pool(lv_tlsf_t tlsf)", "sline": 59, "rels": [["lv_pool_t", null, "Typeof"]]}, "lv_tlsf_add_pool": {"type": "Function", "def": "lv_pool_t lv_tlsf_add_pool(lv_tlsf_t tlsf, void * mem, size_t bytes)", "sline": 62, "rels": [["lv_pool_t", null, "Typeof"]]}, "lv_tlsf_remove_pool": {"type": "Function", "def": "void lv_tlsf_remove_pool(lv_tlsf_t tlsf, lv_pool_t pool)", "sline": 63}, "lv_tlsf_malloc": {"type": "Function", "def": "void * lv_tlsf_malloc(lv_tlsf_t tlsf, size_t bytes)", "sline": 66}, "lv_tlsf_memalign": {"type": "Function", "def": "void * lv_tlsf_memalign(lv_tlsf_t tlsf, size_t align, size_t bytes)", "sline": 67}, "lv_tlsf_realloc": {"type": "Function", "def": "void * lv_tlsf_realloc(lv_tlsf_t tlsf, void * ptr, size_t size)", "sline": 68}, "lv_tlsf_free": {"type": "Function", "def": "void lv_tlsf_free(lv_tlsf_t tlsf, void * ptr)", "sline": 69}, "lv_tlsf_block_size": {"type": "Function", "def": "size_t lv_tlsf_block_size(void * ptr)", "sline": 72}, "lv_tlsf_size": {"type": "Function", "def": "size_t lv_tlsf_size(void)", "sline": 75}, "lv_tlsf_align_size": {"type": "Function", "def": "size_t lv_tlsf_align_size(void)", "sline": 76}, "lv_tlsf_block_size_min": {"type": "Function", "def": "size_t lv_tlsf_block_size_min(void)", "sline": 77}, "lv_tlsf_block_size_max": {"type": "Function", "def": "size_t lv_tlsf_block_size_max(void)", "sline": 78}, "lv_tlsf_pool_overhead": {"type": "Function", "def": "size_t lv_tlsf_pool_overhead(void)", "sline": 79}, "lv_tlsf_alloc_overhead": {"type": "Function", "def": "size_t lv_tlsf_alloc_overhead(void)", "sline": 80}, "lv_tlsf_walker": {"type": "Variable", "def": "typedef void (*lv_tlsf_walker)(void * ptr, size_t size, int used, void * user)", "sline": 83, "docstring": "/* Debugging. */"}, "lv_tlsf_walk_pool": {"type": "Function", "def": "void lv_tlsf_walk_pool(lv_pool_t pool, lv_tlsf_walker walker, void * user)", "sline": 84}, "lv_tlsf_check": {"type": "Function", "def": "int lv_tlsf_check(lv_tlsf_t tlsf)", "sline": 86}, "lv_tlsf_check_pool": {"type": "Function", "def": "int lv_tlsf_check_pool(lv_pool_t pool)", "sline": 87}, "carbit_updater/lvgl/src/misc/lv_tlsf.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/misc/lv_tlsf.h"}}, "carbit_updater/lv_drivers/display/g2d_driver.h": {"stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 22}, "types": {"type": "Variable", "def": "#include linux/types.h", "sline": 23}, "ioctl": {"type": "Variable", "def": "#include linux/ioctl.h", "sline": 24}, "g2d_fmt_enh": {"type": "Variable", "def": "typedef enum {\n\tG2D_FORMAT_ARGB8888,\n\tG2D_FORMAT_ABGR8888,\n\tG2D_FORMAT_RGBA8888,\n\tG2D_FORMAT_BGRA8888,\n\tG2D_FORMAT_XRGB8888,\n\tG2D_FORMAT_XBGR8888,\n\tG2D_FORMAT_RGBX8888,\n\tG2D_FORMAT_BGRX8888,\n\tG2D_FORMAT_RGB888,\n\tG2D_FORMAT_BGR888,\n\tG2D_FORMAT_RGB565,\n\tG2D_FORMAT_BGR565,\n\tG2D_FORMAT_ARGB4444,\n\tG2D_FORMAT_ABGR4444,\n\tG2D_FORMAT_RGBA4444,\n\tG2D_FORMAT_BGRA4444,\n\tG2D_FORMAT_ARGB1555,\n\tG2D_FORMAT_ABGR1555,\n\tG2D_FORMAT_RGBA5551,\n\tG2D_FORMAT_BGRA5551,\n\tG2D_FORMAT_ARGB2101010,\n\tG2D_FORMAT_ABGR2101010,\n\tG2D_FORMAT_RGBA1010102,\n\tG2D_FORMAT_BGRA1010102,\n\n\t/* invailed for UI channel */\n\tG2D_FORMAT_IYUV422_V0Y1U0Y0 = 0x20,\n\tG2D_FORMAT_IYUV422_Y1V0Y0U0,\n\tG2D_FORMAT_IYUV422_U0Y1V0Y0,\n\tG2D_FORMAT_IYUV422_Y1U0Y0V0,\n\n\tG2D_FORMAT_YUV422UVC_V1U1V0U0,\n\tG2D_FORMAT_YUV422UVC_U1V1U0V0,\n\tG2D_FORMAT_YUV422_PLANAR,\n\n\tG2D_FORMAT_YUV420UVC_V1U1V0U0 = 0x28,\n\tG2D_FORMAT_YUV420UVC_U1V1U0V0,\n\tG2D_FORMAT_YUV420_PLANAR,\n\n\tG2D_FORMAT_YUV411UVC_V1U1V0U0 = 0x2c,\n\tG2D_FORMAT_YUV411UVC_U1V1U0V0,\n\tG2D_FORMAT_YUV411_PLANAR,\n\n\tG2D_FORMAT_Y8 = 0x30,\n\n\t/* YUV 10bit format */\n\tG2D_FORMAT_YVU10_P010 = 0x34,\n\n\tG2D_FORMAT_YVU10_P210 = 0x36,\n\n\tG2D_FORMAT_YVU10_444 = 0x38,\n\tG2D_FORMAT_YUV10_444 = 0x39,\n\tG2D_FORMAT_MAX,\n} g2d_fmt_enh", "sline": 81, "docstring": "/* data format */"}, "g2d_data_fmt": {"type": "Variable", "def": "typedef enum {\n\t/* share data format */\n\tG2D_FMT_ARGB_AYUV8888\t= (0x0),\n\tG2D_FMT_BGRA_VUYA8888\t= (0x1),\n\tG2D_FMT_ABGR_AVUY8888\t= (0x2),\n\tG2D_FMT_RGBA_YUVA8888\t= (0x3),\n\n\tG2D_FMT_XRGB8888\t\t= (0x4),\n\tG2D_FMT_BGRX8888\t\t= (0x5),\n\tG2D_FMT_XBGR8888\t\t= (0x6),\n\tG2D_FMT_RGBX8888\t\t= (0x7),\n\n\tG2D_FMT_ARGB4444\t\t= (0x8),\n\tG2D_FMT_ABGR4444\t\t= (0x9),\n\tG2D_FMT_RGBA4444\t\t= (0xA),\n\tG2D_FMT_BGRA4444\t\t= (0xB),\n\n\tG2D_FMT_ARGB1555\t\t= (0xC),\n\tG2D_FMT_ABGR1555\t\t= (0xD),\n\tG2D_FMT_RGBA5551\t\t= (0xE),\n\tG2D_FMT_BGRA5551\t\t= (0xF),\n\n\tG2D_FMT_RGB565\t\t\t= (0x10),\n\tG2D_FMT_BGR565\t\t\t= (0x11),\n\n\tG2D_FMT_IYUV422\t\t\t= (0x12),\n\n\tG2D_FMT_8BPP_MONO\t\t= (0x13),\n\tG2D_FMT_4BPP_MONO\t\t= (0x14),\n\tG2D_FMT_2BPP_MONO\t\t= (0x15),\n\tG2D_FMT_1BPP_MONO\t\t= (0x16),\n\n\tG2D_FMT_PYUV422UVC\t\t= (0x17),\n\tG2D_FMT_PYUV420UVC\t\t= (0x18),\n\tG2D_FMT_PYUV411UVC\t\t= (0x19),\n\n\t/* just for output format */\n\tG2D_FMT_PYUV422\t\t\t= (0x1A),\n\tG2D_FMT_PYUV420\t\t\t= (0x1B),\n\tG2D_FMT_PYUV411\t\t\t= (0x1C),\n\n\t/* just for input format */\n\tG2D_FMT_8BPP_PALETTE\t= (0x1D),\n\tG2D_FMT_4BPP_PALETTE\t= (0x1E),\n\tG2D_FMT_2BPP_PALETTE\t= (0x1F),\n\tG2D_FMT_1BPP_PALETTE\t= (0x20),\n\n\tG2D_FMT_PYUV422UVC_MB16\t= (0x21),\n\tG2D_FMT_PYUV420UVC_MB16\t= (0x22),\n\tG2D_FMT_PYUV411UVC_MB16\t= (0x23),\n\tG2D_FMT_PYUV422UVC_MB32\t= (0x24),\n\tG2D_FMT_PYUV420UVC_MB32\t= (0x25),\n\tG2D_FMT_PYUV411UVC_MB32\t= (0x26),\n\tG2D_FMT_PYUV422UVC_MB64\t= (0x27),\n\tG2D_FMT_PYUV420UVC_MB64\t= (0x28),\n\tG2D_FMT_PYUV411UVC_MB64\t= (0x29),\n\tG2D_FMT_PYUV422UVC_MB128 = (0x2A),\n\tG2D_FMT_PYUV420UVC_MB128 = (0x2B),\n\tG2D_FMT_PYUV411UVC_MB128 = (0x2C),\n\n} g2d_data_fmt", "sline": 143, "docstring": "/* mixer data format */"}, "g2d_pixel_seq": {"type": "Variable", "def": "typedef enum {\n\tG2D_SEQ_NORMAL = 0x0,\n\n\t/* for interleaved yuv422 */\n\tG2D_SEQ_VYUY   = 0x1,\t\t\t/* pixel 0\ufffd\u06b5\ufffd16\u03bb */\n\tG2D_SEQ_YVYU   = 0x2,\t\t\t/* pixel 1\ufffd\u06b5\ufffd16\u03bb */\n\n\t/* for uv_combined yuv420 */\n\tG2D_SEQ_VUVU   = 0x3,\n\n\t/* for 16bpp rgb */\n\tG2D_SEQ_P10    = 0x4,\t\t\t/* pixel 0\ufffd\u06b5\ufffd16\u03bb */\n\tG2D_SEQ_P01    = 0x5,\t\t\t/* pixel 1\ufffd\u06b5\ufffd16\u03bb */\n\n\t/* planar format or 8bpp rgb */\n\tG2D_SEQ_P3210  = 0x6,\t\t\t/* pixel 0\ufffd\u06b5\ufffd8\u03bb */\n\tG2D_SEQ_P0123  = 0x7,\t\t\t/* pixel 3\ufffd\u06b5\ufffd8\u03bb */\n\n\t/* for 4bpp rgb */\n\tG2D_SEQ_P76543210  = 0x8,\t\t\t/* 7,6,5,4,3,2,1,0 */\n\tG2D_SEQ_P67452301  = 0x9,\t\t\t/* 6,7,4,5,2,3,0,1 */\n\tG2D_SEQ_P10325476  = 0xA,\t\t\t/* 1,0,3,2,5,4,7,6 */\n\tG2D_SEQ_P01234567  = 0xB,\t\t\t/* 0,1,2,3,4,5,6,7 */\n\n\t/* for 2bpp rgb */\n\t/* 15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0 */\n\tG2D_SEQ_2BPP_BIG_BIG       = 0xC,\n\t/* 12,13,14,15,8,9,10,11,4,5,6,7,0,1,2,3 */\n\tG2D_SEQ_2BPP_BIG_LITTER    = 0xD,\n\t/* 3,2,1,0,7,6,5,4,11,10,9,8,15,14,13,12 */\n\tG2D_SEQ_2BPP_LITTER_BIG    = 0xE,\n\t/* 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 */\n\tG2D_SEQ_2BPP_LITTER_LITTER = 0xF,\n\n\t/* for 1bpp rgb */\n\t/* 31,30,29,28,27,26,25,24,23,22,21,20,\n\t * 19,18,17,16,15,14,13,12,11,10,9,8,7,\n\t * 6,5,4,3,2,1,0\n\t */\n\tG2D_SEQ_1BPP_BIG_BIG       = 0x10,\n\t/* 24,25,26,27,28,29,30,31,16,17,\n\t * 18,19,20,21,22,23,8,9,10,11,12,\n\t * 13,14,15,0,1,2,3,4,5,6,7\n\t */\n\tG2D_SEQ_1BPP_BIG_LITTER    = 0x11,\n\t/* 7,6,5,4,3,2,1,0,15,14,13,12,11,\n\t * 10,9,8,23,22,21,20,19,18,17,16,\n\t * 31,30,29,28,27,26,25,24\n\t */\n\tG2D_SEQ_1BPP_LITTER_BIG    = 0x12,\n\t/* 0,1,2,3,4,5,6,7,8,9,10,11,12,13,\n\t * 14,15,16,17,18,19,20,21,22,23,24,\n\t * 25,26,27,28,29,30,31\n\t */\n\tG2D_SEQ_1BPP_LITTER_LITTER = 0x13,\n} g2d_pixel_seq", "sline": 201, "docstring": "/* pixel sequence in double word */"}, "g2d_blt_flags_h": {"type": "Variable", "def": "typedef enum {\n\tG2D_BLT_NONE_H = 0x0,\n\tG2D_BLT_BLACKNESS,\n\tG2D_BLT_NOTMERGEPEN,\n\tG2D_BLT_MASKNOTPEN,\n\tG2D_BLT_NOTCOPYPEN,\n\tG2D_BLT_MASKPENNOT,\n\tG2D_BLT_NOT,\n\tG2D_BLT_XORPEN,\n\tG2D_BLT_NOTMASKPEN,\n\tG2D_BLT_MASKPEN,\n\tG2D_BLT_NOTXORPEN,\n\tG2D_BLT_NOP,\n\tG2D_BLT_MERGENOTPEN,\n\tG2D_BLT_COPYPEN,\n\tG2D_BLT_MERGEPENNOT,\n\tG2D_BLT_MERGEPEN,\n\tG2D_BLT_WHITENESS = 0x000000ff,\n\n\tG2D_ROT_90  = 0x00000100,\n\tG2D_ROT_180 = 0x00000200,\n\tG2D_ROT_270 = 0x00000300,\n\tG2D_ROT_0   = 0x00000400,\n\tG2D_ROT_H = 0x00001000,\n\tG2D_ROT_V = 0x00002000,\n\n/*\tG2D_SM_TDLR_1  =    0x10000000, */\n\tG2D_SM_DTLR_1 = 0x10000000,\n/*\tG2D_SM_TDRL_1  =    0x20000000, */\n/*\tG2D_SM_DTRL_1  =    0x30000000, */\n} g2d_blt_flags_h", "sline": 234, "docstring": "/*  */"}, "g2d_rop3_cmd_flag": {"type": "Variable", "def": "typedef enum {\n\tG2D_ROP3_BLACKNESS = 0x00,\n\tG2D_ROP3_NOTSRCERASE = 0x11,\n\tG2D_ROP3_NOTSRCCOPY = 0x33,\n\tG2D_ROP3_SRCERASE = 0x44,\n\tG2D_ROP3_DSTINVERT = 0x55,\n\tG2D_ROP3_PATINVERT = 0x5A,\n\tG2D_ROP3_SRCINVERT = 0x66,\n\tG2D_ROP3_SRCAND = 0x88,\n\tG2D_ROP3_MERGEPAINT = 0xBB,\n\tG2D_ROP3_MERGECOPY = 0xC0,\n\tG2D_ROP3_SRCCOPY = 0xCC,\n\tG2D_ROP3_SRCPAINT = 0xEE,\n\tG2D_ROP3_PATCOPY = 0xF0,\n\tG2D_ROP3_PATPAINT = 0xFB,\n\tG2D_ROP3_WHITENESS = 0xFF,\n} g2d_rop3_cmd_flag", "sline": 253, "docstring": "/* ROP3 command */"}, "g2d_fillrect_flags": {"type": "Variable", "def": "typedef enum {\n\tG2D_FIL_NONE\t\t\t= 0x00000000,\n\tG2D_FIL_PIXEL_ALPHA\t\t= 0x00000001,\n\tG2D_FIL_PLANE_ALPHA\t\t= 0x00000002,\n\tG2D_FIL_MULTI_ALPHA\t\t= 0x00000004,\n} g2d_fillrect_flags", "sline": 260}, "g2d_blt_flags": {"type": "Variable", "def": "typedef enum {\n\tG2D_BLT_NONE\t\t\t= 0x00000000,\n\tG2D_BLT_PIXEL_ALPHA\t\t= 0x00000001,\n\tG2D_BLT_PLANE_ALPHA\t\t= 0x00000002,\n\tG2D_BLT_MULTI_ALPHA\t\t= 0x00000004,\n\tG2D_BLT_SRC_COLORKEY\t= 0x00000008,\n\tG2D_BLT_DST_COLORKEY\t= 0x00000010,\n\tG2D_BLT_FLIP_HORIZONTAL\t= 0x00000020,\n\tG2D_BLT_FLIP_VERTICAL\t= 0x00000040,\n\tG2D_BLT_ROTATE90\t\t= 0x00000080,\n\tG2D_BLT_ROTATE180\t\t= 0x00000100,\n\tG2D_BLT_ROTATE270\t\t= 0x00000200,\n\tG2D_BLT_MIRROR45\t\t= 0x00000400,\n\tG2D_BLT_MIRROR135\t\t= 0x00000800,\n\tG2D_BLT_SRC_PREMULTIPLY\t= 0x00001000,\n\tG2D_BLT_DST_PREMULTIPLY\t= 0x00002000,\n} g2d_blt_flags", "sline": 278}, "g2d_alpha_mode_enh": {"type": "Variable", "def": "typedef enum {\n\tG2D_PIXEL_ALPHA,\n\tG2D_GLOBAL_ALPHA,\n\tG2D_MIXER_ALPHA,\n} g2d_alpha_mode_enh", "sline": 285, "docstring": "/* BLD LAYER ALPHA MODE*/"}, "g2d_rect.x": {"type": "Variable", "def": "__s32\t\tx", "sline": 289, "in_struct": "g2d_rect"}, "g2d_rect.y": {"type": "Variable", "def": "__s32\t\ty", "sline": 290, "in_struct": "g2d_rect"}, "g2d_rect.w": {"type": "Variable", "def": "__u32\t\tw", "sline": 291, "in_struct": "g2d_rect"}, "g2d_rect.h": {"type": "Variable", "def": "__u32\t\th", "sline": 292, "in_struct": "g2d_rect"}, "g2d_rect": {"type": "Variable", "def": "typedef struct {\n\t__s32\t\tx;\t\t/* left top point coordinate x */\n\t__s32\t\ty;\t\t/* left top point coordinate y */\n\t__u32\t\tw;\t\t/* rectangle width */\n\t__u32\t\th;\t\t/* rectangle height */\n} g2d_rect", "sline": 293, "docstring": "/* flip rectangle struct */"}, "g2d_color_gmt": {"type": "Variable", "def": "typedef enum {\n\tG2D_BT601,\n\tG2D_BT709,\n\tG2D_BT2020,\n} g2d_color_gmt", "sline": 300, "docstring": "/* g2d color gamut */"}, "g2d_image.addr": {"type": "Variable", "def": "__u32\t\taddr[3]", "sline": 304, "in_struct": "g2d_image"}, "g2d_image.w": {"type": "Variable", "def": "__u32\t\tw", "sline": 305, "in_struct": "g2d_image"}, "g2d_image.h": {"type": "Variable", "def": "__u32\t\th", "sline": 306, "in_struct": "g2d_image"}, "g2d_image.format": {"type": "Variable", "def": "g2d_data_fmt\tformat", "sline": 307, "in_struct": "g2d_image", "rels": [["g2d_data_fmt", null, "Typeof"]]}, "g2d_image.pixel_seq": {"type": "Variable", "def": "g2d_pixel_seq\tpixel_seq", "sline": 308, "in_struct": "g2d_image", "rels": [["g2d_pixel_seq", null, "Typeof"]]}, "g2d_image": {"type": "Variable", "def": "typedef struct {\n\t__u32\t\taddr[3];/* base addr of image frame buffer in byte */\n\t__u32\t\tw;\t/* width of image frame buffer in pixel */\n\t__u32\t\th;\t/* height of image frame buffer in pixel */\n\tg2d_data_fmt\tformat;\t/* pixel format of image frame buffer */\n\tg2d_pixel_seq\tpixel_seq;/* pixel sequence of image frame buffer */\n} g2d_image", "sline": 309, "docstring": "/* image struct */"}, "color_range": {"type": "Enum", "def": "enum color_range {\n\tCOLOR_RANGE_0_255 = 0,\n\tCOLOR_RANGE_16_235 = 1,\n}", "sline": 311}, "g2d_image_enh.bbuff": {"type": "Variable", "def": "int\t\t bbuff", "sline": 318, "in_struct": "g2d_image_enh"}, "g2d_image_enh.color": {"type": "Variable", "def": "__u32\t\t color", "sline": 319, "in_struct": "g2d_image_enh"}, "g2d_image_enh.format": {"type": "Variable", "def": "g2d_fmt_enh\t format", "sline": 320, "in_struct": "g2d_image_enh", "rels": [["g2d_fmt_enh", null, "Typeof"]]}, "g2d_image_enh.laddr": {"type": "Variable", "def": "__u32\t\t laddr[3]", "sline": 321, "in_struct": "g2d_image_enh"}, "g2d_image_enh.haddr": {"type": "Variable", "def": "__u32\t\t haddr[3]", "sline": 322, "in_struct": "g2d_image_enh"}, "g2d_image_enh.width": {"type": "Variable", "def": "__u32\t\t width", "sline": 323, "in_struct": "g2d_image_enh"}, "g2d_image_enh.height": {"type": "Variable", "def": "__u32\t\t height", "sline": 324, "in_struct": "g2d_image_enh"}, "g2d_image_enh.align": {"type": "Variable", "def": "__u32\t\t align[3]", "sline": 325, "in_struct": "g2d_image_enh"}, "g2d_image_enh.clip_rect": {"type": "Variable", "def": "g2d_rect\t clip_rect", "sline": 327, "in_struct": "g2d_image_enh", "rels": [["g2d_rect", null, "Typeof"]]}, "g2d_image_enh.gamut": {"type": "Variable", "def": "g2d_color_gmt\t gamut", "sline": 329, "in_struct": "g2d_image_enh", "rels": [["g2d_color_gmt", null, "Typeof"]]}, "g2d_image_enh.bpremul": {"type": "Variable", "def": "int\t\t bpremul", "sline": 330, "in_struct": "g2d_image_enh"}, "g2d_image_enh.alpha": {"type": "Variable", "def": "__u8\t\t alpha", "sline": 331, "in_struct": "g2d_image_enh"}, "g2d_image_enh.mode": {"type": "Variable", "def": "g2d_alpha_mode_enh mode", "sline": 332, "in_struct": "g2d_image_enh", "rels": [["g2d_alpha_mode_enh", null, "Typeof"]]}, "g2d_image_enh.fd": {"type": "Variable", "def": "int\t\t fd", "sline": 333, "in_struct": "g2d_image_enh"}, "g2d_image_enh.use_phy_addr": {"type": "Variable", "def": "__u32 use_phy_addr", "sline": 334, "in_struct": "g2d_image_enh"}, "g2d_image_enh.color_range": {"type": "Variable", "def": "enum color_range color_range", "sline": 335, "in_struct": "g2d_image_enh"}, "g2d_image_enh": {"type": "Variable", "def": "typedef struct {\n\tint\t\t bbuff;\n\t__u32\t\t color;\n\tg2d_fmt_enh\t format;\n\t__u32\t\t laddr[3];\n\t__u32\t\t haddr[3];\n\t__u32\t\t width;\n\t__u32\t\t height;\n\t__u32\t\t align[3];\n\n\tg2d_rect\t clip_rect;\n\n\tg2d_color_gmt\t gamut;\n\tint\t\t bpremul;\n\t__u8\t\t alpha;\n\tg2d_alpha_mode_enh mode;\n\tint\t\t fd;\n\t__u32 use_phy_addr;\n\tenum color_range color_range;\n} g2d_image_enh", "sline": 336, "docstring": "/* image struct */"}, "g2d_scan_order": {"type": "Enum", "def": "enum g2d_scan_order {\n\tG2D_SM_TDLR = 0x00000000,\n\tG2D_SM_TDRL = 0x00000001,\n\tG2D_SM_DTLR = 0x00000002,\n\tG2D_SM_DTRL = 0x00000003,\n}", "sline": 344}, "g2d_fillrect.flag": {"type": "Variable", "def": "g2d_fillrect_flags\t flag", "sline": 352, "in_struct": "g2d_fillrect", "rels": [["g2d_fillrect_flags", null, "Typeof"]]}, "g2d_fillrect.dst_image": {"type": "Variable", "def": "g2d_image\t\t\t dst_image", "sline": 353, "in_struct": "g2d_fillrect", "rels": [["g2d_image", null, "Typeof"]]}, "g2d_fillrect.dst_rect": {"type": "Variable", "def": "g2d_rect\t\t\t dst_rect", "sline": 354, "in_struct": "g2d_fillrect", "rels": [["g2d_rect", null, "Typeof"]]}, "g2d_fillrect.color": {"type": "Variable", "def": "__u32\t\t\t\t color", "sline": 356, "in_struct": "g2d_fillrect"}, "g2d_fillrect.alpha": {"type": "Variable", "def": "__u32\t\t\t\t alpha", "sline": 357, "in_struct": "g2d_fillrect"}, "g2d_fillrect": {"type": "Variable", "def": "typedef struct {\n\tg2d_fillrect_flags\t flag;\n\tg2d_image\t\t\t dst_image;\n\tg2d_rect\t\t\t dst_rect;\n\n\t__u32\t\t\t\t color;\t\t/* fill color */\n\t__u32\t\t\t\t alpha;\t\t/* plane alpha value */\n\n} g2d_fillrect", "sline": 359}, "g2d_fillrect_h.dst_image_h": {"type": "Variable", "def": "g2d_image_enh dst_image_h", "sline": 362, "in_struct": "g2d_fillrect_h", "rels": [["g2d_image_enh", null, "Typeof"]]}, "g2d_fillrect_h": {"type": "Variable", "def": "typedef struct {\n\tg2d_image_enh dst_image_h;\n} g2d_fillrect_h", "sline": 363}, "g2d_blt.flag": {"type": "Variable", "def": "g2d_blt_flags\t\tflag", "sline": 366, "in_struct": "g2d_blt", "rels": [["g2d_blt_flags", null, "Typeof"]]}, "g2d_blt.src_image": {"type": "Variable", "def": "g2d_image\t\tsrc_image", "sline": 367, "in_struct": "g2d_blt", "rels": [["g2d_image", null, "Typeof"]]}, "g2d_blt.src_rect": {"type": "Variable", "def": "g2d_rect\t\tsrc_rect", "sline": 368, "in_struct": "g2d_blt", "rels": [["g2d_rect", null, "Typeof"]]}, "g2d_blt.dst_image": {"type": "Variable", "def": "g2d_image\t\tdst_image", "sline": 370, "in_struct": "g2d_blt", "rels": [["g2d_image", null, "Typeof"]]}, "g2d_blt.dst_x": {"type": "Variable", "def": "__s32\t\t\tdst_x", "sline": 372, "in_struct": "g2d_blt"}, "g2d_blt.dst_y": {"type": "Variable", "def": "__s32\t\t\tdst_y", "sline": 374, "in_struct": "g2d_blt"}, "g2d_blt.color": {"type": "Variable", "def": "__u32\t\t\tcolor", "sline": 376, "in_struct": "g2d_blt"}, "g2d_blt.alpha": {"type": "Variable", "def": "__u32\t\t\talpha", "sline": 377, "in_struct": "g2d_blt"}, "g2d_blt": {"type": "Variable", "def": "typedef struct {\n\tg2d_blt_flags\t\tflag;\n\tg2d_image\t\tsrc_image;\n\tg2d_rect\t\tsrc_rect;\n\n\tg2d_image\t\tdst_image;\n\t/* left top point coordinate x of dst rect */\n\t__s32\t\t\tdst_x;\n\t/* left top point coordinate y of dst rect */\n\t__s32\t\t\tdst_y;\n\n\t__u32\t\t\tcolor;\t\t/* colorkey color */\n\t__u32\t\t\talpha;\t\t/* plane alpha value */\n\n} g2d_blt", "sline": 379}, "g2d_blt_h.flag_h": {"type": "Variable", "def": "g2d_blt_flags_h flag_h", "sline": 382, "in_struct": "g2d_blt_h", "rels": [["g2d_blt_flags_h", null, "Typeof"]]}, "g2d_blt_h.src_image_h": {"type": "Variable", "def": "g2d_image_enh src_image_h", "sline": 383, "in_struct": "g2d_blt_h", "rels": [["g2d_image_enh", null, "Typeof"]]}, "g2d_blt_h.dst_image_h": {"type": "Variable", "def": "g2d_image_enh dst_image_h", "sline": 384, "in_struct": "g2d_blt_h", "rels": [["g2d_image_enh", null, "Typeof"]]}, "g2d_blt_h": {"type": "Variable", "def": "typedef struct {\n\tg2d_blt_flags_h flag_h;\n\tg2d_image_enh src_image_h;\n\tg2d_image_enh dst_image_h;\n} g2d_blt_h", "sline": 385}, "g2d_stretchblt.flag": {"type": "Variable", "def": "g2d_blt_flags\t\t\t flag", "sline": 388, "in_struct": "g2d_stretchblt", "rels": [["g2d_blt_flags", null, "Typeof"]]}, "g2d_stretchblt.src_image": {"type": "Variable", "def": "g2d_image\t\t\t src_image", "sline": 389, "in_struct": "g2d_stretchblt", "rels": [["g2d_image", null, "Typeof"]]}, "g2d_stretchblt.src_rect": {"type": "Variable", "def": "g2d_rect\t\t\t src_rect", "sline": 390, "in_struct": "g2d_stretchblt", "rels": [["g2d_rect", null, "Typeof"]]}, "g2d_stretchblt.dst_image": {"type": "Variable", "def": "g2d_image\t\t\t dst_image", "sline": 392, "in_struct": "g2d_stretchblt", "rels": [["g2d_image", null, "Typeof"]]}, "g2d_stretchblt.dst_rect": {"type": "Variable", "def": "g2d_rect\t\t\t dst_rect", "sline": 393, "in_struct": "g2d_stretchblt", "rels": [["g2d_rect", null, "Typeof"]]}, "g2d_stretchblt.color": {"type": "Variable", "def": "__u32\t\t\t\t color", "sline": 395, "in_struct": "g2d_stretchblt"}, "g2d_stretchblt.alpha": {"type": "Variable", "def": "__u32\t\t\t\t alpha", "sline": 396, "in_struct": "g2d_stretchblt"}, "g2d_stretchblt": {"type": "Variable", "def": "typedef struct {\n\tg2d_blt_flags\t\t\t flag;\n\tg2d_image\t\t\t src_image;\n\tg2d_rect\t\t\t src_rect;\n\n\tg2d_image\t\t\t dst_image;\n\tg2d_rect\t\t\t dst_rect;\n\n\t__u32\t\t\t\t color;\t\t/* colorkey color */\n\t__u32\t\t\t\t alpha;\t\t/* plane alpha value */\n\n\n} g2d_stretchblt", "sline": 399}, "g2d_maskblt.back_flag": {"type": "Variable", "def": "g2d_rop3_cmd_flag back_flag", "sline": 402, "in_struct": "g2d_maskblt", "rels": [["g2d_rop3_cmd_flag", null, "Typeof"]]}, "g2d_maskblt.fore_flag": {"type": "Variable", "def": "g2d_rop3_cmd_flag fore_flag", "sline": 403, "in_struct": "g2d_maskblt", "rels": [["g2d_rop3_cmd_flag", null, "Typeof"]]}, "g2d_maskblt.dst_image_h": {"type": "Variable", "def": "g2d_image_enh dst_image_h", "sline": 405, "in_struct": "g2d_maskblt", "rels": [["g2d_image_enh", null, "Typeof"]]}, "g2d_maskblt.src_image_h": {"type": "Variable", "def": "g2d_image_enh src_image_h", "sline": 406, "in_struct": "g2d_maskblt", "rels": [["g2d_image_enh", null, "Typeof"]]}, "g2d_maskblt.ptn_image_h": {"type": "Variable", "def": "g2d_image_enh ptn_image_h", "sline": 407, "in_struct": "g2d_maskblt", "rels": [["g2d_image_enh", null, "Typeof"]]}, "g2d_maskblt.mask_image_h": {"type": "Variable", "def": "g2d_image_enh mask_image_h", "sline": 408, "in_struct": "g2d_maskblt", "rels": [["g2d_image_enh", null, "Typeof"]]}, "g2d_maskblt": {"type": "Variable", "def": "typedef struct {\n\tg2d_rop3_cmd_flag back_flag;\n\tg2d_rop3_cmd_flag fore_flag;\n\n\tg2d_image_enh dst_image_h;\n\tg2d_image_enh src_image_h;\n\tg2d_image_enh ptn_image_h;\n\tg2d_image_enh mask_image_h;\n\n} g2d_maskblt", "sline": 410}, "g2d_bld_cmd_flag": {"type": "Variable", "def": "typedef enum {\n\tG2D_BLD_CLEAR = 0x00000001,\n\tG2D_BLD_COPY = 0x00000002,\n\tG2D_BLD_DST = 0x00000003,\n\tG2D_BLD_SRCOVER = 0x00000004,\n\tG2D_BLD_DSTOVER = 0x00000005,\n\tG2D_BLD_SRCIN = 0x00000006,\n\tG2D_BLD_DSTIN = 0x00000007,\n\tG2D_BLD_SRCOUT = 0x00000008,\n\tG2D_BLD_DSTOUT = 0x00000009,\n\tG2D_BLD_SRCATOP = 0x0000000a,\n\tG2D_BLD_DSTATOP = 0x0000000b,\n\tG2D_BLD_XOR = 0x0000000c,\n\tG2D_CK_SRC = 0x00010000,\n\tG2D_CK_DST = 0x00020000,\n} g2d_bld_cmd_flag", "sline": 428, "docstring": "/* Porter Duff BLD command*/"}, "g2d_palette.pbuffer": {"type": "Variable", "def": "__u32\t\t*pbuffer", "sline": 431, "in_struct": "g2d_palette"}, "g2d_palette.size": {"type": "Variable", "def": "__u32\t\t size", "sline": 432, "in_struct": "g2d_palette"}, "g2d_palette": {"type": "Variable", "def": "typedef struct {\n\t__u32\t\t*pbuffer;\n\t__u32\t\t size;\n\n} g2d_palette", "sline": 434}, "g2d_cache_range.start": {"type": "Variable", "def": "long\tstart", "sline": 439, "in_struct": "g2d_cache_range"}, "g2d_cache_range.end": {"type": "Variable", "def": "long\tend", "sline": 440, "in_struct": "g2d_cache_range"}, "g2d_cache_range": {"type": "Variable", "def": "typedef struct {\n\tlong\tstart;\n\tlong\tend;\n} g2d_cache_range", "sline": 441}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver.h:444:9).match_rule": {"type": "Variable", "def": "bool match_rule", "sline": 445, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver.h:444:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver.h:444:9).max_color": {"type": "Variable", "def": "__u32 max_color", "sline": 447, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver.h:444:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver.h:444:9).min_color": {"type": "Variable", "def": "__u32 min_color", "sline": 448, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver.h:444:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver.h:444:9)": {"type": "Struct", "def": "struct {\n\tbool match_rule;\n/*\tint match_rule; */\n\t__u32 max_color;\n\t__u32 min_color;\n}", "sline": 444, "docstring": "/* CK PARA struct */", "body": "bool match_rule\n__u32 max_color\n__u32 min_color\n"}, "g2d_ck": {"type": "Variable", "def": "typedef struct {\n\tbool match_rule;\n/*\tint match_rule; */\n\t__u32 max_color;\n\t__u32 min_color;\n} g2d_ck", "sline": 449, "docstring": "/* CK PARA struct */"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver.h:451:9).bld_cmd": {"type": "Variable", "def": "g2d_bld_cmd_flag bld_cmd", "sline": 452, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver.h:451:9)", "rels": [["g2d_bld_cmd_flag", null, "Typeof"]]}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver.h:451:9).dst_image_h": {"type": "Variable", "def": "g2d_image_enh dst_image_h", "sline": 453, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver.h:451:9)", "rels": [["g2d_image_enh", null, "Typeof"]]}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver.h:451:9).src_image_h": {"type": "Variable", "def": "g2d_image_enh src_image_h", "sline": 454, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver.h:451:9)", "rels": [["g2d_image_enh", null, "Typeof"]]}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver.h:451:9).ck_para": {"type": "Variable", "def": "g2d_ck ck_para", "sline": 455, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver.h:451:9)", "rels": [["g2d_ck", null, "Typeof"]]}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver.h:451:9)": {"type": "Struct", "def": "struct {\n\tg2d_bld_cmd_flag bld_cmd;\n\tg2d_image_enh dst_image_h;\n\tg2d_image_enh src_image_h;\n\tg2d_ck ck_para;\n}", "sline": 451, "body": "g2d_bld_cmd_flag bld_cmd\ng2d_image_enh dst_image_h\ng2d_image_enh src_image_h\ng2d_ck ck_para\n"}, "g2d_bld": {"type": "Variable", "def": "typedef struct {\n\tg2d_bld_cmd_flag bld_cmd;\n\tg2d_image_enh dst_image_h;\n\tg2d_image_enh src_image_h;\n\tg2d_ck ck_para;\n} g2d_bld", "sline": 456}, "g2d_operation_flag": {"type": "Variable", "def": "typedef enum {\n\tOP_FILLRECT = 0x1,\n\tOP_BITBLT = 0x2,\n\tOP_BLEND = 0x4,\n\tOP_MASK = 0x8,\n\tOP_SPLIT_MEM = 0x10,\n} g2d_operation_flag", "sline": 464}, "mixer_para.op_flag": {"type": "Variable", "def": "g2d_operation_flag op_flag", "sline": 470, "in_struct": "mixer_para", "rels": [["g2d_operation_flag", null, "Typeof"]]}, "mixer_para.flag_h": {"type": "Variable", "def": "g2d_blt_flags_h flag_h", "sline": 471, "in_struct": "mixer_para", "rels": [["g2d_blt_flags_h", null, "Typeof"]]}, "mixer_para.back_flag": {"type": "Variable", "def": "g2d_rop3_cmd_flag back_flag", "sline": 472, "in_struct": "mixer_para", "rels": [["g2d_rop3_cmd_flag", null, "Typeof"]]}, "mixer_para.fore_flag": {"type": "Variable", "def": "g2d_rop3_cmd_flag fore_flag", "sline": 473, "in_struct": "mixer_para", "rels": [["g2d_rop3_cmd_flag", null, "Typeof"]]}, "mixer_para.bld_cmd": {"type": "Variable", "def": "g2d_bld_cmd_flag bld_cmd", "sline": 474, "in_struct": "mixer_para", "rels": [["g2d_bld_cmd_flag", null, "Typeof"]]}, "mixer_para.src_image_h": {"type": "Variable", "def": "g2d_image_enh src_image_h", "sline": 475, "in_struct": "mixer_para", "rels": [["g2d_image_enh", null, "Typeof"]]}, "mixer_para.dst_image_h": {"type": "Variable", "def": "g2d_image_enh dst_image_h", "sline": 476, "in_struct": "mixer_para", "rels": [["g2d_image_enh", null, "Typeof"]]}, "mixer_para.ptn_image_h": {"type": "Variable", "def": "g2d_image_enh ptn_image_h", "sline": 477, "in_struct": "mixer_para", "rels": [["g2d_image_enh", null, "Typeof"]]}, "mixer_para.mask_image_h": {"type": "Variable", "def": "g2d_image_enh mask_image_h", "sline": 478, "in_struct": "mixer_para", "rels": [["g2d_image_enh", null, "Typeof"]]}, "mixer_para.ck_para": {"type": "Variable", "def": "g2d_ck ck_para", "sline": 479, "in_struct": "mixer_para", "rels": [["g2d_ck", null, "Typeof"]]}, "mixer_para": {"type": "Struct", "def": "struct mixer_para {\n\tg2d_operation_flag op_flag;\n\tg2d_blt_flags_h flag_h;\n\tg2d_rop3_cmd_flag back_flag;\n\tg2d_rop3_cmd_flag fore_flag;\n\tg2d_bld_cmd_flag bld_cmd;\n\tg2d_image_enh src_image_h;\n\tg2d_image_enh dst_image_h;\n\tg2d_image_enh ptn_image_h;\n\tg2d_image_enh mask_image_h;\n\tg2d_ck ck_para;\n}", "sline": 469, "docstring": "/**", "body": "g2d_operation_flag op_flag\ng2d_blt_flags_h flag_h\ng2d_rop3_cmd_flag back_flag\ng2d_rop3_cmd_flag fore_flag\ng2d_bld_cmd_flag bld_cmd\ng2d_image_enh src_image_h\ng2d_image_enh dst_image_h\ng2d_image_enh ptn_image_h\ng2d_image_enh mask_image_h\ng2d_ck ck_para\n"}, "g2d_cmd": {"type": "Variable", "def": "typedef enum {\n\tG2D_CMD_BITBLT\t\t\t=\t0x50,\n\tG2D_CMD_FILLRECT\t\t=\t0x51,\n\tG2D_CMD_STRETCHBLT\t\t=\t0x52,\n\tG2D_CMD_PALETTE_TBL\t\t=\t0x53,\n\tG2D_CMD_QUEUE\t\t\t=\t0x54,\n\tG2D_CMD_BITBLT_H\t\t=\t0x55,\n\tG2D_CMD_FILLRECT_H\t\t=\t0x56,\n\tG2D_CMD_BLD_H\t\t\t=\t0x57,\n\tG2D_CMD_MASK_H\t\t\t=\t0x58,\n\n\tG2D_CMD_MEM_REQUEST\t\t=\t0x59,\n\tG2D_CMD_MEM_RELEASE\t\t=\t0x5A,\n\tG2D_CMD_MEM_GETADR\t\t=\t0x5B,\n\tG2D_CMD_MEM_SELIDX\t\t=\t0x5C,\n\tG2D_CMD_MEM_FLUSH_CACHE\t\t=\t0x5D,\n\tG2D_CMD_INVERTED_ORDER\t\t=\t0x5E,\n\tG2D_CMD_MIXER_TASK = 0x5F,\n\tG2D_CMD_CREATE_TASK = SUNXI_G2D_IOW(0x1, struct mixer_para),\n\tG2D_CMD_TASK_APPLY = SUNXI_G2D_IOW(0x2, struct mixer_para),\n\tG2D_CMD_TASK_DESTROY = SUNXI_G2D_IOW(0x3, unsigned int),\n\tG2D_CMD_TASK_GET_PARA = SUNXI_G2D_IOR(0x4, struct mixer_para),\n\n} g2d_cmd", "sline": 511}, "carbit_updater/lv_drivers/display/g2d_driver.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/g2d_driver.h"}}, "carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar.h": {"lv_btnmatrix": {"type": "Variable", "def": "#include ../../../widgets/lv_btnmatrix.h", "sline": 16}, "lv_calendar_date_t.year": {"type": "Variable", "def": "uint16_t year", "sline": 32, "in_struct": "lv_calendar_date_t"}, "lv_calendar_date_t.month": {"type": "Variable", "def": "int8_t month", "sline": 33, "in_struct": "lv_calendar_date_t"}, "lv_calendar_date_t.day": {"type": "Variable", "def": "int8_t day", "sline": 34, "in_struct": "lv_calendar_date_t"}, "lv_calendar_date_t": {"type": "Variable", "def": "typedef struct {\n    uint16_t year;\n    int8_t month;  /** 1..12*/\n    int8_t day;    /** 1..31*/\n} lv_calendar_date_t", "sline": 35, "docstring": "/**"}, "lv_calendar_t.obj": {"type": "Variable", "def": "lv_obj_t obj", "sline": 39, "in_struct": "lv_calendar_t"}, "lv_calendar_t.btnm": {"type": "Variable", "def": "lv_obj_t * btnm", "sline": 40, "in_struct": "lv_calendar_t"}, "lv_calendar_t.today": {"type": "Variable", "def": "lv_calendar_date_t today", "sline": 42, "in_struct": "lv_calendar_t", "rels": [["lv_calendar_date_t", null, "Typeof"]]}, "lv_calendar_t.showed_date": {"type": "Variable", "def": "lv_calendar_date_t showed_date", "sline": 43, "in_struct": "lv_calendar_t", "rels": [["lv_calendar_date_t", null, "Typeof"]]}, "lv_calendar_t.highlighted_dates": {"type": "Variable", "def": "lv_calendar_date_t *\n    highlighted_dates", "sline": 45, "in_struct": "lv_calendar_t"}, "lv_calendar_t.highlighted_dates_num": {"type": "Variable", "def": "uint16_t highlighted_dates_num", "sline": 46, "in_struct": "lv_calendar_t"}, "lv_calendar_t.map": {"type": "Variable", "def": "const char * map[8 * 7]", "sline": 47, "in_struct": "lv_calendar_t"}, "lv_calendar_t.nums": {"type": "Variable", "def": "char nums [7 * 6][4]", "sline": 48, "in_struct": "lv_calendar_t"}, "lv_calendar_t": {"type": "Variable", "def": "typedef struct {\n    lv_obj_t obj;\n    lv_obj_t * btnm;\n    /*New data for this type*/\n    lv_calendar_date_t today;               /*Date of today*/\n    lv_calendar_date_t showed_date;         /*Currently visible month (day is ignored)*/\n    lv_calendar_date_t *\n    highlighted_dates; /*Apply different style on these days (pointer to an array defined by the user)*/\n    uint16_t highlighted_dates_num;          /*Number of elements in `highlighted_days`*/\n    const char * map[8 * 7];\n    char nums [7 * 6][4];\n} lv_calendar_t", "sline": 49, "docstring": "/*Data of calendar*/"}, "lv_calendar_class": {"type": "Variable", "def": "extern const lv_obj_class_t lv_calendar_class", "sline": 51}, "lv_calendar_create": {"type": "Function", "def": "lv_obj_t * lv_calendar_create(lv_obj_t * parent)", "sline": 57}, "lv_calendar_set_today_date": {"type": "Function", "def": "void lv_calendar_set_today_date(lv_obj_t * obj, uint32_t year, uint32_t month, uint32_t day)", "sline": 74}, "lv_calendar_set_showed_date": {"type": "Function", "def": "void lv_calendar_set_showed_date(lv_obj_t * obj, uint32_t year, uint32_t month)", "sline": 82}, "lv_calendar_set_highlighted_dates": {"type": "Function", "def": "void lv_calendar_set_highlighted_dates(lv_obj_t * obj, lv_calendar_date_t highlighted[], uint16_t date_num)", "sline": 91}, "lv_calendar_set_day_names": {"type": "Function", "def": "void lv_calendar_set_day_names(lv_obj_t * obj, const char ** day_names)", "sline": 100}, "lv_calendar_get_btnmatrix": {"type": "Function", "def": "lv_obj_t * lv_calendar_get_btnmatrix(const lv_obj_t * obj)", "sline": 112}, "lv_calendar_get_today_date": {"type": "Function", "def": "const lv_calendar_date_t * lv_calendar_get_today_date(const lv_obj_t * calendar)", "sline": 119}, "lv_calendar_get_showed_date": {"type": "Function", "def": "const lv_calendar_date_t * lv_calendar_get_showed_date(const lv_obj_t * calendar)", "sline": 126}, "lv_calendar_get_highlighted_dates": {"type": "Function", "def": "lv_calendar_date_t * lv_calendar_get_highlighted_dates(const lv_obj_t * calendar)", "sline": 133}, "lv_calendar_get_highlighted_dates_num": {"type": "Function", "def": "uint16_t lv_calendar_get_highlighted_dates_num(const lv_obj_t * calendar)", "sline": 140}, "lv_calendar_get_pressed_date": {"type": "Function", "def": "lv_res_t lv_calendar_get_pressed_date(const lv_obj_t * calendar, lv_calendar_date_t * date)", "sline": 148}, "carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/calendar/lv_calendar.h"}}, "carbit_updater/lvgl/src/font/lv_font_montserrat_40.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_montserrat_40.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_montserrat_40.c"}}, "carbit_updater/lvgl/src/extra/widgets/chart/lv_chart.c": {"lv_chart": {"type": "Variable", "def": "#include lv_chart.h", "sline": 9, "include": ["carbit_updater/lvgl/src/extra/widgets/chart/lv_chart.h", null]}, "lv_assert": {"type": "Variable", "def": "#include ../../../misc/lv_assert.h", "sline": 12}, "lv_chart_constructor": {"type": "Function", "def": "static void lv_chart_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 640, "body": "{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_chart_t * chart = (lv_chart_t *)obj;\n\n    _lv_ll_init(&chart->series_ll, sizeof(lv_chart_series_t));\n    _lv_ll_init(&chart->cursor_ll, sizeof(lv_chart_cursor_t));\n\n    chart->ymin[0] = 0;\n    chart->xmin[0] = 0;\n    chart->ymin[1] = 0;\n    chart->xmin[1] = 0;\n    chart->ymax[0] = 100;\n    chart->xmax[0] = 100;\n    chart->ymax[1] = 100;\n    chart->xmax[1] = 100;\n\n    chart->hdiv_cnt    = LV_CHART_HDIV_DEF;\n    chart->vdiv_cnt    = LV_CHART_VDIV_DEF;\n    chart->point_cnt   = LV_CHART_POINT_CNT_DEF;\n    chart->pressed_point_id  = LV_CHART_POINT_NONE;\n    chart->type        = LV_CHART_TYPE_LINE;\n    chart->update_mode = LV_CHART_UPDATE_MODE_SHIFT;\n    chart->zoom_x      = LV_IMG_ZOOM_NONE;\n    chart->zoom_y      = LV_IMG_ZOOM_NONE;\n\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}"}, "lv_chart_destructor": {"type": "Function", "def": "static void lv_chart_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 671, "body": "{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_chart_t * chart = (lv_chart_t *)obj;\n    lv_chart_series_t * ser;\n    while(chart->series_ll.head) {\n        ser = _lv_ll_get_head(&chart->series_ll);\n\n        if(!ser->y_ext_buf_assigned) lv_mem_free(ser->y_points);\n\n        _lv_ll_remove(&chart->series_ll, ser);\n        lv_mem_free(ser);\n    }\n    _lv_ll_clear(&chart->series_ll);\n\n    lv_chart_cursor_t * cur;\n    while(chart->cursor_ll.head) {\n        cur = _lv_ll_get_head(&chart->cursor_ll);\n        _lv_ll_remove(&chart->cursor_ll, cur);\n        lv_mem_free(cur);\n    }\n    _lv_ll_clear(&chart->cursor_ll);\n\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}"}, "lv_chart_event": {"type": "Function", "def": "static void lv_chart_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 699, "body": "{\n    LV_UNUSED(class_p);\n\n    /*Call the ancestor's event handler*/\n    lv_res_t res;\n\n    res = lv_obj_event_base(MY_CLASS, e);\n    if(res != LV_RES_OK) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(code == LV_EVENT_PRESSED) {\n        lv_indev_t * indev = lv_indev_get_act();\n        lv_point_t p;\n        lv_indev_get_point(indev, &p);\n\n        p.x -= obj->coords.x1;\n        uint32_t id = get_index_from_x(obj, p.x + lv_obj_get_scroll_left(obj));\n        if(id != chart->pressed_point_id) {\n            invalidate_point(obj, id);\n            invalidate_point(obj, chart->pressed_point_id);\n            chart->pressed_point_id = id;\n            lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n        }\n    }\n    else if(code == LV_EVENT_RELEASED) {\n        invalidate_point(obj, chart->pressed_point_id);\n        chart->pressed_point_id = LV_CHART_POINT_NONE;\n    }\n    else if(code == LV_EVENT_SIZE_CHANGED) {\n        lv_obj_refresh_self_size(obj);\n    }\n    else if(code == LV_EVENT_REFR_EXT_DRAW_SIZE) {\n        lv_event_set_ext_draw_size(e, LV_MAX4(chart->tick[0].draw_size, chart->tick[1].draw_size, chart->tick[2].draw_size,\n                                              chart->tick[3].draw_size));\n    }\n    else if(code == LV_EVENT_GET_SELF_SIZE) {\n        lv_point_t * p = lv_event_get_param(e);\n        p->x = ((int32_t)lv_obj_get_content_width(obj) * chart->zoom_x) >> 8;\n        p->y = ((int32_t)lv_obj_get_content_height(obj) * chart->zoom_y) >> 8;\n    }\n    else if(code == LV_EVENT_DRAW_MAIN) {\n        const lv_area_t * clip_area = lv_event_get_param(e);\n        draw_div_lines(obj, clip_area);\n        draw_axes(obj, clip_area);\n\n        if(_lv_ll_is_empty(&chart->series_ll) == false) {\n            if(chart->type == LV_CHART_TYPE_LINE) draw_series_line(obj, clip_area);\n            else if(chart->type == LV_CHART_TYPE_BAR) draw_series_bar(obj, clip_area);\n            else if(chart->type == LV_CHART_TYPE_SCATTER) draw_series_scatter(obj, clip_area);\n        }\n\n        draw_cursors(obj, clip_area);\n    }\n}"}, "draw_div_lines": {"type": "Function", "def": "static void draw_div_lines(lv_obj_t * obj, const lv_area_t * clip_area)", "sline": 758, "body": "{\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n\n    lv_area_t series_mask;\n    bool mask_ret = _lv_area_intersect(&series_mask, &obj->coords, clip_area);\n    if(mask_ret == false) return;\n\n    int16_t i;\n    int16_t i_start;\n    int16_t i_end;\n    lv_point_t p1;\n    lv_point_t p2;\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n    lv_coord_t pad_left = lv_obj_get_style_pad_left(obj, LV_PART_MAIN) + border_width;\n    lv_coord_t pad_top = lv_obj_get_style_pad_top(obj, LV_PART_MAIN) + border_width;\n    lv_coord_t w     = ((int32_t)lv_obj_get_content_width(obj) * chart->zoom_x) >> 8;\n    lv_coord_t h     = ((int32_t)lv_obj_get_content_height(obj) * chart->zoom_y) >> 8;\n\n    lv_draw_line_dsc_t line_dsc;\n    lv_draw_line_dsc_init(&line_dsc);\n    lv_obj_init_draw_line_dsc(obj, LV_PART_MAIN, &line_dsc);\n\n    lv_obj_draw_part_dsc_t part_draw_dsc;\n    lv_obj_draw_dsc_init(&part_draw_dsc, clip_area);\n    part_draw_dsc.part = LV_PART_MAIN;\n    part_draw_dsc.class_p = MY_CLASS;\n    part_draw_dsc.type = LV_CHART_DRAW_PART_DIV_LINE_INIT;\n    part_draw_dsc.line_dsc = &line_dsc;\n    part_draw_dsc.id = 0xFFFFFFFF;\n    part_draw_dsc.p1 = NULL;\n    part_draw_dsc.p2 = NULL;\n    lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n\n    lv_opa_t border_opa = lv_obj_get_style_border_opa(obj, LV_PART_MAIN);\n    lv_coord_t border_w = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n    lv_border_side_t border_side = lv_obj_get_style_border_side(obj, LV_PART_MAIN);\n\n    lv_coord_t scroll_left = lv_obj_get_scroll_left(obj);\n    lv_coord_t scroll_top = lv_obj_get_scroll_top(obj);\n    if(chart->hdiv_cnt != 0) {\n        lv_coord_t y_ofs = obj->coords.y1 + pad_top - scroll_top;\n        p1.x = obj->coords.x1;\n        p2.x = obj->coords.x2;\n\n        i_start = 0;\n        i_end = chart->hdiv_cnt;\n        if(border_opa > LV_OPA_MIN && border_w > 0) {\n            if((border_side & LV_BORDER_SIDE_TOP) && (lv_obj_get_style_pad_top(obj, LV_PART_MAIN) == 0)) i_start++;\n            if((border_side & LV_BORDER_SIDE_BOTTOM) && (lv_obj_get_style_pad_bottom(obj, LV_PART_MAIN) == 0)) i_end--;\n        }\n\n        for(i = i_start; i < i_end; i++) {\n            p1.y = (int32_t)((int32_t)h * i) / (chart->hdiv_cnt - 1);\n            p1.y += y_ofs;\n            p2.y = p1.y;\n\n            part_draw_dsc.class_p = MY_CLASS;\n            part_draw_dsc.type = LV_CHART_DRAW_PART_DIV_LINE_HOR;\n            part_draw_dsc.p1 = &p1;\n            part_draw_dsc.p2 = &p2;\n            part_draw_dsc.id = i;\n\n            lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n            lv_draw_line(&p1, &p2, &series_mask, &line_dsc);\n            lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n        }\n    }\n\n    if(chart->vdiv_cnt != 0) {\n        lv_coord_t x_ofs = obj->coords.x1 + pad_left - scroll_left;\n        p1.y = obj->coords.y1;\n        p2.y = obj->coords.y2;\n        i_start = 0;\n        i_end = chart->vdiv_cnt;\n        if(border_opa > LV_OPA_MIN && border_w > 0) {\n            if((border_side & LV_BORDER_SIDE_LEFT) && (lv_obj_get_style_pad_left(obj, LV_PART_MAIN) == 0)) i_start++;\n            if((border_side & LV_BORDER_SIDE_RIGHT) && (lv_obj_get_style_pad_right(obj, LV_PART_MAIN) == 0)) i_end--;\n        }\n\n        for(i = i_start; i < i_end; i++) {\n            p1.x = (int32_t)((int32_t)w * i) / (chart->vdiv_cnt - 1);\n            p1.x += x_ofs;\n            p2.x = p1.x;\n\n            part_draw_dsc.class_p = MY_CLASS;\n            part_draw_dsc.type = LV_CHART_DRAW_PART_DIV_LINE_VER;\n            part_draw_dsc.p1 = &p1;\n            part_draw_dsc.p2 = &p2;\n            part_draw_dsc.id = i;\n\n            lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n            lv_draw_line(&p1, &p2, &series_mask, &line_dsc);\n            lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n        }\n    }\n\n    part_draw_dsc.id = 0xFFFFFFFF;\n    part_draw_dsc.p1 = NULL;\n    part_draw_dsc.p2 = NULL;\n    lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n\n}"}, "draw_series_line": {"type": "Function", "def": "static void draw_series_line(lv_obj_t * obj, const lv_area_t * clip_area)", "sline": 862, "body": "{\n    lv_area_t com_area;\n    if(_lv_area_intersect(&com_area, &obj->coords, clip_area) == false) return;\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(chart->point_cnt < 2) return;\n\n    uint16_t i;\n    lv_point_t p1;\n    lv_point_t p2;\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n    lv_coord_t pad_left = lv_obj_get_style_pad_left(obj, LV_PART_MAIN) + border_width;\n    lv_coord_t pad_top = lv_obj_get_style_pad_top(obj, LV_PART_MAIN) + border_width;\n    lv_coord_t w     = ((int32_t)lv_obj_get_content_width(obj) * chart->zoom_x) >> 8;\n    lv_coord_t h     = ((int32_t)lv_obj_get_content_height(obj) * chart->zoom_y) >> 8;\n    lv_coord_t x_ofs = obj->coords.x1 + pad_left - lv_obj_get_scroll_left(obj);\n    lv_coord_t y_ofs = obj->coords.y1 + pad_top - lv_obj_get_scroll_top(obj);\n    lv_chart_series_t * ser;\n\n    lv_area_t series_mask;\n    bool mask_ret = _lv_area_intersect(&series_mask, &obj->coords, clip_area);\n    if(mask_ret == false) return;\n\n    lv_draw_line_dsc_t line_dsc_default;\n    lv_draw_line_dsc_init(&line_dsc_default);\n    lv_obj_init_draw_line_dsc(obj, LV_PART_ITEMS, &line_dsc_default);\n\n    lv_draw_rect_dsc_t point_dsc_default;\n    lv_draw_rect_dsc_init(&point_dsc_default);\n    lv_obj_init_draw_rect_dsc(obj, LV_PART_INDICATOR, &point_dsc_default);\n\n    lv_coord_t point_w = lv_obj_get_style_width(obj, LV_PART_INDICATOR) / 2;\n    lv_coord_t point_h = lv_obj_get_style_height(obj, LV_PART_INDICATOR) / 2;\n\n    /*Do not bother with line ending is the point will over it*/\n    if(LV_MIN(point_w, point_h) > line_dsc_default.width / 2) line_dsc_default.raw_end = 1;\n    if(line_dsc_default.width == 1) line_dsc_default.raw_end = 1;\n\n    /*If there are mire points than pixels draw only vertical lines*/\n    bool crowded_mode = chart->point_cnt >= w ? true : false;\n\n    /*Go through all data lines*/\n    _LV_LL_READ_BACK(&chart->series_ll, ser) {\n        if(ser->hidden) continue;\n        line_dsc_default.color = ser->color;\n        point_dsc_default.bg_color = ser->color;\n\n        lv_coord_t start_point = chart->update_mode == LV_CHART_UPDATE_MODE_SHIFT ? ser->start_point : 0;\n\n        p1.x = x_ofs;\n        p2.x = x_ofs;\n\n        lv_coord_t p_act = start_point;\n        lv_coord_t p_prev = start_point;\n        int32_t y_tmp = (int32_t)((int32_t)ser->y_points[p_prev] - chart->ymin[ser->y_axis_sec]) * h;\n        y_tmp  = y_tmp / (chart->ymax[ser->y_axis_sec] - chart->ymin[ser->y_axis_sec]);\n        p2.y   = h - y_tmp + y_ofs;\n\n        lv_obj_draw_part_dsc_t part_draw_dsc;\n        lv_obj_draw_dsc_init(&part_draw_dsc, clip_area);\n        part_draw_dsc.class_p = MY_CLASS;\n        part_draw_dsc.type = LV_CHART_DRAW_PART_LINE_AND_POINT;\n        part_draw_dsc.part = LV_PART_ITEMS;\n        part_draw_dsc.line_dsc = &line_dsc_default;\n        part_draw_dsc.rect_dsc = &point_dsc_default;\n        part_draw_dsc.sub_part_ptr = ser;\n\n        lv_coord_t y_min = p2.y;\n        lv_coord_t y_max = p2.y;\n\n        for(i = 0; i < chart->point_cnt; i++) {\n            p1.x = p2.x;\n            p1.y = p2.y;\n\n            if(p1.x > clip_area->x2 + point_w + 1) break;\n            p2.x = ((w * i) / (chart->point_cnt - 1)) + x_ofs;\n\n            p_act = (start_point + i) % chart->point_cnt;\n\n            y_tmp = (int32_t)((int32_t)ser->y_points[p_act] - chart->ymin[ser->y_axis_sec]) * h;\n            y_tmp = y_tmp / (chart->ymax[ser->y_axis_sec] - chart->ymin[ser->y_axis_sec]);\n            p2.y  = h - y_tmp + y_ofs;\n\n            if(p2.x < clip_area->x1 - point_w - 1) {\n                p_prev = p_act;\n                continue;\n            }\n\n            /*Don't draw the first point. A second point is also required to draw the line*/\n            if(i != 0) {\n                if(crowded_mode) {\n                    if(ser->y_points[p_prev] != LV_CHART_POINT_NONE && ser->y_points[p_act] != LV_CHART_POINT_NONE) {\n                        /*Draw only one vertical line between the min and max y-values on the same x-value*/\n                        y_max = LV_MAX(y_max, p2.y);\n                        y_min = LV_MIN(y_min, p2.y);\n                        if(p1.x != p2.x) {\n                            lv_coord_t y_cur = p2.y;\n                            p2.x--;         /*It's already on the next x value*/\n                            p1.x = p2.x;\n                            p1.y = y_min;\n                            p2.y = y_max;\n                            if(p1.y == p2.y) p2.y++;    /*If they are the same no line will be drawn*/\n                            lv_draw_line(&p1, &p2, &series_mask, &line_dsc_default);\n                            p2.x++;         /*Compensate the previous x--*/\n                            y_min = y_cur;  /*Start the line of the next x from the current last y*/\n                            y_max = y_cur;\n                        }\n                    }\n                }\n                else {\n                    lv_area_t point_area;\n                    point_area.x1 = p1.x - point_w;\n                    point_area.x2 = p1.x + point_w;\n                    point_area.y1 = p1.y - point_h;\n                    point_area.y2 = p1.y + point_h;\n\n                    part_draw_dsc.id = i - 1;\n                    part_draw_dsc.p1 = ser->y_points[p_prev] != LV_CHART_POINT_NONE ? &p1 : NULL;\n                    part_draw_dsc.p2 = ser->y_points[p_act] != LV_CHART_POINT_NONE ? &p2 : NULL;\n                    part_draw_dsc.draw_area = &point_area;\n                    part_draw_dsc.value = ser->y_points[p_prev];\n\n                    lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n\n                    if(ser->y_points[p_prev] != LV_CHART_POINT_NONE && ser->y_points[p_act] != LV_CHART_POINT_NONE) {\n                        lv_draw_line(&p1, &p2, &series_mask, &line_dsc_default);\n                    }\n\n                    if(point_w && point_h && ser->y_points[p_prev] != LV_CHART_POINT_NONE) {\n                        lv_draw_rect(&point_area, &series_mask, &point_dsc_default);\n                    }\n\n                    lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n                }\n\n            }\n            p_prev = p_act;\n        }\n\n        /*Draw the last point*/\n        if(!crowded_mode && i == chart->point_cnt) {\n\n            if(ser->y_points[p_act] != LV_CHART_POINT_NONE) {\n                lv_area_t point_area;\n                point_area.x1 = p2.x - point_w;\n                point_area.x2 = p2.x + point_w;\n                point_area.y1 = p2.y - point_h;\n                point_area.y2 = p2.y + point_h;\n\n                part_draw_dsc.id = i - 1;\n                part_draw_dsc.p1 = NULL;\n                part_draw_dsc.p2 = NULL;\n                part_draw_dsc.draw_area = &point_area;\n                part_draw_dsc.value = ser->y_points[p_act];\n                lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n                lv_draw_rect(&point_area, &series_mask, &point_dsc_default);\n                lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n            }\n        }\n    }\n}"}, "draw_series_bar": {"type": "Function", "def": "static void draw_series_bar(lv_obj_t * obj, const lv_area_t * clip_area)", "sline": 1168, "body": "{\n    lv_area_t com_area;\n    if(_lv_area_intersect(&com_area, &obj->coords, clip_area) == false) return;\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n\n    uint16_t i;\n    lv_area_t col_a;\n    lv_coord_t pad_left = lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n    lv_coord_t pad_top = lv_obj_get_style_pad_top(obj, LV_PART_MAIN);\n    lv_coord_t w     = ((int32_t)lv_obj_get_content_width(obj) * chart->zoom_x) >> 8;\n    lv_coord_t h     = ((int32_t)lv_obj_get_content_height(obj) * chart->zoom_y) >> 8;\n    int32_t y_tmp;\n    lv_chart_series_t * ser;\n    uint32_t ser_cnt = _lv_ll_get_len(&chart->series_ll);\n    int32_t block_gap = ((int32_t)lv_obj_get_style_pad_column(obj,\n                                                              LV_PART_MAIN) * chart->zoom_x) >> 8;  /*Gap between the column on ~adjacent X*/\n    lv_coord_t block_w = (w - ((chart->point_cnt - 1) * block_gap)) / chart->point_cnt;\n    lv_coord_t col_w = block_w / ser_cnt;\n    int32_t ser_gap = ((int32_t)lv_obj_get_style_pad_column(obj,\n                                                            LV_PART_ITEMS) * chart->zoom_x) >> 8; /*Gap between the column on the ~same X*/\n    lv_coord_t x_ofs = pad_left - lv_obj_get_scroll_left(obj);\n    lv_coord_t y_ofs = pad_top - lv_obj_get_scroll_top(obj);\n\n    lv_draw_rect_dsc_t col_dsc;\n    lv_draw_rect_dsc_init(&col_dsc);\n    lv_obj_init_draw_rect_dsc(obj, LV_PART_ITEMS, &col_dsc);\n    col_dsc.bg_grad_dir = LV_GRAD_DIR_NONE;\n    col_dsc.bg_opa = LV_OPA_COVER;\n\n    /*Make the cols longer with `radius` to clip the rounding from the bottom*/\n    col_a.y2 = obj->coords.y2 + col_dsc.radius;\n\n    lv_area_t series_mask;\n    bool mask_ret = _lv_area_intersect(&series_mask, &obj->coords, clip_area);\n    if(mask_ret == false) return;\n\n    lv_obj_draw_part_dsc_t part_draw_dsc;\n    lv_obj_draw_dsc_init(&part_draw_dsc, &series_mask);\n    part_draw_dsc.part = LV_PART_ITEMS;\n    part_draw_dsc.class_p = MY_CLASS;\n    part_draw_dsc.type = LV_CHART_DRAW_PART_BAR;\n\n    /*Go through all points*/\n    for(i = 0; i < chart->point_cnt; i++) {\n        lv_coord_t x_act = (int32_t)((int32_t)(w + block_gap) * i) / (chart->point_cnt) + obj->coords.x1 + x_ofs;\n\n        part_draw_dsc.id = i;\n\n        /*Draw the current point of all data line*/\n        _LV_LL_READ_BACK(&chart->series_ll, ser) {\n            if(ser->hidden) continue;\n            lv_coord_t start_point = chart->update_mode == LV_CHART_UPDATE_MODE_SHIFT ? ser->start_point : 0;\n\n            col_a.x1 = x_act;\n            col_a.x2 = col_a.x1 + col_w - ser_gap - 1;\n            x_act += col_w;\n\n            if(col_a.x2 < series_mask.x1) continue;\n            if(col_a.x1 > series_mask.x2) break;\n\n            col_dsc.bg_color = ser->color;\n\n            lv_coord_t p_act = (start_point + i) % chart->point_cnt;\n            y_tmp            = (int32_t)((int32_t)ser->y_points[p_act] - chart->ymin[ser->y_axis_sec]) * h;\n            y_tmp            = y_tmp / (chart->ymax[ser->y_axis_sec] - chart->ymin[ser->y_axis_sec]);\n            col_a.y1         = h - y_tmp + obj->coords.y1 + y_ofs;\n\n            if(ser->y_points[p_act] != LV_CHART_POINT_NONE) {\n                part_draw_dsc.draw_area = &col_a;\n                part_draw_dsc.rect_dsc = &col_dsc;\n                part_draw_dsc.sub_part_ptr = ser;\n                part_draw_dsc.value = ser->y_points[p_act];\n                lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n                lv_draw_rect(&col_a, &series_mask, &col_dsc);\n                lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n            }\n        }\n    }\n}"}, "draw_series_scatter": {"type": "Function", "def": "static void draw_series_scatter(lv_obj_t * obj, const lv_area_t * clip_area)", "sline": 1025, "body": "{\n\n    lv_area_t com_area;\n    if(_lv_area_intersect(&com_area, &obj->coords, clip_area) == false) return;\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n\n    uint16_t i;\n    lv_point_t p1;\n    lv_point_t p2;\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n    lv_coord_t pad_left = lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n    lv_coord_t pad_top = lv_obj_get_style_pad_top(obj, LV_PART_MAIN);\n    lv_coord_t w     = ((int32_t)lv_obj_get_content_width(obj) * chart->zoom_x) >> 8;\n    lv_coord_t h     = ((int32_t)lv_obj_get_content_height(obj) * chart->zoom_y) >> 8;\n    lv_coord_t x_ofs = obj->coords.x1 + pad_left + border_width - lv_obj_get_scroll_left(obj);\n    lv_coord_t y_ofs = obj->coords.y1 + pad_top + border_width - lv_obj_get_scroll_top(obj);\n    lv_chart_series_t * ser;\n\n    lv_area_t series_mask;\n    bool mask_ret = _lv_area_intersect(&series_mask, &obj->coords, clip_area);\n    if(mask_ret == false) return;\n\n    lv_draw_line_dsc_t line_dsc_default;\n    lv_draw_line_dsc_init(&line_dsc_default);\n    lv_obj_init_draw_line_dsc(obj, LV_PART_ITEMS, &line_dsc_default);\n\n    lv_draw_rect_dsc_t point_dsc_default;\n    lv_draw_rect_dsc_init(&point_dsc_default);\n    lv_obj_init_draw_rect_dsc(obj, LV_PART_INDICATOR, &point_dsc_default);\n\n    lv_coord_t point_w = lv_obj_get_style_width(obj, LV_PART_INDICATOR) / 2;\n    lv_coord_t point_h = lv_obj_get_style_height(obj, LV_PART_INDICATOR) / 2;\n\n    /*Do not bother with line ending is the point will over it*/\n    if(LV_MIN(point_w, point_h) > line_dsc_default.width / 2) line_dsc_default.raw_end = 1;\n    if(line_dsc_default.width == 1) line_dsc_default.raw_end = 1;\n\n    /*Go through all data lines*/\n    _LV_LL_READ_BACK(&chart->series_ll, ser) {\n        if(ser->hidden) continue;\n        line_dsc_default.color = ser->color;\n        point_dsc_default.bg_color = ser->color;\n\n        lv_coord_t start_point = chart->update_mode == LV_CHART_UPDATE_MODE_SHIFT ? ser->start_point : 0;\n\n        p1.x = x_ofs;\n        p2.x = x_ofs;\n\n        lv_coord_t p_act = start_point;\n        lv_coord_t p_prev = start_point;\n        if(ser->y_points[p_act] != LV_CHART_POINT_CNT_DEF) {\n            p2.x = lv_map(ser->x_points[p_act], chart->xmin[ser->x_axis_sec], chart->xmax[ser->x_axis_sec], 0, w);\n            p2.x += x_ofs;\n\n            p2.y = lv_map(ser->y_points[p_act], chart->ymin[ser->y_axis_sec], chart->ymax[ser->y_axis_sec], 0, h);\n            p2.y = h - p2.y;\n            p2.y += y_ofs;\n        }\n        else {\n            p2.x = LV_COORD_MIN;\n            p2.y = LV_COORD_MIN;\n        }\n\n        lv_obj_draw_part_dsc_t part_draw_dsc;\n        lv_obj_draw_dsc_init(&part_draw_dsc, clip_area);\n        part_draw_dsc.part = LV_PART_ITEMS;\n        part_draw_dsc.class_p = MY_CLASS;\n        part_draw_dsc.type = LV_CHART_DRAW_PART_LINE_AND_POINT;\n        part_draw_dsc.line_dsc = &line_dsc_default;\n        part_draw_dsc.rect_dsc = &point_dsc_default;\n        part_draw_dsc.sub_part_ptr = ser;\n\n        for(i = 0; i < chart->point_cnt; i++) {\n            p1.x = p2.x;\n            p1.y = p2.y;\n\n            p_act = (start_point + i) % chart->point_cnt;\n            if(ser->y_points[p_act] != LV_CHART_POINT_NONE) {\n                p2.y = lv_map(ser->y_points[p_act], chart->ymin[ser->y_axis_sec], chart->ymax[ser->y_axis_sec], 0, h);\n                p2.y = h - p2.y;\n                p2.y += y_ofs;\n\n                p2.x = lv_map(ser->x_points[p_act], chart->xmin[ser->x_axis_sec], chart->xmax[ser->x_axis_sec], 0, w);\n                p2.x += x_ofs;\n            }\n            else {\n                p_prev = p_act;\n                continue;\n            }\n\n            /*Don't draw the first point. A second point is also required to draw the line*/\n            if(i != 0) {\n                lv_area_t point_area;\n                point_area.x1 = p1.x - point_w;\n                point_area.x2 = p1.x + point_w;\n                point_area.y1 = p1.y - point_h;\n                point_area.y2 = p1.y + point_h;\n\n                part_draw_dsc.id = i - 1;\n                part_draw_dsc.p1 = ser->y_points[p_prev] != LV_CHART_POINT_NONE ? &p1 : NULL;\n                part_draw_dsc.p2 = ser->y_points[p_act] != LV_CHART_POINT_NONE ? &p2 : NULL;\n                part_draw_dsc.draw_area = &point_area;\n                part_draw_dsc.value = ser->y_points[p_prev];\n\n                lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n\n                if(ser->y_points[p_prev] != LV_CHART_POINT_NONE && ser->y_points[p_act] != LV_CHART_POINT_NONE) {\n                    lv_draw_line(&p1, &p2, &series_mask, &line_dsc_default);\n                    if(point_w && point_h) {\n                        lv_draw_rect(&point_area, &series_mask, &point_dsc_default);\n                    }\n                }\n\n                lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n            }\n            p_prev = p_act;\n        }\n\n        /*Draw the last point*/\n        if(i == chart->point_cnt) {\n\n            if(ser->y_points[p_act] != LV_CHART_POINT_NONE) {\n                lv_area_t point_area;\n                point_area.x1 = p2.x - point_w;\n                point_area.x2 = p2.x + point_w;\n                point_area.y1 = p2.y - point_h;\n                point_area.y2 = p2.y + point_h;\n\n                part_draw_dsc.id = i - 1;\n                part_draw_dsc.p1 = NULL;\n                part_draw_dsc.p2 = NULL;\n                part_draw_dsc.draw_area = &point_area;\n                part_draw_dsc.value = ser->y_points[p_act];\n                lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n                lv_draw_rect(&point_area, &series_mask, &point_dsc_default);\n                lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n            }\n        }\n    }\n}"}, "draw_cursors": {"type": "Function", "def": "static void draw_cursors(lv_obj_t * obj, const lv_area_t * clip_area)", "sline": 1250, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(_lv_ll_is_empty(&chart->cursor_ll)) return;\n\n    lv_point_t p1;\n    lv_point_t p2;\n    lv_chart_cursor_t * cursor;\n\n    lv_draw_line_dsc_t line_dsc_ori;\n    lv_draw_line_dsc_init(&line_dsc_ori);\n    lv_obj_init_draw_line_dsc(obj, LV_PART_CURSOR, &line_dsc_ori);\n\n    lv_draw_rect_dsc_t point_dsc_ori;\n    lv_draw_rect_dsc_init(&point_dsc_ori);\n    point_dsc_ori.bg_opa = line_dsc_ori.opa;\n    point_dsc_ori.radius = LV_RADIUS_CIRCLE;\n\n    lv_draw_line_dsc_t line_dsc_tmp;\n    lv_draw_rect_dsc_t point_dsc_tmp;\n\n    lv_coord_t point_w = lv_obj_get_style_width(obj, LV_PART_CURSOR) / 2;\n    lv_coord_t point_h = lv_obj_get_style_width(obj, LV_PART_CURSOR) / 2;\n\n    lv_obj_draw_part_dsc_t part_draw_dsc;\n    lv_obj_draw_dsc_init(&part_draw_dsc, clip_area);\n    part_draw_dsc.line_dsc = &line_dsc_tmp;\n    part_draw_dsc.rect_dsc = &point_dsc_tmp;\n    part_draw_dsc.part = LV_PART_CURSOR;\n    part_draw_dsc.class_p = MY_CLASS;\n    part_draw_dsc.type = LV_CHART_DRAW_PART_CURSOR;\n\n    lv_area_t clip_area2;\n    _lv_area_intersect(&clip_area2, clip_area, &obj->coords);\n\n    /*Go through all cursor lines*/\n    _LV_LL_READ_BACK(&chart->cursor_ll, cursor) {\n        lv_memcpy(&line_dsc_tmp, &line_dsc_ori, sizeof(lv_draw_line_dsc_t));\n        lv_memcpy(&point_dsc_tmp, &point_dsc_ori, sizeof(lv_draw_rect_dsc_t));\n        line_dsc_tmp.color = cursor->color;\n        point_dsc_tmp.bg_color = cursor->color;\n\n        part_draw_dsc.p1 = &p1;\n        part_draw_dsc.p2 = &p2;\n\n        lv_coord_t cx;\n        lv_coord_t cy;\n        if(cursor->pos_set) {\n            cx = cursor->pos.x;\n            cy = cursor->pos.y;\n        }\n        else {\n            if(cursor->point_id == LV_CHART_POINT_NONE) continue;\n            lv_point_t p;\n            lv_chart_get_point_pos_by_id(obj, cursor->ser, cursor->point_id, &p);\n            cx = p.x;\n            cy = p.y;\n        }\n\n        cx += obj->coords.x1;\n        cy += obj->coords.y1;\n\n        lv_area_t point_area;\n        if(point_w && point_h) {\n            point_area.x1 = cx - point_w;\n            point_area.x2 = cx + point_w;\n            point_area.y1 = cy - point_h;\n            point_area.y2 = cy + point_h;\n\n            part_draw_dsc.draw_area = &point_area;\n        }\n        else {\n            part_draw_dsc.draw_area = NULL;\n        }\n\n        if(cursor->dir & LV_DIR_HOR) {\n            p1.x = cursor->dir & LV_DIR_LEFT ? obj->coords.x1 : cx;\n            p1.y = cy;\n            p2.x = cursor->dir & LV_DIR_RIGHT ? obj->coords.x2 : cx;\n            p2.y = p1.y;\n\n            lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n            lv_draw_line(&p1, &p2, &clip_area2, &line_dsc_tmp);\n            lv_draw_rect(&point_area, &clip_area2, &point_dsc_tmp);\n            lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n        }\n\n        if(cursor->dir & LV_DIR_VER) {\n            p1.x = cx;\n            p1.y = cursor->dir & LV_DIR_TOP ? obj->coords.y1 : cy;\n            p2.x = p1.x;\n            p2.y = cursor->dir & LV_DIR_BOTTOM ? obj->coords.y2 : cy;\n\n            lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n            lv_draw_line(&p1, &p2, &clip_area2, &line_dsc_tmp);\n            lv_draw_rect(&point_area, &clip_area2, &point_dsc_tmp);\n            lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n        }\n\n    }\n}"}, "draw_axes": {"type": "Function", "def": "static void draw_axes(lv_obj_t * obj, const lv_area_t * mask)", "sline": 1622, "body": "{\n    draw_y_ticks(obj, mask, LV_CHART_AXIS_PRIMARY_Y);\n    draw_y_ticks(obj, mask, LV_CHART_AXIS_SECONDARY_Y);\n    draw_x_ticks(obj, mask, LV_CHART_AXIS_PRIMARY_X);\n    draw_x_ticks(obj, mask, LV_CHART_AXIS_SECONDARY_X);\n}"}, "get_index_from_x": {"type": "Function", "def": "static uint32_t get_index_from_x(lv_obj_t * obj, lv_coord_t x)", "sline": 1636, "body": "{\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    lv_coord_t w = ((int32_t)lv_obj_get_content_width(obj) * chart->zoom_x) >> 8;\n    lv_coord_t pad_left = lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n    x -= pad_left;\n\n    if(x < 0) return 0;\n    if(x > w) return chart->point_cnt - 1;\n    if(chart->type == LV_CHART_TYPE_LINE) return (x * (chart->point_cnt - 1) + w / 2) / w;\n    if(chart->type == LV_CHART_TYPE_BAR) return (x * chart->point_cnt) / w;\n\n    return 0;\n}"}, "invalidate_point": {"type": "Function", "def": "static void invalidate_point(lv_obj_t * obj, uint16_t i)", "sline": 1651, "body": "{\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(i >= chart->point_cnt) return;\n\n    lv_coord_t w  = ((int32_t)lv_obj_get_content_width(obj) * chart->zoom_x) >> 8;\n    lv_coord_t scroll_left = lv_obj_get_scroll_left(obj);\n\n    /*In shift mode the whole chart changes so the whole object*/\n    if(chart->update_mode == LV_CHART_UPDATE_MODE_SHIFT) {\n        lv_obj_invalidate(obj);\n        return;\n    }\n\n    if(chart->type == LV_CHART_TYPE_LINE) {\n        lv_coord_t bwidth = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n        lv_coord_t pleft = lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n        lv_coord_t x_ofs = obj->coords.x1 + pleft + bwidth - scroll_left;\n        lv_coord_t line_width = lv_obj_get_style_line_width(obj, LV_PART_ITEMS);\n        lv_coord_t point_w = lv_obj_get_style_width(obj, LV_PART_INDICATOR);\n\n        lv_area_t coords;\n        lv_area_copy(&coords, &obj->coords);\n        coords.y1 -= line_width + point_w;\n        coords.y2 += line_width + point_w;\n\n        if(i < chart->point_cnt - 1) {\n            coords.x1 = ((w * i) / (chart->point_cnt - 1)) + x_ofs - line_width - point_w;\n            coords.x2 = ((w * (i + 1)) / (chart->point_cnt - 1)) + x_ofs + line_width + point_w;\n            lv_obj_invalidate_area(obj, &coords);\n        }\n\n        if(i > 0) {\n            coords.x1 = ((w * (i - 1)) / (chart->point_cnt - 1)) + x_ofs - line_width - point_w;\n            coords.x2 = ((w * i) / (chart->point_cnt - 1)) + x_ofs + line_width + point_w;\n            lv_obj_invalidate_area(obj, &coords);\n        }\n    }\n    else if(chart->type == LV_CHART_TYPE_BAR) {\n        lv_area_t col_a;\n        int32_t block_gap = ((int32_t)lv_obj_get_style_pad_column(obj,\n                                                                  LV_PART_MAIN) * chart->zoom_x) >> 8;  /*Gap between the column on ~adjacent X*/\n        lv_coord_t block_w = (w + block_gap) / chart->point_cnt;\n\n        lv_coord_t x_act;\n        x_act = (int32_t)((int32_t)(block_w) * i) ;\n        x_act += obj->coords.x1 + lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n\n        lv_obj_get_coords(obj, &col_a);\n        col_a.x1 = x_act - scroll_left;\n        col_a.x2 = col_a.x1 + block_w;\n        col_a.x1 -= block_gap;\n\n        lv_obj_invalidate_area(obj, &col_a);\n    }\n    else if(chart->type == LV_CHART_TYPE_SCATTER) {\n        lv_obj_invalidate(obj);\n    }\n    else {\n        lv_obj_invalidate(obj);\n    }\n}"}, "new_points_alloc": {"type": "Function", "def": "static void new_points_alloc(lv_obj_t * obj, lv_chart_series_t * ser, uint32_t cnt, lv_coord_t ** a)", "sline": 1714, "body": "{\n    if((*a) == NULL) return;\n\n    lv_chart_t * chart = (lv_chart_t *) obj;\n    uint32_t point_cnt_old = chart->point_cnt;\n    uint32_t i;\n\n    if(ser->start_point != 0) {\n        lv_coord_t * new_points = lv_mem_alloc(sizeof(lv_coord_t) * cnt);\n        LV_ASSERT_MALLOC(new_points);\n        if(new_points == NULL) return;\n\n        if(cnt >= point_cnt_old) {\n            for(i = 0; i < point_cnt_old; i++) {\n                new_points[i] =\n                    (*a)[(i + ser->start_point) % point_cnt_old]; /*Copy old contents to new array*/\n            }\n            for(i = point_cnt_old; i < cnt; i++) {\n                new_points[i] = LV_CHART_POINT_NONE; /*Fill up the rest with default value*/\n            }\n        }\n        else {\n            for(i = 0; i < cnt; i++) {\n                new_points[i] =\n                    (*a)[(i + ser->start_point) % point_cnt_old]; /*Copy old contents to new array*/\n            }\n        }\n\n        /*Switch over pointer from old to new*/\n        lv_mem_free((*a));\n        (*a) = new_points;\n    }\n    else {\n        (*a) = lv_mem_realloc((*a), sizeof(lv_coord_t) * cnt);\n        LV_ASSERT_MALLOC((*a));\n        if((*a) == NULL) return;\n        /*Initialize the new points*/\n        if(cnt > point_cnt_old) {\n            for(i = point_cnt_old - 1; i < cnt; i++) {\n                (*a)[i] = LV_CHART_POINT_NONE;\n            }\n        }\n    }\n}"}, "get_tick_gsc": {"type": "Function", "def": "lv_chart_tick_dsc_t * get_tick_gsc(lv_obj_t * obj, lv_chart_axis_t axis)", "sline": 1760, "body": "{\n    lv_chart_t * chart = (lv_chart_t *) obj;\n    switch(axis) {\n        case LV_CHART_AXIS_PRIMARY_Y:\n            return &chart->tick[0];\n        case LV_CHART_AXIS_PRIMARY_X:\n            return &chart->tick[1];\n        case LV_CHART_AXIS_SECONDARY_Y:\n            return &chart->tick[2];\n        case LV_CHART_AXIS_SECONDARY_X:\n            return &chart->tick[3];\n        default:\n            return NULL;\n    }\n}"}, "lv_chart_class": {"type": "Variable", "def": "const lv_obj_class_t lv_chart_class = {\n    .constructor_cb = lv_chart_constructor,\n    .destructor_cb = lv_chart_destructor,\n    .event_cb = lv_chart_event,\n    .width_def = LV_PCT(100),\n    .height_def = LV_DPI_DEF * 2,\n    .instance_size = sizeof(lv_chart_t),\n    .base_class = &lv_obj_class\n}", "sline": 49}, "lv_chart_create": {"type": "Function", "def": "lv_obj_t * lv_chart_create(lv_obj_t * parent)", "sline": 67, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_chart_set_type": {"type": "Function", "def": "void lv_chart_set_type(lv_obj_t * obj, lv_chart_type_t type)", "sline": 75, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(chart->type == type) return;\n\n    if(chart->type == LV_CHART_TYPE_SCATTER) {\n        lv_chart_series_t * ser;\n        _LV_LL_READ_BACK(&chart->series_ll, ser) {\n            lv_mem_free(ser->x_points);\n            ser->x_points = NULL;\n        }\n    }\n\n    if(type == LV_CHART_TYPE_SCATTER) {\n        lv_chart_series_t * ser;\n        _LV_LL_READ_BACK(&chart->series_ll, ser) {\n            ser->x_points = lv_mem_alloc(sizeof(lv_point_t) * chart->point_cnt);\n            LV_ASSERT_MALLOC(ser->x_points);\n            if(ser->x_points == NULL) return;\n        }\n    }\n\n    chart->type = type;\n\n    lv_chart_refresh(obj);\n}"}, "lv_chart_set_point_count": {"type": "Function", "def": "void lv_chart_set_point_count(lv_obj_t * obj, uint16_t cnt)", "sline": 104, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(chart->point_cnt == cnt) return;\n\n    lv_chart_series_t * ser;\n\n    if(cnt < 1) cnt = 1;\n\n    _LV_LL_READ_BACK(&chart->series_ll, ser) {\n        if(chart->type == LV_CHART_TYPE_SCATTER) {\n            if(!ser->x_ext_buf_assigned) new_points_alloc(obj, ser, cnt, &ser->x_points);\n        }\n        if(!ser->y_ext_buf_assigned) new_points_alloc(obj, ser, cnt, &ser->y_points);\n        ser->start_point = 0;\n    }\n\n    chart->point_cnt = cnt;\n\n    lv_chart_refresh(obj);\n}"}, "lv_chart_set_range": {"type": "Function", "def": "void lv_chart_set_range(lv_obj_t * obj, lv_chart_axis_t axis, lv_coord_t min, lv_coord_t max)", "sline": 128, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    max = max == min ? max + 1 : max;\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    switch(axis) {\n        case LV_CHART_AXIS_PRIMARY_Y:\n            chart->ymin[0] = min;\n            chart->ymax[0] = max;\n            break;\n        case LV_CHART_AXIS_SECONDARY_Y:\n            chart->ymin[1] = min;\n            chart->ymax[1] = max;\n            break;\n        case LV_CHART_AXIS_PRIMARY_X:\n            chart->xmin[0] = min;\n            chart->xmax[0] = max;\n            break;\n        case LV_CHART_AXIS_SECONDARY_X:\n            chart->xmin[1] = min;\n            chart->xmax[1] = max;\n            break;\n        default:\n            LV_LOG_WARN(\"Invalid axis: %d\", axis);\n            return;\n    }\n\n    lv_chart_refresh(obj);\n}"}, "lv_chart_set_update_mode": {"type": "Function", "def": "void lv_chart_set_update_mode(lv_obj_t * obj, lv_chart_update_mode_t update_mode)", "sline": 160, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(chart->update_mode == update_mode) return;\n\n    chart->update_mode = update_mode;\n    lv_obj_invalidate(obj);\n}"}, "lv_chart_set_div_line_count": {"type": "Function", "def": "void lv_chart_set_div_line_count(lv_obj_t * obj, uint8_t hdiv, uint8_t vdiv)", "sline": 171, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(chart->hdiv_cnt == hdiv && chart->vdiv_cnt == vdiv) return;\n\n    chart->hdiv_cnt = hdiv;\n    chart->vdiv_cnt = vdiv;\n\n    lv_obj_invalidate(obj);\n}"}, "lv_chart_set_zoom_x": {"type": "Function", "def": "void lv_chart_set_zoom_x(lv_obj_t * obj, uint16_t zoom_x)", "sline": 185, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(chart->zoom_x == zoom_x) return;\n\n    chart->zoom_x = zoom_x;\n    lv_obj_refresh_self_size(obj);\n    /*Be the chart doesn't remain scrolled out*/\n    lv_obj_readjust_scroll(obj, LV_ANIM_OFF);\n    lv_obj_invalidate(obj);\n}"}, "lv_chart_set_zoom_y": {"type": "Function", "def": "void lv_chart_set_zoom_y(lv_obj_t * obj, uint16_t zoom_y)", "sline": 199, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(chart->zoom_y == zoom_y) return;\n\n    chart->zoom_y = zoom_y;\n    lv_obj_refresh_self_size(obj);\n    /*Be the chart doesn't remain scrolled out*/\n    lv_obj_readjust_scroll(obj, LV_ANIM_OFF);\n    lv_obj_invalidate(obj);\n}"}, "lv_chart_get_zoom_x": {"type": "Function", "def": "uint16_t lv_chart_get_zoom_x(const lv_obj_t * obj)", "sline": 213, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    return chart->zoom_x;\n}"}, "lv_chart_get_zoom_y": {"type": "Function", "def": "uint16_t lv_chart_get_zoom_y(const lv_obj_t * obj)", "sline": 221, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    return chart->zoom_y;\n}"}, "lv_chart_set_axis_tick": {"type": "Function", "def": "void lv_chart_set_axis_tick(lv_obj_t * obj, lv_chart_axis_t axis, lv_coord_t major_len, lv_coord_t minor_len,\n                            lv_coord_t major_cnt, lv_coord_t minor_cnt, bool label_en, lv_coord_t draw_size)", "sline": 229, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_tick_dsc_t * t = get_tick_gsc(obj, axis);\n    t->major_len = major_len;\n    t->minor_len = minor_len;\n    t->minor_cnt = minor_cnt;\n    t->major_cnt = major_cnt;\n    t->label_en = label_en;\n    t->draw_size = draw_size;\n\n    lv_obj_refresh_ext_draw_size(obj);\n    lv_obj_invalidate(obj);\n}"}, "lv_chart_get_type": {"type": "Function", "def": "lv_chart_type_t lv_chart_get_type(const lv_obj_t * obj)", "sline": 246, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    return chart->type;\n}"}, "lv_chart_get_point_count": {"type": "Function", "def": "uint16_t lv_chart_get_point_count(const lv_obj_t * obj)", "sline": 254, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    return chart->point_cnt;\n}"}, "lv_chart_get_x_start_point": {"type": "Function", "def": "uint16_t lv_chart_get_x_start_point(const lv_obj_t * obj, lv_chart_series_t * ser)", "sline": 262, "body": "{\n    LV_UNUSED(obj);\n    LV_ASSERT_NULL(ser);\n\n    return ser->start_point;\n}"}, "lv_chart_get_point_pos_by_id": {"type": "Function", "def": "void lv_chart_get_point_pos_by_id(lv_obj_t * obj, lv_chart_series_t * ser, uint16_t id, lv_point_t * p_out)", "sline": 270, "body": "{\n    LV_ASSERT_NULL(obj);\n    LV_ASSERT_NULL(ser);\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(id >= chart->point_cnt) {\n        LV_LOG_WARN(\"Invalid index: %d\", id);\n        p_out->x = 0;\n        p_out->y = 0;\n        return;\n    }\n\n    lv_coord_t w = ((int32_t)lv_obj_get_content_width(obj) * chart->zoom_x) >> 8;\n    lv_coord_t h = ((int32_t)lv_obj_get_content_height(obj) * chart->zoom_y) >> 8;\n\n    if(chart->type == LV_CHART_TYPE_LINE) {\n        p_out->x = (w * id) / (chart->point_cnt - 1);\n    }\n    else if(chart->type == LV_CHART_TYPE_SCATTER) {\n        p_out->x = lv_map(ser->x_points[id], chart->xmin[ser->x_axis_sec], chart->xmax[ser->x_axis_sec], 0, w);\n    }\n    else if(chart->type == LV_CHART_TYPE_BAR) {\n        uint32_t ser_cnt = _lv_ll_get_len(&chart->series_ll);\n        int32_t ser_gap = ((int32_t)lv_obj_get_style_pad_column(obj,\n                                                                LV_PART_ITEMS) * chart->zoom_x) >> 8; /*Gap between the column on the ~same X*/\n        int32_t block_gap = ((int32_t)lv_obj_get_style_pad_column(obj,\n                                                                  LV_PART_MAIN) * chart->zoom_x) >> 8;  /*Gap between the column on ~adjacent X*/\n        lv_coord_t block_w = (w - ((chart->point_cnt - 1) * block_gap)) / chart->point_cnt;\n        lv_coord_t col_w = block_w / ser_cnt;\n\n        p_out->x = (int32_t)((int32_t)w * id) / chart->point_cnt;\n\n        lv_chart_series_t * ser_i = NULL;\n        _LV_LL_READ_BACK(&chart->series_ll, ser_i) {\n            if(ser_i == ser) break;\n            p_out->x += col_w;\n        }\n\n        p_out->x += (col_w - ser_gap) / 2;\n    }\n\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n    p_out->x += lv_obj_get_style_pad_left(obj, LV_PART_MAIN) + border_width;\n    p_out->x -= lv_obj_get_scroll_left(obj);\n\n    int32_t temp_y = 0;\n    temp_y = (int32_t)((int32_t)ser->y_points[id] - chart->ymin[ser->y_axis_sec]) * h;\n    temp_y = temp_y / (chart->ymax[ser->y_axis_sec] - chart->ymin[ser->y_axis_sec]);\n    p_out->y = h - temp_y;\n    p_out->y += lv_obj_get_style_pad_top(obj, LV_PART_MAIN) + border_width;\n    p_out->y -= lv_obj_get_scroll_top(obj);\n}"}, "lv_chart_refresh": {"type": "Function", "def": "void lv_chart_refresh(lv_obj_t * obj)", "sline": 325, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_obj_invalidate(obj);\n}"}, "lv_chart_add_series": {"type": "Function", "def": "lv_chart_series_t * lv_chart_add_series(lv_obj_t * obj, lv_color_t color, lv_chart_axis_t axis)", "sline": 336, "body": "{\n    LV_LOG_INFO(\"begin\");\n\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart    = (lv_chart_t *)obj;\n    lv_chart_series_t * ser = _lv_ll_ins_head(&chart->series_ll);\n    LV_ASSERT_MALLOC(ser);\n    if(ser == NULL) return NULL;\n\n    lv_coord_t def = LV_CHART_POINT_NONE;\n\n    ser->color  = color;\n    ser->y_points = lv_mem_alloc(sizeof(lv_coord_t) * chart->point_cnt);\n    LV_ASSERT_MALLOC(ser->y_points);\n\n    if(chart->type == LV_CHART_TYPE_SCATTER) {\n        ser->x_points = lv_mem_alloc(sizeof(lv_coord_t) * chart->point_cnt);\n        LV_ASSERT_MALLOC(ser->x_points);\n    }\n    if(ser->y_points == NULL) {\n        _lv_ll_remove(&chart->series_ll, ser);\n        lv_mem_free(ser);\n        return NULL;\n    }\n\n    ser->start_point = 0;\n    ser->y_ext_buf_assigned = false;\n    ser->hidden = 0;\n    ser->x_axis_sec = axis & LV_CHART_AXIS_SECONDARY_X ? 1 : 0;\n    ser->y_axis_sec = axis & LV_CHART_AXIS_SECONDARY_Y ? 1 : 0;\n\n    uint16_t i;\n    lv_coord_t * p_tmp = ser->y_points;\n    for(i = 0; i < chart->point_cnt; i++) {\n        *p_tmp = def;\n        p_tmp++;\n    }\n\n    return ser;\n}"}, "lv_chart_remove_series": {"type": "Function", "def": "void lv_chart_remove_series(lv_obj_t * obj, lv_chart_series_t * series)", "sline": 379, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(series);\n\n    lv_chart_t * chart    = (lv_chart_t *)obj;\n    if(!series->y_ext_buf_assigned && series->y_points) lv_mem_free(series->y_points);\n\n    _lv_ll_remove(&chart->series_ll, series);\n    lv_mem_free(series);\n\n    return;\n}"}, "lv_chart_hide_series": {"type": "Function", "def": "void lv_chart_hide_series(lv_obj_t * chart, lv_chart_series_t * series, bool hide)", "sline": 393, "body": "{\n    LV_ASSERT_OBJ(chart, MY_CLASS);\n    LV_ASSERT_NULL(series);\n\n    series->hidden = hide ? 1 : 0;\n    lv_chart_refresh(chart);\n}"}, "lv_chart_set_series_color": {"type": "Function", "def": "void lv_chart_set_series_color(lv_obj_t * chart, lv_chart_series_t * series, lv_color_t color)", "sline": 403, "body": "{\n    LV_ASSERT_OBJ(chart, MY_CLASS);\n    LV_ASSERT_NULL(series);\n\n    series->color = color;\n    lv_chart_refresh(chart);\n}"}, "lv_chart_set_x_start_point": {"type": "Function", "def": "void lv_chart_set_x_start_point(lv_obj_t * obj, lv_chart_series_t * ser, uint16_t id)", "sline": 412, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(ser);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(id >= chart->point_cnt) return;\n    ser->start_point = id;\n}"}, "lv_chart_get_series_next": {"type": "Function", "def": "lv_chart_series_t * lv_chart_get_series_next(const lv_obj_t * obj, const lv_chart_series_t * ser)", "sline": 422, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    if(ser == NULL) return _lv_ll_get_head(&chart->series_ll);\n    else return _lv_ll_get_next(&chart->series_ll, ser);\n}"}, "lv_chart_add_cursor": {"type": "Function", "def": "lv_chart_cursor_t  * lv_chart_add_cursor(lv_obj_t * obj, lv_color_t color, lv_dir_t dir)", "sline": 442, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    lv_chart_cursor_t * cursor = _lv_ll_ins_head(&chart->cursor_ll);\n    LV_ASSERT_MALLOC(cursor);\n    if(cursor == NULL) return NULL;\n\n    cursor->pos.x = LV_CHART_POINT_NONE;\n    cursor->pos.y = LV_CHART_POINT_NONE;\n    cursor->point_id = LV_CHART_POINT_NONE;\n    cursor->pos_set = 0;\n    cursor->color = color;\n    cursor->dir = dir;\n\n    return cursor;\n}"}, "lv_chart_set_cursor_pos": {"type": "Function", "def": "void lv_chart_set_cursor_pos(lv_obj_t * chart, lv_chart_cursor_t * cursor, lv_point_t * pos)", "sline": 468, "body": "{\n    LV_ASSERT_NULL(cursor);\n    LV_UNUSED(chart);\n\n    cursor->pos.x = pos->x;\n    cursor->pos.y = pos->y;\n    cursor->pos_set = 1;\n    lv_chart_refresh(chart);\n}"}, "lv_chart_set_cursor_point": {"type": "Function", "def": "void lv_chart_set_cursor_point(lv_obj_t * chart, lv_chart_cursor_t * cursor, lv_chart_series_t * ser, uint16_t point_id)", "sline": 487, "body": "{\n    LV_ASSERT_NULL(cursor);\n    LV_UNUSED(chart);\n\n    cursor->point_id = point_id;\n    cursor->pos_set = 0;\n    if(ser == NULL) ser = lv_chart_get_series_next(chart, NULL);\n    cursor->ser = ser;\n    lv_chart_refresh(chart);\n}"}, "lv_chart_get_cursor_point": {"type": "Function", "def": "lv_point_t lv_chart_get_cursor_point(lv_obj_t * chart, lv_chart_cursor_t * cursor)", "sline": 505, "body": "{\n    LV_ASSERT_NULL(cursor);\n    LV_UNUSED(chart);\n\n    return cursor->pos;\n}"}, "lv_chart_set_all_value": {"type": "Function", "def": "void lv_chart_set_all_value(lv_obj_t * obj, lv_chart_series_t * ser, lv_coord_t value)", "sline": 518, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(ser);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    uint16_t i;\n    for(i = 0; i < chart->point_cnt; i++) {\n        ser->y_points[i] = value;\n    }\n    ser->start_point = 0;\n    lv_chart_refresh(obj);\n}"}, "lv_chart_set_next_value": {"type": "Function", "def": "void lv_chart_set_next_value(lv_obj_t * obj, lv_chart_series_t * ser, lv_coord_t value)", "sline": 532, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(ser);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n    ser->y_points[ser->start_point] = value;\n    invalidate_point(obj, ser->start_point);\n    ser->start_point = (ser->start_point + 1) % chart->point_cnt;\n    invalidate_point(obj, ser->start_point);\n}"}, "lv_chart_set_next_value2": {"type": "Function", "def": "void lv_chart_set_next_value2(lv_obj_t * obj, lv_chart_series_t * ser, lv_coord_t x_value, lv_coord_t y_value)", "sline": 544, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(ser);\n\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n\n    if(chart->type != LV_CHART_TYPE_SCATTER) {\n        LV_LOG_WARN(\"Type must be LV_CHART_TYPE_SCATTER\");\n        return;\n    }\n\n    ser->x_points[ser->start_point] = x_value;\n    ser->y_points[ser->start_point] = y_value;\n    invalidate_point(obj, ser->start_point);\n    ser->start_point = (ser->start_point + 1) % chart->point_cnt;\n    invalidate_point(obj, ser->start_point);\n    lv_chart_refresh(obj);\n\n}"}, "lv_chart_set_value_by_id": {"type": "Function", "def": "void lv_chart_set_value_by_id(lv_obj_t * obj, lv_chart_series_t * ser, uint16_t id, lv_coord_t value)", "sline": 565, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(ser);\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n\n    if(id >= chart->point_cnt) return;\n    ser->y_points[id] = value;\n}"}, "lv_chart_set_value_by_id2": {"type": "Function", "def": "void lv_chart_set_value_by_id2(lv_obj_t * obj, lv_chart_series_t * ser, uint16_t id, lv_coord_t x_value,\n                               lv_coord_t y_value)", "sline": 575, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(ser);\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n\n    if(chart->type != LV_CHART_TYPE_SCATTER) {\n        LV_LOG_WARN(\"Type must be LV_CHART_TYPE_SCATTER\");\n        return;\n    }\n\n    if(id >= chart->point_cnt) return;\n    ser->x_points[id] = x_value;\n    ser->y_points[id] = y_value;\n}"}, "lv_chart_set_ext_y_array": {"type": "Function", "def": "void lv_chart_set_ext_y_array(lv_obj_t * obj, lv_chart_series_t * ser, lv_coord_t array[])", "sline": 592, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(ser);\n\n    if(!ser->y_ext_buf_assigned && ser->y_points) lv_mem_free(ser->y_points);\n    ser->y_ext_buf_assigned = true;\n    ser->y_points = array;\n    lv_obj_invalidate(obj);\n}"}, "lv_chart_set_ext_x_array": {"type": "Function", "def": "void lv_chart_set_ext_x_array(lv_obj_t * obj, lv_chart_series_t * ser, lv_coord_t array[])", "sline": 603, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(ser);\n\n    if(!ser->x_ext_buf_assigned && ser->x_points) lv_mem_free(ser->x_points);\n    ser->x_ext_buf_assigned = true;\n    ser->x_points = array;\n    lv_obj_invalidate(obj);\n}"}, "lv_chart_get_y_array": {"type": "Function", "def": "lv_coord_t * lv_chart_get_y_array(const lv_obj_t * obj, lv_chart_series_t * ser)", "sline": 614, "body": "{\n    LV_UNUSED(obj);\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(ser);\n    return ser->y_points;\n}"}, "lv_chart_get_x_array": {"type": "Function", "def": "lv_coord_t * lv_chart_get_x_array(const lv_obj_t * obj, lv_chart_series_t * ser)", "sline": 622, "body": "{\n    LV_UNUSED(obj);\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(ser);\n    return ser->x_points;\n}"}, "lv_chart_get_pressed_point": {"type": "Function", "def": "uint32_t lv_chart_get_pressed_point(const lv_obj_t * obj)", "sline": 630, "body": "{\n    lv_chart_t * chart = (lv_chart_t *)obj;\n    return chart->pressed_point_id;\n}"}, "draw_y_ticks": {"type": "Function", "def": "static void draw_y_ticks(lv_obj_t * obj, const lv_area_t * clip_area, lv_chart_axis_t axis)", "sline": 1354, "body": "{\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n\n    lv_chart_tick_dsc_t * t = get_tick_gsc(obj, axis);\n\n    if(t->major_cnt <= 1) return;\n    if(!t->label_en && !t->major_len && !t->minor_len) return;\n\n    uint8_t sec_axis = axis == LV_CHART_AXIS_PRIMARY_Y ? 0 : 1;\n\n    uint32_t i;\n\n    lv_point_t p1;\n    lv_point_t p2;\n\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n    lv_coord_t pad_top = lv_obj_get_style_pad_top(obj, LV_PART_MAIN);\n    lv_coord_t h     = ((int32_t)lv_obj_get_content_height(obj) * chart->zoom_y) >> 8;\n    lv_coord_t y_ofs = obj->coords.y1 + pad_top + border_width - lv_obj_get_scroll_top(obj);\n\n    lv_coord_t label_gap;\n    lv_coord_t x_ofs;\n    if(axis == LV_CHART_AXIS_PRIMARY_Y) {\n        label_gap = lv_obj_get_style_pad_left(obj, LV_PART_TICKS);\n        x_ofs = obj->coords.x1;\n    }\n    else {\n        label_gap = lv_obj_get_style_pad_right(obj, LV_PART_TICKS);\n        x_ofs = obj->coords.x2;\n    }\n\n    lv_coord_t major_len = t->major_len;\n    lv_coord_t minor_len = t->minor_len;\n    /*tick lines on secondary y axis are drawn in other direction*/\n    if(axis == LV_CHART_AXIS_SECONDARY_Y) {\n        major_len *= -1;\n        minor_len *= -1;\n    }\n\n    lv_draw_line_dsc_t line_dsc;\n    lv_draw_line_dsc_init(&line_dsc);\n    lv_obj_init_draw_line_dsc(obj, LV_PART_TICKS, &line_dsc);\n\n    lv_draw_label_dsc_t label_dsc;\n    lv_draw_label_dsc_init(&label_dsc);\n    lv_obj_init_draw_label_dsc(obj, LV_PART_TICKS, &label_dsc);\n\n    lv_obj_draw_part_dsc_t part_draw_dsc;\n    lv_obj_draw_dsc_init(&part_draw_dsc, clip_area);\n    part_draw_dsc.class_p = MY_CLASS;\n    part_draw_dsc.type = LV_CHART_DRAW_PART_TICK_LABEL;\n    part_draw_dsc.id = axis;\n    part_draw_dsc.part = LV_PART_TICKS;\n    part_draw_dsc.line_dsc = &line_dsc;\n    part_draw_dsc.label_dsc = &label_dsc;\n\n    uint32_t total_tick_num = (t->major_cnt - 1) * (t->minor_cnt);\n    for(i = 0; i <= total_tick_num; i++) {\n        /*draw a line at moving y position*/\n        p2.y = p1.y = y_ofs + (int32_t)((int32_t)(h - line_dsc.width) * i) / total_tick_num;\n\n        /*first point of the tick*/\n        p1.x = x_ofs;\n\n        /*move extra pixel out of chart boundary*/\n        if(axis == LV_CHART_AXIS_PRIMARY_Y) p1.x--;\n        else p1.x++;\n\n        /*second point of the tick*/\n        bool major = false;\n        if(i % t->minor_cnt == 0) major = true;\n\n        if(major) p2.x = p1.x - major_len; /*major tick*/\n        else p2.x = p1.x - minor_len; /*minor tick*/\n\n        part_draw_dsc.p1 = &p1;\n        part_draw_dsc.p2 = &p2;\n\n        int32_t tick_value = lv_map(total_tick_num - i, 0, total_tick_num, chart->ymin[sec_axis], chart->ymax[sec_axis]);\n        part_draw_dsc.value = tick_value;\n\n        /*add text only to major tick*/\n        if(major && t->label_en)  {\n            char buf[LV_CHART_LABEL_MAX_TEXT_LENGTH];\n            lv_snprintf(buf, sizeof(buf), \"%\" LV_PRId32, tick_value);\n            part_draw_dsc.label_dsc = &label_dsc;\n            part_draw_dsc.text = buf;\n            part_draw_dsc.text_length = LV_CHART_LABEL_MAX_TEXT_LENGTH;\n            lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n\n            /*reserve appropriate area*/\n            lv_point_t size;\n            lv_txt_get_size(&size, part_draw_dsc.text, label_dsc.font, label_dsc.letter_space, label_dsc.line_space, LV_COORD_MAX,\n                            LV_TEXT_FLAG_NONE);\n\n            /*set the area at some distance of the major tick len left of the tick*/\n            lv_area_t a;\n            a.y1 = p2.y - size.y / 2;\n            a.y2 = p2.y + size.y / 2;\n\n            if(!sec_axis) {\n                a.x1 = p2.x - size.x - label_gap;\n                a.x2 = p2.x - label_gap;\n            }\n            else {\n                a.x1 = p2.x + label_gap;\n                a.x2 = p2.x + size.x + label_gap;\n            }\n\n            if(a.y2 >= obj->coords.y1 &&\n               a.y1  <= obj->coords.y2) {\n                lv_draw_label(&a, clip_area, &label_dsc, part_draw_dsc.text, NULL);\n            }\n        }\n        else {\n            part_draw_dsc.label_dsc = NULL;\n            part_draw_dsc.text = NULL;\n            part_draw_dsc.text_length = 0;\n            lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n        }\n\n        if(p1.y + line_dsc.width / 2  >= obj->coords.y1 &&\n           p2.y - line_dsc.width / 2  <= obj->coords.y2) {\n            lv_draw_line(&p1, &p2, clip_area, &line_dsc);\n        }\n\n        lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n    }\n}"}, "draw_x_ticks": {"type": "Function", "def": "static void draw_x_ticks(lv_obj_t * obj, const lv_area_t * clip_area, lv_chart_axis_t axis)", "sline": 1485, "body": "{\n    lv_chart_t * chart  = (lv_chart_t *)obj;\n\n    lv_chart_tick_dsc_t * t = get_tick_gsc(obj, axis);\n    if(t->major_cnt <= 1) return;\n    if(!t->label_en && !t->major_len && !t->minor_len) return;\n\n    uint32_t i;\n    lv_point_t p1;\n    lv_point_t p2;\n\n    lv_coord_t pad_left = lv_obj_get_style_pad_left(obj, LV_PART_MAIN) + lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n    lv_coord_t w     = ((int32_t)lv_obj_get_content_width(obj) * chart->zoom_x) >> 8;\n\n\n    lv_draw_label_dsc_t label_dsc;\n    lv_draw_label_dsc_init(&label_dsc);\n    lv_obj_init_draw_label_dsc(obj, LV_PART_TICKS, &label_dsc);\n\n    lv_coord_t x_ofs = obj->coords.x1 + pad_left - lv_obj_get_scroll_left(obj);\n    lv_coord_t y_ofs;\n    lv_coord_t label_gap;\n    if(axis == LV_CHART_AXIS_PRIMARY_X) {\n        label_gap = t->label_en ? lv_obj_get_style_pad_bottom(obj, LV_PART_TICKS) : 0;\n        y_ofs = obj->coords.y2;\n    }\n    else {\n        label_gap = t->label_en ? lv_obj_get_style_pad_top(obj, LV_PART_TICKS) : 0;\n        y_ofs = obj->coords.y1;\n    }\n\n    if(axis == LV_CHART_AXIS_PRIMARY_X) {\n        if(y_ofs > clip_area->y2) return;\n        if(y_ofs + label_gap  + label_dsc.font->line_height + t->major_len < clip_area->y1) return;\n    }\n\n    lv_draw_line_dsc_t line_dsc;\n    lv_draw_line_dsc_init(&line_dsc);\n    lv_obj_init_draw_line_dsc(obj, LV_PART_TICKS, &line_dsc);\n    line_dsc.dash_gap = 0;\n    line_dsc.dash_width = 0;\n\n    lv_obj_draw_part_dsc_t part_draw_dsc;\n    lv_obj_draw_dsc_init(&part_draw_dsc, clip_area);\n    part_draw_dsc.class_p = MY_CLASS;\n    part_draw_dsc.type = LV_CHART_DRAW_PART_TICK_LABEL;\n    part_draw_dsc.id = LV_CHART_AXIS_PRIMARY_X;\n    part_draw_dsc.part = LV_PART_TICKS;\n    part_draw_dsc.label_dsc = &label_dsc;\n    part_draw_dsc.line_dsc = &line_dsc;\n\n    uint8_t sec_axis = axis == LV_CHART_AXIS_PRIMARY_X ? 0 : 1;\n\n    /*The columns ticks should be aligned to the center of blocks*/\n    if(chart->type == LV_CHART_TYPE_BAR) {\n        int32_t block_gap = ((int32_t)lv_obj_get_style_pad_column(obj,\n                                                                  LV_PART_MAIN) * chart->zoom_x) >> 8;  /*Gap between the columns on ~adjacent X*/\n        lv_coord_t block_w = (w + block_gap) / (chart->point_cnt);\n        x_ofs += (block_w - block_gap) / 2;\n        w -= block_w - block_gap;\n    }\n\n    p1.y = y_ofs;\n    uint32_t total_tick_num = (t->major_cnt - 1) * t->minor_cnt;\n    for(i = 0; i <= total_tick_num; i++) { /*one extra loop - it may not exist in the list, empty label*/\n        bool major = false;\n        if(i % t->minor_cnt == 0) major = true;\n\n        /*draw a line at moving x position*/\n        p2.x = p1.x = x_ofs + (int32_t)((int32_t)(w - line_dsc.width) * i) / total_tick_num;\n\n        if(sec_axis) p2.y = p1.y - (major ? t->major_len : t->minor_len);\n        else p2.y = p1.y + (major ? t->major_len : t->minor_len);\n\n        part_draw_dsc.p1 = &p1;\n        part_draw_dsc.p2 = &p2;\n\n        /*add text only to major tick*/\n        int32_t tick_value;\n        if(chart->type == LV_CHART_TYPE_SCATTER) {\n            tick_value = lv_map(i, 0, total_tick_num, chart->xmin[sec_axis], chart->xmax[sec_axis]);\n        }\n        else {\n            tick_value = i / t->minor_cnt;\n        }\n        part_draw_dsc.value = tick_value;\n\n        if(major && t->label_en) {\n            char buf[LV_CHART_LABEL_MAX_TEXT_LENGTH];\n            lv_snprintf(buf, sizeof(buf), \"%\" LV_PRId32, tick_value);\n            part_draw_dsc.label_dsc = &label_dsc;\n            part_draw_dsc.text = buf;\n            part_draw_dsc.text_length = LV_CHART_LABEL_MAX_TEXT_LENGTH;\n\n            lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n\n            /*reserve appropriate area*/\n            lv_point_t size;\n            lv_txt_get_size(&size, part_draw_dsc.text, label_dsc.font, label_dsc.letter_space, label_dsc.line_space, LV_COORD_MAX,\n                            LV_TEXT_FLAG_NONE);\n\n            /*set the area at some distance of the major tick len under of the tick*/\n            lv_area_t a;\n            a.x1 = (p2.x - size.x / 2);\n            a.x2 = (p2.x + size.x / 2);\n            if(sec_axis) {\n                a.y2 = p2.y - label_gap;\n                a.y1 = a.y2 - size.y;\n            }\n            else {\n                a.y1 = p2.y + label_gap;\n                a.y2 = a.y1 + size.y;\n            }\n\n            if(a.x2 >= obj->coords.x1 &&\n               a.x1 <= obj->coords.x2) {\n                lv_draw_label(&a, clip_area, &label_dsc, part_draw_dsc.text, NULL);\n            }\n        }\n        else {\n            part_draw_dsc.label_dsc = NULL;\n            part_draw_dsc.text = NULL;\n            part_draw_dsc.text_length = 0;\n            lv_event_send(obj, LV_EVENT_DRAW_PART_BEGIN, &part_draw_dsc);\n        }\n\n\n        if(p1.x + line_dsc.width / 2  >= obj->coords.x1 &&\n           p2.x - line_dsc.width / 2  <= obj->coords.x2) {\n            lv_draw_line(&p1, &p2, clip_area, &line_dsc);\n        }\n\n        lv_event_send(obj, LV_EVENT_DRAW_PART_END, &part_draw_dsc);\n    }\n}"}, "carbit_updater/lvgl/src/extra/widgets/chart/lv_chart.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/widgets/chart/lv_chart.c"}}, "carbit_updater/lv_drivers/display/R61581.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 20}, "carbit_updater/lv_drivers/display/R61581.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/R61581.h"}}, "carbit_updater/lvgl/src/widgets/lv_btn.c": {"lv_btn": {"type": "Variable", "def": "#include lv_btn.h", "sline": 10, "include": ["carbit_updater/lvgl/src/widgets/lv_btn.h", null]}, "lv_flex": {"type": "Variable", "def": "#include ../extra/layouts/flex/lv_flex.h", "sline": 13}, "lv_btn_constructor": {"type": "Function", "def": "static void lv_btn_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 61, "body": "{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_obj_clear_flag(obj, LV_OBJ_FLAG_SCROLLABLE);\n    lv_obj_add_flag(obj, LV_OBJ_FLAG_SCROLL_ON_FOCUS);\n\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}"}, "lv_btn_class": {"type": "Variable", "def": "const lv_obj_class_t lv_btn_class  = {\n    .constructor_cb = lv_btn_constructor,\n    .width_def = LV_SIZE_CONTENT,\n    .height_def = LV_SIZE_CONTENT,\n    .group_def = LV_OBJ_CLASS_GROUP_DEF_TRUE,\n    .instance_size = sizeof(lv_btn_t),\n    .base_class = &lv_obj_class\n}", "sline": 32}, "lv_btn_create": {"type": "Function", "def": "lv_obj_t * lv_btn_create(lv_obj_t * parent)", "sline": 49, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "carbit_updater/lvgl/src/widgets/lv_btn.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_btn.c"}}, "carbit_updater/lvgl/src/core/lv_event.h": {"stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 16}, "_lv_obj_t": {"type": "Struct", "def": "struct _lv_obj_t", "sline": 26}, "_lv_event_dsc_t": {"type": "Struct", "def": "struct _lv_event_dsc_t", "sline": 27}, "lv_event_code_t": {"type": "Variable", "def": "typedef enum {\n    LV_EVENT_ALL = 0,\n\n    /** Input device events*/\n    LV_EVENT_PRESSED,             /**< The object has been pressed*/\n    LV_EVENT_PRESSING,            /**< The object is being pressed (called continuously while pressing)*/\n    LV_EVENT_PRESS_LOST,          /**< The object is still being pressed but slid cursor/finger off of the object */\n    LV_EVENT_SHORT_CLICKED,       /**< The object was pressed for a short period of time, then released it. Not called if scrolled.*/\n    LV_EVENT_LONG_PRESSED,        /**< Object has been pressed for at least `long_press_time`.  Not called if scrolled.*/\n    LV_EVENT_LONG_PRESSED_REPEAT, /**< Called after `long_press_time` in every `long_press_repeat_time` ms.  Not called if scrolled.*/\n    LV_EVENT_CLICKED,             /**< Called on release if not scrolled (regardless to long press)*/\n    LV_EVENT_RELEASED,            /**< Called in every cases when the object has been released*/\n    LV_EVENT_SCROLL_BEGIN,        /**< Scrolling begins*/\n    LV_EVENT_SCROLL_END,          /**< Scrolling ends*/\n    LV_EVENT_SCROLL,              /**< Scrolling*/\n    LV_EVENT_GESTURE,             /**< A gesture is detected. Get the gesture with `lv_indev_get_gesture_dir(lv_indev_get_act());` */\n    LV_EVENT_KEY,                 /**< A key is sent to the object. Get the key with `lv_indev_get_key(lv_indev_get_act());`*/\n    LV_EVENT_FOCUSED,             /**< The object is focused*/\n    LV_EVENT_DEFOCUSED,           /**< The object is defocused*/\n    LV_EVENT_LEAVE,               /**< The object is defocused but still selected*/\n    LV_EVENT_HIT_TEST,            /**< Perform advanced hit-testing*/\n\n    /** Drawing events*/\n    LV_EVENT_COVER_CHECK,        /**< Check if the object fully covers an area. The event parameter is `lv_cover_check_info_t *`.*/\n    LV_EVENT_REFR_EXT_DRAW_SIZE, /**< Get the required extra draw area around the object (e.g. for shadow). The event parameter is `lv_coord_t *` to store the size.*/\n    LV_EVENT_DRAW_MAIN_BEGIN,    /**< Starting the main drawing phase*/\n    LV_EVENT_DRAW_MAIN,          /**< Perform the main drawing*/\n    LV_EVENT_DRAW_MAIN_END,      /**< Finishing the main drawing phase*/\n    LV_EVENT_DRAW_POST_BEGIN,    /**< Starting the post draw phase (when all children are drawn)*/\n    LV_EVENT_DRAW_POST,          /**< Perform the post draw phase (when all children are drawn)*/\n    LV_EVENT_DRAW_POST_END,      /**< Finishing the post draw phase (when all children are drawn)*/\n    LV_EVENT_DRAW_PART_BEGIN,    /**< Starting to draw a part. The event parameter is `lv_obj_draw_dsc_t *`. */\n    LV_EVENT_DRAW_PART_END,      /**< Finishing to draw a part. The event parameter is `lv_obj_draw_dsc_t *`. */\n\n    /** Special events*/\n    LV_EVENT_VALUE_CHANGED,       /**< The object's value has changed (i.e. slider moved)*/\n    LV_EVENT_INSERT,              /**< A text is inserted to the object. The event data is `char *` being inserted.*/\n    LV_EVENT_REFRESH,             /**< Notify the object to refresh something on it (for the user)*/\n    LV_EVENT_READY,               /**< A process has finished*/\n    LV_EVENT_CANCEL,              /**< A process has been cancelled */\n\n    /** Other events*/\n    LV_EVENT_DELETE,              /**< Object is being deleted*/\n    LV_EVENT_CHILD_CHANGED,       /**< Child was removed, added, or its size, position were changed */\n    LV_EVENT_CHILD_CREATED,       /**< Child was created, always bubbles up to all parents*/\n    LV_EVENT_CHILD_DELETED,       /**< Child was deleted, always bubbles up to all parents*/\n    LV_EVENT_SCREEN_UNLOAD_START, /**< A screen unload started, fired immediately when scr_load is called*/\n    LV_EVENT_SCREEN_LOAD_START,   /**< A screen load started, fired when the screen change delay is expired*/\n    LV_EVENT_SCREEN_LOADED,       /**< A screen was loaded*/\n    LV_EVENT_SCREEN_UNLOADED,     /**< A screen was unloaded*/\n    LV_EVENT_SIZE_CHANGED,        /**< Object coordinates/size have changed*/\n    LV_EVENT_STYLE_CHANGED,       /**< Object's style has changed*/\n    LV_EVENT_LAYOUT_CHANGED,      /**< The children position has changed due to a layout recalculation*/\n    LV_EVENT_GET_SELF_SIZE,       /**< Get the internal size of a widget*/\n\n    _LV_EVENT_LAST                /** Number of default events*/\n} lv_event_code_t", "sline": 88, "docstring": "/**"}, "_lv_event_t.target": {"type": "Variable", "def": "struct _lv_obj_t * target", "sline": 91, "in_struct": "_lv_event_t"}, "_lv_event_t.current_target": {"type": "Variable", "def": "struct _lv_obj_t * current_target", "sline": 92, "in_struct": "_lv_event_t"}, "_lv_event_t.code": {"type": "Variable", "def": "lv_event_code_t code", "sline": 93, "in_struct": "_lv_event_t", "rels": [["lv_event_code_t", null, "Typeof"]]}, "_lv_event_t.user_data": {"type": "Variable", "def": "void * user_data", "sline": 94, "in_struct": "_lv_event_t"}, "_lv_event_t.param": {"type": "Variable", "def": "void * param", "sline": 95, "in_struct": "_lv_event_t"}, "_lv_event_t.prev": {"type": "Variable", "def": "struct _lv_event_t * prev", "sline": 96, "in_struct": "_lv_event_t"}, "_lv_event_t.deleted": {"type": "Variable", "def": "uint8_t deleted", "sline": 97, "in_struct": "_lv_event_t"}, "_lv_event_t": {"type": "Struct", "def": "struct _lv_event_t {\n    struct _lv_obj_t * target;\n    struct _lv_obj_t * current_target;\n    lv_event_code_t code;\n    void * user_data;\n    void * param;\n    struct _lv_event_t * prev;\n    uint8_t deleted : 1;\n}", "sline": 90, "body": "struct _lv_obj_t * target\nstruct _lv_obj_t * current_target\nlv_event_code_t code\nvoid * user_data\nvoid * param\nstruct _lv_event_t * prev\nuint8_t deleted\n"}, "lv_event_t": {"type": "Variable", "def": "typedef struct _lv_event_t {\n    struct _lv_obj_t * target;\n    struct _lv_obj_t * current_target;\n    lv_event_code_t code;\n    void * user_data;\n    void * param;\n    struct _lv_event_t * prev;\n    uint8_t deleted : 1;\n} lv_event_t", "sline": 98}, "lv_event_cb_t": {"type": "Variable", "def": "typedef void (*lv_event_cb_t)(lv_event_t * e)", "sline": 105}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_event.h:114:9).point": {"type": "Variable", "def": "const lv_point_t * point", "sline": 115, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_event.h:114:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_event.h:114:9).res": {"type": "Variable", "def": "bool res", "sline": 116, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_event.h:114:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_event.h:114:9)": {"type": "Struct", "def": "struct {\n    const lv_point_t * point;   /**< A point relative to screen to check if it can click the object or not*/\n    bool res;                   /**< true: `point` can click the object; false: it cannot*/\n}", "sline": 114, "body": "const lv_point_t * point\nbool res\n"}, "lv_hit_test_info_t": {"type": "Variable", "def": "typedef struct {\n    const lv_point_t * point;   /**< A point relative to screen to check if it can click the object or not*/\n    bool res;                   /**< true: `point` can click the object; false: it cannot*/\n} lv_hit_test_info_t", "sline": 117}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_event.h:124:9).res": {"type": "Variable", "def": "lv_cover_res_t res", "sline": 125, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_event.h:124:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_event.h:124:9).area": {"type": "Variable", "def": "const lv_area_t * area", "sline": 126, "in_struct": "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_event.h:124:9)"}, "struct (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_event.h:124:9)": {"type": "Struct", "def": "struct {\n    lv_cover_res_t res;\n    const lv_area_t * area;\n}", "sline": 124, "body": "lv_cover_res_t res\nconst lv_area_t * area\n"}, "lv_cover_check_info_t": {"type": "Variable", "def": "typedef struct {\n    lv_cover_res_t res;\n    const lv_area_t * area;\n} lv_cover_check_info_t", "sline": 127}, "lv_event_send": {"type": "Function", "def": "lv_res_t lv_event_send(struct _lv_obj_t * obj, lv_event_code_t event_code, void * param)", "sline": 140}, "lv_obj_event_base": {"type": "Function", "def": "lv_res_t lv_obj_event_base(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 148}, "lv_event_get_target": {"type": "Function", "def": "struct _lv_obj_t * lv_event_get_target(lv_event_t * e)", "sline": 155}, "lv_event_get_current_target": {"type": "Function", "def": "struct _lv_obj_t * lv_event_get_current_target(lv_event_t * e)", "sline": 163}, "lv_event_get_code": {"type": "Function", "def": "lv_event_code_t lv_event_get_code(lv_event_t * e)", "sline": 170, "rels": [["lv_event_code_t", null, "Typeof"]]}, "lv_event_get_param": {"type": "Function", "def": "void * lv_event_get_param(lv_event_t * e)", "sline": 177}, "lv_event_get_user_data": {"type": "Function", "def": "void * lv_event_get_user_data(lv_event_t * e)", "sline": 184}, "lv_event_register_id": {"type": "Function", "def": "uint32_t lv_event_register_id(void)", "sline": 198}, "_lv_event_mark_deleted": {"type": "Function", "def": "void _lv_event_mark_deleted(struct _lv_obj_t * obj)", "sline": 205}, "lv_obj_add_event_cb": {"type": "Function", "def": "struct _lv_event_dsc_t * lv_obj_add_event_cb(struct _lv_obj_t * obj, lv_event_cb_t event_cb, lv_event_code_t filter,\n                                             void * user_data)", "sline": 218}, "lv_obj_remove_event_cb": {"type": "Function", "def": "bool lv_obj_remove_event_cb(struct _lv_obj_t * obj, lv_event_cb_t event_cb)", "sline": 227}, "lv_obj_remove_event_cb_with_user_data": {"type": "Function", "def": "bool lv_obj_remove_event_cb_with_user_data(struct _lv_obj_t * obj, lv_event_cb_t event_cb,\n                                           const void * event_user_data)", "sline": 236}, "lv_obj_remove_event_dsc": {"type": "Function", "def": "bool lv_obj_remove_event_dsc(struct _lv_obj_t * obj, struct _lv_event_dsc_t * event_dsc)", "sline": 246}, "lv_event_get_indev": {"type": "Function", "def": "lv_indev_t * lv_event_get_indev(lv_event_t * e)", "sline": 253}, "lv_event_get_draw_part_dsc": {"type": "Function", "def": "lv_obj_draw_part_dsc_t * lv_event_get_draw_part_dsc(lv_event_t * e)", "sline": 260}, "lv_event_get_clip_area": {"type": "Function", "def": "const lv_area_t * lv_event_get_clip_area(lv_event_t * e)", "sline": 268}, "lv_event_get_old_size": {"type": "Function", "def": "const lv_area_t * lv_event_get_old_size(lv_event_t * e)", "sline": 275}, "lv_event_get_key": {"type": "Function", "def": "uint32_t lv_event_get_key(lv_event_t * e)", "sline": 282}, "lv_event_get_scroll_anim": {"type": "Function", "def": "lv_anim_t * lv_event_get_scroll_anim(lv_event_t * e)", "sline": 289}, "lv_event_set_ext_draw_size": {"type": "Function", "def": "void lv_event_set_ext_draw_size(lv_event_t * e, lv_coord_t size)", "sline": 296}, "lv_event_get_self_size_info": {"type": "Function", "def": "lv_point_t * lv_event_get_self_size_info(lv_event_t * e)", "sline": 304}, "lv_event_get_hit_test_info": {"type": "Function", "def": "lv_hit_test_info_t * lv_event_get_hit_test_info(lv_event_t * e)", "sline": 311}, "lv_event_get_cover_area": {"type": "Function", "def": "const lv_area_t * lv_event_get_cover_area(lv_event_t * e)", "sline": 319}, "lv_event_set_cover_res": {"type": "Function", "def": "void lv_event_set_cover_res(lv_event_t * e, lv_cover_res_t res)", "sline": 326}, "carbit_updater/lvgl/src/core/lv_event.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_event.h"}}, "carbit_updater/lvgl/src/gpu/lv_gpu_stm32_dma2d.c": {"lv_gpu_stm32_dma2d": {"type": "Variable", "def": "#include lv_gpu_stm32_dma2d.h", "sline": 9, "include": ["carbit_updater/lvgl/src/gpu/lv_gpu_stm32_dma2d.h", null]}, "lv_disp": {"type": "Variable", "def": "#include ../core/lv_disp.h", "sline": 10}, "lv_refr": {"type": "Variable", "def": "#include ../core/lv_refr.h", "sline": 11}, "carbit_updater/lvgl/src/gpu/lv_gpu_stm32_dma2d.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_stm32_dma2d.c"}}, "carbit_updater/lv_drivers/win32drv/win32drv.c": {"win32drv": {"type": "Variable", "def": "#include win32drv.h", "sline": 10, "include": ["carbit_updater/lv_drivers/win32drv/win32drv.h", null]}, "carbit_updater/lv_drivers/win32drv/win32drv.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/win32drv/win32drv.c"}}, "carbit_updater/lvgl/src/core/lv_theme.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 9}, "apply_theme": {"type": "Function", "def": "static void apply_theme(lv_theme_t * th, lv_obj_t * obj)", "sline": 114, "body": "{\n    if(th->parent) apply_theme(th->parent, obj);\n    if(th->apply_cb) th->apply_cb(th, obj);\n}"}, "lv_theme_get_from_obj": {"type": "Function", "def": "lv_theme_t  * lv_theme_get_from_obj(lv_obj_t * obj)", "sline": 36, "body": "{\n    lv_disp_t * disp = obj ? lv_obj_get_disp(obj) : lv_disp_get_default();\n    return lv_disp_get_theme(disp);\n}"}, "lv_theme_apply": {"type": "Function", "def": "void lv_theme_apply(lv_obj_t * obj)", "sline": 47, "body": "{\n    lv_theme_t * th = lv_theme_get_from_obj(obj);\n    if(th == NULL) return;\n\n    lv_obj_remove_style_all(obj);\n\n    apply_theme(th, obj);    /*Apply the theme including the base theme(s)*/\n}"}, "lv_theme_set_parent": {"type": "Function", "def": "void lv_theme_set_parent(lv_theme_t * new_theme, lv_theme_t * base)", "sline": 64, "body": "{\n    new_theme->parent = base;\n}"}, "lv_theme_set_apply_cb": {"type": "Function", "def": "void lv_theme_set_apply_cb(lv_theme_t * theme, lv_theme_apply_cb_t apply_cb)", "sline": 75, "body": "{\n    theme->apply_cb = apply_cb;\n}"}, "lv_theme_get_font_small": {"type": "Function", "def": "const lv_font_t * lv_theme_get_font_small(lv_obj_t * obj)", "sline": 80, "body": "{\n    lv_theme_t * th = lv_theme_get_from_obj(obj);\n    return th ? th->font_small : LV_FONT_DEFAULT;\n}"}, "lv_theme_get_font_normal": {"type": "Function", "def": "const lv_font_t * lv_theme_get_font_normal(lv_obj_t * obj)", "sline": 86, "body": "{\n    lv_theme_t * th = lv_theme_get_from_obj(obj);\n    return th ? th->font_normal : LV_FONT_DEFAULT;\n}"}, "lv_theme_get_font_large": {"type": "Function", "def": "const lv_font_t * lv_theme_get_font_large(lv_obj_t * obj)", "sline": 92, "body": "{\n    lv_theme_t * th = lv_theme_get_from_obj(obj);\n    return th ? th->font_large : LV_FONT_DEFAULT;\n}"}, "lv_theme_get_color_primary": {"type": "Function", "def": "lv_color_t lv_theme_get_color_primary(lv_obj_t * obj)", "sline": 98, "body": "{\n    lv_theme_t * th = lv_theme_get_from_obj(obj);\n    return th ? th->color_primary : lv_palette_main(LV_PALETTE_BLUE_GREY);\n}"}, "lv_theme_get_color_secondary": {"type": "Function", "def": "lv_color_t lv_theme_get_color_secondary(lv_obj_t * obj)", "sline": 104, "body": "{\n    lv_theme_t * th = lv_theme_get_from_obj(obj);\n    return th ? th->color_secondary : lv_palette_main(LV_PALETTE_BLUE);\n}"}, "carbit_updater/lvgl/src/core/lv_theme.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/core/lv_theme.c"}}, "carbit_updater/lv_drivers/display/UC1610.h": {"lv_drv_conf": {"type": "Variable", "def": "#include ../../lv_drv_conf.h", "sline": 20}, "carbit_updater/lv_drivers/display/UC1610.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lv_drivers/display/UC1610.h"}}, "carbit_updater/lvgl/src/widgets/lv_textarea.c": {"lv_textarea": {"type": "Variable", "def": "#include lv_textarea.h", "sline": 9, "include": ["carbit_updater/lvgl/src/widgets/lv_textarea.h", null]}, "string": {"type": "Variable", "def": "#include string.h", "sline": 12}, "lv_assert": {"type": "Variable", "def": "#include ../misc/lv_assert.h", "sline": 13}, "lv_group": {"type": "Variable", "def": "#include ../core/lv_group.h", "sline": 14}, "lv_refr": {"type": "Variable", "def": "#include ../core/lv_refr.h", "sline": 15}, "lv_indev": {"type": "Variable", "def": "#include ../core/lv_indev.h", "sline": 16}, "lv_draw": {"type": "Variable", "def": "#include ../draw/lv_draw.h", "sline": 17}, "lv_anim": {"type": "Variable", "def": "#include ../misc/lv_anim.h", "sline": 18}, "lv_txt": {"type": "Variable", "def": "#include ../misc/lv_txt.h", "sline": 19}, "lv_math": {"type": "Variable", "def": "#include ../misc/lv_math.h", "sline": 20}, "lv_textarea_constructor": {"type": "Function", "def": "static void lv_textarea_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 799, "body": "{\n    LV_UNUSED(class_p);\n    LV_TRACE_OBJ_CREATE(\"begin\");\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n\n    ta->pwd_mode          = 0;\n    ta->pwd_tmp           = NULL;\n    ta->pwd_show_time     = LV_TEXTAREA_DEF_PWD_SHOW_TIME;\n    ta->accepted_chars    = NULL;\n    ta->max_length        = 0;\n    ta->cursor.show      = 1;\n    /*It will be set to zero later (with zero value lv_textarea_set_cursor_pos(obj, 0); woldn't do anything as there is no difference)*/\n    ta->cursor.pos        = 1;\n    ta->cursor.click_pos  = 1;\n    ta->cursor.valid_x    = 0;\n    ta->one_line          = 0;\n#if LV_LABEL_TEXT_SELECTION\n    ta->text_sel_en = 0;\n#endif\n    ta->label       = NULL;\n    ta->placeholder_txt = NULL;\n\n    ta->label = lv_label_create(obj);\n    lv_obj_set_width(ta->label, lv_pct(100));\n    lv_label_set_text(ta->label, \"\");\n    lv_obj_add_event_cb(ta->label, label_event_cb, LV_EVENT_ALL, NULL);\n    lv_obj_add_flag(obj, LV_OBJ_FLAG_SCROLL_ON_FOCUS);\n    lv_textarea_set_cursor_pos(obj, 0);\n\n    start_cursor_blink(obj);\n\n    LV_TRACE_OBJ_CREATE(\"finished\");\n}"}, "lv_textarea_destructor": {"type": "Function", "def": "static void lv_textarea_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)", "sline": 835, "body": "{\n    LV_UNUSED(class_p);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    if(ta->pwd_tmp != NULL) {\n        lv_mem_free(ta->pwd_tmp);\n        ta->pwd_tmp = NULL;\n    }\n    if(ta->placeholder_txt != NULL) {\n        lv_mem_free(ta->placeholder_txt);\n        ta->placeholder_txt = NULL;\n    }\n}"}, "lv_textarea_event": {"type": "Function", "def": "static void lv_textarea_event(const lv_obj_class_t * class_p, lv_event_t * e)", "sline": 850, "body": "{\n    LV_UNUSED(class_p);\n\n    lv_res_t res;\n    /*Call the ancestor's event handler*/\n    res = lv_obj_event_base(MY_CLASS, e);\n    if(res != LV_RES_OK) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n\n    if(code == LV_EVENT_FOCUSED) {\n        start_cursor_blink(obj);\n    }\n    else if(code == LV_EVENT_KEY) {\n        uint32_t c = *((uint32_t *)lv_event_get_param(e)); /*uint32_t because can be UTF-8*/\n        if(c == LV_KEY_RIGHT)\n            lv_textarea_cursor_right(obj);\n        else if(c == LV_KEY_LEFT)\n            lv_textarea_cursor_left(obj);\n        else if(c == LV_KEY_UP)\n            lv_textarea_cursor_up(obj);\n        else if(c == LV_KEY_DOWN)\n            lv_textarea_cursor_down(obj);\n        else if(c == LV_KEY_BACKSPACE)\n            lv_textarea_del_char(obj);\n        else if(c == LV_KEY_DEL)\n            lv_textarea_del_char_forward(obj);\n        else if(c == LV_KEY_HOME)\n            lv_textarea_set_cursor_pos(obj, 0);\n        else if(c == LV_KEY_END)\n            lv_textarea_set_cursor_pos(obj, LV_TEXTAREA_CURSOR_LAST);\n        else if(c == LV_KEY_ENTER && lv_textarea_get_one_line(obj))\n            lv_event_send(obj, LV_EVENT_READY, NULL);\n        else {\n            lv_textarea_add_char(obj, c);\n        }\n    }\n    else if(code == LV_EVENT_PRESSED || code == LV_EVENT_PRESSING || code == LV_EVENT_PRESS_LOST ||\n            code == LV_EVENT_RELEASED) {\n        update_cursor_position_on_click(e);\n    }\n    else if(code == LV_EVENT_DRAW_MAIN) {\n        draw_placeholder(e);\n    }\n    else if(code == LV_EVENT_DRAW_POST) {\n        draw_cursor(e);\n    }\n}"}, "label_event_cb": {"type": "Function", "def": "static void label_event_cb(lv_event_t * e)", "sline": 901, "body": "{\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * label = lv_event_get_target(e);\n    lv_obj_t * ta = lv_obj_get_parent(label);\n\n    if(code == LV_EVENT_STYLE_CHANGED || code == LV_EVENT_SIZE_CHANGED) {\n        lv_label_set_text(label, NULL);\n        refr_cursor_area(ta);\n        start_cursor_blink(ta);\n    }\n}"}, "cursor_blink_anim_cb": {"type": "Function", "def": "static void cursor_blink_anim_cb(void * obj, int32_t show)", "sline": 921, "body": "{\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    if(show != ta->cursor.show) {\n        ta->cursor.show = show == 0 ? 0 : 1;\n        lv_area_t area_tmp;\n        lv_area_copy(&area_tmp, &ta->cursor.area);\n        area_tmp.x1 += ta->label->coords.x1;\n        area_tmp.y1 += ta->label->coords.y1;\n        area_tmp.x2 += ta->label->coords.x1;\n        area_tmp.y2 += ta->label->coords.y1;\n        lv_obj_invalidate_area(obj, &area_tmp);\n    }\n}"}, "pwd_char_hider_anim": {"type": "Function", "def": "static void pwd_char_hider_anim(void * obj, int32_t x)", "sline": 943, "body": "{\n    LV_UNUSED(obj);\n    LV_UNUSED(x);\n}"}, "pwd_char_hider_anim_ready": {"type": "Function", "def": "static void pwd_char_hider_anim_ready(lv_anim_t * a)", "sline": 953, "body": "{\n    lv_obj_t * obj = a->var;\n    pwd_char_hider(obj);\n}"}, "pwd_char_hider": {"type": "Function", "def": "static void pwd_char_hider(lv_obj_t * obj)", "sline": 963, "body": "{\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    if(ta->pwd_mode != 0) {\n        char * txt  = lv_label_get_text(ta->label);\n        int32_t enc_len = _lv_txt_get_encoded_length(txt);\n        if(enc_len == 0) return;\n\n        /*If the textarea's font has \"bullet\" character use it else fallback to \"*\"*/\n        const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_MAIN);\n        lv_font_glyph_dsc_t g;\n        bool has_bullet;\n        has_bullet = lv_font_get_glyph_dsc(font, &g, LV_TEXTAREA_PWD_BULLET_UNICODE, 0);\n        const char * bullet;\n        if(has_bullet) bullet = LV_SYMBOL_BULLET;\n        else bullet = \"*\";\n\n        size_t bullet_len = strlen(bullet);\n        char * txt_tmp = lv_mem_buf_get(enc_len * bullet_len + 1);\n        int32_t i;\n        for(i = 0; i < enc_len; i++) {\n            lv_memcpy(&txt_tmp[i * bullet_len], bullet, bullet_len);\n        }\n\n        txt_tmp[i * bullet_len] = '\\0';\n\n        lv_label_set_text(ta->label, txt_tmp);\n        lv_mem_buf_release(txt_tmp);\n        refr_cursor_area(obj);\n    }\n}"}, "char_is_accepted": {"type": "Function", "def": "static bool char_is_accepted(lv_obj_t * obj, uint32_t c)", "sline": 1001, "body": "{\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n\n    /*If no restriction accept it*/\n    if((ta->accepted_chars == NULL || ta->accepted_chars[0] == '\\0') && ta->max_length == 0) return true;\n\n    /*Too many characters?*/\n    if(ta->max_length > 0 && _lv_txt_get_encoded_length(lv_textarea_get_text(obj)) >= ta->max_length) {\n        return false;\n    }\n\n    /*Accepted character?*/\n    if(ta->accepted_chars) {\n        uint32_t i = 0;\n\n        while(ta->accepted_chars[i] != '\\0') {\n            uint32_t a = _lv_txt_encoded_next(ta->accepted_chars, &i);\n            if(a == c) return true; /*Accepted*/\n        }\n\n        return false; /*The character wasn't in the list*/\n    }\n    else {\n        return true; /*If the accepted char list in not specified the accept the character*/\n    }\n}"}, "start_cursor_blink": {"type": "Function", "def": "static void start_cursor_blink(lv_obj_t * obj)", "sline": 1029, "body": "{\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    uint32_t blink_time = lv_obj_get_style_anim_time(obj, LV_PART_CURSOR);\n    if(blink_time == 0) {\n        lv_anim_del(obj, cursor_blink_anim_cb);\n        ta->cursor.show = 1;\n    }\n    else {\n        lv_anim_t a;\n        lv_anim_init(&a);\n        lv_anim_set_var(&a, ta);\n        lv_anim_set_exec_cb(&a, cursor_blink_anim_cb);\n        lv_anim_set_time(&a, blink_time);\n        lv_anim_set_playback_time(&a, blink_time);\n        lv_anim_set_values(&a, 1, 0);\n        lv_anim_set_path_cb(&a, lv_anim_path_step);\n        lv_anim_set_repeat_count(&a, LV_ANIM_REPEAT_INFINITE);\n        lv_anim_start(&a);\n    }\n}"}, "refr_cursor_area": {"type": "Function", "def": "static void refr_cursor_area(lv_obj_t * obj)", "sline": 1051, "body": "{\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n\n    const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_MAIN);\n    lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);\n\n    uint32_t cur_pos = lv_textarea_get_cursor_pos(obj);\n    const char * txt = lv_label_get_text(ta->label);\n\n    uint32_t byte_pos;\n    byte_pos = _lv_txt_encoded_get_byte_id(txt, cur_pos);\n\n    uint32_t letter = _lv_txt_encoded_next(&txt[byte_pos], NULL);\n\n    lv_coord_t letter_h = lv_font_get_line_height(font);\n\n    /*Set letter_w (set not 0 on non printable but valid chars)*/\n    lv_coord_t letter_w;\n    if(letter == '\\0' || letter == '\\n' || letter == '\\r') {\n        letter_w = lv_font_get_glyph_width(font, ' ', '\\0');\n    }\n    else {\n        /*`letter_next` parameter is '\\0' to ignore kerning*/\n        letter_w = lv_font_get_glyph_width(font, letter, '\\0');\n    }\n\n    lv_point_t letter_pos;\n    lv_label_get_letter_pos(ta->label, cur_pos, &letter_pos);\n\n    lv_text_align_t align = lv_obj_calculate_style_text_align(ta->label, LV_PART_MAIN, lv_label_get_text(ta->label));\n\n    /*If the cursor is out of the text (most right) draw it to the next line*/\n    if(letter_pos.x + ta->label->coords.x1 + letter_w > ta->label->coords.x2 && ta->one_line == 0 &&\n       align != LV_TEXT_ALIGN_RIGHT) {\n        letter_pos.x = 0;\n        letter_pos.y += letter_h + line_space;\n\n        if(letter != '\\0') {\n            byte_pos += _lv_txt_encoded_size(&txt[byte_pos]);\n            letter = _lv_txt_encoded_next(&txt[byte_pos], NULL);\n        }\n\n        if(letter == '\\0' || letter == '\\n' || letter == '\\r') {\n            letter_w = lv_font_get_glyph_width(font, ' ', '\\0');\n        }\n        else {\n            letter_w = lv_font_get_glyph_width(font, letter, '\\0');\n        }\n    }\n\n    /*Save the byte position. It is required to draw `LV_CURSOR_BLOCK`*/\n    ta->cursor.txt_byte_pos = byte_pos;\n\n    /*Calculate the cursor according to its type*/\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_CURSOR);\n    lv_coord_t top = lv_obj_get_style_pad_top(obj, LV_PART_CURSOR) + border_width;\n    lv_coord_t bottom = lv_obj_get_style_pad_bottom(obj, LV_PART_CURSOR) + border_width;\n    lv_coord_t left = lv_obj_get_style_pad_left(obj, LV_PART_CURSOR) + border_width;\n    lv_coord_t right = lv_obj_get_style_pad_right(obj, LV_PART_CURSOR) + border_width;\n\n    lv_area_t cur_area;\n    cur_area.x1 = letter_pos.x - left;\n    cur_area.y1 = letter_pos.y - top;\n    cur_area.x2 = letter_pos.x + right + letter_w - 1;\n    cur_area.y2 = letter_pos.y + bottom + letter_h - 1;\n\n    /*Save the new area*/\n    lv_area_t area_tmp;\n    lv_area_copy(&area_tmp, &ta->cursor.area);\n    area_tmp.x1 += ta->label->coords.x1;\n    area_tmp.y1 += ta->label->coords.y1;\n    area_tmp.x2 += ta->label->coords.x1;\n    area_tmp.y2 += ta->label->coords.y1;\n    lv_obj_invalidate_area(obj, &area_tmp);\n\n    lv_area_copy(&ta->cursor.area, &cur_area);\n\n    lv_area_copy(&area_tmp, &ta->cursor.area);\n    area_tmp.x1 += ta->label->coords.x1;\n    area_tmp.y1 += ta->label->coords.y1;\n    area_tmp.x2 += ta->label->coords.x1;\n    area_tmp.y2 += ta->label->coords.y1;\n    lv_obj_invalidate_area(obj, &area_tmp);\n}"}, "update_cursor_position_on_click": {"type": "Function", "def": "static void update_cursor_position_on_click(lv_event_t * e)", "sline": 1137, "body": "{\n    lv_indev_t * click_source = lv_indev_get_act();\n    if(click_source == NULL) return;\n\n    lv_event_code_t code = lv_event_get_code(e);\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    if(ta->cursor.click_pos == 0) return;\n\n    if(lv_indev_get_type(click_source) == LV_INDEV_TYPE_KEYPAD ||\n       lv_indev_get_type(click_source) == LV_INDEV_TYPE_ENCODER) {\n        return;\n    }\n\n    lv_area_t label_coords;\n    lv_obj_get_coords(ta->label, &label_coords);\n\n    lv_point_t point_act, vect_act;\n    lv_indev_get_point(click_source, &point_act);\n    lv_indev_get_vect(click_source, &vect_act);\n\n    if(point_act.x < 0 || point_act.y < 0) return; /*Ignore event from keypad*/\n    lv_point_t rel_pos;\n    rel_pos.x = point_act.x - label_coords.x1;\n    rel_pos.y = point_act.y - label_coords.y1;\n\n    lv_coord_t label_width = lv_obj_get_width(ta->label);\n\n    uint16_t char_id_at_click;\n\n#if LV_LABEL_TEXT_SELECTION\n    lv_label_t * label_data = (lv_label_t *)ta->label;\n    bool click_outside_label;\n    /*Check if the click happened on the left side of the area outside the label*/\n    if(rel_pos.x < 0) {\n        char_id_at_click = 0;\n        click_outside_label       = true;\n    }\n    /*Check if the click happened on the right side of the area outside the label*/\n    else if(rel_pos.x >= label_width) {\n        char_id_at_click = LV_TEXTAREA_CURSOR_LAST;\n        click_outside_label       = true;\n    }\n    else {\n        char_id_at_click = lv_label_get_letter_on(ta->label, &rel_pos);\n        click_outside_label       = !lv_label_is_char_under_pos(ta->label, &rel_pos);\n    }\n\n    if(ta->text_sel_en) {\n        if(!ta->text_sel_in_prog && !click_outside_label && code == LV_EVENT_PRESSED) {\n            /*Input device just went down. Store the selection start position*/\n            ta->sel_start    = char_id_at_click;\n            ta->sel_end      = LV_LABEL_TEXT_SELECTION_OFF;\n            ta->text_sel_in_prog = 1;\n            lv_obj_clear_flag(obj, LV_OBJ_FLAG_SCROLL_CHAIN);\n        }\n        else if(ta->text_sel_in_prog && code == LV_EVENT_PRESSING) {\n            /*Input device may be moving. Store the end position*/\n            ta->sel_end = char_id_at_click;\n        }\n        else if(ta->text_sel_in_prog && (code == LV_EVENT_PRESS_LOST || code == LV_EVENT_RELEASED)) {\n            /*Input device is released. Check if anything was selected.*/\n            lv_obj_add_flag(obj, LV_OBJ_FLAG_SCROLL_CHAIN);\n        }\n    }\n\n    if(ta->text_sel_in_prog || code == LV_EVENT_PRESSED) lv_textarea_set_cursor_pos(obj, char_id_at_click);\n\n    if(ta->text_sel_in_prog) {\n        /*If the selected area has changed then update the real values and*/\n\n        /*Invalidate the text area.*/\n        if(ta->sel_start > ta->sel_end) {\n            if(label_data->sel_start != ta->sel_end || label_data->sel_end != ta->sel_start) {\n                label_data->sel_start = ta->sel_end;\n                label_data->sel_end   = ta->sel_start;\n                lv_obj_invalidate(obj);\n            }\n        }\n        else if(ta->sel_start < ta->sel_end) {\n            if(label_data->sel_start != ta->sel_start || label_data->sel_end != ta->sel_end) {\n                label_data->sel_start = ta->sel_start;\n                label_data->sel_end   = ta->sel_end;\n                lv_obj_invalidate(obj);\n            }\n        }\n        else {\n            if(label_data->sel_start != LV_DRAW_LABEL_NO_TXT_SEL || label_data->sel_end != LV_DRAW_LABEL_NO_TXT_SEL) {\n                label_data->sel_start = LV_DRAW_LABEL_NO_TXT_SEL;\n                label_data->sel_end   = LV_DRAW_LABEL_NO_TXT_SEL;\n                lv_obj_invalidate(obj);\n            }\n        }\n        /*Finish selection if necessary*/\n        if(code == LV_EVENT_PRESS_LOST || code == LV_EVENT_RELEASED) {\n            ta->text_sel_in_prog = 0;\n        }\n    }\n#else\n    /*Check if the click happened on the left side of the area outside the label*/\n    if(rel_pos.x < 0) {\n        char_id_at_click = 0;\n    }\n    /*Check if the click happened on the right side of the area outside the label*/\n    else if(rel_pos.x >= label_width) {\n        char_id_at_click = LV_TEXTAREA_CURSOR_LAST;\n    }\n    else {\n        char_id_at_click = lv_label_get_letter_on(ta->label, &rel_pos);\n    }\n\n    if(code == LV_EVENT_PRESSED) lv_textarea_set_cursor_pos(obj, char_id_at_click);\n#endif\n}"}, "insert_handler": {"type": "Function", "def": "static lv_res_t insert_handler(lv_obj_t * obj, const char * txt)", "sline": 1253, "body": "{\n    ta_insert_replace = NULL;\n    lv_event_send(obj, LV_EVENT_INSERT, (char *)txt);\n    if(ta_insert_replace) {\n        if(ta_insert_replace[0] == '\\0') return LV_RES_INV; /*Drop this text*/\n\n        /*Add the replaced text directly it's different from the original*/\n        if(strcmp(ta_insert_replace, txt)) {\n            lv_textarea_add_text(obj, ta_insert_replace);\n            return LV_RES_INV;\n        }\n    }\n\n    return LV_RES_OK;\n}"}, "draw_placeholder": {"type": "Function", "def": "static void draw_placeholder(lv_event_t * e)", "sline": 1270, "body": "{\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    const lv_area_t * clip_area = lv_event_get_param(e);\n    const char * txt = lv_label_get_text(ta->label);\n\n    /*Draw the place holder*/\n    if(txt[0] == '\\0' && ta->placeholder_txt && ta->placeholder_txt[0] != 0) {\n        lv_draw_label_dsc_t ph_dsc;\n        lv_draw_label_dsc_init(&ph_dsc);\n        lv_obj_init_draw_label_dsc(obj, LV_PART_TEXTAREA_PLACEHOLDER, &ph_dsc);\n\n        if(ta->one_line) ph_dsc.flag |= LV_TEXT_FLAG_EXPAND;\n\n        lv_coord_t left = lv_obj_get_style_pad_left(obj, LV_PART_MAIN);\n        lv_coord_t top = lv_obj_get_style_pad_top(obj, LV_PART_MAIN);\n        lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_MAIN);\n        lv_area_t ph_coords;\n        lv_area_copy(&ph_coords, &obj->coords);\n        lv_area_move(&ph_coords, left + border_width, top + border_width);\n        lv_draw_label(&ph_coords, clip_area, &ph_dsc, ta->placeholder_txt, NULL);\n    }\n}"}, "draw_cursor": {"type": "Function", "def": "static void draw_cursor(lv_event_t * e)", "sline": 1295, "body": "{\n    lv_obj_t * obj = lv_event_get_target(e);\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    const lv_area_t * clip_area = lv_event_get_param(e);\n    const char * txt = lv_label_get_text(ta->label);\n\n    if(ta->cursor.show == 0) return;\n\n    lv_draw_rect_dsc_t cur_dsc;\n    lv_draw_rect_dsc_init(&cur_dsc);\n    lv_obj_init_draw_rect_dsc(obj, LV_PART_CURSOR, &cur_dsc);\n\n    /*Draw he cursor according to the type*/\n    lv_area_t cur_area;\n    lv_area_copy(&cur_area, &ta->cursor.area);\n\n\n    cur_area.x1 += ta->label->coords.x1;\n    cur_area.y1 += ta->label->coords.y1;\n    cur_area.x2 += ta->label->coords.x1;\n    cur_area.y2 += ta->label->coords.y1;\n\n    lv_draw_rect(&cur_area, clip_area, &cur_dsc);\n\n    lv_coord_t border_width = lv_obj_get_style_border_width(obj, LV_PART_CURSOR);\n    lv_coord_t left = lv_obj_get_style_pad_left(obj, LV_PART_CURSOR) + border_width;\n    lv_coord_t top = lv_obj_get_style_pad_top(obj, LV_PART_CURSOR) + border_width;\n    char letter_buf[8] = {0};\n    lv_memcpy(letter_buf, &txt[ta->cursor.txt_byte_pos], _lv_txt_encoded_size(&txt[ta->cursor.txt_byte_pos]));\n\n    cur_area.x1 += left;\n    cur_area.y1 += top;\n\n    /*Draw the letter over the cursor only if\n     *the cursor has background or the letter has different color than the original.\n     *Else the original letter is drawn twice which makes it look bolder*/\n    lv_color_t label_color = lv_obj_get_style_text_color(ta->label, 0);\n    lv_draw_label_dsc_t cur_label_dsc;\n    lv_draw_label_dsc_init(&cur_label_dsc);\n    lv_obj_init_draw_label_dsc(obj, LV_PART_CURSOR, &cur_label_dsc);\n    if(cur_dsc.bg_opa > LV_OPA_MIN || cur_label_dsc.color.full != label_color.full) {\n        lv_draw_label(&cur_area, clip_area, &cur_label_dsc, letter_buf, NULL);\n    }\n}"}, "lv_textarea_class": {"type": "Variable", "def": "const lv_obj_class_t lv_textarea_class = {\n    .constructor_cb = lv_textarea_constructor,\n    .destructor_cb = lv_textarea_destructor,\n    .event_cb = lv_textarea_event,\n    .group_def = LV_OBJ_CLASS_GROUP_DEF_TRUE,\n    .width_def = LV_DPI_DEF * 2,\n    .height_def = LV_DPI_DEF,\n    .instance_size = sizeof(lv_textarea_t),\n    .base_class = &lv_obj_class\n}", "sline": 64}, "ta_insert_replace": {"type": "Variable", "def": "static const char * ta_insert_replace", "sline": 75}, "lv_textarea_create": {"type": "Function", "def": "lv_obj_t * lv_textarea_create(lv_obj_t * parent)", "sline": 85, "body": "{\n    LV_LOG_INFO(\"begin\");\n    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);\n    lv_obj_class_init_obj(obj);\n    return obj;\n}"}, "lv_textarea_add_char": {"type": "Function", "def": "void lv_textarea_add_char(lv_obj_t * obj, uint32_t c)", "sline": 97, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n\n    const char * letter_buf;\n\n    uint32_t u32_buf[2];\n    u32_buf[0] = c;\n    u32_buf[1] = 0;\n\n    letter_buf = (char *)&u32_buf;\n\n#if LV_BIG_ENDIAN_SYSTEM\n    if(c != 0) while(*letter_buf == 0) ++letter_buf;\n#endif\n\n    lv_res_t res = insert_handler(obj, letter_buf);\n    if(res != LV_RES_OK) return;\n\n    if(ta->one_line && (c == '\\n' || c == '\\r')) {\n        LV_LOG_INFO(\"Text area: line break ignored in one-line mode\");\n        return;\n    }\n\n    uint32_t c_uni = _lv_txt_encoded_next((const char *)&c, NULL);\n\n    if(char_is_accepted(obj, c_uni) == false) {\n        LV_LOG_INFO(\"Character is not accepted by the text area (too long text or not in the accepted list)\");\n        return;\n    }\n\n    if(ta->pwd_mode != 0) pwd_char_hider(obj); /*Make sure all the current text contains only '*'*/\n\n    /*If the textarea is empty, invalidate it to hide the placeholder*/\n    if(ta->placeholder_txt) {\n        const char * txt = lv_label_get_text(ta->label);\n        if(txt[0] == '\\0') lv_obj_invalidate(obj);\n    }\n\n    lv_label_ins_text(ta->label, ta->cursor.pos, letter_buf); /*Insert the character*/\n    lv_textarea_clear_selection(obj);                                                /*Clear selection*/\n\n    if(ta->pwd_mode != 0) {\n        ta->pwd_tmp = lv_mem_realloc(ta->pwd_tmp, strlen(ta->pwd_tmp) + strlen(letter_buf) + 1); /*+2: the new char + \\0*/\n        LV_ASSERT_MALLOC(ta->pwd_tmp);\n        if(ta->pwd_tmp == NULL) return;\n\n        _lv_txt_ins(ta->pwd_tmp, ta->cursor.pos, (const char *)letter_buf);\n\n        /*Auto hide characters*/\n        if(ta->pwd_show_time == 0) {\n            pwd_char_hider(obj);\n        }\n        else {\n            lv_anim_t a;\n            lv_anim_init(&a);\n            lv_anim_set_var(&a, ta);\n            lv_anim_set_exec_cb(&a, pwd_char_hider_anim);\n            lv_anim_set_time(&a, ta->pwd_show_time);\n            lv_anim_set_values(&a, 0, 1);\n            lv_anim_set_path_cb(&a, lv_anim_path_step);\n            lv_anim_set_ready_cb(&a, pwd_char_hider_anim_ready);\n            lv_anim_start(&a);\n        }\n    }\n\n    /*Move the cursor after the new character*/\n    lv_textarea_set_cursor_pos(obj, lv_textarea_get_cursor_pos(obj) + 1);\n\n    lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n}"}, "lv_textarea_add_text": {"type": "Function", "def": "void lv_textarea_add_text(lv_obj_t * obj, const char * txt)", "sline": 171, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(txt);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n\n    if(ta->pwd_mode != 0) pwd_char_hider(obj); /*Make sure all the current text contains only '*'*/\n\n    /*Add the character one-by-one if not all characters are accepted or there is character limit.*/\n    if(lv_textarea_get_accepted_chars(obj) || lv_textarea_get_max_length(obj)) {\n        uint32_t i = 0;\n        while(txt[i] != '\\0') {\n            uint32_t c = _lv_txt_encoded_next(txt, &i);\n            lv_textarea_add_char(obj, _lv_txt_unicode_to_encoded(c));\n        }\n        return;\n    }\n\n    lv_res_t res = insert_handler(obj, txt);\n    if(res != LV_RES_OK) return;\n\n    /*If the textarea is empty, invalidate it to hide the placeholder*/\n    if(ta->placeholder_txt) {\n        const char * txt_act = lv_label_get_text(ta->label);\n        if(txt_act[0] == '\\0') lv_obj_invalidate(obj);\n    }\n\n    /*Insert the text*/\n    lv_label_ins_text(ta->label, ta->cursor.pos, txt);\n    lv_textarea_clear_selection(obj);\n\n    if(ta->pwd_mode != 0) {\n        ta->pwd_tmp = lv_mem_realloc(ta->pwd_tmp, strlen(ta->pwd_tmp) + strlen(txt) + 1);\n        LV_ASSERT_MALLOC(ta->pwd_tmp);\n        if(ta->pwd_tmp == NULL) return;\n\n        _lv_txt_ins(ta->pwd_tmp, ta->cursor.pos, txt);\n\n        /*Auto hide characters*/\n        if(ta->pwd_show_time == 0) {\n            pwd_char_hider(obj);\n        }\n        else {\n            lv_anim_t a;\n            lv_anim_init(&a);\n            lv_anim_set_var(&a, ta);\n            lv_anim_set_exec_cb(&a, pwd_char_hider_anim);\n            lv_anim_set_time(&a, ta->pwd_show_time);\n            lv_anim_set_values(&a, 0, 1);\n            lv_anim_set_path_cb(&a, lv_anim_path_step);\n            lv_anim_set_ready_cb(&a, pwd_char_hider_anim_ready);\n            lv_anim_start(&a);\n        }\n    }\n\n    /*Move the cursor after the new text*/\n    lv_textarea_set_cursor_pos(obj, lv_textarea_get_cursor_pos(obj) + _lv_txt_get_encoded_length(txt));\n\n    lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n}"}, "lv_textarea_del_char": {"type": "Function", "def": "void lv_textarea_del_char(lv_obj_t * obj)", "sline": 233, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    uint32_t cur_pos  = ta->cursor.pos;\n\n    if(cur_pos == 0) return;\n\n    char del_buf[2]   = {LV_KEY_DEL, '\\0'};\n\n    lv_res_t res = insert_handler(obj, del_buf);\n    if(res != LV_RES_OK) return;\n\n    char * label_txt = lv_label_get_text(ta->label);\n\n    /*Delete a character*/\n    _lv_txt_cut(label_txt, ta->cursor.pos - 1, 1);\n\n    /*Refresh the label*/\n    lv_label_set_text(ta->label, label_txt);\n    lv_textarea_clear_selection(obj);\n\n    /*If the textarea became empty, invalidate it to hide the placeholder*/\n    if(ta->placeholder_txt) {\n        const char * txt = lv_label_get_text(ta->label);\n        if(txt[0] == '\\0') lv_obj_invalidate(obj);\n    }\n\n    if(ta->pwd_mode != 0) {\n        _lv_txt_cut(ta->pwd_tmp, ta->cursor.pos - 1, 1);\n\n        ta->pwd_tmp = lv_mem_realloc(ta->pwd_tmp, strlen(ta->pwd_tmp) + 1);\n        LV_ASSERT_MALLOC(ta->pwd_tmp);\n        if(ta->pwd_tmp == NULL) return;\n    }\n\n    /*Move the cursor to the place of the deleted character*/\n    lv_textarea_set_cursor_pos(obj, ta->cursor.pos - 1);\n\n    lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n\n}"}, "lv_textarea_del_char_forward": {"type": "Function", "def": "void lv_textarea_del_char_forward(lv_obj_t * obj)", "sline": 277, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    uint32_t cp = lv_textarea_get_cursor_pos(obj);\n    lv_textarea_set_cursor_pos(obj, cp + 1);\n    if(cp != lv_textarea_get_cursor_pos(obj)) lv_textarea_del_char(obj);\n}"}, "lv_textarea_set_text": {"type": "Function", "def": "void lv_textarea_set_text(lv_obj_t * obj, const char * txt)", "sline": 290, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(txt);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n\n    /*Clear the existing selection*/\n    lv_textarea_clear_selection(obj);\n\n    /*Add the character one-by-one if not all characters are accepted or there is character limit.*/\n    if(lv_textarea_get_accepted_chars(obj) || lv_textarea_get_max_length(obj)) {\n        lv_label_set_text(ta->label, \"\");\n        lv_textarea_set_cursor_pos(obj, LV_TEXTAREA_CURSOR_LAST);\n        if(ta->pwd_mode != 0) {\n            ta->pwd_tmp[0] = '\\0'; /*Clear the password too*/\n        }\n        uint32_t i = 0;\n        while(txt[i] != '\\0') {\n            uint32_t c = _lv_txt_encoded_next(txt, &i);\n            lv_textarea_add_char(obj, _lv_txt_unicode_to_encoded(c));\n        }\n    }\n    else {\n        lv_label_set_text(ta->label, txt);\n        lv_textarea_set_cursor_pos(obj, LV_TEXTAREA_CURSOR_LAST);\n    }\n\n    /*If the textarea is empty, invalidate it to hide the placeholder*/\n    if(ta->placeholder_txt) {\n        const char * txt_act = lv_label_get_text(ta->label);\n        if(txt_act[0] == '\\0') lv_obj_invalidate(obj);\n    }\n\n    if(ta->pwd_mode != 0) {\n        ta->pwd_tmp = lv_mem_realloc(ta->pwd_tmp, strlen(txt) + 1);\n        LV_ASSERT_MALLOC(ta->pwd_tmp);\n        if(ta->pwd_tmp == NULL) return;\n        strcpy(ta->pwd_tmp, txt);\n\n        /*Auto hide characters*/\n        if(ta->pwd_show_time == 0) {\n            pwd_char_hider(obj);\n        }\n        else {\n            lv_anim_t a;\n            lv_anim_init(&a);\n            lv_anim_set_var(&a, ta);\n            lv_anim_set_exec_cb(&a, pwd_char_hider_anim);\n            lv_anim_set_time(&a, ta->pwd_show_time);\n            lv_anim_set_values(&a, 0, 1);\n            lv_anim_set_path_cb(&a, lv_anim_path_step);\n            lv_anim_set_ready_cb(&a, pwd_char_hider_anim_ready);\n            lv_anim_start(&a);\n        }\n    }\n\n    lv_event_send(obj, LV_EVENT_VALUE_CHANGED, NULL);\n}"}, "lv_textarea_set_placeholder_text": {"type": "Function", "def": "void lv_textarea_set_placeholder_text(lv_obj_t * obj, const char * txt)", "sline": 350, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n    LV_ASSERT_NULL(txt);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n\n    size_t txt_len = strlen(txt);\n\n    if(txt_len == 0) {\n        if(ta->placeholder_txt) {\n            lv_mem_free(ta->placeholder_txt);\n            ta->placeholder_txt = NULL;\n        }\n    }\n    else {\n\n        /*Allocate memory for the placeholder_txt text*/\n        if(ta->placeholder_txt == NULL) {\n            ta->placeholder_txt = lv_mem_alloc(txt_len + 1);\n        }\n        else {\n            ta->placeholder_txt = lv_mem_realloc(ta->placeholder_txt, txt_len + 1);\n\n        }\n        LV_ASSERT_MALLOC(ta->placeholder_txt);\n        if(ta->placeholder_txt == NULL) {\n            LV_LOG_ERROR(\"lv_textarea_set_placeholder_text: couldn't allocate memory for placeholder\");\n            return;\n        }\n        strcpy(ta->placeholder_txt, txt);\n    }\n\n    lv_obj_invalidate(obj);\n}"}, "lv_textarea_set_cursor_pos": {"type": "Function", "def": "void lv_textarea_set_cursor_pos(lv_obj_t * obj, int32_t pos)", "sline": 386, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    if((uint32_t)ta->cursor.pos == (uint32_t)pos) return;\n\n    uint32_t len = _lv_txt_get_encoded_length(lv_label_get_text(ta->label));\n\n    if(pos < 0) pos = len + pos;\n\n    if(pos > (int32_t)len || pos == LV_TEXTAREA_CURSOR_LAST) pos = len;\n\n    ta->cursor.pos = pos;\n\n    /*Position the label to make the cursor visible*/\n    lv_obj_update_layout(obj);\n\n    lv_point_t cur_pos;\n    const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_MAIN);\n    lv_label_get_letter_pos(ta->label, pos, &cur_pos);\n\n    /*The text area needs to have it's final size to see if the cursor is out of the area or not*/\n\n    /*Check the top*/\n    lv_coord_t font_h = lv_font_get_line_height(font);\n    if(cur_pos.y < lv_obj_get_scroll_top(obj)) {\n        lv_obj_scroll_to_y(obj, cur_pos.y, LV_ANIM_ON);\n    }\n    /*Check the bottom*/\n    lv_coord_t h = lv_obj_get_content_height(obj);\n    if(cur_pos.y + font_h - lv_obj_get_scroll_top(obj) > h) {\n        lv_obj_scroll_to_y(obj, cur_pos.y - h + font_h, LV_ANIM_ON);\n    }\n\n    /*Check the left*/\n    if(cur_pos.x < lv_obj_get_scroll_left(obj)) {\n        lv_obj_scroll_to_x(obj, cur_pos.x, LV_ANIM_ON);\n    }\n    /*Check the right*/\n    lv_coord_t w = lv_obj_get_content_width(obj);\n    if(cur_pos.x + font_h - lv_obj_get_scroll_left(obj) > w) {\n        lv_obj_scroll_to_x(obj, cur_pos.x - w + font_h, LV_ANIM_ON);\n    }\n\n    ta->cursor.valid_x = cur_pos.x;\n\n    start_cursor_blink(obj);\n\n    refr_cursor_area(obj);\n}"}, "lv_textarea_set_cursor_click_pos": {"type": "Function", "def": "void lv_textarea_set_cursor_click_pos(lv_obj_t * obj, bool en)", "sline": 438, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    ta->cursor.click_pos = en ? 1 : 0;\n}"}, "lv_textarea_set_password_mode": {"type": "Function", "def": "void lv_textarea_set_password_mode(lv_obj_t * obj, bool en)", "sline": 446, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    if(ta->pwd_mode == en) return;\n\n    ta->pwd_mode = en == false ? 0 : 1;\n    /*Pwd mode is now enabled*/\n    if(en != false) {\n        char * txt   = lv_label_get_text(ta->label);\n        size_t len = strlen(txt);\n        ta->pwd_tmp = lv_mem_alloc(len + 1);\n        LV_ASSERT_MALLOC(ta->pwd_tmp);\n        if(ta->pwd_tmp == NULL) return;\n\n        strcpy(ta->pwd_tmp, txt);\n\n        pwd_char_hider(obj);\n\n        lv_textarea_clear_selection(obj);\n    }\n    /*Pwd mode is now disabled*/\n    else {\n        lv_textarea_clear_selection(obj);\n        lv_label_set_text(ta->label, ta->pwd_tmp);\n        lv_mem_free(ta->pwd_tmp);\n        ta->pwd_tmp = NULL;\n    }\n\n    refr_cursor_area(obj);\n}"}, "lv_textarea_set_one_line": {"type": "Function", "def": "void lv_textarea_set_one_line(lv_obj_t * obj, bool en)", "sline": 479, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    if(ta->one_line == en) return;\n\n    if(en) {\n        ta->one_line = 1;\n        lv_obj_set_width(ta->label, LV_SIZE_CONTENT);\n        lv_obj_set_style_min_width(ta->label, lv_pct(100), 0);\n\n        lv_obj_set_height(obj, LV_SIZE_CONTENT);\n        lv_obj_scroll_to(obj, 0, 0, LV_ANIM_OFF);\n    }\n    else {\n        ta->one_line = 0;\n        lv_obj_set_width(ta->label, lv_pct(100));\n        lv_obj_set_style_min_width(ta->label, 0, 0);\n        lv_obj_remove_local_style_prop(obj, LV_STYLE_HEIGHT, LV_PART_MAIN);\n        lv_obj_scroll_to(obj, 0, 0, LV_ANIM_OFF);\n    }\n}"}, "lv_textarea_set_accepted_chars": {"type": "Function", "def": "void lv_textarea_set_accepted_chars(lv_obj_t * obj, const char * list)", "sline": 503, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n\n    ta->accepted_chars = list;\n}"}, "lv_textarea_set_max_length": {"type": "Function", "def": "void lv_textarea_set_max_length(lv_obj_t * obj, uint32_t num)", "sline": 512, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n\n    ta->max_length = num;\n}"}, "lv_textarea_set_insert_replace": {"type": "Function", "def": "void lv_textarea_set_insert_replace(lv_obj_t * obj, const char * txt)", "sline": 521, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    LV_UNUSED(obj);\n    ta_insert_replace = txt;\n}"}, "lv_textarea_set_text_selection": {"type": "Function", "def": "void lv_textarea_set_text_selection(lv_obj_t * obj, bool en)", "sline": 529, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n#if LV_LABEL_TEXT_SELECTION\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n\n    ta->text_sel_en = en;\n\n    if(!en) lv_textarea_clear_selection(obj);\n#else\n    LV_UNUSED(obj); /*Unused*/\n    LV_UNUSED(en);  /*Unused*/\n#endif\n}"}, "lv_textarea_set_password_show_time": {"type": "Function", "def": "void lv_textarea_set_password_show_time(lv_obj_t * obj, uint16_t time)", "sline": 545, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    ta->pwd_show_time = time;\n}"}, "lv_textarea_set_align": {"type": "Function", "def": "void lv_textarea_set_align(lv_obj_t * obj, lv_text_align_t align)", "sline": 553, "body": "{\n    LV_LOG_WARN(\"Deprecated: use the normal text_align style property instead\");\n    lv_obj_set_style_text_align(obj, align, 0);\n\n    switch(align) {\n        default:\n        case LV_TEXT_ALIGN_LEFT:\n            lv_obj_align(lv_textarea_get_label(obj), LV_ALIGN_TOP_LEFT, 0, 0);\n            break;\n        case LV_TEXT_ALIGN_RIGHT:\n            lv_obj_align(lv_textarea_get_label(obj), LV_ALIGN_TOP_RIGHT, 0, 0);\n            break;\n        case LV_TEXT_ALIGN_CENTER:\n            lv_obj_align(lv_textarea_get_label(obj), LV_ALIGN_TOP_MID, 0, 0);\n            break;\n    }\n}"}, "lv_textarea_get_text": {"type": "Function", "def": "const char * lv_textarea_get_text(const lv_obj_t * obj)", "sline": 576, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n\n    const char * txt;\n    if(ta->pwd_mode == 0) {\n        txt = lv_label_get_text(ta->label);\n    }\n    else {\n        txt = ta->pwd_tmp;\n    }\n\n    return txt;\n}"}, "lv_textarea_get_placeholder_text": {"type": "Function", "def": "const char * lv_textarea_get_placeholder_text(lv_obj_t * obj)", "sline": 593, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    if(ta->placeholder_txt) return ta->placeholder_txt;\n    else return \"\";\n}"}, "lv_textarea_get_label": {"type": "Function", "def": "lv_obj_t * lv_textarea_get_label(const lv_obj_t * obj)", "sline": 602, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    return ta->label;\n}"}, "lv_textarea_get_cursor_pos": {"type": "Function", "def": "uint32_t lv_textarea_get_cursor_pos(const lv_obj_t * obj)", "sline": 610, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    return ta->cursor.pos;\n}"}, "lv_textarea_get_cursor_click_pos": {"type": "Function", "def": "bool lv_textarea_get_cursor_click_pos(lv_obj_t * obj)", "sline": 618, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    return ta->cursor.click_pos ? true : false;\n}"}, "lv_textarea_get_password_mode": {"type": "Function", "def": "bool lv_textarea_get_password_mode(const lv_obj_t * obj)", "sline": 626, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    return ta->pwd_mode == 0 ? false : true;\n}"}, "lv_textarea_get_one_line": {"type": "Function", "def": "bool lv_textarea_get_one_line(const lv_obj_t * obj)", "sline": 634, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    return ta->one_line == 0 ? false : true;\n}"}, "lv_textarea_get_accepted_chars": {"type": "Function", "def": "const char * lv_textarea_get_accepted_chars(lv_obj_t * obj)", "sline": 642, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n\n    return ta->accepted_chars;\n}"}, "lv_textarea_get_max_length": {"type": "Function", "def": "uint32_t lv_textarea_get_max_length(lv_obj_t * obj)", "sline": 651, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    return ta->max_length;\n}"}, "lv_textarea_text_is_selected": {"type": "Function", "def": "bool lv_textarea_text_is_selected(const lv_obj_t * obj)", "sline": 659, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n#if LV_LABEL_TEXT_SELECTION\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n\n    if((lv_label_get_text_selection_start(ta->label) != LV_DRAW_LABEL_NO_TXT_SEL ||\n        lv_label_get_text_selection_end(ta->label) != LV_DRAW_LABEL_NO_TXT_SEL)) {\n        return true;\n    }\n    else {\n        return false;\n    }\n#else\n    LV_UNUSED(obj); /*Unused*/\n    return false;\n#endif\n}"}, "lv_textarea_get_text_selection": {"type": "Function", "def": "bool lv_textarea_get_text_selection(lv_obj_t * obj)", "sline": 679, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n#if LV_LABEL_TEXT_SELECTION\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    return ta->text_sel_en;\n#else\n    LV_UNUSED(obj); /*Unused*/\n    return false;\n#endif\n}"}, "lv_textarea_get_password_show_time": {"type": "Function", "def": "uint16_t lv_textarea_get_password_show_time(lv_obj_t * obj)", "sline": 692, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n\n    return ta->pwd_show_time;\n}"}, "lv_textarea_clear_selection": {"type": "Function", "def": "void lv_textarea_clear_selection(lv_obj_t * obj)", "sline": 705, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n#if LV_LABEL_TEXT_SELECTION\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n\n    if(lv_label_get_text_selection_start(ta->label) != LV_DRAW_LABEL_NO_TXT_SEL ||\n       lv_label_get_text_selection_end(ta->label) != LV_DRAW_LABEL_NO_TXT_SEL) {\n        lv_label_set_text_sel_start(ta->label, LV_DRAW_LABEL_NO_TXT_SEL);\n        lv_label_set_text_sel_end(ta->label, LV_DRAW_LABEL_NO_TXT_SEL);\n    }\n#else\n    LV_UNUSED(obj); /*Unused*/\n#endif\n}"}, "lv_textarea_cursor_right": {"type": "Function", "def": "void lv_textarea_cursor_right(lv_obj_t * obj)", "sline": 722, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    uint32_t cp = lv_textarea_get_cursor_pos(obj);\n    cp++;\n    lv_textarea_set_cursor_pos(obj, cp);\n}"}, "lv_textarea_cursor_left": {"type": "Function", "def": "void lv_textarea_cursor_left(lv_obj_t * obj)", "sline": 731, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    uint32_t cp = lv_textarea_get_cursor_pos(obj);\n    if(cp > 0) {\n        cp--;\n        lv_textarea_set_cursor_pos(obj, cp);\n    }\n}"}, "lv_textarea_cursor_down": {"type": "Function", "def": "void lv_textarea_cursor_down(lv_obj_t * obj)", "sline": 742, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    lv_point_t pos;\n\n    /*Get the position of the current letter*/\n    lv_label_get_letter_pos(ta->label, lv_textarea_get_cursor_pos(obj), &pos);\n\n    /*Increment the y with one line and keep the valid x*/\n\n    lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);\n    const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_MAIN);\n    lv_coord_t font_h              = lv_font_get_line_height(font);\n    pos.y += font_h + line_space + 1;\n    pos.x = ta->cursor.valid_x;\n\n    /*Do not go below the last line*/\n    if(pos.y < lv_obj_get_height(ta->label)) {\n        /*Get the letter index on the new cursor position and set it*/\n        uint32_t new_cur_pos = lv_label_get_letter_on(ta->label, &pos);\n\n        lv_coord_t cur_valid_x_tmp = ta->cursor.valid_x; /*Cursor position set overwrites the valid position*/\n        lv_textarea_set_cursor_pos(obj, new_cur_pos);\n        ta->cursor.valid_x = cur_valid_x_tmp;\n    }\n}"}, "lv_textarea_cursor_up": {"type": "Function", "def": "void lv_textarea_cursor_up(lv_obj_t * obj)", "sline": 771, "body": "{\n    LV_ASSERT_OBJ(obj, MY_CLASS);\n\n    lv_textarea_t * ta = (lv_textarea_t *)obj;\n    lv_point_t pos;\n\n    /*Get the position of the current letter*/\n    lv_label_get_letter_pos(ta->label, lv_textarea_get_cursor_pos(obj), &pos);\n\n    /*Decrement the y with one line and keep the valid x*/\n    lv_coord_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);\n    const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_MAIN);\n    lv_coord_t font_h              = lv_font_get_line_height(font);\n    pos.y -= font_h + line_space - 1;\n    pos.x = ta->cursor.valid_x;\n\n    /*Get the letter index on the new cursor position and set it*/\n    uint32_t new_cur_pos       = lv_label_get_letter_on(ta->label, &pos);\n    lv_coord_t cur_valid_x_tmp = ta->cursor.valid_x; /*Cursor position set overwrites the valid position*/\n    lv_textarea_set_cursor_pos(obj, new_cur_pos);\n    ta->cursor.valid_x = cur_valid_x_tmp;\n}"}, "carbit_updater/lvgl/src/widgets/lv_textarea.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/widgets/lv_textarea.c"}}, "carbit_updater/lvgl/src/draw/lv_draw_rect.h": {"lv_draw_blend": {"type": "Variable", "def": "#include lv_draw_blend.h", "sline": 16, "include": ["carbit_updater/lvgl/src/draw/lv_draw_blend.h", null]}, "lv_font": {"type": "Variable", "def": "#include ../font/lv_font.h", "sline": 17}, "_silence_gcc_warning": {"type": "Struct", "def": "LV_EXPORT_CONST_INT(LV_RADIUS_CIRCLE)", "sline": 23}, "lv_draw_rect_dsc_t.radius": {"type": "Variable", "def": "lv_coord_t radius", "sline": 31, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.blend_mode": {"type": "Variable", "def": "lv_blend_mode_t blend_mode", "sline": 32, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.bg_color": {"type": "Variable", "def": "lv_color_t bg_color", "sline": 35, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.bg_grad_color": {"type": "Variable", "def": "lv_color_t bg_grad_color", "sline": 36, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.bg_main_color_stop": {"type": "Variable", "def": "uint8_t bg_main_color_stop", "sline": 37, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.bg_grad_color_stop": {"type": "Variable", "def": "uint8_t bg_grad_color_stop", "sline": 38, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.bg_opa": {"type": "Variable", "def": "lv_opa_t bg_opa", "sline": 39, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.bg_grad_dir": {"type": "Variable", "def": "lv_grad_dir_t bg_grad_dir : 3", "sline": 40, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.bg_img_src": {"type": "Variable", "def": "const void * bg_img_src", "sline": 43, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.bg_img_symbol_font": {"type": "Variable", "def": "const void * bg_img_symbol_font", "sline": 44, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.bg_img_recolor": {"type": "Variable", "def": "lv_color_t bg_img_recolor", "sline": 45, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.bg_img_opa": {"type": "Variable", "def": "lv_opa_t bg_img_opa", "sline": 46, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.bg_img_recolor_opa": {"type": "Variable", "def": "lv_opa_t bg_img_recolor_opa", "sline": 47, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.bg_img_tiled": {"type": "Variable", "def": "uint8_t bg_img_tiled", "sline": 48, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.border_color": {"type": "Variable", "def": "lv_color_t border_color", "sline": 51, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.border_width": {"type": "Variable", "def": "lv_coord_t border_width", "sline": 52, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.border_opa": {"type": "Variable", "def": "lv_opa_t border_opa", "sline": 53, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.border_post": {"type": "Variable", "def": "uint8_t border_post : 1", "sline": 54, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.border_side": {"type": "Variable", "def": "lv_border_side_t border_side : 5", "sline": 55, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.outline_color": {"type": "Variable", "def": "lv_color_t outline_color", "sline": 58, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.outline_width": {"type": "Variable", "def": "lv_coord_t outline_width", "sline": 59, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.outline_pad": {"type": "Variable", "def": "lv_coord_t outline_pad", "sline": 60, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.outline_opa": {"type": "Variable", "def": "lv_opa_t outline_opa", "sline": 61, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.shadow_color": {"type": "Variable", "def": "lv_color_t shadow_color", "sline": 64, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.shadow_width": {"type": "Variable", "def": "lv_coord_t shadow_width", "sline": 65, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.shadow_ofs_x": {"type": "Variable", "def": "lv_coord_t shadow_ofs_x", "sline": 66, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.shadow_ofs_y": {"type": "Variable", "def": "lv_coord_t shadow_ofs_y", "sline": 67, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.shadow_spread": {"type": "Variable", "def": "lv_coord_t shadow_spread", "sline": 68, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t.shadow_opa": {"type": "Variable", "def": "lv_opa_t shadow_opa", "sline": 69, "in_struct": "lv_draw_rect_dsc_t"}, "lv_draw_rect_dsc_t": {"type": "Variable", "def": "typedef struct {\n    lv_coord_t radius;\n    lv_blend_mode_t blend_mode;\n\n    /*Background*/\n    lv_color_t bg_color;\n    lv_color_t bg_grad_color;\n    uint8_t bg_main_color_stop;\n    uint8_t bg_grad_color_stop;\n    lv_opa_t bg_opa;\n    lv_grad_dir_t bg_grad_dir : 3;\n\n    /*Background img*/\n    const void * bg_img_src;\n    const void * bg_img_symbol_font;\n    lv_color_t bg_img_recolor;\n    lv_opa_t bg_img_opa;\n    lv_opa_t bg_img_recolor_opa;\n    uint8_t bg_img_tiled;\n\n    /*Border*/\n    lv_color_t border_color;\n    lv_coord_t border_width;\n    lv_opa_t border_opa;\n    uint8_t border_post : 1;        /*There is a border it will be drawn later.*/\n    lv_border_side_t border_side : 5;\n\n    /*Outline*/\n    lv_color_t outline_color;\n    lv_coord_t outline_width;\n    lv_coord_t outline_pad;\n    lv_opa_t outline_opa;\n\n    /*Shadow*/\n    lv_color_t shadow_color;\n    lv_coord_t shadow_width;\n    lv_coord_t shadow_ofs_x;\n    lv_coord_t shadow_ofs_y;\n    lv_coord_t shadow_spread;\n    lv_opa_t shadow_opa;\n} lv_draw_rect_dsc_t", "sline": 70}, "lv_draw_rect_dsc_init": {"type": "Function", "def": "void lv_draw_rect_dsc_init(lv_draw_rect_dsc_t * dsc)", "sline": 76}, "lv_draw_rect": {"type": "Function", "def": "void lv_draw_rect(const lv_area_t * coords, const lv_area_t * clip, const lv_draw_rect_dsc_t * dsc)", "sline": 86}, "carbit_updater/lvgl/src/draw/lv_draw_rect.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/draw/lv_draw_rect.h"}}, "carbit_updater/lvgl/src/font/lv_font.h": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 16}, "stdint": {"type": "Variable", "def": "#include stdint.h", "sline": 17}, "stddef": {"type": "Variable", "def": "#include stddef.h", "sline": 18}, "stdbool": {"type": "Variable", "def": "#include stdbool.h", "sline": 19}, "lv_symbol_def": {"type": "Variable", "def": "#include lv_symbol_def.h", "sline": 21, "include": ["carbit_updater/lvgl/src/font/lv_symbol_def.h", null]}, "lv_area": {"type": "Variable", "def": "#include ../misc/lv_area.h", "sline": 22}, "lv_font_glyph_dsc_t.adv_w": {"type": "Variable", "def": "uint16_t adv_w", "sline": 38, "in_struct": "lv_font_glyph_dsc_t"}, "lv_font_glyph_dsc_t.box_w": {"type": "Variable", "def": "uint16_t box_w", "sline": 39, "in_struct": "lv_font_glyph_dsc_t"}, "lv_font_glyph_dsc_t.box_h": {"type": "Variable", "def": "uint16_t box_h", "sline": 40, "in_struct": "lv_font_glyph_dsc_t"}, "lv_font_glyph_dsc_t.ofs_x": {"type": "Variable", "def": "int16_t ofs_x", "sline": 41, "in_struct": "lv_font_glyph_dsc_t"}, "lv_font_glyph_dsc_t.ofs_y": {"type": "Variable", "def": "int16_t ofs_y", "sline": 42, "in_struct": "lv_font_glyph_dsc_t"}, "lv_font_glyph_dsc_t.bpp": {"type": "Variable", "def": "uint8_t bpp", "sline": 43, "in_struct": "lv_font_glyph_dsc_t"}, "lv_font_glyph_dsc_t": {"type": "Variable", "def": "typedef struct {\n    uint16_t adv_w; /**< The glyph needs this space. Draw the next glyph after this width.*/\n    uint16_t box_w;  /**< Width of the glyph's bounding box*/\n    uint16_t box_h;  /**< Height of the glyph's bounding box*/\n    int16_t ofs_x;   /**< x offset of the bounding box*/\n    int16_t ofs_y;  /**< y offset of the bounding box*/\n    uint8_t bpp;   /**< Bit-per-pixel: 1, 2, 4, 8*/\n} lv_font_glyph_dsc_t", "sline": 44, "docstring": "/** Describes the properties of a glyph.*/"}, "enum (unnamed at /home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font.h:47:1)": {"type": "Enum", "def": "enum {\n    LV_FONT_SUBPX_NONE,\n    LV_FONT_SUBPX_HOR,\n    LV_FONT_SUBPX_VER,\n    LV_FONT_SUBPX_BOTH,\n}", "sline": 47, "docstring": "/** The bitmaps might be upscaled by 3 to achieve subpixel rendering.*/"}, "lv_font_subpx_t": {"type": "Variable", "def": "typedef uint8_t lv_font_subpx_t", "sline": 54}, "_lv_font_t": {"type": "Struct", "def": "struct _lv_font_t {\n    /** Get a glyph's descriptor from a font*/\n    bool (*get_glyph_dsc)(const struct _lv_font_t *, lv_font_glyph_dsc_t *, uint32_t letter, uint32_t letter_next);\n\n    /** Get a glyph's bitmap from a font*/\n    const uint8_t * (*get_glyph_bitmap)(const struct _lv_font_t *, uint32_t);\n\n    /*Pointer to the font in a font pack (must have the same line height)*/\n    lv_coord_t line_height;         /**< The real line height where any text fits*/\n    lv_coord_t base_line;           /**< Base line measured from the top of the line_height*/\n    uint8_t subpx  : 2;             /**< An element of `lv_font_subpx_t`*/\n\n    int8_t underline_position;      /**< Distance between the top of the underline and base line (< 0 means below the base line)*/\n    int8_t underline_thickness;     /**< Thickness of the underline*/\n\n    const void * dsc;                     /**< Store implementation specific or run_time data or caching here*/\n#if LV_USE_USER_DATA\n    void * user_data;               /**< Custom user data for font.*/\n#endif\n\n}", "sline": 59, "docstring": "/** Describe the properties of a font*/", "body": "bool (*get_glyph_dsc)(const struct _lv_font_t *, lv_font_glyph_dsc_t *, uint32_t letter, uint32_t letter_next)\nconst uint8_t * (*get_glyph_bitmap)(const struct _lv_font_t *, uint32_t)\nlv_coord_t line_height\nlv_coord_t base_line\nuint8_t subpx  : 2\nint8_t underline_position\nint8_t underline_thickness\nconst void * dsc\nvoid * user_data\n"}, "_lv_font_t.bool": {"type": "Variable", "def": "bool (*get_glyph_dsc)(const struct _lv_font_t *, lv_font_glyph_dsc_t *, uint32_t letter, uint32_t letter_next)", "sline": 61, "in_struct": "_lv_font_t"}, "_lv_font_t.get_glyph_bitmap": {"type": "Variable", "def": "const uint8_t * (*get_glyph_bitmap)(const struct _lv_font_t *, uint32_t)", "sline": 64, "in_struct": "_lv_font_t"}, "_lv_font_t.line_height": {"type": "Variable", "def": "lv_coord_t line_height", "sline": 67, "in_struct": "_lv_font_t"}, "_lv_font_t.base_line": {"type": "Variable", "def": "lv_coord_t base_line", "sline": 68, "in_struct": "_lv_font_t"}, "_lv_font_t.subpx": {"type": "Variable", "def": "uint8_t subpx  : 2", "sline": 69, "in_struct": "_lv_font_t"}, "_lv_font_t.underline_position": {"type": "Variable", "def": "int8_t underline_position", "sline": 71, "in_struct": "_lv_font_t"}, "_lv_font_t.underline_thickness": {"type": "Variable", "def": "int8_t underline_thickness", "sline": 72, "in_struct": "_lv_font_t"}, "_lv_font_t.dsc": {"type": "Variable", "def": "const void * dsc", "sline": 74, "in_struct": "_lv_font_t"}, "_lv_font_t.user_data": {"type": "Variable", "def": "void * user_data", "sline": 76, "in_struct": "_lv_font_t"}, "lv_font_t": {"type": "Variable", "def": "typedef struct _lv_font_t {\n    /** Get a glyph's descriptor from a font*/\n    bool (*get_glyph_dsc)(const struct _lv_font_t *, lv_font_glyph_dsc_t *, uint32_t letter, uint32_t letter_next);\n\n    /** Get a glyph's bitmap from a font*/\n    const uint8_t * (*get_glyph_bitmap)(const struct _lv_font_t *, uint32_t);\n\n    /*Pointer to the font in a font pack (must have the same line height)*/\n    lv_coord_t line_height;         /**< The real line height where any text fits*/\n    lv_coord_t base_line;           /**< Base line measured from the top of the line_height*/\n    uint8_t subpx  : 2;             /**< An element of `lv_font_subpx_t`*/\n\n    int8_t underline_position;      /**< Distance between the top of the underline and base line (< 0 means below the base line)*/\n    int8_t underline_thickness;     /**< Thickness of the underline*/\n\n    const void * dsc;                     /**< Store implementation specific or run_time data or caching here*/\n#if LV_USE_USER_DATA\n    void * user_data;               /**< Custom user data for font.*/\n#endif\n\n} lv_font_t", "sline": 79, "docstring": "/** Describe the properties of a font*/"}, "lv_font_get_glyph_bitmap": {"type": "Function", "def": "const uint8_t * lv_font_get_glyph_bitmap(const lv_font_t * font_p, uint32_t letter)", "sline": 91}, "lv_font_get_glyph_dsc": {"type": "Function", "def": "bool lv_font_get_glyph_dsc(const lv_font_t * font_p, lv_font_glyph_dsc_t * dsc_out, uint32_t letter,\n                           uint32_t letter_next)", "sline": 101}, "lv_font_get_glyph_width": {"type": "Function", "def": "uint16_t lv_font_get_glyph_width(const lv_font_t * font, uint32_t letter, uint32_t letter_next)", "sline": 111}, "lv_font_get_line_height": {"type": "Function", "def": "static inline lv_coord_t lv_font_get_line_height(const lv_font_t * font_p)", "sline": 118, "body": "{\n    return font_p->line_height;\n}"}, "lv_font_montserrat_12": {"type": "Variable", "def": "", "sline": 138}, "lv_font_montserrat_14": {"type": "Variable", "def": "", "sline": 142}, "lv_font_montserrat_16": {"type": "Variable", "def": "", "sline": 146}, "lv_font_default": {"type": "Function", "def": "static inline const lv_font_t * lv_font_default(void)", "sline": 246, "body": "{\n    return LV_FONT_DEFAULT;\n}"}, "carbit_updater/lvgl/src/font/lv_font.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font.h"}}, "carbit_updater/lvgl/src/font/lv_font_unscii_16.c": {"lvgl": {"type": "Variable", "def": "#include ../../lvgl.h", "sline": 10}, "carbit_updater/lvgl/src/font/lv_font_unscii_16.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/font/lv_font_unscii_16.c"}}, "carbit_updater/lvgl/src/gpu/lv_gpu_nxp_pxp.c": {"lv_conf_internal": {"type": "Variable", "def": "#include ../lv_conf_internal.h", "sline": 34}, "carbit_updater/lvgl/src/gpu/lv_gpu_nxp_pxp.c": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/gpu/lv_gpu_nxp_pxp.c"}}, "carbit_updater/lvgl/src/extra/libs/qrcode/lv_qrcode.h": {"lvgl": {"type": "Variable", "def": "#include ../../../lvgl.h", "sline": 16}, "carbit_updater/lvgl/src/extra/libs/qrcode/lv_qrcode.h": {"type": "Module", "file_path": "/home/sub4-wy/lxl/ccoder/CEval/c_repo/t113-system-prj/carbit_updater/lvgl/src/extra/libs/qrcode/lv_qrcode.h"}}}